{"input": "package kademlia;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.util.NoSuchElementException;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport kademlia.dht.GetParameter;\nimport kademlia.dht.DHT;\nimport kademlia.dht.KadContent;\nimport kademlia.dht.KademliaDHT;\nimport kademlia.dht.KademliaStorageEntry;\nimport kademlia.dht.JKademliaStorageEntry;\nimport kademlia.exceptions.ContentNotFoundException;\nimport kademlia.exceptions.RoutingException;\nimport kademlia.message.MessageFactory;\nimport kademlia.node.Node;\nimport kademlia.node.KademliaId;\nimport kademlia.operation.ConnectOperation;\nimport kademlia.operation.ContentLookupOperation;\nimport kademlia.operation.Operation;\nimport kademlia.operation.KadRefreshOperation;\nimport kademlia.operation.StoreOperation;\nimport kademlia.routing.JKademliaRoutingTable;\nimport kademlia.routing.KademliaRoutingTable;\nimport kademlia.util.serializer.JsonDHTSerializer;\nimport kademlia.util.serializer.JsonRoutingTableSerializer;\nimport kademlia.util.serializer.JsonSerializer;\n\n\n/**\n * The main Kademlia Node on the network, this node manages everything for this local system.\n *\n * @author Joshua Kissoon\n * @since 20140215\n *\n * @todo When we receive a store message - if we have a newer version of the content, re-send this newer version to that node so as to update their version\n * @todo Handle IPv6 Addresses\n *\n */\npublic class JKademliaNode implements KademliaNode\n{\n\n    /* Kademlia Attributes */\n    private final String ownerId;\n\n    /* Objects to be used */\n    private final transient Node localNode;\n    private final transient KadServer server;\n    private final transient KademliaDHT dht;", "context": "src/kademlia/operation/KadRefreshOperation.java\npublic class KadRefreshOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public KadRefreshOperation(KadServer server, KademliaNode localNode, KademliaDHT dht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public void execute() throws IOException\n    {\n        /* Run our BucketRefreshOperation to refresh buckets */\n        new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n\n        /* After buckets have been refreshed, we refresh content */\n        new ContentRefreshOperation(this.server, this.localNode, this.dht, this.config).execute();\n    }\n}\nsrc/kademlia/operation/StoreOperation.java\npublic class StoreOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final JKademliaStorageEntry storageEntry;\n    private final KademliaDHT localDht;\n    private final KadConfiguration config;\n\n    /**\n     * @param server\n     * @param localNode\n     * @param storageEntry The content to be stored on the DHT\n     * @param localDht     The local DHT\n     * @param config\n     */\n    public StoreOperation(KadServer server, KademliaNode localNode, JKademliaStorageEntry storageEntry, KademliaDHT localDht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.storageEntry = storageEntry;\n        this.localDht = localDht;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        /* Get the nodes on which we need to store the content */\n        NodeLookupOperation ndlo = new NodeLookupOperation(this.server, this.localNode, this.storageEntry.getContentMetadata().getKey(), this.config);\n        ndlo.execute();\n        List<Node> nodes = ndlo.getClosestNodes();\n\n        /* Create the message */\n        Message msg = new StoreContentMessage(this.localNode.getNode(), this.storageEntry);\n\n        /*Store the message on all of the K-Nodes*/\n        for (Node n : nodes)\n        {\n            if (n.equals(this.localNode.getNode()))\n            {\n                /* Store the content locally */\n                this.localDht.store(this.storageEntry);\n            }\n            else\n            {\n                /**\n                 * @todo Create a receiver that receives a store acknowledgement message to count how many nodes a content have been stored at\n                 */\n                this.server.sendMessage(n, msg, null);\n            }\n        }\n    }\n\n    /**\n     * @return The number of nodes that have stored this content\n     *\n     * @todo Implement this method\n     */\n    public int numNodesStoredAt()\n    {\n        return 1;\n    }\n}\nsrc/kademlia/dht/JKademliaStorageEntry.java\npublic class JKademliaStorageEntry implements KademliaStorageEntry\n{\n\n    private String content;\n    private final StorageEntryMetadata metadata;\n\n    public JKademliaStorageEntry(final KadContent content)\n    {\n        this(content, new StorageEntryMetadata(content));\n    }\n\n    public JKademliaStorageEntry(final KadContent content, final StorageEntryMetadata metadata)\n    {\n        this.setContent(content.toSerializedForm());\n        this.metadata = metadata;\n    }\n\n    @Override\n    public final void setContent(final byte[] data)\n    {\n        this.content = new String(data);\n    }\n\n    @Override\n    public final byte[] getContent()\n    {\n        return this.content.getBytes();\n    }\n\n    @Override\n    public final KademliaStorageEntryMetadata getContentMetadata()\n    {\n        return this.metadata;\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"[StorageEntry: \");\n\n        sb.append(\"[Content: \");\n        sb.append(this.getContent());\n        sb.append(\"]\");\n\n        sb.append(this.getContentMetadata());\n\n        sb.append(\"]\");\n\n        return sb.toString();\n    }\n}\nsrc/kademlia/dht/DHT.java\npublic class DHT implements KademliaDHT\n{\n\n    private transient StoredContentManager contentManager;\n    private transient KadSerializer<JKademliaStorageEntry> serializer = null;\n    private transient KadConfiguration config;\n\n    private final String ownerId;\n\n    public DHT(String ownerId, KadConfiguration config)\n    {\n        this.ownerId = ownerId;\n        this.config = config;\n        this.initialize();\n    }\n\n    @Override\n    public final void initialize()\n    {\n        contentManager = new StoredContentManager();\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration con)\n    {\n        this.config = con;\n    }\n\n    @Override\n    public KadSerializer<JKademliaStorageEntry> getSerializer()\n    {\n        if (null == serializer)\n        {\n            serializer = new JsonSerializer<>();\n        }\n\n        return serializer;\n    }\n\n    @Override\n    public boolean store(JKademliaStorageEntry content) throws IOException\n    {\n        /* Lets check if we have this content and it's the updated version */\n        if (this.contentManager.contains(content.getContentMetadata()))\n        {\n            KademliaStorageEntryMetadata current = this.contentManager.get(content.getContentMetadata());\n\n            /* update the last republished time */\n            current.updateLastRepublished();\n\n            if (current.getLastUpdatedTimestamp() >= content.getContentMetadata().getLastUpdatedTimestamp())\n            {\n                /* We have the current content, no need to update it! just leave this method now */\n                return false;\n            }\n            else\n            {\n                /* We have this content, but not the latest version, lets delete it so the new version will be added below */\n                try\n                {\n                    //System.out.println(\"Removing older content to update it\");\n                    this.remove(content.getContentMetadata());\n                }\n                catch (ContentNotFoundException ex)\n                {\n                    /* This won't ever happen at this point since we only get here if the content is found, lets ignore it  */\n                }\n            }\n        }\n\n        /**\n         * If we got here means we don't have this content, or we need to update the content\n         * If we need to update the content, the code above would've already deleted it, so we just need to re-add it\n         */\n        try\n        {\n            //System.out.println(\"Adding new content.\");\n            /* Keep track of this content in the entries manager */\n            KademliaStorageEntryMetadata sEntry = this.contentManager.put(content.getContentMetadata());\n\n            /* Now we store the content locally in a file */\n            String contentStorageFolder = this.getContentStorageFolderName(content.getContentMetadata().getKey());\n\n            try (FileOutputStream fout = new FileOutputStream(contentStorageFolder + File.separator + sEntry.hashCode() + \".kct\");\n                    DataOutputStream dout = new DataOutputStream(fout))\n            {\n                this.getSerializer().write(content, dout);\n            }\n            return true;\n        }\n        catch (ContentExistException e)\n        {\n            /**\n             * Content already exist on the DHT\n             * This won't happen because above takes care of removing the content if it's older and needs to be updated,\n             * or returning if we already have the current content version.\n             */\n            return false;\n        }\n    }\n\n    @Override\n    public boolean store(KadContent content) throws IOException\n    {\n        return this.store(new JKademliaStorageEntry(content));\n    }\n\n    @Override\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(key);\n        DataInputStream din = new DataInputStream(new FileInputStream(folder + File.separator + hashCode + \".kct\"));\n        return this.getSerializer().read(din);\n    }\n\n    @Override\n    public boolean contains(GetParameter param)\n    {\n        return this.contentManager.contains(param);\n    }\n\n    @Override\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException\n    {\n        try\n        {\n            return this.retrieve(entry.getKey(), entry.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException\n    {\n        /* Load a KadContent if any exist for the given criteria */\n        try\n        {\n            KademliaStorageEntryMetadata e = this.contentManager.get(param);\n            return this.retrieve(e.getKey(), e.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public void remove(KadContent content) throws ContentNotFoundException\n    {\n        this.remove(new StorageEntryMetadata(content));\n    }\n\n    @Override\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(entry.getKey());\n        File file = new File(folder + File.separator + entry.hashCode() + \".kct\");\n\n        contentManager.remove(entry);\n\n        if (file.exists())\n        {\n            file.delete();\n        }\n        else\n        {\n            throw new ContentNotFoundException();\n        }\n    }\n\n    /**\n     * Get the name of the folder for which a content should be stored\n     *\n     * @param key The key of the content\n     *\n     * @return String The name of the folder\n     */\n    private String getContentStorageFolderName(KademliaId key)\n    {\n        /**\n         * Each content is stored in a folder named after the first 2 characters of the NodeId\n         *\n         * The name of the file containing the content is the hash of this content\n         */\n        String folderName = key.hexRepresentation().substring(0, 2);\n        File contentStorageFolder = new File(this.config.getNodeDataFolder(ownerId) + File.separator + folderName);\n\n        /* Create the content folder if it doesn't exist */\n        if (!contentStorageFolder.isDirectory())\n        {\n            contentStorageFolder.mkdir();\n        }\n\n        return contentStorageFolder.toString();\n    }\n\n    @Override\n    public List<KademliaStorageEntryMetadata> getStorageEntries()\n    {\n        return contentManager.getAllEntries();\n    }\n\n    @Override\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries)\n    {\n        for (KademliaStorageEntryMetadata e : ientries)\n        {\n            try\n            {\n                this.contentManager.put(e);\n            }\n            catch (ContentExistException ex)\n            {\n                /* Entry already exist, no need to store it again */\n            }\n        }\n    }\n\n    @Override\n    public synchronized String toString()\n    {\n        return this.contentManager.toString();\n    }\n}\nsrc/kademlia/routing/KademliaRoutingTable.java\npublic interface KademliaRoutingTable\n{\n\n    /**\n     * Initialize the RoutingTable to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Sets the configuration file for this routing table\n     *\n     * @param config\n     */\n    public void setConfiguration(KadConfiguration config);\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    public void insert(Contact c);\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    public void insert(Node n);\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    public int getBucketId(KademliaId nid);\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    public List<Node> findClosest(KademliaId target, int numNodesRequired);\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllNodes();\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllContacts();\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    public KademliaBucket[] getBuckets();\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    public void setUnresponsiveContacts(List<Node> contacts);\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    public void setUnresponsiveContact(Node n);\n\n}\nsrc/kademlia/dht/KadContent.java\npublic interface KadContent\n{\n\n    /**\n     * @return NodeId The DHT key for this content\n     */\n    public KademliaId getKey();\n\n    /**\n     * @return String The type of content\n     */\n    public String getType();\n\n    /**\n     * Each content will have an created date\n     * This allows systems to know when to delete a content form his/her machine\n     *\n     * @return long The create date of this content\n     */\n    public long getCreatedTimestamp();\n\n    /**\n     * Each content will have an update timestamp\n     * This allows the DHT to keep only the latest version of a content\n     *\n     * @return long The timestamp of when this content was last updated\n     */\n    public long getLastUpdatedTimestamp();\n\n    /**\n     * @return The ID of the owner of this content\n     */\n    public String getOwnerId();\n\n    /**\n     * Each content needs to be in byte format for transporting and storage,\n     * this method takes care of that.\n     *\n     * Each object is responsible for transforming itself to byte format since the\n     * structure of methods may differ.\n     *\n     * @return The content in byte format\n     */\n    public byte[] toSerializedForm();\n\n    /**\n     * Given the Content in byte format, read it\n     *\n     * @param data The object in byte format\n     *\n     * @return A new object from the given\n     */\n    public KadContent fromSerializedForm(byte[] data);\n}\nsrc/kademlia/util/serializer/JsonRoutingTableSerializer.java\npublic class JsonRoutingTableSerializer implements KadSerializer<KademliaRoutingTable>\n{\n\n    private final Gson gson;\n\n    Type contactCollectionType = new TypeToken<List<Contact>>()\n    {\n    }.getType();\n\n    private final KadConfiguration config;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    /**\n     * Initialize the class\n     *\n     * @param config\n     */\n    public JsonRoutingTableSerializer(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    @Override\n    public void write(KademliaRoutingTable data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic JKademliaRoutingTable */\n            gson.toJson(data, JKademliaRoutingTable.class, writer);\n\n            /* Now Store the Contacts  */\n            gson.toJson(data.getAllContacts(), contactCollectionType, writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public KademliaRoutingTable read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic JKademliaRoutingTable */\n            KademliaRoutingTable tbl = gson.fromJson(reader, KademliaRoutingTable.class);\n            tbl.setConfiguration(config);\n            \n            /* Now get the Contacts and add them back to the JKademliaRoutingTable */\n            List<Contact> contacts = gson.fromJson(reader, contactCollectionType);\n            tbl.initialize();\n\n            for (Contact c : contacts)\n            {\n                tbl.insert(c);\n            }\n\n            reader.endArray();\n            /* Read and return the Content*/\n            return tbl;\n        }\n    }\n}\nsrc/kademlia/operation/ConnectOperation.java\npublic class ConnectOperation implements Operation, Receiver\n{\n\n    public static final int MAX_CONNECT_ATTEMPTS = 5;       // Try 5 times to connect to a node\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final Node bootstrapNode;\n    private final KadConfiguration config;\n\n    private boolean error;\n    private int attempts;\n\n    /**\n     * @param server    The message server used to send/receive messages\n     * @param local     The local node\n     * @param bootstrap Node to use to bootstrap the local node onto the network\n     * @param config\n     */\n    public ConnectOperation(KadServer server, KademliaNode local, Node bootstrap, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = local;\n        this.bootstrapNode = bootstrap;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        try\n        {\n            /* Contact the bootstrap node */\n            this.error = true;\n            this.attempts = 0;\n            Message m = new ConnectMessage(this.localNode.getNode());\n\n            /* Send a connect message to the bootstrap node */\n            server.sendMessage(this.bootstrapNode, m, this);\n\n            /* If we haven't finished as yet, wait for a maximum of config.operationTimeout() time */\n            int totalTimeWaited = 0;\n            int timeInterval = 50;     // We re-check every 300 milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (error)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            if (error)\n            {\n                /* If we still haven't received any responses by then, do a routing timeout */\n                throw new RoutingException(\"ConnectOperation: Bootstrap node did not respond: \" + bootstrapNode);\n            }\n\n            /* Perform lookup for our own ID to get nodes close to us */\n            Operation lookup = new NodeLookupOperation(this.server, this.localNode, this.localNode.getNode().getNodeId(), this.config);\n            lookup.execute();\n\n            /**\n             * Refresh buckets to get a good routing table\n             * After the above lookup operation, K nodes will be in our routing table,\n             * Now we try to populate all of our buckets.\n             */\n            new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n        }\n        catch (InterruptedException e)\n        {\n            System.err.println(\"Connect operation was interrupted. \");\n        }\n    }\n\n    /**\n     * Receives an AcknowledgeMessage from the bootstrap node.\n     *\n     * @param comm\n     */\n    @Override\n    public synchronized void receive(Message incoming, int comm)\n    {\n        /* The incoming message will be an acknowledgement message */\n        AcknowledgeMessage msg = (AcknowledgeMessage) incoming;\n\n        /* The bootstrap node has responded, insert it into our space */\n        this.localNode.getRoutingTable().insert(this.bootstrapNode);\n\n        /* We got a response, so the error is false */\n        error = false;\n\n        /* Wake up any waiting thread */\n        notify();\n    }\n\n    /**\n     * Resends a ConnectMessage to the boot strap node a maximum of MAX_ATTEMPTS\n     * times.\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        if (++this.attempts < MAX_CONNECT_ATTEMPTS)\n        {\n            this.server.sendMessage(this.bootstrapNode, new ConnectMessage(this.localNode.getNode()), this);\n        }\n        else\n        {\n            /* We just exit, so notify all other threads that are possibly waiting */\n            notify();\n        }\n    }\n}\nsrc/kademlia/dht/KademliaStorageEntry.java\npublic interface KademliaStorageEntry\n{\n\n    /**\n     * Add the content to the storage entry\n     *\n     * @param data The content data in byte[] format\n     */\n    public void setContent(final byte[] data);\n\n    /**\n     * Get the content from this storage entry\n     *\n     * @return The content in byte format\n     */\n    public byte[] getContent();\n\n    /**\n     * Get the metadata for this storage entry\n     *\n     * @return the storage entry metadata\n     */\n    public KademliaStorageEntryMetadata getContentMetadata();\n}\nsrc/kademlia/message/MessageFactory.java\npublic class MessageFactory implements KademliaMessageFactory\n{\n\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public MessageFactory(KademliaNode local, KademliaDHT dht, KadConfiguration config)\n    {\n        this.localNode = local;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public Message createMessage(byte code, DataInputStream in) throws IOException\n    {\n        switch (code)\n        {\n            case AcknowledgeMessage.CODE:\n                return new AcknowledgeMessage(in);\n            case ConnectMessage.CODE:\n                return new ConnectMessage(in);\n            case ContentMessage.CODE:\n                return new ContentMessage(in);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupMessage(in);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupMessage(in);\n            case NodeReplyMessage.CODE:\n                return new NodeReplyMessage(in);\n            case SimpleMessage.CODE:\n                return new SimpleMessage(in);\n            case StoreContentMessage.CODE:\n                return new StoreContentMessage(in);\n            default:\n                //System.out.println(this.localNode + \" - No Message handler found for message. Code: \" + code);\n                return new SimpleMessage(in);\n\n        }\n    }\n\n    @Override\n    public Receiver createReceiver(byte code, KadServer server)\n    {\n        switch (code)\n        {\n            case ConnectMessage.CODE:\n                return new ConnectReceiver(server, this.localNode);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupReceiver(server, this.localNode, this.dht, this.config);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupReceiver(server, this.localNode, this.config);\n            case StoreContentMessage.CODE:\n                return new StoreContentReceiver(server, this.localNode, this.dht);\n            default:\n                //System.out.println(\"No receiver found for message. Code: \" + code);\n                return new SimpleReceiver();\n        }\n    }\n}\nsrc/kademlia/util/serializer/JsonSerializer.java\npublic class JsonSerializer<T> implements KadSerializer<T>\n{\n\n    private final Gson gson;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    @Override\n    public void write(T data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Store the content type */\n            gson.toJson(data.getClass().getName(), String.class, writer);\n\n            /* Now Store the content */\n            gson.toJson(data, data.getClass(), writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public T read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the class name */\n            String className = gson.fromJson(reader, String.class);\n\n            /* Read and return the Content*/\n            T ret = gson.fromJson(reader, Class.forName(className));\n            \n            reader.endArray();\n            \n            return ret;\n        }\n    }\n}\nsrc/kademlia/exceptions/RoutingException.java\npublic class RoutingException extends IOException\n{\n\n    public RoutingException()\n    {\n        super();\n    }\n\n    public RoutingException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/node/KademliaId.java\npublic class KademliaId implements Streamable, Serializable\n{\n\n    public final transient static int ID_LENGTH = 160;\n    private byte[] keyBytes;\n\n    /**\n     * Construct the NodeId from some string\n     *\n     * @param data The user generated key string\n     */\n    public KademliaId(String data)\n    {\n        keyBytes = data.getBytes();\n        if (keyBytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long.\");\n        }\n    }\n\n    /**\n     * Generate a random key\n     */\n    public KademliaId()\n    {\n        keyBytes = new byte[ID_LENGTH / 8];\n        new Random().nextBytes(keyBytes);\n    }\n\n    /**\n     * Generate the NodeId from a given byte[]\n     *\n     * @param bytes\n     */\n    public KademliaId(byte[] bytes)\n    {\n        if (bytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long. Data Given: '\" + new String(bytes) + \"'\");\n        }\n        this.keyBytes = bytes;\n    }\n\n    /**\n     * Load the NodeId from a DataInput stream\n     *\n     * @param in The stream from which to load the NodeId\n     *\n     * @throws IOException\n     */\n    public KademliaId(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n    }\n\n    public byte[] getBytes()\n    {\n        return this.keyBytes;\n    }\n\n    /**\n     * @return The BigInteger representation of the key\n     */\n    public BigInteger getInt()\n    {\n        return new BigInteger(1, this.getBytes());\n    }\n\n    /**\n     * Compares a NodeId to this NodeId\n     *\n     * @param o The NodeId to compare to this NodeId\n     *\n     * @return boolean Whether the 2 NodeIds are equal\n     */\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof KademliaId)\n        {\n            KademliaId nid = (KademliaId) o;\n            return this.hashCode() == nid.hashCode();\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int hash = 7;\n        hash = 83 * hash + Arrays.hashCode(this.keyBytes);\n        return hash;\n    }\n\n    /**\n     * Checks the distance between this and another NodeId\n     *\n     * @param nid\n     *\n     * @return The distance of this NodeId from the given NodeId\n     */\n    public KademliaId xor(KademliaId nid)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n        byte[] nidBytes = nid.getBytes();\n\n        for (int i = 0; i < ID_LENGTH / 8; i++)\n        {\n            result[i] = (byte) (this.keyBytes[i] ^ nidBytes[i]);\n        }\n\n        KademliaId resNid = new KademliaId(result);\n\n        return resNid;\n    }\n\n    /**\n     * Generates a NodeId that is some distance away from this NodeId\n     *\n     * @param distance in number of bits\n     *\n     * @return NodeId The newly generated NodeId\n     */\n    public KademliaId generateNodeIdByDistance(int distance)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n\n        /* Since distance = ID_LENGTH - prefixLength, we need to fill that amount with 0's */\n        int numByteZeroes = (ID_LENGTH - distance) / 8;\n        int numBitZeroes = 8 - (distance % 8);\n\n        /* Filling byte zeroes */\n        for (int i = 0; i < numByteZeroes; i++)\n        {\n            result[i] = 0;\n        }\n\n        /* Filling bit zeroes */\n        BitSet bits = new BitSet(8);\n        bits.set(0, 8);\n\n        for (int i = 0; i < numBitZeroes; i++)\n        {\n            /* Shift 1 zero into the start of the value */\n            bits.clear(i);\n        }\n        bits.flip(0, 8);        // Flip the bits since they're in reverse order\n        result[numByteZeroes] = (byte) bits.toByteArray()[0];\n\n        /* Set the remaining bytes to Maximum value */\n        for (int i = numByteZeroes + 1; i < result.length; i++)\n        {\n            result[i] = Byte.MAX_VALUE;\n        }\n\n        return this.xor(new KademliaId(result));\n    }\n\n    /**\n     * Counts the number of leading 0's in this NodeId\n     *\n     * @return Integer The number of leading 0's\n     */\n    public int getFirstSetBitIndex()\n    {\n        int prefixLength = 0;\n\n        for (byte b : this.keyBytes)\n        {\n            if (b == 0)\n            {\n                prefixLength += 8;\n            }\n            else\n            {\n                /* If the byte is not 0, we need to count how many MSBs are 0 */\n                int count = 0;\n                for (int i = 7; i >= 0; i--)\n                {\n                    boolean a = (b & (1 << i)) == 0;\n                    if (a)\n                    {\n                        count++;\n                    }\n                    else\n                    {\n                        break;   // Reset the count if we encounter a non-zero number\n                    }\n                }\n\n                /* Add the count of MSB 0s to the prefix length */\n                prefixLength += count;\n\n                /* Break here since we've now covered the MSB 0s */\n                break;\n            }\n        }\n        return prefixLength;\n    }\n\n    /**\n     * Gets the distance from this NodeId to another NodeId\n     *\n     * @param to\n     *\n     * @return Integer The distance\n     */\n    public int getDistance(KademliaId to)\n    {\n        /**\n         * Compute the xor of this and to\n         * Get the index i of the first set bit of the xor returned NodeId\n         * The distance between them is ID_LENGTH - i\n         */\n        return ID_LENGTH - this.xor(to).getFirstSetBitIndex();\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        out.write(this.getBytes());\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        byte[] input = new byte[ID_LENGTH / 8];\n        in.readFully(input);\n        this.keyBytes = input;\n    }\n\n    public String hexRepresentation()\n    {\n        /* Returns the hex format of this NodeId */\n        BigInteger bi = new BigInteger(1, this.keyBytes);\n        return String.format(\"%0\" + (this.keyBytes.length << 1) + \"X\", bi);\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.hexRepresentation();\n    }\n\n}\nsrc/kademlia/dht/KademliaDHT.java\npublic interface KademliaDHT\n{\n\n    /**\n     * Initialize this DHT to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Set a new configuration. Mainly used when we restore the DHT state from a file\n     *\n     * @param con The new configuration file\n     */\n    public void setConfiguration(KadConfiguration con);\n\n    /**\n     * Creates a new Serializer or returns an existing serializer\n     *\n     * @return The new ContentSerializer\n     */\n    public KadSerializer<JKademliaStorageEntry> getSerializer();\n\n    /**\n     * Handle storing content locally\n     *\n     * @param content The DHT content to store\n     *\n     * @return boolean true if we stored the content, false if the content already exists and is up to date\n     *\n     * @throws java.io.IOException\n     */\n    public boolean store(JKademliaStorageEntry content) throws IOException;\n\n    public boolean store(KadContent content) throws IOException;\n\n    /**\n     * Retrieves a Content from local storage\n     *\n     * @param key      The Key of the content to retrieve\n     * @param hashCode The hash code of the content to retrieve\n     *\n     * @return A KadContent object\n     *\n     * @throws java.io.FileNotFoundException\n     * @throws java.lang.ClassNotFoundException\n     */\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException;\n\n    /**\n     * Check if any content for the given criteria exists in this DHT\n     *\n     * @param param The content search criteria\n     *\n     * @return boolean Whether any content exist that satisfy the criteria\n     */\n    public boolean contains(GetParameter param);\n\n    /**\n     * Retrieve and create a KadContent object given the StorageEntry object\n     *\n     * @param entry The StorageEntry used to retrieve this content\n     *\n     * @return KadContent The content object\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException;\n\n    /**\n     * Get the StorageEntry for the content if any exist.\n     *\n     * @param param The parameters used to filter the content needed\n     *\n     * @return KadContent A KadContent found on the DHT satisfying the given criteria\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException;\n\n    /**\n     * Delete a content from local storage\n     *\n     * @param content The Content to Remove\n     *\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public void remove(KadContent content) throws ContentNotFoundException;\n\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException;\n\n    /**\n     * @return A List of all StorageEntries for this node\n     */\n    public List<KademliaStorageEntryMetadata> getStorageEntries();\n\n    /**\n     * Used to add a list of storage entries for existing content to the DHT.\n     * Mainly used when retrieving StorageEntries from a saved state file.\n     *\n     * @param ientries The entries to add\n     */\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries);\n\n}\nsrc/kademlia/operation/Operation.java\npublic interface Operation\n{\n\n    /**\n     * Starts an operation and returns when the operation is finished\n     *\n     * @throws kademlia.exceptions.RoutingException\n     */\n    public void execute() throws IOException, RoutingException;\n}\nsrc/kademlia/routing/JKademliaRoutingTable.java\npublic class JKademliaRoutingTable implements KademliaRoutingTable\n{\n\n    private final Node localNode;  // The current node\n    private transient KademliaBucket[] buckets;\n\n    private transient KadConfiguration config;\n\n    public JKademliaRoutingTable(Node localNode, KadConfiguration config)\n    {\n        this.localNode = localNode;\n        this.config = config;\n\n        /* Initialize all of the buckets to a specific depth */\n        this.initialize();\n\n        /* Insert the local node */\n        this.insert(localNode);\n    }\n\n    /**\n     * Initialize the JKademliaRoutingTable to it's default state\n     */\n    @Override\n    public final void initialize()\n    {\n        this.buckets = new KademliaBucket[KademliaId.ID_LENGTH];\n        for (int i = 0; i < KademliaId.ID_LENGTH; i++)\n        {\n            buckets[i] = new JKademliaBucket(i, this.config);\n        }\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    @Override\n    public synchronized final void insert(Contact c)\n    {\n        this.buckets[this.getBucketId(c.getNode().getNodeId())].insert(c);\n    }\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    @Override\n    public synchronized final void insert(Node n)\n    {\n        this.buckets[this.getBucketId(n.getNodeId())].insert(n);\n    }\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    @Override\n    public final int getBucketId(KademliaId nid)\n    {\n        int bId = this.localNode.getNodeId().getDistance(nid) - 1;\n\n        /* If we are trying to insert a node into it's own routing table, then the bucket ID will be -1, so let's just keep it in bucket 0 */\n        return bId < 0 ? 0 : bId;\n    }\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    @Override\n    public synchronized final List<Node> findClosest(KademliaId target, int numNodesRequired)\n    {\n        TreeSet<Node> sortedSet = new TreeSet<>(new KeyComparator(target));\n        sortedSet.addAll(this.getAllNodes());\n\n        List<Node> closest = new ArrayList<>(numNodesRequired);\n\n        /* Now we have the sorted set, lets get the top numRequired */\n        int count = 0;\n        for (Node n : sortedSet)\n        {\n            closest.add(n);\n            if (++count == numNodesRequired)\n            {\n                break;\n            }\n        }\n        return closest;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public synchronized final List<Node> getAllNodes()\n    {\n        List<Node> nodes = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            for (Contact c : b.getContacts())\n            {\n                nodes.add(c.getNode());\n            }\n        }\n\n        return nodes;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public final List<Contact> getAllContacts()\n    {\n        List<Contact> contacts = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            contacts.addAll(b.getContacts());\n        }\n\n        return contacts;\n    }\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    @Override\n    public final KademliaBucket[] getBuckets()\n    {\n        return this.buckets;\n    }\n\n    /**\n     * Set the KadBuckets of this routing table, mainly used when retrieving saved state\n     *\n     * @param buckets\n     */\n    public final void setBuckets(KademliaBucket[] buckets)\n    {\n        this.buckets = buckets;\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    @Override\n    public void setUnresponsiveContacts(List<Node> contacts)\n    {\n        if (contacts.isEmpty())\n        {\n            return;\n        }\n        for (Node n : contacts)\n        {\n            this.setUnresponsiveContact(n);\n        }\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    @Override\n    public synchronized void setUnresponsiveContact(Node n)\n    {\n        int bucketId = this.getBucketId(n.getNodeId());\n\n        /* Remove the contact from the bucket */\n        this.buckets[bucketId].removeNode(n);\n    }\n\n    @Override\n    public synchronized final String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"\\nPrinting Routing Table Started ***************** \\n\");\n        int totalContacts = 0;\n        for (KademliaBucket b : this.buckets)\n        {\n            if (b.numContacts() > 0)\n            {\n                totalContacts += b.numContacts();\n                sb.append(\"# nodes in Bucket with depth \");\n                sb.append(b.getDepth());\n                sb.append(\": \");\n                sb.append(b.numContacts());\n                sb.append(\"\\n\");\n                sb.append(b.toString());\n                sb.append(\"\\n\");\n            }\n        }\n\n        sb.append(\"\\nTotal Contacts: \");\n        sb.append(totalContacts);\n        sb.append(\"\\n\\n\");\n\n        sb.append(\"Printing Routing Table Ended ******************** \");\n\n        return sb.toString();\n    }\n\n}\nsrc/kademlia/util/serializer/JsonDHTSerializer.java\npublic class JsonDHTSerializer implements KadSerializer<KademliaDHT>\n{\n\n    private final Gson gson;\n    private final Type storageEntriesCollectionType;\n\n    \n    {\n        gson = new Gson();\n\n        storageEntriesCollectionType = new TypeToken<List<KademliaStorageEntryMetadata>>()\n        {\n        }.getType();\n    }\n\n    @Override\n    public void write(KademliaDHT data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic DHT */\n            gson.toJson(data, DHT.class, writer);\n\n            /* Now Store the Entries  */\n            gson.toJson(data.getStorageEntries(), this.storageEntriesCollectionType, writer);\n\n            writer.endArray();\n        }\n\n    }\n\n    @Override\n    public KademliaDHT read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic DHT */\n            DHT dht = gson.fromJson(reader, DHT.class);\n            dht.initialize();\n\n            /* Now get the entries and add them back to the DHT */\n            List<KademliaStorageEntryMetadata> entries = gson.fromJson(reader, this.storageEntriesCollectionType);\n            dht.putStorageEntries(entries);\n\n            reader.endArray();\n            return dht;\n        }\n    }\n}\nsrc/kademlia/exceptions/ContentNotFoundException.java\npublic class ContentNotFoundException extends Exception\n{\n\n    public ContentNotFoundException()\n    {\n        super();\n    }\n\n    public ContentNotFoundException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/dht/GetParameter.java\npublic class GetParameter\n{\n\n    private KademliaId key;\n    private String ownerId = null;\n    private String type = null;\n\n    /**\n     * Construct a GetParameter to search for data by NodeId and owner\n     *\n     * @param key\n     * @param type\n     */\n    public GetParameter(KademliaId key, String type)\n    {\n        this.key = key;\n        this.type = type;\n    }\n\n    /**\n     * Construct a GetParameter to search for data by NodeId, owner, type\n     *\n     * @param key\n     * @param type\n     * @param owner\n     */\n    public GetParameter(KademliaId key, String type, String owner)\n    {\n        this(key, type);\n        this.ownerId = owner;\n    }\n\n    /**\n     * Construct our get parameter from a Content\n     *\n     * @param c\n     */\n    public GetParameter(KadContent c)\n    {\n        this.key = c.getKey();\n\n        if (c.getType() != null)\n        {\n            this.type = c.getType();\n        }\n\n        if (c.getOwnerId() != null)\n        {\n            this.ownerId = c.getOwnerId();\n        }\n    }\n\n    /**\n     * Construct our get parameter from a StorageEntryMeta data\n     *\n     * @param md\n     */\n    public GetParameter(KademliaStorageEntryMetadata md)\n    {\n        this.key = md.getKey();\n\n        if (md.getType() != null)\n        {\n            this.type = md.getType();\n        }\n\n        if (md.getOwnerId() != null)\n        {\n            this.ownerId = md.getOwnerId();\n        }\n    }\n\n    public KademliaId getKey()\n    {\n        return this.key;\n    }\n\n    public void setOwnerId(String ownerId)\n    {\n        this.ownerId = ownerId;\n    }\n\n    public String getOwnerId()\n    {\n        return this.ownerId;\n    }\n\n    public void setType(String type)\n    {\n        this.type = type;\n    }\n\n    public String getType()\n    {\n        return this.type;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"GetParameter - [Key: \" + key + \"][Owner: \" + this.ownerId + \"][Type: \" + this.type + \"]\";\n    }\n}\nsrc/kademlia/operation/ContentLookupOperation.java\npublic class ContentLookupOperation implements Operation, Receiver\n{\n\n    /* Constants */\n    private static final Byte UNASKED = (byte) 0x00;\n    private static final Byte AWAITING = (byte) 0x01;\n    private static final Byte ASKED = (byte) 0x02;\n    private static final Byte FAILED = (byte) 0x03;\n\n    private final KadServer server;\n    private final JKademliaNode localNode;\n    private JKademliaStorageEntry contentFound = null;\n    private final KadConfiguration config;\n\n    private final ContentLookupMessage lookupMessage;\n\n    private boolean isContentFound;\n    private final SortedMap<Node, Byte> nodes;\n\n    /* Tracks messages in transit and awaiting reply */\n    private final Map<Integer, Node> messagesTransiting;\n\n    /* Used to sort nodes */\n    private final Comparator comparator;\n\n    /* Statistical information */\n    private final RouteLengthChecker routeLengthChecker;\n\n    \n    {\n        messagesTransiting = new HashMap<>();\n        isContentFound = false;\n        routeLengthChecker = new RouteLengthChecker();\n    }\n\n    /**\n     * @param server\n     * @param localNode\n     * @param params    The parameters to search for the content which we need to find\n     * @param config\n     */\n    public ContentLookupOperation(KadServer server, JKademliaNode localNode, GetParameter params, KadConfiguration config)\n    {\n        /* Construct our lookup message */\n        this.lookupMessage = new ContentLookupMessage(localNode.getNode(), params);\n\n        this.server = server;\n        this.localNode = localNode;\n        this.config = config;\n\n        /**\n         * We initialize a TreeMap to store nodes.\n         * This map will be sorted by which nodes are closest to the lookupId\n         */\n        this.comparator = new KeyComparator(params.getKey());\n        this.nodes = new TreeMap(this.comparator);\n    }\n\n    /**\n     * @throws java.io.IOException\n     * @throws kademlia.exceptions.RoutingException\n     */\n    @Override\n    public synchronized void execute() throws IOException, RoutingException\n    {\n        try\n        {\n            /* Set the local node as already asked */\n            nodes.put(this.localNode.getNode(), ASKED);\n\n            /**\n             * We add all nodes here instead of the K-Closest because there may be the case that the K-Closest are offline\n             * - The operation takes care of looking at the K-Closest.\n             */\n            List<Node> allNodes = this.localNode.getRoutingTable().getAllNodes();\n            this.addNodes(allNodes);\n            \n            /* Also add the initial set of nodes to the routeLengthChecker */\n            this.routeLengthChecker.addInitialNodes(allNodes);\n\n            /**\n             * If we haven't found the requested amount of content as yet,\n             * keey trying until config.operationTimeout() time has expired\n             */\n            int totalTimeWaited = 0;\n            int timeInterval = 10;     // We re-check every n milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (!this.askNodesorFinish() && !isContentFound)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        catch (InterruptedException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Add nodes from this list to the set of nodes to lookup\n     *\n     * @param list The list from which to add nodes\n     */\n    public void addNodes(List<Node> list)\n    {\n        for (Node o : list)\n        {\n            /* If this node is not in the list, add the node */\n            if (!nodes.containsKey(o))\n            {\n                nodes.put(o, UNASKED);\n            }\n        }\n    }\n\n    /**\n     * Asks some of the K closest nodes seen but not yet queried.\n     * Assures that no more than DefaultConfiguration.CONCURRENCY messages are in transit at a time\n     *\n     * This method should be called every time a reply is received or a timeout occurs.\n     *\n     * If all K closest nodes have been asked and there are no messages in transit,\n     * the algorithm is finished.\n     *\n     * @return <code>true</code> if finished OR <code>false</code> otherwise\n     */\n    private boolean askNodesorFinish() throws IOException\n    {\n        /* If >= CONCURRENCY nodes are in transit, don't do anything */\n        if (this.config.maxConcurrentMessagesTransiting() <= this.messagesTransiting.size())\n        {\n            return false;\n        }\n\n        /* Get unqueried nodes among the K closest seen that have not FAILED */\n        List<Node> unasked = this.closestNodesNotFailed(UNASKED);\n\n        if (unasked.isEmpty() && this.messagesTransiting.isEmpty())\n        {\n            /* We have no unasked nodes nor any messages in transit, we're finished! */\n            return true;\n        }\n\n        /* Sort nodes according to criteria */\n        Collections.sort(unasked, this.comparator);\n\n        /**\n         * Send messages to nodes in the list;\n         * making sure than no more than CONCURRENCY messsages are in transit\n         */\n        for (int i = 0; (this.messagesTransiting.size() < this.config.maxConcurrentMessagesTransiting()) && (i < unasked.size()); i++)\n        {\n            Node n = (Node) unasked.get(i);\n\n            int comm = server.sendMessage(n, lookupMessage, this);\n\n            this.nodes.put(n, AWAITING);\n            this.messagesTransiting.put(comm, n);\n        }\n\n        /* We're not finished as yet, return false */\n        return false;\n    }\n\n    /**\n     * Find The K closest nodes to the target lookupId given that have not FAILED.\n     * From those K, get those that have the specified status\n     *\n     * @param status The status of the nodes to return\n     *\n     * @return A List of the closest nodes\n     */\n    private List<Node> closestNodesNotFailed(Byte status)\n    {\n        List<Node> closestNodes = new ArrayList<>(this.config.k());\n        int remainingSpaces = this.config.k();\n\n        for (Map.Entry e : this.nodes.entrySet())\n        {\n            if (!FAILED.equals(e.getValue()))\n            {\n                if (status.equals(e.getValue()))\n                {\n                    /* We got one with the required status, now add it */\n                    closestNodes.add((Node) e.getKey());\n                }\n\n                if (--remainingSpaces == 0)\n                {\n                    break;\n                }\n            }\n        }\n\n        return closestNodes;\n    }\n\n    @Override\n    public synchronized void receive(Message incoming, int comm) throws IOException, RoutingException\n    {\n        if (this.isContentFound)\n        {\n            return;\n        }\n\n        if (incoming instanceof ContentMessage)\n        {\n            /* The reply received is a content message with the required content, take it in */\n            ContentMessage msg = (ContentMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            this.localNode.getRoutingTable().insert(msg.getOrigin());\n\n            /* Get the Content and check if it satisfies the required parameters */\n            JKademliaStorageEntry content = msg.getContent();\n            this.contentFound = content;\n            this.isContentFound = true;\n        }\n        else\n        {\n            /* The reply received is a NodeReplyMessage with nodes closest to the content needed */\n            NodeReplyMessage msg = (NodeReplyMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            Node origin = msg.getOrigin();\n            this.localNode.getRoutingTable().insert(origin);\n\n            /* Set that we've completed ASKing the origin node */\n            this.nodes.put(origin, ASKED);\n\n            /* Remove this msg from messagesTransiting since it's completed now */\n            this.messagesTransiting.remove(comm);\n            \n            /* Add the received nodes to the routeLengthChecker */\n            this.routeLengthChecker.addNodes(msg.getNodes(), origin);\n\n            /* Add the received nodes to our nodes list to query */\n            this.addNodes(msg.getNodes());\n            this.askNodesorFinish();\n        }\n    }\n\n    /**\n     * A node does not respond or a packet was lost, we set this node as failed\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        /* Get the node associated with this communication */\n        Node n = this.messagesTransiting.get(new Integer(comm));\n\n        if (n == null)\n        {\n            throw new UnknownMessageException(\"Unknown comm: \" + comm);\n        }\n\n        /* Mark this node as failed and inform the routing table that it's unresponsive */\n        this.nodes.put(n, FAILED);\n        this.localNode.getRoutingTable().setUnresponsiveContact(n);\n        this.messagesTransiting.remove(comm);\n\n        this.askNodesorFinish();\n    }\n    \n    /**\n     * @return Whether the content was found or not.\n     */\n    public boolean isContentFound()\n    {\n        return this.isContentFound;\n    }\n\n    /**\n     * @return The list of all content found during the lookup operation\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public JKademliaStorageEntry getContentFound() throws ContentNotFoundException\n    {\n        if (this.isContentFound)\n        {\n            return this.contentFound;\n        }\n        else\n        {\n            throw new ContentNotFoundException(\"No Value was found for the given key.\");\n        }\n    }\n\n    /**\n     * @return How many hops it took in order to get to the content.\n     */\n    public int routeLength()\n    {\n        return this.routeLengthChecker.getRouteLength();\n    }\n}\nsrc/kademlia/node/Node.java\npublic class Node implements Streamable, Serializable\n{\n\n    private KademliaId nodeId;\n    private InetAddress inetAddress;\n    private int port;\n    private final String strRep;\n\n    public Node(KademliaId nid, InetAddress ip, int port)\n    {\n        this.nodeId = nid;\n        this.inetAddress = ip;\n        this.port = port;\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Load the Node's data from a DataInput stream\n     *\n     * @param in\n     *\n     * @throws IOException\n     */\n    public Node(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Set the InetAddress of this node\n     *\n     * @param addr The new InetAddress of this node\n     */\n    public void setInetAddress(InetAddress addr)\n    {\n        this.inetAddress = addr;\n    }\n\n    /**\n     * @return The NodeId object of this node\n     */\n    public KademliaId getNodeId()\n    {\n        return this.nodeId;\n    }\n\n    /**\n     * Creates a SocketAddress for this node\n     *\n     * @return\n     */\n    public InetSocketAddress getSocketAddress()\n    {\n        return new InetSocketAddress(this.inetAddress, this.port);\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        this.nodeId.toStream(out);\n\n        /* Add the Node's IP address to the stream */\n        byte[] a = inetAddress.getAddress();\n        if (a.length != 4)\n        {\n            throw new RuntimeException(\"Expected InetAddress of 4 bytes, got \" + a.length);\n        }\n        out.write(a);\n\n        /* Add the port to the stream */\n        out.writeInt(port);\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        /* Load the NodeId */\n        this.nodeId = new KademliaId(in);\n\n        /* Load the IP Address */\n        byte[] ip = new byte[4];\n        in.readFully(ip);\n        this.inetAddress = InetAddress.getByAddress(ip);\n\n        /* Read in the port */\n        this.port = in.readInt();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof Node)\n        {\n            Node n = (Node) o;\n            if (n == this)\n            {\n                return true;\n            }\n            return this.getNodeId().equals(n.getNodeId());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.getNodeId().hashCode();\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.getNodeId().toString();\n    }\n}\n", "answers": ["    private transient KademliaRoutingTable routingTable;"], "length": 6425, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "03b9c503110e4dc8f2d7690f56be9e9b2733744da1a855ff"}
{"input": "import android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;\n    private ImmersiveTouchNavigation mImmersiveTouchNavigation;\n\n    public EffectManager(Activity activity, int parameterListViewId, SpectaculumView glView) {\n        mActivity = activity;\n        mParameterListView = (ViewGroup) activity.findViewById(parameterListViewId);\n        mSpectaculumView = glView;\n        mEffects = new ArrayList<>();\n        mSpectaculumView.setEffectEventListener(this);\n\n        // Spectaculum-Core filters", "context": "Spectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\n", "answers": ["        mEffects.add(new NoEffect());"], "length": 8194, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "cb75af27199120a4d11be40c2968da895ebd2e8795dfc692"}
{"input": "import doctest\nimport unittest\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\nfrom arxpy.bitvector.core import Variable, Constant\nfrom arxpy.bitvector.operation import RotateLeft, RotateRight\nfrom arxpy.primitives.primitives import BvFunction, KeySchedule, Encryption, Cipher\nfrom arxpy.differential.difference import XorDiff, RXDiff\nfrom arxpy.differential import characteristic\nfrom arxpy.differential.characteristic import BvCharacteristic, SingleKeyCh, RelatedKeyCh\n\"\"\"Tests for the Characteristic module.\"\"\"\n\n\n\n\n\n\nVERBOSE = False\n\n\n# 1st cipher: linear key schedule and encryption with modular addition (no ctes)\n\nclass MyFunction(BvFunction):  # noqa: D101\n    input_widths = [8, 8]\n    output_widths = [8]\n    rounds = 1\n\n    @classmethod\n    def eval(cls, x, y):\n        x = RotateLeft(x ^ Constant(1, 8), 1)\n        y = ~y\n        return tuple([x + y])\n\n\nclass KeySchedule1(KeySchedule):  # noqa: D101\n    input_widths = [8]\n    output_widths = [8, 8]\n\n    @classmethod\n    def eval(cls, mk):\n        return tuple([mk, mk ^ Constant(1, 8)])\n\n\n", "context": "arxpy/differential/characteristic.py\nclass RelatedKeyCh(object):\n    \"\"\"Represent related-key characteristics of block ciphers.\n\n    A related-key characteristic of a `Cipher` is a pair `BvCharacteristic`,\n    one over the `KeySchedule` of the cipher, and another one over the\n    the `Encryption` function of the cipher, where the output differences\n    of the key schedule characteristic are used as round key differences\n    in the encryption characteristic.\n\n    The master key differences start with the prefix ``\"dmk\"``,\n    the round key differences start with the prefix ``\"dk\"``,\n    the plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import RelatedKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives.lea import LeaCipher\n        >>> issubclass(LeaCipher, Cipher)\n        True\n        >>> LeaCipher.set_rounds(1)\n        >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n        >>> rkch .key_schedule_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dmk0, dmk1, dmk2, dmk3),\n        'output_vars': (dk1, dk3, dk5, dk3, dk7, dk3),\n        'assignments': ((dk0, 0xc3efe9db + dmk0), (dk1, dk0 <<< 1), (dk2, 0x87dfd3b7 + dmk1), (dk3, dk2 <<< 3),\n        (dk4, 0x0fbfa76f + dmk2), (dk5, dk4 <<< 6), (dk6, 0x1f7f4ede + dmk3), (dk7, dk6 <<< 11))}\n        >>> rkch.key_schedule_ch.input_diff\n        (XorDiff(dmk0), XorDiff(dmk1), XorDiff(dmk2), XorDiff(dmk3))\n        >>> rkch.key_schedule_ch.output_diff  # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dk1), XorDiff(dk0 <<< 1)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk5), XorDiff(dk4 <<< 6)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk7), XorDiff(dk6 <<< 11)], [XorDiff(dk3), XorDiff(dk2 <<< 3)]]\n        >>> rkch.key_schedule_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dk0), XDCA_0xc3efe9db(XorDiff(dmk0))),\n        (XorDiff(dk2), XDCA_0x87dfd3b7(XorDiff(dmk1))),\n        (XorDiff(dk4), XDCA_0x0fbfa76f(XorDiff(dmk2))),\n        (XorDiff(dk6), XDCA_0x1f7f4ede(XorDiff(dmk3)))])\n        >>> rkch.encryption_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1, dp2, dp3),\n        'output_vars': (dx3, dx7, dx11, dp0),\n        'assignments': ((dx0, dk1 ^ dp0), (dx1, dk3 ^ dp1), (dx2, dx0 + dx1), (dx3, dx2 <<< 9),\n        (dx4, dk5 ^ dp1), (dx5, dk3 ^ dp2), (dx6, dx4 + dx5), (dx7, dx6 >>> 5), (dx8, dk7 ^ dp2),\n        (dx9, dk3 ^ dp3), (dx10, dx8 + dx9), (dx11, dx10 >>> 3))}\n        >>> rkch.encryption_ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1), XorDiff(dp2), XorDiff(dp3))\n        >>> rkch.encryption_ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dx3), XorDiff(dx2 <<< 9)], [XorDiff(dx7), XorDiff(dx6 >>> 5)],\n        [XorDiff(dx11), XorDiff(dx10 >>> 3)], [XorDiff(dp0), XorDiff(dp0)]]\n        >>> rkch.encryption_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dx2), XDA(XorDiff(dp0 ^ (dk0 <<< 1)), XorDiff(dp1 ^ (dk2 <<< 3)))),\n        (XorDiff(dx6), XDA(XorDiff(dp1 ^ (dk4 <<< 6)), XorDiff(dp2 ^ (dk2 <<< 3)))),\n        (XorDiff(dx10), XDA(XorDiff(dp2 ^ (dk6 <<< 11)), XorDiff(dp3 ^ (dk2 <<< 3))))])\n\n    Attributes:\n        key_schedule_ch: the `BvCharacteristic` over the key schedule\n        encryption_ch: the `BvCharacteristic` over the encryption function\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        func = bv_cipher.key_schedule\n        prefix = \"dk\"\n        input_diff_names = tuple([\"dmk\" + str(i) for i in range(len(func.input_widths))])\n        ks_ch = BvCharacteristic(func, diff_type, input_diff_names, prefix)\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = ks_ch.ssa[\"output_vars\"]\n\n        func = Encryption\n        prefix = \"dx\"\n        input_diff_names = [\"dp\" + str(i) for i in range(len(func.input_widths))]\n        round_key_diff = {}\n        for var, diff in ks_ch.output_diff:\n            round_key_diff[var.val] = diff\n        encryption_ch = BvCharacteristic(func, diff_type, input_diff_names,\n                                         prefix, round_key_diff)\n\n        self.diff_type = diff_type\n        self.key_schedule_ch = ks_ch\n        self.encryption_ch = encryption_ch\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n        \"\"\"Return the empirical weight of a given differential for multiple keys.\n\n        This method returns the differential probability weight for the\n        key schedule characteristic (see `BvCharacteristic.empirical_weight`)\n        and the `collections.Counter` storing the distribution of weights for the encryption\n        characteristic (see `SingleKeyCh.empirical_weight`).\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> kid, kod = [zero]*4, [zero]*6\n            >>> eid, eod = [zero]*4, [zero]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (0.0, Counter({0.0: 10}))\n            >>> kid, kod = [zero]*4, [one]*6\n            >>> eid, eod = [zero]*4, [one]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (inf, Counter({inf: 10}))\n\n        \"\"\"\n        key_weight = self.key_schedule_ch.empirical_weight(key_input_diff, key_output_diff, key_samples)\n        # noinspection PyProtectedMember\n        enc_counter = self.encryption_ch._empirical_weight_distribution(self._cipher,\n                                                                        enc_input_diff, enc_output_diff, enc_samples,\n                                                                        key_samples, precision, key_output_diff)\n        return key_weight, enc_counter\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the related-key characteristic.\n\n        The signature of a related-key characteristic is the\n        concatenation of the key schedule and encryption signatures.\n\n        See also `BvCharacteristic.signature`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh, ChSignatureType\n            >>> from arxpy.primitives.primitives import Cipher\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> rkch.signature(ChSignatureType.Full)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk0, dk2, dk4, dk6, dp0, dp1, dp2, dp3, dx2, dx6, dx10]\n            >>> rkch.signature(ChSignatureType.InputOutput)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk1, dk3, dk5, dk3, dk7, dk3, dp0, dp1, dp2, dp3, dx3, dx7, dx11]\n\n        \"\"\"\n        return self.key_schedule_ch.signature(ch_signature_type) + self.encryption_ch.signature(ch_signature_type)\n\n    def _to_dict(self):\n        dict_ch = {\n            \"key_schedule_ch\": self.key_schedule_ch._to_dict(),\n            \"encryption_ch\": self.encryption_ch._to_dict(),\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/bitvector/operation.py\nclass RotateLeft(Operation):\n    \"\"\"Circular left rotation operation.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateLeft\n        >>> RotateLeft(Constant(150, 8), 2)\n        0x5a\n        >>> RotateLeft(Variable(\"x\", 8), 2)\n        x <<< 2\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \"<<<\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Left cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val << r) & mask) | ((val & mask) >> (width - r))\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/bitvector/operation.py\nclass RotateRight(Operation):\n    \"\"\"Circular right rotation operation.\n\n    It provides Automatic Constant Conversion. See `Operation` for more\n    information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateRight\n        >>> RotateRight(Constant(150, 8), 3)\n        0xd2\n        >>> RotateRight(Variable(\"x\", 8), 3)\n        x >>> 3\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \">>>\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Right cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val & mask) >> r) | (val << (width - r) & mask)\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/differential/difference.py\nclass XorDiff(Difference):\n    \"\"\"Represent XOR differences.\n\n    The XOR difference of two `Term` is given by the XOR\n    of the terms. In other words, the *difference operation*\n    of `XorDiff` is the `BvXor` (see `Difference`).\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b010, 3), Constant(0b101, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b111)\n        >>> alpha.get_pair_element(x)\n        0b101\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = XorDiff.from_pair(k, k)\n        >>> alpha\n        XorDiff(0x00)\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = operation.BvXor\n    inv_diff_op = operation.BvXor\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft, BvSub\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import XorDiff\n            >>> d1, d2 = XorDiff(Variable(\"d1\", 8)), XorDiff(Variable(\"d2\", 8))\n            >>> XorDiff.derivative(BvXor, [d1, d2])\n            XorDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(Xor1, d1)\n            XorDiff(d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> XorDiff.derivative(Rotate1, d1)\n            XorDiff(d1 <<< 1)\n            >>> XorDiff.derivative(BvAdd, [d1, d2])\n            XDA(XorDiff(d1), XorDiff(d2))\n            >>> XorDiff.derivative(BvSub, [d1, d2])\n            XDS(XorDiff(d1), XorDiff(d2))\n            >>> CteAdd1 = make_partial_operation(BvAdd, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(CteAdd1, d1)\n            XDCA_0x01(XorDiff(d1))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.Concat:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.XDA(input_diff)\n\n        if op == operation.BvSub:\n            from arxpy.differential import derivative\n            return derivative.XDS(input_diff)\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAnd:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                if isinstance(val, core.Constant):\n                    return cls(op.base_op(d1.val, val))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op in [operation.BvShl, operation.BvLshr]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Extract:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None and op.fixed_args[2] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1], op.fixed_args[2]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Concat:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                if op.fixed_args[0] is not None:\n                    val = op.fixed_args[0]\n                    input_diff = [cls.from_pair(val, val), d1]\n                else:\n                    val = op.fixed_args[1]\n                    input_diff = [d1, cls.from_pair(val, val)]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAdd:\n                assert len(input_diff) == 1\n                d = input_diff[0]\n                cte = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                from arxpy.differential import derivative\n                return derivative.XDCA(d, cte)\n            else:\n                raise ValueError(msg)\n\n        if hasattr(op, \"xor_derivative\"):\n            return op.xor_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/bitvector/core.py\nclass Constant(basic.Atom, Term):\n    \"\"\"Represent bit-vector constants.\n\n    Bit-vector constants are interpreted as unsigned integers in base 2,\n    that is, a bit-vector :math:`(x_{n-1}, \\dots, x_1, x_0)` represents\n    the non-negative integer :math:`x_0 + 2 x_1 + \\dots + 2^{n-1} x_{n-1}`.\n\n    Args:\n        val: the integer value.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Constant\n        >>> Constant(3, 12)\n        0x003\n        >>> Constant(0b11, 12)\n        0x003\n        >>> Constant(0x003, 12)\n        0x003\n        >>> Constant(3, 12).vrepr()\n        'Constant(0b000000000011, width=12)'\n\n    \"\"\"\n\n    def __int__(self):\n        return self.val\n\n    def __hash__(self):\n        return super().__hash__()\n\n    def __eq__(self, other):\n        \"\"\"Override == operator.\"\"\"\n        if isinstance(other, int):\n            return self.val == other\n        elif isinstance(other, Constant) and self.width == other.width:\n            return self.val == other.val\n        else:\n            return False\n\n    # def __index__(self):\n    #     \"\"\"Return an int to be used inside a slice [ : : ].\"\"\"\n    #     return self.int\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute its hash.\"\"\"\n        return self.val, self.width\n\n    @classmethod\n    def class_key(cls):\n        \"\"\"Return the key (identifier) of the class for sorting.\"\"\"\n        return 1, 0, cls.__name__\n\n    # end Integer\n\n    __slots__ = [\"_val\"]\n\n    def __new__(cls, val, width):\n        assert isinstance(val, int) and 0 <= val < 2 ** width\n        obj = Term.__new__(cls, width=width)\n        obj._val = val\n        return obj\n\n    def __bool__(self):\n        if self.width == 1:\n            return self == Constant(1, 1)\n        else:\n            raise AttributeError(\"only 1-bit constants implement bool()\")\n\n    @property\n    def val(self):\n        \"\"\"The integer represented by the bit-vector constant.\"\"\"\n        return self._val\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the constant.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + log2(int(self) + 1) + bin_enc(self.width)\n\n    def bin(self):\n        \"\"\"Return the binary representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).bin())\n            0b0011\n            >>> print(Constant(4, 6).bin())\n            0b000100\n\n        \"\"\"\n        width = self.width + 2  # 2 due to '0b'\n        return format(self.val, r'0=#{}b'.format(width))\n\n    def hex(self):\n        \"\"\"Return the hexadecimal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).hex())\n            0x3\n\n        \"\"\"\n        assert self.width % 4 == 0\n        width = (self.width // 4) + 2\n        return format(self.val, '0=#{}x'.format(width))\n\n    def oct(self):\n        \"\"\"Return the octal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(4, 6).oct())\n            0o04\n\n        \"\"\"\n        assert self.width % 3 == 0\n        width = (self.width // 3) + 2\n        return format(self.val, '0=#{}o'.format(width))\narxpy/differential/characteristic.py\nclass BvCharacteristic(object):\n    \"\"\"Represent characteristics of bit-vector functions.\n\n    Given a bit-vector function `BvFunction` :math:`f`,\n    a characteristic is a trail of differences obtained by\n    propagating an input difference over :math:`f`.\n\n    In particular, a characteristic is composed of the\n    input difference and the output difference of each\n    non-linear operation.\n\n    This class manages symbolic characteristics,\n    where the input difference is given symbolically\n    and the intermediate differences are `Term`\n    that depend on the input difference.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff, RXDiff\n        >>> from arxpy.differential.characteristic import BvCharacteristic\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi.set_rounds(1)\n        >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dv0, dv1, dv2, dv3),\n        'output_vars': (d7, d12, d13, d9),\n        'assignments': ((d0, dv0 + dv1), (d1, dv1 <<< 5), (d2, d0 ^ d1), (d3, d0 <<< 16), (d4, dv2 + dv3),\n        (d5, dv3 <<< 8), (d6, d4 ^ d5), (d7, d3 + d6), (d8, d6 <<< 13), (d9, d7 ^ d8), (d10, d2 + d4),\n        (d11, d2 <<< 7), (d12, d10 ^ d11), (d13, d10 <<< 16))}\n        >>> ch.input_diff\n        (XorDiff(dv0), XorDiff(dv1), XorDiff(dv2), XorDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(d0), XDA(XorDiff(dv0), XorDiff(dv1))),\n        (XorDiff(d4), XDA(XorDiff(dv2), XorDiff(dv3))),\n        (XorDiff(d7), XDA(XorDiff(d0 <<< 16), XorDiff(d4 ^ (dv3 <<< 8)))),\n        (XorDiff(d10), XDA(XorDiff(d0 ^ (dv1 <<< 5)), XorDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(d7), XorDiff(d7)],\n        [XorDiff(d12), XorDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [XorDiff(d13), XorDiff(d10 <<< 16)],\n        [XorDiff(d9), XorDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n        >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.input_diff\n        (RXDiff(dv0), RXDiff(dv1), RXDiff(dv2), RXDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(RXDiff(d0), RXDA(RXDiff(dv0), RXDiff(dv1))),\n        (RXDiff(d4), RXDA(RXDiff(dv2), RXDiff(dv3))),\n        (RXDiff(d7), RXDA(RXDiff(d0 <<< 16), RXDiff(d4 ^ (dv3 <<< 8)))),\n        (RXDiff(d10), RXDA(RXDiff(d0 ^ (dv1 <<< 5)), RXDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[RXDiff(d7), RXDiff(d7)],\n        [RXDiff(d12), RXDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [RXDiff(d13), RXDiff(d10 <<< 16)],\n        [RXDiff(d9), RXDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n\n    Attributes:\n        func: the `BvFunction`\n        diff_type: the `Difference` of the characteristic\n        input_diff: a list containing the input symbolic differences\n        nonlinear_diffs: an `collections.OrderedDict` mapping non-linear symbolic differences\n            to their corresponding `Derivative`\n        output_diff: a list, where the i-th element is a pair containing\n            the i-th output symbolic difference and its value\n    \"\"\"\n\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n        assert issubclass(func, primitives.BvFunction)\n        assert issubclass(diff_type, difference.Difference)\n\n        assert len(input_diff_names) == len(func.input_widths)\n        input_diff = []\n        for name, width in zip(input_diff_names, func.input_widths):\n            input_diff.append(diff_type(core.Variable(name, width)))\n        input_diff = tuple(input_diff)\n\n        self.func = func\n        self.diff_type = diff_type\n        self.input_diff = input_diff\n\n        # Propagate the input difference through the function\n\n        names = [d.val.name for d in self.input_diff]\n        ssa = self.func.ssa(names, id_prefix=prefix)\n        self.ssa = ssa\n        self._prefix = prefix\n        self._input_diff_names = input_diff_names\n\n        for var in ssa[\"output_vars\"]:\n            if isinstance(var, core.Constant):\n                raise ValueError(\"constant outputs (independent of the inputs) are not supported\")\n\n        var2diff = {}  # Variable to Difference\n        for var, diff in zip(ssa[\"input_vars\"], self.input_diff):\n            var2diff[var] = diff\n\n        if initial_var2diff is not None:\n            for var in initial_var2diff:\n                if str(var) in names:\n                    raise ValueError(\"the input differences cannot be replaced by initial_var2diff\")\n            var2diff.update(initial_var2diff)\n\n        self.nonlinear_diffs = collections.OrderedDict()\n        for var, expr in ssa[\"assignments\"]:\n            expr_args = []\n            for arg in expr.args:\n                if isinstance(arg, int):\n                    expr_args.append(arg)  # 'int' object has no attribute 'xreplace'\n                else:\n                    expr_args.append(arg.xreplace(var2diff))\n\n            if all(not isinstance(arg, diff_type) for arg in expr_args):\n                # symbolic computations with the key\n                var2diff[var] = expr\n                continue\n\n            if all(isinstance(arg, diff_type) for arg in expr_args):\n                der = self.diff_type.derivative(type(expr), expr_args)\n            else:\n                def contains_key_var(term):\n                    from sympy import basic\n                    for sub in basic.preorder_traversal(term):\n                        if sub in func.round_keys:\n                            return True\n                    else:\n                        return False\n\n                if type(expr) == operation.BvAdd and hasattr(func, 'round_keys') and \\\n                        all(isinstance(r, core.Variable) for r in func.round_keys) and \\\n                        any(contains_key_var(a) for a in expr_args):\n                    # temporary solution to Derivative(BvAddCte_k(x)) != Derivative(x + k)\n                    # with x a Diff and k a key variable\n                    keyed_indices = []\n                    for i, a in enumerate(expr_args):\n                        if contains_key_var(a):\n                            keyed_indices.append(i)\n                    if len(keyed_indices) != 1 or expr_args[keyed_indices[0]] not in func.round_keys:\n                        raise NotImplementedError(\"invalid expression: op={}, args={}\".format(\n                            type(expr).__name__, expr_args))\n                    # expr_args[keyed_indices[0]] replaced to the zero diff\n                    zero_diff = diff_type(core.Constant(0, expr_args[keyed_indices[0]].width))\n                    der = self.diff_type.derivative(type(expr), [expr_args[(keyed_indices[0] + 1) % 2], zero_diff])\n                elif hasattr(expr, \"xor_derivative\"):\n                    # temporary solution to operations containing a custom derivative\n                    input_diff_expr = []\n                    for i, arg in enumerate(expr_args):\n                        if isinstance(arg, diff_type):\n                            input_diff_expr.append(arg)\n                        else:\n                            assert isinstance(arg, core.Term)  # int arguments currently not supported\n                            input_diff_expr.append(diff_type.from_pair(arg, arg))\n                    der = self.diff_type.derivative(type(expr), input_diff_expr)\n                else:\n                    fixed_args = []\n                    for i, arg in enumerate(expr_args):\n                        if not isinstance(arg, diff_type):\n                            fixed_args.append(arg)\n                        else:\n                            fixed_args.append(None)\n                    new_op = extraop.make_partial_operation(type(expr), tuple(fixed_args))\n                    der = self.diff_type.derivative(new_op, [arg for arg in expr_args if isinstance(arg, diff_type)])\n\n            if isinstance(der, derivative.Derivative):\n                diff = self.diff_type(var)\n                var2diff[var] = diff\n                self.nonlinear_diffs[diff] = der\n            else:\n                var2diff[var] = der\n\n        self._var2diff = var2diff\n\n        self.output_diff = []\n        for var in ssa[\"output_vars\"]:\n            self.output_diff.append([self.diff_type(var), var2diff[var]])\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n        \"\"\"Return the empirical weight of a given differential.\n\n        Given a differential (a pair of input and output differences),\n        the differential probability is the fraction of input pairs\n        with the given input difference leading to output pairs\n        with the given output difference.\n\n        This method returns an approximation of the weight of the\n        differential probability by sampling a given number\n        of input pairs.\n\n        If no correct output pairs are found, `math.inf` is returned.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff, RXDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> ch.empirical_weight([zero, zero, zero, zero], [zero, zero, zero, zero], 100)\n            0.0\n            >>> ch.empirical_weight([zero, zero, zero, zero], [one, one, one, one], 100)\n            inf\n            >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = RXDiff(Constant(0, 32)), RXDiff(Constant(1, 32))\n            >>> 4 - 1 <= ch.empirical_weight([zero]*4, [zero]*4, 3 * 2**6) <= 8\n            True\n            >>> ch.empirical_weight([zero]*4, [one]*4, 3 * 2**6)\n            inf\n\n        \"\"\"\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            correct_pairs = 0\n\n            for index_input in range(pair_samples):\n                pt, other_pt = list_pairs[index_input]\n                ct = self.func(*pt)\n                other_ct = self.func(*other_pt)\n\n                assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                for i, diff in enumerate(output_diff):\n                    # noinspection PyUnresolvedReferences\n                    if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                        break\n                else:\n                    correct_pairs += 1\n\n            if correct_pairs == 0:\n                weight = math.inf\n            else:\n                weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n\n        return weight\n\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n        # this function is not part of SingleKeyCh since it must be accessible\n        # for the encryption characteristic of RelatedKeyCh (which is a\n        # plain BvCharacteristic)\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        old_round_keys = self.func.round_keys\n\n        empirical_weights = collections.Counter()\n\n        if rk_output_diff is not None:\n            class RelatedFunc(self.func):\n                pass\n        else:\n            RelatedFunc = self.func\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            for _ in range(key_samples):\n                master_key = []\n                for width in cipher.key_schedule.input_widths:\n                    master_key.append(core.Constant(random.randrange(2 ** width), width))\n                self.func.round_keys = cipher.key_schedule(*master_key)\n                assert all(isinstance(rk, core.Constant) for rk in self.func.round_keys), str(self.func.round_keys)\n\n                if rk_output_diff is not None:\n                    RelatedFunc.round_keys = [d.get_pair_element(r) for r, d in zip(self.func.round_keys, rk_output_diff)]\n                    assert all(isinstance(rk, core.Constant) for rk in RelatedFunc.round_keys), str(RelatedFunc.round_keys)\n\n                correct_pairs = 0\n\n                for index_input in range(pair_samples):\n                    pt, other_pt = list_pairs[index_input]\n                    ct = self.func(*pt)\n                    other_ct = RelatedFunc(*other_pt)\n\n                    assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                    assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                    for i, diff in enumerate(output_diff):\n                        # noinspection PyUnresolvedReferences\n                        if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                            break\n                    else:\n                        correct_pairs += 1\n\n                if correct_pairs == 0:\n                    weight = math.inf\n                else:\n                    weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n                # weight = float((\"{0:.\"+str(precision)+\"f}\").format(weight))\n                weight = round(weight, precision)\n                empirical_weights[weight] += 1\n\n        self.func.round_keys = old_round_keys\n\n        return empirical_weights\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the characteristic.\n\n        The signature is a \"hash\" of the characteristic used for comparing.\n\n        For the type of the signature, see `ChSignatureType`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic, ChSignatureType\n            >>> from arxpy.primitives.primitives import BvFunction\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> issubclass(ChaskeyPi, BvFunction)\n            True\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n            >>> ch.signature(ChSignatureType.Full)\n            [dv0, dv1, dv2, dv3, d0, d4, d7, d10]\n            >>> ch.signature(ChSignatureType.InputOutput)\n            [dv0, dv1, dv2, dv3, d7, d12, d13, d9]\n\n        \"\"\"\n        if ch_signature_type == ChSignatureType.Full:\n            return [d.val for d in self.input_diff] + [d.val for d in self.nonlinear_diffs]\n        elif ch_signature_type == ChSignatureType.InputOutput:\n            # sig = [d for d in self.input_diff]\n            sig_var = [d.val for d in self.input_diff]\n\n            for out_diff, _ in self.output_diff:\n                for aux_var in self._var2diff[out_diff.val].val.atoms(core.Variable):\n                    if aux_var not in sig_var:\n                        # sig.append(out_diff)\n                        sig_var.append(out_diff.val)\n                        break\n\n            return sig_var\n        else:\n            raise ValueError(\"invalid ch_signature_type: {}\".format(ch_signature_type))\n\n    def _to_dict(self):\n        dict_ch = {\n            \"ssa\": self.ssa,\n            \"input_diff\": self.input_diff,\n            \"output_diff\": self.output_diff,\n            \"nonlinear_diffs\": self.nonlinear_diffs,\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/primitives/primitives.py\nclass Encryption(BvFunction):\n    \"\"\"Represent encryption functions.\n\n    An encryption function is a `BvFunction` that takes\n    the plaintext as input and returns the ciphertext\n    for some fixed key.\n    See `BvFunction` for more information.\n\n    Attributes:\n        round_keys: a list of `Term` representing the round keys\n\n    \"\"\"\n    round_keys = None\narxpy/bitvector/core.py\nclass Variable(basic.Atom, Term):\n    \"\"\"Represent bit-vector variables.\n\n    Args:\n        name: the name of the variable.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> Variable(\"x\", 12)\n        x\n        >>> Variable(\"x\", 12).vrepr()\n        \"Variable('x', width=12)\"\n\n    \"\"\"\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute hash.\"\"\"\n        return self.name, self.width\n\n    # def __call__(self, *args):\n    #     from sympy.core.function as function\n    #     return function.UndefinedFunction(self.name, self.width)(*args)\n\n    # end Symbol\n\n    __slots__ = ['_name']\n\n    def __new__(cls, name, width):\n        assert isinstance(name, str)\n        obj = Term.__new__(cls, width=width)\n        obj._name = name\n\n        return obj\n\n    @property\n    def name(self):\n        \"\"\"The name of the variable.\"\"\"\n        return self._name\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the variable.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + bin_enc(self.width)\narxpy/differential/characteristic.py\nclass SingleKeyCh(BvCharacteristic):\n    \"\"\"Represent single-key characteristics of block ciphers.\n\n    A single-key characteristic of a `Cipher` is a `BvCharacteristic`\n    over the `Encryption` function of the cipher.\n\n    The plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import SingleKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> Speck32.set_rounds(1)\n        >>> ch = SingleKeyCh(Speck32, XorDiff)\n        >>> ch .ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1), 'output_vars': (dx2, dx4),\n        'assignments': ((dx0, dp0 >>> 7), (dx1, dp1 + dx0), (dx2, dx1 ^ k0), (dx3, dp1 <<< 2), (dx4, dx2 ^ dx3))}\n        >>> ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1))\n        >>> ch.nonlinear_diffs\n        OrderedDict([(XorDiff(dx1), XDA(XorDiff(dp1), XorDiff(dp0 >>> 7)))])\n        >>> ch.output_diff\n        [[XorDiff(dx2), XorDiff(dx1)], [XorDiff(dx4), XorDiff(dx1 ^ (dp1 <<< 2))]]\n\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        rk = []\n        for i, width in enumerate(bv_cipher.key_schedule.output_widths):\n            rk.append(core.Variable(\"k\" + str(i), width))\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = tuple(rk)\n\n        func = Encryption\n        num_inputs = len(func.input_widths)\n        input_diff_names = [\"dp\" + str(i) for i in range(num_inputs)]\n        prefix = \"dx\"\n        super().__init__(func, diff_type, input_diff_names, prefix)\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n        \"\"\"Return the empirical weight distribution of a given differential.\n\n        This method returns a `collections.Counter` storing the distribution of\n        differential probability weights over the given number of keys.\n\n        The weights are rounded to the given number of precision\n        digits after the decimal point.\n\n        See also `BvCharacteristic.empirical_weight`.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import SingleKeyCh\n            >>> from arxpy.primitives import speck\n            >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n            >>> Speck32.set_rounds(1)\n            >>> ch = SingleKeyCh(Speck32, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 16)), XorDiff(Constant(1, 16))\n            >>> ch.empirical_weight([zero, zero], [zero, zero], 100, 10)\n            Counter({0.0: 10})\n            >>> ch.empirical_weight([zero, zero], [one, one], 100, 10)\n            Counter({inf: 10})\n\n        \"\"\"\n        return self._empirical_weight_distribution(self._cipher, input_diff, output_diff, pair_samples, key_samples,\n                                                   precision, rk_diffs)\narxpy/differential/characteristic.py\nclass ChSignatureType(enum.Enum):\nclass BvCharacteristic(object):\n            class RelatedFunc(self.func):\nclass SingleKeyCh(BvCharacteristic):\n        class Encryption(bv_cipher.encryption):\nclass RelatedKeyCh(object):\n        class Encryption(bv_cipher.encryption):\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n                def contains_key_var(term):\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\narxpy/differential/difference.py\nclass RXDiff(Difference):\n    \"\"\"Represent rotational-XOR (RX) differences.\n\n    The pair ``(x, (x <<< 1) ^ d)`` has RX difference ``d``.\n    In other words,  the RX difference of two `Term` ``x`` and ``y``\n    is defined as ``(x <<< 1) ^ y``.\n\n    See `Difference` for more information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import RXDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b000, 3), Constant(0b001, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b001)\n        >>> alpha.get_pair_element(x)\n        0b001\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = RXDiff.from_pair(k, k)\n        >>> alpha\n        RXDiff(k ^ (k <<< 1))\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = RXOp\n    inv_diff_op = RXInvOp\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import RXDiff\n            >>> d1, d2 = RXDiff(Variable(\"d1\", 8)), RXDiff(Variable(\"d2\", 8))\n            >>> RXDiff.derivative(BvXor, [d1, d2])\n            RXDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> RXDiff.derivative(Xor1, d1)\n            RXDiff(0x03 ^ d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> RXDiff.derivative(Rotate1, d1)\n            RXDiff(d1 <<< 1)\n            >>> RXDiff.derivative(BvAdd, [d1, d2])\n            RXDA(RXDiff(d1), RXDiff(d2))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.RXDA(input_diff)\n\n        # Concact, BvSub\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            # BvShl, Extract\n\n        if hasattr(op, \"rx_derivative\"):\n            return op.rx_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/primitives/primitives.py\nclass BvFunction(object):\n    \"\"\"Represent (iterated) fixed-width bit-vector functions.\n\n    A `BvFunction` takes fixed-width `Constant` operands and return a\n    tuple of fixed-width `Constant`. An iterated bit-vector function\n    contains a subroutine that is iterated a certain number of *rounds*,\n    which can be changed using `set_rounds`.\n\n    Similar to `Operation`, `BvFunction` is evaluated\n    using the operator ``()`` and provides *Automatic Constant Conversion*.\n    Note that `BvFunction` only accepts `Constant` operands and\n    always return a tuple, as opposed to `Operation` that accepts\n    `Term` and scalar operands and returns a single `Term`.\n\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi(0, 0, 0, 0)  # automatic conversion from int to Constant\n        (0x00000000, 0x00000000, 0x00000000, 0x00000000)\n\n    Attributes:\n        input_widths: a list containing the widths of the inputs\n        output_widths: a list containing the widths of the outputs\n        rounds: the number of iterations\n\n    \"\"\"\n    input_widths = None\n    output_widths = None\n    rounds = None\n\n    def __new__(cls, *args, **options):\n        if len(cls.input_widths) != len(args):\n            raise ValueError(\"{} requires {} inputs but {} were given: {}\".format(\n                cls.__name__, len(cls.input_widths), len(args), args))\n        newargs = []\n        for arg, width in zip(args, cls.input_widths):\n            newargs.append(core.bitvectify(arg, width))\n        args = newargs\n\n        if all(isinstance(arg, core.Constant) for arg in args) or \\\n                options.pop(\"symbolic_inputs\", False):\n            result = cls.eval(*args)\n        else:\n            raise TypeError(\"expected bit-vector constant arguments\")\n\n        assert isinstance(result, collections.abc.Sequence)\n        assert len(cls.output_widths) == len(result)\n\n        output = []\n        for r, width in zip(result, cls.output_widths):\n            output.append(core.bitvectify(r, width))\n\n        return tuple(output)\n\n    @classmethod\n    def eval(cls, *args):\n        \"\"\"Evaluate the function (internal method).\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    # noinspection PyArgumentList\n    @classmethod\n    def ssa(cls, input_names, id_prefix):\n        \"\"\"Return a static single assignment program representing the function.\n\n        Args:\n            input_names: the names  for the input variables\n            id_prefix: the prefix to denote the intermediate variables\n\n        Return:\n            : a dictionary with three keys\n\n            - *input_vars*: a list of `Variable` representing the inputs\n            - *output_vars*: a list of `Variable` representing the outputs\n            - *assignments*: an ordered sequence of pairs\n              (`Variable`, `Operation`) representing each assignment\n              of the SSA program.\n\n        ::\n\n                >>> from arxpy.primitives.chaskey import ChaskeyPi\n                >>> ChaskeyPi.set_rounds(1)\n                >>> ChaskeyPi.ssa([\"v0\", \"v1\", \"v2\", \"v3\"], \"x\")  # doctest: +NORMALIZE_WHITESPACE\n                {'input_vars': (v0, v1, v2, v3),\n                'output_vars': (x7, x12, x13, x9),\n                'assignments': ((x0, v0 + v1), (x1, v1 <<< 5), (x2, x0 ^ x1), (x3, x0 <<< 16), (x4, v2 + v3),\n                (x5, v3 <<< 8), (x6, x4 ^ x5), (x7, x3 + x6), (x8, x6 <<< 13), (x9, x7 ^ x8), (x10, x2 + x4),\n                (x11, x2 <<< 7), (x12, x10 ^ x11), (x13, x10 <<< 16))}\n\n        \"\"\"\n        input_vars = []\n        for name, width in zip(input_names, cls.input_widths):\n            input_vars.append(core.Variable(name, width))\n        input_vars = tuple(input_vars)\n\n        table = context.MemoizationTable(id_prefix=id_prefix)\n\n        with context.Memoization(table):\n            # noinspection PyArgumentList\n            output_vars = cls(*input_vars, symbolic_inputs=True)\n\n        ssa_dict = {\n            \"input_vars\": input_vars,\n            \"output_vars\": output_vars,\n            \"assignments\": tuple(table.items())\n        }\n\n        for var, expr in ssa_dict[\"assignments\"]:\n            for arg in expr.args:\n                if isinstance(arg, operation.Operation):\n                    raise ValueError(\"assignment {} <- {} was not decomposed\".format(var, expr))\n\n        to_delete = []\n        vars_needed = set()\n        for var in output_vars:\n            vars_needed.add(var)\n        for var, expr in reversed(ssa_dict[\"assignments\"]):\n            if var in vars_needed:\n                for arg in expr.atoms(core.Variable):\n                    vars_needed.add(arg)\n            else:\n                to_delete.append((var, expr))\n                # raise ValueError(\"assignment {} <- {} is redundant in \\n{}\".format(var, expr, ssa_dict))\n\n        if len(to_delete) > 0:\n            import warnings\n            warnings.warn(\"removing redundant assignments {} in \\n{}\".format(to_delete, ssa_dict))\n            ssa_dict[\"assignments\"] = list(ssa_dict[\"assignments\"])\n            for assignment in to_delete:\n                ssa_dict[\"assignments\"].remove(assignment)\n            ssa_dict[\"assignments\"] = tuple(ssa_dict[\"assignments\"])\n\n        return ssa_dict\narxpy/primitives/primitives.py\nclass KeySchedule(BvFunction):\n    \"\"\"Represent key schedule functions.\n\n    A key schedule function is a `BvFunction` that takes\n    the masterkey as input and returns the round keys.\n    See `BvFunction` for more information.\n    \"\"\"\narxpy/primitives/primitives.py\nclass Cipher(object):\n    \"\"\"Represent (iterated) block ciphers.\n\n    A (iterated) block cipher consists of `KeySchedule` function\n    that computes round keys from a master key and an `Encryption`\n    function that computes a ciphertext from a given plaintext\n    and the round keys.\n\n    Given a ``cipher``, it can be evaluated with the operator ``()``\n    by passing it as arguments the plaintext and the master key,\n    that is, ``cipher(plaintext, masterkey)`` returns the ciphertext.\n\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> plaintext = [0, 0]\n        >>> masterkey = [0, 0, 0, 0]\n        >>> Speck32(plaintext, masterkey)\n        (0x2bb9, 0xc642)\n\n    Attributes:\n        key_schedule: the `KeySchedule` function of the cipher\n        encryption: the `Encryption` function of the cipher\n\n    \"\"\"\n    key_schedule = None\n    encryption = None\n    rounds = None\n\n    _minimum_rounds = 1  # for testing\n\n    def __new__(cls, plaintext, masterkey, **options):\n        assert isinstance(plaintext, collections.abc.Sequence)\n        assert isinstance(masterkey, collections.abc.Sequence)\n        assert cls.rounds >= cls._minimum_rounds\n\n        previous_round_keys = cls.encryption.round_keys\n\n        round_keys = cls.key_schedule(*masterkey, **options)\n        cls.encryption.round_keys = round_keys\n        result = cls.encryption(*plaintext, **options)\n\n        cls.encryption.round_keys = previous_round_keys\n\n        return result\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n", "answers": ["class Encryption1(Encryption):  # noqa: D101"], "length": 5302, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "348e33db9dd7512c0d821c5d1fc6a5b74a412a1e9be012f7"}
{"input": "import android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;", "context": "Spectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\n", "answers": ["    private ImmersiveTouchNavigation mImmersiveTouchNavigation;"], "length": 8166, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "cf3d37ae2215d5f5123fcc3ad041ba23b56d19a3abad67e6"}
{"input": "import com.fasterxml.jackson.core.JsonProcessingException;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.ulyssis.ipp.config.Config;\nimport org.ulyssis.ipp.config.ReaderConfig;\nimport org.ulyssis.ipp.config.Team;\nimport org.ulyssis.ipp.control.CommandProcessor;\nimport org.ulyssis.ipp.control.commands.AddTagCommand;\nimport org.ulyssis.ipp.control.commands.CorrectionCommand;\nimport org.ulyssis.ipp.control.commands.RemoveTagCommand;\nimport org.ulyssis.ipp.control.commands.SetEndTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStartTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusMessageCommand;\nimport org.ulyssis.ipp.control.commands.SetUpdateFrequencyCommand;\nimport org.ulyssis.ipp.control.handlers.EventCommandHandler;\nimport org.ulyssis.ipp.control.handlers.PingHandler;\nimport org.ulyssis.ipp.snapshot.Snapshot;\nimport org.ulyssis.ipp.snapshot.AddTagEvent;\nimport org.ulyssis.ipp.snapshot.CorrectionEvent;\nimport org.ulyssis.ipp.snapshot.EndEvent;\nimport org.ulyssis.ipp.snapshot.Event;\nimport org.ulyssis.ipp.snapshot.MessageEvent;\nimport org.ulyssis.ipp.snapshot.RemoveTagEvent;\nimport org.ulyssis.ipp.snapshot.StartEvent;\nimport org.ulyssis.ipp.snapshot.StatusChangeEvent;\nimport org.ulyssis.ipp.snapshot.UpdateFrequencyChangeEvent;\nimport org.ulyssis.ipp.status.StatusMessage;\nimport org.ulyssis.ipp.status.StatusReporter;\nimport org.ulyssis.ipp.utils.JedisHelper;\nimport org.ulyssis.ipp.utils.Serialization;\nimport org.ulyssis.ipp.TagId;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.sql.*;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_ONLY;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_WRITE;\n        }\n        URI uri = options.getRedisUri();\n        this.eventQueue = new LinkedBlockingQueue<>();\n        this.eventCallbacks  = new ConcurrentHashMap<>();\n        this.onStartedCallbacks = new CopyOnWriteArrayList<>();\n        this.readerListeners = new ArrayList<>();\n        this.threads = new ArrayList<>();\n        // TODO: Move status reporting and processing of commands to ZeroMQ?\n        // Also: post some stuff to a log in the db?\n        this.statusReporter = new StatusReporter(uri, Config.getCurrentConfig().getStatusChannel());\n        this.commandProcessor = new CommandProcessor(uri, Config.getCurrentConfig().getControlChannel(), statusReporter);\n        initCommandProcessor();\n        snapshot = new Snapshot(Instant.EPOCH);\n        if (!restoreFromDb()) {\n            registerInitialTags();\n        }\n    }\n\n    /**\n     * Restore the state from the database\n     *\n     * @return Whether we could restore from db, if false, we're starting from a clean slate\n     */\n    private boolean restoreFromDb() {\n        Connection connection = null;\n        Snapshot oldSnapshot = this.snapshot;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            Optional<Snapshot> snapshot = Snapshot.loadLatest(connection);\n            if (snapshot.isPresent()) {\n                this.snapshot = snapshot.get();\n                connection.commit();\n                return true;\n            } else {\n                List<Event> events = Event.loadAll(connection);\n                Snapshot snapshotBefore = this.snapshot;\n                // Instant now = Instant.now(); // TODO: Handle future events later!\n                for (Event event : events) {\n                    if (!event.isRemoved()/* && event.getTime().isBefore(now)*/) { // TODO: Future events later!\n                        this.snapshot = event.apply(this.snapshot);\n                        this.snapshot.save(connection);\n                    }\n                }\n                connection.commit();\n                return !Objects.equals(this.snapshot, snapshotBefore);\n            }\n        } catch (SQLException | IOException e) {\n            LOG.error(\"An error occurred when restoring from database!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n            return false;\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void registerInitialTags() {\n        Snapshot oldSnapshot = this.snapshot;\n        Connection connection = null;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            for (Team team : Config.getCurrentConfig().getTeams()) {\n                for (TagId tag : team.getTags()) {\n                    AddTagEvent e = new AddTagEvent(Instant.EPOCH, tag, team.getTeamNb());\n                    e.save(connection);\n                    this.snapshot = e.apply(this.snapshot);\n                    this.snapshot.save(connection);\n                }\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            LOG.error(\"An error occurred when registering initial tags!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void initCommandProcessor() {\n        commandProcessor.addHandler(new PingHandler());\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(AddTagCommand.class, AddTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(RemoveTagCommand.class, RemoveTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(CorrectionCommand.class, CorrectionEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStartTimeCommand.class, StartEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetEndTimeCommand.class, EndEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusCommand.class, StatusChangeEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusMessageCommand.class, MessageEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(", "context": "shared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusCommand.java\n@JsonTypeName(\"SetStatus\")\npublic final class SetStatusCommand extends Command {\n    private final Status status;\n\n    public SetStatusCommand(Status status) {\n        super();\n        this.status = status;\n    }\n\n    @JsonCreator\n    private SetStatusCommand(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\") Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetUpdateFrequencyCommand.java\n@JsonTypeName(\"SetUpdateFrequency\")\npublic final class SetUpdateFrequencyCommand extends Command {\n    private final int updateFrequency;\n\n    public SetUpdateFrequencyCommand(int updateFrequency) {\n        super();\n        this.updateFrequency = updateFrequency;\n    }\n\n    @JsonCreator\n    private SetUpdateFrequencyCommand(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusMessageCommand.java\n@JsonTypeName(\"SetStatusMessage\")\npublic class SetStatusMessageCommand extends Command {\n    private final String message;\n\n    public SetStatusMessageCommand(String message) {\n        super();\n        this.message = message;\n    }\n\n    public SetStatusMessageCommand(Instant time, String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @JsonCreator\n    private SetStatusMessageCommand(@JsonProperty(\"commandId\") String commandId,\n                                    @JsonProperty(\"time\") Instant time,\n                                    @JsonProperty(\"message\") String message) {\n        super(commandId, time);\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusReporter.java\npublic final class StatusReporter {\n    private static final Logger LOG = LogManager.getLogger(StatusReporter.class);\n    \n    private final Jedis jedis;\n    private final String statusChannel;\n\n    /**\n     * Create a new status reporter for the given Redis URI and status channel.\n     *\n     * @param redisURI\n     *        The URI for the Redis instance to report the status on. This should\n     *        be the \"own\" Redis instance.\n     * @param statusChannel\n     *        The channel to broadcast the status messages to. This channel is\n     *        made specific to the database, so if the `redisUri`\n     *        contains database `N`, and the channel is `status`,\n     *        then messages will be broadcast on channel `status:N`.\n     * @see org.ulyssis.ipp.utils.JedisHelper#dbLocalChannel(String, java.net.URI)\n     */\n    public StatusReporter(URI redisURI, String statusChannel) {\n        this.jedis = JedisHelper.get(redisURI);\n        this.statusChannel = JedisHelper.dbLocalChannel(statusChannel, redisURI);\n    }\n\n    /**\n     * Broadcast a status message.\n     *\n     * @param message\n     *        The message to broadcast\n     * @return True if the broadcast was successful, false if the broadcast was unsuccessful.\n     *         Failure to broadcast will be logged.\n     */\n    public synchronized boolean broadcast(StatusMessage message) {\n        if (jedis == null)\n            return false;\n        try {\n            jedis.publish(statusChannel.getBytes(), Serialization.getJsonMapper().writeValueAsBytes(message));\n            return true;\n        } catch (JsonProcessingException e) {\n            LOG.error(\"Error processing message {}\", message.getDetails(), e);\n            return false;\n        } catch (JedisConnectionException e) {\n            LOG.error(\"Couldn't connect to Redis when sending: {}\", message.getDetails(), e);\n            return false;\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/handlers/PingHandler.java\npublic final class PingHandler implements CommandHandler {\n\n    /**\n     * Handles the given command, which should be a PingCommand.\n     *\n     * @param command\n     *        The ping command to handle.\n     * @param callback\n     *        The ping callback, which is always invoked with true.\n     */\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        callback.accept(true);\n    }\n\n    /**\n     * Returns PingCommand.class\n     *\n     * @return PingCommand.class\n     */\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return PingCommand.class;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/ReaderConfig.java\npublic class ReaderConfig {\n    private URI uri;\n    private Type type = Type.LLRP;\n    private double position;\n    private List<SimulatedTeam> simulatedTeams = new ArrayList<>();\n\n    public static class SimulatedTeam {\n        private final TagId tag;\n        private final long lapTime;\n\n        @JsonCreator\n        public SimulatedTeam(\n                @JsonProperty(\"tag\") TagId tag,\n                @JsonProperty(\"lapTime\") long lapTime) {\n            this.tag = tag;\n            this.lapTime = lapTime;\n        }\n\n        public TagId getTag() {\n            return tag;\n        }\n\n        public long getLapTime() {\n            return lapTime;\n        }\n    }\n\n    public enum Type {\n        LLRP,\n        SIMULATOR\n    }\n\n    /**\n     * Private constructor used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private ReaderConfig() {\n    }\n\n    public URI getURI() {\n        return uri;\n    }\n    \n    /**\n     * Private setter used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private void setURI(URI uri) {\n        this.uri = uri;\n    }\n\n    public double getPosition() {\n        return position;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setPosition(double position) {\n        this.position = position;\n    }\n\n    public Type getType() {\n        return type;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setType(Type type) {\n        this.type = type;\n    }\n\n    public List<SimulatedTeam> getSimulatedTeams() {\n        return Collections.unmodifiableList(simulatedTeams);\n    }\n\n    public SimulatedTeam getSimulatedTeam(int id) {\n        return simulatedTeams.get(id);\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setSimulatedTeams(List<SimulatedTeam> simulatedTeams) {\n        this.simulatedTeams = simulatedTeams;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/RemoveTagCommand.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagCommand extends TagCommand {\n    public RemoveTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    public RemoveTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @JsonCreator\n    private RemoveTagCommand(@JsonProperty(\"commandId\") String commandId,\n                             @JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"tag\") TagId tag,\n                             @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StartEvent.java\n@JsonTypeName(\"Start\")\npublic final class StartEvent extends Event {\n    /**\n     * Private constructor for Jackson\n     */\n    private StartEvent() {\n        super(Instant.MIN);\n    }\n\n    public StartEvent(Instant time) {\n        super(time);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withStartTime(getTime()).build();\n    }\n\n    public static StartEvent fromCommand(Command command) {\n        assert(command instanceof SetStartTimeCommand);\n        SetStartTimeCommand cmd = (SetStartTimeCommand) command;\n        return new StartEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/JedisHelper.java\npublic final class JedisHelper {\n\n    // Static methods only! No instances!\n    private JedisHelper() {\n    }\n\n    /**\n     * Get a new Jedis instance from the given URI\n     *\n     * The URI is formed as such:\n     * `new URI(\"redis://:password@host:port/database\")`\n     * for example:\n     * `new URI(\"redis://:hunter2@10.0.0.1:6379/0\")}`.\n     * The port, password and path can be omitted. If no path is\n     * supplied, database +0+ is selected. If no user\n     * info is supplied, then no authorization is performed.\n     * If no port is supplied, the default port +6379+\n     * is used.\n     *\n     * Use this instead of `new Jedis(uri)`, because\n     * that method does not allow to omit anything.\n     *\n     * @param uri\n     *        The URI for the Jedis instance.\n     * @return A new Jedis instance.\n     */\n    // TODO: Exceptions for wrong password, failing to parse database,...\n    public static Jedis get(URI uri) throws IllegalArgumentException {\n        int port = uri.getPort() != -1 ? uri.getPort() : 6379;\n        String host = uri.getHost();\n        Jedis result = new Jedis(host, port);\n        if (uri.getUserInfo() != null) {\n            String password = uri.getUserInfo().split(\":\")[1];\n            result.auth(password);\n        }\n        result.select(getDb(uri));\n        return result;\n    }\n\n    /**\n     * Extract the database number from the given Redis URI\n     *\n     * If the URI has the path +/N+, then +N+\n     * is returned. If the path is empty, +0+ is returned.\n     *\n     * @param uri\n     *        The URI\n     * @throws java.lang.IllegalArgumentException\n     *         The supplied path could not be parsed as an int\n     * @return The database number (+0+ for no path, +N+\n     *         if the path is +/N+)\n     */\n    public static int getDb(URI uri) throws IllegalArgumentException {\n        if (!Objects.equals(uri.getPath(), \"\")) {\n            try {\n                return Integer.parseInt(uri.getPath().split(\"/\", 2)[1]);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"The supplied path could not be parsed as an int\", e);\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Generates a channel name that is local to a database.\n     *\n     * Redis channels are not tied to a single database, but are\n     * global to the instance of Redis. We, however, want to tie\n     * these to a certain database, so we have to add some information\n     * that does that. For this reason, if the channel name is\n     * +channel+, the database number +N+ is added to it\n     * to form +channel:N+. The database number is extracted\n     * using `getDb(uri)`.\n     *\n     * @param channel\n     *        The base channel name\n     * @param uri\n     *        The URI containing the database info\n     * @return +channel:N+, where +N+ is the database number\n     * @see org.ulyssis.ipp.utils.JedisHelper#getDb(java.net.URI)\n     */\n    public static String dbLocalChannel(String channel, URI uri) {\n        return channel + \":\" + getDb(uri);\n    }\n\n    /**\n     * A helper class that implements +BinaryJedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class BinaryCallBackPubSub extends BinaryJedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(byte[] pattern, byte[] channel, byte[] message);\n        }\n\n        private final List<BiConsumer<byte[],byte[]>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(byte[] channel, byte[] message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onMessage(byte[], byte[])\n         */\n        public void addOnMessageListener(BiConsumer<byte[],byte[]> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(byte[] pattern, byte[] channel, byte[] message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPMessage(byte[], byte[], byte[])\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(byte[] channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onSubscribe(byte[], int)\n         */\n        public void addOnSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(byte[] channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onUnsubscribe(byte[], int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(byte[] pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPSubscribe(byte[], int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(byte[] pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPUnsubscribe(byte[], int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n\n    /**\n     * A helper class that implements +JedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class CallBackPubSub extends JedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(String pattern, String channel, String message);\n        }\n\n        private final List<BiConsumer<String,String>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(String channel, String message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onMessage(String, String)\n         */\n        public void addOnMessageListener(BiConsumer<String, String> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(String pattern, String channel, String message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPMessage(String, String, String)\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(String channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onSubscribe(String, int)\n         */\n        public void addOnSubscribeListener(BiConsumer<String, Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(String channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onUnsubscribe(String, int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(String pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPSubscribe(String, int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<String, Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(String pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPUnsubscribe(String, int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Snapshot.java\npublic final class Snapshot {\n    private static final Logger LOG = LogManager.getLogger(Snapshot.class);\n\n    public static class Builder {\n        private Snapshot snapshot;\n\n        private Builder(Instant time, Snapshot other) {\n            snapshot = new Snapshot(time);\n            if (other != null) {\n                snapshot.teamTagMap = other.teamTagMap;\n                snapshot.startTime = other.startTime;\n                snapshot.endTime = other.endTime;\n                snapshot.teamStates = other.teamStates;\n                snapshot.publicTeamStates = other.publicTeamStates;\n                snapshot.statusMessage = other.statusMessage;\n                snapshot.status = other.status;\n                snapshot.updateFrequency = other.updateFrequency;\n            }\n        }\n\n        public Builder withTeamTagMap(TeamTagMap teamTagMap) {\n            this.snapshot.teamTagMap = teamTagMap;\n            return this;\n        }\n\n        public Builder withStartTime(Instant time) {\n            this.snapshot.startTime = time;\n            return this;\n        }\n\n        public Builder withEndTime(Instant time) {\n            this.snapshot.endTime = time;\n            return this;\n        }\n\n        public Builder withTeamStates(TeamStates teamStates) {\n            this.snapshot.teamStates = teamStates;\n            return this;\n        }\n\n        public Builder withPublicTeamStates(TeamStates teamStates) {\n            this.snapshot.publicTeamStates = teamStates;\n            return this;\n        }\n\n        public Builder withStatusMessage(String message) {\n            this.snapshot.statusMessage = message;\n            return this;\n        }\n\n        public Builder withStatus(Status status) {\n            this.snapshot.status = status;\n            return this;\n        }\n\n        public Builder withUpdateFrequency(int updateFrequency) {\n            this.snapshot.updateFrequency = updateFrequency;\n            return this;\n        }\n\n        public Snapshot build() {\n            return snapshot;\n        }\n    }\n\n    @JsonIgnore\n    private long id = -1;\n\n    @JsonIgnore\n    long eventId = -1;\n\n    public Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    public Optional<Long> getEventId() {\n        if (eventId != -1) return Optional.of(eventId);\n        else return Optional.empty();\n    }\n\n    /**\n     * Default constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private Snapshot() {\n    }\n\n    public Snapshot(Instant time) {\n        snapshotTime = time;\n    }\n\n    public Instant getSnapshotTime() {\n        return snapshotTime;\n    }\n\n    public TeamTagMap getTeamTagMap() {\n        return teamTagMap;\n    }\n\n    public Instant getStartTime() {\n        return startTime;\n    }\n\n    public Instant getEndTime() {\n        return endTime;\n    }\n\n    public TeamStates getTeamStates() {\n        return teamStates;\n    }\n\n    public TeamStates getPublicTeamStates() {\n        return publicTeamStates;\n    }\n\n    public String getStatusMessage() {\n        return statusMessage;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    private Instant snapshotTime = Instant.MIN;\n    private Instant startTime = Instant.MAX;\n    private Instant endTime = Instant.MAX;\n    private TeamTagMap teamTagMap = new TeamTagMap();\n    private TeamStates teamStates;\n    private TeamStates publicTeamStates;\n    {\n        teamStates = new TeamStates();\n        publicTeamStates = teamStates;\n    }\n    private String statusMessage = \"\";\n    private Status status = Status.NoResults;\n    private int updateFrequency = 3;\n\n    public static Builder builder(Instant time, Snapshot other) {\n        return new Builder(time, other);\n    }\n\n    public static Optional<Snapshot> loadForEvent(Connection connection, Event event) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"snapshots\\\" WHERE \\\"event\\\" = ?\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setLong(1, event.getId().get());\n            LOG.debug(\"executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = event.getId().get();\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadLatest(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" ORDER BY \\\"time\\\" DESC FETCH FIRST ROW ONLY\";\n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(statement)) {\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadBefore(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" \" +\n                \"WHERE \\\"time\\\" < ? ORDER BY \\\"time\\\" DESC, \\\"event\\\" DESC FETCH FIRST ROW ONLY\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                \"INSERT INTO \\\"snapshots\\\" (\\\"time\\\",\\\"data\\\",\\\"event\\\") VALUES (?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(snapshotTime));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false; // TODO(Roel): Programming error\n                return;\n            }\n            statement.setString(2, serialized);\n            statement.setLong(3, eventId);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public static void deleteAfter(Connection connection, Snapshot snapshot) throws SQLException {\n        String statement =\n                \"DELETE FROM \\\"snapshots\\\" WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"event\\\" > ?)\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            Timestamp timestamp = Timestamp.from(snapshot.getSnapshotTime());\n            stmt.setTimestamp(1, timestamp);\n            stmt.setTimestamp(2, timestamp);\n            stmt.setLong(3, snapshot.getEventId().orElse(-1L));\n            LOG.debug(\"Executing query: {}\", stmt);\n            int affectedRows = stmt.executeUpdate();\n            LOG.debug(\"deleteAfter affected {} rows\", affectedRows);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/MessageEvent.java\n@JsonTypeName(\"Message\")\npublic final class MessageEvent extends Event {\n    private final String message;\n\n    @JsonCreator\n    public MessageEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"message\") String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withStatusMessage(message).build();\n    }\n\n    public static MessageEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusMessageCommand);\n        SetStatusMessageCommand cmd = (SetStatusMessageCommand) command;\n        return new MessageEvent(cmd.getTime(), cmd.getMessage());\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/CorrectionEvent.java\n@JsonTypeName(\"Correction\")\npublic final class CorrectionEvent extends Event {\n    private int teamNb;\n    private int correction;\n\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private CorrectionEvent() {\n        super(Instant.MIN);\n    }\n\n    /**\n     * Create an event representing a correction of score.\n     *\n     * @param time\n     *        The time at which the corection is performed.\n     * @param teamNb\n     *        The number of the team to correct the score of.\n     * @param correction\n     *        The number of laps that should be added (positive)\n     *        or removed (negative)\n     */\n    public CorrectionEvent(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getCorrection() {\n        return correction;\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamStates oldTeamStates = snapshot.getTeamStates();\n        Optional<TeamState> oldTeamState = oldTeamStates.getStateForTeam(teamNb);\n        TeamState newTeamState;\n        if (oldTeamState.isPresent()) {\n            newTeamState = oldTeamState.get().addCorrection(correction);\n        } else {\n            newTeamState = new TeamState().addCorrection(correction);\n        }\n        return Snapshot.builder(getTime(), snapshot)\n                .withTeamStates(snapshot.getTeamStates().setStateForTeam(teamNb, newTeamState))\n                .build();\n    }\n\n    public static CorrectionEvent fromCommand(Command command) {\n        assert(command instanceof CorrectionCommand);\n        CorrectionCommand cmd = (CorrectionCommand) command;\n        return new CorrectionEvent(cmd.getTime(), cmd.getTeamNb(), cmd.getCorrection());\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Event.java\n@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n@JsonSubTypes({ @JsonSubTypes.Type(value=StartEvent.class),\n                @JsonSubTypes.Type(value=EndEvent.class),\n                @JsonSubTypes.Type(value=AddTagEvent.class),\n                @JsonSubTypes.Type(value=RemoveTagEvent.class),\n                @JsonSubTypes.Type(value=CorrectionEvent.class),\n                @JsonSubTypes.Type(value=TagSeenEvent.class),\n                @JsonSubTypes.Type(value=IdentityEvent.class),\n                @JsonSubTypes.Type(value=MessageEvent.class),\n                @JsonSubTypes.Type(value=StatusChangeEvent.class)})\npublic abstract class Event {\n    private static final Logger LOG = LogManager.getLogger(Event.class);\n\n    @JsonIgnore\n    private long id = -1;\n    @JsonIgnore\n    private boolean removed = false;\n\n    private Instant time;\n\n    protected Event(Instant time) {\n        this.time = time;\n    }\n\n    @JsonIgnore\n    public final Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    @JsonIgnore\n    public final boolean isRemoved() {\n        if (id == -1) throw new IllegalStateException(\"Trying to request removed state of event not in db\");\n        return removed;\n    }\n\n    public final Instant getTime() {\n        return time;\n    }\n\n    /**\n     * Determines whether this event should be isUnique, defaults to false\n     *\n     * @return whether this event should be isUnique (default implementation = false)\n     */\n    @JsonIgnore\n    public boolean isUnique() {\n        return false;\n    }\n\n    /**\n     * Determines whether this event can be removed or undone.\n     *\n     * @return whether this event can be removed or undone (default implementation = isUnique())\n     */\n    @JsonIgnore\n    public boolean isRemovable() {\n        return isUnique();\n    }\n\n    /**\n     * Apply this event to a snapshot, yielding the new snapshot\n     */\n    protected abstract Snapshot doApply(Snapshot before);\n\n    public final Snapshot apply(Snapshot before) {\n        assert !removed;\n        Snapshot result = doApply(before);\n        if (result == before && before.getEventId().isPresent()) {\n            // We need to copy it anyway\n            result = Snapshot.builder(getTime(), before).build();\n        }\n        result.eventId = this.id;\n        return result;\n    }\n\n    // TODO: How to deal with deserialization problem?\n    public static List<Event> loadAll(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"removed\\\" FROM \\\"events\\\" ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (Statement stmt = connection.createStatement();\n             ResultSet result = stmt.executeQuery(statement)) {\n            while (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = result.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static Optional<Event> loadUnique(Connection connection, Class<? extends Event> eventType) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"events\\\" WHERE \\\"type\\\" = ? AND \\\"removed\\\" = false\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setString(1, eventType.getSimpleName());\n            ResultSet result = stmt.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = false;\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Event> load(Connection connection, long id) throws SQLException, IOException {\n        try (PreparedStatement statement =\n                connection.prepareStatement(\n                        \"SELECT \\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" WHERE \\\"id\\\"=?\")) {\n            statement.setLong(1, id);\n            ResultSet result = statement.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = id;\n                event.removed = result.getBoolean(\"removed\");\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static List<Event> loadFrom(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" >= ? ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static List<Event> loadAfter(Connection connection, Instant time, long id) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"id\\\" > ?) ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            stmt.setTimestamp(2, Timestamp.from(time));\n            stmt.setLong(3, id);\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        LOG.debug(\"Loaded {} events\", events.size());\n        return events;\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                    \"INSERT INTO \\\"events\\\" (\\\"time\\\",\\\"type\\\",\\\"data\\\",\\\"removed\\\") \" +\n                            \"VALUES (?,?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(time));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false;\n                throw new IllegalStateException(e); // TODO(Roel): is this appropriate?\n            }\n            statement.setString(2, this.getClass().getSimpleName());\n            statement.setString(3, serialized);\n            statement.setBoolean(4, removed);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public void setRemoved(Connection connection, boolean removed) throws SQLException {\n        if (!isRemovable()) {\n            assert false; // This is a programming error\n            return;\n        }\n        PreparedStatement statement =\n                connection.prepareStatement(\n                        \"UPDATE \\\"events\\\" SET \\\"removed\\\"=? WHERE \\\"id\\\"=?\");\n        statement.setBoolean(1, removed);\n        statement.setLong(2, id);\n        boolean result = statement.execute();\n        assert(!result);\n        this.removed = true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/UpdateFrequencyChangeEvent.java\n@JsonTypeName(\"UpdateFrequencyChange\")\npublic final class UpdateFrequencyChangeEvent extends Event {\n    private final int updateFrequency;\n\n    @JsonCreator\n    public UpdateFrequencyChangeEvent(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withUpdateFrequency(updateFrequency).build();\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    public static UpdateFrequencyChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetUpdateFrequencyCommand);\n        SetUpdateFrequencyCommand cmd = (SetUpdateFrequencyCommand) command;\n        return new UpdateFrequencyChangeEvent(cmd.getTime(), cmd.getUpdateFrequency());\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/Serialization.java\npublic final class Serialization {\n    private static final ObjectMapper jsonMapper;\n\n    static {\n        jsonMapper = new ObjectMapper();\n        jsonMapper.findAndRegisterModules();\n    }\n\n    // Static methods only! No instances!\n    private Serialization() {\n    }\n\n    /**\n     * Get a JSON mapper, with all modules registered.\n     *\n     * This is equivalent to:\n     *\n     * [source,java]\n     * --\n     * jsonMapper = new ObjectMapper();\n     * jsonMapper.findAndRegisterModules();\n     * --\n     *\n     * @return A JSON ObjectMapper\n     */\n    public static ObjectMapper getJsonMapper() {\n        return jsonMapper;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Team.java\npublic final class Team {\n    private static final Logger LOG = LogManager.getLogger(Team.class);\n\n    private int teamNb;\n    private String name;\n    private ImmutableList<TagId> tags;\n\n    @SuppressWarnings(\"unused\")\n    private Team() {\n        this.teamNb = 0;\n        this.name = \"\";\n        tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name, ImmutableList<TagId> tags) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = tags;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public ImmutableList<TagId> getTags() {\n        return tags;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/EndEvent.java\n@JsonTypeName(\"End\")\npublic final class EndEvent extends Event {\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private EndEvent() {\n        super(Instant.MIN);\n    }\n\n    public EndEvent(Instant time) {\n        super(time);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withEndTime(getTime()).build();\n    }\n\n    public static EndEvent fromCommand(Command command) {\n        assert(command instanceof SetEndTimeCommand);\n        SetEndTimeCommand cmd = (SetEndTimeCommand) command;\n        return new EndEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/AddTagEvent.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagEvent extends TagEvent {\n    @JsonCreator\n    public AddTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().addTagToTeam(getTag(), getTeamNb());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static AddTagEvent fromCommand(Command command) {\n        assert(command instanceof AddTagCommand);\n        AddTagCommand addTagCommand = (AddTagCommand) command;\n        return new AddTagEvent(\n            addTagCommand.getTime(),\n            addTagCommand.getTag(),\n            addTagCommand.getTeamNb()\n        );\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/CommandProcessor.java\npublic final class CommandProcessor implements Runnable {\n    private static final Logger LOG = LogManager.getLogger(CommandProcessor.class);\n\n    private final Map<Class<? extends Command>, CommandHandler> commandHandlers = new HashMap<>();\n    private final Jedis jedis;\n    private final StatusReporter reporter;\n    private final String channel;\n\n    private BinaryJedisPubSub listener;\n\n    public CommandProcessor(URI redisUri, String commandChannel, String statusChannel) {\n        this(redisUri, JedisHelper.dbLocalChannel(commandChannel, redisUri),\n                new StatusReporter(redisUri, statusChannel));\n    }\n\n    public CommandProcessor(URI redisUri, String channel, StatusReporter statusReporter) {\n        this.jedis = JedisHelper.get(redisUri);\n        this.channel = JedisHelper.dbLocalChannel(channel, redisUri);\n        this.reporter = statusReporter;\n    }\n\n    public void run() {\n        jedis.subscribe(createCommandListener(), channel.getBytes());\n    }\n\n    private BinaryJedisPubSub createCommandListener() {\n        JedisHelper.BinaryCallBackPubSub pubSub = new JedisHelper.BinaryCallBackPubSub();\n        listener = pubSub;\n        pubSub.addOnMessageListener(this::onCommandMessage);\n        return pubSub;\n    }\n\n    private void onCommandMessage(byte[] channel, byte[] message) {\n        assert (Arrays.equals(channel, this.channel.getBytes()));\n        try {\n            Command command = Serialization.getJsonMapper().readValue(message, Command.class);\n            handleCommand(command);\n        } catch (IOException e) {\n            LOG.error(\"Couldn't parse command: {}\", new String(message), e);\n        }\n    }\n\n    public void addHandler(CommandHandler handler) {\n        commandHandlers.put(handler.getCommandClass(), handler);\n    }\n\n    private void handleCommand(Command command) {\n        LOG.debug(\"Handing command {}: {}\", command.getCommandId(), command.getClass().toString());\n        if (commandHandlers.containsKey(command.getClass())) {\n            commandHandlers.get(command.getClass()).handle(command, notifyCommandExecuted(command));\n        } else {\n            notifyCommandUnsupported(command);\n        }\n    }\n\n    private Consumer<Boolean> notifyCommandExecuted(Command command) {\n        return (result) -> {\n            if (result) {\n                notifySuccess(command);\n            } else {\n                notifyFailure(command);\n            }\n        };\n    }\n\n    private void notifySuccess(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_COMPLETE, command.getCommandId()));\n    }\n\n    private void notifyFailure(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_FAILED, command.getCommandId()));\n    }\n\n    private void notifyCommandUnsupported(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_UNSUPPORTED, command.getCommandId()));\n    }\n\n    public void stop() {\n        try {\n            listener.unsubscribe();\n        } catch (JedisConnectionException ignored) {\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusMessage.java\npublic final class StatusMessage {\n    private MessageType type;\n    private String details;\n\n    public enum MessageType {\n        /**\n         * The reader sends this message when no updates have been received for a while\n         */\n        NO_UPDATES,\n        /**\n         * Notifies that the system has started up\n         */\n        STARTED_UP,\n        /**\n         * Notifies that the startup has failed\n         */\n        STARTUP_FAILURE,\n        /**\n         * Notifies that the system is being shut down\n         */\n        SHUTDOWN,\n        /**\n         * Signals that the command given executed successfully.\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_COMPLETE,\n        /**\n         * Signals that no command handler is installed for the given command\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_UNSUPPORTED,\n        /**\n         * Signals that the command failed to execute\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_FAILED,\n        /**\n         * Signals that the processor's snapshot has been updated\n         */\n        NEW_SNAPSHOT,\n        /**\n         * Signals a miscellaneous error. The details field will contain more information\n         * about the error.\n         */\n        MISC_ERROR\n    }\n\n    /**\n     * Create a new status message with the given type and details.\n     *\n     * This message is to be broadcast by a StatusReporter to the\n     * status channel.\n     *\n     * @param type\n     *        The type of the status\n     * @param details\n     *        The details. The form of this field depends\n     *        on the type of message.\n     * @see org.ulyssis.ipp.status.StatusReporter\n     */\n    @JsonCreator\n    public StatusMessage(@JsonProperty(\"type\") MessageType type,\n                         @JsonProperty(\"details\") String details) {\n        this.type = type;\n        this.details = details;\n    }\n\n    public MessageType getType() {\n        return type;\n    }\n\n    public String getDetails() {\n        return details;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/AddTagCommand.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagCommand extends TagCommand {\n\n    /**\n     * Create an AddTagCommand for the given tag and team number.\n     *\n     * The time is set to be the current time.\n     *\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    /**\n     * Create an AddTagCommand for the given tag and team number at the given time.\n     *\n     * @param time\n     *        The time when to add the tag, this can be in the future for\n     *        an anticipated adding of a tag, or in the past, to add a tag\n     *        afterwards (e.g. as a correction)\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    /*\n     * Only for deserialization.\n     */\n    @JsonCreator\n    private AddTagCommand(@JsonProperty(\"commandId\") String commandId,\n                          @JsonProperty(\"time\") Instant time,\n                          @JsonProperty(\"tag\") TagId tag,\n                          @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetEndTimeCommand.java\n@JsonTypeName(\"SetEndTime\")\npublic final class SetEndTimeCommand extends Command {\n    public SetEndTimeCommand() {\n        super();\n    }\n\n    public SetEndTimeCommand(Instant endTime) {\n        super(endTime);\n    }\n\n    @JsonCreator\n    private SetEndTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/RemoveTagEvent.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagEvent extends TagEvent {\n    @JsonCreator\n    public RemoveTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().removeTag(getTag());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static RemoveTagEvent fromCommand(Command command) {\n        assert(command instanceof RemoveTagCommand);\n        RemoveTagCommand cmd = (RemoveTagCommand) command;\n        return new RemoveTagEvent(cmd.getTime(), cmd.getTag(), cmd.getTeamNb());\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/control/handlers/EventCommandHandler.java\npublic final class EventCommandHandler<EventT extends Event> implements CommandHandler {\n    private final Class<? extends Command> clazz;\n    private final Function<Command, EventT> toEvent;\n    private final BiConsumer<Event, Consumer<Boolean>> processCallback;\n\n    public EventCommandHandler(Class<? extends Command> clazz,\n                               Function<Command, EventT> toEvent,\n                               BiConsumer<Event, Consumer<Boolean>> processCallback) {\n        this.clazz = clazz;\n        this.toEvent = toEvent;\n        this.processCallback = processCallback;\n    }\n\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        Event event = toEvent.apply(command);\n        processCallback.accept(event, callback);\n    }\n\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return clazz;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/CorrectionCommand.java\n@JsonTypeName(\"Correction\")\npublic class CorrectionCommand extends Command {\n    private final int teamNb;\n    private final int correction;\n\n    /**\n     * Create a CorrectionCommand\n     * @param teamNb\n     *        The team number to correct\n     * @param correction\n     *        The correction in nb. of laps. Positive adds laps,\n     *        negative removes laps.\n     */\n    public CorrectionCommand(int teamNb, int correction) {\n        super();\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public CorrectionCommand(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @JsonCreator\n    private CorrectionCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time,\n                              @JsonProperty(\"teamNb\") int teamNb,\n                              @JsonProperty(\"correction\") int correction) {\n        super(commandId, time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public int getCorrection() {\n        return correction;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/TagId.java\n@JsonSerialize(using=TagId.Serializer.class)\n@JsonDeserialize(using=TagId.Deserializer.class)\npublic final class TagId {\n    private final String id;\n    private final String lowerCaseId;\n    private final int hashCode;\n\n    static class Serializer extends JsonSerializer<TagId> {\n        @Override\n        public void serialize(TagId value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n            jgen.writeString(value.toString());\n        }\n    }\n\n    static class Deserializer extends JsonDeserializer<TagId> {\n        @Override\n        public TagId deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return new TagId(jp.getValueAsString());\n        }\n    }\n\n    /**\n     * = Create a new TagId from the given byte array.\n     *\n     * @param id\n     *        The tag id in byte array form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(byte[] id) {\n        this(BaseEncoding.base16().lowerCase().encode(id));\n    }\n\n    /**\n     * = Create a new TagId from the given byte list.\n     *\n     * @param id\n     *        The tag id in byte list form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(List<Byte> id) {\n        this(BaseEncoding.base16().lowerCase().encode(Bytes.toArray(id)));\n    }\n\n    /**\n     * = Create a new TagId\n     *\n     * @param id\n     *        A string that uniquely identifies the tag\n     * @throws java.lang.NullPointerException\n     *         A NullPointerException will be thrown if the given id is null.\n     */\n    public TagId(String id) throws NullPointerException {\n        if (id == null) throw new NullPointerException(\"The tag id is not allowed to be null!\");\n        this.id = id;\n        this.lowerCaseId = id.toLowerCase();\n        this.hashCode = this.lowerCaseId.hashCode();\n    }\n\n    /**\n     * = Get the tag id as a string\n     *\n     * @return This tag id as a string\n     */\n    @Override\n    public String toString() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null) return false;\n        if (!(other instanceof TagId)) return false;\n        return this.lowerCaseId.equals(((TagId) other).lowerCaseId);\n    }\n\n    @Override\n    public int hashCode() {\n        return this.hashCode;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStartTimeCommand.java\n@JsonTypeName(\"SetStartTime\")\npublic final class SetStartTimeCommand extends Command {\n    public SetStartTimeCommand() {\n        super();\n    }\n\n    public SetStartTimeCommand(Instant startTime) {\n        super(startTime);\n    }\n\n    @JsonCreator\n    private SetStartTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                                @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Config.java\npublic class Config {\n    private static final Logger LOG = LogManager.getLogger(Config.class);\n\n    private double trackLength;\n    private ImmutableList<ReaderConfig> readers = ImmutableList.of();\n    private ImmutableList<URI> speedwayURIs = ImmutableList.of();\n    private ImmutableList<Team> teams = ImmutableList.of();\n    private long retryInterval = 5000L;\n    private long minUpdateInterval = 5000L;\n    private long maxUpdateInterval = 30000L;\n    private String statusChannel = \"status\";\n    private String updateChannel = \"update\";\n    private String updatesList = \"updates\";\n    private String updatesSet = \"updates\";\n    private String controlChannel = \"control\";\n\n    /**\n     * Private constructor used by Jackson\n     */\n    private Config() {\n    }\n    \n    /**\n     * Create a configuration from the given configuration file.\n     * \n     * Expects the configuration file to be UTF-8 formatted.\n     */\n    public static Optional<Config> fromConfigurationFile(Path configFile) {\n        try {\n            byte[] config = Files.readAllBytes(configFile);\n            Charset charset = Charset.forName(\"utf-8\");\n            String configString = charset.decode(ByteBuffer.wrap(config)).toString();\n            return fromConfigurationString(configString);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration file: {}\", configFile, e);\n            return Optional.empty();\n        }\n    }\n    \n    /**\n     * Create a configuration from the given JSON configuration string.\n     */\n    public static Optional<Config> fromConfigurationString(String configuration) {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.findAndRegisterModules();\n        try {\n            Config result = mapper.readValue(configuration, Config.class);\n            return Optional.of(result);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration\", e);\n            return Optional.empty();\n        }\n    }\n\n    /**\n     * Get the track length in meters.\n     */\n    public double getTrackLength() {\n        return trackLength;\n    }\n\n    public ImmutableList<ReaderConfig> getReaders() {\n        return readers;\n    }\n    public ReaderConfig getReader(int readerId) {\n        return this.readers.get(readerId);\n    }\n    public int getNbReaders() {\n        return readers.size();\n    }\n\n    public ImmutableList<URI> getSpeedwayURIs() {\n        return speedwayURIs;\n    }\n    /**\n     * Get the URI of the Impinj Speedway corresponding\n     * to the reader with the given id. This id ranges from 0 to\n     * getSpeedwayURIs.size() - 1\n     */\n    public URI getSpeedwayURI(int readerId) {\n        return speedwayURIs.get(readerId);\n    }\n    public int getNbSpeedways() {\n        return speedwayURIs.size();\n    }\n\n    /**\n     * The retry interval for connections in ms.\n     */\n    public long getRetryInterval() {\n        return retryInterval;\n    }\n    \n    /**\n     * The minimum amount of time in ms between two updates, any\n     * update within this amount of time is ignored.\n     */\n    public long getMinUpdateInterval() {\n        return minUpdateInterval;\n    }\n    \n    /**\n     * The maximum time in ms to wait for an update before issuing a warning.\n     */\n    public long getMaxUpdateInterval() {\n        return maxUpdateInterval;\n    }\n    \n    /**\n     * Gets the Redis channel name on which status updates are posted.\n     *\n     * Defaults to \"status\".\n     *\n     * Generally, the db id will be added to the prefix, because\n     * pubsub channels are not database-specific in Redis.\n     */\n    public String getStatusChannel() {\n        return statusChannel;\n    }\n    \n    /**\n     * The prefix of the channel where the reader announces new updates.\n     *\n     * This prefix defaults to \"update\". Generally, the db id will be added\n     * to the prefix, because if multiple readers would use the same Redis\n     * instance (e.g. for testing purposes), these would collide, because\n     * pubsub channels are not database-specific.\n     */\n    public String getUpdateChannel() {\n        return updateChannel;\n    }\n\n    /**\n     * The prefix of the channel where an entity in the system receives control messages.\n     *\n     * This defaults to \"control\". Generally, the db id will be added to this prefix,\n     * because pubsub channels are not database-specific in Redis.\n     */\n    public String getControlChannel() {\n        return controlChannel;\n    }\n\n    /**\n     * The name of the list where readers push their updates on.\n     *\n     * Defaults to \"updates\".\n     */\n    public String getUpdatesList() {\n        return updatesList;\n    }\n\n    /**\n     * The name of the set in which updates are stored in the processor.\n     */\n    public String getUpdatesSet() {\n        return updatesSet;\n    }\n\n    /**\n     * The teams, with team number and name.\n     */\n    public ImmutableList<Team> getTeams() {\n        return teams;\n    }\n\n    // TODO: Maybe find some other solution?\n    private static Config currentConfig;\n\n    public static void setCurrentConfig(Config config) {\n        currentConfig = config;\n    }\n\n    public static Config getCurrentConfig() {\n        return currentConfig;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StatusChangeEvent.java\n@JsonTypeName(\"StatusChange\")\npublic final class StatusChangeEvent extends Event {\n    private final Status status;\n\n    @JsonCreator\n    public StatusChangeEvent(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\")Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public static StatusChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusCommand);\n        SetStatusCommand cmd = (SetStatusCommand) command;\n        return new StatusChangeEvent(cmd.getTime(), cmd.getStatus());\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        Snapshot.Builder builder = Snapshot.builder(getTime(), before).withStatus(status);\n        if (!before.getStatus().isPublic() && status.isPublic()) {\n            builder.withPublicTeamStates(before.getTeamStates());\n        }\n        return builder.build();\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\n", "answers": ["                new EventCommandHandler<>(SetUpdateFrequencyCommand.class, UpdateFrequencyChangeEvent::fromCommand, this::queueEvent));"], "length": 6872, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "2c164c959e45cbd40c80a8618dfe2fbe7d12a613e0ce71c4"}
{"input": "package uw.task.container;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport uw.task.TaskData;\nimport uw.task.TaskFactory;\nimport uw.task.TaskListenerManager;\nimport uw.task.TaskRunner;\nimport uw.task.api.TaskAPI;\nimport uw.task.conf.TaskMetaInfoManager;\nimport uw.task.conf.TaskProperties;\nimport uw.task.entity.TaskRunnerConfig;\nimport uw.task.entity.TaskRunnerLog;\nimport uw.task.exception.TaskDataException;\nimport uw.task.exception.TaskPartnerException;\nimport uw.task.listener.RunnerTaskListener;\nimport uw.task.util.GlobalRateLimiter;\nimport uw.task.util.LocalRateLimiter;\nimport uw.task.util.MiscUtils;\n\n\n\n\n/**\n * 在此处接受MQ信息，并进行处理。\n *\n * @author axeon\n */\npublic class TaskRunnerContainer {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskRunnerContainer.class);\n\n    /**\n     * TaskFactory\n     */\n    private TaskFactory taskFactory;\n\n    /**\n     * 服务端任务API\n     */\n    private TaskAPI taskAPI;\n\n    /**\n     * 全局流量限制服务\n     */\n    private GlobalRateLimiter globalRateLimiter;\n\n    /**\n     * 本地流量限制服务\n     */", "context": "src/main/java/uw/task/util/LocalRateLimiter.java\npublic class LocalRateLimiter {\r\n\r\n    private ConcurrentHashMap<String, RateLimiter> map = new ConcurrentHashMap<>();\r\n\r\n    /**\r\n     * 尝试获得限制允许状态。\r\n     *\r\n     * @param name\r\n     * @return\r\n     */\r\n    public boolean tryAcquire(String name, int requests, int seconds, long waitTime, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return true;\r\n        }\r\n        final double rate = (double) requests / (double) seconds;\r\n        RateLimiter limiter = map.computeIfAbsent(name, key -> RateLimiter.create(rate));\r\n        if (limiter != null) {\r\n            //检查并修改\r\n            if (limiter.getRate() != rate) {\r\n                limiter.setRate(rate);\r\n            }\r\n            return limiter.tryAcquire(permits, waitTime, TimeUnit.SECONDS);\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskFactory.java\npublic class TaskFactory {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskFactory.class);\n\n    /**\n     * rabbitTemplate模板.\n     */\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * 全局sequence序列，主要用于taskLog日志。\n     */\n    private GlobalSequenceManager globalSequenceManager;\n\n    /**\n     * 用于本地执行任务的taskConsumer。\n     */\n    private TaskRunnerContainer taskRunnerContainer;\n\n    /**\n     * rpc异步调用线程池\n     */\n    private ExecutorService taskRpcService = null;\n\n    /**\n     * 最大重试次数。\n     */\n    private static final int MAX_RETRY_TIMES = 10;\n\n\n    public TaskFactory(TaskProperties taskProperties, RabbitTemplate rabbitTemplate,\n                       TaskRunnerContainer taskRunnerContainer, GlobalSequenceManager globalSequenceManager) {\n        this.rabbitTemplate = rabbitTemplate;\n        this.taskRunnerContainer = taskRunnerContainer;\n        this.globalSequenceManager = globalSequenceManager;\n        taskRpcService = new ThreadPoolExecutor(taskProperties.getTaskRpcMinThreadNum(),\n                taskProperties.getTaskRpcMaxThreadNum(), 20L, TimeUnit.SECONDS, new SynchronousQueue<>(),\n                new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"TaskRpc-%d\").build(), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    }\n\n    /**\n     * 把任务发送到队列中\n     *\n     * @param taskData 任务数据\n     */\n    public void sendToQueue(final TaskData<?, ?> taskData) {\n        Message message = buildTaskQueueMessage(taskData);\n        String queue = message.getMessageProperties().getConsumerQueue();\n        //此处可能出现The channelMax limit is reached.报错，所以进行重试。\n        for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n            try {\n                if (i > 0) {\n                    Thread.sleep(i * 500);\n                }\n                rabbitTemplate.send(queue, queue, message);\n                return;\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n        throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n    }\n\n    /**\n     * 构造Task消息对象，此方法用于提前构造TaskData。\n     *\n     * @param taskData\n     * @return\n     */\n    private Message buildTaskQueueMessage(final TaskData taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        taskData.setRunType(TaskData.RUN_TYPE_GLOBAL);\n        MessageProperties messageProperties = new MessageProperties();\n        messageProperties.setConsumerQueue(TaskMetaInfoManager.getFitQueue(taskData));\n        Message msg = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n        return msg;\n    }\n\n    /**\n     * 同步执行任务，可能会导致阻塞。\n     * 在调用的时候，尤其要注意，taskData对象不可改变！\n     *\n     * @param taskData 任务数据\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTask(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // 当自动RPC，并且本地有runner，而且target匹配的时候，运行在本地模式下。\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // 启动本地运行模式。\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //加入优先级信息。\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            // 全局运行模式\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            //此处可能出现The channelMax limit is reached.报错，所以进行重试。\n            for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                try {\n                    if (i > 0) {\n                        Thread.sleep(i * 500);\n                    }\n                    Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                    return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                }\n            }\n            throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n        }\n    }\n\n    /**\n     * 同步执行任务，可能会导致阻塞。\n     * 在调用的时候，尤其要注意，taskData对象不可改变！\n     *\n     * @param taskData 任务数据\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTaskLocal(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // 当自动RPC，并且本地有runner，而且target匹配的时候，运行在本地模式下。\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // 启动本地运行模式。\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            throw new TaskRuntimeException(taskData.getClass().getName() + \" is not a local task! \");\n        }\n    }\n\n    /**\n     * 远程运行任务，并返回future<TaskData<?,?>>。 如果需要获得数据，可以使用futrue.get()来获得。\n     * 此方法要谨慎使用，因为task存在限速，大并发下可能会导致线程数超。\n     * 在调用的时候，尤其要注意，taskData对象不可改变！\n     *\n     * @param taskData 任务数据\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> Future<TaskData<TP, RD>> runTaskAsync(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n\n        // 当自动RPC，并且本地有runner，而且target匹配的时候，运行在本地模式下。\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // 启动本地运行模式。\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            // 启动本地运行模式。\n            return taskRpcService.submit(() -> {\n                taskRunnerContainer.process(taskData);\n                return taskData;\n            });\n        } else {\n            // 全局运行模式\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //加入优先级信息。\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            return taskRpcService.submit(() -> {\n                //此处可能出现The channelMax limit is reached.报错，所以进行重试。\n                for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                    try {\n                        if (i > 0) {\n                            Thread.sleep(i * 500);\n                        }\n                        Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                        return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                    } catch (Exception e) {\n                        log.error(e.getMessage(), e);\n                    }\n                }\n                throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n            });\n        }\n    }\n\n    /**\n     * 获得队列信息。\n     *\n     * @param queueName\n     * @return 0 是消息数量 1 是消费者数量\n     */\n    public int[] getQueueInfo(String queueName) {\n        AMQP.Queue.DeclareOk declareOk = this.rabbitTemplate.execute(new ChannelCallback<AMQP.Queue.DeclareOk>() {\n            public AMQP.Queue.DeclareOk doInRabbit(Channel channel) throws Exception {\n                return channel.queueDeclarePassive(queueName);\n            }\n        });\n        return new int[]{declareOk.getMessageCount(), declareOk.getConsumerCount()};\n    }\n\n    /**\n     * 清除队列。\n     *\n     * @param queueName\n     * @return 被清除的队列数\n     */\n    public int purgeQueue(String queueName) {\n        return this.rabbitTemplate.execute(channel -> {\n            AMQP.Queue.PurgeOk queuePurged = channel.queuePurge(queueName);\n            return queuePurged.getMessageCount();\n        });\n    }\n\n}\nsrc/main/java/uw/task/listener/RunnerTaskListener.java\npublic interface RunnerTaskListener {\r\n\r\n    /**\r\n     * 执行前的监听器。\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPreExecute(TaskData data);\r\n\r\n    /**\r\n     * 执行后的监听器。\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPostExecute(TaskData data);\r\n\r\n}\r\nsrc/main/java/uw/task/util/GlobalRateLimiter.java\npublic class GlobalRateLimiter {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(GlobalRateLimiter.class);\r\n\r\n    private static final String REDIS_PREFIX = \"TaskRateLimit:\";\r\n\r\n    private final RedisTemplate<String, Long> redisTemplate;\r\n\r\n    /**\r\n     * LUA脚本。\r\n     * 返回值为：可用请求数,等待毫秒数。\r\n     */\r\n    private static final RedisScript<Long> LUA_RATE_LIMIT = RedisScript.of(\r\n            \"local key = KEYS[1];\\n\" +\r\n                    \"local requests = tonumber(ARGV[1]);\\n\" +\r\n                    \"local millis = tonumber(ARGV[2])*1000;\\n\" +\r\n                    \"local permits = tonumber(ARGV[3]);\\n\" +\r\n                    \"local remainRequests=0;\\n\" +\r\n                    \"local waitMillis=0;\\n\" +\r\n                    \"local nowRate= redis.call('INCRBY', key,permits);\\n\" +\r\n                    \"if (nowRate==permits) then \\n\" +//如果是第一次执行，设置有效期保护。\r\n                    \"    redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"end\\n\" +\r\n                    \"remainRequests = requests-nowRate;\\n\" +\r\n                    \"if (remainRequests<1) then \\n\" +//请求数超过限制\r\n                    \"    waitMillis = redis.call('PTTL',key);\\n\" +\r\n                    \"    if (waitMillis == -1) then \\n\" +\r\n                    \"        redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"        waitMillis = millis;\\n\" +\r\n                    \"    end\\n\" +\r\n                    \"end \\n\" +\r\n                    \"return waitMillis\", Long.class);\r\n\r\n\r\n    public GlobalRateLimiter(final RedisConnectionFactory redisConnectionFactory) {\r\n        redisTemplate = new RedisTemplate<String, Long>();\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setValueSerializer(new GenericToStringSerializer<Long>(Long.class));\r\n        redisTemplate.setExposeConnection(true);\r\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\r\n        redisTemplate.afterPropertiesSet();\r\n    }\r\n\r\n    /**\r\n     * 尝试可否获得授权。\r\n     *\r\n     * @param permits       申请访问次数\r\n     * @return 如果未超限则返回0，-1为不确定时间，其他为需要等待的毫秒数\r\n     */\r\n    public long tryAcquire(String name, int requests, int seconds, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return 0;\r\n        }\r\n        Long waitLimit = redisTemplate.execute(LUA_RATE_LIMIT, Collections.singletonList(REDIS_PREFIX + name), requests,seconds, permits);\r\n        if (waitLimit==null)\r\n            return 0;\r\n        else\r\n            return waitLimit;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/exception/TaskPartnerException.java\npublic class TaskPartnerException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> 的注释\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskPartnerException() {\r\n        super();\r\n    }\r\n\r\n    public TaskPartnerException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskPartnerException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskPartnerException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/TaskData.java\npublic class TaskData<TP, RD> implements Serializable {\n\n    /**\n     * serialVersionUID\n     */\n    private static final long serialVersionUID = 1333167065535557828L;\n\n    /**\n     * 任务状态:未设置\n     */\n    public static final int STATE_UNKNOWN = 0;\n\n    /**\n     * 任务状态:成功\n     */\n    public static final int STATE_SUCCESS = 1;\n\n    /**\n     * 任务状态:程序错误\n     */\n    public static final int STATE_FAIL_PROGRAM = 2;\n\n    /**\n     * 任务状态:配置错误，如超过流量限制\n     */\n    public static final int STATE_FAIL_CONFIG = 3;\n\n    /**\n     * 任务状态:第三方接口错误\n     */\n    public static final int STATE_FAIL_PARTNER = 4;\n\n    /**\n     * 任务状态:数据错误\n     */\n    public static final int STATE_FAIL_DATA = 5;\n\n    /**\n     * 运行模式：本地运行\n     */\n    public static final int RUN_TYPE_LOCAL = 1;\n\n    /**\n     * 运行模式：全局运行\n     */\n    public static final int RUN_TYPE_GLOBAL = 3;\n\n    /**\n     * 运行模式：全局运行RPC返回结果\n     */\n    public static final int RUN_TYPE_GLOBAL_RPC = 5;\n\n    /**\n     * 运行模式：自动运行RPC返回结果，使用此模式，会自动选择本地还远程运行模式。\n     */\n    public static final int RUN_TYPE_AUTO_RPC = 6;\n\n    /**\n     * 自动重试[为了兼容,默认开启重试]\n     */\n    public static final int RETRY_TYPE_AUTO = 0;\n\n    /**\n     * 用户手工重试\n     */\n    public static final int RETRY_TYPE_MANUAL = 1;\n\n    /**\n     * id，此序列值由框架自动生成，无需手工设置。\n     */\n    private long id;\n\n    /**\n     * 关联TAG，由调用方设定，用于第三方统计信息。\n     */\n    private String refTag;\n\n    /**\n     * 关联id，由调用方根据需要设置，用于第三方统计信息。\n     */\n    private long refId;\n\n    /**\n     * 关联子id，由调用方根据需要设置，用于第三方统计信息。\n     */\n    private long refSubId;\n\n    /**\n     * 关联对象，此对象不存入数据库，但可以通过Listener来访问。\n     */\n    @JsonIgnore\n    private Object refObject;\n\n    /**\n     * 流量限制TAG。\n     */\n    private String rateLimitTag;\n\n    /**\n     * 需要执行的类名，此数值必须由调用方设置。\n     */\n    private String taskClass = \"\";\n\n    /**\n     * 任务标签，用于细分任务队列，支持多实例运行。\n     */\n    private String taskTag = \"\";\n\n    /**\n     * 任务延迟毫秒数。一般这个时间不宜太长，大多数情况下不要超过60秒。\n     */\n    private long taskDelay;\n\n    /**\n     * 执行参数，此数值必须有调用方设置。\n     */\n    private TP taskParam;\n\n    /**\n     * 任务运行类型，默认为自动RPC，根据情况选择本地还是远程运行。\n     */\n    private int runType = RUN_TYPE_AUTO_RPC;\n\n    /**\n     * 重试类型\n     */\n    private int retryType;\n\n    /**\n     * 指定运行目标。\n     */\n    private String runTarget = \"\";\n\n    /**\n     * 任务运行时主机IP，此信息由框架自动设置。\n     */\n    private String hostIp;\n\n    /**\n     * 任务运行时主机ID（可能为docker的ContainerID），此信息由框架自动设置。\n     */\n    private String hostId;\n\n    /**\n     * 进入队列时间，此信息由框架自动设置。\n     */\n    private Date queueDate;\n\n    /**\n     * 开始消费时间，此信息由框架自动设置。\n     */\n    private Date consumeDate;\n\n    /**\n     * 开始运行时间，此信息由框架自动设置。\n     */\n    private Date runDate;\n\n    /**\n     * 运行结束日期，此信息由框架自动设置。\n     */\n    private Date finishDate;\n\n    /**\n     * 执行信息，用于存储框架自动设置。\n     */\n    private RD resultData;\n\n    /**\n     * 出错信息\n     */\n    private String errorInfo;\n\n    /**\n     * 已经执行的次数，此信息由框架自动设置。\n     */\n    private int ranTimes;\n\n    /**\n     * 执行状态，此信息由框架根据异常自动设置。\n     */\n    private int state;\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * @param id the id to set\n     */\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return refId;\n    }\n\n    /**\n     * @param refId the refId to set\n     */\n    public void setRefId(long refId) {\n        this.refId = refId;\n    }\n\n    /**\n\t * @return the refSubId\n\t */\n\tpublic long getRefSubId() {\n\t\treturn refSubId;\n\t}\n\n\t/**\n\t * @param refSubId the refSubId to set\n\t */\n\tpublic void setRefSubId(long refSubId) {\n\t\tthis.refSubId = refSubId;\n\t}\n\n\t/**\n\t * @return the refTag\n\t */\n\tpublic String getRefTag() {\n\t\treturn refTag;\n\t}\n\n\t/**\n\t * @param refTag the refTag to set\n\t */\n\tpublic void setRefTag(String refTag) {\n\t\tthis.refTag = refTag;\n\t}\n\n\t/**\n\t * @return the rateLimitTag\n\t */\n\tpublic String getRateLimitTag() {\n\t\treturn rateLimitTag;\n\t}\n\n\t/**\n\t * @param rateLimitTag the rateLimitTag to set\n\t */\n\tpublic void setRateLimitTag(String rateLimitTag) {\n\t\tthis.rateLimitTag = rateLimitTag;\n\t}\n\n\t/**\n\t * @return the refObject\n\t */\n\tpublic Object getRefObject() {\n\t\treturn refObject;\n\t}\n\n    /**\n     * @param refObject the refObject to set\n     */\n    public void setRefObject(Object refObject) {\n        this.refObject = refObject;\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    /**\n     * @param taskClass the taskClass to set\n     */\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    /**\n\t * @return the taskTag\n\t */\n\tpublic String getTaskTag() {\n\t\treturn taskTag;\n\t}\n\n\tpublic long getTaskDelay() {\n\t\treturn taskDelay;\n\t}\n\n\tpublic void setTaskDelay(long taskDelay) {\n\t\tthis.taskDelay = taskDelay;\n\t}\n\n\t/**\n\t * @param taskTag the taskTag to set\n\t */\n\tpublic void setTaskTag(String taskTag) {\n\t\tthis.taskTag = taskTag;\n\t}\n\n\t/**\n     * @return the taskParam\n     */\n    public TP getTaskParam() {\n        return taskParam;\n    }\n\n    /**\n     * @param taskParam the taskParam to set\n     */\n    public void setTaskParam(TP taskParam) {\n        this.taskParam = taskParam;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return runType;\n    }\n\n    /**\n     * @param runType the runType to set\n     */\n    public void setRunType(int runType) {\n        this.runType = runType;\n    }\n\n    public int getRetryType() {\n        return retryType;\n    }\n\n    public void setRetryType(int retryType) {\n        this.retryType = retryType;\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    /**\n     * @param runTarget the runTarget to set\n     */\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * @param hostIp the hostIp to set\n     */\n    public void setHostIp(String hostIp) {\n        this.hostIp = hostIp;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return queueDate;\n    }\n\n    /**\n     * @param queueDate the queueDate to set\n     */\n    public void setQueueDate(Date queueDate) {\n        this.queueDate = queueDate;\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return consumeDate;\n    }\n\n    /**\n     * @param consumeDate the consumeDate to set\n     */\n    public void setConsumeDate(Date consumeDate) {\n        this.consumeDate = consumeDate;\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return runDate;\n    }\n\n    /**\n     * @param runDate the runDate to set\n     */\n    public void setRunDate(Date runDate) {\n        this.runDate = runDate;\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return finishDate;\n    }\n\n    /**\n     * @param finishDate the finishDate to set\n     */\n    public void setFinishDate(Date finishDate) {\n        this.finishDate = finishDate;\n    }\n\n    /**\n     * @return the resultData\n     */\n    public RD getResultData() {\n        return resultData;\n    }\n\n    /**\n     * @param resultData the resultData to set\n     */\n    public void setResultData(RD resultData) {\n        this.resultData = resultData;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return errorInfo;\n    }\n\n    /**\n     * @param errorInfo the errorInfo to set\n     */\n    public void setErrorInfo(String errorInfo) {\n        this.errorInfo = errorInfo;\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return ranTimes;\n    }\n\n    /**\n     * @param ranTimes the ranTimes to set\n     */\n    public void setRanTimes(int ranTimes) {\n        this.ranTimes = ranTimes;\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return state;\n    }\n\n    /**\n     * @param status the status to set\n     */\n    public void setState(int status) {\n        this.state = status;\n    }\n\n}\nsrc/main/java/uw/task/TaskRunner.java\npublic abstract class TaskRunner<TP, RD> {\r\n\r\n    /**\r\n     * 执行任务。\r\n     * 业务层面的异常请根据实际情况手动Throw TaskException:\r\n     * 目前支持的异常:\r\n     * 1. TaskDataException 任务数据异常\r\n     * 2. TaskPartnerException 任务合作方异常\r\n     *\r\n     * @param taskData 数据\r\n     * @throws Exception 异常\r\n     * @return 指定的返回对象\r\n     */\r\n    public abstract RD runTask(TaskData<TP, RD> taskData) throws Exception;\r\n\r\n    /**\r\n     * 初始化配置信息\r\n     *\r\n     * @return TaskRunnerConfig配置\r\n     */\r\n    public abstract TaskRunnerConfig initConfig();\r\n\r\n    /**\r\n     * 初始化联系人信息\r\n     *\r\n     * @return TaskContact联系人信息\r\n     */\r\n    public abstract TaskContact initContact();\r\n}\nsrc/main/java/uw/task/conf/TaskMetaInfoManager.java\npublic class TaskMetaInfoManager {\r\n\r\n\t/**\r\n\t * 运行主机配置\r\n\t */\r\n\tstatic List<String> targetConfig = null;\r\n\r\n\t/**\r\n\t * Runner任务实例缓存。\r\n\t */\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tstatic Map<String, TaskRunner> runnerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Cron任务实例缓存。\r\n\t */\r\n\tstatic Map<String, TaskCroner> cronerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Runner任务配置缓存\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskRunnerConfig> runnerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * Cron任务配置缓存。\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskCronerConfig> cronerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * 获得任务运行实例。\r\n\t *\r\n\t * @param taskClass\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunner<?, ?> getRunner(String taskClass) {\r\n\t\treturn runnerMap.get(taskClass);\r\n\t}\r\n\r\n\t/**\r\n\t * 检查一个runner是否可以在本地运行。\r\n\t * \r\n\t * @param taskData\r\n\t * @return\r\n\t */\r\n\tpublic static boolean checkRunnerRunLocal(TaskData<?, ?> taskData) {\r\n\t\treturn runnerMap.containsKey(taskData.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * 根据服务器端Queue列表，返回合适的key。\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getFitQueue(TaskData<?, ?> data) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tif (runnerConfigMap.containsKey(all)) {\r\n\t\t\treturn all;\r\n\t\t}\r\n        // 检测去除TAG的情况\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            if (runnerConfigMap.containsKey(test)) {\r\n                return test;\r\n            }\r\n        }\r\n\t\t// 检测去除目标的情况\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 两个都去除的情况\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 最后都没匹配到，返回原始数据\r\n\t\treturn all;\r\n\t}\r\n\r\n\t/**\r\n\t * 获得任务配置\r\n\t *\r\n\t * @param data\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunnerConfig getRunnerConfig(TaskData<?, ?> data) {\r\n\t\tTaskRunnerConfig config = null;\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tconfig = runnerConfigMap.get(all);\r\n\t\tif (config != null) {\r\n\t\t\treturn config;\r\n\t\t}\r\n        // 检测去除TAG的情况\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            config = runnerConfigMap.get(test);\r\n            if (config != null) {\r\n                return config;\r\n            }\r\n        }\r\n\t\t// 检测去除目标的情况\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 两个都去除的情况\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new RuntimeException(\"找不到任务配置: taskClass = \" + data.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * 更新系统队列表。\r\n\t * \r\n\t * @param config\r\n\t */\r\n\tstatic void updateSysQueue(final TaskRunnerConfig config) {\r\n\t\tString key = getRunnerConfigKey(config);\r\n\t\t// 检测是否老的TaskRunnerConfig是否是本地的完整配置，如果是，则不管。\r\n\t\tTaskRunnerConfig old = runnerConfigMap.get(key);\r\n\t\tif (old == null || (old != null && old.getCreateDate() == null)) {\r\n\t\t\tif (config.getState() < 1) {\r\n\t\t\t\trunnerConfigMap.remove(key);\r\n\t\t\t} else {\r\n\t\t\t\trunnerConfigMap.put(key, config);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 获得croner配置键。 使用taskClass#Id$target来配置\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getCronerConfigKey(TaskCronerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskParam() != null && config.getTaskParam().length() > 0) {\r\n\t\t\tsb.append(config.getId());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * 获得Runner配置结合Host。\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getRunnerConfigKey(TaskRunnerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskTag() != null && config.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(config.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n    /**\r\n     * 获得RunnerLog配置KEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getRunnerLogKey(TaskData<?,?> log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskTag() != null && log.getTaskTag().length() > 0) {\r\n            sb.append(log.getTaskTag());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * 获得CronerLog配置KEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getCronerLogKey(TaskCronerLog log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskParam() != null && log.getTaskParam().length()>0){\r\n            sb.append(log.getTaskParam());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\nsrc/main/java/uw/task/api/TaskAPI.java\npublic class TaskAPI {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskAPI.class);\n\n    /**\n     * Task配置文件\n     */\n    private TaskProperties taskProperties;\n\n    /**\n     * Rest模板类\n     */\n    private RestTemplate restTemplate;\n\n    /**\n     * 日志客户端。\n     */\n    private LogClient logClient = null;\n\n    /**\n     * 本机的外网IP\n     */\n    private String hostIp = \"\";\n\n    public TaskAPI(final TaskProperties taskProperties, final RestTemplate restTemplate,\n                   final LogClient logClient) {\n        this.taskProperties = taskProperties;\n        this.restTemplate = restTemplate;\n        this.logClient = logClient;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * 更新当前主机目标配置。\n     *\n     * @return\n     */\n    public List<String> getServerTargetConfig() {\n        List<String> targetConfig = null;\n        // 判断是否是私有模式。\n        boolean privacyMode = taskProperties.isPrivacyMode();\n        try {\n            String[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/target/config?targetType={targetType}\", String[].class,\n                    privacyMode ? 1 : 0);\n            targetConfig = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getHostConfig()服务端Target配置拉取异常:{}\", e.getMessage());\n        }\n        if (targetConfig == null || targetConfig.size() == 0) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"获得主机Target服务端配置失败，启用默认配置项!\");\n            }\n            targetConfig = new ArrayList<>();\n            if (!privacyMode) {\n                targetConfig.add(\"\");\n            }\n        }\n        return targetConfig;\n    }\n\n    /**\n     * 更新当前主机状态，返回主机IP地址。\n     *\n     * @return 主机IP地址\n     */\n    public String updateHostStatus() {\n        String ip = \"\";\n        TaskHostStatus taskHostStatus = new TaskHostStatus();\n        taskHostStatus.setHostId(taskProperties.getHostId());\n        taskHostStatus.setTaskProject(taskProperties.getProject());\n        try {\n            ip = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/host/status\", taskHostStatus,\n                    String.class);\n            hostIp = ip;\n        } catch (Exception e) {\n            log.error(\"TaskAPI.updateHostStatus()服务端主机状态更新异常:{}\", e.getMessage());\n        }\n        return ip;\n    }\n\n    /**\n     * 初始化CronerConfig。\n     *\n     * @param config\n     */\n    public TaskCronerConfig initTaskCronerConfig(TaskCronerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/croner/config\", config,\n                    TaskCronerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskCronerConfig上传Croner配置到服务端异常:{}\", e.getMessage());\n        }\n        return config;\n    }\n\n    /**\n     * 初始化RunnerConfig\n     *\n     * @param config\n     */\n    public TaskRunnerConfig initTaskRunnerConfig(TaskRunnerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/runner/config\", config,\n                    TaskRunnerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskRunnerConfig上传Runner配置到服务端异常:{}\", e.getMessage());\n        }\n        return config;\n\n    }\n\n    /**\n     * 初始化联系人信息。\n     *\n     * @param contact\n     */\n    public void initTaskContact(TaskContact contact) {\n        try {\n            restTemplate.postForLocation(taskProperties.getTaskCenterHost() + \"/taskapi/contact\", contact);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskContact上传联系人信息到服务端异常:{}\", e.getMessage());\n        }\n    }\n\n    /**\n     * 根据更新时间获得变化的TaskRunner队列列表。\n     *\n     * @param lastUpdateTime 最后更新时间\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerQueueList(long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/runner/queue?lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerQueueList()服务端主机状态更新异常:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * 根据包名前缀获得TaskRunner配置列表。\n     *\n     * @param taskPackage\n     * @param lastUpdateTime 最后更新时间\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/runner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerConfigList()服务端主机状态更新异常:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * 根据包名前缀获得TaskCroner配置列表。\n     *\n     * @param taskPackage\n     * @param lastUpdateTime 最后更新时间\n     * @return\n     */\n    public List<TaskCronerConfig> getTaskCronerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskCronerConfig> list = null;\n        try {\n            TaskCronerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskCronerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskCronerConfigList()服务端主机状态更新异常:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * 发送Runner任务日志。\n     *\n     * @param log\n     */\n    public void sendTaskRunnerLog(TaskRunnerLog log) {\n        logClient.log(log);\n    }\n\n    /**\n     * 发送CronLog日志\n     *\n     * @param configId      配置Id,方便更新下一次执行时间\n     * @param taskCronerLog 日志对象\n     */\n    public void sendTaskCronerLog(long configId, TaskCronerLog taskCronerLog) {\n        try {\n            restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/tick?id={id}&nextDate={nextDate}\",\n                    Integer.class, configId, taskCronerLog.getNextDate().getTime());\n        } catch (Exception e) {\n            log.error(\"TaskAPI.cornerTick()服务端主机状态更新异常: \" + e.getMessage(), e);\n        }\n\n        int logLevel = taskCronerLog.getLogLevel();\n        int logLimitSize = taskCronerLog.getLogLimitSize();\n        if (logLevel > TaskCronerConfig.TASK_LOG_TYPE_NONE) {\n            switch (logLevel) {\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD: {\n                    taskCronerLog.setTaskParam(null);\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM: {\n                    String taskParam = taskCronerLog.getTaskParam();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                        taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA: {\n                    String resultData = taskCronerLog.getResultData();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                        taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setTaskParam(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_ALL: {\n                    if (logLimitSize > 0) {\n                        String taskParam = taskCronerLog.getTaskParam();\n                        String resultData = taskCronerLog.getResultData();\n                        if (StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                            taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                        }\n                        if (StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                            taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                        }\n                    }\n                }\n                break;\n            }\n            logClient.log(taskCronerLog);\n        }\n    }\n}\nsrc/main/java/uw/task/exception/TaskDataException.java\npublic class TaskDataException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> 的注释\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskDataException() {\r\n        super();\r\n    }\r\n\r\n    public TaskDataException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskDataException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskDataException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/entity/TaskRunnerConfig.java\npublic class TaskRunnerConfig implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * 限速类型：不限速\n     */\n    public static final int RATE_LIMIT_NONE = 0;\n\n    /**\n     * 限速类型：本地进程限速\n     */\n    public static final int RATE_LIMIT_LOCAL = 1;\n\n    /**\n     * 限速类型：本地TASK限速\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK = 2;\n\n    /**\n     * 限速类型：本地TASK+TAG限速\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK_TAG = 3;\n\n    /**\n     * 限速类型：全局主机HOST限速\n     */\n    public static final int RATE_LIMIT_GLOBAL_HOST = 4;\n\n    /**\n     * 限速类型：全局TAG限速\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG = 5;\n\n    /**\n     * 限速类型：全局TASK限速\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK = 6;\n\n    /**\n     * 限速类型：全局TAG+HOST限速\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG_HOST = 7;\n\n    /**\n     * 限速类型：全局TASK+IP限速\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_HOST = 8;\n\n    /**\n     * 限速类型：全局TASK+TAG限速\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG = 9;\n\n    /**\n     * 限速类型：全局TASK+TAG+IP限速\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG_HOST = 10;\n\n    /**\n     * 什么都不记录\n     */\n    public static final int TASK_LOG_TYPE_NONE = -1;\n\n    /**\n     * 记录日志\n     */\n    public static final int TASK_LOG_TYPE_RECORD = 0;\n\n    /**\n     * 记录日志,含请求参数\n     */\n    public static final int TASK_LOG_TYPE_RECORD_TASK_PARAM = 1;\n\n    /**\n     * 记录日志,含返回参数\n     */\n    public static final int TASK_LOG_TYPE_RECORD_RESULT_DATA = 2;\n\n    /**\n     * 记录全部日志\n     */\n    public static final int TASK_LOG_TYPE_RECORD_ALL = 3;\n\n    private long id;\n\n    /**\n     * 任务名称\n     */\n    private String taskName;\n\n    /**\n     * 任务描述\n     */\n    private String taskDesc;\n\n    /**\n     * 执行类信息\n     */\n    private String taskClass;\n\n    /**\n     * 执行类TAG，可能用于区分子任务\n     */\n    private String taskTag;\n\n    /**\n     * 消费者的数量\n     */\n    private int consumerNum = 1;\n\n    /**\n     * 预取任务数。\n     */\n    private int prefetchNum = 1;\n\n    /**\n     * 详见流量限制类型说明。\n     */\n    private int rateLimitType = RATE_LIMIT_NONE;\n\n    /**\n     * 流量限定数值，默认为10次\n     */\n    private int rateLimitValue = 10;\n\n    /**\n     * 流量限定时间(S)，默认为1秒\n     */\n    private int rateLimitTime = 1;\n\n    /**\n     * 当发生流量限制时，等待的秒数，默认300秒\n     */\n    private int rateLimitWait = 30;\n\n    /**\n     * 超过流量限制重试次数，默认不在重试，放弃任务。\n     */\n    private int retryTimesByOverrated = 0;\n\n    /**\n     * 对方接口错误重试次数，默认不再重试，放弃任务。\n     */\n    private int retryTimesByPartner = 0;\n\n    /**\n     * 运行目标，默认不指定\n     */\n    private String runTarget = \"\";\n\n    /**\n     * 失败率\n     */\n    private int failRate;\n\n    /**\n     * 接口失败率\n     */\n    private int failPartnerRate;\n\n    /**\n     * 程序失败率\n     */\n    private int failProgramRate;\n\n    /**\n     * 配置失败率\n     */\n    private int failConfigRate;\n\n    /**\n     * 数据失败率\n     */\n    private int failDataRate;\n\n    /**\n     * 队列等待超时\n     */\n    private int queueTimeout;\n\n    /**\n     * 等待超时\n     */\n    private int waitTimeout;\n\n    /**\n     * 运行超时\n     */\n    private int runTimeout;\n\n    /**\n     * 创建日期。\n     */\n    private Date createDate;\n\n    /**\n     * 修改日期。\n     */\n    private Date modifyDate;\n\n    /**\n     * 状态值\n     */\n    private int state = 1;\n\n    /**\n     * 详见日志类型说明\n     */\n    private int logLevel = TASK_LOG_TYPE_RECORD;\n\n    /**\n     * 日志字符串字段大小限制: 0 表示无限制\n     */\n    private int logLimitSize = 0;\n\n    public TaskRunnerConfig() {\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public String getTaskName() {\n        return taskName;\n    }\n\n    public void setTaskName(String taskName) {\n        this.taskName = taskName;\n    }\n\n    public String getTaskDesc() {\n        return taskDesc;\n    }\n\n    public void setTaskDesc(String taskDesc) {\n        this.taskDesc = taskDesc;\n    }\n\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    public String getTaskTag() {\n        return taskTag;\n    }\n\n    public void setTaskTag(String taskTag) {\n        this.taskTag = taskTag;\n    }\n\n    public int getConsumerNum() {\n        return consumerNum;\n    }\n\n    public void setConsumerNum(int consumerNum) {\n        this.consumerNum = consumerNum;\n    }\n\n    public int getPrefetchNum() {\n        return prefetchNum;\n    }\n\n    public void setPrefetchNum(int prefetchNum) {\n        this.prefetchNum = prefetchNum;\n    }\n\n    public int getRateLimitType() {\n        return rateLimitType;\n    }\n\n    public void setRateLimitType(int rateLimitType) {\n        this.rateLimitType = rateLimitType;\n    }\n\n    public int getRateLimitValue() {\n        return rateLimitValue;\n    }\n\n    public void setRateLimitValue(int rateLimitValue) {\n        this.rateLimitValue = rateLimitValue;\n    }\n\n    public int getRateLimitTime() {\n        return rateLimitTime;\n    }\n\n    public void setRateLimitTime(int rateLimitTime) {\n        this.rateLimitTime = rateLimitTime;\n    }\n\n    public int getRateLimitWait() {\n        return rateLimitWait;\n    }\n\n    public void setRateLimitWait(int rateLimitWait) {\n        this.rateLimitWait = rateLimitWait;\n    }\n\n    public int getRetryTimesByOverrated() {\n        return retryTimesByOverrated;\n    }\n\n    public void setRetryTimesByOverrated(int retryTimesByOverrated) {\n        this.retryTimesByOverrated = retryTimesByOverrated;\n    }\n\n    public int getRetryTimesByPartner() {\n        return retryTimesByPartner;\n    }\n\n    public void setRetryTimesByPartner(int retryTimesByPartner) {\n        this.retryTimesByPartner = retryTimesByPartner;\n    }\n\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    public int getFailRate() {\n        return failRate;\n    }\n\n    public void setFailRate(int failRate) {\n        this.failRate = failRate;\n    }\n\n    public int getFailPartnerRate() {\n        return failPartnerRate;\n    }\n\n    public void setFailPartnerRate(int failPartnerRate) {\n        this.failPartnerRate = failPartnerRate;\n    }\n\n    public int getFailProgramRate() {\n        return failProgramRate;\n    }\n\n    public void setFailProgramRate(int failProgramRate) {\n        this.failProgramRate = failProgramRate;\n    }\n\n    public int getFailConfigRate() {\n        return failConfigRate;\n    }\n\n    public void setFailConfigRate(int failConfigRate) {\n        this.failConfigRate = failConfigRate;\n    }\n\n    public int getFailDataRate() {\n        return failDataRate;\n    }\n\n    public void setFailDataRate(int failDataRate) {\n        this.failDataRate = failDataRate;\n    }\n\n    public int getQueueTimeout() {\n        return queueTimeout;\n    }\n\n    public void setQueueTimeout(int queueTimeout) {\n        this.queueTimeout = queueTimeout;\n    }\n\n    public int getWaitTimeout() {\n        return waitTimeout;\n    }\n\n    public void setWaitTimeout(int waitTimeout) {\n        this.waitTimeout = waitTimeout;\n    }\n\n    public int getRunTimeout() {\n        return runTimeout;\n    }\n\n    public void setRunTimeout(int runTimeout) {\n        this.runTimeout = runTimeout;\n    }\n\n    public Date getCreateDate() {\n        return createDate;\n    }\n\n    public void setCreateDate(Date createDate) {\n        this.createDate = createDate;\n    }\n\n    public Date getModifyDate() {\n        return modifyDate;\n    }\n\n    public void setModifyDate(Date modifyDate) {\n        this.modifyDate = modifyDate;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n    public void setState(int state) {\n        this.state = state;\n    }\n\n    public int getLogLevel() {\n        return logLevel;\n    }\n\n    public void setLogLevel(int logLevel) {\n        this.logLevel = logLevel;\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/util/MiscUtils.java\npublic class MiscUtils {\r\n\r\n    /**\r\n     * taskData的copy器。\r\n     */\r\n    private static BeanCopier beanCopier = BeanCopier.create(TaskData.class, TaskData.class, false);\r\n\r\n    /**\r\n     * copy taskData对象。\r\n     *\r\n     * @param srcData\r\n     * @param dstData\r\n     */\r\n    public static void copyTaskData(TaskData srcData, TaskData dstData) {\r\n        beanCopier.copy(srcData, dstData, null);\r\n    }\r\n\r\n    /**\r\n     * 打印异常信息，屏蔽掉spring自己的堆栈输出。\r\n     *\r\n     * @param e 需要打印的异常信息\r\n     * @return\r\n     */\r\n    public static String exceptionToString(Throwable e) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(e.toString()).append(\"\\n\");\r\n\r\n        StackTraceElement[] trace = e.getStackTrace();\r\n        for (StackTraceElement traceElement : trace) {\r\n            if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                continue;\r\n            }\r\n            if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                continue;\r\n            }\r\n            sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n        }\r\n        Throwable ourCause = e.getCause();\r\n        if (ourCause != null) {\r\n            sb.append(\"CAUSE BY\").append(ourCause.toString()).append(\"\\n\");\r\n            trace = ourCause.getStackTrace();\r\n            for (StackTraceElement traceElement : trace) {\r\n                if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                    continue;\r\n                }\r\n                if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                    continue;\r\n                }\r\n                sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskListenerManager.java\npublic class TaskListenerManager {\r\n\r\n\t/**\r\n\t * runner监听器列表。\r\n\t */\r\n    private ArrayList<RunnerTaskListener> runnerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * croner监听器列表。\r\n     */\r\n    private ArrayList<CronerTaskListener> cronerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * 加入一个RunnerListener。\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addRunnerListener(RunnerTaskListener listener) {\r\n        runnerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * 加入一个RunnerListener.\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addCronerListener(CronerTaskListener listener) {\r\n        cronerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * 清除RunnerListener列表\r\n     */\r\n    public void clearRunnerListener() {\r\n        runnerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * 清除RunnerListener列表\r\n     */\r\n    public void clearCronerListener() {\r\n        cronerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * 获得Runner Listener列表。\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<RunnerTaskListener> getRunnerListenerList() {\r\n        return runnerListenerList;\r\n    }\r\n\r\n    /**\r\n     * 获得Croner Listener列表。\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<CronerTaskListener> getCronerListenerList() {\r\n        return cronerListenerList;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/entity/TaskRunnerLog.java\n@JsonIgnoreProperties({\"taskData\"})\npublic class TaskRunnerLog extends LogBaseVo {\n\n    private static final Logger logger = LoggerFactory.getLogger(TaskRunnerLog.class);\n\n    private TaskData taskData;\n\n    /**\n     * logLimitSize。\n     */\n    private int logLimitSize;\n\n    public TaskRunnerLog(TaskData taskData) {\n        this.taskData = taskData;\n    }\n\n    public TaskData getTaskData() {\n        return taskData;\n    }\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return taskData.getId();\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return taskData.getRefId();\n    }\n\n    /**\n     * @return the refSubId\n     */\n    public long getRefSubId() {\n        return taskData.getRefSubId();\n    }\n\n    /**\n     * @return the refTag\n     */\n    public String getRefTag() {\n        return taskData.getRefTag();\n    }\n\n    /**\n     * @return the rateLimitTag\n     */\n    public String getRateLimitTag() {\n        return taskData.getRateLimitTag();\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskData.getTaskClass();\n    }\n\n    /**\n     * @return the taskTag\n     */\n    public String getTaskTag() {\n        return taskData.getTaskTag();\n    }\n\n    public long getTaskDelay() {\n        return taskData.getTaskDelay();\n    }\n\n    /**\n     * @return the taskParam\n     */\n    public String getTaskParam() {\n        Object value = taskData.getTaskParam();\n        if (value != null) {\n            // 报错了\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return taskData.getRunType();\n    }\n\n    /**\n     * @return the retryType\n     */\n    public int getRetryType() {\n        return taskData.getRetryType();\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return taskData.getRunTarget();\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return taskData.getHostIp();\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return taskData.getHostId();\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return taskData.getQueueDate();\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return taskData.getConsumeDate();\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return taskData.getRunDate();\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return taskData.getFinishDate();\n    }\n\n    /**\n     * @return the resultData\n     */\n    public String getResultData() {\n        Object value = taskData.getResultData();\n        if (value != null) {\n            // 报错了\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return taskData.getErrorInfo();\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return taskData.getRanTimes();\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return taskData.getState();\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/conf/TaskProperties.java\n@ConfigurationProperties(prefix = \"uw.task\")\npublic class TaskProperties {\n\n    /**\n     * 是否启用uw-task服务注册和主机注册，默认不启用。\n     *\n     */\n    private boolean enableTaskRegistry = false;\n    /**\n     * 任务名，必须设置为基础包名。\n     */\n    private String project;\n\n    /**\n     * 私有模式。不运行全局target任务。\n     */\n    private boolean privacyMode = false;\n\n    /**\n     * croner线程数，默认在3个，建议按照实际croner任务数量*70%。\n     */\n    private int cronerThreadNum = 5;\n\n    /**\n     * RPC最小线程数,用于执行RPC调用，如不使用rpc，建议设置为1，否则按照最大并发量*10%设置。\n     */\n    private int taskRpcMinThreadNum = 1;\n\n    /**\n     * RPC最大线程数,用于执行RPC调用，超过此线程数，将会导致阻塞。\n     */\n    private int taskRpcMaxThreadNum = 100;\n\n    /**\n     * 队列任务重试延时毫秒数，默认2秒\n     */\n    private long taskQueueRetryDelay = 2000;\n\n    /**\n     *  rpc任务重试延时毫秒数，默认100毫秒\n     */\n    private long taskRpcRetryDelay = 100;\n\n    /**\n     * 运行主机ID\n     */\n    private String hostId = ManagementFactory.getRuntimeMXBean().getName();\n\n    /**\n     * 任务服务器\n     */\n    private String taskCenterHost = \"127.0.0.1\";\n\n    /**\n     * Redis配置\n     */\n    private RedisProperties redis = new RedisProperties();\n\n    /**\n     * Rabbit MQ配置\n     */\n    private RabbitProperties rabbitmq = new RabbitProperties();\n\n    public static class RedisProperties extends org.springframework.boot.autoconfigure.data.redis.RedisProperties {\n\n    }\n\n    public static class RabbitProperties extends org.springframework.boot.autoconfigure.amqp.RabbitProperties {\n\n    }\n\n    public boolean isEnableTaskRegistry() {\n        return enableTaskRegistry;\n    }\n\n    public void setEnableTaskRegistry(boolean enableTaskRegistry) {\n        this.enableTaskRegistry = enableTaskRegistry;\n    }\n\n    /**\n\t * @return the privacyMode\n\t */\n\tpublic boolean isPrivacyMode() {\n\t\treturn privacyMode;\n\t}\n\n\t/**\n\t * @param privacyMode the privacyMode to set\n\t */\n\tpublic void setPrivacyMode(boolean privacyMode) {\n\t\tthis.privacyMode = privacyMode;\n\t}\n\n\tpublic int getTaskRpcMinThreadNum() {\n\t\treturn taskRpcMinThreadNum;\n\t}\n\n\tpublic void setTaskRpcMinThreadNum(int taskRpcMinThreadNum) {\n\t\tthis.taskRpcMinThreadNum = taskRpcMinThreadNum;\n\t}\n\n\tpublic int getTaskRpcMaxThreadNum() {\n\t\treturn taskRpcMaxThreadNum;\n\t}\n\n\tpublic void setTaskRpcMaxThreadNum(int taskRpcMaxThreadNum) {\n\t\tthis.taskRpcMaxThreadNum = taskRpcMaxThreadNum;\n\t}\n\n\t/**\n     * @return the project\n     */\n    public String getProject() {\n        return project;\n    }\n\n    /**\n     * @param project the project to set\n     */\n    public void setProject(String project) {\n        this.project = project;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n\t * @return the cronerThreadNum\n\t */\n\tpublic int getCronerThreadNum() {\n\t\treturn cronerThreadNum;\n\t}\n\n\t/**\n\t * @param cronerThreadNum the cronerThreadNum to set\n\t */\n\tpublic void setCronerThreadNum(int cronerThreadNum) {\n\t\tthis.cronerThreadNum = cronerThreadNum;\n\t}\n\n\t/**\n     * @return the taskCenterHost\n     */\n    public String getTaskCenterHost() {\n        return taskCenterHost;\n    }\n\n    /**\n     * @param taskCenterHost the taskCenterHost to set\n     */\n    public void setTaskCenterHost(String taskCenterHost) {\n        this.taskCenterHost = taskCenterHost;\n    }\n\n    public RedisProperties getRedis() {\n        return redis;\n    }\n\n    public void setRedis(RedisProperties redis) {\n        this.redis = redis;\n    }\n\n    public RabbitProperties getRabbitmq() {\n        return rabbitmq;\n    }\n\n    public void setRabbitmq(RabbitProperties rabbitmq) {\n        this.rabbitmq = rabbitmq;\n    }\n\n    public long getTaskQueueRetryDelay() {\n        return taskQueueRetryDelay;\n    }\n\n    public void setTaskQueueRetryDelay(long taskQueueRetryDelay) {\n        this.taskQueueRetryDelay = taskQueueRetryDelay;\n    }\n\n    public long getTaskRpcRetryDelay() {\n        return taskRpcRetryDelay;\n    }\n\n    public void setTaskRpcRetryDelay(long taskRpcRetryDelay) {\n        this.taskRpcRetryDelay = taskRpcRetryDelay;\n    }\n}\n", "answers": ["    private LocalRateLimiter localRateLimiter;"], "length": 5298, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "fbea06f3c6f93b8aaf69f52783041ff4c6ce262cc8922060"}
{"input": "package org.cryptomator.sanitizer.commands;\nimport static java.lang.String.format;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.nio.file.Files.isDirectory;\nimport static java.nio.file.Files.isRegularFile;\nimport static java.nio.file.Files.newBufferedWriter;\nimport static java.nio.file.Files.size;\nimport static java.nio.file.Files.walk;\nimport static java.nio.file.StandardOpenOption.CREATE_NEW;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.util.Collections.sort;\nimport static java.util.stream.Collectors.toList;\nimport static org.cryptomator.sanitizer.Sanitizer.print;\nimport static org.cryptomator.sanitizer.Sanitizer.printNoNewline;\nimport static org.cryptomator.sanitizer.integrity.problems.Severity.INFO;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport org.cryptomator.sanitizer.CryptorHolder;\nimport org.cryptomator.sanitizer.Passphrase;\nimport org.cryptomator.sanitizer.integrity.AbortCheckException;\nimport org.cryptomator.sanitizer.integrity.IntegrityCheck;\nimport org.cryptomator.sanitizer.integrity.problems.Problem;\nimport org.cryptomator.sanitizer.integrity.problems.Severity;\nimport org.cryptomator.sanitizer.integrity.problems.SolutionContext;\nimport org.cryptomator.sanitizer.utils.Counter;\n\n\n\n\nclass CheckRunner implements Runnable {\n\n\tprivate static final long KIBI = 1024;\n\tprivate static final String[] KIBI_POWERS = {\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"};\n\n\tprivate final CheckCommand args;\n\n\tpublic CheckRunner(CheckCommand args) {\n\t\tthis.args = args;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry (CryptorHolder cryptorHolder = new CryptorHolder(); //\n\t\t\t\tPassphrase passphrase = args.passphrase()) {\n\t\t\tIntegrityCheck integrityCheck = new IntegrityCheck(cryptorHolder);", "context": "src/main/java/org/cryptomator/sanitizer/Passphrase.java\npublic class Passphrase implements CharSequence, AutoCloseable {\n\n\tprivate final char[] chars;\n\n\tpublic Passphrase(char[] chars) {\n\t\tthis.chars = chars;\n\t}\n\n\tpublic Passphrase(CharBuffer chars) {\n\t\tthis.chars = new char[chars.remaining()];\n\t\tchars.get(this.chars);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tArrays.fill(chars, ' ');\n\t}\n\n\t@Override\n\tpublic int length() {\n\t\treturn chars.length;\n\t}\n\n\t@Override\n\tpublic char charAt(int index) {\n\t\treturn chars[index];\n\t}\n\n\t@Override\n\tpublic Passphrase subSequence(int start, int end) {\n\t\tint len = end - start;\n\t\tchar[] result = new char[len];\n\t\tSystem.arraycopy(chars, start, result, 0, len);\n\t\treturn new Passphrase(result);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn new String(chars);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/IntegrityCheck.java\npublic class IntegrityCheck {\n\n\tprivate final CryptorHolder cryptorHolder;\n\n\tpublic IntegrityCheck(CryptorHolder cryptorHolder) {\n\t\tthis.cryptorHolder = cryptorHolder;\n\t}\n\n\tpublic Set<Problem> check(Path path, CharSequence passphrase, boolean checkFileIntegrity) throws AbortCheckException {\n\t\tProblems problems = new Problems(path);\n\t\ttry {\n\t\t\tcryptorHolder.createCryptor(problems, path, passphrase).ifPresent(cryptor -> {\n\t\t\t\ttry {\n\t\t\t\t\tvaultFormatChecks(cryptor, path, checkFileIntegrity).check(problems, path);\n\t\t\t\t} finally {\n\t\t\t\t\tcryptor.destroy();\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (AbortCheckException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tproblems.reportException(e);\n\t\t}\n\t\treturn problems.asSet();\n\t}\n\n\tprivate Check vaultFormatChecks(Cryptor cryptor, Path pathToVault, boolean checkContentIntegrity) {\n\t\tCheck referencedDirectoryExists = referencedDirectoryExists(cryptor, pathToVault);\n\t\tHasCorrespondingDirectoryFileCheck hasCorrespondingDirectoryFileCheck = hasCorrespondingDirectoryFile(cryptor, pathToVault);\n\t\tCheck decryptedNameCheckForRegularFiles = decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck);\n\t\tHasCorrespondingDFileCheck hasCorrespondingDFile = hasCorrespondingDFileIn(pathToVault);\n\t\tCheck decryptedNameCheckForLongFiles = Checks.decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck, hasCorrespondingDFile);\n\t\tCheck emptyEncryptedFileIfEmpty = emptyEncryptedFileIfEmpty();\n\t\treturn dir().containing( //\n\t\t\t\tdir().that(hasName(\"d\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{30}\")) //\n\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()).validate(hasCorrespondingDirectoryFileCheck) //\n\t\t\t\t\t\t\t\t\t\t.reportAs(rootDirectoryIfMachting(cryptor)) //\n\t\t\t\t\t\t\t\t\t\t.containing( //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidDirectoryFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0?([A-Z2-7]{8})*[A-Z2-7=]{1,7}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aFileWithMissingEqualsSign()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tdir().that(hasName(\"m\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName()))\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles), //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName())) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles)\n\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator\")).validate(nameDoesNotContainUppercaseChars()), // do not validate contents because this already happened when creating the Cryptor\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator.bkup\")).validate(isMasterkeyBackupFile()));\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/SolutionContext.java\npublic interface SolutionContext {\n\n\tpublic static SolutionContext simulatePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, true);\n\t}\n\n\tpublic static SolutionContext executePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, false);\n\t}\n\n\tvoid start(String format, Object... args);\n\n\tvoid finish();\n\n\tvoid fail(String format, Object... args);\n\n\tvoid fail(Throwable reason);\n\n\tboolean dryRun();\n\n\tPath vaultLocation();\n\n\tCryptor cryptor();\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void printNoNewline(String line) {\n\tprintNoNewline(line, System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Severity.java\npublic enum Severity {\n\n\t/**\n\t * Issues which prevent the integrity check from operating correctly.\n\t */\n\tFATAL,\n\n\t/**\n\t * Issues which are guaranteed to cause problems while using the vault.\n\t */\n\tERROR,\n\n\t/**\n\t * Issues which are not guaranteed to cause problems while using the vault.\n\t */\n\tWARN,\n\n\t/**\n\t * Issues which occur during normal operation of the vault.\n\t */\n\tINFO\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Problem.java\npublic interface Problem {\n\n\tSeverity severity();\n\n\tdefault Optional<Solution> solution() {\n\t\treturn Optional.empty();\n\t}\n\n\tdefault String name() {\n\t\treturn \"notSolvable\";\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/CryptorHolder.java\npublic class CryptorHolder implements AutoCloseable {\n\n\tprivate static final int VAULT_VERSION = 6;\n\n\tprivate static final int VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION = 6;\n\n\tprivate Optional<Cryptor> cryptor = Optional.empty();\n\n\tpublic Optional<Cryptor> optionalCryptor() {\n\t\treturn cryptor;\n\t}\n\n\tpublic Optional<Cryptor> createCryptor(Problems problems, Path path, CharSequence passphrase) throws IOException, AbortCheckException {\n\t\tdestroyCryptor();\n\t\tPath masterkeyFile = path.resolve(\"masterkey.cryptomator\");\n\t\ttry {\n\t\t\tif (!isRegularFile(masterkeyFile)) {\n\t\t\t\tproblems.reportMissingMasterkeyFile(masterkeyFile);\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\tKeyFile keyFile = KeyFile.parse(readAllBytes(masterkeyFile));\n\t\t\tif (keyFile.getVersion() != VAULT_VERSION) {\n\t\t\t\tthrow new AbortCheckException(format(\"Vault version mismatch. Expected: %d Actual: %d\", VAULT_VERSION, keyFile.getVersion()));\n\t\t\t}\n\t\t\tcryptor = Optional.of(bestGuessCryptorProvider(keyFile).createFromKeyFile(keyFile, normalizePassphrase(keyFile, passphrase), keyFile.getVersion()));\n\t\t\treturn cryptor;\n\t\t} catch (InvalidPassphraseException e) {\n\t\t\tthrow new AbortCheckException(\"Invalid passphrase\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tif (e.getCause() instanceof InvalidKeyException) {\n\t\t\t\tthrow new AbortCheckException(\"JCE files seem to be missing. Download from \\n\" //\n\t\t\t\t\t\t+ \"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html.\\n\" //\n\t\t\t\t\t\t+ \"and install according to instructions in README.txt\");\n\t\t\t} else {\n\t\t\t\tproblems.reportInvalidMasterkeyFile(masterkeyFile);\n\t\t\t}\n\t\t}\n\t\tcryptor = Optional.empty();\n\t\treturn cryptor;\n\t}\n\n\tpublic void destroyCryptor() {\n\t\tcryptor.ifPresent(Cryptor::destroy);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tdestroyCryptor();\n\t}\n\n\tpublic static CharSequence normalizePassphrase(KeyFile keyFile, CharSequence passphrase) {\n\t\tif (keyFile.getVersion() < VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION) {\n\t\t\treturn passphrase;\n\t\t}\n\t\treturn Normalizer.normalize(passphrase, Form.NFC);\n\t}\n\n\tpublic static CryptorProvider bestGuessCryptorProvider(KeyFile keyFile) {\n\t\tswitch (keyFile.getVersion()) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\t\treturn Cryptors.version1(strongSecureRandom());\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"Unsupported vault version \" + keyFile.getVersion());\n\t\t}\n\t}\n\n\tprivate static SecureRandom strongSecureRandom() {\n\t\ttry {\n\t\t\treturn SecureRandom.getInstanceStrong();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IllegalStateException(\"Java platform is required to support a strong SecureRandom.\", e);\n\t\t}\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/AbortCheckException.java\npublic class AbortCheckException extends Exception {\n\n\tpublic AbortCheckException(String message) {\n\t\tsuper(message);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void print() {\n\tprint(System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/utils/Counter.java\npublic class Counter {\n\n\tprivate long count = 0;\n\n\tpublic void increment() {\n\t\tcount++;\n\t}\n\n\tpublic long get() {\n\t\treturn count;\n\t}\n\n}\n", "answers": ["\t\t\tprint(\"Scanning vault structure may take some time. Be patient...\");"], "length": 924, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "47573702c5f1ad33b86b8645ddc49617af39e584b4303008"}
{"input": "package de.fau.cs.mad.yasme.android.asyncTasks.server;\nimport android.app.Activity;\nimport android.os.AsyncTask;\nimport de.fau.cs.mad.yasme.android.connection.DeviceTask;\nimport de.fau.cs.mad.yasme.android.contacts.QR;\nimport de.fau.cs.mad.yasme.android.controller.Log;\nimport de.fau.cs.mad.yasme.android.controller.ObservableRegistry;\nimport de.fau.cs.mad.yasme.android.controller.SpinnerObservable;\nimport de.fau.cs.mad.yasme.android.encryption.KeyEncryption;\nimport de.fau.cs.mad.yasme.android.entities.OwnDevice;\nimport de.fau.cs.mad.yasme.android.entities.User;\nimport de.fau.cs.mad.yasme.android.exception.RestServiceException;\nimport de.fau.cs.mad.yasme.android.gcm.CloudMessaging;\nimport de.fau.cs.mad.yasme.android.storage.DebugManager;\nimport de.fau.cs.mad.yasme.android.ui.AbstractYasmeActivity;\nimport de.fau.cs.mad.yasme.android.ui.fragments.LoginFragment;\n\n\n\n/**\n * Created by Cuong Bui <cuong.bui@fau.de> on 21/06/14.\n */\npublic class DeviceRegistrationTask extends AsyncTask<String, Void, Boolean> {\n\n    private long deviceId;\n    private Activity activity;\n    private String regId;\n    private Class classToNotify;\n\n    public DeviceRegistrationTask(Activity activity, Class classToNotify) {\n        this.activity = activity;\n        this.classToNotify = classToNotify;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n    }\n\n    /**\n     * @params params[0] is userId\n     * @params params[1] is product\n     */\n    @Override\n    protected Boolean doInBackground(String... params) {\n        long userId = Long.parseLong(params[0]);\n\n        // the product : e.g Google Nexus\n        String product = params[1];\n\n        // Register for Google Cloud Messaging at Google Server\n        if (!registerGCM()) {\n            return false;\n        }\n\n        // Register at YASME server\n        return registerDeviceAtYASME(userId, product, regId);\n    }\n\n\n    private boolean registerGCM() {\n        CloudMessaging cloudMessaging = CloudMessaging.getInstance(this.activity);\n\n        if (cloudMessaging.checkPlayServices()) {\n            String regid = cloudMessaging.getRegistrationId();\n            Log.d(this.getClass().getSimpleName(), \"Google reg id is empty? \" + regid.isEmpty());\n            if (regid.isEmpty()) {\n                regId = cloudMessaging.registerInBackground();\n                if (null == regId || regId.isEmpty()) {\n                    Log.e(this.getClass().getSimpleName(), \"reg id for GCM is empty\");\n                    return false;\n                }\n            }\n        } else {\n            Log.i(AbstractYasmeActivity.TAG, \"No valid Google Play Services APK found.\");\n        }\n\n        return true;\n    }\n\n\n    private boolean registerDeviceAtYASME(long userId, String product, String regId) {\n        long deviceIdFromServer;\n\n        //register device through REST-Call\n        // create a new device to be registered\n\n        // user which want to register the device\n        // ignore the name user, the server will set the right values according to the userId\n        User user = new User(\"user\", userId);\n\n        // indicates if its a smartphone or a tablet\n        // currently unused\n        String type = \"device\";\n\n        // phone number, currently unused\n        String number = null;\n\n        KeyEncryption rsa = new KeyEncryption();\n        //generate private and public Key\n        rsa.generateRSAKeys();\n        String pubKeyInBase64 = rsa.getGeneratedPubKeyInBase64();\n\n        OwnDevice deviceToBeRegistered = new OwnDevice(user, OwnDevice.Platform.ANDROID, pubKeyInBase64, type, number, product, regId);\n\n        // make the REST-Call\n        try {\n            deviceIdFromServer = DeviceTask.getInstance().registerDevice(deviceToBeRegistered);\n            deviceId = deviceIdFromServer;\n            //save private and public Key to storage\n            rsa.saveRSAKeys(deviceId);", "context": "yasme/src/main/java/de/fau/cs/mad/yasme/android/encryption/KeyEncryption.java\npublic class KeyEncryption {\r\n\r\n    public static final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n    public static final String PRIVATEKEY = \"privateKey\";\r\n    public static final String PUBLICKEY = \"publicKey\";\r\n    private final byte CREATOR = 0;\r\n    private final byte RECIPIENT = 1;\r\n    private RSAEncryption rsa;\r\n    private DatabaseManager db = DatabaseManager.INSTANCE;\r\n\r\n    public KeyEncryption() {\r\n        this.rsa = new RSAEncryption();\r\n    }\r\n\r\n    /**\r\n     * generate a random RSA-KeyPair (Private and Public Key)\r\n     */\r\n    public void generateRSAKeys(){\r\n        rsa.generateKeyPair();\r\n    }\r\n\r\n    /**\r\n     * encode generated RSA-KeyPair to base64 and store it to local storage (SharedPreferences)\r\n     * there is a own SharedPreference for every user on the device\r\n     *\r\n     * @param deviceId deviceId from the user logged in currently\r\n     * @return true/false\r\n     */\r\n    public boolean saveRSAKeys(long deviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + deviceId;\r\n\r\n        try {\r\n\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            //delete existing keys\r\n            if (privKeyStorage.getString(PRIVATEKEY, \"\") != \"\"){\r\n                keyeditor.remove(PRIVATEKEY);\r\n            }\r\n            if (privKeyStorage.getString(PUBLICKEY, \"\") != \"\"){\r\n                keyeditor.remove(PUBLICKEY);\r\n            }\r\n\r\n            keyeditor.putString(PRIVATEKEY, rsa.getPrivKeyinBase64());\r\n            keyeditor.putString(PUBLICKEY, rsa.getPubKeyinBase64());\r\n\r\n            keyeditor.commit();\r\n\r\n            // For Developer-Devices only\r\n            if (DebugManager.INSTANCE.isDebugMode()) {\r\n                Log.d(getClass().getSimpleName(), \"Store keys to external storage\");\r\n                DebugManager.INSTANCE.storePrivatePublicKeyToExternalStorage(rsa.getPrivKeyinBase64(),rsa.getPubKeyinBase64());\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"RSA Keys generated and saved\");\r\n\r\n\r\n            return true;\r\n        } catch (Exception e){\r\n            Log.e(this.getClass().getSimpleName(), \"saving rsa keys failed\");\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the generated RSA Public Key in Base64\r\n     * method is needed in registration when the Public Key needs to be sent to the server\r\n     *\r\n     * @return base64 encoded string\r\n     */\r\n    public String getGeneratedPubKeyInBase64(){\r\n        return rsa.getPubKeyinBase64();\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the RSA PublicKey from the recipient\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be encrypted\r\n     * @return messageKey containing the RSA-encrypted AES-Key\r\n     */\r\n    public MessageKey encrypt(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, RECIPIENT);\r\n\r\n        if (pubKey != null){\r\n            String keyEncrypted = rsa.encrypt(messageKey.getMessageKey(), pubKey);\r\n            messageKey.setKey(keyEncrypted);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the encrypted AES-Key that should be decrypted\r\n     * @return messageKey containing the decrypted AES-Key\r\n     */\r\n    public MessageKey decrypt(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getRecipientDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String key = rsa.decrypt(messageKey.getMessageKey(), privKey);\r\n            if (key == null) {\r\n                return null;\r\n            }\r\n            messageKey.setKey(key);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * sign an AES-Key using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be signed\r\n     * @return  messageKey containing the signature\r\n     */\r\n    public MessageKey sign(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getCreatorDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String keySigned = rsa.sign(messageKey.getMessageKey(), privKey);\r\n            messageKey.setSign(keySigned);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * verify the signature from given messageKey using the RSA Public Key from the creatorDevice\r\n     *\r\n     * @param messageKey messageKey containing the signature\r\n     * @return true/false\r\n     */\r\n    public boolean verify(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, CREATOR);\r\n\r\n        if (pubKey != null) {\r\n            Log.d(getClass().getSimpleName(), \"Verify key\");\r\n            return rsa.verify(messageKey.getSign(), messageKey.getMessageKey(), pubKey);\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"PubKey is null\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * load own RSA Private Key from local storage\r\n     *\r\n     * @param selfDeviceId deviceId from the user logged in currently\r\n     * @return PrivateKey\r\n     */\r\n    public PrivateKey getPrivateRSAKeyFromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String privKeyInBase64 = privKeyStorage.getString(PRIVATEKEY, \"\");\r\n\r\n        Log.d(this.getClass().getSimpleName(),\"Load private Key from storage: \" + RSAKEY_STORAGE_USER);\r\n\r\n        //if Key is available\r\n        if (privKeyInBase64 != \"\") {\r\n\r\n            PrivateKey privKey = rsa.convertBase64toPrivKey(privKeyInBase64);\r\n\r\n            if (privKey != null){\r\n                Log.d(this.getClass().getSimpleName(),\"Private Key was successfully loaded from storage\");\r\n                return privKey;\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Getting private key from storage failed\");\r\n            return null;\r\n        }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Private Key could not be found.\");\r\n            return null;\r\n\r\n    }\r\n\r\n    /**\r\n     * load the needed RSA Public Key from local storage/Device-Object\r\n     *\r\n     * @param messageKey messageKey containing the information about creatorDevice and recipientDevice\r\n     * @param type define, the RSA Public Key from the recipient or the creator is needed\r\n     * @return PublicKey\r\n     */\r\n    public PublicKey getPubKeyFromUser(MessageKey messageKey, byte type) {\r\n\r\n        String pubKeyInBase64 = null;\r\n\r\n        //try to extract Public Key from MessageKey\r\n        if (type == CREATOR){\r\n                pubKeyInBase64 = messageKey.getCreatorDevice().getPublicKey();\r\n        }\r\n        else if (type == RECIPIENT){\r\n                pubKeyInBase64 = messageKey.getRecipientDevice().getPublicKey();\r\n        }\r\n        else{\r\n            Log.d(this.getClass().getSimpleName(), \"Wrong use of function: getPubKeyFromUser()\");\r\n            return null;\r\n        }\r\n\r\n        //convert Base64toPublicKey\r\n        if (pubKeyInBase64 != null) {\r\n            PublicKey pubKey = rsa.convertBase64toPubKey(pubKeyInBase64);\r\n            if (pubKey != null) return pubKey;\r\n        }\r\n\r\n        Log.d(this.getClass().getSimpleName(), \"Getting public key from storage failed\");\r\n        return null;\r\n    }\r\n\r\n    /*\r\n    //get own PublicKey in Base64\r\n    public String getPublicRSAKeyInBase64FromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String pubKeyInBase64 = privKeyStorage.getString(PUBLICKEY, \"\");\r\n\r\n        return pubKeyInBase64;\r\n    }\r\n    */\r\n\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/fragments/LoginFragment.java\npublic class LoginFragment extends Fragment implements NotifiableFragment<LoginFragment.LoginParam> {\n\n    //Keep track of the login task to ensure we can cancel it if requested.\n    private UserLoginTask authTask = null;\n\n    // UI references.\n    private EditText emailView;\n    private EditText passwordView;\n    private TextView loginStatusMessageView;\n    private View mProgressView;\n    private View mLoginFormView;\n    // values for devices yasme server\n    private String deviceProduct;\n    // Values for name, email and password at the time of the login attempt.\n    private String emailTmp;\n    private String passwordTmp;\n    // focusView for validate()\n    private View focusView = null;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        // In debug app, show @yasme.net\n        String defaultEmail = (BuildConfig.DEBUG) ? \"@yasme.net\" : \"\";\n\n        // Restore preferences\n        emailTmp = DatabaseManager.INSTANCE.getSharedPreferences().getString(AbstractYasmeActivity.USER_MAIL, defaultEmail);\n    }\n\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.fragment_login, container,\n                false);\n\n        // Set up the login form.\n        emailView = (EditText) rootView.findViewById(R.id.email);\n        emailView.setText(emailTmp);\n\n        passwordView = (EditText) rootView.findViewById(R.id.password);\n        if (BuildConfig.DEBUG) {\n            passwordView.setText(R.string.default_password);\n        }\n        passwordView\n                .setOnEditorActionListener(new TextView.OnEditorActionListener() {\n                    @Override\n                    public boolean onEditorAction(TextView textView, int id,\n                                                  KeyEvent keyEvent) {\n                        if (id == R.id.login || id == EditorInfo.IME_NULL) {\n                            attemptLogin();\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n\n        loginStatusMessageView = (TextView) rootView.findViewById(R.id.login_status_message);\n\n        rootView.findViewById(R.id.sign_in_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"SignIn-Button pushed\");\n                        attemptLogin();\n                    }\n                }\n        );\n\n        rootView.findViewById(R.id.register_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Register-Button pushed\");\n                        registerDialog();\n                    }\n                }\n        );\n\n        TextView tv = (TextView) rootView.findViewById(R.id.forgot_password);\n\n        Pattern pattern = Pattern.compile(getString(R.string.forgot_password));\n        /*\n        Linkify.addLinks(tv, pattern, \"\", null, new Linkify.TransformFilter() {\n            @Override\n            public String transformUrl(Matcher matcher, String s) {\n                return \"\";\n            }\n        });\n        */\n        tv.setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Forgot Password-Button pushed\");\n                        requestMail();\n                    }\n                }\n        );\n\n        return rootView;\n    }\n\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Log.d(this.getClass().getSimpleName(), \"Try to get LoginObservableInstance\");\n        FragmentObservable<LoginFragment, LoginParam> obs = ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"... successful\");\n\n        obs.register(this);\n        mProgressView = getActivity().findViewById(R.id.login_status);\n        mLoginFormView = getActivity().findViewById(R.id.login);\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        FragmentObservable<LoginFragment, LoginParam> obs =\n                ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"Remove from observer\");\n        obs.remove(this);\n    }\n\n    private void registerDialog() {\n        getFragmentManager().beginTransaction()\n                .add(R.id.singleFragmentContainer, new RegisterFragment()).commit();\n    }\n\n    /**\n     * Attempts to sign in or register the account specified by the login form.\n     * If there are form errors (missing fields, etc.), the errors are presented\n     * and no actual login attempt is made.\n     */\n    public void attemptLogin() {\n        if (authTask == null) {\n            authTask = new UserLoginTask(true, this.getClass());\n            Log.d(this.getClass().getSimpleName(), \"AuthTask is null\");\n        }\n\n        // Reset errors.\n        emailView.setError(null);\n        passwordView.setError(null);\n\n        // Store values at the time of the login attempt.\n        emailTmp = emailView.getText().toString();\n        passwordTmp = passwordView.getText().toString();\n\n        boolean cancel = false;\n\n        // Check for a valid password.\n        if (TextUtils.isEmpty(passwordTmp)) {\n            passwordView.setError(getString(R.string.error_field_required));\n            focusView = passwordView;\n            cancel = true;\n        } else if (passwordTmp.length() < 8) {\n            passwordView.setError(getString(R.string.error_invalid_password));\n            focusView = passwordView;\n            cancel = true;\n        }\n\n        // Check for a valid mail.\n        if (TextUtils.isEmpty(emailTmp)) {\n            emailView.setError(getString(R.string.error_field_required));\n            focusView = emailView;\n            cancel = true;\n        }\n\n        if (cancel) {\n            // There was an error; don't attempt login and focus the first\n            // form field with an error.\n            focusView.requestFocus();\n        } else {\n            // Show a progress spinner, and kick off a background task to\n            // perform the user login attempt.\n            loginStatusMessageView.setText(R.string.login_progress_signing_in);\n            showProgress(true);\n\n            // Hide the virtual keyboard\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            View focus = activity.getCurrentFocus();\n            if (null == focus) {\n                focus = focusView;\n            }\n            if (null == focus) {\n                focus = passwordView;\n            }\n            if (null == focus) {\n                focus = emailView;\n            }\n            InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n            if (null != imm && null != focus)\n                imm.hideSoftInputFromWindow(focus.getWindowToken(), 0);\n\n            // Start the asynctask\n            authTask.execute(emailTmp, passwordTmp);\n            authTask = null;\n        }\n    }\n\n    public void onPostLoginExecute(Boolean success, long userId) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        activity.getSelfUser().setId(userId);\n\n        if (success) {\n            //Initialize database (once in application)\n            if (!DatabaseManager.INSTANCE.isInitialized()) {\n                Log.e(getClass().getSimpleName(), \"DB-Manger hasn't been initialized\");\n            }\n            DatabaseManager.INSTANCE.setUserId(userId);\n\n            // check if there is a device in the Database\n            if (yasmeDeviceCheck()) {\n                Log.d(this.getClass().getSimpleName(), \"Device exists in Database\");\n\n                long deviceId = DatabaseManager.INSTANCE.getSharedPreferences().getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n                if (deviceId < 0) {\n                    // Error ocurred\n                    Log.e(this.getClass().getSimpleName(), \"Could not load registered device's id from shared prefs\");\n                    showProgress(false);\n                    return;\n                }\n\n                DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n                showProgress(false);\n                Intent intent = new Intent(activity, ChatListActivity.class);\n                startActivity(intent);\n                getActivity().finish();\n            } else {\n                // register device\n                Log.d(this.getClass().getSimpleName(), \"Device does not exist in Database\");\n                Log.d(this.getClass().getSimpleName(), \"Starting task to register device at yasme server\");\n\n                new DeviceRegistrationTask(activity, this.getClass())\n                        .execute(Long.toString(userId), this.deviceProduct, this.getClass().getName());\n\n            }\n        } else {\n            Log.d(getClass().getSimpleName(), \"Login failed\");\n            ServerInfo serverInfo = DatabaseManager.INSTANCE.getServerInfo();\n            if (serverInfo != null && !serverInfo.getLoginAllowed() && serverInfo.hasMessage()) {\n                passwordView.setError(DatabaseManager.INSTANCE.getServerInfo().getMessage());\n            } else {\n                passwordView.setError(getString(R.string.error_incorrect_user_or_password));\n            }\n            passwordView.requestFocus();\n            showProgress(false);\n        }\n    }\n\n    public void onPostYasmeDeviceRegExecute(Boolean success, long deviceId) {\n        if (!success) {\n            Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n        } else {\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            // Initialize the session a second time because the deviceId was missing\n            /*SharedPreferences devicePrefs = activity.getSharedPreferences(\n                    AbstractYasmeActivity.DEVICE_PREFS,\n                    AbstractYasmeActivity.MODE_PRIVATE);\n            long userId = devicePrefs.getLong(AbstractYasmeActivity.USER_ID, -1);\n            if (userId < 0) {\n                // Error ocurred\n                Log.e(this.getClass().getSimpleName(), \"Did not find user id in shared prefs\");\n                Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n                showProgress(false);\n                return;\n            }*/\n\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n            Log.d(this.getClass().getSimpleName(), \"Login after device registration at yasme server\");\n            showProgress(false);\n            Intent intent = new Intent(activity, ChatListActivity.class);\n            startActivity(intent);\n            getActivity().finish();\n        }\n    }\n\n    /**\n     * This method checks if there is a device in the DB\n     */\n    public boolean yasmeDeviceCheck() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        //set the deviceProduct\n        this.deviceProduct = Build.MANUFACTURER + \" \" + Build.MODEL;\n        Log.d(this.getClass().getSimpleName(), \"MODEL is \" + Build.MODEL);\n        Log.d(this.getClass().getSimpleName(), \"DEVICE is \" + Build.DEVICE);\n        Log.d(this.getClass().getSimpleName(), \"PRODUCT is \" + Build.PRODUCT);\n        Log.d(this.getClass().getSimpleName(), \"MANUFACTURER is \" + Build.MANUFACTURER);\n        Log.d(this.getClass().getSimpleName(), \"BRAND is \" + Build.BRAND);\n        Log.d(this.getClass().getSimpleName(), \"NOW is \" + this.deviceProduct);\n        //try to load device from shared preferences\n        SharedPreferences devicePrefs = activity.getSharedPreferences(\n                AbstractYasmeActivity.DEVICE_PREFS,\n                AbstractYasmeActivity.MODE_PRIVATE);\n        long deviceId = devicePrefs.getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n\n        // load regId\n        SharedPreferences pushPrefs = activity.\n                getSharedPreferences(AbstractYasmeActivity.PUSH_PREFS,\n                        AbstractYasmeActivity.MODE_PRIVATE);\n\n        String googleRegId = pushPrefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, null);\n        // TODO proper check\n\n        if (deviceId == -1) {\n            if (DebugManager.INSTANCE.isDebugMode()) {\n                return DebugManager.INSTANCE.restoreData();\n            }\n            return false;\n        }\n        // TODO devices from server\n        // TODO use case : plain app + old user + old device\n\n        Log.d(this.getClass().getSimpleName(), \"deviceId is \" + deviceId);\n        return true;\n    }\n\n    public void requestMail() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.request_email_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final TextView requestEmailText = new TextView(activity);\n        requestEmailText.setText(R.string.request_email_body);\n\n        final EditText mail = new EditTextWithX(activity).getEditText();\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n        mail.setText(emailTmp);\n\n        list.addView(mail);\n        list.addView(requestEmailText, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        // Grab the EditText's input\n                        emailTmp = mail.getText().toString();\n                        Log.d(this.getClass().getSimpleName(), \"Mail to send token at: \" + emailTmp);\n                        User user = new User();\n                        user.setEmail(emailTmp);\n                        new ChangePasswordTask(user).execute(\"1\");\n                        forgotPasswordDialog(emailTmp);\n                    }\n                }\n        );\n\n        // Skip, email was already sent\n        alert.setNeutralButton(R.string.skip,\n                new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n                        forgotPasswordDialog(null);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    public void forgotPasswordDialog(final String inputMail) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.password_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final EditText token = new EditText(activity);\n        token.setInputType(InputType.TYPE_CLASS_TEXT);\n        token.setHint(R.string.hint_mail_token);\n\n        final TextView tokenExplanation = new TextView(activity);\n        tokenExplanation.setText(R.string.explanation_mail_token);\n\n        final EditText password = new EditText(activity);\n        password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        password.setHint(R.string.hint_new_password);\n\n        final EditText passwordCheck = new EditText(activity);\n        passwordCheck.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        passwordCheck.setHint(R.string.hint_repeat_new_password);\n\n        final EditText mail = new EditText(activity);\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n\n        if (inputMail == null || inputMail.isEmpty()) {\n            list.addView(mail);\n        }\n        list.addView(token, layoutParams);\n        list.addView(tokenExplanation, layoutParams);\n        list.addView(password, layoutParams);\n        list.addView(passwordCheck, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n\n                        // Grab the EditText's input\n                        String email;\n                        if (inputMail == null || inputMail.isEmpty()) {\n                            email = mail.getText().toString();\n                        } else {\n                            email = inputMail;\n                        }\n                        String mailToken = token.getText().toString();\n                        String inputPassword = password.getText().toString();\n                        String inputPasswordCheck = passwordCheck.getText()\n                                .toString();\n\n                        if (password.getText().length() < 8) {\n                            Toaster.getInstance().toast(R.string.password_too_short,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        if (!inputPassword.equals(inputPasswordCheck)) {\n                            Toaster.getInstance().toast(R.string.passwords_do_not_match,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        User user = new User(email, inputPassword);\n                        PasswordEncryption pwEnc = new PasswordEncryption(user);\n                        User secured = pwEnc.securePassword();\n                        new ChangePasswordTask(secured).execute(\"0\", mailToken);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    /**\n     * Shows the progress UI and hides the login form.\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)\n    public void showProgress(final boolean show) {\n        // On Honeycomb MR2 we have the ViewPropertyAnimator APIs, which allow\n        // for very easy animations. If available, use these APIs to fade-in\n        // the progress spinner.\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {\n            int shortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);\n\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n            mLoginFormView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 0 : 1).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n                }\n            });\n\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mProgressView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 1 : 0).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n                }\n            });\n        } else {\n            // The ViewPropertyAnimator APIs are not available, so simply show\n            // and hide the relevant UI components.\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n        }\n    }\n\n    @Override\n    public void notifyFragment(LoginParam param) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified. Yeeha!\");\n        if (param instanceof LoginProcessParam) {\n            notifyFragment((LoginProcessParam) param);\n        } else if (param instanceof DeviceRegistrationParam) {\n            notifyFragment((DeviceRegistrationParam) param);\n        }\n    }\n\n    public void notifyFragment(LoginProcessParam loginParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with loginParam\");\n\n        onPostLoginExecute(loginParam.getSuccess(), loginParam.getUserId());\n        Log.d(super.getClass().getSimpleName(), \"Login-Status: \" + loginParam.getSuccess());\n    }\n\n    public void notifyFragment(DeviceRegistrationParam deviceRegistrationParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with deviceRegistrationParam\");\n\n        onPostYasmeDeviceRegExecute(deviceRegistrationParam.getSuccess(),\n                deviceRegistrationParam.getDeviceId());\n\n    }\n\n    public static class LoginParam {\n        protected Boolean success;\n\n        public Boolean getSuccess() {\n            return success;\n        }\n    }\n\n    public static class LoginProcessParam extends LoginParam {\n        private Long userId;\n\n        public LoginProcessParam(Boolean success) {\n            this.success = success;\n            this.userId = DatabaseManager.INSTANCE.getUserId();\n        }\n\n        public Long getUserId() {\n            return userId;\n        }\n    }\n\n    public static class DeviceRegistrationParam extends LoginParam {\n        private Long deviceId;\n\n        public DeviceRegistrationParam(Boolean success) {\n            this.success = success;\n            this.deviceId = DatabaseManager.INSTANCE.getDeviceId();\n        }\n\n        public Long getDeviceId() {\n            return deviceId;\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/AbstractYasmeActivity.java\npublic abstract class AbstractYasmeActivity extends Activity implements Toastable {\n    public final static String USER_ID = \"de.fau.cs.mad.yasme.android.USER_ID\";\n    public final static String USER_NAME = \"de.fau.cs.mad.yasme.android.USER_NAME\";\n    public final static String USER_MAIL = \"de.fau.cs.mad.yasme.android.USER_MAIL\";\n    public final static String USER_PW = \"de.fau.cs.mad.yasme.android.USER_PW\";\n    public final static String DEVICE_ID = \"de.fau.cs.mad.yasme.android.DEVICE_ID\";\n    public final static String PROFILE_PICTURE = \"de.fau.cs.mad.yasme.android.PROFILE_PICTURE\";\n\n    public final static String CHAT_ID = \"de.fau.cs.mad.yasme.android.CHAT_ID\";\n    public final static String LAST_MESSAGE_ID = \"de.fau.cs.mad.yasme.android.LAST_MESSAGE_ID\";\n\n    public final static String ACCESSTOKEN = \"de.fau.cs.mad.yasme.android.ACCESSTOKEN\";\n    public final static String SIGN_IN = \"de.fau.cs.mad.yasme.android.SIGN_IN\";\n\n    public final static String SERVERINFOUPDATETIME = \"de.fau.cs.mad.yasme.android.SERVERINFOUPDATETIME\";\n    public final static String SERVERMESSAGE = \"de.fau.cs.mad.yasme.android.SERVERMESSAGE\";\n\n    public final static String STORAGE_PREFS = \"de.fau.cs.mad.yasme.android.STORAGE_PREFS\";\n    public final static String SETTINGS_PREFS = \"de.fau.cs.mad.yasme.android.SETTINGS_PREFS\";\n    public final static String DEVICE_PREFS = \"de.fau.cs.mad.yasme.android.DEVICE_PREFS\";\n    public final static String PUSH_PREFS = \"de.fau.cs.mad.yasme.android.PUSH_PREFS\";\n\n    public final static String NOTIFICATION_VIBRATE = \"de.fau.cs.mad.yasme.android.NOTIFICATION_VIBRATE\";\n    public final static String NOTIFICATION_SOUND = \"de.fau.cs.mad.yasme.android.NOTIFICATION_SOUND\";\n\n\n    //GCM Properties\n    public static final String PROPERTY_REG_ID = \"registration_id\";\n    public static final String PROPERTY_APP_VERSION = \"appVersion\";\n    public static final String SENDER_ID = \"688782154540\"; //\"104759172131\";\n    public static final int PLAY_SERVICES_RESOLUTION_REQUEST = 9000;\n    public static final String TAG = \"YasmeGCM\";\n\n    protected User selfUser;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        if (!ConnectionTask.isInitialized()) {\n            String server = getResources().getString(R.string.server_host);\n            if (BuildConfig.DEBUG) {\n                server = getResources().getString(R.string.server_host_debug);\n            }\n            Log.d(getClass().getSimpleName(), \"YASME-Server: \" + server);\n            ConnectionTask.initParams(getResources().getString(R.string.server_scheme),\n                    server,\n                    getResources().getString(R.string.server_port), getResources().getString(R.string.language), getVersion());\n        }\n\n        SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n        SharedPreferences settings = getSharedPreferences(SETTINGS_PREFS, MODE_PRIVATE);\n        Long userId = storage.getLong(USER_ID, 0);\n        String userName = storage.getString(USER_NAME, \"\");\n        String userMail = storage.getString(USER_MAIL, \"\");\n        String userPw = storage.getString(USER_PW, \"password\");\n\n        if(selfUser==null) {\n            selfUser = new User();\n        }\n        selfUser.setId(userId);\n        selfUser.setName(userName);\n        selfUser.setEmail(userMail);\n        selfUser.setPw(userPw);\n\n\n        //Initialize databaseManager (once in application)\n        if (!DatabaseManager.INSTANCE.isInitialized()) {\n            DatabaseManager.INSTANCE.init(this, storage, settings, userId);\n        }\n        //Init QR-Code\n        QR.init(false);\n\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Toaster.getInstance().register(this);\n        stopSpinning();\n        SpinnerObservable.getInstance().registerActivity(this);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        Toaster.getInstance().remove(this);\n        SpinnerObservable.getInstance().removeActivity(this);\n    }\n\n    public void setActionBarTitle(String title) {\n        getActionBar().setTitle(title);\n    }\n\n    public void setActionBarTitle(String title, String subtitle) {\n        getActionBar().setTitle(title);\n        getActionBar().setSubtitle(subtitle);\n    }\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        Intent intent;\n        int itemId = item.getItemId();\n        switch (itemId) {\n            case android.R.id.home:\n                if (NavUtils.getParentActivityName(this) != null) {\n                    NavUtils.navigateUpFromSameTask(this);\n                }\n                return true;\n            case R.id.action_settings:\n                intent = new Intent(this, SettingsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_chats:\n                intent = new Intent(this, ChatListActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_add_chat:\n                intent = new Intent(this, InviteToChatActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            case R.id.action_contacts:\n                intent = new Intent(this, ContactActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            default:\n                return super.onOptionsItemSelected(item);\n\n        }\n    }\n\n    public String getSelfName() {\n\n        if(selfUser==null) {\n            SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n            Long userId = storage.getLong(USER_ID, 0);\n            String userName = storage.getString(USER_NAME, \"\");\n            String userMail = storage.getString(USER_MAIL, \"\");\n            String userPw = storage.getString(USER_PW, \"password\");\n\n            selfUser = new User();\n            selfUser.setId(userId);\n            selfUser.setName(userName);\n            selfUser.setEmail(userMail);\n            selfUser.setPw(userPw);\n        }\n        if (selfUser.getName().isEmpty()) {\n            String name = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_NAME, \"\");\n            selfUser.setName(name);\n        }\n        return selfUser.getName();\n    }\n\n    public User getSelfUser() {\n        return selfUser;\n    }\n\n    public String getUserMail() {\n        if (selfUser == null || selfUser.getEmail().isEmpty()) {\n            String mail = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_MAIL, \"\");\n            selfUser.setEmail(mail);\n        }\n        return selfUser.getEmail();\n    }\n\n    public long getUserId() {\n        return selfUser.getId();\n    }\n\n    public String getOwnProfilePicture() {\n        String path = selfUser.getProfilePicture();\n        if (path == null || path.isEmpty()) {\n            path = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(PROFILE_PICTURE, null);\n        }\n        return path;\n    }\n\n    public void setOwnProfilePicture(String ownProfilePicture) {\n        selfUser.setProfilePicture(ownProfilePicture);\n        SharedPreferences.Editor editor = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).edit();\n        editor.putString(AbstractYasmeActivity.PROFILE_PICTURE, ownProfilePicture);\n        editor.commit();\n    }\n\n    public String getAccessToken() {\n        return DatabaseManager.INSTANCE.getAccessToken();\n    }\n\n    public void toast(final int messageId, final int duration) {\n        String text = getApplicationContext().getResources().getString(messageId);\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration) {\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration, final int gravity) {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                Toast toast = Toast.makeText(getApplicationContext(), text, duration);\n                if (-1 != gravity) {\n                    toast.setGravity(gravity, 0, 0);\n                }\n                // otherwise use default position\n                Log.d(getClass().getSimpleName(), \"Toast: \" + text);\n                toast.show();\n            }\n        });\n    }\n\n    public void startSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(true);\n            }\n        });\n    }\n\n    public void stopSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(false);\n            }\n        });\n    }\n\n    public int getVersion() {\n        try {\n            return getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;\n        } catch (Exception e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return 0;\n        }\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/gcm/CloudMessaging.java\npublic class CloudMessaging {\n\n    private static CloudMessaging instance;\n\n    private Activity activity;\n    private GoogleCloudMessaging gcm;\n    private Context context;\n    private String regid;\n\n\n    public static CloudMessaging getInstance(Activity activity) {\n        if (instance == null) {\n            instance = new CloudMessaging(activity);\n        }\n        return instance;\n    }\n\n    private CloudMessaging(Activity activity) {\n        this.activity = activity;\n        this.context = activity.getApplicationContext();\n        this.gcm = GoogleCloudMessaging.getInstance(activity);\n    }\n\n    public boolean checkPlayServices() {\n        int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(activity);\n        if (resultCode != ConnectionResult.SUCCESS) {\n            if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {\n                GooglePlayServicesUtil.getErrorDialog(resultCode, activity,\n                        AbstractYasmeActivity.PLAY_SERVICES_RESOLUTION_REQUEST).show();\n            } else {\n                Log.i(AbstractYasmeActivity.TAG, \"This device is not supported.\");\n                activity.finish();\n            }\n            return false;\n        }\n        return true;\n    }\n\n    public String getRegistrationId() {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        String registrationId = prefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, \"\");\n        Log.i(AbstractYasmeActivity.TAG + \"WOOOOOLOOOLOOOO\", \"this is my id: [\" + AbstractYasmeActivity.PROPERTY_REG_ID + \"]\");\n        if (registrationId.isEmpty()) {\n            Log.i(AbstractYasmeActivity.TAG, \"Registration not found.\");\n            return \"\";\n        }\n        // Check if app was updated; if so, it must clear the registration ID\n        // since the existing regID is not guaranteed to work with the new\n        // app version.\n        int registeredVersion = prefs.getInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, Integer.MIN_VALUE);\n        int currentVersion = getAppVersion(context);\n        if (registeredVersion != currentVersion) {\n            Log.i(AbstractYasmeActivity.TAG, \"App version changed.\");\n            return \"\";\n        }\n        return registrationId;\n    }\n\n    public SharedPreferences getGCMPreferences(Context context) {\n        return context.getSharedPreferences(LoginActivity.class.getSimpleName(),\n                Context.MODE_PRIVATE);\n    }\n\n    public int getAppVersion(Context context) {\n        try {\n            PackageInfo packageInfo = context.getPackageManager()\n                    .getPackageInfo(context.getPackageName(), 0);\n            return packageInfo.versionCode;\n        } catch (PackageManager.NameNotFoundException e) {\n            throw new RuntimeException(\"Could not get package name: \" + e);\n        }\n    }\n\n    public String registerInBackground() {\n        try {\n            if (gcm == null) {\n                gcm = GoogleCloudMessaging.getInstance(context);\n            }\n            regid = gcm.register(AbstractYasmeActivity.SENDER_ID);\n\n            Log.d(this.getClass().getSimpleName(), \"Device registered, registration ID=\" + regid);\n\n            // Persist the regID - no need to register again.\n            storeRegistrationId(context, regid);\n            return regid;\n        } catch (IOException e) {\n            // If there is an error, don't just keep trying to register.\n            // Require the user to click a button again, or perform\n            // exponential back-off.\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return null;\n        }\n    }\n\n    private void storeRegistrationId(Context context, String regId) {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        int appVersion = getAppVersion(context);\n        Log.i(AbstractYasmeActivity.TAG, \"Saving regId on app version \" + appVersion);\n        SharedPreferences.Editor editor = prefs.edit();\n        editor.putString(AbstractYasmeActivity.PROPERTY_REG_ID, regId);\n        editor.putInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, appVersion);\n        editor.commit();\n\n        // For Developer-Devices only\n        if (DebugManager.INSTANCE.isDebugMode()) {\n            Log.d(getClass().getSimpleName(), \"Store gcmId to external storage\");\n            DebugManager.INSTANCE.storePushId(regId);\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/storage/DebugManager.java\npublic enum DebugManager {\r\n    INSTANCE;\r\n\r\n    private final String OWNDEVICE = \"owndevice\";\r\n    private final String MESSAGEKEYS = \"messagekeys\";\r\n\r\n    private boolean debugMode = false;\r\n    private OwnDevice ownDevice = new OwnDevice();\r\n\r\n    public boolean isDebugMode() {\r\n        return debugMode;\r\n    }\r\n\r\n    public boolean storeDeviceId(long deviceId) {\r\n        ownDevice.setId(deviceId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n\r\n    public boolean storePrivatePublicKeyToExternalStorage(String privateKey, String publicKey) {\r\n        ownDevice.setPrivateKey(privateKey);\r\n        ownDevice.setPublicKey(publicKey);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    public boolean storePushId(String pushId) {\r\n        ownDevice.setPushId(pushId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    private boolean storeOwnDeviceToExternalStorage() {\r\n        return storeToExternalStorage(OWNDEVICE, ownDevice, false);\r\n    }\r\n\r\n    public boolean storeMessageKeyToExternalStorage(MessageKey data) {\r\n        return storeToExternalStorage(MESSAGEKEYS, data, true);\r\n    }\r\n\r\n    private boolean storeToExternalStorage(String name, Object data, boolean append) {\r\n        try {\r\n            String state = Environment.getExternalStorageState();\r\n            Log.d(getClass().getSimpleName(), \"Check state\");\r\n            if (!Environment.MEDIA_MOUNTED.equals(state)) {\r\n                return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            Log.d(getClass().getSimpleName(), \"Mkdir\");\r\n            if (!dir.exists() && !dir.mkdirs()) {\r\n                Log.d(getClass().getSimpleName(), \"... failed\");\r\n               return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            File file = new File(dir,name + \".txt\");\r\n            Log.d(getClass().getSimpleName(), \"Write file\");\r\n\r\n            ObjectWriter objectWriter = new ObjectMapper().writer();\r\n            String json = objectWriter.writeValueAsString(data);\r\n            Log.d(getClass().getSimpleName(),\"Generated JSON: \" + json);\r\n\r\n            FileOutputStream f = new FileOutputStream(file,append);\r\n            PrintWriter pw = new PrintWriter(f);\r\n            if (append) {\r\n                pw.println(json + \",\");\r\n            } else {\r\n                pw.println(json);\r\n            }\r\n            pw.flush();\r\n            pw.close();\r\n            f.close();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean restoreData() {\r\n        Log.d(getClass().getSimpleName(),\"Restoring data\");\r\n        if (!restoreOwnDeviceFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring OwnDevice failed\");\r\n            return false;\r\n        }\r\n        if (!restoreMessageKeysFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring MessageKeys failed\");\r\n            return false;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Restoring successful\");\r\n        Toaster.getInstance().toast(\"Restoring Debug-Data successful\", Toast.LENGTH_LONG);\r\n        return true;\r\n    }\r\n\r\n\r\n    private boolean restoreOwnDeviceFromExternalStorage() {\r\n         final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n         final String PRIVATEKEY = \"privateKey\";\r\n         final String PUBLICKEY = \"publicKey\";\r\n\r\n        try {\r\n            OwnDevice device = getOwnDeviceFromExternalStorage();\r\n            if (device == null) {\r\n                Log.d(getClass().getSimpleName(), \"Device is null\");\r\n                return false;\r\n            }\r\n\r\n            // Restore devId\r\n            Log.d(getClass().getSimpleName(), \"Restore devId\");\r\n            SharedPreferences.Editor editor1 = DatabaseManager.INSTANCE.getSharedPreferences().edit();\r\n            editor1.putLong(AbstractYasmeActivity.DEVICE_ID, ownDevice.getId());\r\n            editor1.commit();\r\n\r\n            // Restore pushId and app version\r\n            Log.d(getClass().getSimpleName(), \"Restore pushId\");\r\n            SharedPreferences prefs = DatabaseManager.INSTANCE.getContext().getSharedPreferences(LoginActivity.class.getSimpleName(), Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor editor2 = prefs.edit();\r\n            editor2.putString(AbstractYasmeActivity.PROPERTY_REG_ID, ownDevice.getPushId());\r\n            editor2.commit();\r\n\r\n            // Restore PrivatePublicKey\r\n            Log.d(getClass().getSimpleName(), \"Restore PrivPubKeys\");\r\n            String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + ownDevice.getId();\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            keyeditor.putString(PRIVATEKEY, device.getPrivateKey());\r\n            keyeditor.putString(PUBLICKEY,device.getPublicKey());\r\n            keyeditor.commit();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private OwnDevice getOwnDeviceFromExternalStorage() {\r\n        String text = readText(OWNDEVICE);\r\n        if (text == null || text == \"\") {\r\n            return null;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Device-Text: \" + text);\r\n        try {\r\n            OwnDevice device = new ObjectMapper().readValue(text, OwnDevice.class);\r\n            Log.d(getClass().getSimpleName(), \"PubKey: \" + device.getPublicKey());\r\n            return device;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private boolean restoreMessageKeysFromExternalStorage() {\r\n        String text = readText(MESSAGEKEYS);\r\n        if (text == null) {\r\n            return false;\r\n        }\r\n        if (text == \"\") {\r\n            // No messageKey stored yet\r\n            return true;\r\n        }\r\n        String json = \"[\" + text + \"{}]\";\r\n        Log.d(getClass().getSimpleName(), \"MessageKeys-Text: \" + text);\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"JSON: \" + json);\r\n            JSONArray jsonArray = new JSONArray(json);\r\n\r\n            for (int i = 0; i < jsonArray.length() - 1; i++) {\r\n                MessageKey messageKey = new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\r\n                        toString(), MessageKey.class);\r\n                messageKey.setAuthenticity(true);\r\n                DatabaseManager.INSTANCE.getMessageKeyDAO().addOrUpdate(messageKey);\r\n            }\r\n\r\n            return true;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private String readText(String name) {\r\n        String filename = \"\";\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            if (!dir.exists()) {\r\n                return null;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            filename = dir.getAbsolutePath() + \"/\" + name + \".txt\";\r\n\r\n\r\n            BufferedReader br = new BufferedReader(new FileReader(filename));\r\n            StringBuilder sb = new StringBuilder();\r\n            String line = br.readLine();\r\n\r\n            while (line != null) {\r\n                sb.append(line);\r\n                line = br.readLine();\r\n            }\r\n            br.close();\r\n            return sb.toString();\r\n        } catch (FileNotFoundException e) {\r\n            Log.e(getClass().getSimpleName(), \"File \" + filename + \" not found.\");\r\n            return \"\";\r\n        }\r\n        catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private File getDir() {\r\n        return new File(Environment.getExternalStoragePublicDirectory(\"yasme\"), String.valueOf(DatabaseManager.INSTANCE.getUserId()));\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/connection/DeviceTask.java\npublic class DeviceTask extends ConnectionTask {\n\n    private static DeviceTask instance;\n\n    public static DeviceTask getInstance() {\n        if (instance == null) {\n            synchronized (DeviceTask.class) {\n                if (null == instance) {\n                    instance = new DeviceTask();\n                }\n            }\n        }\n        return instance;\n    }\n\n    private DeviceTask() {\n        try {\n            this.uri = new URIBuilder(baseURI).setPath(ConnectionTask.APIVERSION + \"/device\").build();\n        } catch (URISyntaxException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n    }\n\n    public Long registerDevice(OwnDevice device) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.POST, \"\", device);\n\n            //Log.d(this.getClass().getSimpleName(), \"Device registration was successful\");\n\n            long deviceId = (new JSONObject((new BufferedReader(\n                    new InputStreamReader(httpResponse.getEntity()\n                            .getContent())\n            )).readLine())).getLong(\"id\");\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n            return deviceId;\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n        return null;\n    }\n\n    public Device getDevice(long devId) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, String.valueOf(devId));\n            return new ObjectMapper().readValue(new BufferedReader(new InputStreamReader(httpResponse.getEntity()\n                    .getContent())).readLine(), Device.class);\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        }\n    }\n\n    public ArrayList<Device> getAllDevices(Long userId) throws RestServiceException {\n\n        ArrayList<Device> devices = new ArrayList<Device>();\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, \"all/\" + userId);\n\n            JSONArray jsonArray = new JSONArray(new BufferedReader(new InputStreamReader(\n                    httpResponse.getEntity().getContent())).readLine());\n\n            for (int i = 0; i < jsonArray.length(); i++)\n                devices.add(new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\n                        toString(), Device.class));\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n\n        //Log.d(this.getClass().getSimpleName(), \"No.Devices: \" + devices.size());\n        return devices;\n    }\n\n    public void deleteDevice(long deviceId) throws RestServiceException {\n        executeRequest(Request.DELETE, Long.toString(deviceId));\n        //Log.d(this.getClass().getSimpleName(), \"Device removed!\");\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/User.java\n@JsonIgnoreProperties(ignoreUnknown = true)\n@DatabaseTable(tableName = DatabaseConstants.USER_TABLE)\npublic class User implements Serializable {\n\n    @DatabaseField(columnName = DatabaseConstants.USER_ID, id = true)\n    private long id;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_NAME)\n    private String name;\n\n    //@DatabaseField(columnName = DatabaseConstants.USER_EMAIL)\n    private String email;\n\n    private String pw;\n\n    @JsonIgnore\n    private List<Device> devices;   // Just for convenience\n\n    @DatabaseField(columnName = DatabaseConstants.USER_LAST_MODIFIED)\n    private Date lastModified;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_CREATED)\n    private Date created;\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.USER_PICTURE)\n    private String profilePicture;\n\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.CONTACT)\n    private int contactFlag = 0;\n\n\n    public User(String pw, String name, String email) {\n        this.pw = pw;\n        this.name = name;\n        this.email = email;\n    }\n\n    public User(String email, String pw) {\n        this.email = email;\n        this.pw = pw;\n    }\n\n    public User(String name, long id) {\n        this.name = name;\n        this.id = id;\n    }\n\n    public User(long id) {\n        this.id = id;\n    }\n\n    public User(String name, String email, long id) {\n        this.name = name;\n        this.email = email;\n        this.id = id;\n    }\n\n    public User() {\n        // ORMLite needs a no-arg constructor\n    }\n\n    /*\n     * Getters\n     */\n\n    @JsonIgnoreProperties({\"id\", \"user\", \"publicKey\", \"product\", \"lastModified\"})\n    public List<Device> getDevices() {\n        return devices;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPw() {\n        return pw;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Date getLastModified() {\n        return lastModified;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public String getProfilePicture() {\n        return profilePicture;\n    }\n\n    /*\n     * Setters\n     */\n\n    public void setDevices(List<Device> devices) {\n        this.devices = devices;\n    }\n\n    public void setPw(String pw) {\n        this.pw = pw;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setProfilePicture(String profilePicture) {\n        this.profilePicture = profilePicture;\n    }\n\n    @JsonIgnore\n    public void addToContacts() {\n        contactFlag = 1;\n    }\n\n    @JsonIgnore\n    public void removeFromContacts() {\n        contactFlag = 0;\n    }\n\n    @JsonIgnore\n    public boolean isContact() {\n        return contactFlag == 1;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/ObservableRegistry.java\npublic class ObservableRegistry {\n\n    private static ArrayList<ObservableRegistryEntry> entries = new ArrayList<ObservableRegistryEntry>();\n\n    public static <T extends NotifiableFragment<P>, P> FragmentObservable<T, P> getObservable(Class fragmentClass) {\n        for (ObservableRegistryEntry entry : entries) {\n            if (entry.check(fragmentClass)) {\n                Log.d(\"ObserverRegistry\",\"Returned existing observable\");\n                return (FragmentObservable<T,P>) entry.getObs(); // no idea how to solve this... \n            }\n        }\n\n        FragmentObservable<T, P> res = new FragmentObservable<T, P>();\n        Log.d(\"ObserverRegistry\",\"Created new observable\");\n        entries.add(new ObservableRegistryEntry<P>(res,fragmentClass));\n        return res;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/Log.java\npublic class Log {\r\n    static final boolean LOG_I = BuildConfig.DEBUG;\r\n    static final boolean LOG_E = BuildConfig.DEBUG;\r\n    static final boolean LOG_D = BuildConfig.DEBUG;\r\n    static final boolean LOG_V = BuildConfig.DEBUG;\r\n    static final boolean LOG_W = BuildConfig.DEBUG;\r\n\r\n    public static void i(String tag, String string) {\r\n        if (LOG_I) android.util.Log.i(tag, string);\r\n    }\r\n    public static void e(String tag, String string) {\r\n        if (LOG_E) android.util.Log.e(tag, string);\r\n    }\r\n    public static void d(String tag, String string) {\r\n        if (LOG_D) android.util.Log.d(tag, string);\r\n    }\r\n    public static void v(String tag, String string) {\r\n        if (LOG_V) android.util.Log.v(tag, string);\r\n    }\r\n    public static void w(String tag, String string) {\r\n        if (LOG_W) android.util.Log.w(tag, string);\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/exception/RestServiceException.java\npublic class RestServiceException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate int code;\n\n\tpublic RestServiceException(ErrorCode error) {\n\n\t\tthis(error.getDescription(), error.getNumber());\n\n\t}\n\n\tpublic RestServiceException(String message, int code) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\n\t\tSystem.err.println(\"Code: \" + this.code + \"  \" + \"Message: \"\n\t\t\t\t+ this.getMessage());\n\t}\n\n    public int getCode() {\n        return code;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/contacts/QR.java\npublic class QR {\n    private static final int SIZE = 1024;\n    private static Bitmap qrCode;\n    private static boolean isRunning = false;\n\n    public static void init(boolean force) {\n        if (force) {\n            qrCode = null;\n            isRunning = false;\n        }\n        if (qrCode == null && !isRunning) {\n            isRunning = true;\n            new QRTask().execute();\n        }\n    }\n\n    public static void finished() {\n        isRunning = false;\n    }\n\n    public Bitmap generateQRCode() {\n        if (qrCode != null) {\n            return qrCode;\n        }\n        QRData qrdata = new QRData();\n        DatabaseManager db = DatabaseManager.INSTANCE;\n        qrdata.setDeviceId(db.getDeviceId());\n\n        Context context = db.getContext();\n        String RSAKEY_STORAGE_USER = KeyEncryption.RSAKEY_STORAGE + \"_\" + db.getDeviceId();\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\n        String pubKeyInBase64 = privKeyStorage.getString(KeyEncryption.PUBLICKEY, \"\");\n        qrdata.setPublicKey(pubKeyInBase64);\n\n        //ObjectWriter objectWriter = new ObjectMapper().writer().withDefaultPrettyPrinter();\n        ObjectWriter objectWriter = new ObjectMapper().writer();\n        try {\n            String data = objectWriter.writeValueAsString(qrdata);\n            qrCode = generateQRCode(data);\n            return qrCode;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public Bitmap generateQRCode(String data) {\n        Log.d(getClass().getName(), \"Generate QR for \" + data);\n        com.google.zxing.Writer writer = new QRCodeWriter();\n        BitMatrix bm;\n        try {\n            bm = writer.encode(data, BarcodeFormat.QR_CODE,SIZE, SIZE);\n        } catch (Exception e) {\n            return null;\n        }\n\n        Bitmap imageBitmap = Bitmap.createBitmap(SIZE, SIZE, Bitmap.Config.ARGB_8888);\n\n        for (int i = 0; i < SIZE; i++) {//width\n            for (int j = 0; j < SIZE; j++) {//height\n                imageBitmap.setPixel(i, j, bm.get(i, j) ? Color.BLACK: Color.WHITE);\n            }\n        }\n        return imageBitmap;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/OwnDevice.java\npublic class OwnDevice {\n\n    public enum Platform {\n        ANDROID,\n        IOS,\n        WINDOWSPHONE;\n    }\n\n    private long id;\n    private Platform platform; // android, ios or windowsmobile\n    private String type;    // mobilephone, tablet or desktop\n    private User user;\n    private String number;  // optional\n    private String publicKey;\n    private String privateKey;\n    private String product; // product name e.g. Google Nexux 5\n    private String pushId;\n\n    private Date created;\n\n    private Date lastModified;\n\n    public OwnDevice(User user, Platform platform, String publicKey, String type, String number, String product, String pushId) {\n        this.user = user;\n        this.platform = platform;\n        this.type = type;\n        this.number = number;\n        this.product = product;\n        this.pushId = pushId;\n        this.publicKey = publicKey;\n    }\n\n    public OwnDevice() {\n    }\n\n    public OwnDevice(long id) {\n        this.id = id;\n    }\n\n    @JsonIgnoreProperties({ \"pw\", \"email\", \"name\", \"devices\", \"lastModified\", \"created\" })\n    public User getUser() {\n        return this.user;\n    }\n\n    public String getPushId(){return this.pushId;}\n\n    public String getProduct(){return this.product;}\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setProduct(String product){this.product = product;}\n\n    public void setUser(User user) {\n        this.user = user;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Platform getPlatform() {\n        return platform;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public void setPlatform(Platform platform) {\n        this.platform = platform;\n    }\n\n    public void setPushId(String pushId){this.pushId = pushId;}\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public void setNumber(String number) {\n        this.number = number;\n    }\n\n    public String getPublicKey() {\n        return publicKey;\n    }\n\n    public void setPublicKey(String publicKey) {\n        this.publicKey = publicKey;\n    }\n\n    public Date getCreated() {\n        return this.created;\n    }\n\n    public Date getLastModified() {\n        return this.lastModified;\n    }\n\n    public String getPrivateKey() {\n        return privateKey;\n    }\n\n    public void setPrivateKey(String privateKey) {\n        this.privateKey = privateKey;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/SpinnerObservable.java\npublic class SpinnerObservable {\r\n    private Set<AsyncTask> backgroundTasks;\r\n    private Set<AbstractYasmeActivity> activities;\r\n    private boolean spinning = false;\r\n\r\n    private static SpinnerObservable instance;\r\n\r\n    public static SpinnerObservable getInstance() {\r\n        if (instance == null) {\r\n            instance = new SpinnerObservable();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    private SpinnerObservable() {\r\n        backgroundTasks = new HashSet<>();\r\n        activities = new HashSet<>();\r\n    }\r\n\r\n    public void registerActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Register activity\");\r\n        activities.add(activity);\r\n        if (spinning) {\r\n            Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n            activity.startSpinning();\r\n        } else {\r\n            Log.d(getClass().getSimpleName(), \"No spinning\");\r\n        }\r\n    }\r\n\r\n    public void removeActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Remove activity\");\r\n        activities.remove(activity);\r\n    }\r\n\r\n    public void registerBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Register backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.add(backgroundTask);\r\n        spinning = true;\r\n        startSpinning();\r\n    }\r\n\r\n    public void removeBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Remove backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.remove(backgroundTask);\r\n        if (backgroundTasks.size() == 0) {\r\n            spinning = false;\r\n            stopSpinning();\r\n        }\r\n    }\r\n\r\n    public void startSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.startSpinning();\r\n        }\r\n    }\r\n\r\n    public void stopSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Stop spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.stopSpinning();\r\n        }\r\n    }\r\n}\r\n", "answers": ["        } catch (RestServiceException e) {"], "length": 5741, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "6844939b4c4619bf2bb691b26c2beecaad85f0aeb4518366"}
{"input": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.MockitoAnnotations.initMocks;\nimport java.security.cert.X509Certificate;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Matchers;\nimport org.mockito.Mock;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.u2f.TestVectors;\nimport com.google.u2f.U2FException;\nimport com.google.u2f.server.ChallengeGenerator;\nimport com.google.u2f.server.Crypto;\nimport com.google.u2f.server.DataStore;\nimport com.google.u2f.server.SessionIdGenerator;\nimport com.google.u2f.server.U2FServer;\nimport com.google.u2f.server.data.EnrollSessionData;\nimport com.google.u2f.server.data.SecurityKeyData;\nimport com.google.u2f.server.data.SecurityKeyData.Transports;\nimport com.google.u2f.server.data.SignSessionData;\nimport com.google.u2f.server.messages.RegisteredKey;\nimport com.google.u2f.server.messages.RegistrationRequest;\nimport com.google.u2f.server.messages.RegistrationResponse;\nimport com.google.u2f.server.messages.SignResponse;\nimport com.google.u2f.server.messages.U2fSignRequest;\n\n  @Test\n  public void testGetRegistrationRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationRequest registrationRequest = u2fServer.getRegistrationRequest(ACCOUNT_NAME, APP_ID_ENROLL);\n\n    assertEquals(new RegistrationRequest(\"U2F_V2\", SERVER_CHALLENGE_ENROLL_BASE64, APP_ID_ENROLL,\n        SESSION_ID), registrationRequest);\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_noTransports() throws U2FException {\n\t  when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX, VENDOR_CERTIFICATE, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_oneTransport() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_ONE_TRANSPORT);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_ONE_TRANSPORT, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_multipleTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    transports.add(Transports.BLUETOOTH_LOW_ENERGY);\n    transports.add(Transports.NFC);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_malformedTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse2() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(VENDOR_CERTIFICATE);\n    trustedCertificates.add(TRUSTED_CERTIFICATE_2);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_2_BASE64,\n        BROWSER_DATA_2_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE_2, USER_PUBLIC_KEY_2,\n            TRUSTED_CERTIFICATE_2, 0)));\n  }\n\n  @Test\n  public void testGetSignRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n    when(mockChallengeGenerator.generateChallenge(ACCOUNT_NAME)).thenReturn(SERVER_CHALLENGE_SIGN);\n", "context": "u2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationRequest.java\npublic class RegistrationRequest {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegistrationRequest(String version, String challenge, String appId, String sessionId) {\n    this.version = version;\n    this.challenge = challenge;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(challenge, version, sessionId, appId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationRequest other = (RegistrationRequest) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(challenge, other.challenge)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic enum Transports {\n  BLUETOOTH_BREDR(\"bt\"),\n  BLUETOOTH_LOW_ENERGY(\"ble\"),\n  USB(\"usb\"),\n  NFC(\"nfc\");\n\n  private String mValue;\n\n  Transports(String value) {\n    mValue = value;\n  }\n\n  @Override\n  public String toString() {\n    return mValue;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationResponse.java\npublic class RegistrationResponse {\n  /** websafe-base64(raw registration response message) */\n  private final String registrationData;\n\n  /** websafe-base64(UTF8(stringified(client data))) */\n  private final String clientData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n  public RegistrationResponse(String registrationData, String clientData, String sessionId) {\n    this.registrationData = registrationData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getRegistrationData() {\n    return registrationData;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(registrationData, clientData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationResponse other = (RegistrationResponse) obj;\n    if (clientData == null) {\n      if (other.clientData != null)\n        return false;\n    } else if (!clientData.equals(other.clientData))\n      return false;\n    if (registrationData == null) {\n      if (other.registrationData != null)\n        return false;\n    } else if (!registrationData.equals(other.registrationData))\n      return false;\n    if (sessionId == null) {\n      if (other.sessionId != null)\n        return false;\n    } else if (!sessionId.equals(other.sessionId))\n      return false;\n    return true;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SignSessionData.java\npublic class SignSessionData extends EnrollSessionData {\n  private static final long serialVersionUID = -1374014642398686120L;\n\n  private final byte[] publicKey;\n\n  public SignSessionData(String accountName, String appId, byte[] challenge, byte[] publicKey) {\n    super(accountName, appId, challenge);\n    this.publicKey = publicKey;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/SignResponse.java\npublic class SignResponse {\n\n  /** websafe-base64 key handle from U2F device */\n  private final String keyHandle;\n\n  /** websafe-base64(client data) */\n  private final String clientData;\n\n  /** websafe-base64(raw response from U2F device) */\n  private final String signatureData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n\n  public SignResponse(String keyHandle, String signatureData, String clientData, String sessionId) {\n    this.keyHandle = keyHandle;\n    this.signatureData = signatureData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSignatureData() {\n    return signatureData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(keyHandle, clientData, signatureData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (getClass() != obj.getClass())\n      return false;\n    SignResponse other = (SignResponse) obj;\n    return Objects.equals(keyHandle, other.keyHandle)\n        && Objects.equals(clientData, other.clientData)\n        && Objects.equals(signatureData, other.signatureData)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic class SecurityKeyData {\n  public enum Transports {\n    BLUETOOTH_BREDR(\"bt\"),\n    BLUETOOTH_LOW_ENERGY(\"ble\"),\n    USB(\"usb\"),\n    NFC(\"nfc\");\n\n    private String mValue;\n\n    Transports(String value) {\n      mValue = value;\n    }\n\n    @Override\n    public String toString() {\n      return mValue;\n    }\n  }\n\n  private final long enrollmentTime;\n  private final List<Transports> transports;\n  private final byte[] keyHandle;\n  private final byte[] publicKey;\n  private final X509Certificate attestationCert;\n  private int counter;\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this(enrollmentTime, null /* transports */, keyHandle, publicKey, attestationCert, counter);\n  }\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      List<Transports> transports,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this.enrollmentTime = enrollmentTime;\n    this.transports = transports;\n    this.keyHandle = keyHandle;\n    this.publicKey = publicKey;\n    this.attestationCert = attestationCert;\n    this.counter = counter;\n  }\n\n  /**\n   * When these keys were created/enrolled with the relying party.\n   */\n  public long getEnrollmentTime() {\n    return enrollmentTime;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public byte[] getKeyHandle() {\n    return keyHandle;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n\n  public X509Certificate getAttestationCertificate() {\n    return attestationCert;\n  }\n\n  public int getCounter() {\n    return counter;\n  }\n\n  public void setCounter(int newCounterValue) {\n    counter = newCounterValue;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        enrollmentTime,\n        transports,\n        keyHandle,\n        publicKey,\n        attestationCert,\n        counter);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (!(obj instanceof SecurityKeyData)) {\n      return false;\n    }\n    SecurityKeyData that = (SecurityKeyData) obj;\n    return Arrays.equals(this.keyHandle, that.keyHandle)\n        && (this.enrollmentTime == that.enrollmentTime)\n        && containSameTransports(this.transports, that.transports)\n        && Arrays.equals(this.publicKey, that.publicKey)\n        && Objects.equals(this.attestationCert, that.attestationCert)\n        && Objects.equals(counter, counter);\n  }\n\n  /**\n   * Compares the two Lists of Transports and says if they are equal.\n   *\n   * @param transports1 first List of Transports\n   * @param transports2 second List of Transports\n   * @return true if both lists are null or if both lists contain the same transport values\n   */\n  public static boolean containSameTransports(List<Transports> transports1,\n      List<Transports> transports2) {\n    if (transports1 == null && transports2 == null) {\n      return true;\n    } else if (transports1 == null || transports2 == null) {\n      return false;\n    }\n    return transports1.containsAll(transports2) && transports2.containsAll(transports1);\n  }\n\n  @Override\n  public String toString() {\n    return new StringBuilder()\n      .append(\"public_key: \")\n      .append(Base64.encodeBase64URLSafeString(publicKey))\n      .append(\"\\n\")\n      .append(\"key_handle: \")\n      .append(Base64.encodeBase64URLSafeString(keyHandle))\n      .append(\"\\n\")\n      .append(\"counter: \")\n      .append(counter)\n      .append(\"\\n\")\n      .append(\"attestation certificate:\\n\")\n      .append(attestationCert.toString())\n      .append(\"transports: \")\n      .append(transports)\n      .append(\"\\n\")\n      .toString();\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/U2fSignRequest.java\npublic class U2fSignRequest {\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n  /** List of registered keys */\n  private List<RegisteredKey> registeredKeys;\n\n  public U2fSignRequest(String challenge, List<RegisteredKey> registeredKeys) {\n    this.challenge = challenge;\n    this.registeredKeys = registeredKeys;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public List<RegisteredKey> getRegisteredKeys() {\n    return registeredKeys;\n  }\n\n  public JsonArray getRegisteredKeysAsJson(String defaultAppId) {\n    if (registeredKeys == null) {\n      return null;\n    }\n    JsonArray result = new JsonArray();\n    for (RegisteredKey registeredKey : registeredKeys) {\n      result.add(registeredKey.getJson(defaultAppId));\n    }\n    return result;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/U2FServer.java\npublic interface U2FServer {\n\n  // registration //\n  public RegistrationRequest getRegistrationRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processRegistrationResponse(RegistrationResponse registrationResponse,\n      long currentTimeInMillis) throws U2FException;\n\n  // authentication //\n  public U2fSignRequest getSignRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processSignResponse(SignResponse signResponse) throws U2FException;\n\n  // token management //\n  public List<SecurityKeyData> getAllSecurityKeys(String accountName);\n\n  public void removeSecurityKey(String accountName, byte[] publicKey) throws U2FException;\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/EnrollSessionData.java\npublic class EnrollSessionData implements Serializable {\n  private static final long serialVersionUID = 1750990095756334568L;\n\n  private final String accountName;\n  private final byte[] challenge;\n  private final String appId;\n\n  public EnrollSessionData(String accountName, String appId, byte[] challenge) {\n    this.accountName = accountName;\n    this.challenge = challenge;\n    this.appId = appId;\n  }\n\n  public String getAccountName() {\n    return accountName;\n  }\n\n  public byte[] getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n\treturn appId;\n  }\n}\nu2f-ref-code/java/tests/com/google/u2f/TestVectors.java\npublic class TestVectors {\n  // Test vectors from FIDO U2F: Raw Message Formats - Draft 4\n  protected static final int COUNTER_VALUE = 1;\n  protected static final String ACCOUNT_NAME = \"test@example.com\";\n  protected static final Set<String> TRUSTED_DOMAINS = ImmutableSet.of(\"http://example.com\");\n  protected static final String SESSION_ID = \"session_id\";\n  protected static final String APP_ID_ENROLL = \"http://example.com\";\n  protected static final byte[] APP_ID_ENROLL_SHA256 = computeSha256(APP_ID_ENROLL);\n  protected static final String APP_ID_SIGN = \"https://gstatic.com/securitykey/a/example.com\";\n  protected static final byte[] APP_ID_SIGN_SHA256 = computeSha256(APP_ID_SIGN);\n  protected static final String ORIGIN = \"http://example.com\";\n  protected static final String SERVER_CHALLENGE_ENROLL_BASE64 =\n      \"vqrS6WXDe1JUs5_c3i4-LkKIHRr-3XVb3azuA5TifHo\";\n  protected static final byte[] SERVER_CHALLENGE_ENROLL =\n      Base64.decodeBase64(SERVER_CHALLENGE_ENROLL_BASE64);\n  protected static final String SERVER_CHALLENGE_SIGN_BASE64 =\n      \"opsXqUifDriAAmWclinfbS0e-USY0CgyJHe_Otd7z8o\";\n  protected static final byte[] SERVER_CHALLENGE_SIGN =\n      Base64.decodeBase64(SERVER_CHALLENGE_SIGN_BASE64);\n  protected static final String VENDOR_CERTIFICATE_HEX =\n      \"3082013c3081e4a003020102020a47901280001155957352300a06082a8648ce\"\n      + \"3d0403023017311530130603550403130c476e756262792050696c6f74301e17\"\n      + \"0d3132303831343138323933325a170d3133303831343138323933325a303131\"\n      + \"2f302d0603550403132650696c6f74476e756262792d302e342e312d34373930\"\n      + \"313238303030313135353935373335323059301306072a8648ce3d020106082a\"\n      + \"8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c144668\"\n      + \"2c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23abaf02\"\n      + \"03b4b8911ba0569994e101300a06082a8648ce3d0403020347003044022060cd\"\n      + \"b6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30dfa0220\"\n      + \"631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b30410df\";\n  protected static final X509Certificate VENDOR_CERTIFICATE =\n      parseCertificate(VENDOR_CERTIFICATE_HEX);\n  protected static final PrivateKey VENDOR_CERTIFICATE_PRIVATE_KEY =\n      parsePrivateKey(\"f3fccc0d00d8031954f90864d43c247f4bf5f0665c6b50cc17749a27d1cf7664\");\n  protected static final String CHANNEL_ID_STRING =\n      \"{\"\n      + \"\\\"kty\\\":\\\"EC\\\",\"\n      + \"\\\"crv\\\":\\\"P-256\\\",\"\n      + \"\\\"x\\\":\\\"HzQwlfXX7Q4S5MtCCnZUNBw3RMzPO9tOyWjBqRl4tJ8\\\",\"\n      + \"\\\"y\\\":\\\"XVguGFLIZx1fXg3wNqfdbn75hi4-_7-BxhMljw42Ht4\\\"\"\n      + \"}\";\n  protected static final JsonObject CHANNEL_ID_JSON =\n      (JsonObject) new JsonParser().parse(CHANNEL_ID_STRING);\n  protected static final String BROWSER_DATA_ENROLL = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.finishEnrollment\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_ENROLL_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_ENROLL_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_ENROLL.getBytes());\n  protected static final byte[] BROWSER_DATA_ENROLL_SHA256 =\n      computeSha256(BROWSER_DATA_ENROLL.getBytes());\n  protected static final String BROWSER_DATA_SIGN = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.getAssertion\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_SIGN_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_SIGN_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_SIGN.getBytes());\n  protected static final byte[] BROWSER_DATA_SIGN_SHA256 =\n      parseHex(\"ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc57\");\n  protected static final byte[] REGISTRATION_REQUEST_DATA =\n      parseHex(\"4142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfacb\"\n          + \"f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1c4\");\n  protected static final byte[] REGISTRATION_RESPONSE_DATA =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2\"\n          + \"e3925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772\"\n          + \"d70c253082013c3081e4a003020102020a47901280001155957352300a06082a\"\n          + \"8648ce3d0403023017311530130603550403130c476e756262792050696c6f74\"\n          + \"301e170d3132303831343138323933325a170d3133303831343138323933325a\"\n          + \"3031312f302d0603550403132650696c6f74476e756262792d302e342e312d34\"\n          + \"373930313238303030313135353935373335323059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c\"\n          + \"1446682c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23\"\n          + \"abaf0203b4b8911ba0569994e101300a06082a8648ce3d040302034700304402\"\n          + \"2060cdb6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30d\"\n          + \"fa0220631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b3\"\n          + \"0410df304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80f\"\n          + \"cab017db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5\"\n          + \"ad7804a6d3d3961ef871\");\n  protected static final String REGISTRATION_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA);\n\n  // Has Bluetooth Radio transport\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc\"\n          + \"6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552d\"\n          + \"fdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab6\"\n          + \"1d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019a30820140\"\n          + \"a0030201020209012242000255962657300a06082a8648ce3d0403023045310b30090\"\n          + \"603550406130241553113301106035504080c0a536f6d652d53746174653121301f06\"\n          + \"0355040a0c18496e7465726e6574205769646769747320507479204c74643020170d3\"\n          + \"135303830353136353131325a180f32303633303630373136353131325a3045310b30\"\n          + \"090603550406130241553113301106035504080c0a536f6d652d53746174653121301\"\n          + \"f060355040a0c18496e7465726e6574205769646769747320507479204c7464305930\"\n          + \"1306072a8648ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b\"\n          + \"367eb0b8dcb4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932\"\n          + \"d3167e961eb664c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51\"\n          + \"c020101040403020780300a06082a8648ce3d040302034800304502202106e368bbe2\"\n          + \"fc9f86991826b90a51c694b90fb7c01945e7a9531e4b65315ac5022100aa8e75a071e\"\n          + \"645000376150c7faef1b8a57cb4bd41729c28d9b9bec744ebb4493045022070c1b332\"\n          + \"667853491a525850b15599cc88be0433fc673be89e991b550921c2110221008326311\"\n          + \"e0feaf1698110bed2c0737f3614298a8f265121f896db3cad459607fb\");\n  protected static final String REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6\"\n          + \"b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfd\"\n          + \"b7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1\"\n          + \"6591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019930820140a003\"\n          + \"0201020209012242000255962657300a06082a8648ce3d0403023045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643020170d31353038\"\n          + \"30353136343932345a180f32303633303630373136343932345a3045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643059301306072a86\"\n          + \"48ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb\"\n          + \"4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb6\"\n          + \"64c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51c020101040403\"\n          + \"0204d0300a06082a8648ce3d0403020347003044022058b52f205dc9772e1bef915973\"\n          + \"6098290ffb5850769efd1c37cfc97141279e5f02200c4d91c96c457d1a607a0d16b0b5\"\n          + \"47bbb2e5e2865490112e4b94607b3adcad18304402202548b5204488995f00c905d2b9\"\n          + \"25ca2f9b8c0aba76faf3461dc6778864eb5ee3022005f2d852969864577e01c71cbb10\"\n          + \"93412ef0fef518141d698cda2a45fe2bc767\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS);\n\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6b\"\n          + \"952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfdb7\"\n          + \"477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1659\"\n          + \"1659cbaf00b4950f7abfe6660e2e006f76868b772d70c25308201983082013ea0030201\"\n          + \"020209012242000255962657300a06082a8648ce3d0403023045310b300906035504061\"\n          + \"30241553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18\"\n          + \"496e7465726e6574205769646769747320507479204c74643020170d313530383036323\"\n          + \"3333532385a180f32303633303630383233333532385a3045310b300906035504061302\"\n          + \"41553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18496\"\n          + \"e7465726e6574205769646769747320507479204c74643059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb4a61d1fa336\"\n          + \"bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb664c3080347e5\"\n          + \"05626c1d5d15cfa31530133011060b2b0601040182e51c0201010402aa80300a06082a8\"\n          + \"648ce3d0403020348003045022100907f965f33d857982b39d9f4c22ccb4a63359fc10a\"\n          + \"af08a81997c0e04b73dc9b02204f45d556ae2ea71a5fdfa646b516584dada84954a5d8b\"\n          + \"9d27bdb041e89b216b6304402206b5085168e0c0e850677d3423c0f3972860bd3fbf6d2\"\n          + \"d98cd7af9e1d3f46269402201bde430c86260666bcaa23155296bd0627a8e48d98c2009\"\n          + \"212bec8a7a77f7974\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS);\n\n  protected static final byte[] KEY_HANDLE =\n      parseHex(\"2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a\"\n          + \"6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c25\");\n  protected static final String KEY_HANDLE_BASE64 = Base64.encodeBase64URLSafeString(KEY_HANDLE);\n  protected static final byte[] USER_PUBLIC_KEY_ENROLL_HEX =\n      parseHex(\"04b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b65\"\n          + \"7c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6\"\n          + \"d9\");\n  protected static final String USER_PRIVATE_KEY_ENROLL_HEX =\n      \"9a9684b127c5e3a706d618c86401c7cf6fd827fd0bc18d24b0eb842e36d16df1\";\n  protected static final PublicKey USER_PUBLIC_KEY_ENROLL =\n      parsePublicKey(USER_PUBLIC_KEY_ENROLL_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_ENROLL =\n      parsePrivateKey(USER_PRIVATE_KEY_ENROLL_HEX);\n  protected static final KeyPair USER_KEY_PAIR_ENROLL =\n      new KeyPair(USER_PUBLIC_KEY_ENROLL, USER_PRIVATE_KEY_ENROLL);\n  protected static final String USER_PRIVATE_KEY_SIGN_HEX =\n      \"ffa1e110dde5a2f8d93c4df71e2d4337b7bf5ddb60c75dc2b6b81433b54dd3c0\";\n  protected static final byte[] USER_PUBLIC_KEY_SIGN_HEX =\n      parseHex(\"04d368f1b665bade3c33a20f1e429c7750d5033660c019119d29aa4ba7abc04a\"\n          + \"a7c80a46bbe11ca8cb5674d74f31f8a903f6bad105fb6ab74aefef4db8b0025e\"\n          + \"1d\");\n  protected static final PublicKey USER_PUBLIC_KEY_SIGN = parsePublicKey(USER_PUBLIC_KEY_SIGN_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_SIGN =\n      parsePrivateKey(USER_PRIVATE_KEY_SIGN_HEX);\n  protected static final KeyPair USER_KEY_PAIR_SIGN =\n      new KeyPair(USER_PUBLIC_KEY_SIGN, USER_PRIVATE_KEY_SIGN);\n  protected static final byte[] SIGN_REQUEST_DATA =\n      parseHex(\"03ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc\"\n          + \"574b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992\"\n          + \"ca402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3\"\n          + \"925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d7\"\n          + \"0c25\");\n  protected static final byte[] SIGN_RESPONSE_DATA =\n      parseHex(\"0100000001304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030c\"\n          + \"e43d406de870b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f\"\n          + \"53c7b22272ec10047a923f\");\n  protected static final String SIGN_RESPONSE_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(SIGN_RESPONSE_DATA);\n  protected static final byte[] EXPECTED_REGISTER_SIGNED_BYTES =\n      parseHex(\"00f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1\"\n          + \"c44142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfa\"\n          + \"cb2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e392\"\n          + \"5a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c\"\n          + \"2504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9\");\n  protected static final byte[] EXPECTED_AUTHENTICATE_SIGNED_BYTES =\n      parseHex(\"4b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992ca\"\n          + \"0100000001ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c482\"\n          + \"1b3b9dbc57\");\n  protected static final byte[] SIGNATURE_ENROLL =\n      parseHex(\"304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80fcab017\"\n          + \"db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5ad7804\"\n          + \"a6d3d3961ef871\");\n  protected static final byte[] SIGNATURE_AUTHENTICATE =\n      parseHex(\"304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030ce43d406de8\"\n          + \"70b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f53c7b22272\"\n          + \"ec10047a923f\");\n\n  // Test vectors provided by Discretix\n  protected static final String APP_ID_2 = APP_ID_ENROLL;\n  protected static final String CHALLENGE_2_BASE64 = SERVER_CHALLENGE_ENROLL_BASE64;\n  protected static final String BROWSER_DATA_2_BASE64 = BROWSER_DATA_ENROLL_BASE64;\n\n  protected static final String TRUSTED_CERTIFICATE_2_HEX =\n      \"308201443081eaa0030201020209019189ffffffff5183300a06082a8648ce3d\"\n      + \"040302301b3119301706035504031310476e756262792048534d204341203030\"\n      + \"3022180f32303132303630313030303030305a180f3230363230353331323335\"\n      + \"3935395a30303119301706035504031310476f6f676c6520476e756262792076\"\n      + \"3031133011060355042d030a00019189ffffffff51833059301306072a8648ce\"\n      + \"3d020106082a8648ce3d030107034200041f1302f12173a9cbea83d06d755411\"\n      + \"e582a87fbb5850eddcf3607ec759a4a12c3cb392235e8d5b17caee1b34e5b5eb\"\n      + \"548649696257f0ea8efb90846f88ad5f72300a06082a8648ce3d040302034900\"\n      + \"3046022100b4caea5dc60fbf9f004ed84fc4f18522981c1c303155c08274e889\"\n      + \"f3f10c5b23022100faafb4f10b92f4754e3b08b5af353f78485bc903ece7ea91\"\n      + \"1264fc1673b6598f\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_2 =\n      parseCertificate(TRUSTED_CERTIFICATE_2_HEX);\n\n  // Has Bluetooth Radio transport\n  private static final String TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64 =\n      \"MIIBmjCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY1MTEyWhgPMjA2MzA2MDcxNjUxMTJaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIHgDAKBggqhkjO\"\n      + \"PQQDAgNIADBFAiAhBuNou+L8n4aZGCa5ClHGlLkPt8AZReepUx5LZTFaxQIhAKqO\"\n      + \"daBx5kUAA3YVDH+u8bilfLS9QXKcKNm5vsdE67RJ\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_ONE_TRANSPORT =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  private static final String TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64 =\n      \"MIIBmTCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY0OTI0WhgPMjA2MzA2MDcxNjQ5MjRaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIE0DAKBggqhkjO\"\n      + \"PQQDAgNHADBEAiBYtS8gXcl3LhvvkVlzYJgpD/tYUHae/Rw3z8lxQSeeXwIgDE2R\"\n      + \"yWxFfRpgeg0WsLVHu7Ll4oZUkBEuS5RgezrcrRg=\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64);\n\n  private static final String TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64 =\n      \"MIIBmDCCAT6gAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA2MjMzNTI4WhgPMjA2MzA2MDgyMzM1MjhaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxUwEzARBgsrBgEEAYLlHAIBAQQCqoAwCgYIKoZIzj0E\"\n      + \"AwIDSAAwRQIhAJB/ll8z2FeYKznZ9MIsy0pjNZ/BCq8IqBmXwOBLc9ybAiBPRdVW\"\n      + \"ri6nGl/fpka1FlhNrahJVKXYudJ72wQeibIWtg==\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64);\n\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64 =\n      \"MIIBlzCCAQCgAwIBAgICJxAwDQYJKoZIhvcNAQELBQAwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXlt\"\n      + \"YXN0ZXIwHhcNNzAwMTAxMDAwMDAwWhcNNzAwMTAxMDI0NjQwWjAaMRgwFgYDVQQDDA9BIEtleW1h\"\n      + \"c3RlciBLZXkwOjANBgkqhkiG9w0BAQEFAAMpADAmAiEAvKVptjTyP1p0L8rF/XANRuIc/TOmDiBc\"\n      + \"yb0lMri0YpkCAQOjUDBOMEwGCisGAQQB1nkCAREEPjA8MDihBgIBAgIBA4IBAYMCAQClAwIBAKYD\"\n      + \"AgEBn4FIAQOfg3gBAZ+DeQIBLJ+FPQYBUqVEtxCfhT4BADAAMA0GCSqGSIb3DQEBCwUAA4GBAHwH\"\n      + \"DZvsYbkgWAPv7QRa+cxLrFxrmv7M3HxYL7UdbpXP5/5sOp3hkhBdtAwlUW9tgGLdjheFFcz0lUSP\"\n      + \"uK5et199s1ifeNzV4fePlBAGvzKFci6adJgGDMXDodM49jhIEF1KC4xlbwBWR/brl4vZa4h1EZ9H\"\n      + \"ghyoJ3PFFZC8xYOB\";\n  protected static final X509Certificate ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION =\n      parseCertificateBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64);\n\n  /**\n   * Contains a chain where:\n   *   cert[0] = attestation certificate describing some new key\n   *   cert[1] = batch certificate\n   *\n   * Note that cert[1] is signed by another cert that should be known to RPs.\n   */\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64 =\n      \"MIIBjTCCATKgAwIBAgICJxAwCgYIKoZIzj0EAwIwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXltYXN0\"\n      + \"ZXIwIBcNNzAwMTAxMDAwMDAwWhgPMjEwNjAyMDcwNjI4MTVaMBoxGDAWBgNVBAMMD0EgS2V5bWFz\"\n      + \"dGVyIEtleTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABJiTI/rSw9N1NYV3FGxgeJSj1NWyyb61\"\n      + \"/gbdEefKuM3dYOeUZhciSigDY/u9Y3gBKm0wmXsd7DxXibDk/VvGIVWjZDBiMGAGCisGAQQB1nkC\"\n      + \"AREEUjBQAgECBAljaGFsbGVuZ2UwPqEIMQYCAQICAQOiAwIBA6MEAgIBAKUFMQMCAQS/g3gDAgEB\"\n      + \"v4N5BAICASy/hT0IAgYBUqi8MmC/hT4DAgEAMAAwCgYIKoZIzj0EAwIDSQAwRgIhANnmsSeWsnVH\"\n      + \"aF5zII50tkiA7fRhIMNeZZBcPvSV2BN5AiEAwUZm63OxMZEHTIFL50ASKVN/sCLs8+gMY6uEVZRy\"\n      + \"61QwggK2MIICH6ADAgECAgIQADANBgkqhkiG9w0BAQsFADBjMQswCQYDVQQGEwJVUzETMBEGA1UE\"\n      + \"CAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEVMBMGA1UECgwMR29vZ2xlLCBJ\"\n      + \"bmMuMRAwDgYDVQQLDAdBbmRyb2lkMB4XDTE2MDEwNDEyNDA1M1oXDTM1MTIzMDEyNDA1M1owdjEL\"\n      + \"MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFTATBgNVBAoMDEdvb2dsZSwgSW5jLjEQ\"\n      + \"MA4GA1UECwwHQW5kcm9pZDEpMCcGA1UEAwwgQW5kcm9pZCBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBL\"\n      + \"ZXkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMCDI9xWiBu4MCBp9bCFYcbuvn8F4vWoQgSK\"\n      + \"votHvnb+rvJc8psq+jIAFBYBQpmJoV/PxoFes2NYPC/S8gvkmDKD3YFLFtfhhUF65Uq8KWo6bbXA\"\n      + \"BAg7aMVWwfAjOZFkGYZNULdNQK7KSEx3NWyJWgwnWr+sSZ1dfSNi8pxeAuhxAgMBAAGjZjBkMB0G\"\n      + \"A1UdDgQWBBTUDBAb+M1jufc5UrUOE1ym15mThjAfBgNVHSMEGDAWgBQp+vGszE3STJZAJ3W2sOky\"\n      + \"5Qf+LjASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIChDANBgkqhkiG9w0BAQsFAAOB\"\n      + \"gQCeLUhfjGcz3BqFrZnXUCPqFOxDsOGd6sIjRh5ytRncYCLkpWgxbAtVxOacoi2fOk+TazGLFngW\"\n      + \"DYjL2YvMgJ2E8MIn42s48f3R5xdyMVk1fZbzxX+rnY+WYSZPsr6Buw1JBCKKzp/39UIuJUT6IQcS\"\n      + \"WoO1Va0YgvhAFJucIGMEfw==\";\n  protected static final X509Certificate[] ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN =\n      parseCertificateChainBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64);\n\n  protected static final byte[] REGISTRATION_DATA_2 =\n      parseHex(\"0504478E16BBDBBB741A660A000314A8B6BD63095196ED704C52EEBC0FA02A61\"\n          + \"8F19FF59DF18451A11CEE43DEFD9A29B5710F63DFC671F752B1B0C6CA76C8427\"\n          + \"AF2D403C2415E1760D1108105720C6069A9039C99D09F76909C36D9EFC350937\"\n          + \"31F85F55AC6D73EA69DE7D9005AE9507B95E149E19676272FC202D949A3AB151\"\n          + \"B96870308201443081EAA0030201020209019189FFFFFFFF5183300A06082A86\"\n          + \"48CE3D040302301B3119301706035504031310476E756262792048534D204341\"\n          + \"2030303022180F32303132303630313030303030305A180F3230363230353331\"\n          + \"3233353935395A30303119301706035504031310476F6F676C6520476E756262\"\n          + \"7920763031133011060355042D030A00019189FFFFFFFF51833059301306072A\"\n          + \"8648CE3D020106082A8648CE3D030107034200041F1302F12173A9CBEA83D06D\"\n          + \"755411E582A87FBB5850EDDCF3607EC759A4A12C3CB392235E8D5B17CAEE1B34\"\n          + \"E5B5EB548649696257F0EA8EFB90846F88AD5F72300A06082A8648CE3D040302\"\n          + \"0349003046022100B4CAEA5DC60FBF9F004ED84FC4F18522981C1C303155C082\"\n          + \"74E889F3F10C5B23022100FAAFB4F10B92F4754E3B08B5AF353F78485BC903EC\"\n          + \"E7EA911264FC1673B6598F3046022100F3BE1BF12CBF0BE7EAB5EA32F3664EDB\"\n          + \"18A24D4999AAC5AA40FF39CF6F34C9ED022100CE72631767367467DFE2AECF6A\"\n          + \"5A4EBA9779FAC65F5CA8A2C325B174EE4769AC\");\n  protected static final String REGISTRATION_DATA_2_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_DATA_2);\n  protected static final byte[] KEY_HANDLE_2 =\n      parseHex(\"3c2415e1760d1108105720c6069a9039c99d09f76909c36d9efc35093731f85f\"\n          + \"55ac6d73ea69de7d9005ae9507b95e149e19676272fc202d949a3ab151b96870\");\n  protected static final String KEY_HANDLE_2_BASE64 =\n      Base64.encodeBase64URLSafeString(KEY_HANDLE_2);\n  protected static final byte[] USER_PUBLIC_KEY_2 =\n      parseHex(\"04478e16bbdbbb741a660a000314a8b6bd63095196ed704c52eebc0fa02a618f\"\n          + \"19ff59df18451a11cee43defd9a29b5710f63dfc671f752b1b0c6ca76c8427af\"\n          + \"2d\");\n  protected static final byte[] SIGN_DATA_2 =\n      parseHex(\"01000000223045022100FB16D12F8EC73D93EAB43BFDF141BF94E31AD3B1C98E\"\n          + \"E4459E9E80CBBBD892F70220796DBCB8BBF57EC95A20A76D9ED3365CB688BF88\"\n          + \"2ECCEABCC8D4A674024F6ABA\");\n  protected static final String SIGN_DATA_2_BASE64 = Base64.encodeBase64URLSafeString(SIGN_DATA_2);\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegisteredKey.java\npublic class RegisteredKey {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /**\n   * websafe-base64 encoding of the key handle obtained from the U2F token\n   * during registration.\n   */\n  private final String keyHandle;\n\n  /**\n   * The transports registered for this key handle.\n   */\n  private final List<Transports> transports;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegisteredKey(String version, String keyHandle, List<Transports> transports,\n      String appId, String sessionId) {\n    super();\n    this.version = version;\n    this.keyHandle = keyHandle;\n    this.transports = transports;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(version, keyHandle, transports, appId, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegisteredKey other = (RegisteredKey) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(keyHandle, other.keyHandle)\n        && SecurityKeyData.containSameTransports(transports, other.transports)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n\n  public JsonObject getJson(String defaultAppId) {\n    JsonObject result = new JsonObject();\n    if (appId != null && !appId.equals(defaultAppId)) {\n      result.addProperty(\"appId\", appId);\n    }\n    result.addProperty(\"version\", version);\n    result.addProperty(\"keyHandle\", keyHandle);\n    result.addProperty(\"sessionId\", sessionId);\n    String transportsString = getTransportsAsString();\n    if (transportsString != null) {\n      result.addProperty(\"transports\", transportsString);\n    }\n    return result;\n  }\n\n  private String getTransportsAsString() {\n    if (this.transports == null) {\n      return null;\n    }\n    StringBuilder stringBuilder = new StringBuilder();\n    for (int i = 0; i < transports.size(); i++) {\n      stringBuilder.append(transports.get(i));\n      if (i < transports.size() - 1) {\n        stringBuilder.append(\",\");\n      }\n    }\n    return stringBuilder.toString();\n  }\n}\n", "answers": ["    U2fSignRequest signRequest = u2fServer.getSignRequest(ACCOUNT_NAME, APP_ID_SIGN);"], "length": 2959, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "d60990d706853cd274c7ff6b8b766fcccca25dc8de5ae49c"}
{"input": "from sippy.Timeout import Timeout\nfrom sippy.Signal import Signal\nfrom sippy.SipFrom import SipFrom\nfrom sippy.SipTo import SipTo\nfrom sippy.SipCiscoGUID import SipCiscoGUID\nfrom sippy.UA import UA\nfrom sippy.CCEvents import CCEventRing, CCEventConnect, CCEventDisconnect, CCEventTry, CCEventUpdate, CCEventFail\nfrom sippy.UasStateTrying import UasStateTrying\nfrom sippy.UasStateRinging import UasStateRinging\nfrom sippy.UaStateDead import UaStateDead\nfrom sippy.SipConf import SipConf\nfrom sippy.SipHeader import SipHeader\nfrom sippy.RadiusAuthorisation import RadiusAuthorisation\nfrom sippy.RadiusAccounting import RadiusAccounting\nfrom sippy.FakeAccounting import FakeAccounting\nfrom sippy.SipLogger import SipLogger\nfrom sippy.Rtp_proxy_session import Rtp_proxy_session\nfrom sippy.Rtp_proxy_client import Rtp_proxy_client\nfrom signal import SIGHUP, SIGPROF, SIGUSR1, SIGUSR2\nfrom twisted.internet import reactor\nfrom urllib import unquote\nfrom sippy.Cli_server_local import Cli_server_local\nfrom sippy.SipTransactionManager import SipTransactionManager\nfrom sippy.SipCallId import SipCallId\nfrom re import sub\nfrom time import time\nfrom urllib import quote\nfrom hashlib import md5\nfrom sippy.MyConfigParser import MyConfigParser\nimport gc, getopt, os, sys\n    id = 1\n    uaA = None\n    uaO = None\n    state = None\n    cId = None\n    cld = None\n    eTry = None\n    routes = None\n    remote_ip = None\n    source = None\n    acctA = None\n    acctO = None\n    global_config = None\n    rtp_proxy_session = None\n    huntstop_scodes = None\n    pass_headers = None\n    auth_proc = None\n    proxied = False\n    challenge = None\n\n    def __init__(self, remote_ip, source, global_config, pass_headers):\n        self.id = CallController.id\n        CallController.id += 1\n        self.global_config = global_config\n        self.uaA = UA(self.global_config, event_cb = self.recvEvent, conn_cbs = (self.aConn,), disc_cbs = (self.aDisc,), \\\n          fail_cbs = (self.aDisc,), dead_cbs = (self.aDead,))\n        self.uaA.kaInterval = self.global_config['keepalive_ans']\n        self.state = CCStateIdle\n        self.uaO = None\n        self.routes = []\n        self.remote_ip = remote_ip\n        self.source = source\n        self.pass_headers = pass_headers\n\n    def recvEvent(self, event, ua):\n        if ua == self.uaA:\n            if self.state == CCStateIdle:\n                if not isinstance(event, CCEventTry):\n                    # Some weird event received\n                    self.uaA.recvEvent(CCEventDisconnect(rtime = event.rtime))\n                    return\n                self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name = event.getData()\n                self.cGUID = cGUID.hexForm()\n                if self.cld == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Internal Server Error (1)'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if body == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Body-less INVITE is not supported'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if self.global_config.has_key('_allowed_pts'):\n                    try:\n                        body.parse()\n                    except:\n                        self.uaA.recvEvent(CCEventFail((400, 'Malformed SDP Body'), rtime = event.rtime))\n                        self.state = CCStateDead\n                        return\n                    allowed_pts = self.global_config['_allowed_pts']\n                    mbody = body.content.sections[0].m_header\n                    if mbody.transport.lower() == 'rtp/avp':\n                        mbody.formats = [x for x in mbody.formats if x in allowed_pts]\n                        if len(mbody.formats) == 0:\n                            self.uaA.recvEvent(CCEventFail((488, 'Not Acceptable Here')))\n                            self.state = CCStateDead\n                            return\n                if self.cld.startswith('nat-'):\n                    self.cld = self.cld[4:]\n                    body.content += 'a=nated:yes\\r\\n'\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('static_tr_in'):\n                    self.cld = re_replace(self.global_config['static_tr_in'], self.cld)\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('_rtp_proxy_clients'):\n                    self.rtp_proxy_session = Rtp_proxy_session(self.global_config, call_id = self.cId, \\\n                      notify_socket = global_config['b2bua_socket'], \\\n                      notify_tag = quote('r %s' % str(self.id)))\n                    self.rtp_proxy_session.callee_raddress = (self.remote_ip, 5060)\n                self.eTry = event\n                self.state = CCStateWaitRoute\n                if not self.global_config['auth_enable']:\n                    self.username = self.remote_ip\n                    self.rDone(((), 0))\n                elif auth == None or auth.username == None or len(auth.username) == 0:\n                    self.username = self.remote_ip\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(self.remote_ip, self.cli, self.cld, self.cGUID, \\\n                      self.cId, self.remote_ip, self.rDone)\n                else:\n                    self.username = auth.username\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(auth.username, self.cli, self.cld, self.cGUID, \n                      self.cId, self.remote_ip, self.rDone, auth.realm, auth.nonce, auth.uri, auth.response)\n                return\n            if self.state not in (CCStateARComplete, CCStateConnected, CCStateDisconnecting) or self.uaO == None:\n                return\n            self.uaO.recvEvent(event)\n        else:\n            if (isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect)) and self.state == CCStateARComplete and \\\n              (isinstance(self.uaA.state, UasStateTrying) or isinstance(self.uaA.state, UasStateRinging)) and len(self.routes) > 0:\n                if isinstance(event, CCEventFail):\n                    code = event.getData()[0]\n                else:\n                    code = None\n                if code == None or code not in self.huntstop_scodes:\n                    self.placeOriginate(self.routes.pop(0))\n                    return\n            self.uaA.recvEvent(event)\n\n    def rDone(self, results):\n        # Check that we got necessary result from Radius\n        if len(results) != 2 or results[1] != 0:\n            if isinstance(self.uaA.state, UasStateTrying):\n                if self.challenge != None:\n                    event = CCEventFail((401, 'Unauthorized'))\n                    event.extra_header = self.challenge\n                else:\n                    event = CCEventFail((403, 'Auth Failed'))\n                self.uaA.recvEvent(event)\n                self.state = CCStateDead\n            return\n        if self.global_config['acct_enable']:\n", "context": "sippy/Rtp_proxy_session.py\nclass Rtp_proxy_session(object):\n    rtp_proxy_client = None\n    call_id = None\n    from_tag = None\n    to_tag = None\n    caller_session_exists = False\n    caller_codecs = None\n    caller_raddress = None\n    callee_session_exists = False\n    callee_codecs = None\n    callee_raddress = None\n    max_index = -1\n    origin = None\n    notify_socket = None\n    notify_tag = None\n    global_config = None\n\n    def __init__(self, global_config, call_id = None, from_tag = None, to_tag = None,\n      notify_socket = None, notify_tag = None):\n        self.global_config = global_config\n        if global_config.has_key('_rtp_proxy_clients'):\n            rtp_proxy_clients = [x for x in global_config['_rtp_proxy_clients'] if x.online]\n            n = len(rtp_proxy_clients)\n            if n == 0:\n                raise Exception('No online RTP proxy client has been found')\n            self.rtp_proxy_client = rtp_proxy_clients[int(random() * n)]\n        else:\n            self.rtp_proxy_client = global_config['rtp_proxy_client']\n            if not self.rtp_proxy_client.online:\n                raise Exception('No online RTP proxy client has been found')\n        if call_id != None:\n            self.call_id = call_id\n        else:\n            self.call_id = md5(str(random()) + str(time())).hexdigest()\n        if from_tag != None:\n            self.from_tag = from_tag\n        else:\n            self.from_tag = md5(str(random()) + str(time())).hexdigest()\n        if to_tag != None:\n            self.to_tag = to_tag\n        else:\n            self.to_tag = md5(str(random()) + str(time())).hexdigest()\n        self.origin = SdpOrigin()\n        self.notify_socket = notify_socket\n        self.notify_tag = notify_tag\n\n    def version(self, result_callback):\n        self.rtp_proxy_client.send_command('V', self.version_result, result_callback)\n\n    def version_result(self, result, result_callback):\n        result_callback(result)\n\n    def play_caller(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._play_caller, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_caller(None, prompt_name, times, result_callback, index)\n\n    def _play_caller(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.caller_codecs, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def play_callee(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            return\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._play_callee, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_callee(None, prompt_name, times, result_callback, index)\n\n    def _play_callee(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.callee_codecs, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_caller(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_callee(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_caller(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._copy_caller, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_caller(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_caller(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_callee(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._copy_callee, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_callee(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_callee(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def start_recording(self, rname = None, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._start_recording, '', index, rname, result_callback, index)\n            return\n        self._start_recording(None, rname, result_callback, index)\n\n    def _start_recording(self, result, rname, result_callback, index):\n        if rname == None:\n            command = 'R %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n            return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n        command = 'C %s %s.a %s %s' % ('%s-%d' % (self.call_id, index), rname, self.from_tag, self.to_tag)\n        return self.rtp_proxy_client.send_command(command, self._start_recording1, \\\n          (rname, result_callback, index))\n\n    def _start_recording1(self, result, args):\n        rname, result_callback, index = args\n        command = 'C %s %s.o %s %s' % ('%s-%d' % (self.call_id, index), rname, self.to_tag, self.from_tag)\n        return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def command_result(self, result, result_callback):\n        if result_callback != None:\n            result_callback(result)\n\n    def update_caller(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.caller_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.caller_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.caller_raddress[0]\n        command += options\n        command += ' %s %s %d %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag)\n        if self.caller_session_exists:\n            command += ' %s' % self.to_tag\n        if self.notify_socket != None and index == 0 and \\\n          self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'caller', callback_parameters))\n\n    def update_callee(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.callee_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.callee_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.callee_raddress[0]\n        command += options\n        command += ' %s %s %d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        if self.notify_socket != None and index == 0 \\\n          and self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'callee', callback_parameters))\n\n    def update_result(self, result, args):\n        result_callback, face, callback_parameters = args\n        if face == 'caller':\n            self.caller_session_exists = True\n        else:\n            self.callee_session_exists = True\n        if result == None:\n            result_callback(None, *callback_parameters)\n            return\n        t1 = result.split()\n        rtpproxy_port = int(t1[0])\n        if rtpproxy_port == 0:\n            result_callback(None, *callback_parameters)\n        family = 'IP4'\n        if len(t1) > 1:\n            rtpproxy_address = t1[1]\n            if len(t1) > 2 and t1[2] == '6':\n                family = 'IP6'\n        else:\n            rtpproxy_address = self.rtp_proxy_client.proxy_address\n        result_callback((rtpproxy_address, rtpproxy_port, family), *callback_parameters)\n\n    def delete(self):\n        while self.max_index >= 0:\n            command = 'D %s %s %s' % ('%s-%d' % (self.call_id, self.max_index), self.from_tag, self.to_tag)\n            self.rtp_proxy_client.send_command(command)\n            self.max_index -= 1\n\n    def on_caller_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_caller, sdp_body, result_callback)\n\n    def on_callee_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_callee, sdp_body, result_callback)\n\n    def on_xxx_sdp_change(self, update_xxx, sdp_body, result_callback):\n        sects = []\n        try:\n            sdp_body.parse()\n        except Exception, exception:\n            print datetime.now(), 'can\\'t parse SDP body: %s:' % str(exception)\n            print '-' * 70\n            print_exc(file = sys.stdout)\n            print '-' * 70\n            print sdp_body.content\n            print '-' * 70\n            sys.stdout.flush()\n            return\n        for i in range(0, len(sdp_body.content.sections)):\n            sect = sdp_body.content.sections[i]\n            if sect.m_header.transport.lower() not in ('udp', 'udptl', 'rtp/avp'):\n                continue\n            sects.append(sect)\n        if len(sects) == 0:\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n            return\n        formats = sects[0].m_header.formats\n        if update_xxx == self.update_caller:\n            if len(formats) > 1:\n                self.caller_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.caller_codecs = str(formats[0])\n        else:\n            if len(formats) > 1:\n                self.callee_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.callee_codecs = str(formats[0])\n        for sect in sects:\n            options = ''\n            if sect.c_header.atype == 'IP6':\n                options = '6'\n            update_xxx(sect.c_header.addr, sect.m_header.port, self.xxx_sdp_change_finish, options, \\\n              sects.index(sect), sdp_body, sect, sects, result_callback)\n        return\n\n    def xxx_sdp_change_finish(self, address_port, sdp_body, sect, sects, result_callback):\n        sect.needs_update = False\n        if address_port != None:\n            sect.c_header.atype = address_port[2]\n            sect.c_header.addr = address_port[0]\n            if sect.m_header.port != 0:\n                sect.m_header.port = address_port[1]\n        if len([x for x in sects if x.needs_update]) == 0:\n            sdp_body.content.o_header = self.origin\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n\n    def __del__(self):\n        self.delete()\n        self.rtp_proxy_client = None\nsippy/Signal.py\nclass Signal(object):\n    callback = None\n    parameters = None\n    previous_handler = None\n\n    def __init__(self, signum, callback, *parameters):\n        self.callback = callback\n        self.parameters = parameters\n        self.previous_handler = signal(signum, self.signal_handler)\n\n    def signal_handler(self, signum, *frame):\n        try:\n            reactor.callFromThread(self.callback, *self.parameters)\n        except:\n            print datetime.now(), 'Signal: unhandled exception in signal callback'\n            print '-' * 70\n            print_exc(file = stdout)\n            print '-' * 70\n            stdout.flush()\n        if self.previous_handler not in (SIG_IGN, SIG_DFL):\n            try:\n                self.previous_handler(signum, *frame)\n            except:\n                print datetime.now(), 'Signal: unhandled exception in signal chain'\n                print '-' * 70\n                print_exc(file = stdout)\n                print '-' * 70\n                stdout.flush()\nsippy/SipCiscoGUID.py\nclass SipCiscoGUID(SipGenericHF):\n    hf_names = ('cisco-guid', 'h323-conf-id')\n    ciscoGUID = None\n\n    def __init__(self, body = None, ciscoGUID = None):\n        SipGenericHF.__init__(self, body)\n        if body != None:\n            return\n        self.parsed = True\n        if ciscoGUID != None:\n            self.ciscoGUID = ciscoGUID\n        else:\n            s = md5(str((random() * 1000000000L) + time())).hexdigest()\n            self.ciscoGUID = (long(s[0:8], 16), long(s[8:16], 16), long(s[16:24], 16), long(s[24:32], 16))\n\n    def parse(self):\n        self.parsed = True\n        self.ciscoGUID = tuple([int(x) for x in  self.body.split('-', 3)])\n\n    def __str__(self):\n        if not self.parsed:\n            return self.body\n        return '%d-%d-%d-%d' % self.ciscoGUID\n\n    def getCiscoGUID(self):\n        return self.ciscoGUID\n\n    def hexForm(self):\n        return '%.8X %.8X %.8X %.8X' % self.ciscoGUID\n\n    def getCanName(self, name, compact = False):\n        if name.lower() == 'h323-conf-id':\n            return 'h323-conf-id'\n        else:\n            return 'cisco-GUID'\n\n    def getCopy(self):\n        if not self.parsed:\n            return SipCiscoGUID(self.body)\n        return SipCiscoGUID(ciscoGUID = self.ciscoGUID)\nsippy/SipHeader.py\nclass SipHeader(object):\n    name = None\n    body = None\n\n    def __init__(self, s = None, name = None, body = None, bodys = None, fixname = False):\n        if s != None:\n            name, bodys = [x.strip() for x in s.split(':', 1)]\n        if name != None:\n            self.name = name.lower()\n        if body == None:\n            try:\n                try:\n                    body = hf_types[self.name](bodys)\n                except KeyError:\n                    body = SipGenericHF(bodys, name)\n            except ESipHeaderCSV, einst:\n                einst.name = self.name\n                raise einst\n        self.body = body\n        # If no name is provided use canonic name from the body-specific\n        # class.\n        if self.name == None or fixname:\n            self.name = body.hf_names[0]\n\n    def __str__(self):\n        return str(self.body.getCanName(self.name)) + ': ' + str(self.body)\n\n    def localStr(self, local_addr = None, local_port = None, compact = False):\n        return str(self.body.getCanName(self.name, compact)) + ': ' + \\\n          self.body.localStr(local_addr, local_port)\n\n    def getBody(self):\n        if not self.body.parsed:\n            self.body.parse()\n        return self.body\nsippy/SipFrom.py\nclass SipFrom(SipAddressHF):\n    hf_names = ('from', 'f')\n\n    def __init__(self, body = None, address = None):\n        SipAddressHF.__init__(self, body, address)\n        if body == None and address == None:\n            self.address = SipAddress(name = 'Anonymous', url = SipURL(host = SipConf.my_address, port = SipConf.my_port))\n\n    def getTag(self):\n        return self.address.getParam('tag')\n\n    def genTag(self):\n        self.address.setParam('tag', md5(str((random() * 1000000000L) + time())).hexdigest())\n\n    def setTag(self, value):\n        self.address.setParam('tag', value)\n\n    def delTag(self):\n        self.address.delParam('tag')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 'f'\n        return 'From'\nsippy/CCEvents.py\nclass CCEventDisconnect(CCEventGeneric):\n    name = 'CCEventDisconnect'\n    pass\nsippy/UA.py\nclass UA(object):\n    global_config = None\n    state = None\n    event_cb = None\n    uasReq = None\n    uacResp = None\n    username = None\n    password = None\n    equeue = None\n    dId = None\n    credit_time = None\n    credit_times = None\n    credit_timer = None\n    conn_cbs = None\n    disc_cbs = None\n    fail_cbs = None\n    ring_cbs = None\n    dead_cbs = None\n    rCSeq = None\n    lTag = None\n    lUri = None\n    rUri = None\n    cId = None\n    lCSeq = None\n    lContact = None\n    cGUID = None\n    rAddr = None\n    rAddr0 = None\n    routes = None\n    rTarget = None\n    uasResp = None\n    lSDP = None\n    rSDP = None\n    kaInterval = 0\n    branch = None\n    reqs = None\n    extra_headers = None\n    useRefer = True\n    expire_time = None\n    expire_timer = None\n    no_progress_time = None\n    no_progress_timer = None\n    no_reply_time = None\n    no_reply_timer = None\n    on_local_sdp_change = None\n    on_remote_sdp_change = None\n    last_scode = 100\n    setup_ts = None\n    p100_ts = None\n    p1xx_ts = None\n    connect_ts = None\n    disconnect_ts = None\n    user_agent = None\n    elast_seq = None\n    origin = None\n    source_address = None\n\n    def __init__(self, global_config, event_cb = None, username = None, password = None, nh_address = None, credit_time = None, \\\n      conn_cbs = None, disc_cbs = None, fail_cbs = None, ring_cbs = None, dead_cbs = None, ltag = None, extra_headers = None, \\\n      expire_time = None, no_progress_time = None):\n        self.global_config = global_config\n        self.event_cb = event_cb\n        self.equeue = []\n        self.username = username\n        self.password = password\n        self.rAddr = nh_address\n        self.rAddr0 = self.rAddr\n        self.credit_time = credit_time\n        self.credit_times = {}\n        if conn_cbs != None:\n            self.conn_cbs = conn_cbs\n        else:\n            self.conn_cbs = ()\n        if disc_cbs != None:\n            self.disc_cbs = disc_cbs\n        else:\n            self.disc_cbs = ()\n        if fail_cbs != None:\n            self.fail_cbs = fail_cbs\n        else:\n            self.fail_cbs = ()\n        if ring_cbs != None:\n            self.ring_cbs = ring_cbs\n        else:\n            self.ring_cbs = ()\n        if dead_cbs != None:\n            self.dead_cbs = dead_cbs\n        else:\n            self.dead_cbs = ()\n        if ltag != None:\n            self.lTag = ltag\n        else:\n            self.lTag = md5(str((random() * 1000000000L) + time())).hexdigest()\n        self.reqs = {}\n        self.extra_headers = extra_headers\n        self.expire_time = expire_time\n        self.no_progress_time = no_progress_time\n        #print self.username, self.password\n\n    def recvRequest(self, req):\n        #print 'Received request %s in state %s instance %s' % (req.getMethod(), self.state, self)\n        #print self.rCSeq, req.getHFBody('cseq').getCSeqNum()\n        if self.user_agent == None:\n            self.update_ua(req)\n        if self.rCSeq != None and self.rCSeq >= req.getHFBody('cseq').getCSeqNum():\n            return (req.genResponse(500, 'Server Internal Error'), None, None)\n        self.rCSeq = req.getHFBody('cseq').getCSeqNum()\n        if self.state == None:\n            if req.getMethod() == 'INVITE':\n                self.changeState((UasStateIdle,))\n            else:\n                return None\n        newstate = self.state.recvRequest(req)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n        if newstate != None and req.getMethod() == 'INVITE':\n            return (None, self.state.cancel, self.disconnect)\n        else:\n            return None\n\n    def recvResponse(self, resp):\n        if self.state == None:\n            return\n        self.update_ua(resp)\n        code, reason = resp.getSCode()\n        cseq, method = resp.getHFBody('cseq').getCSeq()\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 401 and resp.countHFs('www-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('authorization') == 0:\n            challenge = resp.getHFBody('www-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm())\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 407 and resp.countHFs('proxy-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('proxy-authorization') == 0:\n            challenge = resp.getHFBody('proxy-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm(), SipProxyAuthorization)\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if code >= 200 and self.reqs.has_key(cseq):\n            del self.reqs[cseq]\n        newstate = self.state.recvResponse(resp)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def recvEvent(self, event):\n        #print self, event\n        if self.state == None:\n            if isinstance(event, CCEventTry) or isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect):\n                self.changeState((UacStateIdle,))\n            else:\n                return\n        newstate = self.state.recvEvent(event)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def disconnect(self, rtime = None):\n        if rtime == None:\n            rtime = time()\n        self.equeue.append(CCEventDisconnect(rtime = rtime))\n        self.recvEvent(CCEventDisconnect(rtime = rtime))\n\n    def expires(self):\n        self.expire_timer = None\n        self.disconnect()\n\n    def no_progress_expires(self):\n        self.no_progress_timer = None\n        self.disconnect()\n\n    def no_reply_expires(self):\n        self.no_reply_timer = None\n        self.disconnect()\n\n    def credit_expires(self, rtime):\n        self.credit_timer = None\n        self.disconnect(rtime)\n\n    def changeState(self, newstate):\n        if self.state != None:\n            self.state.onStateChange(newstate[0])\n        self.state = newstate[0](self)\n        if len(newstate) > 1:\n            for callback in newstate[1]:\n                callback(self, *newstate[2:])\n\n    def emitEvent(self, event):\n        if self.event_cb != None:\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                return\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def emitPendingEvents(self):\n        while len(self.equeue) != 0 and self.event_cb != None:\n            event = self.equeue.pop(0)\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                continue\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def genRequest(self, method, body = None, nonce = None, realm = None, SipXXXAuthorization = SipAuthorization, \\\n      reason = None):\n        req = SipRequest(method = method, ruri = self.rTarget, to = self.rUri, fr0m = self.lUri,\n                         cseq = self.lCSeq, callid = self.cId, contact = self.lContact,\n                         routes = self.routes, target = self.rAddr, cguid = self.cGUID)\n        if nonce != None and realm != None and self.username != None and self.password != None:\n            auth = SipXXXAuthorization(realm = realm, nonce = nonce, method = method, uri = str(self.rTarget),\n              username = self.username, password = self.password)\n            req.appendHeader(SipHeader(body = auth))\n        if body != None:\n            req.setBody(body)\n        if self.extra_headers != None:\n            req.appendHeaders(self.extra_headers)\n        if reason != None:\n            req.appendHeader(SipHeader(body = reason))\n        self.reqs[self.lCSeq] = req\n        return req\n\n    def sendUasResponse(self, scode, reason, body = None, contact = None, \\\n      reason_rfc3326 = None, extra_header = None):\n        self.uasResp.setSCode(scode, reason)\n        self.uasResp.setBody(body)\n        self.uasResp.delHFs('www-authenticate')\n        self.uasResp.delHFs('contact')\n        self.uasResp.delHFs('reason')\n        if contact != None:\n            self.uasResp.appendHeader(SipHeader(name = 'contact', body = contact))\n        if reason_rfc3326 != None:\n            self.uasResp.appendHeader(SipHeader(body = reason_rfc3326))\n        if extra_header != None:\n            self.uasResp.appendHeader(extra_header)\n        self.global_config['_sip_tm'].sendResponse(self.uasResp)\n\n    def isYours(self, req = None, call_id = None, from_tag = None, to_tag = None):\n        #print self.branch, req.getHFBody('via').getBranch()\n        if req != None:\n            if req.getMethod() != 'BYE' and self.branch != None and \\\n              self.branch != req.getHFBody('via').getBranch():\n                return None\n            call_id = str(req.getHFBody('call-id'))\n            from_tag = req.getHFBody('from').getTag()\n            to_tag = req.getHFBody('to').getTag()\n        #print str(self.cId), call_id\n        if call_id != str(self.cId):\n            return None\n        #print self.rUri.getTag(), from_tag\n        if self.rUri != None and self.rUri.getTag() != from_tag:\n            return None\n        #print self.lUri.getTag(), to_tag\n        if self.lUri != None and self.lUri.getTag() != to_tag:\n            return None\n        return self\n\n    def isDead(self):\n        if self.state != None:\n            return self.state.dead\n        return False\n\n    def isConnected(self):\n        if self.state != None:\n            return self.state.connected\n        return False\n\n    def getCLD(self):\n        if self.rUri == None:\n            return None\n        return self.rUri.getUrl().username\n\n    def getCLI(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUrl().username\n\n    def getCallingName(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUri().name\n\n    def getRAddr0(self):\n        return self.rAddr0\n\n    def getCID(self):\n        # Return tuple containing call-id, local tag and remote tag\n        rval = [str(self.cId), None, None]\n        if self.lUri != None:\n            rval[1] = self.lUri.getTag()\n        if self.rUri != None:\n            rval[2] = self.rUri.getTag()\n        return tuple(rval)\n\n    def delayed_remote_sdp_update(self, event, remote_sdp_body):\n        self.rSDP = remote_sdp_body.getCopy()\n        self.equeue.append(event)\n        self.emitPendingEvents()\n\n    def getAcct(self):\n        if self.disconnect_ts != None:\n            disconnect_ts = self.disconnect_ts\n            disconnected = True\n        else:\n            disconnect_ts = time()\n            disconnected = False\n        if self.connect_ts != None:\n            return (disconnect_ts - self.connect_ts, self.connect_ts - self.setup_ts, True, disconnected)\n        return (0, disconnect_ts - self.setup_ts, False, disconnected)\n\n    def update_ua(self, msg):\n        if msg.countHFs('user-agent') > 0:\n            self.user_agent = msg.getHFBody('user-agent').name\n        elif msg.countHFs('server') > 0:\n            self.user_agent = msg.getHFBody('server').name\n        return\n\n    def cancelCreditTimer(self):\n        if self.credit_timer != None:\n            self.credit_timer.cancel()\n            self.credit_timer = None\n\n    def startCreditTimer(self, rtime):\n        if self.credit_time != None:\n            self.credit_times[0] = rtime + self.credit_time\n            self.credit_time = None\n        try:\n            credit_time = min([x for x in self.credit_times.values() if x != None])\n        except ValueError:\n            return\n        self.credit_timer = TimeoutAbs(self.credit_expires, credit_time, credit_time)\n\n    def resetCreditTime(self, rtime, new_credit_times):\n        self.credit_times.update(new_credit_times)\n        if self.state.connected:\n            self.cancelCreditTimer()\n            self.startCreditTimer(rtime)\n\n    def cleanup(self):\n        pass\nsippy/CCEvents.py\nclass CCEventTry(CCEventGeneric):\n    name = 'CCEventTry'\n    pass\nsippy/RadiusAuthorisation.py\nclass RadiusAuthorisation(Radius_client):\n    def do_auth(self, username, caller, callee, h323_cid, sip_cid, remote_ip, res_cb, \\\n      realm = None, nonce = None, uri = None, response = None, extra_attributes = None):\n        sip_cid = str(sip_cid)\n        attributes = None\n        if None not in (realm, nonce, uri, response):\n            attributes = [('User-Name', username), ('Digest-Realm', realm), \\\n              ('Digest-Nonce', nonce), ('Digest-Method', 'INVITE'), ('Digest-URI', uri), \\\n              ('Digest-Algorithm', 'MD5'), ('Digest-User-Name', username), ('Digest-Response', response)]\n        else:\n            attributes = [('User-Name', remote_ip), ('Password', 'cisco')]\n        if caller == None:\n            caller = ''\n        attributes.extend((('Calling-Station-Id', caller), ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), \\\n          ('call-id', sip_cid), ('h323-remote-address', remote_ip), ('h323-session-protocol', 'sipv2')))\n        if extra_attributes != None:\n            for a, v in extra_attributes:\n                attributes.append((a, v))\n        message = 'sending AAA request:\\n' \n        message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes])\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        Radius_client.do_auth(self, attributes, self._process_result, res_cb, sip_cid, time())\n\n    def _process_result(self, results, res_cb, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'AAA request accepted (delay is %.3f), processing response:\\n' % delay\n            else:\n                message = 'AAA request rejected (delay is %.3f), processing response:\\n' % delay\n            if len(results[0]) > 0:\n                message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % x for x in results[0]])\n        else:\n            message = 'Error sending AAA request (delay is %.3f)\\n' % delay\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        res_cb(results)\nsippy/CCEvents.py\nclass CCEventConnect(CCEventGeneric):\n    name = 'CCEventConnect'\n    pass\nsippy/UasStateTrying.py\nclass UasStateTrying(UaStateGeneric):\n    sname = 'Trying(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body)\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n                if self.ua.expire_time != None:\n                    self.ua.expire_timer = TimeoutAbs(self.ua.expires, self.ua.expire_time)\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            return (UasStateRinging, self.ua.ring_cbs, event.rtime, event.origin, code)\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Trying state' % event\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/SipTo.py\nclass SipTo(SipFrom):\n    hf_names = ('to', 't')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 't'\n        return 'To'\nsippy/CCEvents.py\nclass CCEventUpdate(CCEventGeneric):\n    name = 'CCEventUpdate'\n    pass\nsippy/SipLogger.py\nclass SipLogger(object):\n    app = None\n    call_id = None\n    log = None\n    level = None\n    flock = lambda x, y, z: None\n\n    def __init__(self, app, call_id = 'GLOBAL', logfile = '/var/log/sip.log'):\n        self.app = app\n        self.call_id = call_id\n        bend = os.environ.get('SIPLOG_BEND', 'stderr').lower()\n        if bend == 'stderr':\n            self.log = sys.__stderr__\n        elif bend == 'none':\n            self.write = self.donoting\n        else:\n            logfile = os.environ.get('SIPLOG_LOGFILE_FILE', logfile)\n            self.log = file(logfile, 'a')\n            self.flock = flock\n            Signal(SIGUSR1, self.reopen, logfile)\n        self.level = eval('SIPLOG_' + os.environ.get('SIPLOG_LVL', 'INFO'))\n\n    def donoting(self, *args, **kwargs):\n        pass\n\n    def write(self, *args, **kwargs):\n        if kwargs.get('level', SIPLOG_INFO) < self.level:\n            return\n        ltime = kwargs.get('ltime', None)\n        if ltime == None:\n            ltime = time()\n        call_id = kwargs.get('call_id', self.call_id)\n        obuf = '%s.%.3d/%s/%s: %s\\n' % (strftime('%d %b %H:%M:%S', localtime(ltime)), \\\n          (ltime % 1) * 1000, call_id, self.app, \\\n          reduce(lambda x, y: x + y, [str(x) for x in args]))\n        try:\n            self.flock(self.log, LOCK_EX)\n        except IOError, e:\n            # Catch ENOTSUP\n            if e.args[0] != 45:\n                raise e\n            self.flock = lambda x, y: None\n        try:\n            self.log.write(obuf)\n        except IOError, e:\n            if e.args[0] != EINTR:\n                raise e\n        self.log.flush()\n        self.flock(self.log, LOCK_UN)\n\n    def reopen(self, logfile):\n        self.log = file(logfile, 'a')\nsippy/CCEvents.py\nclass CCEventFail(CCEventGeneric):\n    name = 'CCEventFail'\n    pass\nsippy/UasStateRinging.py\nclass UasStateRinging(UaStateGeneric):\n    sname = 'Ringing(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            self.ua.sendUasResponse(code, reason, body)\n            for ring_cb in self.ua.ring_cbs:\n                ring_cb(self.ua, event.rtime, event.origin, code)\n            return None\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Ringing state' % event\n        return None\n\n    def recvRequest(self, req):\n        if req.getMethod() == 'BYE':\n            self.ua.sendUasResponse(487, 'Request Terminated')\n            self.ua.global_config['_sip_tm'].sendResponse(req.genResponse(200, 'OK'))\n            #print 'BYE received in the Ringing state, going to the Disconnected state'\n            if req.countHFs('also') > 0:\n                also = req.getHFBody('also').getUrl().getCopy()\n            else:\n                also = None\n            event = CCEventDisconnect(also, rtime = req.rtime, origin = self.ua.origin)\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n            self.ua.equeue.append(event)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = req.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, req.rtime, self.ua.origin)\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/RadiusAccounting.py\nclass RadiusAccounting(object):\n    global_config = None\n    drec = None\n    crec = None\n    iTime = None\n    cTime = None\n    sip_cid = None\n    origin = None\n    lperiod = None\n    el = None\n    send_start = None\n    complete = False\n    ms_precision = False\n    user_agent = None\n    p1xx_ts = None\n    p100_ts = None\n\n    def __init__(self, global_config, origin, lperiod = None, send_start = False):\n        self.global_config = global_config\n        self._attributes = [('h323-call-origin', origin), ('h323-call-type', 'VoIP'), \\\n          ('h323-session-protocol', 'sipv2')]\n        self.drec = False\n        self.crec = False\n        self.origin = origin\n        self.lperiod = lperiod\n        self.send_start = send_start\n\n    def setParams(self, username, caller, callee, h323_cid, sip_cid, remote_ip, \\\n      h323_in_cid = None):\n        if caller == None:\n            caller = ''\n        self._attributes.extend((('User-Name', username), ('Calling-Station-Id', caller), \\\n          ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), ('call-id', sip_cid), \\\n          ('Acct-Session-Id', sip_cid), ('h323-remote-address', remote_ip)))\n        if h323_in_cid != None and h323_in_cid != h323_cid:\n            self._attributes.append(('h323-incoming-conf-id', h323_in_cid))\n        self.sip_cid = str(sip_cid)\n        self.complete = True\n\n    def conn(self, ua, rtime, origin):\n        if self.crec:\n            return\n        self.crec = True\n        self.iTime = ua.setup_ts\n        self.cTime = ua.connect_ts\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        if self.send_start:\n            self.asend('Start', rtime, origin, ua)\n        self._attributes.extend((('h323-voice-quality', 0), ('Acct-Terminate-Cause', 'User-Request')))\n        if self.lperiod != None and self.lperiod > 0:\n            self.el = Timeout(self.asend, self.lperiod, -1, 'Alive')\n\n    def disc(self, ua, rtime, origin, result = 0):\n        if self.drec:\n            return\n        self.drec = True\n        if self.el != None:\n            self.el.cancel()\n            self.el = None\n        if self.iTime == None:\n            self.iTime = ua.setup_ts\n        if self.cTime == None:\n            self.cTime = rtime\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        self.asend('Stop', rtime, origin, result, ua)\n\n    def asend(self, type, rtime = None, origin = None, result = 0, ua = None):\n        if not self.complete:\n            return\n        if rtime == None:\n            rtime = time()\n        if ua != None:\n            duration, delay, connected = ua.getAcct()[:3]\n        else:\n            # Alive accounting\n            duration = rtime - self.cTime\n            delay = self.cTime - self.iTime\n            connected = True\n        if not(self.ms_precision):\n            duration = round(duration)\n            delay = round(delay)\n        attributes = self._attributes[:]\n        if type != 'Start':\n            if result >= 400:\n                try:\n                    dc = sipErrToH323Err[result][0]\n                except:\n                    dc = '7f'\n            elif result < 200:\n                dc = '10'\n            else:\n                dc = '0'\n            attributes.extend((('h323-disconnect-time', self.ftime(self.iTime + delay + duration)), \\\n              ('Acct-Session-Time', '%d' % round(duration)), ('h323-disconnect-cause', dc)))\n        if type == 'Stop':\n            if origin == 'caller':\n                release_source = '2'\n            elif origin == 'callee':\n                release_source = '4'\n            else:\n                release_source = '8'\n            attributes.append(('release-source', release_source))\n        attributes.extend((('h323-connect-time', self.ftime(self.iTime + delay)), ('h323-setup-time', self.ftime(self.iTime)), \\\n          ('Acct-Status-Type', type)))\n        if self.user_agent != None:\n            attributes.append(('h323-ivr-out', 'sip_ua:' + self.user_agent))\n        if self.p1xx_ts != None:\n            attributes.append(('Acct-Delay-Time', round(self.p1xx_ts)))\n        if self.p100_ts != None:\n            attributes.append(('provisional-timepoint', self.ftime(self.p100_ts)))\n        pattributes = ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes]\n        pattributes.insert(0, 'sending Acct %s (%s):\\n' % (type, self.origin.capitalize()))\n        self.global_config['_sip_logger'].write(call_id = self.sip_cid, *pattributes)\n        self.global_config['_radius_client'].do_acct(attributes, self._process_result, self.sip_cid, time())\n\n    def ftime(self, t):\n        gt = gmtime(t)\n        day = strftime('%d', gt)\n        if day[0] == '0':\n            day = day[1]\n        if self.ms_precision:\n            msec = (t % 1) * 1000\n        else:\n            msec = 0\n        return strftime('%%H:%%M:%%S.%.3d GMT %%a %%b %s %%Y' % (msec, day), gt)\n\n    def _process_result(self, results, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'Acct/%s request accepted (delay is %.3f)\\n' % (self.origin, delay)\n            else:\n                message = 'Acct/%s request rejected (delay is %.3f)\\n' % (self.origin, delay)\n        else:\n            message = 'Error sending Acct/%s request (delay is %.3f)\\n' % (self.origin, delay)\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\nsippy/MyConfigParser.py\nclass MyConfigParser(RawConfigParser):\n    default_section = None\n    _private_keys = None\n\n    def __init__(self, default_section = 'general'):\n        self.default_section = default_section\n        self._private_keys = {}\n        RawConfigParser.__init__(self)\n        self.add_section(self.default_section)\n\n    def __getitem__(self, key):\n        if key.startswith('_'):\n            return self._private_keys[key]\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type  == 'B':\n            return self.getboolean(self.default_section, key)\n        elif value_type == 'I':\n            return self.getint(self.default_section, key)\n        return self.get(self.default_section, key)\n\n    def __setitem__(self, key, value):\n        if key.startswith('_'):\n            self._private_keys[key] = value\n        else:\n            self.set(self.default_section, key, str(value))\n        return\n\n    def has_key(self, key):\n        return self.__contains__(key)\n\n    def __contains__(self, key):\n        if key.startswith('_'):\n            return self._private_keys.has_key(key)\n        return self.has_option(self.default_section, key)\n\n    def get(self, *args):\n        if len(args) == 1:\n            return self.__getitem__(args[0])\n        return RawConfigParser.get(self, *args)\n\n    def getdefault(self, key, default_value):\n        if self.__contains__(key):\n            return self.__getitem__(key)\n        return default_value\n\n    def get_longopts(self):\n        return tuple([x + '=' for x in SUPPORTED_OPTIONS.keys()])\n\n    def read(self, fname):\n        RawConfigParser.readfp(self, open(fname))\n        for key in tuple(self.options(self.default_section)):\n            self.check_and_set(key, RawConfigParser.get(self, \\\n              self.default_section, key), False)\n\n    def check_and_set(self, key, value, compat = True):\n        value = value.strip()\n        if compat:\n            if key == 'rtp_proxy_client':\n                # XXX compatibility option\n                if self.has_key('_rtp_proxy_clients'):\n                    self['_rtp_proxy_clients'].append(value)\n                else:\n                    self['_rtp_proxy_clients'] = [value,]\n                if self.has_key('rtp_proxy_clients'):\n                    self['rtp_proxy_clients'] += ',' + value\n                else:\n                    self['rtp_proxy_clients'] = value\n                return\n            elif key == 'pass_header':\n                # XXX compatibility option\n                if self.has_key('_pass_headers'):\n                    self['_pass_headers'].append(value)\n                else:\n                    self['_pass_headers'] = [value,]\n                if self.has_key('pass_headers'):\n                    self['pass_headers'] += ',' + value\n                else:\n                    self['pass_headers'] = value\n                return\n\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type == 'B':\n            if value.lower() not in self._boolean_states:\n                raise ValueError, 'Not a boolean: %s' % value\n        elif value_type == 'I':\n            _value = int(value)\n        if key in ('keepalive_ans', 'keepalive_orig'):\n            if _value < 0:\n                raise ValueError, 'keepalive_ans should be non-negative'\n        elif key == 'max_credit_time':\n            if _value <= 0:\n                raise ValueError, 'max_credit_time should be more than zero'\n        elif key == 'allowed_pts':\n            self['_allowed_pts'] = [int(x) for x in value.split(',')]\n        elif key in ('accept_ips', 'pass_headers', 'rtp_proxy_clients'):\n            self['_' + key] = [x.strip() for x in value.split(',')]\n        elif key == 'sip_address':\n            if 'my' in dir(value):\n                self['_sip_address'] = value\n                value = '*'\n            elif value in ('*', '0.0.0.0', '::'):\n                self['_sip_address'] = SipConf.my_address\n            else:\n                self['_sip_address'] = value\n        elif key == 'sip_port':\n            if _value <= 0 or _value > 65535:\n                raise ValueError, 'sip_port should be in the range 1-65535'\n            self['_sip_port'] = _value\n        self[key] = value\n\n    def options_help(self):\n        supported_options = SUPPORTED_OPTIONS.items()\n        supported_options.sort()\n        for option, (value_type, helptext) in supported_options:\n            if value_type == 'B':\n                value = 'on/off'\n            elif value_type == 'I':\n                value = 'number'\n            else:\n                value = '\"string\"'\n            print '--%s=%s\\n\\t%s\\n' % (option, value, helptext)\nsippy/UaStateDead.py\nclass UaStateDead(UaStateGeneric):\n    sname = 'Dead'\n    dead = True\n\n    def __init__(self, ua):\n        UaStateGeneric.__init__(self, None)\n        if ua.cId != None:\n            ua.global_config['_sip_tm'].unregConsumer(ua, str(ua.cId))\n        ua.tr = None\n        ua.event_cb = None\n        ua.conn_cbs = ()\n        ua.disc_cbs = ()\n        ua.fail_cbs = ()\n        ua.on_local_sdp_change = None\n        ua.on_remote_sdp_change = None\n        ua.expire_timer = None\n        ua.no_progress_timer = None\n        ua.credit_timer = None\n        # Keep this at the very end of processing\n        for callback in ua.dead_cbs:\n            callback(ua)\n        ua.dead_cbs = ()\n        ua.cleanup()\n        # Break cross-ref chain\n        self.ua = None\nsippy/SipTransactionManager.py\nclass SipTransactionManager(object):\n    global_config = None\n    l4r = None\n    tclient = None\n    tserver = None\n    req_cb = None\n    l1rcache = None\n    l2rcache = None\n    nat_traversal = False\n    req_consumers = None\n    provisional_retr = 0\n\n    def __init__(self, global_config, req_cb = None):\n        self.global_config = global_config\n        self.l4r = local4remote(global_config, self.handleIncoming)\n        self.tclient = {}\n        self.tserver = {}\n        self.req_cb = req_cb\n        self.l1rcache = {}\n        self.l2rcache = {}\n        self.req_consumers = {}\n        Timeout(self.rCachePurge, 32, -1)\n\n    def handleIncoming(self, data, address, server):\n        if len(data) < 32:\n            return\n        rtime = time()\n        self.global_config['_sip_logger'].write('RECEIVED message from %s:%d:\\n' % address, data, ltime = rtime)\n        checksum = md5(data).digest()\n        retrans = self.l1rcache.get(checksum, None)\n        if retrans == None:\n            retrans = self.l2rcache.get(checksum, None)\n        if retrans != None:\n            userv, data, address = retrans\n            if data == None:\n                return\n            self.transmitData(userv, data, address)\n            return\n        if data.startswith('SIP/2.0 '):\n            try:\n                resp = SipResponse(data)\n                tid = resp.getTId(True, True)\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP response from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            if resp.getSCode()[0] < 100 or resp.getSCode()[0] > 999:\n                print datetime.now(), 'invalid status code in SIP response from %s:%d:' % address\n                print data\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            resp.rtime = rtime\n            if not self.tclient.has_key(tid):\n                #print 'no transaction with tid of %s in progress' % str(tid)\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            t = self.tclient[tid]\n            if self.nat_traversal and resp.countHFs('contact') > 0 and not check1918(t.address[0]):\n                curl = resp.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n            resp.setSource(address)\n            self.incomingResponse(resp, t, checksum)\n        else:\n            if self.req_cb == None:\n                return\n            try:\n                req = SipRequest(data)\n                tids = req.getTIds()\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP request from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            req.rtime = rtime\n            via0 = req.getHFBody('via')\n            ahost, aport = via0.getAddr()\n            rhost, rport = address\n            if self.nat_traversal and rport != aport and check1918(ahost):\n                req.nated = True\n            if ahost != rhost:\n                via0.params['received'] = rhost\n            if via0.params.has_key('rport') or req.nated:\n                via0.params['rport'] = str(rport)\n            if self.nat_traversal and req.countHFs('contact') > 0 and req.countHFs('via') == 1:\n                curl = req.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n                    req.nated = True\n            req.setSource(address)\n            self.incomingRequest(req, checksum, tids, server)\n\n    # 1. Client transaction methods\n    def newTransaction(self, msg, resp_cb = None, laddress = None, userv = None):\n        t = SipTransaction()\n        t.tid = msg.getTId(True, True)\n        if self.tclient.has_key(t.tid):\n            raise ValueError('BUG: Attempt to initiate transaction with the same TID as existing one!!!')\n        t.tout = 0.5\n        t.fcode = None\n        t.address = msg.getTarget()\n        if userv == None:\n            if laddress == None:\n                t.userv = self.l4r.getServer(t.address)\n            else:\n                t.userv = self.l4r.getServer(laddress, is_local = True)\n        else:\n            t.userv = userv\n        t.data = msg.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        try:\n            t.expires = msg.getHFBody('expires').getNum()\n            if t.expires <= 0:\n                t.expires = 300\n        except IndexError:\n            t.expires = 300\n        if msg.getMethod() == 'INVITE':\n            t.needack = True\n            t.ack = msg.genACK()\n            t.cancel = msg.genCANCEL()\n        else:\n            t.needack = False\n            t.ack = None\n            t.cancel = None\n        t.cancelPending = False\n        t.resp_cb = resp_cb\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n        if resp_cb != None:\n            t.r408 = msg.genResponse(408, 'Request Timeout')\n        t.teB = Timeout(self.timerB, 32.0, 1, t)\n        t.teC = None\n        t.state = TRYING\n        self.tclient[t.tid] = t\n        self.transmitData(t.userv, t.data, t.address)\n        return t\n\n    def cancelTransaction(self, t, reason = None):\n        # If we got at least one provisional reply then (state == RINGING)\n        # then start CANCEL transaction, otherwise deffer it\n        if t.state != RINGING:\n            t.cancelPending = True\n        else:\n            if reason != None:\n                t.cancel.appendHeader(SipHeader(body = reason))\n            self.newTransaction(t.cancel, userv = t.userv)\n\n    def incomingResponse(self, msg, t, checksum):\n        # In those two states upper level already notified, only do ACK retransmit\n        # if needed\n        if t.state == TERMINATED:\n            return\n\n        if t.state == TRYING:\n            # Stop timers\n            if t.teA != None:\n                t.teA.cancel()\n                t.teA = None\n\n        if t.state in (TRYING, RINGING):\n            if t.teB != None:\n                t.teB.cancel()\n                t.teB = None\n\n            if msg.getSCode()[0] < 200:\n                # Privisional response - leave everything as is, except that\n                # change state and reload timeout timer\n                if t.state == TRYING:\n                    t.state = RINGING\n                    if t.cancelPending:\n                        self.newTransaction(t.cancel, userv = t.userv)\n                        t.cancelPending = False\n                t.teB = Timeout(self.timerB, t.expires, 1, t)\n                self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n            else:\n                # Final response - notify upper layer and remove transaction\n                if t.needack:\n                    # Prepare and send ACK if necessary\n                    fcode = msg.getSCode()[0]\n                    tag = msg.getHFBody('to').getTag()\n                    if tag != None:\n                        t.ack.getHFBody('to').setTag(tag)\n                    rAddr = None\n                    if msg.getSCode()[0] >= 200 and msg.getSCode()[0] < 300:\n                        # Some hairy code ahead\n                        if msg.countHFs('contact') > 0:\n                            rTarget = msg.getHFBody('contact').getUrl().getCopy()\n                        else:\n                            rTarget = None\n                        routes = [x.getCopy() for x in msg.getHFBodys('record-route')]\n                        routes.reverse()\n                        if len(routes) > 0:\n                            if not routes[0].getUrl().lr:\n                                if rTarget != None:\n                                    routes.append(SipRoute(address = SipAddress(url = rTarget)))\n                                rTarget = routes.pop(0).getUrl()\n                                rAddr = rTarget.getAddr()\n                            else:\n                                rAddr = routes[0].getAddr()\n                        elif rTarget != None:\n                            rAddr = rTarget.getAddr()\n                        if rTarget != None:\n                            t.ack.setRURI(rTarget)\n                        if rAddr != None:\n                            t.ack.setTarget(rAddr)\n                        t.ack.delHFs('route')\n                        t.ack.appendHeaders([SipHeader(name = 'route', body = x) for x in routes])\n                    if fcode >= 200 and fcode < 300:\n                        t.ack.getHFBody('via').genBranch()\n                    if rAddr == None:\n                        rAddr = t.address\n                    self.transmitMsg(t.userv, t.ack, rAddr, checksum)\n                else:\n                    self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n                del self.tclient[t.tid]\n                t.cleanup()\n\n    def timerA(self, t):\n        #print 'timerA', t\n        self.transmitData(t.userv, t.data, t.address)\n        t.tout *= 2\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n\n    def timerB(self, t):\n        #print 'timerB', t\n        t.teB = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        t.state = TERMINATED\n        #print '2: Timeout(self.timerC, 32.0, 1, t)', t\n        t.teC = Timeout(self.timerC, 32.0, 1, t)\n        if t.resp_cb == None:\n            return\n        t.r408.rtime = time()\n        t.resp_cb(t.r408)\n        #try:\n        #    t.resp_cb(SipRequest(t.data).genResponse(408, 'Request Timeout'))\n        #except:\n        #    print 'SipTransactionManager: unhandled exception when processing response!'\n\n    def timerC(self, t):\n        #print 'timerC', t\n        #print self.tclient\n        t.teC = None\n        del self.tclient[t.tid]\n        t.cleanup()\n\n    # 2. Server transaction methods\n    def incomingRequest(self, msg, checksum, tids, server):\n        for tid in tids:\n            if self.tclient.has_key(tid):\n                resp = msg.genResponse(482, 'Loop Detected')\n                self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                return\n        tid = msg.getTId()\n        # Fasten seatbelts - bumpy transaction matching code ahead!\n        if msg.getMethod() in ('INVITE', 'CANCEL', 'ACK'):\n            btid = msg.getTId(wBRN = True)\n            t = self.tserver.get(btid, None)\n            if t == None:\n                t = self.tserver.get(tid, None)\n                if t != None and t.branch != btid[3]:\n                    if msg.getMethod() == 'INVITE':\n                        # Different branch on transaction to which no final reply\n                        # has been sent yet - merge requests\n                        resp = msg.genResponse(482, 'Loop Detected')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n                    elif msg.getMethod() == 'CANCEL':\n                        # CANCEL, but with branch that doesn't match any existing\n                        # transactions\n                        resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n        else:\n            t = self.tserver.get(tid, None)\n        if t != None:\n            #print 'existing transaction'\n            if msg.getMethod() == t.method:\n                # Duplicate received, check that we have sent any response on this\n                # request already\n                if t.data != None:\n                    self.transmitData(t.userv, t.data, t.address, checksum)\n                return\n            elif msg.getMethod() == 'CANCEL':\n                # RFC3261 says that we have to reply 200 OK in all cases if\n                # there is such transaction\n                resp = msg.genResponse(200, 'OK')\n                self.transmitMsg(t.userv, resp, resp.getHFBody('via').getTAddr(), checksum)\n                if t.state in (TRYING, RINGING):\n                    self.doCancel(t, msg.rtime, msg)\n            elif msg.getMethod() == 'ACK' and t.state == COMPLETED:\n                t.state = CONFIRMED\n                if t.teA != None:\n                    t.teA.cancel()\n                    t.teA = None\n                t.teD.cancel()\n                # We have done with the transaction, no need to wait for timeout\n                del self.tserver[t.tid]\n                t.cleanup()\n                self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'ACK':\n            # Some ACK that doesn't match any existing transaction.\n            # Drop and forget it - upper layer is unlikely to be interested\n            # to seeing this anyway.\n            print datetime.now(), 'unmatched ACK transaction - ignoring'\n            sys.stdout.flush()\n            self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'CANCEL':\n            resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n            self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n        else:\n            #print 'new transaction', msg.getMethod()\n            t = SipTransaction()\n            t.tid = tid\n            t.state = TRYING\n            t.teA = None\n            t.teD = None\n            t.teE = None\n            t.teF = None\n            t.method = msg.getMethod()\n            t.data = None\n            t.address = None\n            t.noack_cb = None\n            t.cancel_cb = None\n            t.checksum = checksum\n            if server.laddress[0] not in ('0.0.0.0', '[::]'):\n                t.userv = server\n            else:\n                # For messages received on the wildcard interface find\n                # or create more specific server.\n                t.userv = self.l4r.getServer(msg.getSource())\n            if msg.getMethod() == 'INVITE':\n                t.r487 = msg.genResponse(487, 'Request Terminated')\n                t.needack = True\n                t.branch = msg.getHFBody('via').getBranch()\n                try:\n                    e = msg.getHFBody('expires').getNum()\n                    if e <= 0:\n                        e = 300\n                except IndexError:\n                    e = 300\n                t.teE = Timeout(self.timerE, e, 1, t)\n            else:\n                t.r487 = None\n                t.needack = False\n                t.branch = None\n            self.tserver[t.tid] = t\n            for consumer in self.req_consumers.get(t.tid[0], ()):\n                consumer = consumer.isYours(msg)\n                if consumer != None:\n                    rval = consumer.recvRequest(msg)\n                    break\n            else:\n                rval = self.req_cb(msg)\n            if rval == None:\n                if t.teA != None or t.teD != None or t.teE != None or t.teF != None:\n                    return\n                if self.tserver.has_key(t.tid):\n                    del self.tserver[t.tid]\n                t.cleanup()\n                return\n            resp, cancel_cb, noack_cb = rval\n            t.cancel_cb = cancel_cb\n            t.noack_cb = noack_cb\n            if resp != None:\n                self.sendResponse(resp, t)\n\n    def regConsumer(self, consumer, call_id):\n        self.req_consumers.setdefault(call_id, []).append(consumer)\n\n    def unregConsumer(self, consumer, call_id):\n        # Usually there will be only one consumer per call_id, so that\n        # optimize management for this case\n        consumers = self.req_consumers.pop(call_id)\n        if len(consumers) > 1:\n            consumers.remove(consumer)\n            self.req_consumers[call_id] = consumers\n\n    def sendResponse(self, resp, t = None, retrans = False):\n        #print self.tserver\n        if t == None:\n            tid = resp.getTId()\n            t = self.tserver[tid]\n        if t.state not in (TRYING, RINGING) and not retrans:\n            raise ValueError('BUG: attempt to send reply on already finished transaction!!!')\n        scode = resp.getSCode()[0]\n        toHF = resp.getHFBody('to')\n        if scode > 100 and toHF.getTag() == None:\n            toHF.genTag()\n        t.data = resp.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        t.address = resp.getHFBody('via').getTAddr()\n        self.transmitData(t.userv, t.data, t.address, t.checksum)\n        if scode < 200:\n            t.state = RINGING\n            if self.provisional_retr > 0 and scode > 100:\n                if t.teF != None:\n                    t.teF.cancel()\n                t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n        else:\n            t.state = COMPLETED\n            if t.teE != None:\n                t.teE.cancel()\n                t.teE = None\n            if t.teF != None:\n                t.teF.cancel()\n                t.teF = None\n            if t.needack:\n                # Schedule removal of the transaction\n                t.teD = Timeout(self.timerD, 32.0, 1, t)\n                if scode >= 300:\n                    # Black magick to allow proxy send us another INVITE with diffetent branch\n                    del self.tserver[t.tid]\n                    t.tid = list(t.tid)\n                    t.tid.append(t.branch)\n                    t.tid = tuple(t.tid)\n                    self.tserver[t.tid] = t\n                # Install retransmit timer if necessary\n                t.tout = 0.5\n                t.teA = Timeout(self.timerA, t.tout, 1, t)\n            else:\n                # We have done with the transaction\n                del self.tserver[t.tid]\n                t.cleanup()\n\n    def doCancel(self, t, rtime = None, req = None):\n        if rtime == None:\n            rtime = time()\n        if t.r487 != None:\n            self.sendResponse(t.r487, t, True)\n        if t.cancel_cb != None:\n            t.cancel_cb(rtime, req)\n\n    def timerD(self, t):\n        #print 'timerD'\n        t.teD = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        if t.noack_cb != None and t.state != CONFIRMED:\n            t.noack_cb()\n        del self.tserver[t.tid]\n        t.cleanup()\n\n    def timerE(self, t):\n        #print 'timerE'\n        t.teE = None\n        if t.teF != None:\n            t.teF.cancel()\n            t.teF = None\n        if t.state in (TRYING, RINGING):\n            if t.r487 != None:\n                t.r487.reason = 'Request Expired'\n            self.doCancel(t)\n\n    # Timer to retransmit the last provisional reply every\n    # 2 seconds\n    def timerF(self, t):\n        #print 'timerF', t.state\n        t.teF = None\n        if t.state == RINGING and self.provisional_retr > 0:\n            self.transmitData(t.userv, t.data, t.address)\n            t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n\n    def rCachePurge(self):\n        self.l2rcache = self.l1rcache\n        self.l1rcache = {}\n        self.l4r.rotateCache()\n\n    def transmitMsg(self, userv, msg, address, cachesum, compact = False):\n        data = msg.localStr(userv.laddress[0], userv.laddress[1], compact)\n        self.transmitData(userv, data, address, cachesum)\n\n    def transmitData(self, userv, data, address, cachesum = None):\n        userv.send_to(data, address)\n        self.global_config['_sip_logger'].write('SENDING message to %s:%d:\\n' % address, data)\n        if cachesum != None:\n            self.l1rcache[cachesum] = (userv, data, address)\nsippy/CCEvents.py\nclass CCEventRing(CCEventGeneric):\n    name = 'CCEventRing'\n    pass\n", "answers": ["            self.acctA = RadiusAccounting(self.global_config, 'answer', \\"], "length": 7126, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "3cd8fefa66ffe61edf15dd8ce125f6e4933fb96d398da6b5"}
{"input": "import binascii\nimport calendar\nimport six\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom .types import EmbeddedSignatureHeader\nfrom .types import Signature\nfrom ...constants import CompressionAlgorithm\nfrom ...constants import Features as _Features\nfrom ...constants import HashAlgorithm\nfrom ...constants import KeyFlags as _KeyFlags\nfrom ...constants import KeyServerPreferences as _KeyServerPreferences\nfrom ...constants import NotationDataFlags\nfrom ...constants import PubKeyAlgorithm\nfrom ...constants import RevocationKeyClass\nfrom ...constants import RevocationReason\nfrom ...constants import SymmetricKeyAlgorithm\nfrom ...decorators import sdproperty\nfrom ...types import Fingerprint\n        from ..packets import SignatureV4\n\"\"\" signature.py\n\nSignature SubPackets\n\"\"\"\n\n\n\n\n\n\n\n\n__all__ = ['URI',\n           'FlagList',\n           'ByteFlag',\n           'Boolean',\n           'CreationTime',\n           'SignatureExpirationTime',\n           'ExportableCertification',\n           'TrustSignature',\n           'RegularExpression',\n           'Revocable',\n           'KeyExpirationTime',\n           'PreferredSymmetricAlgorithms',\n           'RevocationKey',\n           'Issuer',\n           'NotationData',\n           'PreferredHashAlgorithms',\n           'PreferredCompressionAlgorithms',\n           'KeyServerPreferences',\n           'PreferredKeyServer',\n           'PrimaryUserID',\n           'Policy',\n           'KeyFlags',\n           'SignersUserID',\n           'ReasonForRevocation',\n           'Features',\n           'EmbeddedSignature']\n\n\nclass URI(Signature):\n", "context": "src/leap/mx/vendor/pgpy/constants.py\nclass PubKeyAlgorithm(IntEnum):\n    Invalid = 0x00\n    #: Signifies that a key is an RSA key.\n    RSAEncryptOrSign = 0x01\n    RSAEncrypt = 0x02  # deprecated\n    RSASign = 0x03     # deprecated\n    #: Signifies that a key is an ElGamal key.\n    ElGamal = 0x10\n    #: Signifies that a key is a DSA key.\n    DSA = 0x11\n    #: Signifies that a key is an ECDH key.\n    ECDH = 0x12\n    #: Signifies that a key is an ECDSA key.\n    ECDSA = 0x13\n    FormerlyElGamalEncryptOrSign = 0x14  # deprecated - do not generate\n    # DiffieHellman = 0x15  # X9.42\n\n    @property\n    def can_gen(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign,\n                        PubKeyAlgorithm.DSA,\n                        PubKeyAlgorithm.ECDSA,\n                        PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_encrypt(self):  # pragma: no cover\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.ElGamal, PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_sign(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.DSA, PubKeyAlgorithm.ECDSA}\n\n    @property\n    def deprecated(self):\n        return self in {PubKeyAlgorithm.RSAEncrypt,\n                        PubKeyAlgorithm.RSASign,\n                        PubKeyAlgorithm.FormerlyElGamalEncryptOrSign}\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass Signature(SubPacket):\n    __typeid__ = -1\nsrc/leap/mx/vendor/pgpy/constants.py\nclass SymmetricKeyAlgorithm(IntEnum):\n    \"\"\"Supported symmetric key algorithms.\"\"\"\n    Plaintext = 0x00\n    #: .. warning::\n    #:     IDEA is insecure. PGPy only allows it to be used for decryption, not encryption!\n    IDEA = 0x01\n    #: Triple-DES with 168-bit key derived from 192\n    TripleDES = 0x02\n    #: CAST5 (or CAST-128) with 128-bit key\n    CAST5 = 0x03\n    #: Blowfish with 128-bit key and 16 rounds\n    Blowfish = 0x04\n    #: AES with 128-bit key\n    AES128 = 0x07\n    #: AES with 192-bit key\n    AES192 = 0x08\n    #: AES with 256-bit key\n    AES256 = 0x09\n    # Twofish with 256-bit key - not currently supported\n    Twofish256 = 0x0A\n    #: Camellia with 128-bit key\n    Camellia128 = 0x0B\n    #: Camellia with 192-bit key\n    Camellia192 = 0x0C\n    #: Camellia with 256-bit key\n    Camellia256 = 0x0D\n\n    @property\n    def cipher(self):\n        bs = {SymmetricKeyAlgorithm.IDEA: algorithms.IDEA,\n              SymmetricKeyAlgorithm.TripleDES: algorithms.TripleDES,\n              SymmetricKeyAlgorithm.CAST5: algorithms.CAST5,\n              SymmetricKeyAlgorithm.Blowfish: algorithms.Blowfish,\n              SymmetricKeyAlgorithm.AES128: algorithms.AES,\n              SymmetricKeyAlgorithm.AES192: algorithms.AES,\n              SymmetricKeyAlgorithm.AES256: algorithms.AES,\n              SymmetricKeyAlgorithm.Twofish256: namedtuple('Twofish256', ['block_size'])(block_size=128),\n              SymmetricKeyAlgorithm.Camellia128: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia192: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia256: algorithms.Camellia}\n\n        if self in bs:\n            return bs[self]\n\n        raise NotImplementedError(repr(self))\n\n    @property\n    def is_insecure(self):\n        insecure_ciphers = {SymmetricKeyAlgorithm.IDEA}\n        return self in insecure_ciphers\n\n    @property\n    def block_size(self):\n        return self.cipher.block_size\n\n    @property\n    def key_size(self):\n        ks = {SymmetricKeyAlgorithm.IDEA: 128,\n              SymmetricKeyAlgorithm.TripleDES: 192,\n              SymmetricKeyAlgorithm.CAST5: 128,\n              SymmetricKeyAlgorithm.Blowfish: 128,\n              SymmetricKeyAlgorithm.AES128: 128,\n              SymmetricKeyAlgorithm.AES192: 192,\n              SymmetricKeyAlgorithm.AES256: 256,\n              SymmetricKeyAlgorithm.Twofish256: 256,\n              SymmetricKeyAlgorithm.Camellia128: 128,\n              SymmetricKeyAlgorithm.Camellia192: 192,\n              SymmetricKeyAlgorithm.Camellia256: 256}\n\n        if self in ks:\n            return ks[self]\n\n        raise NotImplementedError(repr(self))\n\n    def gen_iv(self):\n        return os.urandom(self.block_size // 8)\n\n    def gen_key(self):\n        return os.urandom(self.key_size // 8)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass HashAlgorithm(IntEnum):\n    Invalid = 0x00\n    MD5 = 0x01\n    SHA1 = 0x02\n    RIPEMD160 = 0x03\n    _reserved_1 = 0x04\n    _reserved_2 = 0x05\n    _reserved_3 = 0x06\n    _reserved_4 = 0x07\n    SHA256 = 0x08\n    SHA384 = 0x09\n    SHA512 = 0x0A\n    SHA224 = 0x0B\n\n    def __init__(self, *args):\n        super(self.__class__, self).__init__()\n        self._tuned_count = 0\n\n    @property\n    def hasher(self):\n        return hashlib.new(self.name)\n\n    @property\n    def digest_size(self):\n        return self.hasher.digest_size\n\n    @property\n    def tuned_count(self):\n        if self._tuned_count == 0:\n            self.tune_count()\n\n        return self._tuned_count\n\n    def tune_count(self):\n        start = end = 0\n        htd = _hashtunedata[:]\n\n        while start == end:\n            # potentially do this multiple times in case the resolution of time.time is low enough that\n            # hashing 100 KiB isn't enough time to produce a measurable difference\n            # (e.g. if the timer for time.time doesn't have enough precision)\n            htd = htd + htd\n            h = self.hasher\n\n            start = time.time()\n            h.update(htd)\n            end = time.time()\n\n        # now calculate how many bytes need to be hashed to reach our expected time period\n        # GnuPG tunes for about 100ms, so we'll do that as well\n        _TIME = 0.100\n        ct = int(len(htd) * (_TIME / (end - start)))\n        c1 = ((ct >> (ct.bit_length() - 5)) - 16)\n        c2 = (ct.bit_length() - 11)\n        c = ((c2 << 4) + c1)\n\n        # constrain self._tuned_count to be between 0 and 255\n        self._tuned_count = max(min(c, 255), 0)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass CompressionAlgorithm(IntEnum):\n    #: No compression\n    Uncompressed = 0x00\n    #: ZIP DEFLATE\n    ZIP = 0x01\n    #: ZIP DEFLATE with zlib headers\n    ZLIB = 0x02\n    #: Bzip2\n    BZ2 = 0x03\n\n    def compress(self, data):\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.compress(data)[2:-4]\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.compress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.compress(data)\n\n        raise NotImplementedError(self)\n\n    def decompress(self, data):\n        if six.PY2:\n            data = bytes(data)\n\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.decompress(data, -15)\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.decompress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.decompress(data)\n\n        raise NotImplementedError(self)\nsrc/leap/mx/vendor/pgpy/types.py\nclass Fingerprint(str):\n    \"\"\"\n    A subclass of ``str``. Can be compared using == and != to ``str``, ``unicode``, and other :py:obj:`Fingerprint` instances.\n\n    Primarily used as a key for internal dictionaries, so it ignores spaces when comparing and hashing\n    \"\"\"\n    @property\n    def keyid(self):\n        return str(self).replace(' ', '')[-16:]\n\n    @property\n    def shortid(self):\n        return str(self).replace(' ', '')[-8:]\n\n    def __new__(cls, content):\n        if isinstance(content, Fingerprint):\n            return content\n\n        # validate input before continuing: this should be a string of 40 hex digits\n        content = content.upper().replace(' ', '')\n        if not bool(re.match(r'^[A-F0-9]{40}$', content)):\n            raise ValueError(\"Expected: String of 40 hex digits\")\n\n        # store in the format: \"AAAA BBBB CCCC DDDD EEEE  FFFF 0000 1111 2222 3333\"\n        #                                               ^^ note 2 spaces here\n        spaces = [ ' ' if i != 4 else '  ' for i in range(10) ]\n        chunks = [ ''.join(g) for g in six.moves.zip_longest(*[iter(content)] * 4) ]\n        content = ''.join(j for i in six.moves.zip_longest(chunks, spaces, fillvalue='') for j in i).strip()\n\n        return str.__new__(cls, content)\n\n    def __eq__(self, other):\n        if isinstance(other, Fingerprint):\n            return str(self) == str(other)\n\n        if isinstance(other, (six.text_type, bytes, bytearray)):\n            if isinstance(other, (bytes, bytearray)):  # pragma: no cover\n                other = other.decode('latin-1')\n\n            other = str(other).replace(' ', '')\n            return any([self.replace(' ', '') == other,\n                        self.keyid == other,\n                        self.shortid == other])\n\n        return False  # pragma: no cover\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __hash__(self):\n        return hash(str(self.replace(' ', '')))\n\n    def __bytes__(self):\n        return binascii.unhexlify(six.b(self.replace(' ', '')))\nsrc/leap/mx/vendor/pgpy/constants.py\nclass Features(FlagEnum):\n    ModificationDetection = 0x01\n\n    @classproperty\n    def pgpy_features(cls):\n        return Features.ModificationDetection\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyFlags(FlagEnum):\n    #: Signifies that a key may be used to certify keys and user ids. Primary keys always have this, even if it is not specified.\n    Certify = 0x01\n    #: Signifies that a key may be used to sign messages and documents.\n    Sign = 0x02\n    #: Signifies that a key may be used to encrypt messages.\n    EncryptCommunications = 0x04\n    #: Signifies that a key may be used to encrypt storage. Currently equivalent to :py:obj:`~pgpy.constants.EncryptCommunications`.\n    EncryptStorage = 0x08\n    #: Signifies that the private component of a given key may have been split by a secret-sharing mechanism. Split\n    #: keys are not currently supported by PGPy.\n    Split = 0x10\n    #: Signifies that a key may be used for authentication.\n    Authentication = 0x20\n    #: Signifies that the private component of a key may be in the possession of more than one person.\n    MultiPerson = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyServerPreferences(IntEnum):\n    Unknown = 0x00\n    NoModify = 0x80\nsrc/leap/mx/vendor/pgpy/decorators.py\ndef sdproperty(fget):\n    def defset(obj, val):  # pragma: no cover\n        raise TypeError(str(val.__class__))\n\n    class SDProperty(property):\n        def register(self, cls=None, fset=None):\n            return self.fset.register(cls, fset)\n\n        def setter(self, fset):\n            self.register(object, fset)\n            return type(self)(self.fget, self.fset, self.fdel, self.__doc__)\n\n    return SDProperty(fget, sdmethod(defset))\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass EmbeddedSignatureHeader(VersionedHeader):\n    def __bytearray__(self):\n        return bytearray([self.version])\n\n    def parse(self, packet):\n        self.tag = 2\n        super(EmbeddedSignatureHeader, self).parse(packet)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass NotationDataFlags(FlagEnum):\n    HumanReadable = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass RevocationReason(IntEnum):\n    #: No reason was specified. This is the default reason.\n    NotSpecified = 0x00\n    #: The key was superseded by a new key. Only meaningful when revoking a key.\n    Superseded = 0x01\n    #: Key material has been compromised. Only meaningful when revoking a key.\n    Compromised = 0x02\n    #: Key is retired and no longer used. Only meaningful when revoking a key.\n    Retired = 0x03\n    #: User ID information is no longer valid. Only meaningful when revoking a certification of a user id.\n    UserID = 0x20\nsrc/leap/mx/vendor/pgpy/constants.py\nclass RevocationKeyClass(FlagEnum):\n    Sensitive = 0x40\n    Normal = 0x80\n", "answers": ["    @sdproperty"], "length": 1318, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "ea34735f9ac205293023394877d630555a04b487a2cf6036"}
{"input": "import opcode\nfrom ...utils.log import logger\nfrom ..graph import Tree, TreeNode\nfrom .expr import Expr, Const, Ref, Comparator, Operator, Undef, \\\n                  CMP_IMPLICIT_NOT_EMPTY, CMP_TYPE_CHECK, OP_MAP, CMP_MAP\nfrom ..python.opcodes import *\n\"\"\"\n  equip.analysis.constraint.container\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n  Constraint container.\n\n  :copyright: (c) 2014 by Romain Gaucher (@rgaucher)\n  :license: Apache 2, see LICENSE for more details.\n\"\"\"\n\n\n\n\nclass Constraint(object):\n  \"\"\"\n    Represents a constraint in the bytecode. This is used to represent\n    conditional expressions. We store both the bytecode AST constraint\n    and a final internal representation (can be used to compare constraints\n    or generate SMT clauses).\n  \"\"\"\n  def __init__(self):\n    self._ast = Tree()\n    self._cstr = None\n    self._live = None\n    self._root = None\n\n  @property\n  def root(self):\n    return self._root\n\n  @root.setter\n  def root(self, value):\n    self._root = value\n    self._ast.root = self._root\n\n  @property\n  def ast(self):\n    return self._ast\n\n  @property\n  def live(self):\n    if self._live is None:\n      self._live = set()\n      worklist = [self.tree]\n      while worklist:\n        cur = worklist.pop(0)\n        if isinstance(cur, Ref):\n          self._live.add(cur.data)\n        else:\n          if not cur.terminal:\n            worklist.append(cur.rhs)\n            if cur.binary:\n              worklist.append(cur.lhs)\n\n    return self._live\n\n  @property\n  def tree(self):\n    if self._cstr is None:\n      self.__finalize()\n    return self._cstr\n\n  def has_comparator(self, cmp_kind):\n    worklist = [self.tree]\n    while worklist:\n      cur = worklist.pop(0)\n      logger.debug(\"Cur := %s\", cur)\n      if isinstance(cur, Comparator):\n        if cur.cmp_id == cmp_kind:\n          return True\n        worklist.append(cur.lhs)\n        if cur.rhs is not None:\n          worklist.append(cur.rhs)\n      elif isinstance(cur, Operator):\n        worklist.append(cur.lhs)\n        if cur.rhs is not None:\n          worklist.append(cur.rhs)\n    return False\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, Constraint) and self.tree == obj.tree\n\n\n  def __finalize(self):\n    root = self.root\n    self._cstr = None\n    if root.data[0] != COMPARE_OP:\n      self._cstr = Comparator.fromKind(CMP_IMPLICIT_NOT_EMPTY)\n    else:\n      self._cstr = Comparator.fromOpcode(*root.data)\n    self._cstr.data = root.data\n\n    def process_children(cstr_node, ast_node):\n      if ast_node.has_children() and cstr_node.terminal:\n        return\n\n      if not cstr_node.terminal:\n        if cstr_node.kind == Expr.COMPARATOR and cstr_node.cmp_id in (CMP_IMPLICIT_NOT_EMPTY, CMP_TYPE_CHECK):\n          if cstr_node.cmp_id == CMP_IMPLICIT_NOT_EMPTY:\n            cstr_node.rhs = convert_ast_constraint(ast_node)\n            process_children(cstr_node.rhs, ast_node)\n          else:\n            lhs_child = ast_node.first_child\n            cstr_node.lhs = convert_ast_constraint(lhs_child)\n            process_children(cstr_node.lhs, lhs_child)\n\n            if ast_node.num_children() > 1:\n              rhs_child = ast_node.child(1)\n              cstr_node.rhs = convert_ast_constraint(rhs_child)\n              process_children(cstr_node.rhs, rhs_child)\n        else:\n          expected_children_num = 2 if cstr_node.binary else 1\n          children = ast_node.children\n          num_children = len([c for c in children if c is not None])\n          if num_children != expected_children_num:\n            logger.debug(\"Consistency error. expected %d, got %d children for %s\",\n                         expected_children_num, num_children, ast_node)\n", "context": "equip/analysis/constraint/expr.py\nclass Expr(Expression):\n  \"\"\"\n    The ``Expr`` object with helpers for sub-classes. It also derives\n    from ``ast.expr.Expression``.\n  \"\"\"\n  UNKNOWN = 1\n  CONSTANT = 2\n  REFERENCE = 3\n  OPERATOR = 4\n  COMPARATOR = 5\n  UNDEFINED = 6\n\n  CAST_TYPE_BOOLEAN = 1\n  CAST_TYPE_INTEGER = 2\n  CAST_TYPE_NUMBER = 3\n  CAST_TYPE_STRING = 4\n  CAST_TYPE_UNKNOWN = 5\n\n  def __init__(self, kind=UNKNOWN, data=None, terminal=False, binary=False):\n    Expression.__init__(self)\n    self._kind = kind\n    self._data = data\n    self._ast = None\n    self._terminal = terminal\n    self._binary = binary\n    self._cast_type = Expr.CAST_TYPE_UNKNOWN\n\n  @property\n  def kind(self):\n    return self._kind\n\n  @kind.setter\n  def kind(self, value):\n    self._kind = value\n\n  @property\n  def data(self):\n    return self._data\n\n  @data.setter\n  def data(self, value):\n    self._data = value\n\n  @property\n  def ast(self):\n    return self._ast\n\n  @ast.setter\n  def ast(self, value):\n    self._ast = value\n\n  @property\n  def cast_type(self):\n    return self._cast_type\n\n  @cast_type.setter\n  def cast_type(self, value):\n    self._cast_type = value\n\n  @property\n  def terminal(self):\n    return self._terminal\n\n  @terminal.setter\n  def terminal(self, value):\n    self._terminal = value\n\n  @property\n  def binary(self):\n    return self._binary\n\n  @binary.setter\n  def binary(self, value):\n    self._binary = value\n\n  def __ne__(self, obj):\n    return True\n\n  def __eq__(self, obj):\n    return False\n\n  def __repr__(self):\n    return 'Expr(kind=%s, data=%s)' % (self.kind, repr(self.data))\nequip/analysis/constraint/expr.py\nCMP_IMPLICIT_NOT_EMPTY = 12\nequip/utils/log.py\nLOGGING_FMT = '%(asctime)s - %(levelname)3s] %(filename)s::%(funcName)s(%(lineno)d) - %(message)s'\ndef removeOtherHandlers(to_keep=None):\ndef enableLogger(to_file=None):\nequip/analysis/constraint/expr.py\nCMP_TYPE_CHECK = 13\nequip/analysis/graph/graphs.py\nclass TreeNode(object):\n  GLOBAL_COUNTER = 0\n\n  def __init__(self, kind=None, data=None):\n    TreeNode.GLOBAL_COUNTER += 1\n    self._id = TreeNode.GLOBAL_COUNTER\n    self._kind = kind\n    self._data = data\n    self._children = list()\n\n  @property\n  def gid(self):\n    return self._id\n\n  @property\n  def kind(self):\n    return self._kind\n\n  @kind.setter\n  def kind(self, value):\n    self._kind = value\n\n  @property\n  def data(self):\n    return self._data\n\n  @data.setter\n  def data(self, value):\n    self._data = value\n\n  @property\n  def children(self):\n    return self._children\n\n  def has_children(self):\n    return len(self._children) > 0\n\n  def num_children(self):\n    return len(self._children)\n\n  @property\n  def first_child(self):\n    return self._children[0]\n\n  @property\n  def last_child(self):\n    return self._children[len(self._children) - 1]\n\n  def child(self, n):\n    return self._children[n]\n\n  def reserve_children(self, number_children):\n    self._children = [None] * number_children\n\n  def insert_child(self, n, child):\n    self._children[n] = child\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, TreeNode) and obj.gid == self.gid\n\n  def __hash__(self):\n    return hash('treenode-' + str(self.gid))\n\n  def __repr__(self):\n    return 'TreeNode%d(kind=%s, data=%s, num_children=%d)'  \\\n           % (self.gid, repr(self.kind), repr(self.data), self.num_children())\nequip/analysis/constraint/expr.py\nclass Ref(Expr):\n  \"\"\"\n    Reference to a variable, function call, etc.\n  \"\"\"\n  def __init__(self, data=None):\n    Expr.__init__(self, Expr.REFERENCE, data, terminal=True, binary=False)\n    self._is_var = False\n    self._is_function_call = False\n\n  @property\n  def is_var(self):\n    return self._is_var\n\n  @is_var.setter\n  def is_var(self, value):\n    self._is_var = value\n\n  @property\n  def is_function_call(self):\n    return self._is_function_call\n\n  @is_function_call.setter\n  def is_function_call(self, value):\n    self._is_function_call = value\n\n  @staticmethod\n  def fromName(arg):\n    return Ref(data=arg)\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, Ref) and self.data == obj.data\n\n  def __repr__(self):\n    return 'Ref(%s)' % self.data\nequip/analysis/constraint/expr.py\nclass Comparator(Expr):\n  \"\"\"\n    A comparator operator for expressions.\n  \"\"\"\n  def __init__(self, data=None, cmp_id=None, commutative=False, binary=True):\n    Expr.__init__(self, Expr.COMPARATOR, data, terminal=False, binary=binary)\n    self._cmp_id = cmp_id\n    self._commutative = commutative\n    self._lhs = None\n    self._rhs = None\n\n  @property\n  def rhs(self):\n    return self._rhs\n\n  @rhs.setter\n  def rhs(self, value):\n    self._rhs = value\n\n  @property\n  def lhs(self):\n    return self._lhs\n\n  @lhs.setter\n  def lhs(self, value):\n    self._lhs = value\n\n  @property\n  def cmp_id(self):\n    return self._cmp_id\n\n  @cmp_id.setter\n  def cmp_id(self, value):\n    self._cmp_id = value\n\n  @property\n  def commutative(self):\n    return self._commutative\n\n  @commutative.setter\n  def commutative(self, value):\n    self._commutative = value\n\n  @staticmethod\n  def fromOpcode(op, arg):\n    return Comparator(**CMP_MAP[arg])\n\n  @staticmethod\n  def fromKind(kind):\n    return Comparator(**CMP_MAP[CMP_REPR[kind]])\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    if not isinstance(obj, Comparator):\n      return False\n    if self.cmp_id != obj.cmp_id:\n      return False\n    if not self.commutative:\n      return self.lhs == obj.lhs and self.rhs == obj.rhs\n    else:\n      return (self.lhs == obj.lhs and self.rhs == obj.rhs) \\\n             or (self.lhs == obj.rhs and self.rhs == obj.lhs)\n\n  def __repr__(self):\n    if not self.binary:\n      return '(%s %s)' % (CMP_REPR[self.cmp_id], repr(self.rhs))\n    return '(%s %s %s)' % (repr(self.lhs), CMP_REPR[self.cmp_id], repr(self.rhs))\nequip/analysis/constraint/expr.py\nCMP_MAP = {\n  '<': { 'cmp_id': CMP_LESS_THAN, 'commutative': False },\n  '<=' : { 'cmp_id': CMP_LESS_THAN_EQUAL, 'commutative': False },\n  '==': { 'cmp_id': CMP_EQUAL, 'commutative': True },\n  '!=' : { 'cmp_id': CMP_NOT_EQUAL, 'commutative': True },\n  '>': { 'cmp_id': CMP_GREATER_THAN, 'commutative': False },\n  '>=' : { 'cmp_id': CMP_GREATER_THAN_EQUAL, 'commutative': False },\n  'in': { 'cmp_id': CMP_IN, 'commutative': False },\n  'not in' : { 'cmp_id': CMP_NOT_IN, 'commutative': False },\n  'is': { 'cmp_id': CMP_IS, 'commutative': True },\n  'is not' : { 'cmp_id': CMP_IS_NOT, 'commutative': True },\n  'exception match': { 'cmp_id': CMP_EX_MATCH, 'commutative': False },\n  'not empty': { 'cmp_id': CMP_IMPLICIT_NOT_EMPTY, 'commutative': False, 'binary': False },\n  'typeof': { 'cmp_id': CMP_TYPE_CHECK, 'commutative': False },\n}\nequip/analysis/constraint/expr.py\nclass Undef(Expr):\n  def __init__(self, data=None):\n    Expr.__init__(self, Expr.UNDEFINED, data, terminal=True, binary=False)\n\n  def __ne__(self, obj):\n    return True\n\n  def __eq__(self, obj):\n    return False\n\n  def __repr__(self):\n    return 'Undef'\nequip/analysis/constraint/expr.py\nOP_MAP = {\n  opcode.opmap['UNARY_POSITIVE']: {'binary': False, 'commutative': False, 'char': '+' },\n  opcode.opmap['UNARY_NEGATIVE']: {'binary': False, 'commutative': False, 'char': '-' },\n  opcode.opmap['UNARY_NOT']: {'binary': False, 'commutative': False, 'char': 'not' },\n  opcode.opmap['UNARY_CONVERT']: {'binary': False, 'commutative': False, 'char': '`__rhs__`' },\n  opcode.opmap['UNARY_INVERT']: {'binary': False, 'commutative': False, 'char': '~' },\n  opcode.opmap['BINARY_POWER']: {'binary': True, 'commutative': False, 'char': '**' },\n  opcode.opmap['BINARY_MULTIPLY']: {'binary': True, 'commutative': True, 'char': '*' },\n  opcode.opmap['BINARY_DIVIDE']: {'binary': True, 'commutative': False, 'char': '/' },\n  opcode.opmap['BINARY_MODULO']: {'binary': True, 'commutative': False, 'char': '%' },\n  opcode.opmap['BINARY_ADD']: {'binary': True, 'commutative': True, 'char': '+' },\n  opcode.opmap['BINARY_SUBTRACT']: {'binary': True, 'commutative': False, 'char': '-' },\n  opcode.opmap['BINARY_SUBSCR']: {'binary': True, 'commutative': False, 'char': '__lhs__[__rhs__]' },\n  opcode.opmap['BINARY_FLOOR_DIVIDE']: {'binary': True, 'commutative': False, 'char': '//' },\n  opcode.opmap['BINARY_TRUE_DIVIDE']: {'binary': True, 'commutative': False, 'char': '/' },\n  opcode.opmap['BINARY_LSHIFT']: {'binary': True, 'commutative': False, 'char': '<<' },\n  opcode.opmap['BINARY_RSHIFT']: {'binary': True, 'commutative': False, 'char': '>>' },\n  opcode.opmap['BINARY_AND']: {'binary': True, 'commutative': True, 'char': '&' },\n  opcode.opmap['BINARY_XOR']: {'binary': True, 'commutative': True, 'char': '^' },\n  opcode.opmap['BINARY_OR']: {'binary': True, 'commutative': True, 'char': '|' },\n  BINARY_TYPE_CAST_BOOL: {'binary': False, 'commutative': False, 'char': 'bool(__rhs__)' },\n  BINARY_TYPE_CAST_INT: {'binary': False, 'commutative': False, 'char': 'int(__rhs__)' },\n  BINARY_TYPE_CAST_FLOAT: {'binary': False, 'commutative': False, 'char': 'float(__rhs__)' },\n  BINARY_TYPE_CAST_CHAR: {'binary': False, 'commutative': False, 'char': 'chr(__rhs__)' },\n  BINARY_TYPE_CAST_STRING : {'binary': False, 'commutative': False, 'char': 'str(__rhs__)' },\n  BINARY_TYPE_CAST_TUPLE : {'binary': False, 'commutative': False, 'char': 'tuple(__rhs__)' },\n}\nequip/analysis/graph/graphs.py\nclass Tree(object):\n  def __init__(self):\n    self._root = None\n\n  @property\n  def root(self):\n    return self._root\n\n  @root.setter\n  def root(self, value):\n    self._root = value\n\n  def to_dot(self):\n    from .io import DotConverter\n    return DotConverter.process(self)\nequip/analysis/constraint/expr.py\nclass Const(Expr):\n  \"\"\"\n    Constant expression with best-effort strong typing.\n  \"\"\"\n  def __init__(self, data=None):\n    Expr.__init__(self, Expr.CONSTANT, data, terminal=True, binary=False)\n    self._is_none = False\n    self._is_boolean = False\n    self._is_integer = False\n    self._is_string = False\n    self._is_container = False\n    self._is_symbol = False\n\n  @property\n  def is_none(self):\n    return self._is_none\n\n  @is_none.setter\n  def is_none(self, value):\n    self._is_none = value\n\n  @property\n  def is_boolean(self):\n    return self._is_boolean\n\n  @is_boolean.setter\n  def is_boolean(self, value):\n    self._is_boolean = value\n\n  @property\n  def boolean_value(self):\n    if self.is_boolean:\n      return self.data == 'True'\n    return None\n\n  @property\n  def is_integer(self):\n    return self._is_integer\n\n  @is_integer.setter\n  def is_integer(self, value):\n    self._is_integer = value\n\n  @property\n  def integer_value(self):\n    if self.is_integer:\n      return int(self.data)\n    return None\n\n  @property\n  def is_string(self):\n    return self._is_string\n\n  @is_string.setter\n  def is_string(self, value):\n    self._is_string = value\n\n  @property\n  def string_value(self):\n    if self.is_string:\n      return self.data\n    return None\n\n  @property\n  def is_container(self):\n    return self._is_container\n\n  @is_container.setter\n  def is_container(self, value):\n    self._is_container = value\n\n  def container_value(self):\n    if self.is_container:\n      return self.data\n    return None\n\n  @property\n  def is_symbol(self):\n    return self._is_symbol\n\n  @is_symbol.setter\n  def is_symbol(self, value):\n    self._is_symbol = value\n\n  @staticmethod\n  def fromValue(arg, is_symbol=False):\n    c = Const(data=arg)\n    if arg is None:\n      c.is_none = True\n    elif isinstance(arg, basestring):\n      c.is_string = True\n    elif isinstance(arg, bool):\n      c.is_boolean = True\n    elif isinstance(arg, int) or isinstance(arg, long):\n      c.is_integer = True\n    elif isinstance(arg, tuple):\n      c.is_container = True\n\n    if is_symbol:\n      c.is_symbol = True\n    return c\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, Const) and self.data == obj.data\n\n  def __repr__(self):\n    if self.is_symbol:\n      return 'Symbol(%s)' % repr(self.data)\n    return 'Const(%s)' % repr(self.data)\nequip/analysis/constraint/expr.py\nclass Operator(Expr):\n  \"\"\"\n    An operator for the current expression (e.g., PLUS, SUBSTRACT, etc.). The\n    comparison operator is commutativity-sensitive, but not w.r.t. distributivity.\n  \"\"\"\n  def __init__(self, data=None, binary=None, commutative=None, char=None, \\\n               lhs=None, rhs=None):\n    Expr.__init__(self, Expr.OPERATOR, data, terminal=False, binary=binary)\n    self._commutative = commutative\n    self._char = char\n    self._lhs = None\n    self._rhs = None\n\n  @property\n  def rhs(self):\n    return self._rhs\n\n  @rhs.setter\n  def rhs(self, value):\n    self._rhs = value\n\n  @property\n  def lhs(self):\n    return self._lhs\n\n  @lhs.setter\n  def lhs(self, value):\n    self._lhs = value\n\n  @property\n  def commutative(self):\n    return self._commutative\n\n  @commutative.setter\n  def commutative(self, value):\n    self._commutative = value\n\n  @staticmethod\n  def fromOpcode(op, arg):\n    return Operator(**OP_MAP[op])\n\n  @staticmethod\n  def fromTypeMethod(method_name):\n    if method_name == 'int':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_INT])\n    elif method_name == 'float':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_FLOAT])\n    elif method_name == 'bool':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_BOOL])\n    elif method_name == 'str':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_STRING])\n    elif method_name == 'chr':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_CHAR])\n    elif method_name == 'tuple':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_TUPLE])\n    return None\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    if not isinstance(obj, Operator):\n      return False\n    if self._char != obj._char:\n      return False\n    if not self.commutative:\n      return self.lhs == obj.lhs and self.rhs == obj.rhs\n    else:\n      return (self.lhs == obj.lhs and self.rhs == obj.rhs) \\\n             or (self.lhs == obj.rhs and self.rhs == obj.lhs)\n\n  def __repr__(self):\n    rr = ''\n    if not self.binary:\n      if '__rhs__' in self._char:\n        rr = self._char.replace('__rhs__', repr(self.rhs))\n      else:\n        rr = self._char + repr(self.rhs)\n    else:\n      rr = self._char\n      if '__lhs__' in rr and '__rhs__' in rr:\n        for l in ('__rhs__', '__lhs__'):\n          hs = self.rhs if l == '__rhs__' else self.lhs\n          rr = rr.replace(l, repr(hs))\n      else:\n        rr = repr(self.lhs) + ' ' + self._char + ' ' + repr(self.rhs)\n    return \"(%s)\" % rr\n", "answers": ["            cstr_node.rhs = Undef(data=None)"], "length": 1751, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "0697cb04cdcd9172485f3f0398a5d0f1a9a8061972ff6197"}
{"input": "import android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport net.chilicat.m3u8.Element;\nimport net.chilicat.m3u8.ParseException;\nimport net.chilicat.m3u8.Playlist;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport ch.citux.td.R;\nimport ch.citux.td.config.TDConfig;\nimport ch.citux.td.data.model.TwitchAccessToken;\nimport ch.citux.td.data.model.TwitchBroadcast;\nimport ch.citux.td.data.model.TwitchChunk;\nimport ch.citux.td.data.model.TwitchChunks;\nimport ch.citux.td.data.model.TwitchPlayList;\nimport ch.citux.td.data.model.TwitchStreamQuality;\nimport ch.citux.td.data.model.TwitchVideo;\nimport ch.citux.td.data.service.TDServiceImpl;\nimport ch.citux.td.data.worker.TDBasicCallback;\nimport ch.citux.td.ui.TDActivity;\nimport ch.citux.td.ui.adapter.PlaylistAdapter;\nimport ch.citux.td.ui.dialogs.ErrorDialogFragment;\nimport ch.citux.td.ui.fragments.TDBase;\nimport ch.citux.td.ui.fragments.VideoFragment;\nimport retrofit.client.Response;\n/*\n * Copyright 2013-2014 Paul Stöhr\n *\n * This file is part of TD.\n *\n * TD is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage ch.citux.td.util;\n\n\n\n\n\npublic class VideoPlayer {\n\n    private static final String TAG = \"VideoPlayer\";\n\n    public static void playVideo(TDActivity activity, TwitchBroadcast broadcast) {\n        Log.d(TAG, \"Playing Playlist'\" + broadcast.getChannel() + \"' with \" + broadcast.getChunks().getLive().size() + \" parts\");\n\n        if (useInternPlayer(activity)) { //built-in Player\n            Bundle args = new Bundle();\n            args.putString(VideoFragment.TITLE, broadcast.getChannel());\n            args.putStringArray(VideoFragment.PLAYLIST, getPlaylistUrls(broadcast));\n            playVideoIntern(activity, args);\n        } else {\n            activity.showPlaylist(broadcast);\n        }\n    }\n\n    private static String[] getPlaylistUrls(TwitchBroadcast broadcast) {\n        if (broadcast != null && broadcast.getChunks() != null && broadcast.getChunks().getLive() != null) {\n            List<TwitchChunk> videos = broadcast.getChunks().getLive();\n            String[] urls = new String[videos.size()];\n            for (int i = 0; i < videos.size(); i++) {\n                urls[i] = videos.get(i).getUrl();\n            }\n            return urls;\n        }\n        return null;\n    }\n\n    public static void playVideo(TDActivity activity, String title, String url) {\n        if (activity != null) {\n            Log.d(TAG, \"Playing '\" + title + \"' from \" + url);\n\n            if (useInternPlayer(activity)) { //built-in Player\n                Log.d(TAG, \"internal\");\n                Bundle args = new Bundle();\n                args.putString(VideoFragment.TITLE, title);\n                args.putString(VideoFragment.URL, url);\n                playVideoIntern(activity, args);\n            } else { //external Player\n                Log.d(TAG, \"external\");\n\n                Intent intent = new Intent(Intent.ACTION_VIEW);", "context": "src/main/java/ch/citux/td/data/model/TwitchChunks.java\npublic class TwitchChunks extends TwitchBase {\n\n    private List<TwitchChunk> live;\n\n    public List<TwitchChunk> getLive() {\n        return live;\n    }\n\n    public void setLive(List<TwitchChunk> live) {\n        this.live = live;\n    }\n}\nsrc/main/java/ch/citux/td/data/worker/TDBasicCallback.java\npublic abstract class TDBasicCallback<Result> implements TDCallback<Result> {\n\n    private Object caller;\n\n    protected TDBasicCallback(Object caller) {\n        this.caller = caller;\n    }\n\n    @Override\n    public void startLoading() {\n        if (caller instanceof TDListFragment) {\n            ((TDListFragment) caller).startLoading();\n        }\n    }\n\n    @Override\n    public void stopLoading() {\n        if (caller instanceof TDListFragment) {\n            ((TDListFragment) caller).stopLoading();\n        }\n    }\n\n    @Override\n    public void onError(String title, String message) {\n        if (caller instanceof TDListFragment) {\n            ((TDListFragment) caller).onError(title, message);\n        }\n    }\n}\nsrc/main/java/net/chilicat/m3u8/ParseException.java\npublic class ParseException extends Exception {\n    private final String line;\n    private final int lineNumber;\n\n    public ParseException(String line, int lineNumber, Throwable cause) {\n        super(cause);\n        this.line = line;\n        this.lineNumber = lineNumber;\n    }\n\n    public ParseException(String line, int lineNumber, String message) {\n        super(message);\n        this.line = line;\n        this.lineNumber = lineNumber;\n    }\n\n    public String getLine() {\n        return line;\n    }\n\n    public int getLineNumber() {\n        return lineNumber;\n    }\n\n    @Override\n    public String getMessage() {\n        return \"Error at line \" + getLineNumber() + \": \" + getLine() + \"\\n\" + super.getMessage();    //To change body of overridden methods use File | Settings | File Templates.\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchBroadcast.java\npublic class TwitchBroadcast extends TwitchBase {\n\n    private String api_id;\n    private String increment_view_count_url;\n    private String path;\n    private String broadcaster_software;\n    private String channel;\n    private String preview_small;\n    private String preview;\n    private TwitchChunks chunks;\n    private long duration;\n    private long start_offset;\n    private long end_offset;\n    private long play_offset;\n    private long vod_ad_frequency;\n    private long vod_ad_length;\n\n    public String getApi_id() {\n        return api_id;\n    }\n\n    public void setApi_id(String api_id) {\n        this.api_id = api_id;\n    }\n\n    public String getIncrement_view_count_url() {\n        return increment_view_count_url;\n    }\n\n    public void setIncrement_view_count_url(String increment_view_count_url) {\n        this.increment_view_count_url = increment_view_count_url;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public String getBroadcaster_software() {\n        return broadcaster_software;\n    }\n\n    public void setBroadcaster_software(String broadcaster_software) {\n        this.broadcaster_software = broadcaster_software;\n    }\n\n    public String getChannel() {\n        return channel;\n    }\n\n    public void setChannel(String channel) {\n        this.channel = channel;\n    }\n\n    public String getPreview_small() {\n        return preview_small;\n    }\n\n    public void setPreview_small(String preview_small) {\n        this.preview_small = preview_small;\n    }\n\n    public String getPreview() {\n        return preview;\n    }\n\n    public void setPreview(String preview) {\n        this.preview = preview;\n    }\n\n    public TwitchChunks getChunks() {\n        return chunks;\n    }\n\n    public void setChunks(TwitchChunks chunks) {\n        this.chunks = chunks;\n    }\n\n    public long getDuration() {\n        return duration;\n    }\n\n    public void setDuration(long duration) {\n        this.duration = duration;\n    }\n\n    public long getStart_offset() {\n        return start_offset;\n    }\n\n    public void setStart_offset(long start_offset) {\n        this.start_offset = start_offset;\n    }\n\n    public long getEnd_offset() {\n        return end_offset;\n    }\n\n    public void setEnd_offset(long end_offset) {\n        this.end_offset = end_offset;\n    }\n\n    public long getPlay_offset() {\n        return play_offset;\n    }\n\n    public void setPlay_offset(long play_offset) {\n        this.play_offset = play_offset;\n    }\n\n    public long getVod_ad_frequency() {\n        return vod_ad_frequency;\n    }\n\n    public void setVod_ad_frequency(long vod_ad_frequency) {\n        this.vod_ad_frequency = vod_ad_frequency;\n    }\n\n    public long getVod_ad_length() {\n        return vod_ad_length;\n    }\n\n    public void setVod_ad_length(long vod_ad_length) {\n        this.vod_ad_length = vod_ad_length;\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchVideo.java\npublic class TwitchVideo extends TwitchBase {\n\n    private String _id;\n    private String title;\n    private String description;\n    private long broadcast_id;\n    private Date recorded_at;\n    private String game;\n    private long length;\n    private String preview;\n    private String url;\n    private long views;\n    private TwitchChannel channel;\n\n    public String get_id() {\n        return _id;\n    }\n\n    public void set_id(String _id) {\n        this._id = _id;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public long getBroadcast_id() {\n        return broadcast_id;\n    }\n\n    public void setBroadcast_id(long broadcast_id) {\n        this.broadcast_id = broadcast_id;\n    }\n\n    public Date getRecorded_at() {\n        return recorded_at;\n    }\n\n    public void setRecorded_at(Date recorded_at) {\n        this.recorded_at = recorded_at;\n    }\n\n    public String getGame() {\n        return game;\n    }\n\n    public void setGame(String game) {\n        this.game = game;\n    }\n\n    public long getLength() {\n        return length;\n    }\n\n    public void setLength(long length) {\n        this.length = length;\n    }\n\n    public String getPreview() {\n        return preview;\n    }\n\n    public void setPreview(String preview) {\n        this.preview = preview;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public long getViews() {\n        return views;\n    }\n\n    public void setViews(long views) {\n        this.views = views;\n    }\n\n    public TwitchChannel getChannel() {\n        return channel;\n    }\n\n    public void setChannel(TwitchChannel channel) {\n        this.channel = channel;\n    }\n}\nsrc/main/java/ch/citux/td/ui/dialogs/ErrorDialogFragment.java\npublic class ErrorDialogFragment extends DialogFragment {\n\n    private static final String FRAGMENT_TAG = \"ErrorDialogFragment\";\n    private static final String BUNDLE_TITLE = \"title\";\n    private static final String BUNDLE_MESSAGE = \"message\";\n    private DialogInterface.OnClickListener mOnClickListener;\n    private OnCancelListener mOnCancelListener;\n\n    private static ErrorDialogFragment newInstance(String title, String message,\n                                                   DialogInterface.OnClickListener onClickListener, OnCancelListener onCancelListener) {\n        ErrorDialogFragment dialogFragment = new ErrorDialogFragment();\n        dialogFragment.mOnClickListener = onClickListener;\n\n        Bundle args = new Bundle();\n        args.putString(BUNDLE_TITLE, title);\n        args.putString(BUNDLE_MESSAGE, message);\n        dialogFragment.setArguments(args);\n\n        return dialogFragment;\n    }\n\n    public static void dismiss(FragmentActivity activity) {\n        FragmentManager fragmentManager = activity.getSupportFragmentManager();\n        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n\n        Fragment prev = fragmentManager.findFragmentByTag(FRAGMENT_TAG);\n        if (prev != null) {\n            fragmentTransaction.remove(prev);\n        }\n        fragmentTransaction.commit();\n    }\n\n    @Override\n    public Dialog onCreateDialog(Bundle savedInstanceState) {\n        Bundle args = getArguments();\n        AlertDialog.Builder b = new AlertDialog.Builder(getActivity());\n        b.setTitle(args.getString(BUNDLE_TITLE));\n        b.setMessage(args.getString(BUNDLE_MESSAGE));\n        setCancelable(true);\n        b.setNeutralButton(getActivity().getString(android.R.string.ok), mOnClickListener);\n        return b.create();\n    }\n\n    @Override\n    public void onCancel(DialogInterface dialog) {\n        if (mOnCancelListener != null) {\n            mOnCancelListener.onCancel();\n        }\n    }\n\n    public interface OnCancelListener {\n        public void onCancel();\n    }\n\n    public static class ErrorDialogFragmentBuilder {\n        private FragmentActivity mActivity;\n        private String mTitle;\n        private String mMessage;\n        private DialogInterface.OnClickListener mOnClickListener;\n        private OnCancelListener mOnCancelListener;\n\n        public ErrorDialogFragmentBuilder(FragmentActivity activity) {\n            if (activity != null) {\n                mActivity = activity;\n                mTitle = activity.getString(R.string.dialog_error_title);\n            }\n        }\n\n        public ErrorDialogFragmentBuilder setTitle(int resId) {\n            mTitle = mActivity.getString(resId);\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setTitle(String text) {\n            mTitle = text;\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setMessage(int resId) {\n            mMessage = mActivity.getString(resId);\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setMessage(String text) {\n            mMessage = text;\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setOnClickListener(DialogInterface.OnClickListener onClickListener) {\n            mOnClickListener = onClickListener;\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setOnCancelListener(OnCancelListener onCancelListener) {\n            mOnCancelListener = onCancelListener;\n            return this;\n        }\n\n        public void show() {\n            FragmentManager fragmentManager = mActivity.getSupportFragmentManager();\n            FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n\n            Fragment prev = fragmentManager.findFragmentByTag(FRAGMENT_TAG);\n            if (prev != null) {\n                fragmentTransaction.remove(prev);\n            }\n            fragmentTransaction.addToBackStack(null);\n\n            ErrorDialogFragment.newInstance(mTitle, mMessage, mOnClickListener, mOnCancelListener)\n                    .show(fragmentManager, FRAGMENT_TAG);\n        }\n    }\n}\nsrc/main/java/ch/citux/td/ui/TDActivity.java\npublic class TDActivity extends ActionBarActivity implements TDCallback<TwitchChannel>, View.OnFocusChangeListener, AdapterView.OnItemClickListener {\n\n    private FavoritesFragment favoritesFragment;\n    private GameOverviewFragment gameOverviewFragment;\n    private GameStreamsFragment gameStreamsFragment;\n    private ChannelFragment channelFragment;\n    private SearchFragment searchFragment;\n    private VideoFragment videoFragment;\n    private SettingsFragment settingsFragment;\n\n    private ActionBarDrawerToggle toggle;\n    private MenuItem refreshItem;\n    private MenuItem searchItem;\n    private View refreshView;\n    private String username;\n    private Toast toast;\n    private boolean isLoading;\n    private boolean hasUsername;\n\n    @InjectView(R.id.user) View user;\n    @InjectView(R.id.toolbar) Toolbar toolbar;\n    @InjectView(R.id.imgUser) ImageView imgUser;\n    @InjectView(R.id.lblUser) TextView lblUser;\n    @InjectView(R.id.lblNoUser) TextView lblNoUser;\n    @Optional @InjectView(R.id.drawerLayout) DrawerLayout drawerLayout;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.main);\n        ButterKnife.inject(this);\n\n        Context contextThemeWrapper = new ContextThemeWrapper(this, R.style.Theme_TD_Light);\n        LayoutInflater inflater = LayoutInflater.from(this).cloneInContext(contextThemeWrapper);\n        refreshView = inflater.inflate(R.layout.action_refresh, null);\n\n        initNavigation();\n        updateUser();\n\n        if (favoritesFragment == null) {\n            Bundle args = new Bundle();\n            args.putBoolean(TDConfig.SETTINGS_CHANNEL_NAME, hasUsername);\n\n            favoritesFragment = new FavoritesFragment();\n            favoritesFragment.setArgs(args);\n\n            getSupportFragmentManager()\n                    .beginTransaction()\n                    .add(R.id.content, favoritesFragment)\n                    .commit();\n        } else {\n            replaceFragment(favoritesFragment);\n        }\n    }\n\n    private void initNavigation() {\n        toolbar.setLogo(R.drawable.twitch_logo_white);\n        toolbar.setLogoDescription(R.string.app_name);\n        setSupportActionBar(toolbar);\n\n        if (drawerLayout != null) {\n            toggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.navigation_open, R.string.navigation_close);\n            toggle.setDrawerIndicatorEnabled(true);\n            drawerLayout.setDrawerListener(toggle);\n        }\n\n        ListView lstNav = (ListView) findViewById(R.id.lstNav);\n        lstNav.setAdapter(new ArrayAdapter<>(this, R.layout.list_item_navigation, getResources().getStringArray(R.array.navigation)));\n        lstNav.setOnItemClickListener(this);\n    }\n\n    public void updateUser() {\n        username = PreferenceManager.getDefaultSharedPreferences(this).getString(TDConfig.SETTINGS_CHANNEL_NAME, \"\");\n        hasUsername = !username.equals(\"\");\n\n        if (hasUsername) {\n            user.setVisibility(View.VISIBLE);\n            lblUser.setText(username);\n            lblNoUser.setVisibility(View.GONE);\n\n            TDTaskManager.executeTask(this);\n        } else {\n            user.setVisibility(View.GONE);\n            lblNoUser.setVisibility(View.VISIBLE);\n            imgUser.setImageResource(R.drawable.default_channel_logo_medium);\n        }\n    }\n\n    @Override\n    protected void onPostCreate(Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n        if (drawerLayout != null) {\n            toggle.syncState();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        refreshData();\n    }\n\n    private void replaceFragment(Fragment fragment) {\n        replaceFragment(fragment, true);\n    }\n\n    private void replaceFragment(Fragment fragment, boolean backstack) {\n        if (fragment != null && !fragment.isAdded()) {\n            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();\n            transaction.replace(R.id.content, fragment);\n            if (backstack) {\n                transaction.addToBackStack(null);\n            }\n            transaction.commitAllowingStateLoss();\n        }\n    }\n\n    @Override\n    protected void onNewIntent(Intent intent) {\n        if (Intent.ACTION_SEARCH.equals(intent.getAction())) {\n            String query = intent.getStringExtra(SearchManager.QUERY);\n\n            if (searchFragment == null) {\n                searchFragment = new SearchFragment();\n            }\n            searchFragment.setQuery(query);\n            searchFragment.loadData();\n\n            replaceFragment(searchFragment);\n            Log.d(this, query);\n        }\n    }\n\n    @Override\n    public void onPause() {\n        TDTaskManager.cancelAllTasks();\n        super.onPause();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.main, menu);\n\n        refreshItem = menu.findItem(R.id.menu_refresh);\n        searchItem = menu.findItem(R.id.menu_search);\n\n        // Associate searchable configuration with the SearchView\n        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);\n        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);\n        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));\n        searchView.setOnQueryTextFocusChangeListener(this);\n\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.menu_refresh:\n                if (!isLoading) {\n                    refreshData();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    public void showChannel(TwitchChannel channel) {\n        if (channelFragment == null) {\n            channelFragment = new ChannelFragment();\n        }\n\n        if (channelFragment.isAdded()) {\n            channelFragment.updateChannel(channel);\n        } else {\n            Bundle arguments = new Bundle();\n            arguments.putSerializable(ChannelFragment.CHANNEL, channel);\n            channelFragment.setArgs(arguments);\n            replaceFragment(channelFragment);\n        }\n    }\n\n    public void showVideo(Bundle args) {\n        if (videoFragment == null) {\n            videoFragment = new VideoFragment();\n        }\n        videoFragment.setArgs(args);\n\n        if (videoFragment.isAdded()) {\n            videoFragment.playVideo();\n        } else {\n            replaceFragment(videoFragment);\n        }\n        MenuItemCompat.collapseActionView(searchItem);\n    }\n\n    public void showPlaylist(TwitchBroadcast broadcast) {\n        if (channelFragment.isAdded()) {\n            channelFragment.showPlaylist(broadcast);\n        }\n    }\n\n    public void showStreams(Bundle args) {\n        if (gameStreamsFragment == null) {\n            gameStreamsFragment = new GameStreamsFragment();\n        }\n        gameStreamsFragment.setArgs(args);\n        replaceFragment(gameStreamsFragment);\n    }\n\n    public void startLoading() {\n        isLoading = true;\n        if (refreshItem != null) {\n            MenuItemCompat.setActionView(refreshItem, refreshView);\n        }\n    }\n\n    public void stopLoading() {\n        isLoading = false;\n        if (refreshItem != null) {\n            MenuItemCompat.setActionView(refreshItem, null);\n        }\n    }\n\n    @Override\n    public TwitchChannel startRequest() {\n        return TDServiceImpl.getInstance().getChannel(username);\n    }\n\n    @Override\n    public void onResponse(TwitchChannel response) {\n        if (response != null) {\n            Picasso.with(this)\n                    .load(response.getLogo().getUrl(TwitchLogo.Size.MEDIUM))\n                    .placeholder(R.drawable.default_channel_logo_medium)\n                    .into(imgUser);\n        }\n    }\n\n    @Override\n    public void onError(String title, String message) {\n        toast = Toast.makeText(this, title + \": \" + message, Toast.LENGTH_SHORT);\n        toast.show();\n    }\n\n    @Override\n    public boolean isAdded() {\n        return true;\n    }\n\n    @Override\n    public void setTitle(int titleId) {\n        super.setTitle(titleId);\n        if (toolbar != null) {\n            toolbar.setTitle(titleId);\n        }\n    }\n\n    @Override\n    public void setTitle(CharSequence title) {\n        super.setTitle(title);\n        if (toolbar != null) {\n            toolbar.setTitle(title);\n        }\n    }\n\n    protected void refreshData() {\n        if (favoritesFragment != null && favoritesFragment.isAdded()) {\n            favoritesFragment.refreshData();\n        }\n        if (channelFragment != null && channelFragment.isAdded()) {\n            channelFragment.refreshData();\n        }\n        if (searchFragment != null && searchFragment.isAdded()) {\n            searchFragment.refreshData();\n        }\n        if (gameOverviewFragment != null && gameOverviewFragment.isAdded()) {\n            gameOverviewFragment.refreshData();\n        }\n        if (gameStreamsFragment != null && gameStreamsFragment.isAdded()) {\n            gameStreamsFragment.refreshData();\n        }\n    }\n\n    @Override\n    public void onFocusChange(View view, boolean queryTextFocused) {\n        if (!queryTextFocused) {\n            MenuItemCompat.collapseActionView(searchItem);\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (drawerLayout != null && drawerLayout.isDrawerOpen(Gravity.START)) {\n            drawerLayout.closeDrawers();\n        } else {\n            super.onBackPressed();\n        }\n    }\n\n    @Override\n    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n        switch (position) {\n            case 0:\n                if (favoritesFragment == null) {\n                    favoritesFragment = new FavoritesFragment();\n                }\n                replaceFragment(favoritesFragment);\n                break;\n            case 1:\n                if (gameOverviewFragment == null) {\n                    gameOverviewFragment = new GameOverviewFragment();\n                }\n                replaceFragment(gameOverviewFragment);\n                break;\n            case 2:\n                if (settingsFragment == null) {\n                    settingsFragment = new SettingsFragment();\n                }\n                replaceFragment(settingsFragment);\n                break;\n        }\n        if (drawerLayout != null) {\n            drawerLayout.closeDrawers();\n        }\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchChunk.java\npublic class TwitchChunk extends TwitchBase {\n\n    private String url;\n    private String vod_count_url;\n    private String upkeep;\n    private long length;\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public String getVod_count_url() {\n        return vod_count_url;\n    }\n\n    public void setVod_count_url(String vod_count_url) {\n        this.vod_count_url = vod_count_url;\n    }\n\n    public String getUpkeep() {\n        return upkeep;\n    }\n\n    public void setUpkeep(String upkeep) {\n        this.upkeep = upkeep;\n    }\n\n    public long getLength() {\n        return length;\n    }\n\n    public void setLength(long length) {\n        this.length = length;\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchStreamQuality.java\npublic class TwitchStreamQuality extends TwitchBase {\n\n    private String key;\n    private String name;\n    private int value;\n\n    public TwitchStreamQuality(String key, int value) {\n        this(key, value, key);\n    }\n\n    public TwitchStreamQuality(String key, int value, String name) {\n        this.key = key;\n        this.value = value;\n        this.name = name;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\nsrc/main/java/ch/citux/td/ui/adapter/PlaylistAdapter.java\npublic class PlaylistAdapter extends BaseAdapter {\n\n    private LayoutInflater inflater;\n    private List<TwitchChunk> videos;\n    private ArrayList<Integer> played;\n\n    public PlaylistAdapter(Context context, List<TwitchChunk> videos) {\n        super();\n        this.inflater = LayoutInflater.from(context);\n        this.videos = videos;\n        this.played = new ArrayList<Integer>(videos.size());\n    }\n\n    public void setVideos(List<TwitchChunk> videos) {\n        this.videos = videos;\n        if (videos != null && videos.size() > 0) {\n            notifyDataSetChanged();\n        } else {\n            notifyDataSetInvalidated();\n        }\n    }\n\n    public void setPlayed(int position) {\n        played.add(position);\n    }\n\n    @Override\n    public int getCount() {\n        return videos.size();\n    }\n\n    @Override\n    public TwitchChunk getItem(int position) {\n        if (position < videos.size()) {\n            return videos.get(position);\n        }\n        return null;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return position;\n    }\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        TwitchChunk video = getItem(position);\n        ViewHolder holder;\n        if (convertView == null || convertView.getTag() == null) {\n            holder = new ViewHolder();\n            convertView = inflater.inflate(R.layout.list_item_playlist, parent, false);\n            if (convertView != null) {\n                ButterKnife.inject(holder, convertView);\n            }\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        holder.lblPartIndex.setText(String.valueOf(position + 1));\n        holder.lblPartCount.setText(String.valueOf(getCount()));\n        //TODO holder.lblTitle.setText(video.());\n        holder.chkPlayed.setChecked(played.contains(position));\n        return convertView;\n    }\n\n    class ViewHolder {\n        @InjectView(R.id.lblPartIndex) TextView lblPartIndex;\n        @InjectView(R.id.lblPartCount) TextView lblPartCount;\n        @InjectView(R.id.lblTitle) TextView lblTitle;\n        @InjectView(R.id.chkPlayed) CheckBox chkPlayed;\n    }\n}\nsrc/main/java/ch/citux/td/ui/fragments/VideoFragment.java\npublic class VideoFragment extends TDFragment {//implements MediaPlayer.OnPreparedListener {\n\n    public static final String PLAYLIST = \"playlist\";\n    public static final String TITLE = \"title\";\n    public static final String URL = \"url\";\n\n    @InjectView(android.R.id.empty) EmptyView emptyView;\n    //    @InjectView(R.id.videoView) VideoView videoView;\n    @InjectView(R.id.player) View player;\n    @InjectView(R.id.chat) View chat;\n\n    @Override\n    protected int onCreateView() {\n        return R.layout.video;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        super.setRetainInstance(true);\n\n//        if (((TDActivity) getActivity()).isTablet()) {\n//            emptyView.setImage(R.drawable.ic_glitchicon_white);\n//        }\n\n//        MediaController mediaController = new MediaController(getActivity());\n//        videoView.setMediaController(mediaController);\n//        videoView.setVideoLayout(VideoView.VIDEO_LAYOUT_SCALE, 1);\n//        videoView.setOnPreparedListener(this);\n//\n//        onOrientationChange(getResources().getConfiguration().orientation);\n//\n//        playVideo();\n    }\n\n    @Override\n    public void loadData() {\n\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n\n        getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        getSupportActionBar().show();\n    }\n\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n\n//        onOrientationChange(newConfig.orientation);\n    }\n\n    private void onOrientationChange(int orientation) {\n//        if (orientation == Configuration.ORIENTATION_LANDSCAPE) {\n//            getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n//            getSupportActionBar().hide();\n//            videoView.setVideoLayout(VideoView.VIDEO_LAYOUT_STRETCH, 1.77f);\n//            chat.setVisibility(View.GONE);\n//        } else {\n//            getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n//            getSupportActionBar().show();\n//            videoView.setVideoLayout(VideoView.VIDEO_LAYOUT_SCALE, 1.77f);\n//            chat.setVisibility(View.VISIBLE);\n//        }\n    }\n\n    public void playVideo() {\n\n//        getActivity().setVolumeControlStream(AudioManager.STREAM_MUSIC);\n//        if (getArguments() != null && (!getArguments().containsKey(URL) || !getArguments().containsKey(CHUNKS))) {\n//            getSupportActionBar().setTitle(getArguments().getString(TITLE));\n//\n//            if (getArguments().containsKey(URL)) {\n//                videoView.setVideoURI(Uri.parse(getArguments().getString(URL)));\n//            }\n//            if (getArguments().containsKey(CHUNKS)) {\n//                videoView.setVideoPlaylist(getArguments().getStringArray(CHUNKS));\n//            }\n//            videoView.start();\n//        }\n    }\n\n    @Override\n    public Object startRequest() {\n        return null;\n    }\n\n    @Override\n    public void onResponse(Object response) {\n\n    }\n\n//    @Override\n//    public void onPrepared(MediaPlayer mp) {\n//        emptyView.setVisibility(View.GONE);\n//        player.setVisibility(View.VISIBLE);\n//    }\n}\nsrc/main/java/ch/citux/td/ui/fragments/TDBase.java\npublic interface TDBase {\n\n    public void loadData();\n\n    public void startActivity(Intent intent);\n\n    public SharedPreferences getDefaultSharedPreferences();\n\n    public boolean isAdded();\n\n    public TDActivity getTDActivity();\n\n    public void setArgs(Bundle args);\n\n    public Bundle getArgs();\n}\nsrc/main/java/net/chilicat/m3u8/Element.java\npublic interface Element {\n\n    public String getTitle();\n\n\n    public int getDuration();\n\n    /**\n     * URI to media or playlist.\n     *\n     * @return the URI.\n     */\n    public URI getURI();\n\n    /**\n     * Media can be encrypted.\n     *\n     * @return true if media encrypted.\n     */\n    public boolean isEncrypted();\n\n    /**\n     * Element can be another playlist.\n     *\n     * @return true if element a playlist.\n     */\n    public boolean isPlayList();\n\n    /**\n     * Element is a media file.\n     *\n     * @return true if element a media file and not a playlist.\n     */\n    public boolean isMedia();\n\n    /**\n     * If media is encryped than will this method return a info object.\n     *\n     * @return the info object or null if media not encrypted.\n     */\n    public EncryptionInfo getEncryptionInfo();\n\n    /**\n     * If element a playlist than this method will return a PlaylistInfo object.\n     *\n     * @return a info object or null in case of element is not a playlist.\n     */\n    public PlaylistInfo getPlayListInfo();\n\n    /**\n     * The program date.\n     *\n     * @return -1 in case of program date is not set.\n     */\n    public long getProgramDate();\n\n}\nsrc/main/java/net/chilicat/m3u8/Playlist.java\npublic final class Playlist implements Iterable<Element> {\n\n    public static Playlist parse(Readable readable) throws ParseException {\n        if (readable == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return PlaylistParser.create(PlaylistType.M3U8).parse(readable);\n    }\n\n    public static Playlist parse(String playlist) throws ParseException {\n        if (playlist == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return parse(new StringReader(playlist));\n    }\n\n    public static Playlist parse(InputStream playlist) throws ParseException {\n        if (playlist == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return parse(new InputStreamReader(playlist));\n    }\n\n    public static Playlist parse(ReadableByteChannel playlist) throws ParseException {\n        if (playlist == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return parse(makeReadable(playlist));\n    }\n\n    private static Readable makeReadable(ReadableByteChannel source) {\n        if (source == null) {\n            throw new NullPointerException(\"source\");\n        }\n\n\n        return Channels.newReader(source,\n                java.nio.charset.Charset.defaultCharset().name());\n    }\n\n    private final List<Element> elements;\n    private final boolean endSet;\n    private final int targetDuration;\n    private int mediaSequenceNumber;\n\n    Playlist(List<Element> elements, boolean endSet, int targetDuration, int mediaSequenceNumber) {\n        if (elements == null) {\n            throw new NullPointerException(\"elements\");\n        }\n        this.targetDuration = targetDuration;\n        this.elements = elements;\n        this.endSet = endSet;\n        this.mediaSequenceNumber = mediaSequenceNumber;\n    }\n\n    public int getTargetDuration() {\n        return targetDuration;\n    }\n\n    public Iterator<Element> iterator() {\n        return elements.iterator();\n    }\n\n    public List<Element> getElements() {\n        return elements;\n    }\n\n    public boolean isEndSet() {\n        return endSet;\n    }\n\n    public int getMediaSequenceNumber() {\n        return mediaSequenceNumber;\n    }\n\n    @Override\n    public String toString() {\n        return \"PlayListImpl{\" +\n                \"elements=\" + elements +\n                \", endSet=\" + endSet +\n                \", targetDuration=\" + targetDuration +\n                \", mediaSequenceNumber=\" + mediaSequenceNumber +\n                '}';\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchAccessToken.java\npublic class TwitchAccessToken extends TwitchBase {\n\n    private String token;\n    private String sig;\n    private String p;\n    private boolean mobile_restricted;\n\n    public String getToken() {\n        return token;\n    }\n\n    public void setToken(String token) {\n        this.token = token;\n    }\n\n    public String getSig() {\n        return sig;\n    }\n\n    public void setSig(String sig) {\n        this.sig = sig;\n    }\n\n    public String getP() {\n        return p;\n    }\n\n    public void setP(String p) {\n        this.p = p;\n    }\n\n    public boolean isMobile_restricted() {\n        return mobile_restricted;\n    }\n\n    public void setMobile_restricted(boolean mobile_restricted) {\n        this.mobile_restricted = mobile_restricted;\n    }\n}\nsrc/main/java/ch/citux/td/config/TDConfig.java\npublic class TDConfig {\n\n    public static final String SETTINGS_CHANNEL_NAME = \"channel_name\";\n    public static final String SETTINGS_LICENSE_DIALOG = \"license_dialog\";\n    public static final String SETTINGS_STREAM_QUALITY = \"stream_quality\";\n\n    public static final String CAST_APPLICATION_ID = \"D25E1BBE\";\n    public static final String KRAKEN_CLIENT_ID = \"sx9d3whtcht2lhrtd6yjia8rv019wxi\";\n\n    public static final String UTF_8 = \"UTF-8\";\n\n    public static final String MIME_FLV = \"video/x-flv\";\n    public static final String MIME_TWITCH = \"application/vnd.twitchtv.v3+json\";\n\n    public static final String URL_API_TWITCH_KRAKEN_BASE = \"https://api.twitch.tv/kraken\";\n    public static final String URL_API_TWITCH_API_BASE = \"https://api.twitch.tv/api\";\n    public static final String URL_API_USHER_BASE = \"http://usher.twitch.tv\";\n\n}\nsrc/main/java/ch/citux/td/data/service/TDServiceImpl.java\npublic class TDServiceImpl implements TwitchAPI, TwitchKraken, TwitchUsher, RestAdapter.Log {\n\n    private static final String TAG = \"TDService\";\n\n    private static TDServiceImpl instance;\n\n    private TwitchAPI twitchAPI;\n    private TwitchUsher twitchUsher;\n    private TwitchKraken twitchKraken;\n\n    private TDServiceImpl() {\n        RestAdapter.Builder builder = new RestAdapter.Builder()\n                .setLog(this)\n                .setLogLevel(BuildConfig.DEBUG ? RestAdapter.LogLevel.FULL : RestAdapter.LogLevel.NONE)\n                .setConverter(new JacksonConverter());\n\n        RestAdapter apiAdapter = builder\n                .setEndpoint(TDConfig.URL_API_TWITCH_API_BASE)\n                .build();\n        RestAdapter usherAdapter = builder\n                .setEndpoint(TDConfig.URL_API_USHER_BASE)\n                .build();\n        RestAdapter krakenAdapter = builder\n                .setEndpoint(TDConfig.URL_API_TWITCH_KRAKEN_BASE)\n                .setRequestInterceptor(new KrakenRequestInterceptor())\n                .build();\n\n        twitchAPI = apiAdapter.create(TwitchAPI.class);\n        twitchUsher = usherAdapter.create(TwitchUsher.class);\n        twitchKraken = krakenAdapter.create(TwitchKraken.class);\n    }\n\n    public static TDServiceImpl getInstance() {\n        if (instance == null) {\n            instance = new TDServiceImpl();\n        }\n        return instance;\n    }\n\n    @Override\n    public void log(String message) {\n        Log.d(TAG, message);\n    }\n\n    private class KrakenRequestInterceptor implements RequestInterceptor {\n        @Override\n        public void intercept(RequestInterceptor.RequestFacade request) {\n            request.addHeader(\"Accept\", TDConfig.MIME_TWITCH);\n            request.addHeader(\"Client-ID\", TDConfig.KRAKEN_CLIENT_ID);\n        }\n    }\n\n    @Override\n    public TwitchFollows getFollows(String username, int offset) {\n        return twitchKraken.getFollows(username, offset);\n    }\n\n    @Override\n    public TwitchChannel getChannel(String channel) {\n        return twitchKraken.getChannel(channel);\n    }\n\n    @Override\n    public TwitchStream getStream(String channel) {\n        return twitchKraken.getStream(channel);\n    }\n\n    @Override\n    public TwitchStream getStreams(String game, int offset) {\n        return twitchKraken.getStreams(game, offset);\n    }\n\n    @Override\n    public TwitchVideos getVideos(String channel, int offset) {\n        return twitchKraken.getVideos(channel, offset);\n    }\n\n    @Override\n    public TwitchStream searchStreams(String query, int offset) {\n        return twitchKraken.searchStreams(query, offset);\n    }\n\n    @Override\n    public TwitchChannels searchChannels(String query, int offset) {\n        return twitchKraken.searchChannels(query, offset);\n    }\n\n    @Override\n    public TwitchGames getTopGames(int limit, int offset) {\n        return twitchKraken.getTopGames(limit, offset);\n    }\n\n    //TwitchAPI\n    @Override\n    public TwitchAccessToken getChannelToken(String channel) {\n        return twitchAPI.getChannelToken(channel);\n    }\n\n    @Override\n    public TwitchAccessToken getVodToken(@Path(\"videoId\") String videoId) {\n        return twitchAPI.getVodToken(videoId);\n    }\n\n    @Override\n    public TwitchBroadcast getVideoPlaylist(@Path(\"id\") String id) {\n        return twitchAPI.getVideoPlaylist(id);\n    }\n\n    //TwitchUsher\n    @Override\n    public Response getChannelPlaylist(String channel, String p, String token, String sig) {\n        return twitchUsher.getChannelPlaylist(channel, p, token, sig);\n    }\n\n    @Override\n    public Response getVodPlaylist(@Path(\"videoId\") String videoId, @Query(\"p\") String p, @Query(\"token\") String token, @Query(\"sig\") String sig) {\n        return twitchUsher.getVodPlaylist(videoId, p, token, sig);\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchPlayList.java\npublic class TwitchPlayList extends TwitchBase {\n\n    public static final TwitchStreamQuality QUALITY_MOBILE = new TwitchStreamQuality(\"mobile\", 1);\n    public static final TwitchStreamQuality QUALITY_LOW = new TwitchStreamQuality(\"low\", 2);\n    public static final TwitchStreamQuality QUALITY_MEDIUM = new TwitchStreamQuality(\"medium\", 3);\n    public static final TwitchStreamQuality QUALITY_HIGH = new TwitchStreamQuality(\"high\", 4);\n    public static final TwitchStreamQuality QUALITY_CHUNKED = new TwitchStreamQuality(\"chunked\", 5, \"source\");\n\n    public static final TwitchStreamQuality[] SUPPORTED_QUALITIES = {\n            QUALITY_MOBILE,\n            QUALITY_LOW,\n            QUALITY_MEDIUM,\n            QUALITY_HIGH,\n            QUALITY_CHUNKED\n    };\n\n    private HashMap<TwitchStreamQuality, String> streams;\n\n    public static TwitchStreamQuality parseQuality(String name) {\n        for (TwitchStreamQuality quality : SUPPORTED_QUALITIES) {\n            if (quality.getName().equalsIgnoreCase(name) || quality.getKey().equalsIgnoreCase(name)) {\n                return quality;\n            }\n        }\n        return null;\n    }\n\n    public String getStream(TwitchStreamQuality quality) {\n        String url = streams.get(quality);\n        if (StringUtils.isEmpty(url)) {\n            url = getBestStream();\n        }\n        return url;\n    }\n\n    public String getBestStream() {\n        TwitchStreamQuality best = new TwitchStreamQuality(\"\", -1);\n\n        for (TwitchStreamQuality quality : streams.keySet()) {\n            if (best.getValue() < quality.getValue()) {\n                best = quality;\n            }\n        }\n\n        if (best.getValue() > -1) {\n            return getStream(best);\n        }\n        return null;\n    }\n\n    public HashMap<TwitchStreamQuality, String> getStreams() {\n        return streams;\n    }\n\n    public void setStreams(HashMap<TwitchStreamQuality, String> streams) {\n        this.streams = streams;\n    }\n}\n", "answers": ["                intent.setDataAndType(Uri.parse(url), TDConfig.MIME_FLV);"], "length": 3615, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "b3e2346d898f5d979d88e1ef30c8d97a9e53c92308800882"}
{"input": "import android.Manifest;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.PackageManager;\nimport android.location.Location;\nimport android.location.LocationListener;\nimport android.location.LocationManager;\nimport android.support.design.widget.Snackbar;\nimport android.support.design.widget.TextInputEditText;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AlertDialog;\nimport android.os.Bundle;\nimport android.support.v7.widget.AppCompatButton;\nimport android.support.v7.widget.AppCompatSpinner;\nimport android.support.v7.widget.AppCompatTextView;\nimport android.support.v7.widget.SwitchCompat;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.CompoundButton;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Locale;\nimport dlei.forkme.R;\nimport dlei.forkme.datastore.DatabaseHelper;\nimport dlei.forkme.datastore.NoDataException;\nimport dlei.forkme.datastore.TooMuchDataException;\nimport dlei.forkme.endpoints.BaseUrls;\nimport dlei.forkme.endpoints.ForkMeBackendApi;\nimport dlei.forkme.helpers.LocationHelper;\nimport dlei.forkme.helpers.NetworkAsyncCheck;\nimport dlei.forkme.helpers.NetworkHelper;\nimport dlei.forkme.model.LocationData;\nimport dlei.forkme.model.json.PostLocationDataBody;\nimport dlei.forkme.state.AppSettings;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport retrofit2.Call;\nimport retrofit2.Callback;\nimport retrofit2.Retrofit;\nimport retrofit2.converter.gson.GsonConverterFactory;\n                        .create()\n                        .show();\n            }  else {\n                // No explanation needed, we can request the permission.\n                ActivityCompat.requestPermissions(this,\n                        new String[]{Manifest.permission. ACCESS_FINE_LOCATION},\n                        MY_PERMISSIONS_REQUEST_LOCATION);\n            }\n        } else {\n            Log.wtf(\"SettingActivity: \", \" askForLocationPermissions() Already have permissions.\");\n            getLocation();\n        }\n    }\n\n\n    /**\n     * Called when the user responds to a permission request.\n     * @param requestCode code assigned to permission request.\n     * @param permissions permissions requested.\n     * @param grantResults results of permission requests.\n     */\n    public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {\n        switch (requestCode) {\n            case MY_PERMISSIONS_REQUEST_LOCATION: {\n                // If request is cancelled, the result arrays are empty.\n                if (grantResults.length > 0\n                        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                    // Permission is granted.\n                    Log.d(\"SettingsActivity: \", \"onRequestPermissionsResult() \" +\n                            \"Location Permissions: granted\");\n                    String isCheckedStr = \"True\";\n                    mSwitchText.setText(isCheckedStr);\n                    mLocationSwitch.setClickable(false);\n                    // Only enable to turn of locations if locations permissions is revoked from outside.\n                } else {\n                    // Permission denied.\n                    Log.wtf(\"SettingsActivity: \", \"onRequestPermissionsResult() \" +\n                            \"Location Permissions: denied, test: \" + permissions[0]);\n\n                    boolean showRationale = shouldShowRequestPermissionRationale(permissions[0]);\n                    if (!showRationale) {\n                        // User also selected never show again.\n                        Log.wtf(\"SettingsActivity: \", \"onRequestPermissionsResultI() \" +\n                                \"Location Permissions: never show again clicked, disabled forever.\");\n                        // Disable switch button.\n                        mLocationSwitch.setEnabled(false);\n                        mSwitchText.setText(getResources().getText(R.string.disabled));\n                        // Make LocationDisabledForever true.\n                        AppSettings.updateLocationDisabledForever(1);\n                    }\n                    // Update switch to be false.\n                    mLocationSwitch.setChecked(false);\n                }\n                return;\n            }\n\n        }\n\n    }\n\n    // Location code adapted from:\n    // https://stackoverflow.com/questions/10524381/gps-android-get-positioning-only-once\n    // https://stackoverflow.com/questions/40142331/how-to-request-location-permission-on-android-6/40142454\n\n    /**\n     * Determine if location should be asked from GPS. We only want to get location once so we can determine\n     * what city the user is in. Only get new location if the old location if more than 2 days old.\n     */\n    public void getLocation() {\n        try {\n            Location location = mLocationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);\n            // location time retrieved > time in milliseconds - 2000 (less than 2 days old).\n            // 1.4 days.\n            if (location != null && location.getTime() < Calendar.getInstance().getTimeInMillis() + 2 * 60 * 1000) {\n                // Use olg location.\n                Log.d(\"SettingActivity: \", \"getLocation(): Old location, latitude: \" + location.getLatitude() +\n                        \", longitude: \" + location.getLongitude() + \", time: \" + location.getTime());\n                postLocationInformation(location);\n            } else {\n                // Ask for location updates.\n                Log.d(\"SettingActivity: \", \"getLocation(): Request location updates.\");\n                // Bug fix for not being called onLocationChanged()\n                // https://stackoverflow.com/questions/9007600/onlocationchanged-callback-is-never-called\n                mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, this);\n                mLocationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, this);\n            }\n        } catch (SecurityException e) {\n            Log.wtf(\"SettingActivity: \", \"Failed \" + e.getMessage());\n            return;\n        }\n    }\n\n    /**\n     * Location updates have been requested, this is triggered when we get a location update.\n     * We stop updates after this one update.\n     * @param location new location.\n     */\n    public void onLocationChanged(Location location) {\n        Log.d(\"SettingActivity: \", \"onLocationChanged() called\");\n        if (location != null) {\n            Log.d(\"SettingActivity: \", \"onLocationChanged(): Location update, latitude: \"\n                    + location.getLatitude() + \", longitude: \" + location.getLongitude());\n            mLocationManager.removeUpdates(this);   // Stop updates.\n            postLocationInformation(location);\n\n        }\n    }\n\n    // Required functions for location.\n    public void onProviderDisabled(String arg0) {}\n    public void onProviderEnabled(String arg0) {}\n    public void onStatusChanged(String arg0, int arg1, Bundle arg2) {}\n\n    /**\n     * Post location along with user information to ForkMe backend.\n     * @param location retrieved from GPS.\n     */\n    public void postLocationInformation(Location location) {\n        double latitude = location.getLatitude();\n        double longitude = location.getLongitude();", "context": "ForkMe-Mobile/app/src/main/java/dlei/forkme/model/LocationData.java\npublic class LocationData {\n\n    private Double latitude;\n    private Double longitude;\n    private Integer id;\n\n    public Double getLatitude() {\n        return latitude;\n    }\n\n    public void setLatitude(Double latitude) {\n        this.latitude = latitude;\n    }\n\n    public Double getlongitude() {\n        return longitude;\n    }\n\n    public void setlongitude(Double _longitude) {\n        this.longitude = longitude;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n     public void setId(Integer id) {\n        this.id = id;\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/datastore/DatabaseHelper.java\npublic class DatabaseHelper extends SQLiteOpenHelper {\n\n    public static DatabaseHelper sDbInstance = null;\n\n    public static final String sDatabaseName = \"AppSettings\";\n    public static final int sDatabaseVersion = 1;\n\n    private DatabaseHelper(Context context) {\n        super(context, sDatabaseName, null, sDatabaseVersion);\n    }\n\n    /**\n     * Singleton pattern so only 1 object of DatabaseHelper exists.\n     * @param context activity context.\n     * @return instance of DatabaseHelper.\n     */\n    public static synchronized DatabaseHelper getDbInstance(Context context) {\n        if (sDbInstance == null) {\n            sDbInstance = new DatabaseHelper(context);\n            Log.d(\"DatabaseHelper: \", \"getDbInstance() created new instance\");\n        }\n        return sDbInstance;\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase sqLiteDatabase) {\n        try {\n            sqLiteDatabase.execSQL(AppSettings.CREATE_TABLE_SQL);\n            Log.d(\"DatabaseHelper: \", \"onCreate() created db\");\n        } catch (SQLException e) {\n            Log.wtf(\"Error: \", String.format(\"Create Table Statement: %s\\nException: %s\",\n                    AppSettings.CREATE_TABLE_SQL, e));\n        }\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {\n        try {\n            sqLiteDatabase.execSQL(\"DROP TABLE IF EXISTS \" + AppSettings.TABLE_NAME); // Drop table.\n            onCreate(sqLiteDatabase); // Re make table.\n        } catch (SQLException e) {\n            // Shouldn't happen, if it does log what a terrible message.\n            Log.wtf(\"Error: \", String.format(\"onUpdate Error, Exception %s\", e));\n        }\n        // db.close();  // Close database connection.\n    }\n\n    /**\n     * Insert settings for a user into persistant storage.\n     */\n    public void insertSettings() {\n        if (AppSettings.sUserLogin.equals(\"\")) {\n            Log.wtf(\"Error: \", \"DatabaseHelper.insertSettings(): user log in is null\");\n            return;\n        }\n        Log.i(\"DatabaseHelper: \", \"insertSettings(): inserting settings\");\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.USER_ID_COL, AppSettings.sUserLogin);\n        values.put(AppSettings.TIMEFRAME_COL, AppSettings.sTimeframe);\n        values.put(AppSettings.SORT_BY_COL, AppSettings.sSortBy);\n        values.put(AppSettings.LANGUAGE_COL, AppSettings.sLanguage);\n        values.put(AppSettings.LOCATION_DISABLED_FOREVER_COL, AppSettings.sLocationDisabledForever);\n        values.put(AppSettings.FIND_PEOPLE_MESSAGE_COL, AppSettings.sFindPeopleMessage);\n        values.put(AppSettings.PRIVATE_REPOS_COL, AppSettings.sShowPrivateRepositories);\n        long result = db.insert(AppSettings.TABLE_NAME, null, values);\n        if (result == -1) {\n            Log.w(\"Error: \", String.format(\"Adding settings for user %s\", AppSettings.sUserLogin));\n        }\n    }\n\n    /**\n     * Update language for a user in persistant storage.\n     */\n    public void updateLanguage() {\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.LANGUAGE_COL, AppSettings.sLanguage);\n        db.update(AppSettings.TABLE_NAME, values, AppSettings.USER_ID_COL + \"='\" + AppSettings.sUserLogin +\"'\",\n                null);\n        db.close();\n    }\n\n    /**\n     * Update timeframe preference for a user in persistant storage.\n     */\n    public void updateTimeframe() {\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.TIMEFRAME_COL, AppSettings.sTimeframe);\n        db.update(AppSettings.TABLE_NAME, values, AppSettings.USER_ID_COL + \"='\" + AppSettings.sUserLogin +\"'\",\n                null);\n        db.close();\n    }\n\n    /**\n     * Update stort by preference for a user in persistant storage.\n     */\n    public void updateSortBy() {\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.SORT_BY_COL, AppSettings.sSortBy);\n        db.update(AppSettings.TABLE_NAME, values, AppSettings.USER_ID_COL + \"='\" + AppSettings.sUserLogin +\"'\",\n                null);\n        db.close();\n    }\n\n    /**\n     * Loads settings for a user from SQLite db.\n     * @throws NoDataException Thrown when no data returned.\n     * @throws TooMuchDataException Thrown when too much data returned.\n     */\n    public void loadSettings() throws NoDataException, TooMuchDataException{\n        SQLiteDatabase db = this.getWritableDatabase();\n\n        String baseQuery = \"SELECT %s, %s, %s, %s, %s, %s from %s WHERE %s=?\";\n\n        String query = String.format(baseQuery,\n                AppSettings.TIMEFRAME_COL, AppSettings.SORT_BY_COL, AppSettings.LANGUAGE_COL,\n                AppSettings.LOCATION_DISABLED_FOREVER_COL, AppSettings.FIND_PEOPLE_MESSAGE_COL, AppSettings.PRIVATE_REPOS_COL,\n                AppSettings.TABLE_NAME,\n                AppSettings.USER_ID_COL);\n        Log.i(\"UserLogin: \", AppSettings.sUserLogin);\n\n        Cursor cursor = db.rawQuery(query, new String[]{AppSettings.sUserLogin});\n\n        cursor.moveToFirst();\n        int rows = cursor.getCount();\n        if (rows == 0) {\n            cursor.close();\n            db.close();\n            throw new NoDataException(String.format(\n                    \"User with login %s does not exist\", AppSettings.sUserLogin));\n        } else if (rows > 1) {\n            cursor.close();\n            db.close();\n            throw new TooMuchDataException(String.format(\n                    \"Only 1 row should be returned for user %s\", AppSettings.sUserLogin));\n        } else {\n            // Update settings for a user.\n            Log.i(\"Check has data worked: \", \"Language: \" + cursor.getString(2));\n            Log.i(\"Check has data worked: \", \"Timeframe: \" + cursor.getString(1));\n\n            AppSettings.setTimeframe(cursor.getString(0));\n            AppSettings.setSortBy(cursor.getString(1));\n            AppSettings.setLanguage(cursor.getString(2));\n            AppSettings.setLocationDisabledForever(cursor.getInt(3));\n            AppSettings.setFindPeopleAllowedMessage(cursor.getString(4));\n            AppSettings.setShowPrivateRepositories(cursor.getInt(5));\n            cursor.close();\n            db.close();\n        }\n\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/endpoints/ForkMeBackendApi.java\npublic interface ForkMeBackendApi {\n\n    // Get all repositories v1.\n    @GET(\"/all_repos\")\n    Call<RepositoryResponse> getAllRepositories();\n\n    // Get single repository v1.\n    @GET(\"/all_repos/repositories/{id}\")\n    Call<Repository> getRepository(@Path(\"id\") int id);\n\n    // Get all repositories v2.\n    @GET(\"/repositories\")\n    Call<List<Repository>> getRepositoriesArray();\n\n    // Post location data v2.\n    @POST(\"/locations\")\n    Call<ResponseBody> postLocation(@Body PostLocationDataBody data);\n\n    // Get developers v2.\n    @GET(\"/developers/{login}\")\n    Call<List<DeveloperContactInfo>> getDevelopers(@Path(\"login\") String login);\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/helpers/LocationHelper.java\npublic class LocationHelper {\n\n    /**\n     * Checks if location permissions has been granted to application.\n     * @param context Activity context.\n     * @return true if has location permissions, else false.\n     */\n    public static boolean hasLocationPermissions(Context context) {\n\n        boolean hasLocationPermissions = ContextCompat\n                .checkSelfPermission(context,\n                        Manifest.permission.ACCESS_FINE_LOCATION\n                ) == PackageManager.PERMISSION_GRANTED;\n        return hasLocationPermissions;\n    }\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/endpoints/BaseUrls.java\npublic class BaseUrls {\n    public static String githubApi = \"https://api.github.com/\";\n    public static String forkMeBackendApi = \"https://forkme-backend-api2.herokuapp.com/\";\n    public static String forkMeBackendApiDeprecated = \"https://forkme-backend.herokuapp.com/\";\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/state/AppSettings.java\npublic class AppSettings {\n    // Setting attributes.\n    public static String sLanguage = \"All\";\n    public static String sSortBy = \"Stars\";\n    public static String sTimeframe = \"1 Month\";\n    public static String sUserLogin = \"\";\n    public static int sLocationDisabledForever = 0;\n    public static String sFindPeopleMessage = \"N/A\";\n    public static int sShowPrivateRepositories = 0;\n    public static String sOAuthToken = \"\";\n    public static String sUserName = \"\";\n    public static String sUserAvatarUrl = \"\";\n    public static String sUserEmail;\n\n    // Database attributes.\n    public static final String TABLE_NAME = \"settings\";\n    public static final String TIMEFRAME_COL = \"timeframe\";\n    public static final String SORT_BY_COL = \"sort_by\";\n    public static final String LANGUAGE_COL = \"language\";\n    public static final String LOCATION_DISABLED_FOREVER_COL = \"location_disabled_forever\";\n    public static final String FIND_PEOPLE_MESSAGE_COL = \"message\";\n    public static final String PRIVATE_REPOS_COL = \"private_repos\";\n    public static final String USER_ID_COL = \"user\";\n\n    public static final String CREATE_TABLE_SQL =\n            \"CREATE TABLE \" +\n            TABLE_NAME + \" (\" +\n            USER_ID_COL + SqlSyntax.TYPE_STRING + SqlSyntax.PRIMARY_KEY + \", \" +\n            TIMEFRAME_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            SORT_BY_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            LANGUAGE_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            LOCATION_DISABLED_FOREVER_COL + SqlSyntax.TYPE_INTEGER + SqlSyntax.NOT_NULL + \", \" +\n            FIND_PEOPLE_MESSAGE_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            PRIVATE_REPOS_COL + SqlSyntax.TYPE_INTEGER + SqlSyntax.NOT_NULL +\n            \")\";\n\n    public static void setLanguage(String language) {\n        sLanguage = language;\n    }\n\n    public static void setSortBy(String sortBy) {\n        sSortBy = sortBy;\n    }\n\n    public static void setTimeframe(String timeframe) {\n        sTimeframe = timeframe;\n    }\n\n    public static void setLocationDisabledForever(int i) {\n        if (i > 1 || i < 0) {\n            Log.wtf(\"AppSettings: \", \"setShowPrivateRepositories: Invalid value \" + i);\n            return;\n        }\n        sLocationDisabledForever = i;\n    }\n\n    public static void setFindPeopleAllowedMessage(String findPeopleAllowedMessage) {\n        sFindPeopleMessage = findPeopleAllowedMessage;\n    }\n\n    public static void setShowPrivateRepositories(int i) {\n        if (i > 1 || i < 0) {\n            Log.wtf(\"AppSettings: \", \"setShowPrivateRepositories: Invalid value \" + i);\n            return;\n        }\n        sShowPrivateRepositories = i;\n    }\n\n    public static void updateLanguage(String language) {\n        sLanguage = language;\n        Log.i(\"AppSettings: \", \"updateLanguage(): \" + language);\n    }\n\n    public static void updateTimeframe(String timeframe) {\n        sTimeframe = timeframe;\n        Log.i(\"AppSettings: \", \"updateTimeframe(): \" + timeframe);\n    }\n\n    public static void updateSortBy(String sortBy) {\n        sSortBy = sortBy;\n        Log.i(\"AppSettings: \", \"updateSortBy(): \" + sortBy);\n    }\n\n    public static void updateLocationDisabledForever(int i) {\n        if (i > 1 || i < 0) {\n            Log.wtf(\"AppSettings: \", \"updateLocationDisabledForever(): Invalid value \" + i);\n            return;\n        }\n        Log.i(\"AppSettings: \", \"updateLocationDisabledForever(): \" + i);\n        sLocationDisabledForever = i;\n    }\n\n    public static void setOAuthToken(String token) {\n        sOAuthToken = token;\n    }\n\n    public static void setUserLogin(String userLogin) {\n        sUserLogin = userLogin;\n    }\n\n    public static void setUserName(String userName) {\n        sUserName = userName;\n    }\n\n    public static void setUserAvatarUrl(String userAvatarUrl) {\n        sUserAvatarUrl  = userAvatarUrl;\n    }\n\n    public static void setUserEmail(String email) { sUserEmail = email; }\n\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/helpers/NetworkAsyncCheck.java\npublic class NetworkAsyncCheck extends AsyncTask<Void, Void, Boolean> {\n    private View view;\n\n    public NetworkAsyncCheck(View view) {\n        this.view = view;\n        Log.i(\"NetworkAsyncCheck: \", \"Starting\");\n    }\n\n    protected Boolean doInBackground(Void... params) {\n        Log.i(\"NetworkAsyncCheck: \", \"Doing\");\n        try {\n            InetAddress ipAddress = InetAddress.getByName(\"www.google.com\");\n            return !ipAddress.equals(\"\") ? Boolean.TRUE : Boolean.FALSE;\n        } catch (Exception e) {\n            return Boolean.FALSE;\n        }\n    }\n\n    protected void onPostExecute(Boolean result) {\n        Log.i(\"NetWorkASyncCheck: \", \" Done\");\n        if (result == Boolean.FALSE) {\n            Snackbar.make(view, String.format(Locale.getDefault(), NetworkHelper.noConnectionMessage, \"the internet\"), Snackbar.LENGTH_INDEFINITE)\n                    .setAction(\"CLOSE\", new View.OnClickListener() {\n                        @Override\n                        public void onClick(View view) {}\n                    })\n                    .setActionTextColor(ContextCompat.getColor(view.getContext(), R.color.colorAccent))\n                    .show();\n        }\n    }\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/helpers/NetworkHelper.java\npublic class NetworkHelper {\n\n    static String noConnectionMessage = \"Please connect to %s, this app requires internet access.\";\n\n    /**\n     * Return null if not connected to a network, else returns an async task to check the network has internet connection.\n     * Note: This checks for both valid network and valid internet connection.\n     * @param view any view in the activity that called this, used to make snackbar.\n     * @return null or NetworkHelper.NetworkAsyncCheck.\n     */\n    public static NetworkAsyncCheck checkNetworkConnection(View view) {\n        Context context = view.getContext();\n        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n\n        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();\n        boolean isConnectedToNetwork = activeNetwork != null &&\n                activeNetwork.isConnectedOrConnecting();\n\n        if (!isConnectedToNetwork) {\n            Snackbar.make(view, String.format(Locale.getDefault(), noConnectionMessage, \"a network\"), Snackbar.LENGTH_INDEFINITE)\n                    .setAction(\"CLOSE\", new View.OnClickListener() {\n                        @Override\n                        public void onClick(View view) {}\n                    })\n                    .setActionTextColor(ContextCompat.getColor(context, R.color.colorAccent))\n                    .show();\n            return null;\n        }\n        return new NetworkAsyncCheck(view);\n    }\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/datastore/TooMuchDataException.java\npublic class TooMuchDataException extends Exception {\n    public TooMuchDataException(String s) {\n        super(s);\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/datastore/NoDataException.java\npublic class NoDataException extends Exception {\n    public NoDataException(String s) {\n        super(s);\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/model/json/PostLocationDataBody.java\npublic class PostLocationDataBody {\n    String login;\n    double latitude;\n    double longitude;\n    String message;\n    String email;\n    String name;\n    String avatarUrl;\n\n    public PostLocationDataBody(String login, double latitude, double longitude, String message,\n                                String email, String name, String avatarUrl) {\n        this.login = login;\n        this.latitude = latitude;\n        this.longitude = longitude;\n        this.message = message;\n        this.email = email;\n        this.name = name;\n        this.avatarUrl = avatarUrl;\n    }\n}\n", "answers": ["        PostLocationDataBody dataBody = new PostLocationDataBody("], "length": 2035, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "31be7d5ae81230c8f97a65a4360e143cd828be77c08f3863"}
{"input": "import re\nfrom nn_dataflow.core import InputLayer, ConvLayer, FCLayer, PoolingLayer\nfrom nn_dataflow.core import InterLayerPipeline\nfrom nn_dataflow.core import Network\nfrom nn_dataflow.core import Option\nfrom nn_dataflow.core import PhyDim2\nfrom nn_dataflow.core import PipelineSegment\nfrom . import TestPipelineFixture\n\"\"\" $lic$\nCopyright (C) 2016-2020 by Tsinghua University and The Board of Trustees of\nStanford University\n\nThis program is free software: you can redistribute it and/or modify it under\nthe terms of the Modified BSD-3 License as published by the Open Source\nInitiative.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE. See the BSD-3 License for more details.\n\nYou should have received a copy of the Modified BSD-3 License along with this\nprogram. If not, see <https://opensource.org/licenses/BSD-3-Clause>.\n\"\"\"\n\n\n\n\nclass TestInterLayerPipeline(TestPipelineFixture):\n    ''' Tests for InterLayerPipeline. '''\n\n    def test_valid_args(self):\n        ''' Valid arguments. '''\n", "context": "nn_dataflow/tests/pipeline_test/test_pipeline_fixture.py\nclass TestPipelineFixture(unittest.TestCase):\n    ''' Base fixture class for layer pipeline tests. '''\n\n    def setUp(self):\n\n        self.net = {}\n\n        net = Network('net1')\n        # Linear.\n        net.set_input_layer(InputLayer(10, 1))\n        net.add('0', FCLayer(10, 20))\n        net.add('1', FCLayer(20, 30))\n        net.add('1p', PoolingLayer(30, 1, 1))\n        net.add('2', FCLayer(30, 40))\n        net.add('3', FCLayer(40, 50))\n        self.net[net.net_name] = net\n\n        net = Network('net2')\n        # Long linear.\n        net.set_input_layer(InputLayer(1, 1))\n        for idx in range(16):\n            net.add(str(idx), FCLayer(1, 1))\n        self.net[net.net_name] = net\n\n        net = Network('net3')\n        # Fork.\n        # /0-2\\   /6- 7- 8\\\n        #   x  4-5         12\n        # \\1-3/   \\9-10-11/\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1), prevs=net.INPUT_LAYER_KEY)\n        net.add('1', FCLayer(1, 1), prevs=net.INPUT_LAYER_KEY)\n        net.add('2', FCLayer(2, 1), prevs=('0', '1'))\n        net.add('2p', PoolingLayer(1, 1, 1))\n        net.add('3', FCLayer(2, 1), prevs=('0', '1'))\n        net.add('4', FCLayer(2, 1), prevs=('2p', '3'))\n        net.add('5', FCLayer(1, 1))\n        net.add('5p', PoolingLayer(1, 1, 1))\n        net.add('6', FCLayer(1, 1), prevs='5p')\n        net.add('7', FCLayer(1, 1))\n        net.add('8', FCLayer(1, 1))\n        net.add('9', FCLayer(1, 1), prevs='5p')\n        net.add('10', FCLayer(1, 1))\n        net.add('11', FCLayer(1, 1))\n        net.add('12', FCLayer(2, 1), prevs=('8', '11'))\n        self.net[net.net_name] = net\n\n        net = Network('net4')\n        # Complex fork.\n        #          /5       \\\n        # 0-1-2-3-4-6-7-8-10-14\n        #              \\9/\n        #          \\11-12   /\n        #          \\13      /\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1))\n        net.add('2', FCLayer(1, 1))\n        net.add('3', FCLayer(1, 1))\n        net.add('4', FCLayer(1, 1))\n        net.add('5', FCLayer(1, 1), prevs='4')\n        net.add('6', FCLayer(1, 1), prevs='4')\n        net.add('7', FCLayer(1, 1))\n        net.add('8', FCLayer(1, 1), prevs='7')\n        net.add('9', FCLayer(1, 1), prevs='7')\n        net.add('10', FCLayer(1, 1))\n        net.add('10p', PoolingLayer(2, 1, 1), prevs=('8', '10'))\n        net.add('11', PoolingLayer(1, 1, 1), prevs='4')\n        net.add('12', FCLayer(1, 1))\n        net.add('13', PoolingLayer(1, 1, 1), prevs='4')\n        net.add('14', FCLayer(5, 1), prevs=('5', '10p', '12', '13'))\n        self.net[net.net_name] = net\n\n        net = Network('net5')\n        # Corner cases.\n        #  ----\\\n        # //1-2\\ 7-8\\\n        # 0-3-4-x   10-11-12\n        #  \\ \\5/ 9 /  \\__/\n        #   6--/\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1), prevs='0')\n        net.add('2', FCLayer(1, 1))\n        net.add('3', FCLayer(1, 1), prevs='0')\n        net.add('4', FCLayer(1, 1), prevs='3')\n        net.add('5', FCLayer(1, 1), prevs='3')\n        net.add('6', FCLayer(1, 1), prevs='0')\n        net.add('7', FCLayer(5, 1), prevs=('0', '2', '4', '5', '6'))\n        net.add('8', FCLayer(1, 1))\n        net.add('9', FCLayer(5, 1), prevs=('0', '2', '4', '5', '6'))\n        net.add('10', FCLayer(2, 1), prevs=('8', '9'))\n        net.add('11', FCLayer(1, 1))\n        net.add('12', FCLayer(2, 1), prevs=('10', '11'))\n        self.net[net.net_name] = net\n\n        net = Network('net6')\n        # Fmap sizes.\n        net.set_input_layer(InputLayer(1, 24))\n        net.add('0', ConvLayer(1, 1, 24, 3))\n        net.add('1', ConvLayer(1, 1, 12, 3, strd=2))\n        net.add('1p', PoolingLayer(1, 6, 2))\n        net.add('2', ConvLayer(1, 1, 6, 3))\n        net.add('3', ConvLayer(1, 1, 6, 3, strd=4), prevs=('0'))\n        self.net[net.net_name] = net\n\n        net = Network('net7')\n        # Topological order: see a visited vertex again.\n        #  /---\n        # 0-1-\\\\\n        #  \\2--2p\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1), prevs='0')\n        net.add('2', FCLayer(1, 1), prevs='0')\n        net.add('2p', PoolingLayer(3, 1, 1), prevs=('0', '1', '2'))\n        self.net[net.net_name] = net\n\n        net = Network('net8')\n        # Forward to the middle.\n        #    /-\\\n        # 0-1-2-2p-4-4p\n        #  \\-3------/\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1), prevs='0')\n        net.add('2', FCLayer(1, 1), prevs='1')\n        net.add('2p', PoolingLayer(2, 1, 1), prevs=('1', '2'))\n        net.add('3', FCLayer(1, 1), prevs='0')\n        net.add('4', FCLayer(2, 1), prevs='2p')\n        net.add('4p', PoolingLayer(2, 1, 1), prevs=('3', '4'))\n        self.net[net.net_name] = net\n\n        net = Network('net9')\n        # Previous layers include input and others.\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(2, 1), prevs=(net.INPUT_LAYER_KEY, '0'))\n        self.net[net.net_name] = net\n\n        # Real networks.\n        for net_name in all_networks():\n            self.net[net_name] = import_network(net_name)\n\n        self.batch_size = 16\n\n        self.resource = Resource(\n            proc_region=NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(8, 8),\n                                   type=NodeRegion.PROC),\n            dram_region=NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(8, 8),\n                                   type=NodeRegion.DRAM),\n            src_data_region=NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(8, 4),\n                                       type=NodeRegion.DRAM),\n            dst_data_region=NodeRegion(origin=PhyDim2(0, 4), dim=PhyDim2(8, 4),\n                                       type=NodeRegion.DRAM),\n            dim_array=PhyDim2(16, 16), size_gbuf=65536, size_regf=64,\n            array_bus_width=float('inf'), dram_bandwidth=float('inf'),\n            no_time_mux=False)\n\n        part = PartitionScheme(order=range(pe.NUM), pdims=[(1, 1)] * pe.NUM)\n        self.ofmap_layout = DataLayout(\n            frngs=(FmapRange((0, 0, 0, 0), (2, 4, 16, 16)),),\n            regions=(NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(1, 1),\n                                type=NodeRegion.DRAM),),\n            parts=(part,))\n\n\n    def _make_ilp(self, network):\n        ''' Make an InterLayerPipeline instance. '''\n        return InterLayerPipeline(network, self.batch_size, self.resource)\n\n    def _make_segment(self, vseg, network, temporal=False, max_util_drop=None,\n                      with_opt=True):\n        ''' Convert vertex segment to (layer) segment. '''\n        kwargs = {}\n        if max_util_drop is not None:\n            kwargs['max_util_drop'] = max_util_drop\n        if not with_opt:\n            kwargs['with_opt'] = False\n        ilp = self._make_ilp(network)\n        seg = tuple(ilp.dag_vertex_list[vidx] for vidx in vseg)\n        if temporal:\n            seg = (sum(seg, tuple()),)\n        return PipelineSegment(seg, ilp.network, ilp.batch_size, ilp.resource,\n                               **kwargs)\n\n    def _make_sched_res(self, sched_seq, time, top_ti=1, top_to=1, top_tb=1,\n                        top_ord=range(le.NUM), dram_time=0, num_nodes=4):\n        scheme = OrderedDict()\n        scheme['cost'] = 1.234 + 9.876\n        scheme['time'] = max(time, dram_time)\n        scheme['num_nodes'] = num_nodes\n        scheme['proc_time'] = time\n        scheme['bus_time'] = 0\n        scheme['dram_time'] = dram_time\n        scheme['ti'] = [top_ti, 1, 1]\n        scheme['to'] = [top_to, 1, 1]\n        scheme['tb'] = [top_tb, 1, 1]\n        scheme['tvals'] = [[top_ti, top_to, top_tb], [1] * 3, [1] * 3]\n        scheme['orders'] = [top_ord, range(le.NUM), range(le.NUM)]\n        return SchedulingResult(scheme=scheme,\n                                ofmap_layout=self.ofmap_layout,\n                                sched_seq=sched_seq)\n\n    def _gen_all_segment(self, network, **kwargs):\n        '''\n        Generate all segments directly from all layers and all vertex segments.\n        '''\n        # pylint: disable=protected-access\n        ilp = self._make_ilp(network)\n        for layer in network:\n            yield PipelineSegment(((layer,),), ilp.network, ilp.batch_size,\n                                  ilp.resource)\n        for vseg in ilp._gen_vseg():\n            segment = self._make_segment(vseg, network, **kwargs)\n            if len(segment) == 1 and len(segment[0]) == 1:\n                continue\n            yield segment\n\n    def _validate_allocation(self, segment, allocation):\n        ''' Validate segment resource allocation. '''\n\n        # Match segment.\n        self.assertEqual(len(allocation), len(segment))\n        for ltpl, rtpl in zip(segment, allocation):\n            self.assertEqual(len(rtpl), len(ltpl))\n            self.assertTrue(all(isinstance(r, Resource) for r in rtpl))\n\n        # Number of nodes.\n        nodes = []  # number of nodes.\n        for rtpl in allocation:\n            nodes.append(rtpl[0].proc_region.dim.size())\n        self.assertEqual(sum(nodes), self.resource.proc_region.dim.size())\n\n        # Temporal schedules share processing region; spatial schedules use\n        # non-overlapped processing regions.\n        used_proc_nodes = set()  # used processing nodes\n        for rtpl in allocation:\n            proc_region = rtpl[0].proc_region\n            self.assertTrue(all(r.proc_region == proc_region for r in rtpl))\n            for n in proc_region.iter_node():\n                self.assertTrue(self.resource.proc_region.contains_node(n),\n                                '_validate_allocation: node {} outside of '\n                                'the processing region {}'\n                                .format(n, self.resource.proc_region))\n                self.assertNotIn(n, used_proc_nodes,\n                                 '_validate_allocation: node {} has been '\n                                 'used.'.format(n))\n                used_proc_nodes.add(n)\n\n        # Data liveness.\n        data_regions = {}  # layers that have data currently on-chip\n        for ltpl, rtpl in zip(segment, allocation):\n\n            for l, r in zip(ltpl, rtpl):\n\n                # Check data source.\n                prev_layers = segment.network.prevs(l)\n\n                for pl in prev_layers:\n                    if pl not in data_regions:\n                        # Previous layer is not on-chip, from memory.\n                        # Try find a layer responsible to fetch shared mem src.\n                        try:\n                            sh_sp_idx = next((i for i in range(len(allocation))\n                                              if allocation[i][0].proc_region\n                                              == r.src_data_region))\n                        except StopIteration:\n                            # No shared mem src.\n                            self.assertEqual(\n                                r.src_data_region,\n                                self.resource.src_data_region,\n                                '_validate_allocation: layer {}\\'s prev {} '\n                                'is not on-chip, should be from {}, but {}.'\n                                .format(l, pl, self.resource.src_data_region,\n                                        r.src_data_region))\n                        else:\n                            # There exists shared mem src.\n                            sh_l = segment[sh_sp_idx][0]\n                            self.assertEqual(segment.network.prevs(l),\n                                             segment.network.prevs(sh_l),\n                                             '_validate_allocation: layer {} '\n                                             'expects on-chip mem src sharing '\n                                             'with {}, but prevs differ.'\n                                             .format(l, sh_l))\n                    elif data_regions[pl] != r.proc_region:\n                        # Previous layer is on-chip and not local.\n                        self.assertEqual(\n                            r.src_data_region, data_regions[pl],\n                            '_validate_allocation: layer {}\\'s prev {} '\n                            'is on-chip, should be from {}, but {}.'\n                            .format(l, pl, data_regions[pl],\n                                    r.src_data_region))\n\n                # Update data based on destination.\n                # Local or store back to memory. Both will be available on-chip.\n                self.assertTrue(r.dst_data_region == r.proc_region\n                                or r.dst_data_region\n                                == self.resource.dst_data_region,\n                                '_validate_allocation: data can only '\n                                'be local or storing back to mem.')\n                # Overwrite.\n                local_node_set = set(r.proc_region.iter_node())\n                data_regions = {pl: data_regions[pl] for pl in data_regions\n                                if local_node_set.isdisjoint(\n                                    data_regions[pl].iter_node())}\n                data_regions[l] = r.proc_region\n\n    def _validate_constraint(self, segment, constraint):\n        ''' Validate segment scheduling constraint. '''\n        # pylint: disable=too-many-branches\n\n        # Match segment.\n        self.assertEqual(len(constraint), len(segment))\n        for ltpl, ctpl in zip(segment, constraint):\n            self.assertEqual(len(ctpl), len(ltpl))\n            self.assertTrue(all(isinstance(c, SchedulingConstraint)\n                                for c in ctpl))\n\n        # Same top tb.\n        top_tb = constraint[0][0].topbat\n        self.assertTrue(all(c.topbat == top_tb\n                            for ctpl in constraint for c in ctpl))\n\n        # Top tb is a factor of batch size.\n        if top_tb:\n            self.assertEqual((segment.batch_size) % top_tb, 0)\n\n        # Data availability.\n\n        seg_layers = set(l for ltpl in segment for l in ltpl)\n\n        class OutAccPat():\n            ''' Output data access pattern types. '''\n            # pylint: disable=too-few-public-methods\n            ANY = 0   # can access in any way\n            DBF = -1  # must double-buffer\n            # SEQ: use any positive value to represent sequential access with\n            # certain number of groups.\n\n        # Available data in each spatial subregions. Each is represented by a\n        # tuple of layer name and its output data access pattern.\n        avail_data = [(None, OutAccPat.ANY) for _ in segment]\n\n        # Get groups of layers sharing the same memory source.\n        prevs2layers = {}\n        for ltpl in segment:\n            l = ltpl[0]\n            prevs2layers.setdefault(segment.network.prevs(l), []).append(l)\n        sh_mem_src_groups = [ls for ps, ls in prevs2layers.items()\n                             if not seg_layers.intersection(ps) and len(ls) > 1]\n        sh_mem_src_topifms = [None] * len(sh_mem_src_groups)\n\n        # Whether to defer fully buffering output.\n        fb_out = False\n        fb_out_conv = None\n\n        for sp_idx, (ltpl, ctpl) in enumerate(zip(segment, constraint)):\n\n            self.assertFalse(fb_out,\n                             '_validate_constraint: deferring fully buffering '\n                             'from {} should not cross spatial scheduling {}.'\n                             .format(fb_out_conv, sp_idx - 1))\n\n            for tm_idx, (layer, cstr) in enumerate(zip(ltpl, ctpl)):\n\n                # Source data and their access patterns.\n                prev_layers = segment.network.prevs(layer)\n                prev_oaps = []\n                for pl in prev_layers:\n                    if pl not in seg_layers:\n                        # Off-chip sources.\n                        poap = OutAccPat.ANY\n                    elif pl in ltpl:\n                        # On-chip and local.\n                        self.assertEqual(avail_data[sp_idx][0], pl,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'local source data {} not available, '\n                                         'maybe not the immediate previous.'\n                                         .format(layer, (sp_idx, tm_idx), pl))\n                        poap = avail_data[sp_idx][1]\n                    else:\n                        # On-chip and neighbor.\n                        poap = next((avail_data[p_sp_idx][1]\n                                     for p_sp_idx in range(sp_idx)\n                                     if avail_data[p_sp_idx][0] == pl),\n                                    None)\n                        self.assertFalse(poap is None,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'neighbor source data {} not '\n                                         'available on-chip.'\n                                         .format(layer, (sp_idx, tm_idx), pl))\n                    prev_oaps.append(poap)\n                # Only buffer input if having source on-chip.\n                has_src = not seg_layers.isdisjoint(prev_layers)\n\n                # The single SEQ source.\n                seq = None\n                # str is greater than all numbers, see\n                # https://docs.python.org/2/library/stdtypes.html#comparisons\n                seq_prev_oaps = [poap for poap in prev_oaps \\\n                                 if isinstance(poap, str) or \\\n                                    (isinstance(poap, int) and poap > 0)]\n                if seq_prev_oaps:\n                    self.assertEqual(len(seq_prev_oaps), 1,\n                                     '_validate_constraint: layer {} ({}) '\n                                     'has multiple SEQ input.'\n                                     '\\nsrcs: {}, oaps: {}'\n                                     .format(layer, (sp_idx, tm_idx),\n                                             prev_layers, prev_oaps))\n                    seq = seq_prev_oaps[0]\n\n                # Destination data.\n                # Only buffer output if having destination on-chip.\n                next_layers = segment.network.nexts(layer)\n                has_dst = not seg_layers.isdisjoint(next_layers)\n\n                # Validation.\n\n                for g_idx, group in enumerate(sh_mem_src_groups):\n                    if layer in group:\n                        if sh_mem_src_topifms[g_idx] is None:\n                            sh_mem_src_topifms[g_idx] = cstr.topifm\n                        self.assertEqual(sh_mem_src_topifms[g_idx], cstr.topifm,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'share memory source with {}, but has '\n                                         'mismatched topifm {} with {}.'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 group, cstr.topifm,\n                                                 sh_mem_src_topifms[g_idx]))\n                        break\n                else:\n                    if not has_src:\n                        self.assertEqual(cstr.topifm, 0,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'should not constrain input as it '\n                                         'does not have on-chip sources.'\n                                         .format(layer, (sp_idx, tm_idx)))\n\n                if isinstance(segment.network[layer], ConvLayer):\n\n                    self.assertFalse(fb_out,\n                                     '_validate_constraint: deferring fully '\n                                     'buffering from {} has not been realized.'\n                                     .format(fb_out_conv))\n\n                    if any(pl in ltpl for pl in prev_layers):\n                        # Local source.\n                        lcl_poap = avail_data[sp_idx][1]\n                        self.assertIn(lcl_poap, (OutAccPat.DBF, OutAccPat.ANY),\n                                      '_validate_constraint: layer {} ({}) '\n                                      'local source data {} must fully '\n                                      'buffer output.'\n                                      .format(layer, (sp_idx, tm_idx),\n                                              lcl_poap))\n\n                    # DBF source.\n                    if OutAccPat.DBF in prev_oaps:\n                        # Must fully buffer CONV input.\n                        self.assertEqual(cstr.topifm, 1,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'input is not fully buffered but has '\n                                         'DBF source.\\nsrcs: {}, oaps: {}'\n                                         '\\n{}'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 prev_layers, prev_oaps,\n                                                 cstr))\n\n                    # SEQ source.\n                    if seq and has_dst:\n                        # Cannot be lazily updated.\n                        self.assertNotIsInstance(\n                            seq, str,\n                            '_validate_constraint: CONV layer {} ({}) cannot '\n                            'use lazy update (from {})'\n                            .format(layer, (sp_idx, tm_idx), seq))\n                        # Must match SEQ.\n                        self.assertEqual(cstr.topifm, seq,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'input groups ({}) and its SEQ src '\n                                         'output groups ({}) are mismatched.'\n                                         '\\nsrcs: {}, oaps: {}'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 cstr.topifm, seq,\n                                                 prev_layers, prev_oaps))\n                        # Also must fully buffer CONV output.\n                        self.assertEqual(cstr.topofm, 1,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'output is not fully buffered but has '\n                                         'SEQ source.\\nsrcs: {}, oaps: {}'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 prev_layers, prev_oaps))\n                        # Deferred apply to the last layer in the group.\n                        fb_out = True\n                        fb_out_conv = layer\n\n                    oap = None\n                    if cstr.topofm == 1:\n                        if cstr.topifm == 1:\n                            # Fully buffer both, can access output in any way.\n                            # This is fine as we require to buffer either input\n                            # or output for CONV (see below).\n                            oap = OutAccPat.ANY\n                        else:\n                            oap = OutAccPat.DBF\n                    elif has_dst and cstr.topofm > 0:\n                        oap = cstr.topofm\n                        if has_src:\n                            self.assertEqual(cstr.topifm, 1,\n                                             '_validate_constraint: layer {} '\n                                             '({}) has on-chip src and dst '\n                                             'but neither input nor output '\n                                             'are fully buffered.\\ncstr: {}.'\n                                             .format(layer, (sp_idx, tm_idx),\n                                                     cstr))\n                    elif has_dst:\n                        # Lazy update, record layer name as seq.\n                        oap = layer\n\n                else:\n\n                    # SEQ source.\n                    if seq and has_dst:\n                        # Must match SEQ, or fully buffer output.\n                        self.assertTrue(cstr.topofm == seq or cstr.topofm == 1\n                                        or seq in cstr.update_dict,\n                                        '_validate_constraint: layer {} ({}) '\n                                        'output is not fully buffered, and '\n                                        'groups ({}) and its SEQ src output '\n                                        'groups ({}) are mismatched, and '\n                                        'lazy update is not used.'\n                                        '\\nsrcs: {}, oaps: {}'\n                                        .format(layer, (sp_idx, tm_idx),\n                                                cstr.topofm, seq,\n                                                prev_layers, prev_oaps))\n\n                    if cstr.topofm == 1:\n                        # Fully buffer output.\n                        oap = OutAccPat.DBF\n                    elif isinstance(seq, str):\n                        # Lazy update.\n                        oap = seq\n                    else:\n                        # SEQ output.\n                        oap = cstr.topofm\n\n                # Realize deferred fully buffering output.\n                if cstr.topofm == 1:\n                    fb_out = False  # reset\n\n                # Overwrite the previous temporal scheduling.\n                avail_data[sp_idx] = (layer, oap)\nnn_dataflow/core/network.py\nclass Network():\n    '''\n    NN topology. Support DAG structure of layers.\n    '''\n\n    INPUT_LAYER_KEY = '__INPUT__'\n\n    def __init__(self, net_name):\n        self.net_name = net_name\n        self.layer_dict = OrderedDict()\n        self.prevs_dict = {}\n        self.nexts_dict = {}\n        self.ext_dict = OrderedDict()\n\n    def set_input_layer(self, input_layer):\n        '''\n        Set the input layer.\n        '''\n        if self.INPUT_LAYER_KEY in self.layer_dict:\n            raise KeyError('Network: only one input layer is allowed.')\n\n        if not isinstance(input_layer, InputLayer):\n            raise TypeError('Network: input_layer must be an InputLayer '\n                            'instance.')\n\n        self.layer_dict[self.INPUT_LAYER_KEY] = input_layer\n\n    def input_layer(self):\n        '''\n        Get the input layer.\n        '''\n        return self.layer_dict[self.INPUT_LAYER_KEY]\n\n    def add(self, layer_name, layer, prevs=None):\n        '''\n        Add a named layer, with optional previous layer(s).\n\n        If previous layer(s) is not given, assume it follows the last added\n        layer.\n        '''\n        if self.INPUT_LAYER_KEY not in self.layer_dict:\n            raise RuntimeError('Network: must first set input layer.')\n\n        if layer_name in self.layer_dict:\n            raise KeyError('Network: layer {} already exists.'\n                           .format(layer_name))\n\n        if not isinstance(layer, Layer):\n            raise TypeError('Network: layer must be a Layer instance.')\n\n        # First figure out previous layers.\n        if prevs:\n            # Ensure `prevs` as a tuple.\n            if isinstance(prevs, str):\n                prevs = (prevs,)\n            else:\n                prevs = tuple(prevs)\n            # Ensure previous layers are already added.\n            for p in prevs:\n                try:\n                    self.__getitem__(p)\n                except KeyError:\n                    raise KeyError('Network: given previous layer {} '\n                                   'has not been added to the network'.\n                                   format(p))\n        else:\n            prevs = (list(self.layer_dict.keys())[-1],)\n\n        self.layer_dict[layer_name] = layer\n        self.prevs_dict[layer_name] = prevs\n\n        # Ensure dimension matching between layers.\n        try:\n            self._check_prevs(layer_name)\n        except ValueError:\n            del self.layer_dict[layer_name]\n            del self.prevs_dict[layer_name]\n            raise\n\n        for p in prevs:\n            self.nexts_dict.setdefault(p, []).append(layer_name)\n\n    def add_ext(self, layer_name, layer):\n        '''\n        Add a named external layer.\n        '''\n        if layer_name in self.ext_dict:\n            raise KeyError('Network: external layer {} already exists.'\n                           .format(layer_name))\n\n        if not isinstance(layer, InputLayer):\n            raise TypeError('Network: external layer must be an InputLayer '\n                            'instance.')\n\n        self.ext_dict[layer_name] = layer\n\n    def prevs(self, layer_name):\n        '''\n        Get the previous layers of the given layer name.\n\n        Return a tuple of all the previous layer names. Use `None` to represent\n        the input layer in the returned tuple.\n        '''\n        if layer_name == self.INPUT_LAYER_KEY:\n            raise ValueError('Network: cannot get previous layers for '\n                             'input layer.')\n        if layer_name in self.ext_dict:\n            raise ValueError('Network: cannot get previous layers for '\n                             'external layers.')\n\n        prevs = tuple(None if p == self.INPUT_LAYER_KEY else p\n                      for p in self.prevs_dict[layer_name])\n        assert prevs\n\n        return prevs\n\n    def nexts(self, layer_name):\n        '''\n        Get the next layers of the given layer name, i.e., the layers that need\n        the output of this layer.\n\n        Return a tuple of all the next layer names. Use `None` to represent the\n        output of the last layer in the returned tuple.\n        '''\n        try:\n            nexts = tuple(self.nexts_dict[layer_name])\n        except KeyError:\n            nexts = tuple([None])\n        assert nexts\n\n        return nexts\n\n    def firsts(self):\n        '''\n        Get a tuple of the first layers, i.e., those with only the input layer\n        or external layers as their previous layers.\n\n        If a layer has other layers besides the input/external layers as its\n        previous layers, it does not count as a first layer.\n        '''\n        input_ext_layers = set([None]).union(self.ext_layers())\n        firsts = []\n        for layer_name in self:\n            prevs = self.prevs(layer_name)\n            if input_ext_layers.issuperset(prevs):\n                firsts.append(layer_name)\n        return tuple(firsts)\n\n    def lasts(self):\n        '''\n        Get a tuple of the last layers, i.e., those with no next layer.\n        '''\n        lasts = []\n        for layer_name in self:\n            nexts = self.nexts(layer_name)\n            if nexts == (None,):\n                lasts.append(layer_name)\n        return tuple(lasts)\n\n    def ext_layers(self):\n        '''\n        Get a tuple of the external layers.\n        '''\n        return tuple(self.ext_dict.keys())\n\n    def _check_prevs(self, layer_name):\n        '''\n        Check the previous layers of the given layer name.\n        '''\n        layer = self.layer_dict[layer_name]\n\n        prevs = self.prevs_dict[layer_name]\n        assert prevs\n\n        # Compare the ifmap dimensions of this layer, with all the ofmaps of\n        # the previous layers.\n        sum_nfmaps = 0\n\n        for p in prevs:\n            pl = self.__getitem__(p)\n\n            # Ensure fmap sizes match. Allow padding.\n            if not layer.is_valid_padding_sifm((pl.hofm, pl.wofm)):\n                raise ValueError('Network: {}, a previous layer of {}, '\n                                 'has mismatch fmap size: {} vs. {}.'\n                                 .format(p, layer_name,\n                                         (pl.hofm, pl.wofm),\n                                         (layer.hofm, layer.wofm)))\n\n            sum_nfmaps += pl.nofm\n\n        if sum_nfmaps != layer.nifm:\n            raise ValueError('Network: {} cannot be the previous layers of {}.'\n                             .format(' | '.join(prevs), layer_name))\n\n    def __contains__(self, layer_name):\n        ''' Whether the network contains a layer. '''\n        return layer_name in self.layer_dict or layer_name in self.ext_dict\n\n    def __len__(self):\n        ''' Number of layers in the network. '''\n        if self.INPUT_LAYER_KEY not in self.layer_dict:\n            assert not self.layer_dict\n            return 0\n        return len(self.layer_dict) - 1\n\n    def __iter__(self):\n        ''' Iterate through layer names. '''\n        for layer_name in self.layer_dict.keys():\n            if layer_name == self.INPUT_LAYER_KEY:\n                continue\n            yield layer_name\n\n    def __getitem__(self, layer_name):\n        ''' Get the layer by name. '''\n        try:\n            return self.layer_dict[layer_name]\n        except KeyError:\n            try:\n                return self.ext_dict[layer_name]\n            except KeyError as e:\n                raise KeyError('Network: {} layer not found.'.format(str(e)))\n\n    def __str__(self):\n        str_ = 'Network: {}\\n'.format(self.net_name)\n        for layer_name in self:\n            prevs = self.prevs(layer_name)\n            prev_str = ' | '.join(['None' if n is None else n for n in prevs])\n            str_ += '  Layer {} <- {}\\n'.format(layer_name, prev_str)\n        return str_\nnn_dataflow/core/layer.py\nclass ConvLayer(Layer):\n    '''\n    NN convolutional layer parameters.\n\n    nifm (C): # ifmap channels\n    nofm (M): # ofmap channels\n    hifm, wifm (H): ifmap height/width\n    hofm, wofm (E): ofmap height/width\n    hfil, wfil (R): weight filter width/height\n    htrd, wtrd (U): stride height/width\n    '''\n\n    def __init__(self, nifm, nofm, sofm, sfil, strd=1):\n        super(ConvLayer, self).__init__(nofm, sofm, strd=strd)\n\n        if isinstance(sfil, int):\n            hfil = sfil\n            wfil = sfil\n        elif len(sfil) == 2:\n            hfil = sfil[0]\n            wfil = sfil[1]\n        else:\n            raise ValueError('ConvLayer: sfil is invalid ({}), '\n                             'needs to be either one integer or '\n                             'a pair of integers'.format(sfil))\n\n        self.hfil = hfil\n        self.wfil = wfil\n\n        hifm = self.hfil + (self.hofm - 1) * self.htrd\n        wifm = self.wfil + (self.wofm - 1) * self.wtrd\n        self.inlayer = Layer(nifm, (hifm, wifm))\n\n    @staticmethod\n    def data_loops():\n        dls = [None] * de.NUM\n        dls[de.FIL] = DataDimLoops(le.IFM, le.OFM)\n        dls[de.IFM] = DataDimLoops(le.IFM, le.BAT)\n        dls[de.OFM] = DataDimLoops(le.OFM, le.BAT)\n        return tuple(dls)\n\n    def input_layer(self):\n        return self.inlayer\n\n    def ops_per_neuron(self):\n        # 2D convolution across all ifmap channels.\n        return self.hfil * self.wfil * self.nifm\n\n    def filter_size(self, word_size=1):\n        '''\n        Get size of one weight filter.\n\n        If `word_size` is set to word byte size, return size in bytes.\n        '''\n        return self.hfil * self.wfil * word_size\n\n    def total_filter_size(self, word_size=1):\n        '''\n        Get total size of all weight filters.\n\n        If `word_size` is set to word byte size, return size in bytes.\n        '''\n        return self.nifm * self.nofm * self.filter_size(word_size)\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'nifm={}'.format(repr(self.nifm)),\n                'nofm={}'.format(repr(self.nofm)),\n                'sofm={}'.format(repr((self.hofm, self.wofm))),\n                'sfil={}'.format(repr((self.hfil, self.wfil))),\n                'strd={}'.format(repr((self.htrd, self.wtrd)))]))\nnn_dataflow/core/layer.py\nclass FCLayer(ConvLayer):\n    '''\n    NN fully-connected layer parameters.\n\n    As a special case of CONVLayer.\n\n    hifm = hfil, wifm = wfil, strd = 1, hofm = wofm = 1\n    '''\n\n    def __init__(self, nifm, nofm, sfil=1):\n        super(FCLayer, self).__init__(nifm, nofm, 1, sfil)\n        assert self.hofm == 1 and self.wofm == 1\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'nifm={}'.format(repr(self.nifm)),\n                'nofm={}'.format(repr(self.nofm)),\n                'sfil={}'.format(repr((self.hfil, self.wfil)))]))\nnn_dataflow/core/inter_layer_pipeline.py\nclass InterLayerPipeline():\n    '''\n    Inter-layer pipeline.\n    '''\n\n    def __init__(self, network, batch_size, resource, max_util_drop=0.05):\n        if not isinstance(network, Network):\n            raise TypeError('InterLayerPipeline: network must be '\n                            'a Network instance.')\n        if not isinstance(resource, Resource):\n            raise TypeError('InterLayerPipeline: resource must be '\n                            'a Resource instance.')\n        if not 0 <= max_util_drop <= 1:\n            raise ValueError('InterLayerPipeline: max_util_drop must be '\n                             'between [0, 1].')\n\n        self.network = network\n        self.batch_size = batch_size\n        self.resource = resource\n        self.max_util_drop = max_util_drop\n\n        self._calc_sched_dag()\n\n        # Vertices starting from which we have generated the segments.\n        self.seg_vertex_done = set()\n\n    def ordered_layer_list(self):\n        '''\n        Get a list of the layers in their topological order in the scheduling\n        DAG.\n        '''\n        return list(sum(self.dag_vertex_list, tuple()))\n\n    def gen_segment(self, options):\n        '''\n        Generate all valid inter-layer pipelining segments.\n        '''\n\n        kwargs = {'network': self.network,\n                  'batch_size': self.batch_size,\n                  'resource': self.resource,\n                  'max_util_drop': self.max_util_drop,\n                  'with_opt': options.layer_pipeline_opt,\n                 }\n\n        # No pipelining, each layer sequentially occupies the whole resource.\n        for layer in self.network:\n            seg = ((layer,),)\n            segment = PipelineSegment(seg, **kwargs)\n            assert segment.valid\n            yield segment\n\n        # Pipelining.\n        for vseg in self._gen_vseg():\n\n            if len(vseg) > options.layer_pipeline_max_degree:\n                continue\n\n            if len(vseg) == 1 and len(self.dag_vertex_list[vseg[0]]) == 1:\n                # An individual layer, already returned in no-pipelining case.\n                continue\n\n            # Use set to eliminate duplicates.\n            seg_cands = set()\n\n            if options.partition_interlayer:\n                # Spatial pipelining.\n                seg = tuple(self.dag_vertex_list[vidx] for vidx in vseg)\n                seg_cands.add(seg)\n\n            if options.hw_gbuf_save_writeback:\n                # Temporal pipelining.\n                # Reduce the spatial dimension.\n                seg = (tuple(itertools.chain.from_iterable(\n                    self.dag_vertex_list[vidx] for vidx in vseg)),)\n                seg_cands.add(seg)\n\n            # Determine segment allocation.\n            for seg in seg_cands:\n                segment = PipelineSegment(seg, **kwargs)\n                if segment.valid:\n                    yield segment\n\n    def _gen_vseg(self, vertex_idx=0, done=None):\n        '''\n        Generate vertex segments starting from vertex `vertex_idx`. Yield a\n        tuple of the vertices in the segment.\n\n        `done` is a set of vertices which have already been scheduled and the\n        output is already in memory.\n\n        Rules:\n\n        1. If a vertex does not share any dependencies with the current\n        segment, i.e., none of its previous vertices is in the current segment\n        or among the previous vertices of the current segment, we do not add it\n        to the segment, because there is no benefit to co-locate them.\n\n        2. If a vertex has multiple previous vertices, at most one of them\n        can be in the same segment as this vertex, because the output data\n        availability timing of multiple previous vertices may not match.\n\n        3. If a vertex has multiple next vertices, either all or at most one of\n        them can be NOT in the same segment as this vertex, because only\n        including a small subset saves little data write-back to memory.\n        '''\n\n        vseg = tuple()\n\n        if not done:\n            done = set()\n            # Reset.\n            self.seg_vertex_done = set()\n\n        if self.dag_input_vertex not in done:\n            # Input layer is always in memory.\n            done.add(self.dag_input_vertex)\n\n        # The frontier is the vertex to be considered to be added to the\n        # current segment.\n        for frontier in range(vertex_idx, len(self.dag_vertex_list)):\n\n            # Check whether the frontier can be added to the current segment.\n\n            frontier_prevs = self.dag_prev_dict[frontier]\n\n            # Whether the frontier share dependencies with the current segment,\n            # if the segment is not empty.\n            share_deps = not vseg or not frontier_prevs.isdisjoint(\n                set.union(set(vseg), *[self.dag_prev_dict[i] for i in vseg]))\n\n            # Whether multiple previous vertices are in the current segment.\n            multi_prevs = len(frontier_prevs.intersection(vseg)) > 1\n\n            if not share_deps or multi_prevs:\n                # Not sharing any dependencies (rule 1), or multiple previous\n                # vertices in the current segment (rule 2).\n\n                # Make sure the current segment is not empty.\n                assert vseg\n                # Not extend the segment any more. Note that the current\n                # segment has already been yielded, as well as the recursion,\n                # in the last iteration.\n                break\n\n            # Extend the segment.\n            vseg += (frontier,)\n\n            # Check whether the segment is valid.\n\n            for idx in vseg:\n                nexts = self.dag_next_dict[idx]\n\n                # The next vertices should either all or at most one not in the\n                # segment (rule 3).\n                if not nexts.isdisjoint(vseg) \\\n                        and len(nexts.difference(vseg)) > 1:\n                    # The segment is invalid. Need to add more vertices.\n                    break\n            else:\n                # The segment is valid.\n                yield vseg\n\n                # Skip if have done.\n                if frontier + 1 in self.seg_vertex_done:\n                    continue\n\n                # Recursion.\n                for tpl in self._gen_vseg(frontier + 1, done.union(vseg)):\n                    yield tpl\n\n        assert vertex_idx not in self.seg_vertex_done\n        self.seg_vertex_done.add(vertex_idx)\n\n    def _calc_sched_dag(self):\n        '''\n        Build the scheduling DAG of the network. We merge layers with no\n        filters into their last previous layer, so a DAG vertex can contain one\n        or more layers.\n\n        We order and index the DAG vertices in their depth-first topological\n        order. This will also be the order to schedule the layers.\n\n        Also establish two dicts for the previous and next vertices of each DAG\n        vertex.\n\n        In summary, the attributes initialized include: `dag_input_vertex`,\n        `dag_vertex_list`, `dag_vertex_dict`, `dag_prev_dict`, `dag_next_dict`.\n        '''\n\n        # Vertex of the input layer.\n        self.dag_input_vertex = -1\n\n        # The DAG vertex set. Each vertex is a merged layer tuples, represented\n        # by their layer names. Use a list type to make modification easier.\n        dag_vertex_set = []\n\n        for layer_name in self.network:\n            layer = self.network[layer_name]\n\n            if isinstance(layer, ConvLayer):\n                dag_vertex_set.append((layer_name,))\n\n            else:\n                prevs = set(self.network.prevs(layer_name))\n                assert prevs\n\n                # Find and merge to a vertex if that vertex only contains one\n                # previous layer at the last, because non-last previous layer\n                # will not have its data available to be used for this layer.\n                # Also the previous layer can only have this one next layer,\n                # because its data will be overwritten by this layer locally.\n\n                # Check vertices in the reversed order.\n                for idx in reversed(range(len(dag_vertex_set))):\n                    vhead = dag_vertex_set[idx][:-1]\n                    vtail = dag_vertex_set[idx][-1]\n                    if prevs.isdisjoint(vhead) and vtail in prevs \\\n                            and len(self.network.nexts(vtail)) == 1:\n                        dag_vertex_set[idx] += (layer_name,)\n                        break\n                else:\n                    # No valid vertex to merge.\n                    dag_vertex_set.append((layer_name,))\n\n        assert sum(len(v) for v in dag_vertex_set) == len(self.network)\n\n        # The DAG vertex list in the topological order.\n        self.dag_vertex_list = self._topological_order(dag_vertex_set)\n\n        # Make a directory from layer name to DAG vertex index.\n        self.dag_vertex_dict = {}\n\n        for vidx, v in enumerate(self.dag_vertex_list):\n            for layer_name in v:\n                assert layer_name not in self.dag_vertex_dict\n                self.dag_vertex_dict[layer_name] = vidx\n\n        # Add the input layer.\n        self.dag_vertex_dict[self.network.INPUT_LAYER_KEY] = \\\n                self.dag_input_vertex\n        # Add the external layers.\n        for ext_layer in self.network.ext_layers():\n            self.dag_vertex_dict[ext_layer] = self.dag_input_vertex\n\n        # The previous and next relationship of the DAG vertices.\n        self.dag_prev_dict = dict((vidx, set()) for vidx\n                                  in range(len(self.dag_vertex_list)))\n        self.dag_next_dict = dict((vidx, set()) for vidx\n                                  in range(len(self.dag_vertex_list)))\n\n        for layer_name in self.network:\n            vidx = self.dag_vertex_dict[layer_name]\n\n            # Previous layers.\n            for p in self.network.prevs(layer_name):\n                pvidx = self.dag_vertex_dict[p] \\\n                        if p and p not in self.network.ext_layers() \\\n                        else self.dag_input_vertex\n                if pvidx != vidx:\n                    self.dag_prev_dict[vidx].add(pvidx)\n\n            # Next layers.\n            for n in self.network.nexts(layer_name):\n                if not n:\n                    continue\n                nvidx = self.dag_vertex_dict[n]\n                if nvidx != vidx:\n                    self.dag_next_dict[vidx].add(nvidx)\n\n        # Add next layers of the input layer.\n        self.dag_next_dict[self.dag_input_vertex] = set()\n        for vidx in self.dag_prev_dict:\n            if self.dag_input_vertex in self.dag_prev_dict[vidx]:\n                self.dag_next_dict[self.dag_input_vertex].add(vidx)\n\n    def _topological_order(self, dag_vertex_set):\n        '''\n        Order the DAG vertices in topological order using DFS.\n\n        Specifically, The backtrace order of the depth-first search is the\n        inverse of the topological order. See\n        https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search\n        '''\n\n        # The visited layers in the DFS order.\n        visited = []\n        # The unseen pending layers.\n        unseen = set(dag_vertex_set)\n        # The layers that have been seen, but not visited due to unvisited\n        # previous layers.\n        seen = set()\n\n        def _dfs(vertex):\n            assert vertex not in seen\n            if vertex in visited:\n                return\n\n            unseen.discard(vertex)\n            seen.add(vertex)\n\n            nexts = []\n            for l in vertex:\n                for n in self.network.nexts(l):\n                    if n and n not in vertex and n not in nexts:\n                        nexts.append(n)\n\n            # Visit next layers in the reversed order, so the reversed visit\n            # order has the original order.\n            next_vertices = []\n            for n in reversed(nexts):\n                for nv in unseen:\n                    if n in nv:\n                        next_vertices.append(nv)\n\n            for nv in next_vertices:\n                _dfs(nv)\n\n            visited.append(vertex)\n            seen.remove(vertex)\n\n        # Start from the first layers.\n        start_vertices = []\n        for l in reversed(self.network.firsts()):\n            for v in unseen:\n                if l in v:\n                    start_vertices.append(v)\n        for v in start_vertices:\n            _dfs(v)\n        assert not unseen\n        assert not seen\n\n        return list(reversed(visited))\nnn_dataflow/core/layer.py\nclass InputLayer(Layer):\n    '''\n    NN input layer parameters.\n    '''\n\n    @staticmethod\n    def data_loops():\n        dls = [None] * de.NUM\n        dls[de.FIL] = DataDimLoops()\n        dls[de.IFM] = DataDimLoops()\n        dls[de.OFM] = DataDimLoops(le.OFM, le.BAT)\n        return tuple(dls)\n\n    def input_layer(self):\n        return None\n\n    def ops_per_neuron(self):\n        return 0\nnn_dataflow/core/pipeline_segment.py\nclass PipelineSegment():\n    '''\n    Inter-layer pipeline segment.\n\n    Segment is a two-level layer hierarchy, where the first level is spatially\n    scheduled and the second level is temporally scheduled.\n    '''\n\n    # pylint: disable=too-many-instance-attributes\n\n    # Scheduling index in the segment, as a tuple of spatial and temporal\n    # scheduling indices.\n    SchedIndex = namedtuple('SchedIndex', ['sp_idx', 'tm_idx'])\n\n    def __init__(self, seg, network, batch_size, resource, max_util_drop=0.05,\n                 with_opt=True):\n        if not isinstance(seg, tuple):\n            raise TypeError('PipelineSegment: seg must be a tuple.')\n        for ltpl in seg:\n            if not isinstance(ltpl, tuple):\n                raise TypeError('PipelineSegment: seg must be a tuple '\n                                'of sub-tuples.')\n\n        if not isinstance(network, Network):\n            raise TypeError('PipelineSegment: network must be '\n                            'a Network instance.')\n        if not isinstance(resource, Resource):\n            raise TypeError('PipelineSegment: resource must be '\n                            'a Resource instance.')\n\n        self.seg = seg\n        self.network = network\n        self.batch_size = batch_size\n        self.resource = resource\n        self.max_util_drop = max_util_drop\n        self.with_opt = with_opt\n\n        self.valid = self._init_deps()\n        if not self.valid:\n            return\n\n        # Resource allocation.\n        self.valid = self._alloc_resource(max_util_drop=max_util_drop)\n        if not self.valid:\n            return\n\n        # Scheduling constraints.\n        self.valid = self._init_sym_cstrs()\n        if not self.valid:\n            return\n\n    def allocation(self):\n        '''\n        Get resource allocation, as a tuple of sub-tuples corresponding to the\n        layers in the segment.\n        '''\n        if not self.valid:\n            return None\n        return self.alloc\n\n    def gen_constraint(self, max_time_overhead=float('inf')):\n        '''\n        Generate scheduling constraint for the segment, as a tuple of\n        sub-tuples of SchedulingConstraint instances, corresponding to the\n        layers in the segment.\n\n        Yield the segment constraint tuple, and hints for pruning.\n\n        Pruning hints are the top-level loop blocking factors. Smaller hints\n        indicate better (lower) cost, and larger hints indicate better segment\n        timing (with lower time overhead). Constraints with smaller hints are\n        generated before those with larger hints. So if a constraint results in\n        a valid scheduling, the later ones with all hints larger than its can\n        be pruned.\n        '''\n        syms = self.cstr_symvals.keys()\n        vals = self.cstr_symvals.values()\n        assert syms and vals\n\n        # Sort from small to large.\n        # This is not a strict ordering, but we guarantee that if all values in\n        # hint A are larger than the corresponding values in hint B, A will be\n        # generated after B.\n        vals = [sorted(v) for v in vals]\n        syms = list(syms)\n\n        if self.cstr_topbat_idx is not None:\n            # Tovhd =  (1 + 1/to + 1 + 1/to + ...) / tb\n            #       >= (1 + 1 + ...) / tb = num_sp_fbs / tb\n            min_topbat = 1. * self.cstr_num_sp_fbs / max_time_overhead\n            pos = self.cstr_topbat_idx\n            vals[pos] = [t for t in vals[pos] if t >= min_topbat]\n\n        for valp in itertools.product(*vals):\n\n            constraint = tuple()\n\n            for atpl in self._subs_symargs(self.cstr_symargs,\n                                           tuple(zip(syms, valp))):\n                ctpl = tuple()\n                for a in atpl:\n                    # Construct kwargs, adjust the types of the values.\n                    kwargs = {}\n                    kwargs['topbat'] = int(a.get('topbat', 0))\n                    kwargs['fbifm'] = bool(a.get('fbifm', False))\n                    if not kwargs['fbifm']:\n                        kwargs['topifm'] = int(a.get('topifm', 0))\n                    kwargs['fbofm'] = bool(a.get('fbofm', False))\n                    if not kwargs['fbofm']:\n                        kwargs['topofm'] = int(a.get('topofm', 0))\n                    kwargs['update_dict'] = a.get('update_dict')\n\n                    c = Cstr(**kwargs)\n                    ctpl += (c,)\n                constraint += (ctpl,)\n\n            if None in valp:\n                assert len(valp) == 1\n                hints = (1,)\n            else:\n                hints = tuple(valp)\n\n            yield constraint, hints\n\n    def __getitem__(self, index):\n        return self.seg[index]\n\n    def __iter__(self):\n        return self.seg.__iter__()\n\n    def __len__(self):\n        return len(self.seg)\n\n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            # pylint: disable=protected-access\n            return self._key_attrs() == other._key_attrs()\n        return NotImplemented\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash(tuple(self._key_attrs()))\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'seg={}'.format(repr(self.seg)),\n                'network={}'.format(repr(self.network)),\n                'batch_size={}'.format(repr(self.batch_size)),\n                'resource={}'.format(repr(self.resource)),\n                'max_util_drop={}'.format(repr(self.max_util_drop)),\n                'with_opt={}'.format(repr(self.with_opt))]))\n\n    def _key_attrs(self):\n        ''' Used for comparison. '''\n        return (self.seg, self.network, self.batch_size, self.resource,\n                self.max_util_drop, self.with_opt)\n\n    def _init_deps(self):\n        '''\n        Initialize the dependency relationship of the layers in the segment as\n        a mapping of the scheduling indices, and check validation. Return\n        whether the segment is valid to schedule.\n\n        We categorize dependencies to 3 categories:\n        - local: with the same spatial index but different temporal indices;\n        - neighbor: with different spatial indices but in the same segment;\n        - memory: in different segments, from/to memory.\n\n        The values of the src/dst dicts are tuples of indices of the neighbor\n        dependencies. A layer can have at most one neighbor source (must be a\n        last temporal scheduled layer), but may have multiple neighbor\n        destinations (could be temporal scheduled in the middle). Also, all\n        layers with the same spatial index can have at most one neighbor\n        source.\n\n        Special index `None` means memory dependency, i.e., from/to memory.\n        Memory sources and neighbor sources must be mutual exclusive, in order\n        to correctly set the src data regions; memory destinations and neighbor\n        destinations can co-exist.\n\n        Local dependencies are omitted, as by default each layer has its\n        immediately previous layer as local source and immediately next layer\n        as local destination.\n\n        Construct an ifmap forwarding dict for shared memory source data. It\n        maps previous layer name tuples, to a list of scheduling indices of all\n        layers in this segment that share these exact previous layers. The\n        first in the list is responsible to fetch the previous layer data and\n        to forward them to others. We allow shared memory source data between\n        two layers only when both layers have memory dependency only (so their\n        temporal indices must be 0), and their previous layers are exactly the\n        same.\n\n        Construct an ofmap forwarding dict for multiple destinations of both\n        on-chip and off-chip. It maps the scheduling index of a layer in this\n        segment that has both memory and neighbor/local destinations (so needs\n        to store its ofmaps back to memory), to a list of scheduling indices of\n        all layers in this segment that accepts its ofmaps as ifmaps. Neighbor\n        dependencies are only between the last temporal one and the first\n        temporal ones; local dependencies are only between adjacent temporal\n        ones.\n        '''\n\n        self.src_dict = [[None for _ in ltpl] for ltpl in self.seg]\n        self.dst_dict = [[None for _ in ltpl] for ltpl in self.seg]\n\n        self.ifm_fwd_dict = {}\n        self.ofm_fwd_dict = {}\n\n        # Mapping from layer to spatial/temporal indices in the segment.\n        layer2idx = {l: PipelineSegment.SchedIndex(sp_idx, tm_idx)\n                     for sp_idx, ltpl in enumerate(self.seg)\n                     for tm_idx, l in enumerate(ltpl)}\n\n        # Mapping from previous layer tuple to layer.\n        prevs2layer = {}\n\n        for sp_idx, ltpl in enumerate(self.seg):\n\n            single_nbr_src = None\n\n            for tm_idx, l in enumerate(ltpl):\n\n                assert layer2idx[l] == (sp_idx, tm_idx)\n\n                # Sources.\n                src = tuple()\n\n                prevs = self.network.prevs(l)\n                assert all(p not in layer2idx or layer2idx[p] < layer2idx[l]\n                           for p in prevs)\n                mem_src = [p for p in prevs if p not in layer2idx]\n                lcl_src = [p for p in prevs if p not in mem_src\n                           and layer2idx[p].sp_idx == sp_idx]\n                nbr_src = [p for p in prevs if p not in mem_src + lcl_src]\n\n                # Ensure single local source to be the immediately previous.\n                # Check at the destination so here are assertions.\n                if not lcl_src:\n                    assert tm_idx == 0\n                else:\n                    assert len(lcl_src) == 1 \\\n                            and layer2idx[lcl_src[0]].tm_idx == tm_idx - 1\n\n                # Mutual exclusive.\n                if mem_src and nbr_src:\n                    # We now allow each spatial scheduling (vertex) to have\n                    # both memory source and neighbor source when generating\n                    # segments. But each single layer cannot have both;\n                    # otherwise there would be multiple source data regions.\n                    return False\n\n                if mem_src:\n                    # Memory source.\n                    src += (None,)\n                if nbr_src:\n                    # Neighbor source.\n                    # Single neighbor source to be the last temporal scheduled.\n                    assert len(nbr_src) == 1\n                    prev_idx = layer2idx[nbr_src[0]]\n                    assert prev_idx.tm_idx == len(self.seg[prev_idx.sp_idx]) - 1\n                    # Single neighbor source across this spatial scheduling.\n                    if single_nbr_src is not None:\n                        return False\n                    single_nbr_src = prev_idx\n                    src += (prev_idx,)\n\n                # Shared memory source.\n                if mem_src and not lcl_src:\n                    assert not nbr_src\n                    assert tm_idx == 0\n                    if prevs in prevs2layer:\n                        fet_idx = layer2idx[prevs2layer[prevs]]\n                        self.ifm_fwd_dict.setdefault(prevs, [fet_idx]).append(\n                            layer2idx[l])\n                    else:\n                        prevs2layer[prevs] = l\n\n                # Destinations.\n                dst = tuple()\n\n                nexts = self.network.nexts(l)\n                assert all(n not in layer2idx or layer2idx[n] > layer2idx[l]\n                           for n in nexts)\n                mem_dst = [n for n in nexts if n not in layer2idx]\n                lcl_dst = [n for n in nexts if n not in mem_dst\n                           and layer2idx[n].sp_idx == sp_idx]\n                nbr_dst = [n for n in nexts if n not in mem_dst + lcl_dst]\n\n                # Ensure single local destination to be the immediate next.\n                if not lcl_dst:\n                    if tm_idx != len(ltpl) - 1:\n                        # Not utilize local data, sub-optimal.\n                        return False\n                else:\n                    if len(lcl_dst) != 1 \\\n                            or layer2idx[lcl_dst[0]].tm_idx != tm_idx + 1:\n                        # Local data will not be available if not adjacent.\n                        return False\n\n                # Mutual exclusive.\n                # Now they can co-exist.\n                # assert not mem_dst or not nbr_dst\n                if mem_dst and nbr_dst:\n                    assert tm_idx == len(ltpl) - 1\n                    self.ofm_fwd_dict[layer2idx[l]] = [layer2idx[n]\n                                                       for n in nbr_dst]\n                if mem_dst and lcl_dst:\n                    assert not nbr_dst\n                    self.ofm_fwd_dict[layer2idx[l]] = [layer2idx[lcl_dst[0]]]\n\n                if mem_dst:\n                    # Memory destination.\n                    dst += (None,)\n                if nbr_dst:\n                    # Neighbor destinations.\n                    # This layer is the last temporal scheduled.\n                    assert tm_idx == len(ltpl) - 1\n                    dst += tuple(layer2idx[n] for n in nbr_dst)\n\n                # Basic pipelining requires a linear structure (on-chip).\n                if not self.with_opt:\n                    if len(nbr_src) + len(lcl_src) > 1 \\\n                            or len(nbr_dst) + len(lcl_dst) > 1 \\\n                            or ((sp_idx, tm_idx) != (0, 0)\n                                    and not nbr_src and not lcl_src):\n                        return False\n\n                self.src_dict[sp_idx][tm_idx] = src\n                self.dst_dict[sp_idx][tm_idx] = dst\n\n        return True\n\n    def _alloc_resource(self, max_util_drop=0.05):\n        '''\n        Decide the resource allocation. Return whether the allocation succeeds.\n\n        `max_util_drop` specifies the maximum utilization drop due to mismatch\n        throughput between layers.\n        '''\n\n        self.alloc = tuple()\n\n        # Allocate processing subregions.\n        subregions = self._alloc_proc(max_util_drop=max_util_drop)\n        if not subregions:\n            return False\n\n        no_time_mux = len(self.network) == sum(len(ltpl) for ltpl in self.seg)\n        # All layers that have model filters must be spatially scheduled.\n        if no_time_mux:\n            for ltpl in self.seg:\n                if len([l for l in ltpl\n                        if isinstance(self.network[l], ConvLayer)]) > 1:\n                    no_time_mux = False\n                    break\n\n        for sp_idx, ltpl in enumerate(self.seg):\n\n            # Resource for the subregion.\n            rtpl = tuple()\n\n            for tm_idx, _ in enumerate(ltpl):\n\n                # Processing region.\n                proc_region = subregions[sp_idx]\n\n                # Data source.\n                src = self.src_dict[sp_idx][tm_idx]\n                if None in src:\n                    # Data source is memory.\n                    assert src == (None,)\n                    src_data_region = self.resource.src_data_region\n                    for sh_idx_list in self.ifm_fwd_dict.values():\n                        # Find shared memory source to use forwarding.\n                        if (sp_idx, tm_idx) in sh_idx_list[1:]:\n                            src_data_region = subregions[sh_idx_list[0].sp_idx]\n                            break\n                elif src:\n                    # Data source is neighbor.\n                    assert len(src) == 1\n                    src_data_region = subregions[src[0].sp_idx]\n                else:\n                    # Data source is all local.\n                    src_data_region = proc_region\n\n                # Data destination.\n                dst = self.dst_dict[sp_idx][tm_idx]\n                if None in dst:\n                    # Data destination is memory.\n                    # assert dst == (None,)\n                    # Now we can have both memory and neighbor destinations. If\n                    # they co-exist, we need to store them locally and also\n                    # store back to memory. In this case the dst data region is\n                    # set to memory.\n                    dst_data_region = self.resource.dst_data_region\n                elif dst:\n                    # Data destinations are neighbors.\n                    # Put data in local. The next layers will fetch.\n                    dst_data_region = proc_region\n                else:\n                    # Data destination is all local.\n                    dst_data_region = proc_region\n\n                # Make resource.\n                # Note that DRAM bandwidth is not split here. We optimistically\n                # assume each layer can use the full DRAM bandwidth at\n                # different time. We adjust this assumption when calculating\n                # the segment timing.\n                rtpl += (self.resource._replace(\n                    proc_region=proc_region,\n                    src_data_region=src_data_region,\n                    dst_data_region=dst_data_region,\n                    no_time_mux=no_time_mux),)\n\n            assert len(rtpl) == len(ltpl)\n            self.alloc += (rtpl,)\n        assert len(self.alloc) == len(self.seg)\n\n        return True\n\n    def _alloc_proc(self, max_util_drop=0.05):\n        '''\n        Allocate processing subregions for the segment.\n\n        Return a list of processing subregions corresponding to the first-level\n        (spatial scheduled) layers in the segment. Return None if allocation\n        failed.\n\n        `max_util_drop` specifies the maximum utilization drop due to mismatch\n        throughput between layers.\n        '''\n\n        # Spatial allocation.\n        proc_region = self.resource.proc_region\n        dim_nodes = proc_region.dim\n        total_nodes = dim_nodes.size()\n\n        # Number of operations of each spatial allocation.\n        ops = [sum(self.network[l].total_ops() for l in ltpl)\n               for ltpl in self.seg]\n\n        # Enforce a common factor among the numbers of nodes allocated to all\n        # vertices in the segment. Such common factor is likely to be the\n        # common height of the vertex node regions.\n        common_factor_list = [cf for cf, _ in util.factorize(dim_nodes.h, 2)]\n\n        for cf in sorted(common_factor_list, reverse=True):\n            # Pick the largest common factor within the utilization constraint.\n\n            # Number of nodes of each vertex should be approximate to the\n            # number of ops of the vertex.\n            nodes_raw = [o * 1. / sum(ops) * total_nodes for o in ops]\n\n            # Round to the common factor multiples.\n            assert total_nodes % cf == 0\n            nodes = [max(1, int(round(nr / cf))) * cf for nr in nodes_raw]\n            # Fix margin.\n            while sum(nodes) != total_nodes:\n                diff = [n - nr for n, nr in zip(nodes, nodes_raw)]\n                if sum(nodes) > total_nodes:\n                    # Decrease the nodes for the vertex with the maximum\n                    # positive difference.\n                    idx, _ = max(enumerate(diff), key=lambda tpl: tpl[1])\n                    nodes[idx] -= cf\n                else:\n                    # Increase the nodes for the vertex with the minimum\n                    # negative difference.\n                    idx, _ = min(enumerate(diff), key=lambda tpl: tpl[1])\n                    nodes[idx] += cf\n\n            if 0 in nodes:\n                continue\n\n            # Utilization.\n            time = max(o * 1. / n for o, n in zip(ops, nodes))\n            utilization = sum(ops) / time / sum(nodes)\n            assert utilization < 1 + 1e-6\n\n            if utilization >= 1 - max_util_drop:\n                # Found\n                break\n\n        else:\n            # Not found.\n            return None\n\n        # Allocate in the processing region according to the number of nodes.\n        subregions = proc_region.allocate(nodes)\n        assert subregions\n        assert len(subregions) == len(self.seg)\n        if len(subregions) == 1:\n            assert subregions[0] == proc_region\n\n        return subregions\n\n    def _init_sym_cstrs(self):\n        '''\n        Initialize the symbolic scheduling constraints for the layers in the\n        segment, by constructing a nested lists of dicts `cstr_symargs` whose\n        values can be symbolic expressions for the keyword arguments of layers\n        in the segment, and a dict `cstr_symvals` mapping each symbol to its\n        possible numerical values.\n\n        Rules for constraints.\n\n        - Top BAT loop factor.\n\n        With a single layer, there is no constraint on the top BAT loop factor.\n        Otherwise all layers must share the same factor, namely `topbat_shr`.\n\n        - Fmap forwarding and fully buffering.\n\n        Only CONV layers require to fully buffer fmaps. Local-region layers\n        process data in a streaming manner.\n\n        Each CONV layer, and all local-region layers immediately following it\n        within the same spatial scheduling, are made into a group G.\n\n        (initial) if G is both the first spatial and the first temporal\n        scheduling with a CONV layer, it can choose whether to fully buffer\n        ofmaps or not. This is a configuration to explore, namely `fbofm_init`.\n        We decide its value by choosing the one that gives the fewer fully\n        buffered inter-spatial pairs on the critical forwarding path, and the\n        smaller maximum fully buffered data size.\n\n        (within-group) within G, the CONV layer, and all local-region layers,\n        should use the same top OFM factors (IFM factors are automatically\n        determined by OFM factors in local-region layers), unless CONV ofmaps\n        need to be fully buffered, in which case, the CONV layer and the last\n        layer in G fully buffer ofmaps (top OFM factor is 1), and other layers\n        still use the same top OFM factors but can be different than 1.\n\n        (inter-temporal) if G has a source from G' in the same spatial\n        scheduling (which must be immediately before G), G should fully buffer\n        ifmaps, and G' should fully buffer ofmaps.\n\n        (inter-spatial) if G has a source from G' in another spatial scheduling\n        (where the source must be the last temporal scheduling in G' and that\n        spatial scheduling),\n        (a) if G' already fully buffers ofmaps, make G fully buffer ifmaps.\n        (b) otherwise, make G fully buffer ofmaps (do not require G' to fully\n            buffer ifmaps; leave it to other rules, e.g. inter-temporal, to\n            decide); forward data between G' and G, by matching their top O/IFM\n            factors (biasing this case for smaller pipeline filling delay).\n        Notice the destination can be: (1) the leading CONV layer, whose top\n        IFM factor is constrained; (2) a local-region layer, where we constrain\n        the top OFM factors of this group (except otherwise constrained by\n        fully buffering ofmaps).\n        '''\n        # pylint: disable=too-many-branches\n\n        # Symbolic variables mapping to numerical values.\n        symvals = dict()\n\n        # Top BAT loop factor.\n        topbat = symbols('topbat_shr', integer=True)\n        symvals[topbat] = [t for t, _ in util.factorize(self.batch_size, 2)]\n\n        # Whether the initial CONV layer fully buffers ofmaps.\n        fbofm_init = symbols('fbofm_init')\n        symvals[fbofm_init] = [False, True]\n\n        def _layer_topofm_vals(layer_name):\n            layer = self.network[layer_name]\n            # We require that the total ofmap size takes at least 5% of the\n            # gbuf capacity of a single node, to avoid too fine blocking.\n            tmax = layer.total_ofmap_size(self.batch_size) \\\n                    / (0.05 * self.resource.size_gbuf)\n            vals = [t for t, _ in util.factorize(layer.nofm, 2)\n                    if t <= tmax or t == 1]\n            assert vals\n            return vals\n\n        def _layer_topifm_vals(layer_name):\n            layer = self.network[layer_name]\n            # We require that the total ifmap size takes at least 5% of the\n            # gbuf capacity of a single node, to avoid too fine blocking.\n            tmax = layer.total_ifmap_size(self.batch_size) \\\n                    / (0.05 * self.resource.size_gbuf)\n            vals = [t for t, _ in util.factorize(layer.nifm, 2)\n                    if t <= tmax or t == 1]\n            assert vals\n            return vals\n\n        # Layer constraint kwargs.\n        symargs = [[{'topbat': topbat} for _ in ltpl] for ltpl in self.seg]\n\n        # Candidates for critical forwarding path between spatial scheduling.\n        sp_crit_path_cands = set()\n        sp_crit_path_cands.add((0,))  # init with the first spatial.\n\n        # The last CONV layer index.\n        last_conv = PipelineSegment.SchedIndex(-1, 0)\n\n        # Whether the current group needs to fully buffer ofmap. Delayed apply\n        # to the last layer in the group.\n        curr_fbofm = False\n\n        for sp_idx, ltpl in enumerate(self.seg):\n\n            # Initial topofm, in case of a non-CONV starting layer.\n            curr_topofm = symbols('topofm_{}_s'.format(sp_idx), integer=True)\n            symvals[curr_topofm] = _layer_topofm_vals(ltpl[0])\n\n            for tm_idx, l in enumerate(ltpl):\n\n                layer = self.network[l]\n                curr_sa = symargs[sp_idx][tm_idx]\n\n                # Neighbor source dependency.\n                nsrc_sa = None\n                src_deps = self.src_dict[sp_idx][tm_idx]\n                if any(s is not None for s in src_deps):\n                    assert len(src_deps) == 1\n                    nbr_src = src_deps[0]\n                    assert nbr_src.sp_idx < sp_idx\n                    nsrc_sa = symargs[nbr_src.sp_idx][nbr_src.tm_idx]\n                    assert nsrc_sa  # not empty, used to test nbr src exists.\n                    # Set critical path candidates.\n                    new_cands = set()\n                    for cand in sp_crit_path_cands:\n                        if cand[-1] == nbr_src.sp_idx:\n                            new_cands.add(cand + (sp_idx,))\n                    sp_crit_path_cands |= new_cands\n\n                if isinstance(layer, ConvLayer):\n                    # Conv layer.\n\n                    # The last group may require to fully buffer ofmaps.\n                    # Delayed apply to the immediate previous layer.\n                    if curr_fbofm is not False:\n                        assert last_conv >= (0, 0)\n                        if last_conv.sp_idx == sp_idx:\n                            assert tm_idx > 0\n                            lsrc_sa = symargs[sp_idx][tm_idx - 1]\n                        else:\n                            lsrc_sa = symargs[last_conv.sp_idx][-1]\n                        lsrc_sa['fbofm'] = curr_fbofm\n                    # Reset.\n                    curr_fbofm = False\n\n                    # New topofm for a new group.\n                    curr_topofm = symbols('topofm_{}_{}'.format(sp_idx, tm_idx),\n                                          integer=True)\n                    symvals[curr_topofm] = _layer_topofm_vals(l)\n\n                    # Set topofm.\n                    curr_sa['topofm'] = curr_topofm\n\n                    if sp_idx == last_conv.sp_idx:\n                        # Rule inter-temporal.\n                        assert tm_idx > 0\n                        # Make this group fully buffer ifmaps.\n                        curr_sa['fbifm'] = True\n                        # Make the last group fully buffer ofmaps.\n                        last_sa = symargs[sp_idx][last_conv.tm_idx]\n                        lsrc_sa = symargs[sp_idx][tm_idx - 1]\n                        last_sa['fbofm'] = True\n                        lsrc_sa['fbofm'] = True\n\n                    elif nsrc_sa:\n                        # Rule inter-spatial.\n                        # We only look at this rule when inter-temporal rule\n                        # does not apply and the ifmaps of this group are not\n                        # yet required to fully buffer.\n                        if not self.with_opt:\n                            # Basic pipelining requires fully buffering all\n                            # pairs of neighbor src/dst.\n                            nsrc_sa['fbofm'] = True\n                        nsrc_fbofm = nsrc_sa.get('fbofm', False)\n                        # (a): if the source already fully buffers ofmaps.\n                        # Make this group fully buffer ifmaps.\n                        curr_sa['fbifm'] = symeq(nsrc_fbofm, True)\n                        # (b)-(1): otherwise.\n                        # Make this group fully buffer ofmaps.\n                        curr_sa['fbofm'] = symeq(nsrc_fbofm, False)\n                        curr_fbofm = symeq(nsrc_fbofm, False)  # delayed apply.\n                        # Match top OFM/IFM factors.\n                        curr_sa['topifm'] = sympiecewise(\n                            (nsrc_sa['topofm'], symeq(nsrc_fbofm, False)),\n                            (curr_sa.get('topifm', 0), True))\n\n                    elif last_conv < (0, 0):\n                        # The first CONV layer.\n                        # Rule initial.\n                        curr_sa['fbofm'] = fbofm_init\n                        curr_fbofm = fbofm_init\n\n                    last_conv = PipelineSegment.SchedIndex(sp_idx, tm_idx)\n\n                else:\n                    # Non-Conv layer.\n\n                    if nsrc_sa:\n                        # Rule inter-spatial, (b)-(2).\n                        nsrc_fbofm = nsrc_sa.get('fbofm', False)\n                        curr_topofm = sympiecewise(\n                            (nsrc_sa['topofm'], symeq(nsrc_fbofm, False)),\n                            (curr_topofm, True))\n                        # Also backtrace this group.\n                        for bt_idx in range(last_conv.tm_idx, tm_idx):\n                            symargs[sp_idx][bt_idx]['topofm'] = curr_topofm\n\n                    # Rule within-group.\n                    curr_sa['topofm'] = curr_topofm\n\n                # If this layer has no on-chip destinations, cancel the\n                # requirement to fully buffer ofmaps.\n                if all(d is None for d in self.dst_dict[sp_idx][tm_idx]) \\\n                        and tm_idx == len(ltpl) - 1:\n                    curr_sa.pop('fbofm', False)\n\n        # Simplify.\n        self._simplify_symargs(symargs, symvals)\n\n        # Get critical forwarding path between spatial scheduling.\n        # The critical path has the longest forwarding chain.\n        sp_crit_path = max(sp_crit_path_cands, key=len)\n\n        # Check maximum fully-buffering size, and decide fbofm_init.\n        opt_val = None\n        opt_key = (float('inf'),) * 2  # (num of fb pairs, max fb size)\n        num_sp_fbs = 0\n        for val in symvals.get(fbofm_init, [False]):\n            subs_symargs = self._subs_symargs(symargs, fbofm_init, val)\n            maxsz = 0\n            numfb = 0\n            for sp_idx, (ltpl, atpl) in enumerate(zip(self.seg, subs_symargs)):\n                ms = max(itertools.chain(\n                    ((self.network[l].total_ofmap_size() if a.get('fbofm')\n                      else 0)\n                     + (self.network[l].total_ifmap_size() if a.get('fbifm')\n                        else 0)\n                     for l, a in zip(ltpl, atpl)),\n                    [0]))  # safe max with default.\n                if ms > self.alloc[sp_idx][0].proc_region.dim.size() \\\n                        * self.alloc[sp_idx][0].size_gbuf:\n                    break\n                maxsz = max(maxsz, ms)\n                if sp_idx in sp_crit_path and atpl[-1].get('fbofm', False):\n                    numfb += 1\n            else:\n                key = (numfb, maxsz)\n                if key < opt_key:\n                    opt_val, opt_key = val, key\n                    num_sp_fbs = numfb\n        if opt_val is None:\n            return False\n        # Use the optimal value.\n        symvals[fbofm_init] = [opt_val]\n        self._simplify_symargs(symargs, symvals)\n\n        # Shared memory source must have the same topifm.\n        for sh_idx_list in self.ifm_fwd_dict.values():\n            assert len(sh_idx_list) > 1\n            fet_sp_idx = sh_idx_list[0].sp_idx\n            sh_symarg_list = [symargs[idx.sp_idx][0] for idx in sh_idx_list]\n\n            # Must have no constraint on ifmaps access from memory.\n            assert all(not sa.get('fbifm', False) and not sa.get('topifm', 0)\n                       for sa in sh_symarg_list)\n\n            # Cannot constrain both topifm and topofm.\n            if any(sa.get('fbofm', False) or sa.get('topofm', 0)\n                   for sa in sh_symarg_list):\n                sh_kwargs = {'fbifm': True}\n            else:\n                topifm = symbols('topifm_{}'.format(fet_sp_idx), integer=True)\n                symvals[topifm] = _layer_topifm_vals(self.seg[fet_sp_idx][0])\n                sh_kwargs = {'topifm': topifm}\n\n            # Set constraints.\n            for sa in sh_symarg_list:\n                sa.update(sh_kwargs)\n\n        # Simplify.\n        self._simplify_symargs(symargs, symvals)\n\n        # Turn constraints into lazily updated rules.\n        self._lazify_topofm_symargs(symargs, symvals)\n        # Cannot simplify any more as update_dict is not sympifi-able.\n\n        # Sort symbol dict.\n        symvals = OrderedDict(sorted(((s, symvals[s]) for s in symvals),\n                                     key=lambda item: str(item[0])))\n\n        if not symvals:\n            # Must add a dummy symbol so iterative substitution can happen.\n            symvals[symbols('_dummy')] = [None]\n\n        self.cstr_symargs = symargs\n        self.cstr_symvals = symvals\n        self.cstr_num_sp_fbs = num_sp_fbs\n        try:\n            self.cstr_topbat_idx = list(symvals.keys()).index(topbat)\n        except ValueError:\n            self.cstr_topbat_idx = None\n\n        return True\n\n    @staticmethod\n    def _simplify_symargs_one_pass(symargs, symvals):\n        '''\n        Simplify symargs and symvals in-place:\n        - If fbi/ofm is False, then remove it.\n        - If fbi/ofm is True, then remove topi/ofm.\n        - If a symbol can take only one value, then substitute it.\n        - If a symbol only occurs once, then remove its constraint.\n\n        Return whether the symargs and symvals are already simplified.\n        '''\n        for a in itertools.chain.from_iterable(symargs):\n            is_fbifm = a.get('fbifm')\n            is_fbofm = a.get('fbofm')\n            # pylint: disable=singleton-comparison\n            # lhs may be symbolic, see\n            # docs.sympy.org/latest/modules/logic.html#sympy.logic.boolalg.BooleanTrue\n            if is_fbifm == True:\n                a.pop('topifm', 0)\n            if is_fbifm == False:\n                a.pop('fbifm', False)\n            if is_fbofm == True:\n                a.pop('topofm', 0)\n            if is_fbofm == False:\n                a.pop('fbofm', False)\n\n        subs_dict = {}\n\n        # Possible values for symbols.\n        subs_dict.update(\n            (s, symvals[s][0]) for s in symvals if len(symvals[s]) == 1)\n\n        # Count the occurrence of symbols in all args (values).\n        symcnts = Counter(\n            s for a in itertools.chain.from_iterable(symargs)\n            for val in a.values() for s in symtuple(val).free_symbols)\n        assert set(symcnts.keys()).issubset(symvals.keys())\n        subs_dict.update((s, None)\n                         for s in set(symvals.keys()) - set(symcnts.keys()))\n        subs_dict.update((s, 0 if str(s).startswith('top') else False)\n                         for s in symcnts if symcnts[s] <= 1)\n\n        # Substitute symbols and remove from symbol dict.\n        for a in itertools.chain.from_iterable(symargs):\n            for k in a:\n                a[k] = symtuple(a[k]).subs(subs_dict)[0]\n        for s in subs_dict:\n            del symvals[s]\n\n        return not subs_dict\n\n    def _simplify_symargs(self, symargs, symvals):\n        ''' Simplify symargs and symvals in-place iteratively. '''\n        while not self._simplify_symargs_one_pass(symargs, symvals):\n            pass\n        used_syms = symtuple(\n            *[symtuple(*a.values())\n              for a in itertools.chain.from_iterable(symargs)]).free_symbols\n        assert set(used_syms) == set(symvals.keys())\n        assert all(val for val in symvals.values())\n\n    @staticmethod\n    def _subs_symargs(symargs, *subs_args):\n        '''\n        Substitute symbols. The additional arguments are passed to subs().\n\n        Return a new substituted copy without modifying the original one.\n        '''\n        # sympify=False is necessary because there may be str in the values.\n        return [[dict((k, symtuple(a[k], sympify=False).subs(*subs_args)[0])\n                      for k in a) for a in atpl] for atpl in symargs]\n\n    class TopOfmUpdateLambda(symbasic):\n        ''' A sympifi-able lambda function to lazily update topofm. '''\n        # pylint: disable=no-init\n        def __new__(cls, *args):\n            return super(PipelineSegment.TopOfmUpdateLambda, cls).__new__(cls)\n        def __call__(self, arg_s, arg_r):\n            setattr(arg_s, 'topofm', arg_r.scheme['to'][0])\n\n    def _lazify_topofm_symargs(self, symargs, symvals):\n        '''\n        Turn qualified topofm constraints into lazily updated rules.\n\n        If a symbol is only used as the topofm constraint by a single CONV\n        layer and some local-region layers, we can turn it into a lazily update\n        rule.\n        '''\n        sym2conv = {}  # symbol --> the only CONV layer using it.\n        sym2lrs = {}   # symbol --> list of local-region layer using it.\n        unqual_syms = set()  # symbols used by two or more CONV layers.\n        for l, a in zip(itertools.chain.from_iterable(self.seg),\n                        itertools.chain.from_iterable(symargs)):\n            layer = self.network[l]\n            if isinstance(layer, ConvLayer):\n                topofm = a.get('topofm', 0)\n                topifm = a.get('topifm', 0)\n                for s in symtuple(topofm, topifm).free_symbols:\n                    if s not in unqual_syms:\n                        if s in sym2conv:\n                            # If a symbol is used in two CONV layers, it cannot\n                            # be lazily updated.\n                            del sym2conv[s]\n                            sym2lrs.pop(s, [])\n                            unqual_syms.add(s)\n                        elif topofm == s:\n                            assert s not in sym2lrs\n                            sym2conv[s] = l\n            else:\n                topofm = a.get('topofm', 0)\n                if topofm in sym2conv:\n                    sym2lrs.setdefault(topofm, []).append(l)\n        assert 0 not in sym2conv and 0 not in sym2lrs\n\n        syms = sym2conv.keys()  # symbols to be lazily updated.\n        lr2conv = {}  # local-region layer to the CONV layer constraining it.\n        for s in syms:\n            for lr in sym2lrs.get(s, []):\n                lr2conv[lr] = sym2conv[s]\n        lconvs = set(lr2conv.values())  # CONV layer whose topofm to be removed.\n\n        for l, a in zip(itertools.chain.from_iterable(self.seg),\n                        itertools.chain.from_iterable(symargs)):\n            if l in lconvs:\n                # Remove CONV topofm.\n                assert sym2conv[a['topofm']] == l\n                del a['topofm']\n            elif l in lr2conv:\n                # Link local-region layer to the CONV layer.\n                lconv = lr2conv[l]\n                assert sym2conv[a['topofm']] == lconv\n                del a['topofm']\n                a['update_dict'] = {\n                    lconv: PipelineSegment.TopOfmUpdateLambda()}\n\n        for s in syms:\n            del symvals[s]\nnn_dataflow/core/option.py\nclass Option(namedtuple('Option', OPTION_LIST)):\n    '''\n    Schedule options.\n    '''\n\n    def __new__(cls, *args, **kwargs):\n\n        if len(args) > len(OPTION_LIST):\n            raise TypeError('Option: can take at most {} arguments ({} given).'\n                            .format(len(OPTION_LIST), len(args)))\n\n        if not set(kwargs).issubset(OPTION_LIST):\n            raise TypeError('Option: got an unexpected keyword argument {}.'\n                            .format(next(k for k in kwargs\n                                         if k not in OPTION_LIST)))\n\n        # Combine args and kwargs.\n        kwdict = kwargs.copy()\n        for k, v in zip(OPTION_LIST, args):\n            if k in kwdict:\n                raise TypeError('Option: got multiple values for '\n                                'keyword argument {}.'\n                                .format(k))\n            kwdict[k] = v\n\n        kwdict.setdefault('sw_gbuf_bypass', (False,) * de.NUM)\n        kwdict.setdefault('sw_solve_loopblocking', False)\n        kwdict.setdefault('hw_access_forwarding', False)\n        kwdict.setdefault('hw_gbuf_sharing', False)\n        kwdict.setdefault('hw_gbuf_save_writeback', False)\n        kwdict.setdefault('partition_hybrid', False)\n        kwdict.setdefault('partition_batch', False)\n        kwdict.setdefault('partition_ifmaps', False)\n        kwdict.setdefault('partition_interlayer', False)\n        kwdict.setdefault('layer_pipeline_time_ovhd', float('inf'))\n        kwdict.setdefault('layer_pipeline_max_degree', float('inf'))\n        kwdict.setdefault('layer_pipeline_opt', True)\n        kwdict.setdefault('opt_goal', 'e')\n        kwdict.setdefault('ntops', 1)\n        kwdict.setdefault('nprocesses', 1)\n        kwdict.setdefault('verbose', False)\n\n        assert set(kwdict) == set(OPTION_LIST)\n\n        ntp = super(Option, cls).__new__(cls, **kwdict)\n\n        if not isinstance(ntp.sw_gbuf_bypass, tuple):\n            raise TypeError('Option: sw_gbuf_bypass must be a tuple')\n        if len(ntp.sw_gbuf_bypass) != de.NUM:\n            raise ValueError('Option: sw_gbuf_bypass must have length {}'\n                             .format(de.NUM))\n\n        if ntp.sw_solve_loopblocking and ntp.hw_gbuf_sharing:\n            raise ValueError('Option: sw_solve_loopblocking and '\n                             'hw_gbuf_sharing cannot be simultaneously '\n                             'enabled.')\n\n        if ntp.hw_access_forwarding and ntp.hw_gbuf_sharing:\n            raise ValueError('Option: hw_access_forwarding is implied by '\n                             'hw_gbuf_sharing, thus cannot be both enabled.')\n\n        if ntp.sw_solve_loopblocking and ntp.hw_gbuf_save_writeback:\n            raise ValueError('Option: sw_solve_loopblocking and '\n                             'hw_gbuf_save_writeback cannot be simultaneously '\n                             'enabled.')\n\n        if ntp.partition_ifmaps and not ntp.partition_hybrid:\n            raise ValueError('Option: partition_ifmaps requires '\n                             'partition_hybrid to be set.')\n\n        if not isinstance(ntp.layer_pipeline_time_ovhd, (int, float)):\n            raise KeyError('Option: layer_pipeline_time_ovhd must be a '\n                           'number.')\n        if ntp.layer_pipeline_time_ovhd < 0:\n            raise ValueError('Option: layer_pipeline_time_ovhd must be '\n                             'positive.')\n\n        if not isinstance(ntp.layer_pipeline_max_degree, (int, float)):\n            raise KeyError('Option: layer_pipeline_max_degree must be a '\n                           'number.')\n        if ntp.layer_pipeline_max_degree < 0:\n            raise ValueError('Option: layer_pipeline_max_degree must be '\n                             'positive.')\n\n        if ntp.opt_goal not in ['e', 'd', 'ed']:\n            raise ValueError('Option: opt_goal is invalid, must be one of '\n                             '\\'e\\', \\'d\\', and \\'ed\\'.')\n\n        return ntp\n\n    @staticmethod\n    def option_list():\n        ''' List of options. '''\n        return OPTION_LIST\nnn_dataflow/core/layer.py\nclass PoolingLayer(LocalRegionLayer):\n    '''\n    NN pooling layer parameters.\n\n    As a special case of LocalRegionLayer.\n\n    nreg = ntrd = 1\n    '''\n\n    def __init__(self, nofm, sofm, sreg, strd=None):\n        if strd is None:\n            strd = sreg\n        super(PoolingLayer, self).__init__(nofm, sofm, 1, sreg,\n                                           ntrd=1, strd=strd)\n        assert self.nreg == 1\n        assert self.ntrd == 1\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'nofm={}'.format(repr(self.nofm)),\n                'sofm={}'.format(repr((self.hofm, self.wofm))),\n                'sreg={}'.format(repr((self.hreg, self.wreg))),\n                'strd={}'.format(repr((self.htrd, self.wtrd)))]))\nnn_dataflow/core/phy_dim2.py\nclass PhyDim2(namedtuple('PhyDim2', ['h', 'w'])):\n    '''\n    Denote a physical 2D dimension.\n    '''\n\n    def size(self):\n        ''' Total size. '''\n        return int(reduce(mul, self, 1))\n\n    def hop_dist(self, other):\n        ''' Hop distance between twn coordinate. '''\n        if not isinstance(other, PhyDim2):\n            raise TypeError('PhyDim2: hop_dist only applies on two PhyDim2 '\n                            'instances.')\n        return abs(self.h - other.h) + abs(self.w - other.w)\n\n    def __add__(self, other):\n        ''' Return element-wise `self + other`. '''\n        if not isinstance(other, PhyDim2):\n            other = PhyDim2(other, other)\n        return PhyDim2(*map(add, self, other))\n\n    def __sub__(self, other):\n        ''' Return element-wise `self - other`. '''\n        if not isinstance(other, PhyDim2):\n            other = PhyDim2(other, other)\n        return PhyDim2(*map(sub, self, other))\n\n    def __neg__(self):\n        ''' Return element-wise negative. '''\n        return PhyDim2(*map(neg, self))\n\n    def __mul__(self, other):\n        ''' Return element-wise `self * other`. '''\n        if not isinstance(other, PhyDim2):\n            other = PhyDim2(other, other)\n        return PhyDim2(*map(mul, self, other))\n\n    __rmul__ = __mul__\n", "answers": ["        ilp = InterLayerPipeline(self.net['net1'], self.batch_size,"], "length": 9020, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "2aae57de553ed5867969af9a6dd8f670c380c829b2abf753"}
{"input": "import logging\nimport operator\nimport pytest\nfrom bloop.conditions import ConditionRenderer\nfrom bloop.exceptions import InvalidModel, InvalidStream\nfrom bloop.models import (\n    BaseModel,\n    Column,\n    GlobalSecondaryIndex,\n    IMeta,\n    Index,\n    LocalSecondaryIndex,\n    bind_column,\n    bind_index,\n    model_created,\n    object_modified,\n    unbind,\n    unpack_from_dynamodb,\n)\nfrom bloop.types import (\n    UUID,\n    Boolean,\n    DateTime,\n    Integer,\n    String,\n    Timestamp,\n    Type,\n)\nfrom ..helpers.models import User, VectorModel\n\n\n\n\n\noperations = [\n    (operator.ne, \"!=\"),\n    (operator.eq, \"==\"),\n    (operator.lt, \"<\"),\n    (operator.le, \"<=\"),\n    (operator.gt, \">\"),\n    (operator.ge, \">=\")\n]\n\n\n@pytest.fixture\ndef unpack_kwargs(engine):\n    return {\n        \"attrs\": {\"name\": {\"S\": \"numberoverzero\"}},\n        \"expected\": {User.name, User.joined},\n        \"model\": User,\n        \"engine\": engine,\n        \"context\": {\"engine\": engine, \"extra\": \"foo\"},\n    }\n\n\n# BASE MODEL =============================================================================================== BASE MODEL\n\n\ndef test_default_model_init():\n    \"\"\"Missing attributes are set to `None`\"\"\"\n    user = User(id=\"user_id\", email=\"user@domain.com\")\n    assert user.id == \"user_id\"\n    assert user.email == \"user@domain.com\"\n    assert not hasattr(user, \"name\")\n\n\ndef test_load_default_init(engine):\n    \"\"\"The default model loader uses cls.__new__(cls) method\"\"\"\n    init_called = False\n\n", "context": "bloop/types.py\nclass Boolean(Type):\n    python_type = bool\n    backing_type = BOOLEAN\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\nbloop/models.py\nclass IMeta:\nclass BaseModel:\n    class Meta(IMeta):\nclass Index:\nclass GlobalSecondaryIndex(Index):\nclass LocalSecondaryIndex(Index):\nclass Column(ComparisonMixin):\n    class UNBOUND:\n        class Meta(IMeta):\n    def __init__(self, **attrs):\n    def __init_subclass__(cls: type, **kwargs):\n    def __repr__(self):\n    def __init__(self, *, projection, hash_key=None, range_key=None, dynamo_name=None, **kwargs):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\n    def hash_key(self):\n    def range_key(self):\n    def keys(self):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __init__(\n            self, *, projection,\n            hash_key, range_key=None,\n            read_units=None, write_units=None,\n            dynamo_name=None, **kwargs):\n    def __init__(self, *, projection, range_key, dynamo_name=None, strict=True, **kwargs):\n    def hash_key(self):\n    def read_units(self):\n    def read_units(self, value):\n    def write_units(self):\n    def write_units(self, value):\n    def __init__(self, typedef, hash_key=False, range_key=False, dynamo_name=None, default=missing):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\ndef subclassof(obj, classinfo):\ndef instanceof(obj, classinfo):\ndef loaded_columns(obj: BaseModel):\ndef unpack_from_dynamodb(*, attrs, expected, model=None, obj=None, engine=None, context=None, **kwargs):\ndef validate_projection(projection):\ndef validate_stream(meta):\ndef validate_encryption(meta):\ndef validate_backups(meta):\ndef validate_billing(meta):\ndef validate_ttl(meta):\ndef unbound_repr(obj):\ndef setdefault(obj, field, default):\ndef ensure_hash(cls) -> None:\ndef initialize_meta(cls: type):\ndef bind_column(model, name, column, force=False, recursive=False, copy=False) -> Column:\ndef bind_index(model, name, index, force=False, recursive=True, copy=False) -> Index:\ndef refresh_index(meta, index) -> None:\ndef unbind(meta, name=None, dynamo_name=None) -> None:\nbloop/types.py\nclass Integer(Number):\n    \"\"\"Truncates values when loading or dumping.\n\n    For example, ``3.14`` in DynamoDB is loaded as ``3``. If a value is ``7.5``\n    locally, it's stored in DynamoDB as ``7``.\n    \"\"\"\n    python_type = int\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        number = super().dynamo_load(value, context=context, **kwargs)\n        return int(number)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = int(value)\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/exceptions.py\nclass InvalidModel(BloopException, ValueError):\n    \"\"\"This is not a valid Model.\"\"\"\nbloop/types.py\nclass DateTime(String):\n    \"\"\"Always stored in DynamoDB using the :data:`~bloop.types.FIXED_ISO8601_FORMAT` format.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(DateTime)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import DateTime  # becomes:\n            from bloop.ext.pendulum import DateTime\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        dt = datetime.datetime.strptime(value, FIXED_ISO8601_FORMAT)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return dt.replace(tzinfo=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        dt = value.astimezone(tz=datetime.timezone.utc)\n        return dt.strftime(FIXED_ISO8601_FORMAT)\nbloop/exceptions.py\nclass InvalidStream(BloopException, ValueError):\n    \"\"\"This is not a valid stream definition.\"\"\"\nbloop/types.py\nclass UUID(String):\n    python_type = uuid.UUID\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return uuid.UUID(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return str(value)\ntests/helpers/models.py\nclass VectorModel(BaseModel):\n    name = Column(String, hash_key=True)\n    list_str = Column(List(String))\n    set_str = Column(Set(String))\n    map_nested = Column(Map(**{\n        \"bytes\": Binary,\n        \"str\": String,\n        \"map\": Map(**{\n            \"int\": Integer,\n            \"str\": String\n        })\n    }))\n    some_int = Column(Integer)\n    some_bytes = Column(Binary)\nbloop/types.py\nclass Type:\n    \"\"\"Abstract base type.\"\"\"\n\n    python_type = None\n    backing_type = None\n\n    def supports_operation(self, operation: str) -> bool:\n        \"\"\"\n        Used to ensure a conditional operation is supported by this type.\n\n        By default, uses a hardcoded table of operations that maps to each backing DynamoDB type.\n\n        You can override this method to implement your own conditional operators, or to dynamically\n        adjust which operations your type supports.\n        \"\"\"\n        return operation in OPERATION_SUPPORT_BY_TYPE[self.backing_type]\n\n    def __init__(self):\n        if not hasattr(self, \"inner_typedef\"):\n            self.inner_typedef = self\n        super().__init__()\n\n    def __getitem__(self, key):\n        raise RuntimeError(f\"{self!r} does not support document paths\")\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        \"\"\"Converts a local value into a DynamoDB value.\n\n        For example, to store a string enum as an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors.index(value.lower())\n        \"\"\"\n        raise NotImplementedError\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        \"\"\"Converts a DynamoDB value into a local value.\n\n        For example, to load a string enum from an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors[value]\n        \"\"\"\n        raise NotImplementedError\n\n    def _dump(self, value, **kwargs):\n        \"\"\"Entry point for serializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_dump`.\n\n        This wraps the return value of :func:`~bloop.types.Type.dynamo_dump` in DynamoDB's wire format.\n        For example, serializing a string enum to an int:\n\n        .. code-block:: python\n\n            value = \"green\"\n            # dynamo_dump(\"green\") = 2\n            _dump(value) == {\"N\": 2}\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_dump`.  This can happen when dumping eg. a sparse\n        :class:`~.bloop.types.Map`, or a missing (not set) value.\n        \"\"\"\n        wrapped = actions.wrap(value)\n        value = self.dynamo_dump(wrapped.value, **kwargs)\n        if value is None:\n            return actions.wrap(None)\n        else:\n            value = {self.backing_type: value}\n            return wrapped.type.new_action(value)\n\n    def _load(self, value, **kwargs):\n        \"\"\"Entry point for deserializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_load`.\n\n        This unpacks DynamoDB's wire format and calls :func:`~bloop.types.Type.dynamo_load` on the inner value.\n        For example, deserializing an int to a string enum:\n\n        .. code-block:: python\n\n            value = {\"N\": 2}\n            # dynamo_load(2) = \"green\"\n            _load(value) == \"green\"\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_load`.  This can happen when loading eg. a sparse :class:`~bloop.types.Map`.\n        \"\"\"\n        if value is not None:\n            value = next(iter(value.values()))\n        return self.dynamo_load(value, **kwargs)\n\n    def __repr__(self):\n        # Render class python types by name\n        python_type = self.python_type\n        if isinstance(python_type, type):\n            python_type = python_type.__name__\n\n        return \"<{}[{}:{}]>\".format(\n            self.__class__.__name__,\n            self.backing_type, python_type\n        )\ntests/helpers/models.py\nclass User(BaseModel):\n    id = Column(String, hash_key=True)\n    age = Column(Integer)\n    name = Column(String)\n    email = Column(String)\n    joined = Column(DateTime, dynamo_name=\"j\")\n    by_email = GlobalSecondaryIndex(hash_key=\"email\", projection=\"all\")\nbloop/types.py\nclass Timestamp(Integer):\n    \"\"\"Stores the unix (epoch) time in seconds.  Milliseconds are truncated to 0 on load and save.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(Timestamp)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import Timestamp  # becomes:\n            from bloop.ext.pendulum import Timestamp\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = super().dynamo_load(value, context=context, **kwargs)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return datetime.datetime.fromtimestamp(value, tz=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        value = value.timestamp()\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/conditions.py\nclass ConditionRenderer:\n    # noinspection PyUnresolvedReferences\n    \"\"\"Renders collections of :class:`~bloop.conditions.BaseCondition` into DynamoDB's wire format for expressions,\n    including:\n\n    * ``\"ConditionExpression\"`` -- used in conditional operations\n    * ``\"FilterExpression\"`` -- used in queries and scans to ignore results that don't match the filter\n    * ``\"KeyConditionExpressions\"`` -- used to describe a query's hash (and range) key(s)\n    * ``\"ProjectionExpression\"`` -- used to include a subset of possible columns in the results of a query or scan\n    * ``\"UpdateExpression\"`` -- used to save objects\n\n    Normally, you will only need to call :func:`~bloop.conditions.ConditionRenderer.render` to handle any combination\n    of conditions.  You can also call each individual ``render_*`` function to control how multiple conditions of\n    each type are applied.\n\n    You can collect the rendered condition at any time through :attr:`~bloop.conditions.ConditionRenderer.rendered`.\n\n    .. code-block:: python\n\n        >>> renderer.render(obj=user, atomic=True)\n        >>> renderer.output\n        {'ConditionExpression': '((#n0 = :v1) AND (attribute_not_exists(#n2)) AND (#n4 = :v5))',\n         'ExpressionAttributeNames': {'#n0': 'age', '#n2': 'email', '#n4': 'id'},\n         'ExpressionAttributeValues': {':v1': {'N': '3'}, ':v5': {'S': 'some-user-id'}}}\n\n\n    :param engine: Used to dump values in conditions into the appropriate wire format.\n    :type engine: :class:`~bloop.engine.Engine`\n    \"\"\"\n    def __init__(self, engine):\n        self.refs = ReferenceTracker(engine)\n        self.engine = engine\n        self.expressions = {}\n\n    def render(self, obj=None, condition=None, update=False, filter=None, projection=None, key=None):\n        \"\"\"Main entry point for rendering multiple expressions.  All parameters are optional, except obj when\n        atomic or update are True.\n\n        :param obj: *(Optional)* An object to render an atomic condition or update expression for.  Required if\n            update or atomic are true.  Default is False.\n        :param condition: *(Optional)* Rendered as a \"ConditionExpression\" for a conditional operation.\n            If atomic is True, the two are rendered in an AND condition.  Default is None.\n        :type condition: :class:`~bloop.conditions.BaseCondition`\n        :param bool update: *(Optional)*  True if an \"UpdateExpression\" should be rendered for ``obj``.\n            Default is False.\n        :param filter: *(Optional)* A filter condition for a query or scan, rendered as a \"FilterExpression\".\n            Default is None.\n        :type filter: :class:`~bloop.conditions.BaseCondition`\n        :param projection: *(Optional)* A set of Columns to include in a query or scan, rendered as a\n            \"ProjectionExpression\".  Default is None.\n        :type projection: set :class:`~bloop.models.Column`\n        :param key: *(Optional)* A key condition for queries, rendered as a \"KeyConditionExpression\".  Default is None.\n        :type key: :class:`~bloop.conditions.BaseCondition`\n        \"\"\"\n        if update and not obj:\n            raise InvalidCondition(\"An object is required to render updates.\")\n\n        if filter:\n            self.filter_expression(filter)\n\n        if projection:\n            self.projection_expression(projection)\n\n        if key:\n            self.key_expression(key)\n\n        # Condition requires a bit of work, because either one can be empty/false\n        if condition:\n            self.condition_expression(condition)\n\n        if update:\n            self.update_expression(obj)\n\n    def condition_expression(self, condition):\n        self.expressions[\"ConditionExpression\"] = condition.render(self)\n\n    def filter_expression(self, condition):\n        self.expressions[\"FilterExpression\"] = condition.render(self)\n\n    def key_expression(self, condition):\n        self.expressions[\"KeyConditionExpression\"] = condition.render(self)\n\n    def projection_expression(self, columns):\n        included = set()\n        ref_names = []\n        for column in columns:\n            if column in included:\n                continue\n            included.add(column)\n            ref = self.refs.any_ref(column=column)\n            ref_names.append(ref.name)\n        self.expressions[\"ProjectionExpression\"] = \", \".join(ref_names)\n\n    def update_expression(self, obj):\n        updates = {\n            ActionType.Add: [],\n            ActionType.Delete: [],\n            ActionType.Remove: [],\n            ActionType.Set: [],\n        }\n        for column in sorted(\n                # Don't include key columns in an UpdateExpression\n                filter(lambda c: c not in obj.Meta.keys, global_tracking[obj]),\n                key=lambda c: c.dynamo_name):\n            name_ref = self.refs.any_ref(column=column)\n            value_ref = self.refs.any_ref(column=column, value=getattr(obj, column.name, None))\n            update_type = value_ref.action.type\n            # Can't set to an empty value, force to a Remove\n            if is_empty(value_ref) or update_type is ActionType.Remove:\n                self.refs.pop_refs(value_ref)\n                update_type = ActionType.Remove\n                value_ref = None\n            updates[update_type].append((name_ref, value_ref))\n\n        expressions = []\n        for update_type, refs in updates.items():\n            if not refs:\n                continue\n            k = update_type.wire_key.upper()\n            r = update_type.render\n            expressions.append(f\"{k} \" + \", \".join(r(*ref) for ref in refs))\n        if expressions:\n            self.expressions[\"UpdateExpression\"] = \" \".join(e.strip() for e in expressions)\n\n    @property\n    def output(self):\n        \"\"\"The wire format for all conditions that have been rendered.\n        A new :class:`~bloop.conditions.ConditionRenderer` should be used for each operation.\"\"\"\n        expressions = {k: v for (k, v) in self.expressions.items() if v is not None}\n        if self.refs.attr_names:\n            expressions[\"ExpressionAttributeNames\"] = self.refs.attr_names\n        if self.refs.attr_values:\n            expressions[\"ExpressionAttributeValues\"] = self.refs.attr_values\n        return expressions\nbloop/types.py\nclass String(Type):\n    python_type = str\n    backing_type = STRING\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if not value:\n            return \"\"\n        return value\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if not value:\n            return None\n        return value\n", "answers": ["    class Blob(BaseModel):"], "length": 2045, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "8857338affe2d9fe32dc189b478b4aa891b3905618953f5b"}
{"input": "from copy import copy\nfrom ..namespaces import XPATH_FUNCTIONS_NAMESPACE, XSD_NAMESPACE\nfrom ..xpath_nodes import TypedElement, TypedAttribute, XPathNode\nfrom ..xpath_token import XPathToken, ValueToken, XPathFunction\nfrom ..xpath_context import XPathSchemaContext\nfrom ..datatypes import QName\nfrom .xpath30_parser import XPath30Parser\n# type: ignore\n\"\"\"\nXPath 3.0 implementation - part 2 (symbols, operators and expressions)\n\"\"\"\n\n\n\n\nregister = XPath30Parser.register\ninfix = XPath30Parser.infix\nmethod = XPath30Parser.method\n\nregister(':=')\n\n###\n# Placeholder symbol (used also for optional occurrence)\n\nXPath30Parser.unregister('?')\nregister('?', bases=(ValueToken,))\n\n\n@method('?')\ndef nud_placeholder_symbol(self):\n    # self.value = self\n    return self\n\n\n@method('?')\ndef evaluate_placeholder_symbol(self, context=None):\n    return self\n\n\n###\n# Braced/expanded QName(s)\n\nXPath30Parser.duplicate('{', 'Q{', pattern=r'Q\\{')\nXPath30Parser.unregister('{')\nXPath30Parser.unregister('}')\nregister('{')\nregister('}', bp=100)\n\n\nXPath30Parser.unregister('(')\n\n\n@method(register('(', lbp=80, rpb=80, label='expression'))\ndef nud_parenthesized_expression(self):\n    if self.parser.next_token.symbol != ')':\n        self[:] = self.parser.expression(),\n    self.parser.advance(')')\n    return self\n\n\n@method('(')\ndef led_parenthesized_expression(self, left):\n    if left.symbol == '(name)':\n        if left.value in self.parser.RESERVED_FUNCTION_NAMES:\n            msg = f\"{left.value!r} is not allowed as function name\"\n            raise left.error('XPST0003', msg)\n        else:\n            raise left.error('XPST0017', 'unknown function {!r}'.format(left.value))\n\n    elif left.symbol == ':' and left[1].symbol == '(name)':\n        if left[1].namespace == XSD_NAMESPACE:\n            msg = 'unknown constructor function {!r}'.format(left[1].value)\n            raise left[1].error('XPST0017', msg)\n        raise left.error('XPST0017', 'unknown function {!r}'.format(left.value))\n\n    if self.parser.next_token.symbol != ')':\n        self[:] = left, self.parser.expression()\n    else:\n        self[:] = left,\n    self.parser.advance(')')\n    return self\n\n\n@method('(')\ndef evaluate_parenthesized_expression(self, context=None):\n    if not self:\n        return []\n\n    value = self[0].evaluate(context)\n    if isinstance(value, list) and len(value) == 1:\n        value = value[0]\n\n    if len(self) > 1:\n        if isinstance(value, XPathFunction):\n            return value(context, self[1])\n        elif self[0].symbol == '(':\n            if not isinstance(value, list):\n                return value\n            elif any(not isinstance(x, XPathFunction) for x in value):\n                return value\n\n        if isinstance(value, XPathToken) and value.symbol == '?':\n            return value\n\n        raise self.error('XPTY0004', f'an XPath function expected, not {type(value)!r}')\n\n    if not isinstance(value, XPathFunction) or self[0].span[0] > self.span[0]:\n        return value\n    else:\n        return value(context)\n\n\n@method(infix('||', bp=32))\ndef evaluate_union_operator(self, context=None):\n    return self.string_value(self.get_argument(context)) + \\\n        self.string_value(self.get_argument(context, index=1))\n\n\n@method(infix('!', bp=72))\ndef select_simple_map_operator(self, context=None):\n    if context is None:\n        raise self.missing_context()\n\n    for context.item in context.inner_focus_select(self[0]):\n        for result in self[1].select(copy(context)):\n            if not isinstance(result, (tuple, XPathNode)) and not hasattr(result, 'tag'):\n                yield result\n", "context": "elementpath/xpath_nodes.py\nclass TypedAttribute(XPathNode):\n    \"\"\"\n    A class for processing typed attribute nodes.\n\n    :param attribute: the origin AttributeNode instance.\n    :param xsd_type: the reference XSD type.\n    :param value: the types value.\n    \"\"\"\n    def __init__(self, attribute: AttributeNode, xsd_type: Any, value: Any) -> None:\n        self.attribute = attribute\n        self.xsd_type = xsd_type\n        self.value = value\n        self.parent = attribute.parent\n\n    @property\n    def kind(self) -> str:\n        return 'attribute'\n\n    @property\n    def name(self) -> str:\n        return self.attribute.name\n\n    def as_item(self) -> Tuple[str, Any]:\n        return self.attribute.name, self.value\n\n    def __repr__(self) -> str:\n        return '%s(name=%r)' % (self.__class__.__name__, self.attribute.name)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.attribute == other.attribute and \\\n            self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.attribute, self.value))\nelementpath/xpath_nodes.py\nclass XPathNode:\n\n    name: Any = None\n    value: Any = None\n    parent: Optional[ElementNode] = None\n\n    @property\n    def kind(self) -> str:\n        raise NotImplementedError()\nelementpath/xpath_token.py\nclass XPathToken(Token[XPathTokenType]):\n    \"\"\"Base class for XPath tokens.\"\"\"\n    parser: XPathParserType\n    xsd_types: Optional[Dict[str, Union[XsdTypeProtocol, List[XsdTypeProtocol]]]]\n    namespace: Optional[str]\n    occurrence: Optional[str]\n\n    xsd_types = None  # for XPath 2.0+ XML Schema types labeling\n    namespace = None  # for namespace binding of names and wildcards\n    occurrence = None  # occurrence indicator for item types\n\n    def __call__(self, context: Optional[XPathContext] = None) -> Any:\n        return self.evaluate(context)\n\n    def evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        \"\"\"\n        Evaluate default method for XPath tokens.\n\n        :param context: The XPath dynamic context.\n        \"\"\"\n        return [x for x in self.select(context)]\n\n    def select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        \"\"\"\n        Select operator that generates XPath results.\n\n        :param context: The XPath dynamic context.\n        \"\"\"\n        item = self.evaluate(context)\n        if item is not None:\n            if isinstance(item, list):\n                yield from item\n            else:\n                if context is not None:\n                    context.item = item\n                yield item\n\n    def __str__(self) -> str:\n        symbol, label = self.symbol, self.label\n        if symbol == '$':\n            return '$%s variable reference' % (self[0].value if self._items else '')\n        elif symbol == ',':\n            return 'comma operator' if self.parser.version > '1.0' else 'comma symbol'\n        elif symbol == 'function':\n            return str(label)\n        elif label.endswith('function') or label in ('axis', 'sequence type', 'kind test'):\n            return '%r %s' % (symbol, str(label))\n        return super(XPathToken, self).__str__()\n\n    @property\n    def source(self) -> str:\n        symbol = self.symbol\n        if self.label == 'axis':\n            # For XPath 2.0 'attribute' multi-role token ('kind test', 'axis')\n            return '%s::%s' % (symbol, self[0].source)\n        elif symbol == ':':\n            if self.occurrence:\n                return str(self.value) + self.occurrence\n            else:\n                return str(self.value)\n        elif symbol == '(':\n            return '()' if not self else '(%s)' % self[0].source\n        elif symbol == '[':\n            return '%s[%s]' % (self[0].source, self[1].source)\n        elif symbol == ',':\n            return '%s, %s' % (self[0].source, self[1].source)\n        elif symbol == '$':\n            return '$%s' % self[0].source\n        elif symbol == '{':\n            return '{%s}%s' % (self[0].value, self[1].value)\n        elif symbol == 'if':\n            return 'if (%s) then %s else %s' % (self[0].source, self[1].source, self[2].source)\n        elif symbol == 'instance':\n            return '%s instance of %s' % (self[0].source, ''.join(t.source for t in self[1:]))\n        elif symbol == 'treat':\n            return '%s treat as %s' % (self[0].source, ''.join(t.source for t in self[1:]))\n        elif symbol == 'for':\n            return 'for %s return %s' % (\n                ', '.join('%s in %s' % (self[k].source, self[k + 1].source)\n                          for k in range(0, len(self) - 1, 2)),\n                self[-1].source\n            )\n        return super(XPathToken, self).source\n\n    @property\n    def child_axis(self) -> bool:\n        \"\"\"Is `True` if the token apply child axis for default, `False` otherwise.\"\"\"\n        if self.symbol not in _CHILD_AXIS_TOKENS:\n            return False\n        elif self.symbol == '[':\n            return self._items[0].child_axis\n        elif self.symbol != ':':\n            return True\n        return not self._items[1].label.endswith('function')\n\n    ###\n    # Tokens tree analysis methods\n    def iter_leaf_elements(self) -> Iterator[str]:\n        \"\"\"\n        Iterates through the leaf elements of the token tree if there are any,\n        returning QNames in prefixed format. A leaf element is an element\n        positioned at last path step. Does not consider kind tests and wildcards.\n        \"\"\"\n        if self.symbol in ('(name)', ':'):\n            yield cast(str, self.value)\n        elif self.symbol in ('//', '/'):\n            if self._items[-1].symbol in _LEAF_ELEMENTS_TOKENS:\n                yield from self._items[-1].iter_leaf_elements()\n\n        elif self.symbol in ('[',):\n            yield from self._items[0].iter_leaf_elements()\n        else:\n            for tk in self._items:\n                yield from tk.iter_leaf_elements()\n\n    ###\n    # Dynamic context methods\n    def get_argument(self, context: Optional[XPathContext],\n                     index: int = 0,\n                     required: bool = False,\n                     default_to_context: bool = False,\n                     default: Optional[AtomicValueType] = None,\n                     cls: Optional[Type[Any]] = None,\n                     promote: Optional[ClassCheckType] = None) -> Any:\n        \"\"\"\n        Get the argument value of a function of constructor token. A zero length sequence is\n        converted to a `None` value. If the function has no argument returns the context's\n        item if the dynamic context is not `None`.\n\n        :param context: the dynamic context.\n        :param index: an index for select the argument to be got, the first for default.\n        :param required: if set to `True` missing or empty sequence arguments are not allowed.\n        :param default_to_context: if set to `True` then the item of the dynamic context is \\\n        returned when the argument is missing.\n        :param default: the default value returned in case the argument is an empty sequence. \\\n        If not provided returns `None`.\n        :param cls: if a type is provided performs a type checking on item.\n        :param promote: a class or a tuple of classes that are promoted to `cls` class.\n        \"\"\"\n        item: Union[None, ElementProtocol, DocumentProtocol, XPathNode, AnyAtomicType]\n\n        try:\n            selector = self._items[index].select\n        except IndexError:\n            if default_to_context:\n                if context is None:\n                    raise self.missing_context() from None\n                item = context.item if context.item is not None else context.root\n            elif required:\n                msg = \"missing %s argument\" % ordinal(index + 1)\n                raise self.error('XPST0017', msg) from None\n            else:\n                return default\n        else:\n            item = None\n            for k, result in enumerate(selector(copy(context))):\n                if k == 0:\n                    item = result\n                elif self.parser.compatibility_mode:\n                    break\n                elif isinstance(context, XPathSchemaContext):\n                    # Multiple schema nodes are ignored but do not raise. The target\n                    # of schema context selection is XSD type association and multiple\n                    # node coherency is already checked at schema level.\n                    break\n                else:\n                    raise self.wrong_context_type(\n                        \"a sequence of more than one item is not allowed as argument\"\n                    )\n            else:\n                if item is None:\n                    if not required:\n                        return default\n                    ord_arg = ordinal(index + 1)\n                    msg = \"A not empty sequence required for {} argument\"\n                    raise self.error('XPTY0004', msg.format(ord_arg))\n\n        if cls is not None:\n            return self.validated_value(item, cls, promote)\n        return item\n\n    def validated_value(self, item: Any, cls: Type[Any],\n                        promote: Optional[ClassCheckType] = None) -> Any:\n        \"\"\"\n        Type promotion checking (see \"function conversion rules\" in XPath 2.0 language definition)\n        \"\"\"\n        if isinstance(item, (cls, ValueToken)):\n            return item\n        elif promote and isinstance(item, promote):\n            return cls(item)\n\n        if self.parser.compatibility_mode:\n            if issubclass(cls, str):\n                return self.string_value(item)\n            elif issubclass(cls, float) or issubclass(float, cls):\n                return self.number_value(item)\n\n        if issubclass(cls, XPathToken) or self.parser.version == '1.0':\n            code = 'XPTY0004'\n        else:\n            value = self.data_value(item)\n            if isinstance(value, cls):\n                return value\n            elif isinstance(value, AnyURI) and issubclass(cls, str):\n                return cls(value)\n            elif isinstance(value, UntypedAtomic):\n                try:\n                    return cls(value)\n                except (TypeError, ValueError):\n                    pass\n\n            code = 'FOTY0012' if value is None else 'XPTY0004'\n\n        message = \"item type is {!r} instead of {!r}\"\n        raise self.error(code, message.format(type(item), cls))\n\n    def select_data_values(self, context: Optional[XPathContext] = None) \\\n            -> Iterator[Optional[AtomicValueType]]:\n        \"\"\"\n        Yields data value of selected items.\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        for item in self.select(context):\n            yield self.data_value(item)\n\n    def atomization(self, context: Optional[XPathContext] = None) \\\n            -> Iterator[AtomicValueType]:\n        \"\"\"\n        Helper method for value atomization of a sequence.\n\n        Ref: https://www.w3.org/TR/xpath20/#id-atomization\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        for item in self.select(context):\n            value = self.data_value(item)\n            if value is None:\n                msg = \"argument node {!r} does not have a typed value\"\n                raise self.error('FOTY0012', msg.format(item))\n            else:\n                yield value\n\n    def get_atomized_operand(self, context: Optional[XPathContext] = None) \\\n            -> Optional[AtomicValueType]:\n        \"\"\"\n        Get the atomized value for an XPath operator.\n\n        :param context: the XPath dynamic context.\n        :return: the atomized value of a single length sequence or `None` if the sequence is empty.\n        \"\"\"\n        selector = iter(self.atomization(context))\n        try:\n            value = next(selector)\n        except StopIteration:\n            return None\n        else:\n            item = getattr(context, 'item', None)\n\n            try:\n                next(selector)\n            except StopIteration:\n                if isinstance(value, UntypedAtomic):\n                    value = str(value)\n\n                if not isinstance(context, XPathSchemaContext) and \\\n                        item is not None and \\\n                        self.xsd_types and \\\n                        isinstance(value, str):\n\n                    xsd_type = self.get_xsd_type(item)\n                    if xsd_type is None or xsd_type.name in _XSD_SPECIAL_TYPES:\n                        pass\n                    else:\n                        try:\n                            value = xsd_type.decode(value)\n                        except (TypeError, ValueError):\n                            msg = \"Type {!r} is not appropriate for the context\"\n                            raise self.wrong_context_type(msg.format(type(value)))\n\n                return value\n            else:\n                msg = \"atomized operand is a sequence of length greater than one\"\n                raise self.wrong_context_type(msg)\n\n    def iter_comparison_data(self, context: XPathContext) -> Iterator[OperandsType]:\n        \"\"\"\n        Generates comparison data couples for the general comparison of sequences.\n        Different sequences maybe generated with an XPath 2.0 parser, depending on\n        compatibility mode setting.\n\n        Ref: https://www.w3.org/TR/xpath20/#id-general-comparisons\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        if self.parser.compatibility_mode:\n            operand1 = [x for x in self._items[0].select(copy(context))]\n            operand2 = [x for x in self._items[1].select(copy(context))]\n\n            # Boolean comparison if one of the results is a single boolean value (1.)\n            try:\n                if isinstance(operand1[0], bool):\n                    if len(operand1) == 1:\n                        yield operand1[0], self.boolean_value(operand2)\n                        return\n                if isinstance(operand2[0], bool):\n                    if len(operand2) == 1:\n                        yield self.boolean_value(operand1), operand2[0]\n                        return\n            except IndexError:\n                return\n\n            # Converts to float for lesser-greater operators (3.)\n            if self.symbol in ('<', '<=', '>', '>='):\n                yield from product(\n                    map(float, map(self.data_value, operand1)),  # type: ignore[arg-type]\n                    map(float, map(self.data_value, operand2)),  # type: ignore[arg-type]\n                )\n                return\n            elif self.parser.version == '1.0':\n                yield from product(map(self.data_value, operand1), map(self.data_value, operand2))\n                return\n\n        for values in product(map(self.data_value, self._items[0].select(copy(context))),\n                              map(self.data_value, self._items[1].select(copy(context)))):\n            if any(isinstance(x, bool) for x in values):\n                if any(isinstance(x, (str, Integer)) for x in values):\n                    msg = \"cannot compare {!r} and {!r}\"\n                    raise TypeError(msg.format(type(values[0]), type(values[1])))\n            elif any(isinstance(x, Integer) for x in values) and \\\n                    any(isinstance(x, str) for x in values):\n                msg = \"cannot compare {!r} and {!r}\"\n                raise TypeError(msg.format(type(values[0]), type(values[1])))\n            elif any(isinstance(x, float) for x in values):\n                if isinstance(values[0], decimal.Decimal):\n                    yield float(values[0]), values[1]\n                    continue\n                elif isinstance(values[1], decimal.Decimal):\n                    yield values[0], float(values[1])\n                    continue\n\n            yield values\n\n    def select_results(self, context: Optional[XPathContext]) -> Iterator[SelectResultType]:\n        \"\"\"\n        Generates formatted XPath results.\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        if context is not None:\n            self.parser.check_variables(context.variables)\n\n        for result in self.select(context):\n            if not isinstance(result, XPathNode):\n                yield result\n            elif isinstance(result, (TextNode, AttributeNode)):\n                yield result.value\n            elif isinstance(result, TypedElement):\n                yield result.elem\n            elif isinstance(result, TypedAttribute):\n                if is_schema_node(result.attribute.value):\n                    yield result.attribute.value\n                else:\n                    yield result.value\n            elif isinstance(result, NamespaceNode):  # pragma: no cover\n                if self.parser.compatibility_mode:\n                    yield result.prefix, result.uri\n                else:\n                    yield result.uri\n\n    def get_results(self, context: XPathContext) \\\n            -> Union[List[Any], AtomicValueType]:\n        \"\"\"\n        Returns formatted XPath results.\n\n        :param context: the XPath dynamic context.\n        :return: a list or a simple datatype when the result is a single simple type \\\n        generated by a literal or function token.\n        \"\"\"\n        results = [x for x in self.select_results(context)]\n        if len(results) == 1:\n            res = results[0]\n            if isinstance(res, (bool, int, float, Decimal)):\n                return res\n            elif is_etree_element(res) or is_document_node(res) or is_schema_node(res):\n                return results\n            elif self.label in ('function', 'literal'):\n                return cast(AtomicValueType, res)\n            else:\n                return results\n        else:\n            return results\n\n    def get_operands(self, context: XPathContext, cls: Optional[Type[Any]] = None) \\\n            -> OperandsType:\n        \"\"\"\n        Returns the operands for a binary operator. Float arguments are converted\n        to decimal if the other argument is a `Decimal` instance.\n\n        :param context: the XPath dynamic context.\n        :param cls: if a type is provided performs a type checking on item.\n        :return: a couple of values representing the operands. If any operand \\\n        is not available returns a `(None, None)` couple.\n        \"\"\"\n        op1 = self.get_argument(context, cls=cls)\n        if op1 is None:\n            return None, None\n        elif is_element_node(op1):\n            op1 = self._items[0].data_value(op1)\n\n        op2 = self.get_argument(context, index=1, cls=cls)\n        if op2 is None:\n            return None, None\n        elif is_element_node(op2):\n            op2 = self._items[1].data_value(op2)\n\n        if isinstance(op1, AbstractDateTime) and isinstance(op2, AbstractDateTime):\n            if context is not None and context.timezone is not None:\n                if op1.tzinfo is None:\n                    op1.tzinfo = context.timezone\n                if op2.tzinfo is None:\n                    op2.tzinfo = context.timezone\n        else:\n            if isinstance(op1, UntypedAtomic):\n                op1 = self.cast_to_double(op1.value)\n                if isinstance(op2, Decimal):\n                    return op1, float(op2)\n            if isinstance(op2, UntypedAtomic):\n                op2 = self.cast_to_double(op2.value)\n                if isinstance(op1, Decimal):\n                    return float(op1), op2\n\n        if isinstance(op1, float):\n            if isinstance(op2, Duration):\n                return Decimal(op1), op2\n            if isinstance(op2, Decimal):\n                return op1, type(op1)(op2)\n        if isinstance(op2, float):\n            if isinstance(op1, Duration):\n                return op1, Decimal(op2)\n            if isinstance(op1, Decimal):\n                return type(op2)(op1), op2\n\n        return op1, op2\n\n    def get_absolute_uri(self, uri: str,\n                         base_uri: Optional[str] = None,\n                         as_string: bool = True) -> Union[str, AnyURI]:\n        \"\"\"\n        Obtains an absolute URI from the argument and the static context.\n\n        :param uri: a string representing an URI.\n        :param base_uri: an alternative base URI, otherwise the base_uri \\\n        of the static context is used.\n        :param as_string: if `True` then returns the URI as a string, otherwise \\\n        returns the URI as xs:anyURI instance.\n        :returns: the argument if it's an absolute URI. Otherwise returns the URI\n        obtained by the join o the base_uri of the static context with the\n        argument. Returns the argument if the base_uri is `None'.\n        \"\"\"\n        if not base_uri:\n            base_uri = self.parser.base_uri\n\n        uri_parts: urllib.parse.ParseResult = urllib.parse.urlparse(uri)\n        if uri_parts.scheme or uri_parts.netloc or base_uri is None:\n            return uri if as_string else AnyURI(uri)\n\n        base_uri_parts: urllib.parse.SplitResult = urllib.parse.urlsplit(base_uri)\n        if base_uri_parts.fragment or not base_uri_parts.scheme and \\\n                not base_uri_parts.netloc and not base_uri_parts.path.startswith('/'):\n            raise self.error('FORG0002', '{!r} is not suitable as base URI'.format(base_uri))\n\n        if uri_parts.path.startswith('/') and base_uri_parts.path not in ('', '/'):\n            return uri if as_string else AnyURI(uri)\n\n        if as_string:\n            return urllib.parse.urljoin(base_uri, uri)\n        return AnyURI(urllib.parse.urljoin(base_uri, uri))\n\n    def get_namespace(self, prefix: str) -> str:\n        \"\"\"\n        Resolves a prefix to a namespace raising an error (FONS0004) if the\n        prefix is not found in the namespace map.\n        \"\"\"\n        try:\n            return self.parser.namespaces[prefix]\n        except KeyError as err:\n            msg = 'no namespace found for prefix %r' % str(err)\n            raise self.error('FONS0004', msg) from None\n\n    def bind_namespace(self, namespace: str) -> None:\n        \"\"\"\n        Bind a token with a namespace. The token has to be a name, a name wildcard,\n        a function or a constructor, otherwise a syntax error is raised. Functions\n        and constructors must be limited to its namespaces.\n        \"\"\"\n        if self.symbol in ('(name)', '*'):\n            pass\n        elif namespace == self.parser.function_namespace:\n            if self.label != 'function':\n                msg = \"a name, a wildcard or a function expected\"\n                raise self.wrong_syntax(msg, code='XPST0017')\n            elif isinstance(self.label, MultiLabel):\n                self.label = 'function'\n        elif namespace == XSD_NAMESPACE:\n            if self.label != 'constructor function':\n                msg = \"a name, a wildcard or a constructor function expected\"\n                raise self.wrong_syntax(msg, code='XPST0017')\n            elif isinstance(self.label, MultiLabel):\n                self.label = 'constructor function'\n        elif namespace == XPATH_MATH_FUNCTIONS_NAMESPACE:\n            if self.label != 'math function':\n                msg = \"a name, a wildcard or a math function expected\"\n                raise self.wrong_syntax(msg, code='XPST0017')\n            elif isinstance(self.label, MultiLabel):\n                self.label = 'math function'\n        else:\n            msg = \"a name, a wildcard or a function expected\"\n            raise self.wrong_syntax(msg, code='XPST0017')\n\n        self.namespace = namespace\n\n    def adjust_datetime(self, context: XPathContext, cls: Type[DatetimeValueType]) \\\n            -> Optional[Union[DatetimeValueType, DayTimeDuration]]:\n        \"\"\"\n        XSD datetime adjust function helper.\n\n        :param context: the XPath dynamic context.\n        :param cls: the XSD datetime subclass to use.\n        :return: an empty list if there is only one argument that is the empty sequence \\\n        or the adjusted XSD datetime instance.\n        \"\"\"\n        timezone: Optional[Any]\n        item: Optional[DatetimeValueType]\n        _item: Union[DatetimeValueType, DayTimeDuration]\n\n        if len(self) == 1:\n            item = self.get_argument(context, cls=cls)\n            if item is None:\n                return None\n            timezone = getattr(context, 'timezone', None)\n        else:\n            item = self.get_argument(context, cls=cls)\n            timezone = self.get_argument(context, 1, cls=DayTimeDuration)\n\n            if timezone is not None:\n                try:\n                    timezone = Timezone.fromduration(timezone)\n                except ValueError as err:\n                    raise self.error('FODT0003', str(err)) from None\n            if item is None:\n                return None\n\n        _item = item\n        _tzinfo = _item.tzinfo\n        try:\n            if _tzinfo is not None and timezone is not None:\n                if isinstance(_item, DateTime10):\n                    _item += timezone.offset\n                elif not isinstance(item, Date10):\n                    _item += timezone.offset - _tzinfo.offset\n                elif timezone.offset < _tzinfo.offset:\n                    _item -= timezone.offset - _tzinfo.offset\n                    _item -= DayTimeDuration.fromstring('P1D')\n        except OverflowError as err:\n            raise self.error('FODT0001', str(err)) from None\n\n        if not isinstance(_item, DayTimeDuration):\n            _item.tzinfo = timezone\n        return _item\n\n    @contextlib.contextmanager\n    def use_locale(self, collation: str) -> Iterator[None]:\n        \"\"\"A context manager for use a locale setting for string comparison in a code block.\"\"\"\n        loc = locale.getlocale(locale.LC_COLLATE)\n        if collation == UNICODE_CODEPOINT_COLLATION or collation == 'collation/codepoint':\n            collation = 'en_US.UTF-8'\n        elif collation is None:\n            raise self.error('XPTY0004', 'collation cannot be an empty sequence')\n\n        try:\n            locale.setlocale(locale.LC_COLLATE, collation)\n        except locale.Error:\n            raise self.error('FOCH0002', 'Unsupported collation %r' % collation) from None\n        else:\n            yield\n        finally:\n            locale.setlocale(locale.LC_COLLATE, loc)\n\n    ###\n    # XSD types related methods\n    def select_xsd_nodes(self, schema_context: XPathSchemaContext, name: str) \\\n            -> Iterator[Union[None, TypedElement, TypedAttribute, XMLSchemaProtocol]]:\n        \"\"\"\n        Selector for XSD nodes (elements, attributes and schemas). If there is\n        a match with an attribute or an element the node's type is added to\n        matching types of the token. For each matching elements or attributes\n        yields tuple nodes containing the node, its type and a compatible value\n        for doing static evaluation. For matching schemas yields the original\n        instance.\n\n        :param schema_context: an XPathSchemaContext instance.\n        :param name: a QName in extended format.\n        \"\"\"\n        xsd_node: Any\n        for xsd_node in schema_context.iter_children_or_self():\n            if xsd_node is None:\n                if name == XSD_SCHEMA == schema_context.root.tag:\n                    yield None\n                continue  # pragma: no cover\n\n            try:\n                if isinstance(xsd_node, AttributeNode):\n                    if isinstance(xsd_node.value, str):\n                        if xsd_node.name != name:\n                            continue\n                        xsd_node = schema_context.root.maps.attributes.get(name)\n                        if xsd_node is None:\n                            continue\n                    elif xsd_node.value.is_matching(name):\n                        if xsd_node.name is None:\n                            # node is an XSD attribute wildcard\n                            xsd_node = schema_context.root.maps.attributes.get(name)\n                            if xsd_node is None:\n                                continue\n                    else:\n                        continue\n\n                    xsd_type = self.add_xsd_type(xsd_node)\n                    if xsd_type is not None:\n                        value = self.parser.get_atomic_value(xsd_type)\n                        yield TypedAttribute(xsd_node, xsd_type, value)\n\n                elif name == XSD_SCHEMA == xsd_node.tag:\n                    # The element is a schema\n                    yield xsd_node\n\n                elif xsd_node.is_matching(name, self.parser.default_namespace):\n                    if xsd_node.name is None:\n                        # node is an XSD element wildcard\n                        xsd_node = schema_context.root.maps.elements.get(name)\n                        if xsd_node is None:\n                            continue\n\n                    xsd_type = self.add_xsd_type(xsd_node)\n                    if xsd_type is not None:\n                        value = self.parser.get_atomic_value(xsd_type)\n                        yield TypedElement(xsd_node, xsd_type, value)\n\n            except AttributeError:\n                pass\n\n    def add_xsd_type(self, item: Any) -> Optional[XsdTypeProtocol]:\n        \"\"\"\n        Adds an XSD type association from an item. The association is\n        added using the item's name and type.\n        \"\"\"\n        if isinstance(item, AttributeNode):\n            item = item.value\n        elif isinstance(item, TypedAttribute):\n            item = item.attribute.value\n        elif isinstance(item, TypedElement):\n            item = item.elem\n\n        if not is_schema_node(item):\n            return None\n\n        name: str = item.name\n        xsd_type: XsdTypeProtocol = item.type\n\n        if self.xsd_types is None:\n            self.xsd_types = {name: xsd_type}\n        else:\n            obj = self.xsd_types.get(name)\n            if obj is None:\n                self.xsd_types[name] = xsd_type\n            elif not isinstance(obj, list):\n                if obj is not xsd_type:\n                    self.xsd_types[name] = [obj, xsd_type]\n            elif xsd_type not in obj:\n                obj.append(xsd_type)\n\n        return xsd_type\n\n    def get_xsd_type(self, item: Union[str, PrincipalNodeType]) \\\n            -> Optional[XsdTypeProtocol]:\n        \"\"\"\n        Returns the XSD type associated with an item. Match by item's name\n        and XSD validity. Returns `None` if no XSD type is matching.\n\n        :param item: a string or an AttributeNode or an element.\n        \"\"\"\n        if not self.xsd_types or isinstance(self.xsd_types, AbstractSchemaProxy):\n            return None\n        elif isinstance(item, str):\n            xsd_type = self.xsd_types.get(item)\n        elif isinstance(item, AttributeNode):\n            xsd_type = self.xsd_types.get(item.name)\n        elif isinstance(item, (TypedAttribute, TypedElement)):\n            return cast(XsdTypeProtocol, item.xsd_type)\n        else:\n            xsd_type = self.xsd_types.get(item.tag)\n\n        x: XsdTypeProtocol\n        if not xsd_type:\n            return None\n        elif not isinstance(xsd_type, list):\n            return xsd_type\n        elif isinstance(item, AttributeNode):\n            for x in xsd_type:\n                if x.is_valid(item.value):\n                    return x\n        elif is_etree_element(item):\n            for x in xsd_type:\n                if x.is_simple():\n                    if x.is_valid(item.text):  # type: ignore[union-attr]\n                        return x\n                elif x.is_valid(item):\n                    return x\n\n        return xsd_type[0]\n\n    def get_typed_node(self, item: PrincipalNodeType) -> PrincipalNodeType:\n        \"\"\"\n        Returns a typed node if the item is matching an XSD type.\n\n        Ref:\n          https://www.w3.org/TR/xpath20/#id-processing-model\n          https://www.w3.org/TR/xpath20/#id-static-analysis\n          https://www.w3.org/TR/xquery-semantics/\n\n        :param item: an untyped attribute or element.\n        :return: a typed AttributeNode/ElementNode if the argument is matching \\\n        any associated XSD type.\n        \"\"\"\n        if isinstance(item, (TypedAttribute, TypedElement)):\n            return item\n\n        xsd_type = self.get_xsd_type(item)\n        if not xsd_type:\n            return item\n        elif xsd_type.name in _XSD_SPECIAL_TYPES:\n            if isinstance(item, AttributeNode):\n                if not isinstance(item.value, str):\n                    return TypedAttribute(item, xsd_type, UntypedAtomic(''))\n                return TypedAttribute(item, xsd_type, UntypedAtomic(item.value))\n            return TypedElement(item, xsd_type, UntypedAtomic(item.text or ''))\n\n        elif isinstance(item, AttributeNode):\n            pass\n        elif xsd_type.has_mixed_content():\n            value = UntypedAtomic(item.text or '')\n            return TypedElement(item, xsd_type, value)\n        elif xsd_type.is_element_only():\n            return TypedElement(item, xsd_type, None)\n        elif xsd_type.is_empty():\n            return TypedElement(item, xsd_type, None)\n        elif item.get(XSI_NIL) and getattr(xsd_type.parent, 'nillable', None):\n            return TypedElement(item, xsd_type, None)\n\n        if self.parser.xsd_version == '1.0':\n            atomic_types = xsd10_atomic_types\n        else:\n            atomic_types = xsd11_atomic_types\n\n        try:\n            builder: Any = atomic_types[xsd_type.name]\n        except KeyError:\n            if self.parser.schema is None:\n                builder = UntypedAtomic\n            else:\n                try:\n                    primitive_type = self.parser.schema.get_primitive_type(xsd_type)\n                    builder = atomic_types[primitive_type.name]\n                except KeyError:\n                    builder = UntypedAtomic\n                else:\n                    if isinstance(builder, (AbstractDateTime, Duration)):\n                        builder = builder.fromstring\n                    elif issubclass(builder, QName):\n                        builder = self.cast_to_qname\n        else:\n            if issubclass(builder, (AbstractDateTime, Duration)):\n                builder = builder.fromstring\n            elif issubclass(builder, QName):\n                builder = self.cast_to_qname\n\n        if isinstance(item, AttributeNode):\n            if xsd_type.is_valid(item.value):\n                return TypedAttribute(item, xsd_type, builder(item.value))\n        elif item.text is not None:\n            if xsd_type.is_valid(item.text):\n                return TypedElement(item, xsd_type, builder(item.text))\n        elif item.get(XSI_NIL) in ('1', 'true'):\n            return TypedElement(item, atomic_types[XSD_ANY_ATOMIC_TYPE], '')\n\n        msg = \"Type {!r} does not match sequence type of {!r}\"\n        raise self.wrong_sequence_type(msg.format(xsd_type, item)) from None\n\n    def cast_to_qname(self, qname: str) -> QName:\n        \"\"\"Cast a prefixed qname string to a QName object.\"\"\"\n        try:\n            if ':' not in qname:\n                return QName(self.parser.namespaces.get(''), qname.strip())\n            pfx, _ = qname.strip().split(':')\n            return QName(self.parser.namespaces[pfx], qname)\n        except ValueError:\n            msg = 'invalid value {!r} for an xs:QName'.format(qname.strip())\n            raise self.error('FORG0001', msg)\n        except KeyError as err:\n            raise self.error('FONS0004', 'no namespace found for prefix {}'.format(err))\n\n    def cast_to_double(self, value: Union[SupportsFloat, str]) -> float:\n        \"\"\"Cast a value to xs:double.\"\"\"\n        try:\n            if self.parser.xsd_version == '1.0':\n                return cast(float, DoubleProxy10(value))\n            return cast(float, DoubleProxy(value))\n        except ValueError as err:\n            raise self.error('FORG0001', str(err))  # str or UntypedAtomic\n\n    def cast_to_primitive_type(self, obj: Any, type_name: str) -> Any:\n        if obj is None or not type_name.startswith('xs:') or type_name.count(':') != 1:\n            return obj\n\n        values = obj if isinstance(obj, list) else [obj]\n        if not values:\n            return obj\n\n        if type_name[-1] in '+*?':\n            type_name = type_name[:-1]\n\n        result = []\n        for v in values:\n            if self.parser.is_instance(v, XSD_DECIMAL):\n                if type_name == 'xs:double':\n                    result.append(float(v))\n                    continue\n                elif type_name == 'xs:float':\n                    if self.parser.xsd_version == '1.0':\n                        result.append(Float10(v))\n                    else:\n                        result.append(Float(v))\n                    continue\n\n            result.append(v)\n\n        if isinstance(obj, list) or len(result) > 1:\n            return result\n        return result[0]\n\n    ###\n    # XPath data accessors base functions\n    def boolean_value(self, obj: Any) -> bool:\n        \"\"\"\n        The effective boolean value, as computed by fn:boolean().\n        \"\"\"\n        if isinstance(obj, list):\n            if not obj:\n                return False\n            elif is_xpath_node(obj[0]):\n                return True\n            elif len(obj) > 1:\n                message = \"effective boolean value is not defined for a sequence \" \\\n                          \"of two or more items not starting with an XPath node.\"\n                raise self.error('FORG0006', message)\n            else:\n                obj = obj[0]\n\n        if isinstance(obj, (int, str, UntypedAtomic, AnyURI)):  # Include bool\n            return bool(obj)\n        elif isinstance(obj, (float, Decimal)):\n            return False if math.isnan(obj) else bool(obj)\n        elif obj is None:\n            return False\n        elif is_xpath_node(obj):\n            return True\n        else:\n            message = \"effective boolean value is not defined for {!r}.\".format(type(obj))\n            raise self.error('FORG0006', message)\n\n    def data_value(self, obj: Any) -> Optional[AtomicValueType]:\n        \"\"\"\n        The typed value, as computed by fn:data() on each item.\n        Returns an instance of UntypedAtomic for untyped data.\n\n        https://www.w3.org/TR/xpath20/#dt-typed-value\n        \"\"\"\n        if obj is None:\n            return None\n        elif isinstance(obj, XPathNode):\n            if isinstance(obj, TextNode):\n                return UntypedAtomic(obj.value)\n            elif isinstance(obj, AttributeNode) and isinstance(obj.value, str):\n                return UntypedAtomic(obj.value)\n            return cast(Optional[AtomicValueType], obj.value)  # a typed node or a NamespaceNode\n\n        elif isinstance(obj, XPathFunction):\n            raise self.error('FOTY0013', f\"{obj.label!r} has no typed value\")\n\n        elif is_schema_node(obj):\n            return self.parser.get_atomic_value(obj.type)\n\n        elif hasattr(obj, 'tag'):\n            if is_comment_node(obj) or is_processing_instruction_node(obj):\n                return cast(str, obj.text)\n            elif hasattr(obj, 'attrib') and hasattr(obj, 'text'):\n                return UntypedAtomic(''.join(etree_iter_strings(obj)))\n            else:\n                return None\n        elif is_document_node(obj):\n            value = ''.join(etree_iter_strings(obj.getroot()))\n            return UntypedAtomic(value)\n        else:\n            return cast(AtomicValueType, obj)\n\n    def string_value(self, obj: Any) -> str:\n        \"\"\"\n        The string value, as computed by fn:string().\n        \"\"\"\n        if obj is None:\n            return ''\n        elif isinstance(obj, XPathNode):\n            if isinstance(obj, TypedElement):\n                if obj.value is None:\n                    return ''.join(etree_iter_strings(obj))\n                return str(obj.value)\n            elif isinstance(obj, (AttributeNode, TypedAttribute)):\n                return str(obj.value)\n            else:\n                return cast(str, obj.value)  # TextNode or NamespaceNode\n        elif is_schema_node(obj):\n            return str(self.parser.get_atomic_value(obj.type))\n        elif hasattr(obj, 'tag'):\n            if is_comment_node(obj) or is_processing_instruction_node(obj):\n                return cast(str, obj.text)\n            elif hasattr(obj, 'attrib') and hasattr(obj, 'text'):\n                return ''.join(etree_iter_strings(obj))\n        elif is_document_node(obj):\n            return ''.join(etree_iter_strings(obj.getroot()))\n        elif isinstance(obj, bool):\n            return 'true' if obj else 'false'\n        elif isinstance(obj, Decimal):\n            value = format(obj, 'f')\n            if '.' in value:\n                return value.rstrip('0').rstrip('.')\n            return value\n\n        elif isinstance(obj, float):\n            if math.isnan(obj):\n                return 'NaN'\n            elif math.isinf(obj):\n                return str(obj).upper()\n\n            value = str(obj)\n            if '.' in value:\n                value = value.rstrip('0').rstrip('.')\n            if '+' in value:\n                value = value.replace('+', '')\n            if 'e' in value:\n                return value.upper()\n            return value\n\n        elif isinstance(obj, XPathFunction):\n            raise self.error('FOTY0014', f\"{obj.label!r} has no string value\")\n\n        return str(obj)\n\n    def number_value(self, obj: Any) -> float:\n        \"\"\"\n        The numeric value, as computed by fn:number() on each item. Returns a float value.\n        \"\"\"\n        try:\n            return float(self.string_value(obj) if is_xpath_node(obj) else obj)\n        except (TypeError, ValueError):\n            return float('nan')\n\n    ###\n    # Error handling helpers\n    def error_code(self, code: str) -> str:\n        \"\"\"Returns a prefixed error code.\"\"\"\n        if self.parser.namespaces.get('err') == XQT_ERRORS_NAMESPACE:\n            return 'err:%s' % code\n\n        for pfx, uri in self.parser.namespaces.items():\n            if uri == XQT_ERRORS_NAMESPACE:\n                return '%s:%s' % (pfx, code) if pfx else code\n\n        return code  # returns an unprefixed code (without prefix the namespace is not checked)\n\n    def error(self, code: Union[str, QName],\n              message_or_error: Union[None, str, Exception] = None) -> ElementPathError:\n        \"\"\"\n        Returns an XPath error instance related with a code. An XPath/XQuery/XSLT\n        error code is an alphanumeric token starting with four uppercase letters\n        and ending with four digits.\n\n        :param code: the error code as QName or string.\n        :param message_or_error: an optional custom message or an exception.\n        \"\"\"\n        namespace: Optional[str]\n\n        if isinstance(code, QName):\n            namespace = code.uri\n            code = code.local_name\n        elif ':' not in code:\n            namespace = None\n        else:\n            try:\n                prefix, code = code.split(':')\n            except ValueError:\n                raise ElementPathValueError(\n                    message='%r is not a prefixed name' % code,\n                    code=self.error_code('XPTY0004'),\n                    token=self,\n                )\n            else:\n                namespace = self.parser.namespaces.get(prefix)\n\n        if namespace and namespace != XQT_ERRORS_NAMESPACE:\n            raise ElementPathValueError(\n                message='%r namespace is required' % XQT_ERRORS_NAMESPACE,\n                code=self.error_code('XPTY0004'),\n                token=self,\n            )\n\n        try:\n            error_class, default_message = XPATH_ERROR_CODES[code]\n        except KeyError:\n            raise ElementPathValueError(\n                message='unknown XPath error code %r' % code,\n                code=self.error_code('XPTY0004'),\n                token=self,\n            )\n\n        if message_or_error is None:\n            message = default_message\n        elif isinstance(message_or_error, str):\n            message = message_or_error\n        elif isinstance(message_or_error, ElementPathError):\n            message = message_or_error.message\n        else:\n            message = str(message_or_error)\n\n        return error_class(message, code=self.error_code(code), token=self)\n\n    # Shortcuts for XPath errors, only the wrong_syntax\n    def expected(self, *symbols: str,\n                 message: Optional[str] = None,\n                 code: str = 'XPST0003') -> None:\n        if symbols and self.symbol not in symbols:\n            raise self.wrong_syntax(message, code)\n\n    def unexpected(self, *symbols: str,\n                   message: Optional[str] = None,\n                   code: str = 'XPST0003') -> None:\n        if not symbols or self.symbol in symbols:\n            raise self.wrong_syntax(message, code)\n\n    def wrong_syntax(self, message: Optional[str] = None,  # type: ignore[override]\n                     code: str = 'XPST0003') -> ElementPathError:\n        if self.label == 'function':\n            code = 'XPST0017'\n\n        if message:\n            return self.error(code, message)\n\n        error = super(XPathToken, self).wrong_syntax(message)\n        return self.error(code, str(error))\n\n    def wrong_value(self, message: Optional[str] = None) -> ElementPathValueError:\n        return cast(ElementPathValueError, self.error('FOCA0002', message))\n\n    def wrong_type(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('FORG0006', message))\n\n    def missing_context(self, message: Optional[str] = None) -> MissingContextError:\n        return cast(MissingContextError, self.error('XPDY0002', message))\n\n    def wrong_context_type(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('XPTY0004', message))\n\n    def missing_name(self, message: Optional[str] = None) -> ElementPathNameError:\n        return cast(ElementPathNameError, self.error('XPST0008', message))\n\n    def missing_axis(self, message: Optional[str] = None) \\\n            -> Union[ElementPathNameError, ElementPathSyntaxError]:\n        if self.parser.compatibility_mode:\n            return cast(ElementPathNameError, self.error('XPST0010', message))\n        return cast(ElementPathSyntaxError, self.error('XPST0003', message))\n\n    def wrong_nargs(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('XPST0017', message))\n\n    def wrong_sequence_type(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('XPDY0050', message))\n\n    def unknown_atomic_type(self, message: Optional[str] = None) -> ElementPathNameError:\n        return cast(ElementPathNameError, self.error('XPST0051', message))\nelementpath/namespaces.py\nXSD_NAMESPACE = \"http://www.w3.org/2001/XMLSchema\"\nelementpath/xpath_token.py\nclass ValueToken(XPathToken):\n    \"\"\"\n    A dummy token for encapsulating a value.\n    \"\"\"\n    symbol = '(value)'\n\n    def evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        return self.value\n\n    def select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        if isinstance(self.value, list):\n            yield from self.value\n        elif self.value is not None:\n            yield self.value\nelementpath/xpath30/xpath30_parser.py\nclass XPath30Parser(XPath2Parser):\n    \"\"\"\n    XPath 3.0 expression parser class. Accepts all XPath 2.0 options as keyword\n    arguments, but the *strict* option is ignored because XPath 3.0+ has braced\n    URI literals and the expanded name syntax is not compatible.\n\n    :param args: the same positional arguments of class :class:`XPath2Parser`.\n    :param decimal_formats: a mapping with statically known decimal formats.\n    :param kwargs: the same keyword arguments of class :class:`XPath2Parser`.\n    \"\"\"\n    version = '3.0'\n\n    SYMBOLS = XPath2Parser.SYMBOLS | {\n        'Q{',  # see BracedURILiteral rule\n        '||',  # concat operator\n        '!',   # Simple map operator\n\n        # Math functions (trigonometric and exponential)\n        'pi', 'exp', 'exp10', 'log', 'log10', 'pow', 'sqrt',\n        'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'atan2',\n\n        # Formatting functions\n        'format-integer', 'format-number', 'format-dateTime',\n        'format-date', 'format-time',\n\n        # String functions that use regular expressions\n        'analyze-string',\n\n        # Functions and operators on nodes\n        'path', 'has-children', 'innermost', 'outermost',\n\n        # Functions and operators on sequences\n        'head', 'tail', 'generate-id', 'uri-collection',\n        'unparsed-text', 'unparsed-text-lines', 'unparsed-text-available',\n        'environment-variable', 'available-environment-variables',\n\n        # Parsing and serializing\n        'parse-xml', 'parse-xml-fragment', 'serialize',\n\n        # Higher-order functions\n        'function-lookup', 'function-name', 'function-arity', '#', '?',\n        'for-each', 'filter', 'fold-left', 'fold-right', 'for-each-pair',\n\n        # Expressions and node type functions\n        'function', 'let', ':=', 'namespace-node',\n\n        # XSD list-types constructor functions\n        'ENTITIES', 'IDREFS', 'NMTOKENS',\n    }\n\n    DEFAULT_NAMESPACES = {\n        'math': XPATH_MATH_FUNCTIONS_NAMESPACE, **XPath2Parser.DEFAULT_NAMESPACES\n    }\n    PATH_STEP_SYMBOLS = {\n        '(integer)', '(string)', '(float)', '(decimal)', '(name)',\n        '*', '@', '..', '.', '(', '{', 'Q{', '$',\n    }\n\n    decimal_formats: DecimalFormatsType = {\n        None: {\n            'decimal-separator': '.',\n            'grouping-separator': ',',\n            'exponent-separator': 'e',\n            'infinity': 'Infinity',\n            'minus-sign': '-',\n            'NaN': 'NaN',\n            'percent': '%',\n            'per-mille': '‰',\n            'zero-digit': '0',\n            'digit': '#',\n            'pattern-separator': ';',\n        }\n    }\n\n    # https://www.w3.org/TR/xpath-30/#id-reserved-fn-names\n    RESERVED_FUNCTION_NAMES = {\n        'attribute', 'comment', 'document-node', 'element', 'empty-sequence',\n        'function', 'if', 'item', 'namespace-node', 'node', 'processing-instruction',\n        'schema-attribute', 'schema-element', 'switch', 'text', 'typeswitch',\n    }\n\n    function_signatures = XPath2Parser.function_signatures.copy()\n\n    def __init__(self, *args: Any, decimal_formats: Optional[DecimalFormatsType] = None,\n                 **kwargs: Any) -> None:\n        kwargs.pop('strict', None)\n        super(XPath30Parser, self).__init__(*args, **kwargs)\n\n        if decimal_formats is not None:\n            self.decimal_formats = deepcopy(self.decimal_formats)\n\n            for k, v in decimal_formats.items():\n                if k is not None:\n                    self.decimal_formats[k] = self.decimal_formats[None].copy()\n                    self.decimal_formats[k].update(v)\n\n            if None in decimal_formats:\n                self.decimal_formats[None].update(decimal_formats[None])\nelementpath/xpath_nodes.py\nclass TypedElement(XPathNode):\n    \"\"\"\n    A class for processing typed element nodes.\n\n    :param elem: the linked element. Can be an Element, or an XSD element \\\n    when XPath is applied on a schema.\n    :param xsd_type: the reference XSD type.\n    :param value: the decoded value. Can be `None` for empty or element-only elements.\"\n    \"\"\"\n    def __init__(self, elem: ElementProtocol, xsd_type: Any, value: Any) -> None:\n        self.elem = elem\n        self.xsd_type = xsd_type\n        self.value = value\n\n    @property\n    def kind(self) -> str:\n        return 'element'\n\n    @property\n    def name(self) -> str:\n        return self.elem.tag\n\n    @property\n    def tag(self) -> str:\n        return self.elem.tag\n\n    def __repr__(self) -> str:\n        return '%s(tag=%r)' % (self.__class__.__name__, self.elem.tag)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.elem is other.elem and \\\n            self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.elem, self.value))\nelementpath/xpath_context.py\nclass XPathSchemaContext(XPathContext):\n    \"\"\"\n    The XPath dynamic context base class for schema bounded parsers. Use this class\n    as dynamic context for schema instances in order to perform a schema-based type\n    checking during the static analysis phase. Don't use this as dynamic context on\n    XML instances.\n    \"\"\"\n    iter_children_or_self: Callable[..., Iterator[Union[XsdElementProtocol, XMLSchemaProtocol]]]\n    root: XMLSchemaProtocol\nelementpath/datatypes/qname.py\nclass QName(AbstractQName):\n    name = 'QName'\nelementpath/namespaces.py\nXPATH_FUNCTIONS_NAMESPACE = \"http://www.w3.org/2005/xpath-functions\"\nelementpath/xpath_token.py\nclass XPathFunction(XPathToken):\n    \"\"\"\n    A token for processing XPath functions.\n    \"\"\"\n    _name: Optional[QName] = None\n    pattern = r'(?<!\\$)\\b[^\\d\\W][\\w.\\-\\xb7\\u0300-\\u036F\\u203F\\u2040]*' \\\n              r'(?=\\s*(?:\\(\\:.*\\:\\))?\\s*\\((?!\\:))'\n\n    sequence_types: Tuple[str, ...] = ()\n    \"Sequence types of arguments and of the return value of the function.\"\n\n    nargs: NargsType = None\n    \"Number of arguments: a single value or a couple with None that means unbounded.\"\n\n    body: Optional[XPathToken] = None\n    \"Body of anonymous inline function.\"\n\n    variables: Optional[Dict[str, Any]] = None\n    \"Optional variables linked by let and for expressions.\"\n\n    def __init__(self, parser: 'XPath1Parser', nargs: Optional[int] = None) -> None:\n        super().__init__(parser)\n        if isinstance(nargs, int) and nargs != self.nargs:\n            if nargs < 0:\n                raise self.error('XPST0017', 'number of arguments must be non negative')\n            elif self.nargs is None:\n                self.nargs = nargs\n            elif isinstance(self.nargs, int):\n                raise self.error('XPST0017', 'incongruent number of arguments')\n            elif self.nargs[0] > nargs or self.nargs[1] is not None and self.nargs[1] < nargs:\n                raise self.error('XPST0017', 'incongruent number of arguments')\n            else:\n                self.nargs = nargs\n\n    def __call__(self, context: Optional[XPathContext] = None,\n                 argument_list: Optional[Union[\n                     XPathToken,\n                     List[Union[XPathToken, AtomicValueType]],\n                     Tuple[Union[XPathToken, AtomicValueType], ...]\n                 ]] = None) -> Any:\n\n        args: List[Any] = []\n        if isinstance(argument_list, (list, tuple)):\n            args.extend(argument_list)\n        elif isinstance(argument_list, XPathToken):\n            tk = argument_list\n            while True:\n                if tk.symbol == ',':\n                    args.append(tk[1].evaluate(context))\n                    tk = tk[0]\n                else:\n                    args.append(tk.evaluate(context))\n                    break\n            args.reverse()\n\n        # Check provided argument with arity\n        if self.nargs is None or self.nargs == len(args):\n            pass\n        elif isinstance(self.nargs, tuple):\n            if len(args) < self.nargs[0]:\n                raise self.error('XPTY0004', \"missing required arguments\")\n            elif self.nargs[1] is not None and len(args) > self.nargs[1]:\n                raise self.error('XPTY0004', \"too many arguments\")\n        elif self.nargs > len(args):\n            raise self.error('XPTY0004', \"missing required arguments\")\n        else:\n            raise self.error('XPTY0004', \"too many arguments\")\n\n        context = copy(context)\n        if self.variables is not None and context is not None:\n            context.variables.update(self.variables)\n\n        if self.symbol == 'function':\n            if context is None:\n                raise self.missing_context()\n            elif not args and self:\n                if context.item is None:\n                    if is_document_node(context.root):\n                        context.item = cast(DocumentProtocol, context.root).getroot()\n                    else:\n                        context.item = context.root\n\n                args.append(context.item)\n\n            partial_function = False\n            if self.variables is None:\n                self.variables = {}\n\n            for variable, sequence_type, value in zip(self, self.sequence_types, args):\n                varname = cast(str, variable[0].value)\n\n                if isinstance(value, XPathToken) and value.symbol == '?':\n                    partial_function = True\n                    continue\n                elif isinstance(value, XPathFunction) and sequence_type.startswith('function('):\n                    if not value.match_function_test(sequence_type, as_argument=True):\n                        msg = \"argument {!r}: {} does not match sequence type {}\"\n                        raise self.error('XPTY0004', msg.format(varname, value, sequence_type))\n\n                elif not self.parser.match_sequence_type(value, sequence_type):\n                    value = self.cast_to_primitive_type(value, sequence_type)\n                    if not self.parser.match_sequence_type(value, sequence_type):\n                        msg = \"argument {!r}: {} does not match sequence type {}\"\n                        raise self.error('XPTY0004', msg.format(varname, value, sequence_type))\n\n                context.variables[varname] = self.variables[varname] = value\n\n            if partial_function:\n                return self\n\n        elif self.label == 'partial function':\n            for value, tk in zip(args, filter(lambda x: x.symbol == '?', self)):\n                if isinstance(value, XPathToken):\n                    tk.value = value.evaluate(context)\n                else:\n                    assert not isinstance(value, Token), \"An atomic value or None expected\"\n                    tk.value = value\n        else:\n            self.clear()\n            for value in args:\n                if isinstance(value, XPathToken):\n                    self.append(value)\n                else:\n                    assert not isinstance(value, Token), \"An atomic value or None expected\"\n                    self.append(ValueToken(self.parser, value=value))\n\n            if any(tk.symbol == '?' for tk in self._items):\n                self._partial_function()\n                return self\n\n        if isinstance(self.label, MultiLabel):\n            # Disambiguate multi-label tokens\n            if self.namespace == XSD_NAMESPACE and \\\n                    'constructor function' in self.label.values:\n                self.label = 'constructor function'\n            else:\n                for label in self.label.values:\n                    if label.endswith('function'):\n                        self.label = label\n                        break\n\n        if self.label == 'partial function':\n            result = self._partial_evaluate(context)\n        elif self.body is not None:\n            assert self.label == 'inline function'\n            result = self.body.evaluate(context)\n        else:\n            result = self.evaluate(context)\n\n        if isinstance(result, XPathToken) and result.symbol == '?':\n            pass\n        elif not self.parser.match_sequence_type(result, self.sequence_types[-1]):\n            result = self.cast_to_primitive_type(result, self.sequence_types[-1])\n            if not self.parser.match_sequence_type(result, self.sequence_types[-1]):\n                msg = \"{!r} does not match sequence type {}\"\n                self.parser.match_sequence_type(result, self.sequence_types[-1])\n                raise self.error('XPTY0004', msg.format(result, self.sequence_types[-1]))\n\n        return result\n\n    @property\n    def source(self) -> str:\n        if self.label == 'function test':\n            if len(self.sequence_types) == 1 and self.sequence_types[0] == '*':\n                return 'function(*)'\n            else:\n                return 'function(%s) as %s' % (\n                    ', '.join(self.sequence_types[:-1]), self.sequence_types[-1]\n                )\n        elif self.label in ('sequence type', 'kind test', ''):\n            return '%s(%s)%s' % (\n                self.symbol, ', '.join(item.source for item in self), self.occurrence or ''\n            )\n        return '%s(%s)' % (self.symbol, ', '.join(item.source for item in self))\n\n    @property\n    def name(self) -> Optional[QName]:\n        if self._name is not None:\n            return self._name\n        elif self.symbol == 'function':\n            return None\n        elif self.label == 'partial function':\n            return None\n        elif not self.namespace or self.namespace == XPATH_FUNCTIONS_NAMESPACE:\n            self._name = QName(XPATH_FUNCTIONS_NAMESPACE, 'fn:%s' % self.symbol)\n        elif self.namespace == XSD_NAMESPACE:\n            self._name = QName(XSD_NAMESPACE, 'xs:%s' % self.symbol)\n        elif self.namespace == XPATH_MATH_FUNCTIONS_NAMESPACE:\n            self._name = QName(XPATH_MATH_FUNCTIONS_NAMESPACE, 'math:%s' % self.symbol)\n        else:\n            for pfx, uri in self.parser.namespaces.items():\n                if uri == self.namespace:\n                    self._name = QName(uri, f'{pfx}:{self.symbol}')\n                    break\n            else:\n                self._name = QName(self.namespace, self.symbol)\n\n        return self._name\n\n    @property\n    def arity(self) -> int:\n        if isinstance(self.nargs, int):\n            return self.nargs\n        return len(self._items)\n\n    def nud(self) -> 'XPathFunction':\n        code = 'XPST0017' if self.label == 'function' else 'XPST0003'\n        self.value = None\n        self.parser.advance('(')\n        if self.nargs is None:\n            del self._items[:]\n            if self.parser.next_token.symbol in (')', '(end)'):\n                raise self.error(code, 'at least an argument is required')\n            while True:\n                self.append(self.parser.expression(5))\n                if self.parser.next_token.symbol != ',':\n                    break\n                self.parser.advance()\n        elif self.nargs == 0:\n            if self.parser.next_token.symbol != ')':\n                if self.parser.next_token.symbol != '(end)':\n                    raise self.error(code, '%s has no arguments' % str(self))\n                raise self.parser.next_token.wrong_syntax()\n            self.parser.advance()\n            return self\n        else:\n            if isinstance(self.nargs, (tuple, list)):\n                min_args, max_args = self.nargs\n            else:\n                min_args = max_args = self.nargs\n\n            k = 0\n            while k < min_args:\n                if self.parser.next_token.symbol in (')', '(end)'):\n                    msg = 'Too few arguments: expected at least %s arguments' % min_args\n                    raise self.wrong_nargs(msg if min_args > 1 else msg[:-1])\n\n                self._items[k:] = self.parser.expression(5),\n                k += 1\n                if k < min_args:\n                    if self.parser.next_token.symbol == ')':\n                        msg = 'Too few arguments: expected at least %s arguments' % min_args\n                        raise self.error(code, msg if min_args > 1 else msg[:-1])\n                    self.parser.advance(',')\n\n            while max_args is None or k < max_args:\n                if self.parser.next_token.symbol == ',':\n                    self.parser.advance(',')\n                    self._items[k:] = self.parser.expression(5),\n                elif k == 0 and self.parser.next_token.symbol != ')':\n                    self._items[k:] = self.parser.expression(5),\n                else:\n                    break  # pragma: no cover\n                k += 1\n\n            if self.parser.next_token.symbol == ',':\n                msg = 'Too many arguments: expected at most %s arguments' % max_args\n                raise self.error(code, msg if max_args != 1 else msg[:-1])\n\n        self.parser.advance(')')\n        if any(tk.symbol == '?' for tk in self._items):\n            self._partial_function()\n\n        return self\n\n    def match_function_test(self, function_test: str, as_argument: bool = False) -> bool:\n        \"\"\"\n        Match if function signature is a subtype of provided *function_test*.\n        For default return type is covariant and arguments are contravariant.\n        If *as_argument* is `True` the match is inverted and also the return\n        type is considered contravariant.\n\n        References:\n          https://www.w3.org/TR/xpath-31/#id-function-test\n          https://www.w3.org/TR/xpath-31/#id-sequencetype-subtype\n        \"\"\"\n        if not function_test.startswith('function('):\n            return False\n        elif function_test == 'function(*)':\n            return True\n\n        parts = function_test[9:].partition(') as ')\n        if not parts[1] or not parts[2]:\n            return False\n\n        sequence_types = parts[0].split(', ')\n        sequence_types.append(parts[2])\n\n        signature = [x for x in self.sequence_types[:self.arity]]\n        signature.append(self.sequence_types[-1])\n\n        if len(sequence_types) != len(signature):\n            return False\n\n        if as_argument:\n            iterator = zip(sequence_types, signature)\n        else:\n            iterator = zip(signature, sequence_types)\n\n        k = 0\n        for fst, st in iterator:\n            k += 1\n            if not as_argument and k == len(sequence_types):\n                st, fst = fst, st\n\n            if st[-1] in '*+?':\n                st_occurs = st[-1]\n                st = st[:-1]\n            else:\n                st_occurs = ''\n\n            if fst[-1] in '*+?':\n                fst_occurs = fst[-1]\n                fst = fst[:-1]\n            else:\n                fst_occurs = ''\n\n            if st_occurs == fst_occurs or fst_occurs == '*':\n                pass\n            elif not fst_occurs:\n                if st_occurs not in '?*':\n                    return False\n            elif fst_occurs == '+':\n                if st_occurs:\n                    return False\n            elif st_occurs:\n                return False\n\n            if st == fst:\n                continue\n            elif fst == 'item()':\n                continue\n            elif st == 'item()':\n                return False\n            elif fst.startswith('xs:') ^ st.startswith('xs:'):\n                return False\n            elif fst.startswith('xs:'):\n                if not issubclass(xsd11_atomic_types[st[3:]],\n                                  xsd11_atomic_types[fst[3:]]):\n                    return False\n            elif fst != 'node()':\n                return False\n\n        return True\n\n    def _partial_function(self) -> None:\n        \"\"\"Convert a named function to an anonymous partial function.\"\"\"\n        def evaluate(context: Optional[XPathContext] = None) -> Any:\n            return self\n\n        def select(context: Optional[XPathContext] = None) -> Any:\n            yield self\n\n        if self.__class__.evaluate is not XPathToken.evaluate:\n            setattr(self, '_partial_evaluate', self.evaluate)\n        if self.__class__.select is not XPathToken.select:\n            setattr(self, '_partial_select', self.select)\n\n        setattr(self, 'evaluate', evaluate)\n        setattr(self, 'select', select)\n\n        self._name = None\n        self.label = 'partial function'\n        self.nargs = len([tk for tk in self._items if tk.symbol == '?'])\n\n    def _partial_evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        return [x for x in self._partial_select(context)]\n\n    def _partial_select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        item = self._partial_evaluate(context)\n        if item is not None:\n            if isinstance(item, list):\n                yield from item\n            else:\n                if context is not None:\n                    context.item = item\n                yield item\n", "answers": ["            elif isinstance(result, TypedElement):"], "length": 6293, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "ee505459c8831993d6d076ef9ee075e8cf412a45f09a9dfb"}
{"input": "import java.util.Arrays;\nimport java.util.List;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport com.picassotransformations.StackBlurTransformation;\nimport com.picassotransformations.jhlabs.BlockTransformation;\nimport com.picassotransformations.jhlabs.BlurTransformation;\nimport com.picassotransformations.jhlabs.ChannelMixTransformation;\nimport com.picassotransformations.jhlabs.ContrastTransformation;\nimport com.picassotransformations.jhlabs.CurvesTransformation;\nimport com.picassotransformations.jhlabs.DiffusionTransformation;\nimport com.picassotransformations.jhlabs.DitherTransformation;\nimport com.picassotransformations.jhlabs.EdgeTransformation;\nimport com.picassotransformations.jhlabs.EmbossTransformation;\nimport com.picassotransformations.jhlabs.EqualizeTransformation;\nimport com.picassotransformations.jhlabs.ExposureTransformation;\nimport com.picassotransformations.jhlabs.GainTransformation;\nimport com.picassotransformations.jhlabs.GrayTransformation;\nimport com.picassotransformations.jhlabs.GrayscaleTransformation;\nimport com.picassotransformations.jhlabs.HSBAdjustTransformation;\nimport com.picassotransformations.jhlabs.InvertTransformation;\nimport com.picassotransformations.jhlabs.KaleidoscopeTransformation;\nimport com.picassotransformations.jhlabs.LevelsTransformation;\nimport com.picassotransformations.jhlabs.LookupTransformation;\nimport com.picassotransformations.jhlabs.MapColorsTransformation;\nimport com.picassotransformations.jhlabs.MarbleTransformation;\nimport com.picassotransformations.jhlabs.MaskTransformation;\nimport com.picassotransformations.jhlabs.MirrorTransformation;\nimport com.picassotransformations.jhlabs.PolarTransformation;\nimport com.picassotransformations.jhlabs.PosterizeTransformation;\nimport com.picassotransformations.jhlabs.QuantizeTransformation;\nimport com.picassotransformations.jhlabs.RGBAdjustTransformation;\nimport com.picassotransformations.jhlabs.RescaleTransformation;\nimport com.picassotransformations.jhlabs.SolarizeTransformation;\nimport com.picassotransformations.jhlabs.ThresholdTransformation;\nimport com.picassotransformations.jhlabs.TritoneTransformation;\nimport com.picassotransformations.renderscript.RSGaussianBlurTransformation;\nimport com.squareup.picasso.Transformation;\n/*\n * Copyright (C) 2014 Tanner Perrien\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.picassotransformations;\n\n\n\n\n\npublic enum TransformationCategory implements Parcelable {\n\n    COLOR_ADJUSTMENT(\"Color Adjustment\",\n            Arrays.asList(\n                    new ChannelMixTransformation(),\n                    new ContrastTransformation().setBrightness(.7f).setContrast(.5f),\n                    new CurvesTransformation(),\n                    new DiffusionTransformation(),\n                    new DitherTransformation(),\n                    new ExposureTransformation(),\n                    new GainTransformation(),\n                    new GrayTransformation(),\n                    new GrayscaleTransformation(),", "context": "picasso-transformations/src/main/java/com/picassotransformations/jhlabs/ExposureTransformation.java\npublic class ExposureTransformation extends TransferTransformation {\n\n    private float exposure = 1.0f;\n\n    protected float transferFunction(float f) {\n        return 1 - (float) Math.exp(-f * exposure);\n    }\n\n    /**\n     * Set the exposure level.\n     * \n     * @param exposure the exposure level\n     * @min-value 0\n     * @max-value 5+\n     * @see #getExposure\n     */\n    public void setExposure(float exposure) {\n        this.exposure = exposure;\n        initialized = false;\n    }\n\n    /**\n     * Get the exposure level.\n     * \n     * @return the exposure level\n     * @see #setExposure\n     */\n    public float getExposure() {\n        return exposure;\n    }\n\n    public String toString() {\n        return \"Colors/Exposure...\";\n    }\n\n    @Override\n    public String key() {\n        return ExposureTransformation.class.getCanonicalName() + \"-\" + exposure;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/CurvesTransformation.java\npublic class CurvesTransformation extends TransferTransformation {\n\n    private Curve[] curves = new Curve[1];\n\n    public CurvesTransformation() {\n        curves = new Curve[3];\n        curves[0] = new Curve();\n        curves[1] = new Curve();\n        curves[2] = new Curve();\n    }\n\n    protected void initialize() {\n        initialized = true;\n        if (curves.length == 1)\n            rTable = gTable = bTable = curves[0].makeTable();\n        else {\n            rTable = curves[0].makeTable();\n            gTable = curves[1].makeTable();\n            bTable = curves[2].makeTable();\n        }\n    }\n\n    public void setCurve(Curve curve) {\n        curves = new Curve[] {\n            curve\n        };\n        initialized = false;\n    }\n\n    public void setCurves(Curve[] curves) {\n        if (curves == null || (curves.length != 1 && curves.length != 3))\n            throw new IllegalArgumentException(\"Curves must be length 1 or 3\");\n        this.curves = curves;\n        initialized = false;\n    }\n\n    public Curve[] getCurves() {\n        return curves;\n    }\n\n    public String toString() {\n        return \"Colors/Curves...\";\n    }\n\n    @Override\n    public String key() {\n        return CurvesTransformation.class.getCanonicalName() + \"-\" + curves.hashCode();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/EdgeTransformation.java\npublic class EdgeTransformation extends WholeImageTransformation {\n\t\n\tpublic final static float R2 = (float)Math.sqrt(2);\n\n\tpublic final static float[] ROBERTS_V = {\n\t\t0,  0, -1,\n\t\t0,  1,  0,\n\t\t0,  0,  0,\n\t};\n\tpublic final static float[] ROBERTS_H = {\n\t\t-1,  0,  0,\n\t\t0,  1,  0,\n\t\t0,  0,  0,\n\t};\n\tpublic final static float[] PREWITT_V = {\n\t\t-1,  0,  1,\n\t\t-1,  0,  1,\n\t\t-1,  0,  1,\n\t};\n\tpublic final static float[] PREWITT_H = {\n\t\t-1, -1, -1,\n\t\t0,  0,  0,\n\t\t1,  1,  1,\n\t};\n\tpublic final static float[] SOBEL_V = {\n\t\t-1,  0,  1,\n\t\t-2,  0,  2,\n\t\t-1,  0,  1,\n\t};\n\tpublic static float[] SOBEL_H = {\n\t\t-1, -2, -1,\n\t\t0,  0,  0,\n\t\t1,  2,  1,\n\t};\n\tpublic final static float[] FREI_CHEN_V = {\n\t\t-1,  0,  1,\n\t\t-R2,  0,  R2,\n\t\t-1,  0,  1,\n\t};\n\tpublic static float[] FREI_CHEN_H = {\n\t\t-1, -R2, -1,\n\t\t0,  0,  0,\n\t\t1,  R2,  1,\n\t};\n\n\tprotected float[] vEdgeMatrix = SOBEL_V;\n\tprotected float[] hEdgeMatrix = SOBEL_H;\n\n\tpublic EdgeTransformation() {\n\t}\n\n\tpublic void setVEdgeMatrix(float[] vEdgeMatrix) {\n\t\tthis.vEdgeMatrix = vEdgeMatrix;\n\t}\n\n\tpublic float[] getVEdgeMatrix() {\n\t\treturn vEdgeMatrix;\n\t}\n\n\tpublic void setHEdgeMatrix(float[] hEdgeMatrix) {\n\t\tthis.hEdgeMatrix = hEdgeMatrix;\n\t}\n\n\tpublic float[] getHEdgeMatrix() {\n\t\treturn hEdgeMatrix;\n\t}\n\n\tprotected int[] filterPixels( int width, int height, int[] inPixels, Rect transformedSpace ) {\n\t\tint index = 0;\n\t\tint[] outPixels = new int[width * height];\n\n\t\tfor (int y = 0; y < height; y++) {\n\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\tint r = 0, g = 0, b = 0;\n\t\t\t\tint rh = 0, gh = 0, bh = 0;\n\t\t\t\tint rv = 0, gv = 0, bv = 0;\n\t\t\t\tint a = inPixels[y*width+x] & 0xff000000;\n\n\t\t\t\tfor (int row = -1; row <= 1; row++) {\n\t\t\t\t\tint iy = y+row;\n\t\t\t\t\tint ioffset;\n\t\t\t\t\tif (0 <= iy && iy < height)\n\t\t\t\t\t\tioffset = iy*width;\n\t\t\t\t\telse\n\t\t\t\t\t\tioffset = y*width;\n\t\t\t\t\tint moffset = 3*(row+1)+1;\n\t\t\t\t\tfor (int col = -1; col <= 1; col++) {\n\t\t\t\t\t\tint ix = x+col;\n\t\t\t\t\t\tif (!(0 <= ix && ix < width))\n\t\t\t\t\t\t\tix = x;\n\t\t\t\t\t\tint rgb = inPixels[ioffset+ix];\n\t\t\t\t\t\tfloat h = hEdgeMatrix[moffset+col];\n\t\t\t\t\t\tfloat v = vEdgeMatrix[moffset+col];\n\n\t\t\t\t\t\tr = (rgb & 0xff0000) >> 16;\n\t\t\t\t\t\tg = (rgb & 0x00ff00) >> 8;\n\t\t\t\t\t\tb = rgb & 0x0000ff;\n\t\t\t\t\t\trh += (int)(h * r);\n\t\t\t\t\t\tgh += (int)(h * g);\n\t\t\t\t\t\tbh += (int)(h * b);\n\t\t\t\t\t\trv += (int)(v * r);\n\t\t\t\t\t\tgv += (int)(v * g);\n\t\t\t\t\t\tbv += (int)(v * b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr = (int)(Math.sqrt(rh*rh + rv*rv) / 1.8);\n\t\t\t\tg = (int)(Math.sqrt(gh*gh + gv*gv) / 1.8);\n\t\t\t\tb = (int)(Math.sqrt(bh*bh + bv*bv) / 1.8);\n\t\t\t\tr = PixelUtils.clamp(r);\n\t\t\t\tg = PixelUtils.clamp(g);\n\t\t\t\tb = PixelUtils.clamp(b);\n\t\t\t\toutPixels[index++] = a | (r << 16) | (g << 8) | b;\n\t\t\t}\n\n\t\t}\n\t\treturn outPixels;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Edges/Detect Edges\";\n\t}\n\n    @Override\n    public String key() {\n        return EdgeTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/QuantizeTransformation.java\npublic class QuantizeTransformation extends WholeImageTransformation {\n\n    /**\n     * Floyd-Steinberg dithering matrix.\n     */\n    protected final static int[] matrix = {\n            0, 0, 0, 0, 0, 7, 3, 5, 1,\n    };\n\n    private int sum = 3 + 5 + 7 + 1;\n\n    private boolean dither;\n\n    private int numColors = 256;\n\n    private boolean serpentine = true;\n\n    /**\n     * Set the number of colors to quantize to.\n     * \n     * @param numColors the number of colors. The default is 256.\n     */\n    public void setNumColors(int numColors) {\n        this.numColors = Math.min(Math.max(numColors, 8), 256);\n    }\n\n    /**\n     * Get the number of colors to quantize to.\n     * \n     * @return the number of colors.\n     */\n    public int getNumColors() {\n        return numColors;\n    }\n\n    /**\n     * Set whether to use dithering or not. If not, the image is posterized.\n     * \n     * @param dither true to use dithering\n     */\n    public void setDither(boolean dither) {\n        this.dither = dither;\n    }\n\n    /**\n     * Return the dithering setting\n     * \n     * @return the current setting\n     */\n    public boolean getDither() {\n        return dither;\n    }\n\n    /**\n     * Set whether to use a serpentine pattern for return or not. This can reduce 'avalanche' artifacts in the output.\n     * \n     * @param serpentine true to use serpentine pattern\n     */\n    public void setSerpentine(boolean serpentine) {\n        this.serpentine = serpentine;\n    }\n\n    /**\n     * Return the serpentine setting\n     * \n     * @return the current setting\n     */\n    public boolean getSerpentine() {\n        return serpentine;\n    }\n\n    public void quantize(int[] inPixels, int[] outPixels, int width, int height, int numColors, boolean dither, boolean serpentine) {\n        int count = width * height;\n        Quantizer quantizer = new OctTreeQuantizer();\n        quantizer.setup(numColors);\n        quantizer.addPixels(inPixels, 0, count);\n        int[] table = quantizer.buildColorTable();\n\n        if (!dither) {\n            for (int i = 0; i < count; i++)\n                outPixels[i] = table[quantizer.getIndexForColor(inPixels[i])];\n        } else {\n            int index = 0;\n            for (int y = 0; y < height; y++) {\n                boolean reverse = serpentine && (y & 1) == 1;\n                int direction;\n                if (reverse) {\n                    index = y * width + width - 1;\n                    direction = -1;\n                } else {\n                    index = y * width;\n                    direction = 1;\n                }\n                for (int x = 0; x < width; x++) {\n                    int rgb1 = inPixels[index];\n                    int rgb2 = table[quantizer.getIndexForColor(rgb1)];\n\n                    outPixels[index] = rgb2;\n\n                    int r1 = (rgb1 >> 16) & 0xff;\n                    int g1 = (rgb1 >> 8) & 0xff;\n                    int b1 = rgb1 & 0xff;\n\n                    int r2 = (rgb2 >> 16) & 0xff;\n                    int g2 = (rgb2 >> 8) & 0xff;\n                    int b2 = rgb2 & 0xff;\n\n                    int er = r1 - r2;\n                    int eg = g1 - g2;\n                    int eb = b1 - b2;\n\n                    for (int i = -1; i <= 1; i++) {\n                        int iy = i + y;\n                        if (0 <= iy && iy < height) {\n                            for (int j = -1; j <= 1; j++) {\n                                int jx = j + x;\n                                if (0 <= jx && jx < width) {\n                                    int w;\n                                    if (reverse)\n                                        w = matrix[ (i + 1) * 3 - j + 1];\n                                    else\n                                        w = matrix[ (i + 1) * 3 + j + 1];\n                                    if (w != 0) {\n                                        int k = reverse ? index - j : index + j;\n                                        rgb1 = inPixels[k];\n                                        r1 = (rgb1 >> 16) & 0xff;\n                                        g1 = (rgb1 >> 8) & 0xff;\n                                        b1 = rgb1 & 0xff;\n                                        r1 += er * w / sum;\n                                        g1 += eg * w / sum;\n                                        b1 += eb * w / sum;\n                                        inPixels[k] = (PixelUtils.clamp(r1) << 16) | (PixelUtils.clamp(g1) << 8) | PixelUtils.clamp(b1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    index += direction;\n                }\n            }\n        }\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        int[] outPixels = new int[width * height];\n\n        quantize(inPixels, outPixels, width, height, numColors, dither, serpentine);\n\n        return outPixels;\n    }\n\n    public String toString() {\n        return \"Colors/Quantize...\";\n    }\n\n    @Override\n    public String key() {\n        return QuantizeTransformation.class.getCanonicalName() + \"-\" + matrix.hashCode() + \"-\" + sum + \"-\" + dither + \"-\" + numColors + \"-\"\n                + serpentine;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/LookupTransformation.java\npublic class LookupTransformation extends PointTransformation {\n\n    private Colormap colormap = new Gradient();\n\n    /**\n     * Construct a LookupFilter.\n     */\n    public LookupTransformation() {\n        canFilterIndexColorModel = true;\n    }\n\n    /**\n     * Construct a LookupFilter.\n     * \n     * @param colormap the color map\n     */\n    public LookupTransformation(Colormap colormap) {\n        canFilterIndexColorModel = true;\n        this.colormap = colormap;\n    }\n\n    /**\n     * Set the colormap to be used for the filter.\n     * \n     * @param colormap the colormap\n     * @see #getColormap\n     */\n    public void setColormap(Colormap colormap) {\n        this.colormap = colormap;\n    }\n\n    /**\n     * Get the colormap to be used for the filter.\n     * \n     * @return the colormap\n     * @see #setColormap\n     */\n    public Colormap getColormap() {\n        return colormap;\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        // int a = rgb & 0xff000000;\n        int r = (rgb >> 16) & 0xff;\n        int g = (rgb >> 8) & 0xff;\n        int b = rgb & 0xff;\n        rgb = (r + g + b) / 3;\n        return colormap.getColor(rgb / 255.0f);\n    }\n\n    public String toString() {\n        return \"Colors/Lookup...\";\n    }\n\n    @Override\n    public String key() {\n        return LookupTransformation.class.getCanonicalName() + \"-\" + colormap.hashCode();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/LevelsTransformation.java\npublic class LevelsTransformation extends WholeImageTransformation {\n\n    private int[][] lut;\n\n    private float lowLevel = 0;\n\n    private float highLevel = 1;\n\n    private float lowOutputLevel = 0;\n\n    private float highOutputLevel = 1;\n\n    public LevelsTransformation() {\n    }\n\n    public void setLowLevel(float lowLevel) {\n        this.lowLevel = lowLevel;\n    }\n\n    public float getLowLevel() {\n        return lowLevel;\n    }\n\n    public void setHighLevel(float highLevel) {\n        this.highLevel = highLevel;\n    }\n\n    public float getHighLevel() {\n        return highLevel;\n    }\n\n    public void setLowOutputLevel(float lowOutputLevel) {\n        this.lowOutputLevel = lowOutputLevel;\n    }\n\n    public float getLowOutputLevel() {\n        return lowOutputLevel;\n    }\n\n    public void setHighOutputLevel(float highOutputLevel) {\n        this.highOutputLevel = highOutputLevel;\n    }\n\n    public float getHighOutputLevel() {\n        return highOutputLevel;\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        Histogram histogram = new Histogram(inPixels, width, height, 0, width);\n\n        int i, j;\n\n        if (histogram.getNumSamples() > 0) {\n            lut = new int[3][256];\n\n            float low = lowLevel * 255;\n            float high = highLevel * 255;\n            if (low == high)\n                high++;\n            for (i = 0; i < 3; i++) {\n                for (j = 0; j < 256; j++)\n                    lut[i][j] = PixelUtils.clamp((int) (255 * (lowOutputLevel + (highOutputLevel - lowOutputLevel) * (j - low)\n                            / (high - low))));\n            }\n        } else\n            lut = null;\n\n        i = 0;\n        for (int y = 0; y < height; y++)\n            for (int x = 0; x < width; x++) {\n                inPixels[i] = filterRGB(x, y, inPixels[i]);\n                i++;\n            }\n        lut = null;\n\n        return inPixels;\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        if (lut != null) {\n            int a = rgb & 0xff000000;\n            int r = lut[Histogram.RED][ (rgb >> 16) & 0xff];\n            int g = lut[Histogram.GREEN][ (rgb >> 8) & 0xff];\n            int b = lut[Histogram.BLUE][rgb & 0xff];\n\n            return a | (r << 16) | (g << 8) | b;\n        }\n        return rgb;\n    }\n\n    public String toString() {\n        return \"Colors/Levels...\";\n    }\n\n    @Override\n    public String key() {\n        return LevelsTransformation.class.getCanonicalName() + \"-\" + lowLevel + \"-\" + highLevel + \"-\" + lowOutputLevel + \"-\"\n                + highOutputLevel;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/PosterizeTransformation.java\npublic class PosterizeTransformation extends PointTransformation {\n\n    private int numLevels;\n\n    private int[] levels;\n\n    private boolean initialized = false;\n\n    public PosterizeTransformation() {\n        setNumLevels(6);\n    }\n\n    /**\n     * Set the number of levels in the output image.\n     * \n     * @param numLevels the number of levels\n     * @see #getNumLevels\n     */\n    public void setNumLevels(int numLevels) {\n        this.numLevels = numLevels;\n        initialized = false;\n    }\n\n    /**\n     * Get the number of levels in the output image.\n     * \n     * @return the number of levels\n     * @see #setNumLevels\n     */\n    public int getNumLevels() {\n        return numLevels;\n    }\n\n    /**\n     * Initialize the filter.\n     */\n    protected void initialize() {\n        levels = new int[256];\n        if (numLevels != 1)\n            for (int i = 0; i < 256; i++)\n                levels[i] = 255 * (numLevels * i / 256) / (numLevels - 1);\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        if (!initialized) {\n            initialized = true;\n            initialize();\n        }\n        int a = rgb & 0xff000000;\n        int r = (rgb >> 16) & 0xff;\n        int g = (rgb >> 8) & 0xff;\n        int b = rgb & 0xff;\n        r = levels[r];\n        g = levels[g];\n        b = levels[b];\n        return a | (r << 16) | (g << 8) | b;\n    }\n\n    public String toString() {\n        return \"Colors/Posterize...\";\n    }\n\n    @Override\n    public String key() {\n        return PosterizeTransformation.class.getCanonicalName() + \"-\" + numLevels;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/DiffusionTransformation.java\npublic class DiffusionTransformation extends WholeImageTransformation {\n\n    private final static int[] diffusionMatrix = { 0, 0, 0, 0, 0, 7, 3, 5, 1, };\n\n    private int[] matrix;\n    private int sum = 3 + 5 + 7 + 1;\n    private boolean serpentine = true;\n    private boolean colorDither = true;\n    private int levels = 6;\n\n    /**\n     * Construct a DiffusionFilter.\n     */\n    public DiffusionTransformation() {\n        setMatrix(diffusionMatrix);\n    }\n\n    /**\n     * Set whether to use a serpentine pattern for return or not. This can\n     * reduce 'avalanche' artifacts in the output.\n     * \n     * @param serpentine\n     *            true to use serpentine pattern\n     * @see #getSerpentine\n     */\n    public void setSerpentine(boolean serpentine) {\n        this.serpentine = serpentine;\n    }\n\n    /**\n     * Return the serpentine setting.\n     * \n     * @return the current setting\n     * @see #setSerpentine\n     */\n    public boolean getSerpentine() {\n        return serpentine;\n    }\n\n    /**\n     * Set whether to use a color dither.\n     * \n     * @param colorDither\n     *            true to use a color dither\n     * @see #getColorDither\n     */\n    public void setColorDither(boolean colorDither) {\n        this.colorDither = colorDither;\n    }\n\n    /**\n     * Get whether to use a color dither.\n     * \n     * @return true to use a color dither\n     * @see #setColorDither\n     */\n    public boolean getColorDither() {\n        return colorDither;\n    }\n\n    /**\n     * Set the dither matrix.\n     * \n     * @param matrix\n     *            the dither matrix\n     * @see #getMatrix\n     */\n    public void setMatrix(int[] matrix) {\n        this.matrix = matrix;\n        sum = 0;\n        for (int i = 0; i < matrix.length; i++)\n            sum += matrix[i];\n    }\n\n    /**\n     * Get the dither matrix.\n     * \n     * @return the dither matrix\n     * @see #setMatrix\n     */\n    public int[] getMatrix() {\n        return matrix;\n    }\n\n    /**\n     * Set the number of dither levels.\n     * \n     * @param levels\n     *            the number of levels\n     * @see #getLevels\n     */\n    public void setLevels(int levels) {\n        this.levels = levels;\n    }\n\n    /**\n     * Get the number of dither levels.\n     * \n     * @return the number of levels\n     * @see #setLevels\n     */\n    public int getLevels() {\n        return levels;\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        int[] outPixels = new int[width * height];\n\n        int index = 0;\n        int[] map = new int[levels];\n        for (int i = 0; i < levels; i++) {\n            int v = 255 * i / (levels - 1);\n            map[i] = v;\n        }\n        int[] div = new int[256];\n        for (int i = 0; i < 256; i++)\n            div[i] = levels * i / 256;\n\n        for (int y = 0; y < height; y++) {\n            boolean reverse = serpentine && (y & 1) == 1;\n            int direction;\n            if (reverse) {\n                index = y * width + width - 1;\n                direction = -1;\n            } else {\n                index = y * width;\n                direction = 1;\n            }\n            for (int x = 0; x < width; x++) {\n                int rgb1 = inPixels[index];\n\n                int r1 = (rgb1 >> 16) & 0xff;\n                int g1 = (rgb1 >> 8) & 0xff;\n                int b1 = rgb1 & 0xff;\n\n                if (!colorDither)\n                    r1 = g1 = b1 = (r1 + g1 + b1) / 3;\n\n                int r2 = map[div[r1]];\n                int g2 = map[div[g1]];\n                int b2 = map[div[b1]];\n\n                outPixels[index] = (rgb1 & 0xff000000) | (r2 << 16) | (g2 << 8) | b2;\n\n                int er = r1 - r2;\n                int eg = g1 - g2;\n                int eb = b1 - b2;\n\n                for (int i = -1; i <= 1; i++) {\n                    int iy = i + y;\n                    if (0 <= iy && iy < height) {\n                        for (int j = -1; j <= 1; j++) {\n                            int jx = j + x;\n                            if (0 <= jx && jx < width) {\n                                int w;\n                                if (reverse)\n                                    w = matrix[(i + 1) * 3 - j + 1];\n                                else\n                                    w = matrix[(i + 1) * 3 + j + 1];\n                                if (w != 0) {\n                                    int k = reverse ? index - j : index + j;\n                                    rgb1 = inPixels[k];\n                                    r1 = (rgb1 >> 16) & 0xff;\n                                    g1 = (rgb1 >> 8) & 0xff;\n                                    b1 = rgb1 & 0xff;\n                                    r1 += er * w / sum;\n                                    g1 += eg * w / sum;\n                                    b1 += eb * w / sum;\n                                    inPixels[k] = (inPixels[k] & 0xff000000) | (PixelUtils.clamp(r1) << 16)\n                                            | (PixelUtils.clamp(g1) << 8) | PixelUtils.clamp(b1);\n                                }\n                            }\n                        }\n                    }\n                }\n                index += direction;\n            }\n        }\n\n        return outPixels;\n    }\n\n    public String toString() {\n        return \"Colors/Diffusion Dither...\";\n    }\n\n    @Override\n    public String key() {\n        return DiffusionTransformation.class.getCanonicalName() + \"-\" + matrix.hashCode() + \"-\" + sum + \"-\"\n                + serpentine + \"-\" + colorDither + \"-\" + levels;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/GrayscaleTransformation.java\npublic class GrayscaleTransformation extends PointTransformation {\n\n\tpublic GrayscaleTransformation() {\n\t\tcanFilterIndexColorModel = true;\n\t}\n\n\tpublic int filterRGB(int x, int y, int rgb) {\n\t\tint a = rgb & 0xff000000;\n\t\tint r = (rgb >> 16) & 0xff;\n\t\tint g = (rgb >> 8) & 0xff;\n\t\tint b = rgb & 0xff;\n//\t\trgb = (r + g + b) / 3;\t// simple average\n\t\trgb = (r * 77 + g * 151 + b * 28) >> 8;\t// NTSC luma\n\t\treturn a | (rgb << 16) | (rgb << 8) | rgb;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Colors/Grayscale\";\n\t}\n\n    @Override\n    public String key() {\n        return GrayscaleTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/TritoneTransformation.java\npublic class TritoneTransformation extends PointTransformation {\n\n    private int shadowColor = 0xff000000;\n\n    private int midColor = 0xff888888;\n\n    private int highColor = 0xffffffff;\n\n    private int[] lut;\n\n//    public BufferedImage filter(BufferedImage src, BufferedImage dst) {\n//        lut = new int[256];\n//        for (int i = 0; i < 128; i++) {\n//            float t = i / 127.0f;\n//            lut[i] = ImageMath.mixColors(t, shadowColor, midColor);\n//        }\n//        for (int i = 128; i < 256; i++) {\n//            float t = (i - 127) / 128.0f;\n//            lut[i] = ImageMath.mixColors(t, midColor, highColor);\n//        }\n//        dst = super.filter(src, dst);\n//        lut = null;\n//        return dst;\n//    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        return lut[PixelUtils.brightness(rgb)];\n    }\n\n    /**\n     * Set the shadow color.\n     * \n     * @param shadowColor the shadow color\n     * @see #getShadowColor\n     */\n    public void setShadowColor(int shadowColor) {\n        this.shadowColor = shadowColor;\n    }\n\n    /**\n     * Get the shadow color.\n     * \n     * @return the shadow color\n     * @see #setShadowColor\n     */\n    public int getShadowColor() {\n        return shadowColor;\n    }\n\n    /**\n     * Set the mid color.\n     * \n     * @param midColor the mid color\n     * @see #getmidColor\n     */\n    public void setMidColor(int midColor) {\n        this.midColor = midColor;\n    }\n\n    /**\n     * Get the mid color.\n     * \n     * @return the mid color\n     * @see #setmidColor\n     */\n    public int getMidColor() {\n        return midColor;\n    }\n\n    /**\n     * Set the high color.\n     * \n     * @param highColor the high color\n     * @see #gethighColor\n     */\n    public void setHighColor(int highColor) {\n        this.highColor = highColor;\n    }\n\n    /**\n     * Get the high color.\n     * \n     * @return the high color\n     * @see #sethighColor\n     */\n    public int getHighColor() {\n        return highColor;\n    }\n\n    public String toString() {\n        return \"Colors/Tritone...\";\n    }\n\n    @Override\n    public String key() {\n        return TritoneTransformation.class.getCanonicalName() + \"-\" + shadowColor + \"-\" + midColor + \"-\" + highColor;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/MirrorTransformation.java\npublic class MirrorTransformation implements Transformation {\n\n    private float opacity = 1.0f;\n\n    private float centreY = 0.5f;\n\n    private float distance;\n\n    private float gap;\n\n    public MirrorTransformation() {\n    }\n\n    public MirrorTransformation setDistance(float distance) {\n        this.distance = distance;\n        return this;\n    }\n\n    public float getDistance() {\n        return distance;\n    }\n\n    public MirrorTransformation setGap(float gap) {\n        this.gap = gap;\n        return this;\n    }\n\n    public float getGap() {\n        return gap;\n    }\n\n    /**\n     * Set the opacity of the reflection.\n     * \n     * @param opacity the opacity.\n     * @see #getOpacity\n     */\n    public MirrorTransformation setOpacity(float opacity) {\n        this.opacity = opacity;\n        return this;\n    }\n\n    /**\n     * Get the opacity of the reflection.\n     * \n     * @return the opacity.\n     * @see #setOpacity\n     */\n    public float getOpacity() {\n        return opacity;\n    }\n\n    public MirrorTransformation setCentreY(float centreY) {\n        this.centreY = centreY;\n        return this;\n    }\n\n    public float getCentreY() {\n        return centreY;\n    }\n\n    @Override\n    public Bitmap transform(Bitmap source) {\n        int width = source.getWidth();\n        int height = source.getHeight();\n\n        int h = (int) (centreY * height);\n        int d = (int) (gap * height);\n\n        Canvas canvas = new Canvas();\n        Paint paint = new Paint();\n\n        Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n        canvas.setBitmap(bitmap);\n\n        // Set background color\n        canvas.drawColor(Color.BLACK);\n\n        // Draw upper region\n        RectF clipSrcF = new RectF(0, 0, width, height);\n        RectF clipDestF = new RectF(0, 0, width, h);\n        Matrix m = new Matrix();\n        m.setRectToRect(clipSrcF, clipDestF, ScaleToFit.CENTER);\n        canvas.drawBitmap(source, m, paint);\n\n        // Draw mirror\n        clipSrcF = new RectF(0, 0, width, height);\n        clipDestF = new RectF(0, h + d, width, height + d);\n        m = new Matrix();\n        m.setRectToRect(clipSrcF, clipDestF, ScaleToFit.CENTER);\n        m.preTranslate(0, height);\n        m.preScale(1, -1);\n        canvas.drawBitmap(source, m, paint);\n\n        // Done with source image\n        source.recycle();\n\n        // Draw gradient over mirror\n        RectF clipGradientF = new RectF(0, 0, width, height);\n        m.mapRect(clipGradientF);\n        paint.setShader(new LinearGradient(0, h, 0, height, Color.argb(50, 0, 0, 0), Color.argb((int) (opacity * 255), 0, 1, 0),\n                Shader.TileMode.CLAMP));\n        canvas.drawRect(clipGradientF, paint);\n\n        return bitmap;\n    }\n\n    public String toString() {\n        return \"Effects/Mirror...\";\n    }\n\n    @Override\n    public String key() {\n        return MirrorTransformation.class.getCanonicalName() + \"-\" + opacity + \"-\" + centreY + \"-\" + distance + \"-\" + gap;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/GrayTransformation.java\npublic class GrayTransformation extends PointTransformation {\n\n\tpublic GrayTransformation() {\n\t\tcanFilterIndexColorModel = true;\n\t}\n\n\tpublic int filterRGB(int x, int y, int rgb) {\n\t\tint a = rgb & 0xff000000;\n\t\tint r = (rgb >> 16) & 0xff;\n\t\tint g = (rgb >> 8) & 0xff;\n\t\tint b = rgb & 0xff;\n\t\tr = (r+255)/2;\n\t\tg = (g+255)/2;\n\t\tb = (b+255)/2;\n\t\treturn a | (r << 16) | (g << 8) | b;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Colors/Gray Out\";\n\t}\n\n    @Override\n    public String key() {\n        return GainTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/SolarizeTransformation.java\npublic class SolarizeTransformation extends TransferTransformation {\n\n    protected float transferFunction(float v) {\n        return v > 0.5f ? 2 * (v - 0.5f) : 2 * (0.5f - v);\n    }\n\n    public String toString() {\n        return \"Colors/Solarize\";\n    }\n\n    @Override\n    public String key() {\n        return SolarizeTransformation.class.getCanonicalName();\n    }\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/EqualizeTransformation.java\npublic class EqualizeTransformation extends WholeImageTransformation {\n\n    private int[][] lut;\n\n    public EqualizeTransformation() {\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        Histogram histogram = new Histogram(inPixels, width, height, 0, width);\n\n        int i, j;\n\n        if (histogram.getNumSamples() > 0) {\n            float scale = 255.0f / histogram.getNumSamples();\n            lut = new int[3][256];\n            for (i = 0; i < 3; i++) {\n                lut[i][0] = histogram.getFrequency(i, 0);\n                for (j = 1; j < 256; j++)\n                    lut[i][j] = lut[i][j - 1] + histogram.getFrequency(i, j);\n                for (j = 0; j < 256; j++)\n                    lut[i][j] = (int) Math.round(lut[i][j] * scale);\n            }\n        } else\n            lut = null;\n\n        i = 0;\n        for (int y = 0; y < height; y++)\n            for (int x = 0; x < width; x++) {\n                inPixels[i] = filterRGB(x, y, inPixels[i]);\n                i++;\n            }\n        lut = null;\n\n        return inPixels;\n    }\n\n    private int filterRGB(int x, int y, int rgb) {\n        if (lut != null) {\n            int a = rgb & 0xff000000;\n            int r = lut[Histogram.RED][(rgb >> 16) & 0xff];\n            int g = lut[Histogram.GREEN][(rgb >> 8) & 0xff];\n            int b = lut[Histogram.BLUE][rgb & 0xff];\n\n            return a | (r << 16) | (g << 8) | b;\n        }\n        return rgb;\n    }\n\n    public String toString() {\n        return \"Colors/Equalize\";\n    }\n\n    @Override\n    public String key() {\n        return EqualizeTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/BlurTransformation.java\npublic class BlurTransformation extends ConvolveTransformation {\n \t\n \t/**\n     * A 3x3 convolution kernel for a simple blur.\n     */\n    protected static float[] blurMatrix = {\n\t\t1/14f, 2/14f, 1/14f,\n\t\t2/14f, 2/14f, 2/14f,\n\t\t1/14f, 2/14f, 1/14f\n\t};\n\n\tpublic BlurTransformation() {\n\t\tsuper(blurMatrix);\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Blur/Simple Blur\";\n\t}\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/MapColorsTransformation.java\npublic class MapColorsTransformation extends PointTransformation {\n\n    private int oldColor;\n\n    private int newColor;\n\n    /**\n     * Construct a MapColorsFilter.\n     */\n    public MapColorsTransformation() {\n        this(0xffffffff, 0xff000000);\n    }\n\n    /**\n     * Construct a MapColorsFilter.\n     * \n     * @param oldColor the color to replace\n     * @param newColor the color to replace it with\n     */\n    public MapColorsTransformation(int oldColor, int newColor) {\n        canFilterIndexColorModel = true;\n        this.oldColor = oldColor;\n        this.newColor = newColor;\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        if (rgb == oldColor)\n            return newColor;\n        return rgb;\n    }\n\n    @Override\n    public String key() {\n        return MapColorsTransformation.class.getCanonicalName() + \"-\" + oldColor + \"-\" + newColor;\n    }\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/HSBAdjustTransformation.java\npublic class HSBAdjustTransformation extends PointTransformation {\n\n    public float hFactor, sFactor, bFactor;\n    private float[] hsb = new float[3];\n    \n    public HSBAdjustTransformation() {\n        this(0, 0, 0);\n    }\n\n    public HSBAdjustTransformation(float r, float g, float b) {\n        hFactor = r;\n        sFactor = g;\n        bFactor = b;\n        canFilterIndexColorModel = true;\n    }\n\n    public HSBAdjustTransformation setHFactor( float hFactor ) {\n        this.hFactor = hFactor;\n        return this;\n    }\n    \n    public float getHFactor() {\n        return hFactor;\n    }\n    \n    public HSBAdjustTransformation setSFactor( float sFactor ) {\n        this.sFactor = sFactor;\n        return this;\n    }\n    \n    public float getSFactor() {\n        return sFactor;\n    }\n    \n    public HSBAdjustTransformation setBFactor( float bFactor ) {\n        this.bFactor = bFactor;\n        return this;\n    }\n    \n    public float getBFactor() {\n        return bFactor;\n    }\n    \n    public int filterRGB(int x, int y, int rgb) {\n        int a = rgb & 0xff000000;\n        int r = (rgb >> 16) & 0xff;\n        int g = (rgb >> 8) & 0xff;\n        int b = rgb & 0xff;\n        Color.RGBtoHSB(r, g, b, hsb);\n        hsb[0] += hFactor;\n        while (hsb[0] < 0)\n            hsb[0] += Math.PI*2;\n        hsb[1] += sFactor;\n        if (hsb[1] < 0)\n            hsb[1] = 0;\n        else if (hsb[1] > 1.0)\n            hsb[1] = 1.0f;\n        hsb[2] += bFactor;\n        if (hsb[2] < 0)\n            hsb[2] = 0;\n        else if (hsb[2] > 1.0)\n            hsb[2] = 1.0f;\n        rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);\n        return a | (rgb & 0xffffff);\n    }\n\n    public String toString() {\n        return \"Colors/Adjust HSB...\";\n    }\n\n    @Override\n    public String key() {\n        return HSBAdjustTransformation.class.getCanonicalName() + \"-\" + hFactor + \"-\" + sFactor + \"-\" + bFactor;\n    }\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/RescaleTransformation.java\npublic class RescaleTransformation extends TransferTransformation {\n\n    private float scale = 1.0f;\n\n    public RescaleTransformation() {\n    }\n\n    public RescaleTransformation(float scale) {\n        this.scale = scale;\n    }\n\n    protected float transferFunction(float v) {\n        return v * scale;\n    }\n\n    /**\n     * Specifies the scale factor.\n     * \n     * @param scale the scale factor.\n     * @min-value 1\n     * @max-value 5+\n     * @see #getScale\n     */\n    public void setScale(float scale) {\n        this.scale = scale;\n        initialized = false;\n    }\n\n    /**\n     * Returns the scale factor.\n     * \n     * @return the scale factor.\n     * @see #setScale\n     */\n    public float getScale() {\n        return scale;\n    }\n\n    public String toString() {\n        return \"Colors/Rescale...\";\n    }\n\n    @Override\n    public String key() {\n        return RescaleTransformation.class.getCanonicalName() + \"-\" + scale;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/KaleidoscopeTransformation.java\npublic class KaleidoscopeTransformation extends TransformTransformation {\n\n    private float angle = 0;\n\n    private float angle2 = 0;\n\n    private float centreX = 0.5f;\n\n    private float centreY = 0.5f;\n\n    private int sides = 3;\n\n    private float radius = 0;\n\n    private float icentreX;\n\n    private float icentreY;\n\n    /**\n     * Construct a KaleidoscopeFilter with no distortion.\n     */\n    public KaleidoscopeTransformation() {\n        setEdgeAction(CLAMP);\n    }\n\n    /**\n     * Set the number of sides of the kaleidoscope.\n     * \n     * @param sides the number of sides\n     * @min-value 2\n     * @see #getSides\n     */\n    public KaleidoscopeTransformation setSides(int sides) {\n        this.sides = sides;\n        return this;\n    }\n\n    /**\n     * Get the number of sides of the kaleidoscope.\n     * \n     * @return the number of sides\n     * @see #setSides\n     */\n    public int getSides() {\n        return sides;\n    }\n\n    /**\n     * Set the angle of the kaleidoscope.\n     * \n     * @param angle the angle of the kaleidoscope.\n     * @angle\n     * @see #getAngle\n     */\n    public KaleidoscopeTransformation setAngle(float angle) {\n        this.angle = angle;\n        return this;\n    }\n\n    /**\n     * Get the angle of the kaleidoscope.\n     * \n     * @return the angle of the kaleidoscope.\n     * @see #setAngle\n     */\n    public float getAngle() {\n        return angle;\n    }\n\n    /**\n     * Set the secondary angle of the kaleidoscope.\n     * \n     * @param angle2 the angle\n     * @angle\n     * @see #getAngle2\n     */\n    public KaleidoscopeTransformation setAngle2(float angle2) {\n        this.angle2 = angle2;\n        return this;\n    }\n\n    /**\n     * Get the secondary angle of the kaleidoscope.\n     * \n     * @return the angle\n     * @see #setAngle2\n     */\n    public float getAngle2() {\n        return angle2;\n    }\n\n    /**\n     * Set the centre of the effect in the X direction as a proportion of the image size.\n     * \n     * @param centreX the center\n     * @see #getCentreX\n     */\n    public KaleidoscopeTransformation setCentreX(float centreX) {\n        this.centreX = centreX;\n        return this;\n    }\n\n    /**\n     * Get the centre of the effect in the X direction as a proportion of the image size.\n     * \n     * @return the center\n     * @see #setCentreX\n     */\n    public float getCentreX() {\n        return centreX;\n    }\n\n    /**\n     * Set the centre of the effect in the Y direction as a proportion of the image size.\n     * \n     * @param centreY the center\n     * @see #getCentreY\n     */\n    public KaleidoscopeTransformation setCentreY(float centreY) {\n        this.centreY = centreY;\n        return this;\n    }\n\n    /**\n     * Get the centre of the effect in the Y direction as a proportion of the image size.\n     * \n     * @return the center\n     * @see #setCentreY\n     */\n    public float getCentreY() {\n        return centreY;\n    }\n\n    /**\n     * Set the centre of the effect as a proportion of the image size.\n     * \n     * @param centre the center\n     * @see #getCentre\n     */\n    public KaleidoscopeTransformation setCentre(PointF centre) {\n        this.centreX = centre.x;\n        this.centreY = centre.y;\n        return this;\n    }\n\n    /**\n     * Get the centre of the effect as a proportion of the image size.\n     * \n     * @return the center\n     * @see #setCentre\n     */\n    public PointF getCentre() {\n        return new PointF(centreX, centreY);\n    }\n\n    /**\n     * Set the radius of the effect.\n     * \n     * @param radius the radius\n     * @min-value 0\n     * @see #getRadius\n     */\n    public KaleidoscopeTransformation setRadius(float radius) {\n        this.radius = radius;\n        return this;\n    }\n\n    /**\n     * Get the radius of the effect.\n     * \n     * @return the radius\n     * @see #setRadius\n     */\n    public float getRadius() {\n        return radius;\n    }\n\n    @Override\n    public Bitmap transform(Bitmap source) {\n        icentreX = source.getWidth() * centreX;\n        icentreY = source.getHeight() * centreY;\n        return super.transform(source);\n    }\n\n    protected void transformInverse(int x, int y, float[] out) {\n        double dx = x - icentreX;\n        double dy = y - icentreY;\n        double r = Math.sqrt(dx * dx + dy * dy);\n        double theta = Math.atan2(dy, dx) - angle - angle2;\n        theta = ImageMath.triangle((float) (theta / Math.PI * sides * .5));\n        if (radius != 0) {\n            double c = Math.cos(theta);\n            double radiusc = radius / c;\n            r = radiusc * ImageMath.triangle((float) (r / radiusc));\n        }\n        theta += angle;\n\n        out[0] = (float) (icentreX + r * Math.cos(theta));\n        out[1] = (float) (icentreY + r * Math.sin(theta));\n    }\n\n    public String toString() {\n        return \"Distort/Kaleidoscope...\";\n    }\n\n    @Override\n    public String key() {\n        return KaleidoscopeTransformation.class.getCanonicalName() + \"-\" + angle + \"-\" + angle2 + \"-\" + centreX + \"-\" + centreY + \"-\"\n                + sides + \"-\" + radius + \"-\" + icentreX + \"-\" + icentreY;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/EmbossTransformation.java\npublic class EmbossTransformation extends WholeImageTransformation {\n\n    private final static float pixelScale = 255.9f;\n\n    private float azimuth = 135.0f * ImageMath.PI / 180.0f, elevation = 30.0f * ImageMath.PI / 180f;\n    private boolean emboss = false;\n    private float width45 = 3.0f;\n\n    public EmbossTransformation() {\n    }\n\n    public void setAzimuth(float azimuth) {\n        this.azimuth = azimuth;\n    }\n\n    public float getAzimuth() {\n        return azimuth;\n    }\n\n    public void setElevation(float elevation) {\n        this.elevation = elevation;\n    }\n\n    public float getElevation() {\n        return elevation;\n    }\n\n    public void setBumpHeight(float bumpHeight) {\n        this.width45 = 3 * bumpHeight;\n    }\n\n    public float getBumpHeight() {\n        return width45 / 3;\n    }\n\n    public void setEmboss(boolean emboss) {\n        this.emboss = emboss;\n    }\n\n    public boolean getEmboss() {\n        return emboss;\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        int index = 0;\n        int[] outPixels = new int[width * height];\n\n        int[] bumpPixels;\n        int bumpMapWidth, bumpMapHeight;\n\n        bumpMapWidth = width;\n        bumpMapHeight = height;\n        bumpPixels = new int[bumpMapWidth * bumpMapHeight];\n        for (int i = 0; i < inPixels.length; i++)\n            bumpPixels[i] = PixelUtils.brightness(inPixels[i]);\n\n        int Nx, Ny, Nz, Lx, Ly, Lz, Nz2, NzLz, NdotL;\n        int shade, background;\n\n        Lx = (int) (Math.cos(azimuth) * Math.cos(elevation) * pixelScale);\n        Ly = (int) (Math.sin(azimuth) * Math.cos(elevation) * pixelScale);\n        Lz = (int) (Math.sin(elevation) * pixelScale);\n\n        Nz = (int) (6 * 255 / width45);\n        Nz2 = Nz * Nz;\n        NzLz = Nz * Lz;\n\n        background = Lz;\n\n        int bumpIndex = 0;\n\n        for (int y = 0; y < height; y++, bumpIndex += bumpMapWidth) {\n            int s1 = bumpIndex;\n            int s2 = s1 + bumpMapWidth;\n            int s3 = s2 + bumpMapWidth;\n\n            for (int x = 0; x < width; x++, s1++, s2++, s3++) {\n                if (y != 0 && y < height - 2 && x != 0 && x < width - 2) {\n                    Nx = bumpPixels[s1 - 1] + bumpPixels[s2 - 1] + bumpPixels[s3 - 1] - bumpPixels[s1 + 1]\n                            - bumpPixels[s2 + 1] - bumpPixels[s3 + 1];\n                    Ny = bumpPixels[s3 - 1] + bumpPixels[s3] + bumpPixels[s3 + 1] - bumpPixels[s1 - 1] - bumpPixels[s1]\n                            - bumpPixels[s1 + 1];\n\n                    if (Nx == 0 && Ny == 0)\n                        shade = background;\n                    else if ((NdotL = Nx * Lx + Ny * Ly + NzLz) < 0)\n                        shade = 0;\n                    else\n                        shade = (int) (NdotL / Math.sqrt(Nx * Nx + Ny * Ny + Nz2));\n                } else\n                    shade = background;\n\n                if (emboss) {\n                    int rgb = inPixels[index];\n                    int a = rgb & 0xff000000;\n                    int r = (rgb >> 16) & 0xff;\n                    int g = (rgb >> 8) & 0xff;\n                    int b = rgb & 0xff;\n                    r = (r * shade) >> 8;\n                    g = (g * shade) >> 8;\n                    b = (b * shade) >> 8;\n                    outPixels[index++] = a | (r << 16) | (g << 8) | b;\n                } else\n                    outPixels[index++] = 0xff000000 | (shade << 16) | (shade << 8) | shade;\n            }\n        }\n\n        return outPixels;\n    }\n\n    public String toString() {\n        return \"Stylize/Emboss...\";\n    }\n\n    @Override\n    public String key() {\n        return EmbossTransformation.class.getCanonicalName() + \"-\" + pixelScale + \"-\" + azimuth + \"-\" + elevation + \"-\"\n                + emboss + \"-\" + width45;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/renderscript/RSGaussianBlurTransformation.java\npublic class RSGaussianBlurTransformation implements Transformation {\n\n    private Context mContext;\n\n    private int mRadius;\n    \n    /**\n     * Constructor.\n     * \n     * @param context The context.\n     * @param radius The blur radius: (0, 25]\n     */\n    public RSGaussianBlurTransformation(Context context, int radius) {\n        mContext = context;\n        mRadius = radius;\n    }\n\n    @Override\n    public Bitmap transform(Bitmap source) {\n        if (Build.VERSION.SDK_INT < 17) {\n            return source;\n        }\n        \n        RenderScript rs = RenderScript.create(mContext);\n        Allocation input = Allocation.createFromBitmap(rs, source, Allocation.MipmapControl.MIPMAP_NONE, Allocation.USAGE_SCRIPT);\n        Allocation output = Allocation.createTyped(rs, input.getType());\n        ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));\n        script.setRadius(mRadius);\n        script.setInput(input);\n        script.forEach(output);\n        output.copyTo(source);\n        return source;\n    }\n\n    @Override\n    public String key() {\n        return RSGaussianBlurTransformation.class.getCanonicalName() + \"-\" + mRadius;\n    }\n\n}\n", "answers": ["                    new HSBAdjustTransformation(.5f,.5f,.5f),"], "length": 5849, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "054c54050c80c29f3bbf1adf5fba865a2468928d4e19a1fe"}
{"input": "package com.rashwan.reactive_popular_movies.feature.movieDetails.movieInfo;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.Fragment;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport com.rashwan.reactive_popular_movies.PopularMoviesApplication;\nimport com.rashwan.reactive_popular_movies.R;\nimport com.rashwan.reactive_popular_movies.common.utilities.DelegateToActivity;\nimport com.rashwan.reactive_popular_movies.data.model.Movie;\nimport com.rashwan.reactive_popular_movies.data.model.MovieDetails;\nimport com.rashwan.reactive_popular_movies.data.model.Rating;\nimport com.rashwan.reactive_popular_movies.data.model.Trailer;\nimport com.rashwan.reactive_popular_movies.feature.discoverMovies.BrowseMoviesActivity;\nimport com.rashwan.reactive_popular_movies.feature.favoriteMovies.FavoriteMoviesActivity;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.MovieDetailsActivity;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.ShowDetailsInActivity;\nimport java.util.List;\nimport javax.inject.Inject;\nimport butterknife.BindColor;\nimport butterknife.BindView;\nimport butterknife.BindViews;\nimport butterknife.ButterKnife;\nimport butterknife.OnClick;\nimport butterknife.Unbinder;\nimport rx.Observable;\n\n\n\n\n\n\n/**\n * Created by rashwan on 7/3/16.\n */\n\npublic class MovieInfoFragment extends Fragment implements MovieInfoView\n        ,MovieTrailersAdapter.ClickListener,SimilarMoviesAdapter.ClickListener {\n\n    private static final String ARGUMENT_MOVIE_ID = \"ARGUMENT_MOVIE_ID\";\n    private static final String ARGUMENT_DESCRIPTION = \"ARGUMENT_DESCRIPTION\";\n    private static final String ARGUMENT_TMDB_RATING = \"ARGUMENT_TMDB_RATING\";\n    private static final ButterKnife.Action<View> SHOW = (view, index) -> view.setVisibility(View.VISIBLE);\n    private static final ButterKnife.Action<View> HIDE = (view, index) -> view.setVisibility(View.GONE);", "context": "app/src/main/java/com/rashwan/reactive_popular_movies/data/model/Movie.java\n @AutoValue public abstract class Movie implements Parcelable{\n    public static final String QUALITY_LOW = \"w342\";\n    public static final String QUALITY_MEDIUM = \"w500\";\n    public static final String QUALITY_HIGH = \"w780\";\n\n    public abstract long id();\n    @Nullable @Json(name = \"imdb_id\") public abstract String ImdbId();\n    public abstract String title();\n    @Nullable public abstract String overview();\n    public abstract long runtime();\n    @Json(name = \"vote_average\") public abstract float tmdbRating();\n    @Json(name = \"release_date\") public abstract String releaseDate();\n    @Nullable @Json(name = \"backdrop_path\") public abstract String backdropPath();\n    @Nullable @Json(name = \"poster_path\") public abstract String posterPath();\n\n\n    public static Movie create(long id, String ImdbId,String title, String overview, Long runtime,\n           float tmdbRating,String releaseDate, String backdropPath, String posterPath) {\n        return new AutoValue_Movie(id,ImdbId,title,overview,runtime,tmdbRating,releaseDate,backdropPath,posterPath);\n    }\n\n\n\n    public static JsonAdapter<Movie> jsonAdapter(Moshi moshi){\n        return new AutoValue_Movie.MoshiJsonAdapter(moshi);\n    }\n\n\n    public String getFormattedRuntime(Long runtime){\n        int hours = (int) (runtime / 60);\n        int minutes = (int) (runtime % 60);\n        return hours > 1 ? String.format(Locale.getDefault(), \"%d hrs %02d mins\", hours, minutes)\n                : String.format(Locale.getDefault(), \"%d hr %02d mins\", hours, minutes);\n    }\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/MovieDetails.java\n@AutoValue\npublic abstract class MovieDetails {\n    public abstract String imdbID ();\n    public abstract String imdbRating();\n    @Json(name = \"Ratings\") public abstract List<Rating> ratings();\n    @Json(name = \"Rated\") public abstract String rated();\n    @Json(name = \"Genre\") public abstract String genre();\n    @Json(name = \"Metascore\") public abstract String metascore();\n    @Json(name = \"BoxOffice\") public abstract String boxOffice();\n    @Json(name = \"Awards\") public abstract String awards();\n    @Json(name = \"Production\") public abstract String production();\n    @Json(name = \"Website\") public abstract String website();\n\n\n    public static JsonAdapter<MovieDetails> jsonAdapter(Moshi moshi){\n        return new AutoValue_MovieDetails.MoshiJsonAdapter(moshi);\n    }\n\n    public String getFormattedBoxOffice(){\n        return this.boxOffice().substring(0,this.boxOffice().length()-3);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/favoriteMovies/FavoriteMoviesActivity.java\npublic class FavoriteMoviesActivity extends BaseActivity {\n\n    @BindView(R.id.browse_toolbar) Toolbar toolbar;\n    @BindView(R.id.navigation_view) NavigationView navigationView;\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_favorite_movies);\n        navigationView.setCheckedItem(R.id.nav_favorites);\n        toolbar.setTitle(R.string.nav_favorites_title);\n        super.onCreateBaseActivity(savedInstanceState);\n    }\n\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/Rating.java\n@AutoValue\npublic abstract class Rating {\n    public static final String ROTTEN_TOMATOES_KEY = \"Rotten Tomatoes\";\n    @Json(name = \"Source\") public abstract String source();\n    @Json(name = \"Value\") public abstract String value();\n\n    public static JsonAdapter<Rating> jsonAdapter(Moshi moshi){\n        return new AutoValue_Rating.MoshiJsonAdapter(moshi);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/Trailer.java\n@AutoValue public abstract class Trailer {\n    @Inject public transient Application context;\n    @Json(name = \"key\") public abstract String youtubeUrl();\n    public abstract String name();\n    public abstract String type();\n\n    public Trailer() {\n        PopularMoviesApplication.getApplicationComponent().inject(this);\n    }\n\n    public static JsonAdapter<Trailer> jsonAdapter(Moshi moshi){\n        return new AutoValue_Trailer.MoshiJsonAdapter(moshi);\n    }\n\n    public String getTrailerThumbnail(){\n        String baseUrl = context.getString(R.string.trailer_youtube_thumbnail);\n        return String.format(baseUrl,youtubeUrl());\n    }\n    public Uri getFullYoutubeUri(){\n        String baseUrl = context.getString(R.string.trailer_youtube_video);\n        return Uri.parse(baseUrl).buildUpon()\n                .appendQueryParameter(\"v\",this.youtubeUrl()).build();\n    }\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/MovieDetailsActivity.java\npublic class MovieDetailsActivity extends AppCompatActivity implements DelegateToActivity\n        ,MovieDetailsView,ShowDetailsInActivity,AppBarLayout.OnOffsetChangedListener{\n\n    private static final String EXTRA_MOVIE = \"com.rashwan.reactive_popular_movies.feature.movieDetails.EXTRA_MOVIE\";\n    private static final String EXTRA_SHARED_ELEMENT_NAME = \"com.rashwan.reactive_popular_movies.feature.movieDetails.EXTRA_SHARED_ELEMENT_NAME\";\n    @BindView(R.id.details_coordinator_layout) CoordinatorLayout coordinatorLayout;\n    @BindView(R.id.details_sliding_tabs) TabLayout detailsTabLayout;\n    @BindView(R.id.details_view_pager) ViewPager detailsViewPager;\n    @BindView(R.id.image_backdrop) ImageView blurPoster;\n    @BindView(R.id.image_poster) ImageView posterImage;\n    @BindView(R.id.text_release) TextView release;\n    @BindView(R.id.text_movie_title) TextView textMovieTitle;\n    @BindView(R.id.toolbar_movie_title) TextView toolbarMovieTitle;\n    @BindView(R.id.collapsing_toolbar_layout) CollapsingToolbarLayout collapsingToolbar;\n    @BindView(R.id.toggle_watchlist) ToggleButton toggleWatchlist;\n    @BindView(R.id.button_play_main_trailer) ImageButton buttonPlayTrailer;\n    @BindView(R.id.appbar) AppBarLayout appBarLayout;\n    @BindView(R.id.text_runtime) TextView textRuntime;\n    @BindView(R.id.text_movie_genres) TextView textGenres;\n    @BindView(R.id.image_mpaa_rating) ImageView imageMpaaRating;\n    @BindView(R.id.appbar_constraint_layout) ConstraintLayout appbarConstraintLayout;\n    @BindView(R.id.fab_favorite) FloatingActionButton fab;\n    @Nullable @BindView(R.id.toolbar_details) Toolbar toolbar;\n    @BindColor(android.R.color.black) int blackColor;\n    private String sharedElementName;\n    private Movie movie;\n    @Inject MovieDetailsPresenter presenter;\n    private boolean isFavorite = false;\n    private ConstantState fullHeartConstantState;\n    private ConstantState emptyHeartConstantState;\n    private String sharedTrailerUrl;\n    private Uri mainTrailerUri;\n    private TransitionListenerAdapter transitionListener;\n\n    public static Intent getMovieDetailsIntent(Context context, Movie movie, String sharedElementName){\n        Intent intent = new Intent(context,MovieDetailsActivity.class);\n        intent.putExtra(EXTRA_MOVIE,movie);\n        intent.putExtra(EXTRA_SHARED_ELEMENT_NAME,sharedElementName);\n        return intent;\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ((PopularMoviesApplication)getApplication()).createMovieDetailsComponent().inject(this);\n        Intent intent = getIntent();\n        movie = intent.getParcelableExtra(EXTRA_MOVIE);\n        sharedElementName = intent.getStringExtra(EXTRA_SHARED_ELEMENT_NAME);\n        setContentView(R.layout.activity_movie_details);\n        ButterKnife.bind(this);\n        presenter.attachView(this);\n        setupShareElementTransition();\n        setupViews();\n\n\n\n//        MovieInfoFragment movieDetailsFragment = (MovieInfoFragment)\n//                fragmentManager.findFragmentByTag(TAG_MOVIE_DETAILS_FRAGMENT);\n//        if (savedInstanceState == null && movieDetailsFragment == null){\n//            movieDetailsFragment = MovieInfoFragment.newInstance(movie,sharedElementName);\n//            fragmentManager.beginTransaction()\n//                    .replace(R.id.movie_details_container,movieDetailsFragment, TAG_MOVIE_DETAILS_FRAGMENT)\n//                    .commit();\n//        }\n    }\n\n    private void setupShareElementTransition() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            transitionListener = new TransitionListenerAdapter() {\n                @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n                @Override\n                public void onTransitionEnd(Transition transition) {\n                    super.onTransitionEnd(transition);\n                    setupViewPager();\n                    getWindow().getSharedElementEnterTransition().removeListener(transitionListener);\n                }\n            };\n            posterImage.setTransitionName(sharedElementName);\n            getWindow().getSharedElementEnterTransition().addListener(transitionListener);\n        }\n    }\n\n    private void setupViewPager() {\n        MovieDetailsPagerAdapter detailsPagerAdapter = new MovieDetailsPagerAdapter(\n                getSupportFragmentManager(),movie);\n        detailsViewPager.setAdapter(detailsPagerAdapter);\n        detailsTabLayout.setupWithViewPager(detailsViewPager);\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    private void enterReveal() {\n        if (!isDestroyed()) {\n            blurPoster.setVisibility(View.VISIBLE);\n            final int finalRadius = Math.max(blurPoster.getWidth(), blurPoster.getHeight()) / 2;\n            Animator circularReveal = ViewAnimationUtils.createCircularReveal(blurPoster\n                    , blurPoster.getWidth() / 2, blurPoster.getHeight() / 2\n                    , 0, finalRadius);\n            circularReveal.start();\n        }\n    }\n\n    @Override\n    public void showFavoriteMovie() {\n        if (!isFavorite) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n                AnimatedVectorDrawable emptyHeart = (AnimatedVectorDrawable)\n                        emptyHeartConstantState.newDrawable();\n                fab.setImageDrawable(emptyHeart);\n                emptyHeart.start();\n\n            } else {\n                fab.setImageResource(R.drawable.heart_fill);\n            }\n            isFavorite = true;\n        }\n    }\n\n    @Override\n    public void showNonFavoriteMovie() {\n        if (isFavorite) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n                AnimatedVectorDrawable fullHeart = (AnimatedVectorDrawable)\n                        fullHeartConstantState.newDrawable();\n                fab.setImageDrawable(fullHeart);\n                fullHeart.start();\n\n            } else {\n                fab.setImageResource(R.drawable.fab_heart_empty);\n            }\n            isFavorite = false;\n        }\n    }\n    @Override\n    public void showWatchlistMovie() {\n        toggleWatchlist.setChecked(true);\n    }\n\n    @Override\n    public void showNormalMovie() {\n        toggleWatchlist.setChecked(false);\n    }\n\n    @Override\n    public void showRuntime(String runtime) {\n        textRuntime.setText(runtime);\n    }\n\n    @Override\n    public void showOmdbDetails(MovieDetails movieDetails) {\n        textGenres.setText(movieDetails.genre());\n        imageMpaaRating.setImageDrawable(ContextCompat.getDrawable(this\n                ,chooseRatingImage(movieDetails.rated())));\n    }\n\n    @Override\n    public void showReviewMessage(String message) {\n        Snackbar.make(coordinatorLayout,message,Snackbar.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void showShareIcon(String trailerUrl) {\n        sharedTrailerUrl = trailerUrl;\n        supportInvalidateOptionsMenu();\n    }\n\n    @Override\n    public void showPlayMainTrailer(Uri mainTrailerUri) {\n        this.mainTrailerUri = mainTrailerUri;\n        buttonPlayTrailer.setVisibility(View.VISIBLE);\n    }\n\n    private @DrawableRes\n    int chooseRatingImage(String rating){\n        switch (rating){\n            case \"PG-13\":\n                return R.drawable.ic_rated_pg_13;\n            case \"PG\":\n                return R.drawable.ic_rated_pg;\n            case \"R\":\n                return R.drawable.ic_rated_r;\n            case \"G\":\n                return R.drawable.ic_rated_g;\n            case \"NC-17\":\n                return R.drawable.ic_rated_nc_17;\n            default:\n                return R.drawable.ic_not_applicable;\n        }\n    }\n\n    @OnClick(R.id.fab_favorite)\n    public void onFabClicked(){\n        if (isFavorite){\n            presenter.removeMovieFromFavorites(movie.id());\n        }else {\n            presenter.addMovieToFavorites(movie);\n        }\n    }\n\n    @OnClick(R.id.toggle_watchlist)\n    public void onWatchlistClicked(){\n        if (!toggleWatchlist.isChecked()){\n            presenter.removeMovieFromWatchlist(movie.id());\n        }else {\n            presenter.addMovieToWatchlist(movie);\n        }\n    }\n\n    @OnClick({R.id.image_backdrop,R.id.button_play_main_trailer})\n    public void onPlayTrailerClicked(){\n        if (mainTrailerUri != null) {\n            Intent intent = new Intent(Intent.ACTION_VIEW,mainTrailerUri);\n            startActivity(intent);\n        }\n    }\n\n    private void setupViews(){\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n            fullHeartConstantState = ContextCompat.getDrawable(this,R.drawable.fab_heart_fill).getConstantState();\n            emptyHeartConstantState = ContextCompat.getDrawable(this,R.drawable.fab_heart_empty).getConstantState();\n            getWindow().setStatusBarColor(ContextCompat.getColor(this,R.color.transparent_black));\n        }\n        setSupportActionBar(toolbar);\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        presenter.isMovieFavorite(movie.id());\n        presenter.isMovieInWatchlist(movie.id());\n\n\n\n        getSupportActionBar().setDisplayShowTitleEnabled(false);\n        toolbarMovieTitle.setAlpha(0);\n        toolbarMovieTitle.setText(movie.title());\n        appBarLayout.addOnOffsetChangedListener(this);\n        populateMovieDetilas();\n    }\n\n    private void populateMovieDetilas(){\n        textMovieTitle.setText(movie.title());\n        release.setText(Utilities.getFormattedDate(movie.releaseDate(),Utilities.MONTH_YEAR_DATE_FORMAT));\n        Picasso.with(this)\n                .load(Utilities.getFullPosterPath(this,movie.posterPath(),Utilities.QUALITY_LOW))\n                .networkPolicy(NetworkPolicy.OFFLINE)\n                .transform(new PaletteTransformation())\n                .into(posterImage, new PaletteTransformation.Callback(posterImage) {\n                    @Override\n                    public void onPalette(Palette palette) {\n                        if (palette != null) {\n                            Palette.Swatch darkVibrantSwatch = palette.getDarkVibrantSwatch();\n                            if (collapsingToolbar != null && darkVibrantSwatch != null) {\n                                int darkVibrantColor = darkVibrantSwatch.getRgb();\n                                collapsingToolbar.setContentScrimColor(darkVibrantColor);\n                                collapsingToolbar.setStatusBarScrimColor(darkVibrantColor);\n                                detailsTabLayout.setBackgroundColor(darkVibrantColor);\n                                GradientDrawable gradient = new GradientDrawable\n                                        (GradientDrawable.Orientation.TL_BR,new int[]{\n                                                blackColor,\n                                                darkVibrantColor\n                                        });\n                                gradient.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n                                appbarConstraintLayout.setBackground(gradient);\n                            }\n                        }\n                    }});\n\n        Picasso.with(this).load(Utilities.getFullBackdropPath(this,movie.backdropPath()\n                ,Movie.QUALITY_MEDIUM)).fit().centerCrop()\n                .into(blurPoster, new Callback() {\n                    @Override\n                    public void onSuccess() {\n                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                            enterReveal();\n                        }else {\n                            blurPoster.setVisibility(View.VISIBLE);\n                        }\n                    }\n                    @Override\n                    public void onError() {\n                    }\n                });\n    }\n\n\n    @Override\n    public boolean onNavigateUp() {\n        supportFinishAfterTransition();\n        return true;\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.activity_movie_details,menu);\n        if (sharedTrailerUrl != null){\n            menu.findItem(R.id.menu_share).setVisible(true);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()){\n            case android.R.id.home:\n                onNavigateUp();\n                return true;\n            case R.id.menu_share:\n                Utilities.createShareIntent(this,movie.title(), sharedTrailerUrl);\n                Timber.d(\"Share Clicked!\");\n                return true;\n        }\n        return false;\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        presenter.detachView();\n        ((PopularMoviesApplication)getApplication()).releaseMovieDetailsComponent();\n    }\n\n    @Override\n    public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {\n        if(collapsingToolbar.getHeight() + verticalOffset > collapsingToolbar.getScrimVisibleHeightTrigger()){\n            toolbarMovieTitle.animate().alpha(0).setDuration(250);\n        }else {\n            toolbarMovieTitle.animate().alpha(1).setDuration(500);\n\n        }\n    }\n\n\n    @Override\n    public void delegateItemClicked(Object item, ImageView sharedView) {\n        //Dosen't handle master/detail views\n        Intent intent;\n        String transitionName = \"\";\n        if (item instanceof Cast){\n            Cast clickedCastItem = (Cast) item;\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {\n                transitionName = sharedView.getTransitionName();\n                intent = ActorDetailsActivity.getActorDetailsIntent(this,clickedCastItem,transitionName);\n                ActivityOptions activityOptions = ActivityOptions\n                        .makeSceneTransitionAnimation(this,sharedView,sharedView.getTransitionName());\n                startActivity(intent,activityOptions.toBundle());\n\n            }else {\n                intent = ActorDetailsActivity.getActorDetailsIntent(this,clickedCastItem,transitionName);\n                startActivity(intent);\n            }\n        }else if (item instanceof Movie){\n            Movie clickedMovie = (Movie) item;\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {\n                transitionName = sharedView.getTransitionName();\n                intent = getMovieDetailsIntent(this,clickedMovie,transitionName);\n                ActivityOptions activityOptions = ActivityOptions\n                        .makeSceneTransitionAnimation(this,sharedView,sharedView.getTransitionName());\n                startActivity(intent,activityOptions.toBundle());\n\n            }else {\n                intent = MovieDetailsActivity.getMovieDetailsIntent(this,clickedMovie,transitionName);\n                startActivity(intent);\n            }\n        }\n        else {\n            throw new IllegalArgumentException(\"Unknown item type\");\n        }\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/ShowDetailsInActivity.java\npublic interface ShowDetailsInActivity {\n    void showRuntime(String runtime);\n    void showOmdbDetails(MovieDetails movieDetails);\n    void showReviewMessage(String message);\n    void showShareIcon(String trailerUrl);\n    void showPlayMainTrailer(Uri mainTrailerUrl);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/common/utilities/DelegateToActivity.java\npublic interface DelegateToActivity<T> {\n    void delegateItemClicked(T item, ImageView sharedView);\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/PopularMoviesApplication.java\npublic class PopularMoviesApplication extends Application {\n    private static ApplicationComponent applicationComponent;\n    private BrowseMoviesComponent browseMoviesComponent;\n    private MovieDetailsComponent movieDetailsComponent;\n    private MovieInfoComponent movieInfoComponent;\n    private NearbyMoviesComponent nearbyMoviesComponent;\n    private FavoriteMoviesComponent favoriteMoviesComponent;\n    private WatchlistComponent watchlistComponent;\n    private MovieReviewsComponent movieReviewsComponent;\n    private MovieCastComponent movieCastComponent;\n    private ActorInfoComponent actorInfoComponent;\n    private ActorMoviesComponent actorMoviesComponent;\n    private ActorDetailsComponent actorDetailsComponent;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        if (LeakCanary.isInAnalyzerProcess(this)) {\n            // This process is dedicated to LeakCanary for heap analysis.\n            // You should not init your app in this process.\n            return;\n        }\n        LeakCanary.install(this);\n        applicationComponent = createAppComponent();\n\n        Timber.plant(new Timber.DebugTree() {\n            @Override\n            protected String createStackElementTag(StackTraceElement element) {\n                return super.createStackElementTag(element) + ':' + element.getLineNumber();\n            }\n        });\n\n\n    }\n\n    private ApplicationComponent createAppComponent() {\n        return DaggerApplicationComponent.builder().applicationModule(new ApplicationModule(this))\n                .castRepositoryModule(new CastRepositoryModule())\n                .moviesRepositoryModule(new MoviesRepositoryModule())\n                .build();\n    }\n\n    public BrowseMoviesComponent createBrowseMoviesComponent(){\n         browseMoviesComponent = applicationComponent.plus(new BrowseMoviesModule());\n\n        return browseMoviesComponent;\n    }\n\n    public MovieDetailsComponent createMovieDetailsComponent(){\n        movieDetailsComponent = applicationComponent.plusMovieDetailsComponent();\n        return movieDetailsComponent;\n    }\n\n    public NearbyMoviesComponent createNearbyMoviesComponent(){\n        nearbyMoviesComponent = applicationComponent.plus(new NearbyMoviesModule());\n        return nearbyMoviesComponent;\n    }\n\n    public FavoriteMoviesComponent createFavoriteMoviesComponent(){\n        favoriteMoviesComponent = applicationComponent.plus(new FavoriteMoviesModule());\n        return favoriteMoviesComponent;\n    }\n\n    public WatchlistComponent createWatchlistComponent(){\n        watchlistComponent = applicationComponent.plus(new WatchlistModule());\n        return watchlistComponent;\n    }\n    public MovieInfoComponent createMovieInfoComponent(){\n        movieInfoComponent = applicationComponent.plus(new MovieInfoModule());\n        return movieInfoComponent;\n    }\n    public MovieReviewsComponent createMovieReviewsComponent(){\n        movieReviewsComponent = applicationComponent.plus(new MovieReviewsModule());\n        return movieReviewsComponent;\n    }\n    public MovieCastComponent createMovieCastComponent(){\n        movieCastComponent = applicationComponent.plus(new MovieCastModule());\n        return movieCastComponent;\n    }\n\n    public ActorInfoComponent createActorInfoComponent(){\n        actorInfoComponent = applicationComponent.plus(new ActorInfoModule());\n        return actorInfoComponent;\n    }\n\n    public ActorMoviesComponent createActorMoviesComponent(){\n        actorMoviesComponent = applicationComponent.plus(new ActorMoviesModule());\n        return actorMoviesComponent;\n    }\n    public ActorDetailsComponent createActorDetailsComponent(){\n        actorDetailsComponent = applicationComponent.plusActorDetailsComponent();\n        return actorDetailsComponent;\n    }\n\n\n    public void releaseBrowseMoviesComponent(){\n        browseMoviesComponent = null;\n    }\n    public void releaseMovieDetailsComponent(){\n        movieDetailsComponent = null;\n    }\n    public void releaseNearbyMoviesComponent(){\n        nearbyMoviesComponent = null;\n    }\n    public void releaseFavoriteMoviesComponent(){\n        favoriteMoviesComponent = null;\n    }\n    public void releaseWatchlistMoviesComponent(){\n        watchlistComponent = null;\n    }\n    public void releaseMovieInfoComponent(){\n        movieInfoComponent = null;\n    }\n    public void releaseMovieReviewsComponent(){\n        movieReviewsComponent = null;\n    }\n    public void releaseMovieCastComponent(){\n        movieCastComponent = null;\n    }\n    public void releaseActorInfoComponent(){actorInfoComponent = null;}\n    public void releaseActorMoviesComponent(){actorMoviesComponent = null;}\n    public void releaseActorDetailsComponent(){actorDetailsComponent = null;}\n\n\n\n    public static ApplicationComponent getApplicationComponent(){\n        return applicationComponent;\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/discoverMovies/BrowseMoviesActivity.java\npublic class BrowseMoviesActivity extends BaseActivity implements DelegateToActivity<Movie> {\n\n    @BindView(R.id.slidingTabs) TabLayout tabLayout;\n    @BindView(R.id.viewpager) ViewPager viewPager;\n    @BindView(R.id.navigation_view) NavigationView navigationView;\n    @BindView(R.id.browse_toolbar) Toolbar toolbar;\n    private BrowseMoviesPagerAdapter browseMoviesPagerAdapter;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_browse_movies);\n        navigationView.setCheckedItem(R.id.nav_discover);\n        browseMoviesPagerAdapter = new BrowseMoviesPagerAdapter(getSupportFragmentManager());\n        viewPager.setAdapter(browseMoviesPagerAdapter);\n        tabLayout.setupWithViewPager(viewPager);\n        toolbar.setTitle(R.string.nav_discover_title);\n        super.onCreateBaseActivity(savedInstanceState);\n\n    }\n\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if(requestCode == NearbyMoviesFragment.REQUEST_RESOLVE_ERROR){\n            browseMoviesPagerAdapter.getItem(viewPager.getCurrentItem())\n                    .onActivityResult(requestCode,resultCode,data);\n        }else {\n            super.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n}\n", "answers": ["    private DelegateToActivity<Movie> delegateListener;"], "length": 1661, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "31ce3569263336194441a7715e1766ab4954b250a5082477"}
{"input": "import static org.jboss.remotingjmx.protocol.v1.Constants.ADD_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.ATTRIBUTE_LIST;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.BOOLEAN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.CREATE_MBEAN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.EXCEPTION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.FAILURE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_DEFAULT_DOMAIN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_DOMAINS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_MBEAN_COUNT;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INSTANCE_OF;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INTEGER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INTEGER_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INVOKE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.IS_REGISTERED;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.NOTIFICATION_FILTER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_EXP;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_MBEANS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_NAMES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.REMOVE_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.RESPONSE_MASK;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SEND_NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.STRING;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.STRING_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SUCCESS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.UNREGISTER_MBEAN;\nimport java.io.DataInput;\nimport java.io.DataInputStream;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.security.AccessController;\nimport java.security.PrivilegedExceptionAction;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.Executor;\nimport javax.management.Attribute;\nimport javax.management.AttributeList;\nimport javax.management.AttributeNotFoundException;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.InstanceNotFoundException;\nimport javax.management.IntrospectionException;\nimport javax.management.InvalidAttributeValueException;\nimport javax.management.JMRuntimeException;\nimport javax.management.ListenerNotFoundException;\nimport javax.management.MBeanException;\nimport javax.management.MBeanInfo;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MBeanServerConnection;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.Notification;\nimport javax.management.NotificationFilter;\nimport javax.management.NotificationListener;\nimport javax.management.ObjectInstance;\nimport javax.management.ObjectName;\nimport javax.management.QueryExp;\nimport javax.management.ReflectionException;\nimport org.jboss.logging.Logger;\nimport org.jboss.marshalling.AbstractClassResolver;\nimport org.jboss.marshalling.Marshaller;\nimport org.jboss.marshalling.Unmarshaller;\nimport org.jboss.remoting3.Channel;\nimport org.jboss.remoting3.MessageInputStream;\nimport org.jboss.remotingjmx.ServerMessageInterceptor;\nimport org.jboss.remotingjmx.ServerMessageInterceptor.Event;\nimport org.jboss.remotingjmx.VersionedProxy;\nimport org.jboss.remotingjmx.WrappedMBeanServerConnection;\nimport org.xnio.IoUtils;\n                paramType = unmarshaller.readByte();\n                if (paramType != OBJECT) {\n                    throw new IOException(\"Unexpected paramType\");\n                }\n                handback = unmarshaller.readObject();\n            } catch (ClassNotFoundException cnfe) {\n                throw new IOException(cnfe);\n            }\n\n            try {\n                if (remoteNotification) {\n                    remoteNotificationManager.addNotificationListener(name, listenerId, filter, handback);\n                } else {\n                    server.getMBeanServerConnection().addNotificationListener(name, listener, filter, handback);\n                }\n\n                writeResponse(ADD_NOTIFICATION_LISTENER, correlationId);\n\n                log.tracef(\"[%d] AddNotificationListener - Success Response Sent\", correlationId);\n            } catch (InstanceNotFoundException e) {\n                writeResponse(e, ADD_NOTIFICATION_LISTENER, correlationId);\n                log.tracef(\"[%d] AddNotificationListener - Failure Response Sent\", correlationId);\n            }\n        }\n    }\n\n    private class CreateMBeanHandler implements Common.MessageHandler {\n\n        @Override\n        public void handle(DataInput input, final int correlationId) throws IOException {\n            log.trace(\"CreateMBean\");\n            byte paramType = input.readByte();\n            if (paramType != INTEGER) {\n                throw new IOException(\"Unexpected paramType\");\n            }\n            int paramCount = input.readInt();\n            String className = null;\n            ObjectName name = null;\n            ObjectName loader = null;\n            Object[] params = null;\n            String[] signature = null;\n            final ClassLoaderSwitchingClassResolver resolver = new ClassLoaderSwitchingClassResolver(\n                    ServerProxy.class.getClassLoader());\n            Unmarshaller unmarshaller = prepareForUnMarshalling(input, resolver);\n            for (int i = 0; i < paramCount; i++) {\n                byte param = unmarshaller.readByte();\n                switch (param) {\n                    case STRING:\n                        if (className == null) {\n                            className = unmarshaller.readUTF();\n                        } else {\n                            throw new IOException(\"Unexpected paramter\");\n                        }\n                        break;\n                    case OBJECT_NAME:\n                        try {\n                            if (name == null) {\n                                name = unmarshaller.readObject(ObjectName.class);\n                            } else if (loader == null) {\n                                loader = unmarshaller.readObject(ObjectName.class);\n                                switchClassLoaderForLoader(loader, resolver);\n                            } else {\n                                throw new IOException(\"Unexpected paramter\");\n                            }\n                        } catch (ClassNotFoundException e) {\n                            throw new IOException(e);\n                        }\n                        break;\n                    case OBJECT_ARRAY:\n                        if (params == null) {\n                            int count = unmarshaller.readInt();\n                            params = new Object[count];\n                            for (int j = 0; j < count; j++) {\n                                try {\n                                    params[j] = unmarshaller.readObject();\n                                } catch (ClassNotFoundException e) {\n                                    throw new IOException(e);\n                                }\n                            }\n                        } else {\n                            throw new IOException(\"Unexpected paramter\");\n                        }\n\n                        break;\n                    case STRING_ARRAY:\n                        if (signature == null) {\n                            int count = unmarshaller.readInt();\n                            signature = new String[count];\n                            for (int j = 0; j < count; j++) {\n                                signature[j] = unmarshaller.readUTF();\n                            }\n                        } else {\n                            throw new IOException(\"Unexpected paramter\");\n                        }\n\n                        break;\n                    default:\n                        throw new IOException(\"Unexpected paramter\");\n                }\n            }\n\n            try {\n                final ObjectInstance instance;\n                switch (paramCount) {\n                    case 2:\n                        instance = server.getMBeanServerConnection().createMBean(className, name);\n                        break;\n                    case 3:\n                        instance = server.getMBeanServerConnection().createMBean(className, name, loader);\n                        break;\n                    case 4:\n                        instance = server.getMBeanServerConnection().createMBean(className, name, params, signature);\n                        break;\n                    case 5:\n                        instance = server.getMBeanServerConnection().createMBean(className, name, loader, params, signature);\n                        break;\n                    default:\n                        throw new IOException(\"Unable to identify correct create method to call.\");\n                }\n", "context": "src/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte BOOLEAN = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_NAME = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_ATTRIBUTES = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_EXP = 0x07;\nsrc/main/java/org/jboss/remotingjmx/ServerMessageInterceptor.java\npublic interface Event {\n    void run() throws IOException;\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ADD_NOTIFICATION_LISTENER = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_OBJECT_INSTANCE = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/VersionedProxy.java\npublic interface VersionedProxy {\n\n    String getConnectionId();\n\n    void close();\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte NOTIFICATION_FILTER = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_MBEAN_INFO = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte EXCEPTION = 0x03;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte FAILURE = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte CREATE_MBEAN = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte UNREGISTER_MBEAN = 0x02;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_MBEANS = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_INSTANCE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte NOTIFICATION = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte STRING_ARRAY = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_ATTRIBUTE = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_DOMAINS = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SEND_NOTIFICATION = 0x13;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_DEFAULT_DOMAIN = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte MBEAN_INFO = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/ServerMessageInterceptor.java\npublic interface ServerMessageInterceptor {\n\n    /**\n     * Called to handle the actual event, gives the Interceptor an opportunity to wrap the call.\n     *\n     * @param event - The event to run.\n     * @throws IOException - If thrown from the event.\n     */\n    void handleEvent(final Event event) throws IOException;\n\n    public interface Event {\n        void run() throws IOException;\n    }\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_OBJECT_NAME = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte RESPONSE_MASK = (byte) 0x80;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ATTRIBUTE = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INTEGER_ARRAY = 0x12;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SUCCESS = 0x00;\nsrc/main/java/org/jboss/remotingjmx/WrappedMBeanServerConnection.java\npublic interface WrappedMBeanServerConnection {\n\n    MBeanServerConnection getMBeanServerConnection();\n\n    void connectionOpened(final VersionedProxy proxy);\n\n    void connectionClosed(final VersionedProxy proxy);\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INSTANCE_OF = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte IS_REGISTERED = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_NAMES = 0x05;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_ATTRIBUTES = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_ARRAY = 0x05;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_ATTRIBUTE = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte STRING = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INVOKE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_MBEAN_COUNT = 0x07;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_OBJECT_INSTANCE = 0x03;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INTEGER = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ATTRIBUTE_LIST = 0x02;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte REMOVE_NOTIFICATION_LISTENER = 0x12;\n", "answers": ["                writeResponse(instance, OBJECT_INSTANCE, CREATE_MBEAN, correlationId);"], "length": 953, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "feeef9aaf0fc0be21c3fc0124904f5755baa327e041f60dd"}
{"input": "import discord\nfrom discord.ext import commands\nfrom discord.ext.commands import BadArgument\nfrom clembot.config.constants import MyEmojis\nfrom clembot.core.bot import group\nfrom clembot.core.commands import Cog\nfrom clembot.core.logs import Logger\nfrom clembot.core.utils import notify_for\nfrom clembot.exts.config import channel_checks\nfrom clembot.exts.config.guild_metadata import GuildMetadata\nfrom clembot.exts.gymmanager.gym import POILocationConverter\nfrom clembot.exts.pkmn.gm_pokemon import Pokemon\nfrom clembot.exts.profile.user_guild_profile import UserGuildProfile\nfrom clembot.exts.wild.wild import Wild\nfrom clembot.utilities.utils import snowflake\n\n\n\nclass WildCog(commands.Cog):\n\n\n    wild_SYNTAX_ATTRIBUTE = ['gym', 'others']\n\n    def __init__(self, bot):\n        self.bot = bot\n        self.bot.loop.create_task(self.load_wild_reports())\n\n\n    async def load_wild_reports(self):\n        await Pokemon.load(self.bot)\n        for rcrd in await Wild.find_all(self.bot):\n            self.bot.loop.create_task(self.load_wild_report(rcrd))\n\n\n    async def load_wild_report(self, rcrd):\n        Logger.info(f\"load_wild_report({rcrd.get('wild_id', None)})\")\n        wild = await Wild.from_db_dict(self.bot, rcrd)\n        wild.monitor_task = wild.create_task_tuple(wild.monitor_status())\n\n\n    @group(pass_context=True, category='Bot Info', aliases=[\"wild\"])\n    @channel_checks.wild_report_enabled()\n    async def cmd_wild(self, ctx, pokemon: Pokemon, *loc):\n        \"\"\"Reports a wild spawn\n        **Arguments**\n        *pokemon* The name of the wild pokemon\n        *location* The location of the spawn\n\n        If the location is a gym, directions will be accurate otherwise I will\n        just provide a link for **location** + city of the channel.\n        \"\"\"\n\n        timezone = await ctx.timezone()\n        wild_id = next(snowflake.create())\n        if len(loc) == 0:\n            raise BadArgument(\"Ohh, that's awesome, but where? I can't create a report without location.\")\n        location = await POILocationConverter.convert(ctx, ' '.join(loc))\n\n        wild = Wild(self.bot, wild_id=wild_id, guild_id=ctx.guild.id, reporter_id=ctx.message.author.id,\n                    pkmn=pokemon, location=location, timezone=timezone)\n\n        message_content = None\n        role = await notify_for(self.bot, ctx.guild, pokemon.id)\n        if role:\n            message_content=f\"A wild {role.mention} spotted by {ctx.message.author.mention}.\"\n\n        if message_content:\n            wild_report = await ctx.send(content=message_content, embed=wild.wild_embed(ctx))\n        else:\n            wild_report = await ctx.send(embed=wild.wild_embed(ctx))\n\n", "context": "clembot/core/commands.py\nclass Cog(Cog):\n\n\n    pass\nclembot/config/constants.py\nclass MyEmojis:\n\n    DESPAWNED = '💨'\n    ON_MY_WAY = '🏎️'\n    TRASH = '🗑️'\n\n    REMOTE = f\"{parse_emoji(None, config_template.misc_emoji.get('remote_raid'))}\"\n    INVITE = f\"{parse_emoji(None, config_template.misc_emoji.get('add_friend'))}\"\n    HERE = f\"{parse_emoji(None, config_template.misc_emoji.get('here'))}\"\n    COMING = f\"{parse_emoji(None, config_template.misc_emoji.get('coming'))}\"\n    INTERESTED = f\"{parse_emoji(None, config_template.misc_emoji.get('interested'))}\"\n    INFO = f\"{parse_emoji(None, config_template.misc_emoji.get('info'))}\"\n    ERROR = f\"{parse_emoji(None, config_template.misc_emoji.get('error'))}\"\n    POKE_BATTLER = f\"{parse_emoji(None, config_template.misc_emoji.get('pb'))}\"\nclembot/exts/profile/user_guild_profile.py\nclass UserGuildProfile:\n\n    TABLE_NAME = 'user_guild_profile'\n\n    dict_fields = ['leaderboard_status']\n    list_fields = ['badge_id']\n\n    LEADERBOARD_STATS = ['wilds', 'raids', 'quests', 'eggs', 'nest', 'rocket']\n\n    def __init__(self, bot, db_dict = dict()):\n        self.bot = bot\n        self.db_dict = {\n            'user_id' : None,\n            'guild_id' : None,\n            'badge_id' :  [],\n            'leaderboard_status' : {},\n            'status' : None\n        }\n        self.db_dict.update(Serializer.deserialize(db_dict, dict_fields=UserGuildProfile.dict_fields))\n\n\n    def __getitem__(self, item):\n        return self.db_dict.get(item) or ([] if item in UserGuildProfile.list_fields else None) or ({} if item in UserGuildProfile.dict_fields else None)\n\n\n    def __setitem__(self, key, value):\n        \"\"\"use [] operator to access members, simpler to create entity objects. Handles array kind of values.\"\"\"\n        if key in UserGuildProfile.list_fields:\n            if self.db_dict[key] is None or value is None:\n                self.db_dict[key] = []\n            if value:\n                self.db_dict[key].append(value)\n        else:\n            self.db_dict[key] = value\n\n\n    @classmethod\n    async def data(cls, bot, user_id, guild_id) -> dict():\n        report_user_query = bot.dbi.table('user_metadata').query()\n        _data = report_user_query.where(user_id=user_id, guild_id=guild_id)\n        db_record = await _data.get()\n\n        if db_record:\n            user_metadata = UserGuildProfile.from_db_dict(bot, dict(db_record[0]))\n        else:\n\n            user_metadata = UserGuildProfile(bot, user_id, guild_id)\n            await user_metadata.insert()\n\n        return user_metadata\n\n\n    @classmethod\n    async def find(cls, bot, user_id, guild_id):\n        table = bot.dbi.table(UserGuildProfile.TABLE_NAME)\n        query = table.query().select().where(user_id=user_id, guild_id=guild_id)\n        user_list = await query.getjson()\n        if user_list:\n            return cls(bot, user_list[0])\n        else:\n            await UserGuildProfile.create(bot, user_id, guild_id)\n            query = table.query().select().where(user_id=user_id, guild_id=guild_id)\n            user_list = await query.getjson()\n            if user_list:\n                return cls(bot, user_list[0])\n        return None\n\n\n    @classmethod\n    async def create(cls, bot, user_id, guild_id):\n        user_guild_profile = UserGuildProfile(bot, {'user_id': user_id, 'guild_id': guild_id})\n        await user_guild_profile.insert()\n        return user_guild_profile\n\n\n    async def update(self):\n        table = self.bot.dbi.table(UserGuildProfile.TABLE_NAME)\n        update_dict=Serializer.serialize(self.db_dict)\n        update_query = table.update(**update_dict).where(user_id=self['user_id'], guild_id=self['guild_id'])\n        await update_query.commit()\n\n\n    async def insert(self):\n        table = self.bot.dbi.table(UserGuildProfile.TABLE_NAME)\n        insert_dict=Serializer.serialize(self.db_dict)\n        insert_query = table.insert(**insert_dict)\n        await insert_query.commit()\n\n\n    def record_report(self, stat_type, board_type='lifetime', increase_by=1, initialize=False):\n        \"\"\"\n            record_report('eggs','lifetime') => increases by 1\n            record_report('raids','lifetime', initialize=True) => set to 1\n            record_report('wilds','lifetime', increase_by=0, initialize=True) => set to 0\n            record_report('quests','lifetime', increase_by=12, initialize=True) => set to 12\n        \"\"\"\n        if stat_type in UserGuildProfile.LEADERBOARD_STATS:\n            current_stat = 0 if initialize else _.get(self.db_dict,f'leaderboard_status.{board_type}.{stat_type}', 0)\n            self.db_dict.setdefault('leaderboard_status',{}).setdefault(board_type, {})[stat_type] = current_stat + increase_by\n\n\n    def leaderboard_stats_dict(self, board_type):\n        return _.get(self.db_dict, f'leaderboard_status.{board_type}')\n\n\n\n    def leaderboard_status(self, board_type):\n        status_dict = _.get(self.db_dict, f'leaderboard_status.{board_type}')\n\n        wilds, raids, quests, eggs, nest, rocket = ([status_dict.get(stat, 0) for stat in UserGuildProfile.LEADERBOARD_STATS])\n\n        status_text = f\"Raids: **{raids}** | Eggs: **{eggs}** | Wilds: **{wilds}** | Research: **{quests}** | Nest: **{nest}** | Grunts: **{rocket}**\"\n\n        return status_text\n\n    @property\n    def user_id(self):\n        return self['user_id']\n\n    @classmethod\n    async def find_top10_reporters(cls, bot, guild_id, leaderboard_type, stat_type):\n\n        query = top_10_leaderboard_query\n        query_args = [guild_id, f'{leaderboard_type}', f'{leaderboard_type}', None if stat_type == 'total' else stat_type , 10]\n        user_rcrd_list = await bot.dbi.execute_query_json(query, *query_args)\n\n        return user_rcrd_list\nclembot/exts/gymmanager/gym.py\nclass POILocationConverter(commands.Converter):\n    \"\"\"\n    !nest chimchar MESC\n    !nest pikachu somewhere closer\n    !nest aron some park http://google-url.com\n    \"\"\"\n\n    @staticmethod\n    async def convert_from_text(ctx, *argument) -> POILocation:\n\n        try:\n            if len(argument) == 1:\n                city = await ctx.city()\n                gym = await GymRepository(ctx.bot.dbi).to_gym_by_code_city(argument[0], city)\n                if gym:\n                    return POILocation.from_gym(gym)\n\n            text = \" \".join(argument)\n            maps_link = TextUtil.extract_link_from_text(text)\n            if maps_link:\n                new_text = text.replace(maps_link, '')\n                return POILocation.from_url( new_text if new_text.__len__() > 0 else \"Click for directions\", maps_link)\n\n            return POILocation.from_location_city(text, \"\")\n\n        except Exception as error:\n            raise BadArgument(error)\n\n\n    @staticmethod\n    async def convert(ctx, argument) -> POILocation:\n        try:\n            city = await ctx.city()\n            if city is None:\n                city = await ctx.guild_profile(key='city')\n            gym = await GymRepository(ctx.bot.dbi).to_gym_by_code_city(argument, city)\n\n            if gym:\n                return POILocation.from_gym(gym)\n            else:\n                return POILocation.from_location_city(argument, city)\n        except Exception as error:\n            raise BadArgument(error)\n\n    @staticmethod\n    def combine(location_list):\n\n        location_text = []\n        for rl in location_list:\n            if rl.is_gym:\n                return rl\n            location_text.append(rl.location)\n\n        return POILocation.from_location_city(\" \".join(location_text), location_list[0].city)\n\n\n\n    # @staticmethod\n    # async def auto_correct(ctx, pokemon_as_text):\n    #\n    #     not_acceptable_message = f\"**{pokemon_as_text}** isn't a Pokemon!\"\n    #\n    #     spellcheck_suggestion = SpellHelper.correction(pokemon_as_text)\n    #\n    #     if spellcheck_suggestion and spellcheck_suggestion != pokemon_as_text:\n    #\n    #         not_acceptable_message += f\" Did you mean **{spellcheck_suggestion}**?\"\n    #         replace_pokemon = await Utilities.ask_confirmation(ctx, ctx.message, not_acceptable_message, \"Alright!\", \"That's okay!\", \"Timed Out!\")\n    #         if replace_pokemon:\n    #             return spellcheck_suggestion\n    #\n    #     return None\nclembot/core/bot.py\ndef group(*args, **kwargs):\n    def decorator(func):\n        category = kwargs.get(\"category\")\n        func.command_category = category\n        examples = kwargs.get(\"examples\")\n        func.examples = examples\n        error_wrapped_func = wrap_error(func)\n        result = commands.group(*args, **kwargs)(error_wrapped_func)\n        return result\n    return decorator\nclembot/core/logs.py\ndef init_loggers():\nclembot/core/utils.py\nasync def notify_for(bot, guild, role_name):\n    role = discord.utils.get(guild.roles, name=role_name.lower())\n    if role:\n        notify = await bot.data_manager.guild(guild.id).guild_profile('notifications')\n        if notify == 'true':\n            return role\n    return None\nclembot/exts/wild/wild.py\nclass Wild:\n    by_id = dict()\n    by_message = dict()\n\n    def __init__(self, bot, wild_id, guild_id, reporter_id, pkmn: Pokemon, location: POILocation = None, timezone=None,\n                 caught_by=None,\n                 message_id=None, channel_id=None, reported_time=None, despawn_time=None):\n        self.bot = bot\n        self.wild_id = wild_id\n        self.guild_id = guild_id\n        self.reporter_id = reporter_id\n        self.location = location\n        self.pkmn = pkmn\n        self.reported_time = TH.current_epoch(second_precision=True) if reported_time is None else reported_time\n        self.despawn_time = self.reported_time + (config_template.development_timer or 30) * 60 if despawn_time is None else despawn_time\n        self.message_id = message_id\n        self.channel_id = channel_id\n        self.caught_by = caught_by or []\n        self.timezone = timezone\n        self.monitor_task_tuple = None\n        self.snowflake = Snowflake()\n\n    def to_db_dict(self):\n        state = {\n            'wild_id': self.wild_id,\n            'guild_id': self.guild_id,\n            'reporter_id': self.reporter_id,\n            'pokemon_id': self.pkmn.id,\n            'location': json.dumps(self.location.to_dict()),\n            'reported_time': self.reported_time,\n            'despawn_time': self.despawn_time,\n            'message_id': self.message_id,\n            'channel_id': self.channel_id,\n            'timezone': self.timezone\n        }\n        return state\n\n\n    @classmethod\n    async def from_db_dict(cls, bot, db_dict):\n\n        wild_id, guild_id, reporter_id, pokemon_id, location, reported_time, despawn_time, message_id, channel_id, timezone = [\n            db_dict.get(attr, None) for attr in\n            ['wild_id', 'guild_id', 'reporter_id', 'pokemon_id', 'location', 'reported_time', 'despawn_time',\n             'message_id',\n             'channel_id', 'timezone']]\n\n        pkmn = Pokemon.to_pokemon(pokemon_id) if pokemon_id else None\n        wild_location = await POILocation.from_dict(bot, json.loads(location))\n\n        wild = cls(bot, wild_id=wild_id, guild_id=guild_id, reporter_id=reporter_id,\n                   pkmn=pkmn, location=wild_location, timezone=timezone,\n                   message_id=message_id, channel_id=channel_id,\n                   reported_time=reported_time, despawn_time=despawn_time)\n\n        Wild.cache(wild)\n        return wild\n\n\n    def create_task_tuple(self, coro):\n        task_id = CUIDGenerator.cuid(self.snowflake.next())\n        return self.bot.loop.create_task(coro), task_id\n\n\n    @property\n    def monitor_task(self):\n        if self.monitor_task_tuple:\n            return self.monitor_task_tuple[0]\n\n\n    @property\n    def monitor_task_id(self) -> str:\n        if self.monitor_task_tuple:\n            return self.monitor_task_tuple[1]\n\n\n    @monitor_task.setter\n    def monitor_task(self, task_tuple: tuple):\n        \"\"\" reset hatch and expiry tasks\"\"\"\n        if self.monitor_task_tuple:\n            self.monitor_task.cancel()\n        self.monitor_task_tuple = task_tuple\n\n\n    @property\n    def reported_at(self):\n        \"\"\"as Readable time\"\"\"\n        # TODO: add guild timezone\n        return TH.as_local_readable_time(self.reported_time, self.timezone)\n\n\n    def timer_info(self):\n        timer_info = f\"Reported at: {self.reported_at}\" if self.reported_time else \"\"\n        return timer_info\n\n\n    @classmethod\n    def cache(cls, wild):\n        cls.by_message[wild.message_id] = wild\n        cls.by_id[wild.wild_id] = wild\n\n\n    @classmethod\n    def evict(cls, wild):\n        cls.by_message.pop(wild.message_id, None)\n        cls.by_id.pop(wild.wild_id, None)\n\n\n    def set_message(self, message):\n        self.message_id = message.id\n        self.channel_id = message.channel.id\n\n\n    @staticmethod\n    async def find_all(bot):\n        wild_table = bot.dbi.table('wild_report')\n        wild_table_query = wild_table.query().select()\n        record_list = await wild_table_query.getjson()\n        return record_list\n\n\n    async def insert(self):\n        wild_table = self.bot.dbi.table('wild_report')\n        wild_table_insert = wild_table.insert(**self.to_db_dict())\n        await wild_table_insert.commit()\n        Wild.cache(self)\n\n\n    async def delete(self):\n        wild_table = self.bot.dbi.table('wild_report')\n        wild_table_delete = wild_table.query().where(wild_id=self.wild_id)\n        await wild_table_delete.delete()\n        Wild.evict(self)\n\n\n    def wild_embed(self, ctx):\n        return (WildEmbed.from_wild_report(ctx, self)).embed\n\n\n    def expire_embed(self):\n        return (WildEmbed.expire_embed(self)).embed\n\n\n    async def despawn(self):\n        try:\n            channel, message = await ChannelMessage.from_id(self.bot, self.channel_id, self.message_id)\n            embed = self.expire_embed()\n            await message.edit(content=\"\", embed=embed)\n            await message.clear_reactions()\n        except Exception as error:\n            Logger.info(error)\n\n        await self.delete()\n        self.monitor_task = None\n\n\n    async def monitor_status(self):\n        Logger.info(f\"{self.pkmn.label} at {self.location}\")\n        sleep_time = self.despawn_time - TH.current_epoch()\n        if sleep_time > 0:\n            await asyncio.sleep(sleep_time)\n\n        await self.despawn()\nclembot/utilities/utils/snowflake.py\nCLEM_EPOCH = 1502123160\ndef to_timestamp(_id):\ndef create():\n    def __init__(self):\n    def next(self):\n    def dumps(self, number):\n    def loads(self, value):\n    def cuid(cls, id):\ndef main():\nclass Snowflake:\nclass Base36:\nclass CUIDGenerator:\nclembot/exts/pkmn/gm_pokemon.py\nclass Pokemon:\n\n    _cache = dict()\n\n    def __init__(self, db_dict, pokedex_num, aliases=[], pokemon_form_id=None):\n        self.db_dict = db_dict\n        self.pokedex_num = pokedex_num\n        self.aliases = aliases\n        self.pokemon_form_id = pokemon_form_id\n\n    def __getitem__(self, item):\n        \"\"\"use [] operator to access members, simpler to create entity objects\"\"\"\n        return self.db_dict.get(item)\n\n\n    def __setitem__(self, key, value):\n        \"\"\"use [] operator to access members, simpler to create entity objects. Handles array kind of values.\"\"\"\n        self.db_dict[key] = value\n\n\n    def __repr__(self):\n        return self.label\n\n    @property\n    def id(self):\n        return self.aliases[0] if self.aliases else None\n\n    @property\n    def label(self):\n        return self.id.title()\n\n    # @property\n    # def label(self):\n    #     if self.pokeform_display_text:\n    #         return self.pokeform_display_text.capitalize()\n    #     return None\n\n\n    @property\n    def form(self):\n        form = _.get(self.db_dict, 'pokemonId')\n        if '_ALOLA' in form:\n            form = form.replace('_ALOLA','_ALOLA_FORM')\n        return form\n\n    @property\n    def base_attack(self):\n        return _.get(self.db_dict, 'stats.baseAttack')\n\n    @property\n    def base_defense(self):\n        return _.get(self.db_dict, 'stats.baseDefense')\n\n    @property\n    def base_stamina(self):\n        return _.get(self.db_dict, 'stats.baseStamina')\n\n    @property\n    def fast_moves(self):\n        return list(map(lambda move: move.replace(\"_FAST\", \"\"), _.get(self.db_dict, 'quickMoves')))\n\n    @property\n    def fast_moves_labels(self):\n        return list(map(lambda move: move.replace(\"_\",\" \").title() , self.fast_moves))\n\n    @property\n    def charge_moves(self):\n        return list(map(lambda move: move, _.get(self.db_dict, 'cinematicMoves')))\n\n    @property\n    def charge_moves_labels(self):\n        return list(map(lambda move: move.replace(\"_\",\" \").title() , self.charge_moves))\n\n\n    @property\n    def type1(self):\n        type1 = _.get(self.db_dict, 'type')\n        if type1:\n            return type1.replace(\"POKEMON_TYPE_\",\"\").upper()\n        return None\n\n    @property\n    def type2(self):\n        type2 = _.get(self.db_dict, 'type2')\n        if type2:\n            return type2.replace(\"POKEMON_TYPE_\", \"\").upper()\n        return None\n\n    @property\n    def types(self):\n        if self.type2:\n            return [self.type1, self.type2]\n        return [self.type1]\n\n    @property\n    def type1_icon(self):\n        if self.type1:\n            key = self.type1.lower()\n            return config_template.type_emoji[key]\n        return None\n\n    @property\n    def type2_icon(self):\n        if self.type2:\n            key = self.type2.lower()\n            return config_template.type_emoji[key]\n        return None\n\n    @property\n    def shiny(self):\n        return False\n\n    def _gender_type(self):\n        return 'X'\n\n    @property\n    def gender(self):\n        return 'MALE'\n\n\n    @property\n    def extended_label(self):\n        \"\"\"returns pokemon(pokedex) type1 type2\"\"\"\n        extended_label=f\"{self.label} ({self.pokedex_num}) {self.type1_icon}\"\n        if self.type2_icon:\n            extended_label=f\"{extended_label}{self.type2_icon}\"\n        return extended_label\n\n    @property\n    def preview_url(self):\n        url = \"https://raw.githubusercontent.com/TrainingB/Clembot/v2-rewrite/images/pkmn/\"\n        if self.form:\n            url += str(self.form)\n        if self.shiny:\n            url += '_SHINY'\n        if self._gender_type() == 'DIMORPH' and self.gender:\n            url += f'_{self.gender.upper()}'\n        url += '.png'\n        # url += '?cache=5'\n        return url\n\n    # async def color(self):\n    #     url = await self.sprite_url()\n    #     color = await formatters.url_color(url)\n    #     return color\n\n    @property\n    def raid_cp_range(self):\n        low_cp = self.calculate_cp(20, 10, 10, 10)\n        high_cp = self.calculate_cp(20, 15, 15, 15)\n        return [low_cp, high_cp]\n\n\n    def calculate_cp(self, level, attiv, defiv, staiv):\n        if None in [level, attiv, defiv, staiv]:\n            return None\n        else:\n            cpm = CPCalculator().cpM[level]\n            att = (self.base_attack + attiv)*cpm\n            defense = (self.base_defense + defiv)*cpm\n            sta = (self.base_stamina + staiv)*cpm\n            cp = math.floor((att*defense**0.5*sta**0.5)/10)\n            if cp < 10:\n                cp = 10\n            return cp\n\n    @classmethod\n    def cache(cls, form):\n        Pokemon._cache[form.aliases[0]] = form\n\n    @classmethod\n    def to_pokemon(cls, search_for):\n        if len(cls._cache) < 1:\n            raise Exception(\"Error : Pokemon forms are not loaded yet.\")\n\n        if search_for:\n            return cls._cache.get(search_for.upper(), None)\n\n        return None\n\n    @classmethod\n    async def load(cls, bot):\n\n        if len(Pokemon._cache) == 0:\n            table = bot.dbi.table('PB_POKEMON_FORM')\n            forms = await table.query().select().getjson()\n\n            for form in forms:\n                pForm = Pokemon(json.loads(form.get('data')), form.get('pokedex_id'), form.get('aliases'), form.get('pokemon_form_id'))\n                Pokemon.cache(pForm)\n        GMPokemonFormSpellHelper.set_dictionary(cls._cache.keys())\n\n    @classmethod\n    async def convert(cls, ctx, argument) :\n\n        await cls.load(ctx.bot)\n\n        pokemon_form = cls.to_pokemon(argument.upper())\n        if pokemon_form:\n            return pokemon_form\n        else:\n            possible_pokemon_form = await Pokemon.auto_correct(ctx, argument.upper())\n            if possible_pokemon_form:\n                pokemon_form = cls.to_pokemon(possible_pokemon_form)\n                return pokemon_form\n\n        raise BadArgument(f\"{argument} could not be resolved to a pokemon.\")\n\n    @staticmethod\n    async def auto_correct(ctx, pokemon_as_text):\n\n        not_acceptable_message = f\"**{pokemon_as_text}** isn't a Pokemon!\"\n\n        suggestion = GMPokemonFormSpellHelper.correction(pokemon_as_text)\n\n        if suggestion and suggestion != pokemon_as_text:\n\n            not_acceptable_message += f\" Did you mean **{suggestion}**?\"\n            replace_pokemon = await Utilities.ask_confirmation(ctx, ctx.message, not_acceptable_message, \"Alright!\", \"That's okay!\", \"Timed Out!\")\n            if replace_pokemon:\n                return suggestion\n\n        return None\n\n\n\n\n\n    @property\n    def weaknesses(self):\n        \"\"\"\n        Given a Pokemon name, return a list of its weaknesses as defined in the type chart\n        Calculate sum of its weaknesses and resistances.\n        -2 == immune , -1 == NVE, 0 == neutral, 1 == SE, 2 == double SE\n        \"\"\"\n        type_eff = {}\n        for p_type in self.types:\n            for atk_type in _TYPE_CHART[p_type]:\n                if atk_type not in type_eff:\n                    type_eff[atk_type] = 0\n                type_eff[atk_type] += _TYPE_CHART[p_type][atk_type]\n\n        # Summarize into a list of weaknesses,\n        # sorting double weaknesses to the front and marking them with 'x2'.\n        ret = []\n        for p_type, effectiveness in sorted(type_eff.items(), key=lambda x: x[1], reverse=True):\n            if effectiveness == 1:\n                ret.append(p_type.lower())\n            elif effectiveness == 2:\n                ret.append(p_type.lower() + \"x2\")\n\n        return ret\n\n\n    @property\n    def weaknesses_icon(self):\n        \"\"\"\n        Given a list of weaknesses, return a space-separated string of their type IDs as defined in the type_id_dict\n        \"\"\"\n        ret = \"\"\n        for weakness in self.weaknesses:\n            # Handle an \"x2\" postfix defining a double weakness\n            x2 = \"\"\n            if weakness[-2:] == \"x2\":\n                weakness = weakness[:-2]\n                x2 = \"x2\"\n\n            # Append to string\n            ret += config_template.type_emoji[weakness] + x2 + \" \"\n\n        return ret\nclembot/exts/config/channel_checks.py\nasync def _is_wild_report_channel(ctx):\nasync def _is_raid_report_channel(ctx):\nasync def _is_nest_report_channel(ctx):\ndef raid_report_enabled():\ndef wild_report_enabled():\ndef nest_report_enabled():\nclembot/exts/config/guild_metadata.py\nclass GuildMetadata:\n\n\n    def __init__(self, bot, guild):\n        self.bot = bot\n        self.guild = guild\n\n    def __eq__(self, other):\n        return self.guild.id == other.guild.id\n\n    @property\n    def _data(self):\n        report_guild_query = self.bot.dbi.table('guild_metadata').query()\n        _data = report_guild_query.where(guild_id=self.guild.id)\n        return _data\n\n\n    @classmethod\n    async def data(cls, bot, guild_id, config_name):\n\n        report_guild_query = bot.dbi.table('guild_metadata').query()\n        _data = report_guild_query.where(guild_id=guild_id, config_name=config_name)\n        db_record = await _data.get()\n\n        if db_record:\n            guild_metadata = GuildMetadata.deserialize(dict(db_record[0]))\n            return guild_metadata\n\n        return {}\n\n    @classmethod\n    async def city(cls, bot, guild_id):\n        guild_dict = await GuildMetadata.data(bot, guild_id, 'city')\n        return guild_dict.get('config_value')\n\n    @classmethod\n    async def bingo_card_repo(cls, bot, guild_id):\n        guild_dict = await GuildMetadata.data(bot, guild_id, 'bingo-card-repo') or {}\n        return guild_dict.get('config_value')\n\n    @staticmethod\n    def serialize(data_dict):\n        return _.map_values(data_dict, lambda val: json.dumps(val) if isinstance(val, dict) else val)\n\n    @staticmethod\n    def deserialize(data_dict):\n        return { k :json.loads(v) if k == 'config' and v is not None else v for (k, v) in data_dict.items()}\n\n\n    @classmethod\n    async def update(cls, bot, guild_dict):\n        guild_metadata_table = bot.dbi.table('guild_metadata')\n        update_dict=GuildMetadata.serialize(guild_dict)\n        guild_metadata_table_update = guild_metadata_table.update(**update_dict).where(guild_id=guild_dict.get('guild_id'))\n        await guild_metadata_table_update.commit()\n        GuildMetadata.cache(guild_dict)\n\n    @classmethod\n    async def insert(cls, bot, guild_dict):\n        guild_metadata_table = bot.dbi.table('guild_metadata')\n        update_dict = GuildMetadata.serialize(guild_dict)\n        guild_metadata_table_insert = guild_metadata_table.insert(**update_dict)\n        await guild_metadata_table_insert.commit()\n        GuildMetadata.cache(guild_dict)\n\n    @staticmethod\n    def embed(ctx, guild_dict):\n        return (GuildMetadataEmbed.from_guild_metadata(ctx, guild_dict)).embed\n", "answers": ["        await wild_report.add_reaction(MyEmojis.DESPAWNED)"], "length": 2162, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "f376e7b81aae7316d4e0ecc854e42de8695616f6e8946dfa"}
{"input": "import sys\nimport numpy as np\nimport matplotlib.pylab as plt\nimport os\nimport time\nimport atexit\nimport fuel\nimport signal\nimport pprint\nimport pandas as pd\nimport subprocess\nimport tqdm\nimport cPickle as pickle\nimport json\nimport numpy\nimport theano\nimport logging\nfrom theano import tensor\nfrom blocks.bricks.cost import MisclassificationRate\nfrom blocks.bricks.bn import BatchNormalization\nfrom blocks.filter import get_brick\nfrom blocks.bricks import Linear, Sequence\nfrom blocks.bricks.lookup import LookupTable\nfrom blocks.bricks.cost import CategoricalCrossEntropy\nfrom blocks.extensions import ProgressBar, Timestamp\nfrom blocks.extensions.training import TrackTheBest\nfrom dictlearn.extensions import (\n    DumpTensorflowSummaries)\nfrom blocks.extensions.predicates import OnLogRecord\nfrom blocks.serialization import load_parameters\nfrom blocks.initialization import Constant, Uniform\nfrom dictlearn.vocab import Vocabulary\nfrom dictlearn.inits import GlorotUniform\nfrom dictlearn.extensions import LoadNoUnpickling\nfrom theano import tensor as T\nfrom blocks.algorithms import (\n    GradientDescent, Adam)\nfrom blocks.graph import ComputationGraph, apply_batch_normalization, get_batch_normalization_updates\nfrom blocks.model import Model\nfrom blocks.graph.bn import (\n    apply_batch_normalization, get_batch_normalization_updates,\n    batch_normalization)\nfrom blocks.extensions import FinishAfter, Timing, Printing\nfrom blocks.extensions.saveload import Load, Checkpoint\nfrom blocks.extensions.monitoring import (DataStreamMonitoring,\n                                          TrainingDataMonitoring)\nfrom blocks.main_loop import MainLoop\nfrom blocks.roles import WEIGHT\nfrom blocks.filter import VariableFilter\nfrom fuel.streams import ServerDataStream\nfrom dictlearn.util import configure_logger\nfrom dictlearn.extensions import StartFuelServer, DumpCSVSummaries, SimilarityWordEmbeddingEval, construct_embedder, \\\n    construct_dict_embedder, RetrievalPrintStats, PrintMessage\nfrom dictlearn.data import SNLIData\nfrom dictlearn.nli_simple_model import NLISimple\nfrom dictlearn.nli_esim_model import ESIM\nfrom dictlearn.retrieval import Retrieval, Dictionary\nfrom dictlearn.nli_simple_model import LSTMReadDefinitions, MeanPoolReadDefinitions, MeanPoolCombiner\nfrom blocks.serialization import secure_dump, dump_and_add_to_dump\nfrom blocks.extensions import SimpleExtension\n    from six import string_types\n\"\"\"\nTraining loop for simple SNLI model that can use dict enchanced embeddings\n\"\"\"\n\n\n\nsys.path.append(\"..\")\n\n\n\n\n\n\n\n\n\nclass OnLogStatusExceed(object):\n    \"\"\"Trigger a callback when a certain log record is found.\n\n    Parameters\n    ----------\n    record_name : str\n        The record name to check.\n\n    \"\"\"\n    def __init__(self, record_name, max_val):\n        self.record_name = record_name\n        self.max_val = max_val\n\n    def __call__(self, log):\n        return bool(log.status.get(self.record_name, -numpy.inf) >= self.max_val)\n\n    def __eq__(self, other):\n        return (type(other) == type(self) and\n                other.record_name == self.record_name)\n\n\n# vocab defaults to data.vocab\n# vocab_text defaults to vocab\n# Vocab def defaults to vocab\ndef _initialize_simple_model_and_data(c):\n\n    if c['vocab']:\n        vocab = Vocabulary(c['vocab'])\n    else:\n        vocab = None\n    # Load data\n", "context": "dictlearn/retrieval.py\nclass Retrieval(object):\n\n    def __init__(self, vocab_text, dictionary,\n                 max_def_length=1000, with_too_long_defs='drop',\n                 max_def_per_word=1000000, with_too_many_defs='random',\n                 exclude_top_k=None, vocab_def=None,\n                 add_bod_eod=True, seed=777):\n        \"\"\"Retrieves the definitions.\n        vocab_text\n            The vocabulary for text\n        vocab_def\n            The vocabulary for definitions\n        dictionary\n            The dictionary of the definitions.\n        max_def_length\n            Disregard definitions that are longer than that.\n        exclude_top_k\n            Do not provide defitions for the first top k\n            words of the vocabulary (typically the most frequent ones).\n        max_def_per_word\n            Pick at most max_n_def definitions for each word\n        \"\"\"\n        self._vocab_text = vocab_text\n        self._add_bod_eod = add_bod_eod\n        self._rng = numpy.random.RandomState(seed)\n        if vocab_def is None:\n            self._vocab_def = self._vocab_text\n        else:\n            self._vocab_def = vocab_def\n        self._dictionary = dictionary\n        if exclude_top_k == -1:\n            logger.debug(\"Exclude definition of all dictionary words\")\n            exclude_top_k = vocab_text.size()\n        self._exclude_top_k = exclude_top_k\n\n        if all(numpy.array(self._vocab_text._id_to_freq) == 1) and exclude_top_k > 0:\n            # Also note that after merging doing exclude_top_k on freqs in merged def/text is perhaps\n            # confusing\n            raise Exception(\"Cannot perform exclude_top_k based on vocabulary without frequency information.\")\n\n        # TODO(kudkudak):\n        # To follow conventions - def dropping etc should also be performed in crawl_dict.py\n        # TODO (rizar):\n        # ... or maybe it's moving everything to the preprocessing that was a mistake\n\n        self._max_def_length = max_def_length\n        if with_too_long_defs not in {\"drop\", \"crop\"}:\n            raise NotImplementedError(\"Not implemented \" + with_too_long_defs)\n        self._with_too_long_defs = with_too_long_defs\n\n        self._max_def_per_word = max_def_per_word\n        if with_too_many_defs not in {\"random\", \"exclude\"}:\n            raise NotImplementedError(\"Not implemented \" + with_too_many_defs)\n        self._with_too_many_defs = with_too_many_defs\n\n        self._debug_info = {\n            \"missed_word_sample\": [],\n\n            \"N_words\": 0,\n            \"N_excluded_words\": 0,\n\n            \"N_distinct_words\": 0,\n            \"N_missed_distinct_words\": 0,\n\n            \"N_def\": 0,\n            \"N_dropped_def\": 0,\n\n            \"N_queried_words\": 0,\n            \"N_missed_words\": 0,\n        }\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        if \"_rng\" not in self.__dict__:\n            self._rng = numpy.random.RandomState(777)\n\n    def retrieve(self, batch):\n        \"\"\"Retrieves all definitions for a batch of words sequences.\n\n        TODO: definitions of phrases, phrasal verbs, etc.\n\n        Returns\n        -------\n        defs\n            A list of word definitions, each definition is a list of words.\n        def_map\n            A list of triples (batch_index, time_step, def_index). Maps\n            words to their respective definitions from `defs`.\n\n        \"\"\"\n        definitions = []\n        def_map = []\n        word_def_indices = {}\n\n        for seq_pos, sequence in enumerate(batch):\n            for word_pos, word in enumerate(sequence):\n                if isinstance(word, numpy.ndarray):\n                    word = vec2str(word)\n                if not word:\n                    continue\n                self._debug_info['N_words'] += 1\n                word_id = self._vocab_text.word_to_id(word)\n                if (self._exclude_top_k\n                        and word_id != self._vocab_text.unk\n                        and word_id < self._exclude_top_k):\n                    self._debug_info['N_excluded_words'] += 1\n                    continue\n\n                if word not in word_def_indices:\n                    word_def_indices[word] = []\n                    # The first time a word is encountered in a batch\n                    word_defs = self._dictionary.get_definitions(word)\n\n                    if self._max_def_per_word < len(word_defs):\n                        if self._with_too_many_defs == 'random':\n                            word_defs = self._rng.choice(\n                                word_defs, self._max_def_per_word, replace=False)\n                        else:\n                            # (rizar): if there's too many definition for a words,\n                            # maybe let's just accept that it's a \"semantic prime\"?\n                            word_defs = []\n\n                    # Debug info\n                    self._debug_info['N_distinct_words'] += 1\n                    self._debug_info['N_missed_distinct_words'] += (len(word_defs) == 0)\n                    # End of debug info\n\n                    for i, def_ in enumerate(word_defs):\n                        self._debug_info['N_def'] += 1\n\n                        if  self._with_too_long_defs == 'drop':\n                            if len(def_) > self._max_def_length:\n                                self._debug_info['N_dropped_def'] += 1\n                                continue\n                        elif self._with_too_long_defs == 'crop':\n                            def_ = def_[0:self._max_def_length]\n                        else:\n                            raise NotImplementedError()\n\n                        final_def_ = []\n                        if self._add_bod_eod:\n                            final_def_.append(self._vocab_def.bod)\n                        for token in def_:\n                            final_def_.append(self._vocab_def.word_to_id(token))\n                        if self._add_bod_eod:\n                            final_def_.append(self._vocab_def.eod)\n                        word_def_indices[word].append(len(definitions))\n                        definitions.append(final_def_)\n\n                # Debug info\n                self._debug_info['N_queried_words'] += 1\n                if len(word_def_indices[word]) == 0:\n                    self._debug_info['N_missed_words'] += 1\n                    if len(self._debug_info['missed_word_sample']) == 10000:\n                        self._debug_info['missed_word_sample'][numpy.random.randint(10000)] = word\n                    else:\n                        self._debug_info['missed_word_sample'].append(word)\n                # End of debug info\n\n                for def_index in word_def_indices[word]:\n                    def_map.append((seq_pos, word_pos, def_index))\n\n        return definitions, def_map\n\n    def retrieve_and_pad(self, batch):\n        defs, def_map = self.retrieve(batch)\n        if not defs:\n            defs.append(self.sentinel_definition())\n        # `defs` have variable length and have to be padded\n        max_def_length = max(map(len, defs))\n        def_array = numpy.zeros((len(defs), max_def_length), dtype='int64')\n        def_mask = numpy.ones_like(def_array, dtype=fuel.config.floatX)\n        for i, def_ in enumerate(defs):\n            def_array[i, :len(def_)] = def_\n            def_mask[i, len(def_):] = 0.\n        def_map = (numpy.array(def_map)\n                   if def_map\n                   else numpy.zeros((0, 3), dtype='int64'))\n        return def_array, def_mask, def_map\n\n    def sentinel_definition(self):\n        \"\"\"An empty definition.\n\n        If you ever need a definition that is syntactically correct but\n        doesn't mean a thing, call me.\n\n        \"\"\"\n        return [self._vocab_def.bod, self._vocab_def.eod]\ndictlearn/extensions.py\ndef construct_embedder(theano_fnc, vocab):\n    \"\"\"\n    Parameters\n    ----------\n    theano_fnc: theano.Function\n        (batch_size, seq_len) -> (batch_size, seq_len, word_dim)\n\n    vocab: Vocabulary\n        Vocabulary instance\n\n    Returns\n    -------\n        Python function: (batch_size, ) -> (batch_size, word_dim)\n    \"\"\"\n\n    def _embedder(word_list):\n        word_ids = vocab.encode(word_list)\n        word_ids = np.array(word_ids)\n        word_ids = word_ids.reshape((-1, 1)) # Just to adhere to theano.Function, whatever\n        word_vectors = theano_fnc(word_ids)\n        word_vectors = word_vectors.reshape((len(word_list), -1))\n        return word_vectors\n\n    return _embedder\ndictlearn/extensions.py\nclass StartFuelServer(SimpleExtension):\n\n    def __init__(self, stream, stream_path, script_path=\"start_fuel_server.py\", hwm=100, *args, **kwargs):\n        self._stream = stream\n        self._hwm = hwm\n        self._stream_path = stream_path\n        self._script_path = script_path\n        super(StartFuelServer, self).__init__(*args, **kwargs)\n\n    def do(self, *args, **kwars):\n        with open(self._stream_path, 'w') as dst:\n            cPickle.dump(self._stream, dst, 0)\n        port = get_free_port()\n        self.main_loop.data_stream.port = port\n        logger.debug(\"Starting the Fuel server on port \" + str(port))\n        ret = subprocess.Popen(\n            [self._script_path,\n                self._stream_path, str(port), str(self._hwm)])\n        time.sleep(0.1)\n        if ret.returncode is not None:\n            raise Exception()\n        atexit.register(lambda: os.kill(ret.pid, signal.SIGINT))\ndictlearn/inits.py\nclass GlorotUniform(NdarrayInitialization):\n    \"\"\"Initialize parameters from an isotropic Gaussian distribution.\n\n    Parameters\n    ----------\n    std : float, optional\n        The standard deviation of the Gaussian distribution. Defaults to 1.\n    mean : float, optional\n        The mean of the Gaussian distribution. Defaults to 0\n\n    Notes\n    -----\n    Be careful: the standard deviation goes first and the mean goes\n    second!\n\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def generate(self, rng, shape):\n        if len(shape) == 1:\n            return rng.uniform(size=shape, low=-0.00001, high=0.00001).astype(theano.config.floatX)\n\n        if not len(shape) == 2:\n            raise NotImplementedError(\"GlorotUniform doesnt work for \" + str(shape) + \" shape\")\n\n        fan_in, fan_out = shape[0], shape[1]\n        s = np.sqrt(6. / (fan_in + fan_out))\n        return rng.uniform(size=shape, low=-s, high=s).astype(theano.config.floatX)\n\n    def __repr__(self):\n        return \"GlorotUniform\"\ndictlearn/vocab.py\nclass Vocabulary(object):\n    \"\"\"Class that holds a vocabulary for the dataset.\"\"\"\n    BOS = '<bos>' # beginning-of-sequence\n    EOS = '<eos>' # end-of-sequence\n    BOD = '<bod>' # beginning-of-definition\n    EOD = '<eod>' # end-of-definition\n    UNK = '<unk>' # unknown token\n    SPECIAL_TOKEN_MAP = {\n        BOS: 'bos',\n        EOS: 'eos',\n        BOD: 'bod',\n        EOD: 'eod',\n        UNK: 'unk'\n    }\n\n    def __init__(self, path_or_data):\n        \"\"\"Initialize the vocabulary.\n\n        path_or_data\n            Either a list of words or the path to it.\n        top_k\n            If not `None`, only the first `top_k` entries will be left.\n            Note, this does not include the special tokens.\n\n        \"\"\"\n        if isinstance(path_or_data, string_types):\n            words_and_freqs = []\n            with open(path_or_data) as f:\n                for line in f:\n                    word, freq_str = line.strip().split()\n                    word = word.decode('utf-8')\n                    freq = int(freq_str)\n                    words_and_freqs.append((word, freq))\n        else:\n            words_and_freqs = path_or_data\n\n        self._id_to_word = []\n        self._id_to_freq = []\n        self._word_to_id = {}\n        self.bos = self.eos = -1\n        self.bod = self.eod = -1\n        self.unk = -1\n\n        for idx, (word_name, freq) in enumerate(words_and_freqs):\n            token_attr = self.SPECIAL_TOKEN_MAP.get(word_name)\n            if token_attr is not None:\n                setattr(self, token_attr, idx)\n\n            self._id_to_word.append(word_name)\n            self._id_to_freq.append(freq)\n            self._word_to_id[word_name] = idx\n\n        if -1 in [getattr(self, attr)\n                  for attr in self.SPECIAL_TOKEN_MAP.values()]:\n            raise ValueError(\"special token not found in the vocabulary\")\n\n    def size(self):\n        return len(self._id_to_word)\n\n    @property\n    def words(self):\n        return self._id_to_word\n\n    @property\n    def frequencies(self):\n        return self._id_to_freq\n\n    def word_to_id(self, word, top_k=None):\n        id_ = self._word_to_id.get(word)\n        if id_ is not None and not top_k or id_ < top_k:\n            return id_\n        return self.unk\n\n    def id_to_word(self, cur_id):\n        return self._id_to_word[cur_id]\n\n    def word_freq(self, word):\n        if not word in self._word_to_id:\n            return 0\n        return self._id_to_freq[self._word_to_id[word]]\n\n    def decode(self, cur_ids):\n        return ' '.join([self.id_to_word(cur_id) for cur_id in cur_ids])\n\n    def encode(self, sentence):\n        word_ids = [self.word_to_id(cur_word) for cur_word in sentence]\n        return numpy.array(word_ids, dtype=numpy.int64)\n\n    @staticmethod\n    def build(text, top_k=None, sort_by='frequency'):\n        \"\"\"\n        sort_by is either 'frequency' or 'lexicographical'\n        \"\"\"\n        # For now let's use a very stupid tokenization\n        if isinstance(text, str):\n            with open(text) as file_:\n                def data():\n                    for line in file_:\n                        for word in line.strip().split():\n                            yield word\n                counter = Counter(data())\n            logger.info(\"Data is read\")\n        else:\n            counter = Counter(text)\n            for word in list(counter.keys()):\n                if ' ' in word:\n                    logger.error(\"can't have tokens with spaces, skip {}\".format(word))\n                    del counter[word]\n        # It was not immediately clear to me\n        # if counter.most_common() selects consistenly among\n        # the words with the same counts. Hence, let's just sort.\n        if sort_by == 'frequency':\n            sortf = lambda x: (-x[1], x[0])\n        elif sort_by == 'lexicographical':\n            sortf = lambda x: (x[0], x[1])\n        else:\n            raise Exception(\"sort not understood:\", sort_by)\n        words_and_freqs = sorted(counter.items(), key=sortf)\n        logger.info(\"Words are sorted\")\n        if top_k:\n            words_and_freqs  = words_and_freqs[:top_k]\n        words_and_freqs = (\n            [(Vocabulary.BOS, 0),\n             (Vocabulary.EOS, 0),\n             (Vocabulary.BOD, 0),\n             (Vocabulary.EOD, 0),\n             (Vocabulary.UNK, 0)]\n            + words_and_freqs)\n\n        return Vocabulary(words_and_freqs)\n\n    def save(self, filename):\n        with open(filename, 'w') as f:\n            for word, freq in zip(self._id_to_word, self._id_to_freq):\n\n                # Note: if this fails for you make sure that words read\n                # and used by Vocabulary were utf-8 encoded prior to that\n                if not isinstance(word, text_type):\n                    word = text_type(word, \"utf-8\")\n\n                print(word.encode('utf-8'), freq, file=f)\ndictlearn/data.py\nclass SNLIData(Data):\n    def __init__(self, *args, **kwargs):\n        super(SNLIData, self).__init__(*args, **kwargs)\n        self._retrieval = None\n\n    def set_retrieval(self, retrieval):\n        self._retrieval = retrieval\n\n    def get_stream(self, part, batch_size, seed=None, raw_text=False):\n        d = self.get_dataset(part)\n        print(\"Dataset with {} examples\".format(d.num_examples))\n        it = ShuffledExampleScheme(d.num_examples, rng=numpy.random.RandomState(seed))\n        stream = DataStream(d, iteration_scheme=it)\n        stream = Batch(stream, iteration_scheme=ConstantScheme(batch_size))\n\n        if self._retrieval:\n            stream = FixedMapping(\n                stream,\n                functools.partial(retrieve_and_pad_snli, self._retrieval),\n                add_sources=(\"defs\", \"def_mask\", \"sentence1_def_map\", \"sentence2_def_map\")) # This is because there is bug in Fuel :( Cannot concatenate tuple and list\n\n        if not raw_text:\n            stream = SourcewiseMapping(stream, functools.partial(digitize, self.vocab),\n                which_sources=('sentence1', 'sentence2'))\n\n        stream = Padding(stream, mask_sources=('sentence1', 'sentence2'))  # Increases amount of outputs by x2\n\n        return stream\ndictlearn/retrieval.py\nclass Dictionary(object):\n    \"\"\"The dictionary of definitions.\n\n    The native representation of the dictionary is a mapping from a word\n    to a list of definitions, each of which is a sequence of words. All\n    the words are stored as strings.\n\n    \"\"\"\n    def __init__(self, path=None):\n\n        if not path.endswith(\"json\"):\n            raise Exception(\"Please pass path ending in .json\")\n\n        self._data = defaultdict(list)\n        self._meta_data = {}\n        self._path = path\n        self._meta_path = path.replace(\".json\", \"_meta.json\")\n        #self._tmp_path = os.path.join(os.path.dirname(path),\n        #                              self._path + '.tmp')\n        #self._meta_tmp_path = os.path.join(os.path.dirname(path),\n        #    self._meta_path + '.tmp')\n        self._tmp_path = self._path + \".tmp\"\n        self._meta_tmp_path = self._meta_path + \".tmp\"\n        if self._path:\n            if os.path.exists(self._path):\n                self.load()\n            else:\n                logger.warning(\"No dict was loaded; ignore if you are\"\n                               \" creating new one\")\n\n    def load(self):\n        with open(self._path, 'r') as src:\n            # can't just assign because self._data should keep being a\n            # defaultdict\n            self._data.update(json.load(src))\n        if os.path.exists(self._meta_path):\n            with open(self._meta_path, 'r') as src:\n                self._meta_data = json.load(src)\n\n    def save(self):\n        logger.debug(\"saving...\")\n        with open(self._tmp_path, 'w') as dst:\n            json.dump(self._data, dst, indent=2)\n        shutil.move(self._tmp_path, self._path)\n        logger.debug(\"saving meta...\")\n        with open(self._meta_tmp_path, 'w') as dst:\n            json.dump(self._meta_data, dst, indent=2)\n        shutil.move(self._meta_tmp_path, self._meta_path)\n        logger.debug(\"saved\")\n\n    def _wait_until_quota_reset(self):\n        while True:\n            status = self._account_api.getApiTokenStatus()\n            logger.debug(\"{} remaining calls\".format(status.remainingCalls))\n            if status.remainingCalls >= _MIN_REMAINING_CALLS:\n                logger.debug(\"Wordnik quota was resetted\")\n                self._remaining_calls = status.remainingCalls\n                return\n            logger.debug(\"sleep until quota reset\")\n            time.sleep(60.)\n\n    def add_identity_mapping(self, vocab):\n        for word in vocab.words:\n            self._data[word].append([word])\n            self._meta_data[word] = {\"sourceDictionary\": \"identity\"}\n        self.save()\n\n    def remove_out_of_vocabulary(self, vocab):\n        \"\"\"\n        remove definitions that are outside of a vocabulary vocab\n        \"\"\"\n        # TODO: remove from meta too\n        # can't just zip because if meta is empty then nothing happens\n        print(\"vocab size : {}\".format(vocab.size()))\n        print(\"dict len : {}\".format(len(self._data)))\n        count_del = 0\n        for word in self._data.keys():\n            word_id = vocab.word_to_id(word)\n            if word_id == vocab.unk:\n                del self._data[word]\n                count_del += 1\n                # del self._meta_data[word] # TODO:\n        print(\"have deleted {} definitions\".format(count_del))\n        self.save()\n\n\n    def add_spelling(self, vocab, only_if_no_def=True):\n        for word in vocab.words:\n            # only add spelling to the words without defs\n            if only_if_no_def and self._data[word]:\n                continue\n            def_ = word\n            if len(def_) > 10:\n                def_ = u\"{}-{}\".format(def_[:5], def_[-5:])\n            # to avoid overlapping of the vocabularies, let's add a #\n            # before each character\n            self._data[word].append(map(lambda char: u'#' + char, def_))\n            self._meta_data[word] = {\"sourceDictionary\": \"spelling\"}\n        self.save()\n\n\n    def add_from_lowercase_definitions(self, vocab):\n        \"\"\"Add definitions of lowercase word to each word (concat)\n        \"\"\"\n        added = 0\n        no_def = 0\n        for word in vocab.words:\n            word_lower = word.lower()\n            if word != word_lower:\n                lower_defs = self._data.get(word_lower)\n                # This can be quite slow. But this code will not be used\n                # very often.\n                if not lower_defs:\n                    if lower_defs is None:\n                        # This can happen when API just dies (then vocab has, dict doesnt)\n                        logger.error(\"None def for \" + word)\n                        continue\n                    no_def += 1\n                    logger.warning(\"No defs for \" + str(word_lower) + \",\" + str(word))\n                else:\n                    # Note: often empty, like Zeus -> zeus\n                    for def_ in lower_defs:\n                        if not def_ in self._data[word]:\n                            added += 1\n                            self._data[word].append(def_)\n\n        logger.info(\"No def for {}\".format(no_def))\n        logger.info(\"Added {} new defs in add_from_lowercase_definitions\".format(added))\n        self.save()\n\n\n    def add_from_lemma_definitions(self, vocab, try_lower=False):\n        \"\"\"Add lemma definitions for non-lemmas.\n\n        This code covers the following scenario: supposed a dictionary is crawled,\n        but only for word lemmas.\n\n        \"\"\"\n        lemmatizer = nltk.WordNetLemmatizer()\n        added = 0\n        for word in vocab.words:\n            word_list = [word, word.lower()] if try_lower else [word]\n\n            for word_to_lemma in word_list:\n                try:\n                    for part_of_speech in ['a', 's', 'r', 'n', 'v']:\n                        lemma = lemmatizer.lemmatize(word_to_lemma, part_of_speech)\n                        lemma_defs = self._data.get(lemma)\n                        if lemma != word and lemma_defs:\n                            # This can be quite slow. But this code will not be used\n                            # very often.\n                            for def_ in lemma_defs:\n                                if not def_ in self._data[word]:\n                                    added += 1\n                                    self._data[word].append(def_)\n                except:\n                    logger.error(\"lemmatizer crashed on {}\".format(word))\n                    logger.error(traceback.format_exc())\n        logger.info(\"Added {} new defs in add_from_lemma_definitions\".format(added))\n        self.save()\n\n    def add_dictname_to_defs(self, vocab):\n        \"\"\"Add dict name in front of each def\"\"\"\n        # TODO(kudkudak): I will implement it after we have attention on defs +\n        # we do shortlisting based on dict defs\n        raise NotImplementedError()\n\n    def crawl_lemmas(self, vocab):\n        \"\"\"Add Wordnet lemmas as definitions.\"\"\"\n        lemmatizer = nltk.WordNetLemmatizer()\n        for word in vocab.words:\n            definitions = []\n            try:\n                for part_of_speech in ['a', 's', 'r', 'n', 'v']:\n                    lemma = lemmatizer.lemmatize(word, part_of_speech)\n                    if lemma != word and not [lemma] in definitions:\n                        definitions.append([lemma])\n            except:\n                logger.error(\"lemmatizer crashed on {}\".format(word))\n            if definitions:\n                self._data[word] = definitions\n        self.save()\n\n    def crawl_lowercase(self, vocab):\n        \"\"\"Add Wordnet lemmas as definitions.\"\"\"\n        for word in vocab.words:\n            self._data[word] = [[word.lower()]]\n            self._meta_data[word.lower()] = {\"sourceDictionary\": \"lowercase\"}\n        self.save()\n\n    def crawl_wordnet(self, corenlp_url):\n        corenlp = StanfordCoreNLP(corenlp_url)\n        for i, word in enumerate(wordnet.words()):\n            if word in self._data:\n                logger.info('skip a known word {}'.format(word))\n                continue\n            self._data[word] = []\n            for synset in wordnet.synsets(word):\n                def_ = corenlp.tokenize(synset.definition())[0]\n                self._data[word].append(def_)\n            if i % 10000 == 0:\n                self.save()\n        self.save()\n\n    def crawl_wordnik(self, vocab, api_key, corenlp_url,\n                      call_quota=15000, crawl_also_lowercase=False, crawl_also_lemma=False):\n\n        \"\"\"Download and preprocess definitions from Wordnik.\n\n        vocab\n            Vocabulary for which the definitions should be found.\n        api_key\n            The API key to use in communications with Wordnik.\n        call_quota\n            Maximum number of calls per hour.\n        crawl_also_lowercase\n            If true will add lowercase version of each word to crawl list\n        crawl_also_lemma\n            If true will also crawl lemma versions of words\n            WARNING: Lemma of Cat is Cat! So if you want to have definition of \"cat\"\n            you have to also pass crawl_also_lowercase!\n\n        \"\"\"\n        corenlp = StanfordCoreNLP(corenlp_url)\n\n        self._remaining_calls = call_quota\n        self._last_saved = 0\n\n        client = swagger.ApiClient(\n            api_key, 'https://api.wordnik.com/v4')\n        self._word_api = WordApi.WordApi(client)\n        self._account_api = AccountApi.AccountApi(client)\n\n        words = list(vocab.words)\n\n        # Note(kudkudak): for SNLI it adds 3k words\n        if crawl_also_lowercase:\n            words_set = set(words)  # For efficiency\n\n            logger.info(\"Adding lowercase words to crawl\")\n            lowercased = []\n            for w in words:\n                if w.lower() not in words_set:\n                    lowercased.append(w.lower())\n            logger.info(\"Crawling additional {} words\".format(len(lowercased)))\n            words.extend(sorted(lowercased))\n\n        # Note(kudkudak): for SNLI it adds 2k words, so we can expect\n        # like sabotage,sabotaging\n        # Note that lemma crawling is *after* lowercasing\n        if crawl_also_lemma:\n            words_set = set(words) # For efficiency\n\n            logger.info(\"Adding lemmatized vrsions to crawl\")\n            lemmas = []\n            original = []\n            lemmatizer = nltk.WordNetLemmatizer()\n            for w in words:\n                if isinstance(w, str):\n                    w = w.decode('utf-8')\n\n                for part_of_speech in ['a', 's', 'r', 'n', 'v']:\n                    lemma = lemmatizer.lemmatize(w, part_of_speech)\n                    if lemma not in words_set:\n                        lemmas.append(lemma)\n                        original.append(w)\n            logger.info(\"Crawling additional {} words\".format(len(lemmas)))\n            for id in numpy.random.choice(len(lemmas), 100):\n                logger.info(\"Example:\" + lemmas[id] + \",\" + original[id])\n                words.extend(sorted(lemmas))\n\n        # Here, for now, we don't do any stemming or lemmatization.\n        # Stemming is useless because the dictionary is not indexed with\n        # lemmas, not stems. Lemmatizers, on the other hand, can not be\n        # fully trusted when it comes to unknown words.\n        for word in words:\n            if isinstance(word, str):\n                word = word.decode('utf-8')\n\n            if word in self._data:\n                logger.debug(u\"a known word {}, skip\".format(word))\n                continue\n\n            if self._last_saved >= _SAVE_EVERY_CALLS:\n                self.save()\n                self._last_saved = 0\n\n            # 100 is a safery margin, I don't want to DDoS Wordnik :)\n            if self._remaining_calls < _MIN_REMAINING_CALLS:\n                self._wait_until_quota_reset()\n            try:\n                if isinstance(word, str):\n                    word = word.decode('utf-8')\n                # NOTE(kudkudak): We fetch all dictionaries, but retrieval can filter them based on meta info\n                definitions = self._word_api.getDefinitions(word)\n            except Exception:\n                logger.error(u\"error during fetching '{}'\".format(word))\n                logger.error(traceback.format_exc())\n                continue\n            self._remaining_calls -= 1\n            self._last_saved += 1\n\n            if not definitions:\n                definitions = []\n            self._data[word] = []\n            for def_ in definitions:\n                try:\n                    # seems like definition text can be both str and unicode\n                    text = def_.text\n                    if def_.text is None:\n                        continue\n                    if isinstance(text, str):\n                        text = text.decode('utf-8')\n                    tokenized_def = corenlp.tokenize(text)[0]\n                    self._data[word].append(tokenized_def)\n                    # Note(kudkudak): I don't think there is much more useful meta data for us\n                    # Note(kudkudak): This might seem strange, but I am afraid this is most robust (least bug prone)\n                    # way of storing meta data that doens't require rewriting dict storage format\n                    self._meta_data[\" \".join(tokenized_def)] = {\"sourceDictionary\": def_.sourceDictionary}\n                except Exception:\n                    logger.error(\"error during tokenizing '{}'\".format(text))\n                    logger.error(traceback.format_exc())\n            logger.debug(u\"definitions for '{}' fetched {} remaining\".format(word, self._remaining_calls))\n        self.save()\n        self._last_saved = 0\n\n    def num_entries(self):\n        return len(self._data)\n\n    def get_definitions(self, key):\n        return self._data.get(key, [])\ndictlearn/util.py\ndef configure_logger(name = __name__,\n                     console_logging_level = logging.INFO,\n                     file_logging_level = logging.INFO,\n                     log_file = None,\n                     redirect_stdout=False,\n                     redirect_stderr=False):\n    \"\"\"\n    Configures logger\n    :param name: logger name (default=module name, __name__)\n    :param console_logging_level: level of logging to console (stdout), None = no logging\n    :param file_logging_level: level of logging to log file, None = no logging\n    :param log_file: path to log file (required if file_logging_level not None)\n    :return instance of Logger class\n    \"\"\"\n    if console_logging_level is None and file_logging_level is None:\n        return # no logging\n\n    if isinstance(console_logging_level, (str, unicode)):\n        console_logging_level = parse_logging_level(console_logging_level)\n\n    if isinstance(file_logging_level, (str, unicode)):\n        file_logging_level = parse_logging_level(file_logging_level)\n\n    if not os.path.exists(os.path.dirname(log_file)):\n        os.makedirs(os.path.dirname(log_file))\n\n    logger = logging.getLogger(name)\n    logger.handlers = []\n    logger.setLevel(logging.DEBUG)\n    format = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\n    if console_logging_level is not None:\n        ch = logging.StreamHandler(sys.stdout)\n        ch.setFormatter(format)\n        ch.setLevel(console_logging_level)\n        logger.addHandler(ch)\n\n    if file_logging_level is not None:\n        if log_file is None:\n            raise ValueError(\"If file logging enabled, log_file path is required\")\n        fh = handlers.RotatingFileHandler(log_file, maxBytes=(1048576*5), backupCount=7)\n        fh.setFormatter(format)\n        logger.addHandler(fh)\n\n    logger.info(\"Logging configured!\")\n\n    if redirect_stderr:\n        sys.stderr = LoggerWriter(logger.warning)\n    if redirect_stdout:\n        sys.stdout = LoggerWriter(logger.info)\n\n    return logger\ndictlearn/extensions.py\nclass DumpCSVSummaries(SimpleExtension):\n    def __init__(self, save_path, **kwargs):\n        self._save_path = save_path\n\n        if not os.path.exists(os.path.join(self._save_path, \"logs.csv\")):\n            self._current_log = defaultdict(list)\n        else:\n            self._current_log = pd.read_csv(os.path.join(self._save_path, \"logs.csv\"))\n            self._current_log = {col: list(self._current_log[col].values) for col in self._current_log.columns}\n            logging.warning(\"Loaded {} columns and {} rows from logs.csv\".format(len(self._current_log), len(self._current_log.values()[0])))\n\n        super(DumpCSVSummaries, self).__init__(**kwargs)\n\n    def do(self, *args, **kwargs):\n        for key, value in self.main_loop.log.current_row.items():\n            try:\n                float_value = float(value)\n            except:\n                continue\n\n            if not key.startswith(\"val\") and not key.startswith(\"train\") and not key.startswith(\"test\"):\n                key = \"train_\" + key\n\n            if key not in self._current_log:\n                self._current_log[key] = []\n\n            self._current_log[key].append(float_value)\n\n        # Make sure all logs have same length (for csv serialization)\n        max_len = max([len(v) for v in self._current_log.values()])\n        for k in self._current_log:\n            if len(self._current_log[k]) != max_len:\n                self._current_log[k] += [self._current_log[k][-1] for _ in range(max_len - len(self._current_log[k]))]\n\n        pd.DataFrame(self._current_log).to_csv(os.path.join(self._save_path, \"logs.csv\"))\ndictlearn/extensions.py\ndef construct_dict_embedder(theano_fnc, vocab, retrieval):\n    \"\"\"\n    Parameters\n    ----------\n    theano_fnc: theano.Function\n        (batch_size, seq_len) -> (batch_size, seq_len, word_dim)\n\n    vocab: Vocabulary\n        Vocabulary instance\n\n    Returns\n    -------\n        Python function: (batch_size, ) -> (batch_size, word_dim)\n    \"\"\"\n\n    def _embedder(word_list):\n        word_ids = vocab.encode(word_list)\n        word_ids = np.array(word_ids)\n        word_ids = word_ids.reshape((-1, 1)) # Just to adhere to theano.Function, whatever\n        def_array, def_mask, def_map = retrieval.retrieve_and_pad(np.array(word_list).reshape(-1, 1))\n        word_vectors = theano_fnc(word_ids, def_array, def_mask, def_map)\n        word_vectors = word_vectors.reshape((len(word_list), -1))\n        return word_vectors\n\n    return _embedder\ndictlearn/extensions.py\nclass LoadNoUnpickling(Load):\n    \"\"\"Like `Load` but without unpickling.\n\n    Avoids unpiclkling the main loop by assuming that the log\n    and the iteration state were saved separately.\n\n    \"\"\"\n\n    def load_to(self, main_loop):\n        with open(self.path, \"rb\") as source:\n            main_loop.model.set_parameter_values(load_parameters(source))\n            if self.load_iteration_state:\n                main_loop.iteration_state = load(source, name='iteration_state')\n            if self.load_log:\n                main_loop.log = load(source, name='log')\ndictlearn/nli_simple_model.py\nclass NLISimple(Initializable):\n    def __init__(self, mlp_dim, translate_dim, emb_dim, vocab, num_input_words=-1,\n            num_input_def_words=-1, dropout=0.2, encoder=\"sum\",\n            n_layers=3, translate_after_emb=True, bn=True,\n\n            # Dict lookup kwargs\n            retrieval=None, reader_type=\"rnn\", compose_type=\"sum\", def_dim=300,\n            disregard_word_embeddings=False, combiner_dropout=1.0, combiner_bn=False,\n            combiner_dropout_type=\"regular\", share_def_lookup=False, exclude_top_k=-1,\n            combiner_reader_translate=True, def_vocab=None, def_emb_dim=-1,\n            combiner_gating=\"none\", def_emb_translate_dim=-1,\n            combiner_shortcut=False,\n            # Others\n            **kwargs):\n    def get_embeddings_lookups(self):\n    def get_def_embeddings_lookups(self):\n    def set_def_embeddings(self, embeddings):\n    def set_embeddings(self, embeddings):\n    def apply(self, application_call,\n            s1_preunk, s1_mask, s2_preunk, s2_mask, def_mask=None, defs=None, s1_def_map=None,\n            s2_def_map=None, train_phase=True):\ndictlearn/extensions.py\nclass SimilarityWordEmbeddingEval(SimpleExtension):\n    \"\"\"\n    Parameters\n    ----------\n\n    embedder: function: word -> vector\n    \"\"\"\n\n    def __init__(self, embedder, prefix=\"\", **kwargs):\n        try:\n            from web.datasets.similarity import fetch_MEN, fetch_WS353, fetch_SimLex999, fetch_RW\n        except ImportError:\n            raise RuntimeError(\"Please install web (https://github.com/kudkudak/word-embeddings-benchmarks)\")\n\n        self._embedder = embedder\n        self._prefix = prefix\n\n        # Define tasks\n        logger.info(\"Downloading benchmark data\")\n        tasks = { # TODO: Pick a bit better tasks\n            \"MEN\": fetch_MEN(),\n            \"WS353\": fetch_WS353(),\n            \"SIMLEX999\": fetch_SimLex999(),\n            \"RW\": fetch_RW()\n        }\n\n        # Print sample data\n        for name, data in iteritems(tasks):\n            logger.info(\n            \"Sample data from {}: pair \\\"{}\\\" and \\\"{}\\\" is assigned score {}\".format(name, data.X[0][0], data.X[0][1],\n                data.y[0]))\n\n        logger.info(\"Checking embedder for \" + prefix)\n        logger.info(embedder([\"love\"])[0, 0:5]) # Test embedder\n\n        self._tasks = tasks\n\n        super(SimilarityWordEmbeddingEval, self).__init__(**kwargs)\n\n    def __getstate__(self):\n        dict_ = dict(self.__dict__)\n        if '_embedder' in dict_:\n            del dict_['_embedder']\n        if '_tasks' in dict_:\n            del dict_['_tasks']\n        return dict_\n\n    def add_records(self, log, record_tuples):\n        \"\"\"Helper function to add monitoring records to the log.\"\"\"\n        for name, value in record_tuples:\n            if not name:\n                raise ValueError(\"monitor variable without name\")\n            log.current_row[name] = value\n\n    def do(self, *args, **kwargs):\n        # Embedd\n        all_words = []\n        all_words_vectors = []\n\n        # TODO: Do it at once?\n        for task in self._tasks:\n            for row in self._tasks[task].X:\n                for w in row:\n                    all_words.append(w)\n                    all_words_vectors.append(self._embedder([w]))\n        W = dict(zip(np.array(all_words).reshape((-1,)), all_words_vectors))\n\n        # Calculate results using helper function\n        record_items = []\n        for name, data in iteritems(self._tasks):\n            eval = evaluate_similarity(W, data.X, data.y)\n            record_items.append((self._prefix + \"_\" + name, eval))\n\n        self.add_records(self.main_loop.log, record_items)\ndictlearn/extensions.py\nclass PrintMessage(SimpleExtension):\n    \"\"\"Prints log messages to the screen.\"\"\"\n    def __init__(self, msg, **kwargs):\n        self._msg = msg\n        kwargs.setdefault(\"before_first_epoch\", True)\n        kwargs.setdefault(\"on_resumption\", True)\n        kwargs.setdefault(\"after_training\", True)\n        kwargs.setdefault(\"after_epoch\", True)\n        kwargs.setdefault(\"on_interrupt\", True)\n        super(PrintMessage, self).__init__(**kwargs)\n\n    def do(self, which_callback, *args):\n        print(self._msg)\ndictlearn/extensions.py\nclass RetrievalPrintStats(SimpleExtension):\n    \"\"\"\n    Prints statistics about Retrieval object\n    \"\"\"\n\n    def __init__(self, retrieval, **kwargs):\n        self._retrieval = retrieval\n        super(RetrievalPrintStats, self).__init__(**kwargs)\n\n    def __getstate__(self):\n        dict_ = dict(self.__dict__)\n        if '_retrieval' in dict_:\n            del dict_['_retrieval']\n        return dict_\n\n    def add_records(self, log, record_tuples):\n        \"\"\"Helper function to add monitoring records to the log.\"\"\"\n        for name, value in record_tuples:\n            if not name:\n                raise ValueError(\"monitor variable without name\")\n            log.current_row[name] = value\n\n    def do(self, *args, **kwargs):\n        if self._retrieval is not None:\n            d = self._retrieval._debug_info\n            record_tuples = []\n            record_tuples.append(\n                (\"retrieval_distinct_mis_ratio\",\n                 d['N_missed_distinct_words'] / max(1, float(d['N_distinct_words']))))\n            record_tuples.append((\"retrieval_N_words\", d['N_words']))\n            record_tuples.append((\"retrieval_N_excluded_words\", d['N_excluded_words']))\n            record_tuples.append((\"retrieval_N_distinct_words\", d['N_distinct_words']))\n            record_tuples.append((\"retrieval_N_queried_words\", d['N_queried_words']))\n            record_tuples.append((\"retrieval_mis_ratio\",\n                                  d['N_missed_words']\n                                  /  max(1, float(d['N_queried_words']))))\n            record_tuples.append((\"retrieval_drop_def_ratio\",\n                                  d['N_dropped_def'] /  max(1, float(d['N_def']))))\n            if len(d['missed_word_sample']) >= 20:\n                record_tuples.append((\"retrieval_missed_word_sample\",\n                    numpy.random.choice(d['missed_word_sample'], 20, replace=False)))\n            self.add_records(self.main_loop.log, record_tuples)\ndictlearn/extensions.py\nclass DumpTensorflowSummaries(SimpleExtension):\n    def __init__(self, save_path, **kwargs):\n        self._save_path = save_path\n        super(DumpTensorflowSummaries, self).__init__(**kwargs)\n\n    @property\n    def file_writer(self):\n        if not hasattr(self, '_file_writer'):\n            self._file_writer = tensorflow.summary.FileWriter(\n                self._save_path, flush_secs=10.)\n        return self._file_writer\n\n    def __getstate__(self):\n        # FileWriter from TensorFlow is not picklable\n        dict_ = self.__dict__\n        if '_file_writer' in dict_:\n            del dict_['_file_writer']\n        return dict_\n\n    def do(self, *args, **kwargs):\n        summary = tensorflow.Summary()\n        for key, value in self.main_loop.log.current_row.items():\n            try:\n                float_value = float(value)\n                value = summary.value.add()\n                value.tag = key\n                value.simple_value = float_value\n            except:\n                pass\n        self.file_writer.add_summary(\n            summary, self.main_loop.log.status['iterations_done'])\ndictlearn/nli_simple_model.py\nclass NLISimple(Initializable):\n    \"\"\"\n    Simple model based on https://github.com/Smerity/keras_snl\n    \"\"\"\n\n    def __init__(self, mlp_dim, translate_dim, emb_dim, vocab, num_input_words=-1,\n            num_input_def_words=-1, dropout=0.2, encoder=\"sum\",\n            n_layers=3, translate_after_emb=True, bn=True,\n\n            # Dict lookup kwargs\n            retrieval=None, reader_type=\"rnn\", compose_type=\"sum\", def_dim=300,\n            disregard_word_embeddings=False, combiner_dropout=1.0, combiner_bn=False,\n            combiner_dropout_type=\"regular\", share_def_lookup=False, exclude_top_k=-1,\n            combiner_reader_translate=True, def_vocab=None, def_emb_dim=-1,\n            combiner_gating=\"none\", def_emb_translate_dim=-1,\n            combiner_shortcut=False,\n            # Others\n            **kwargs):\n\n        if def_emb_dim <= 0:\n            logger.info(\"Assuming def_emb_dim=emb_dim\")\n            def_emb_dim = emb_dim\n\n        def_emb_translate_dim = def_emb_translate_dim if def_emb_translate_dim > 0 else def_emb_dim\n\n        self._vocab = vocab\n        self._bn = bn\n        self._encoder = encoder\n        self._dropout = dropout\n        self._retrieval = retrieval\n        self._only_def = disregard_word_embeddings\n        self._num_input_def_words = num_input_def_words\n        self._translate_after_emb = translate_after_emb\n\n        if reader_type not in {\"rnn\", \"mean\"}:\n            raise NotImplementedError(\"Not implemented \" + reader_type)\n\n        if num_input_words > 0:\n            logger.info(\"Restricting vocab to \" + str(num_input_words))\n            self._num_input_words = num_input_words\n        else:\n            logger.info(\"Vocab set to \" + str(vocab.size()))\n            self._num_input_words = vocab.size()\n\n        children = []\n\n        if not disregard_word_embeddings:\n            self._lookup = LookupTable(self._num_input_words, emb_dim)\n            children.append(self._lookup)\n\n        if retrieval:\n            if share_def_lookup:\n                if emb_dim != def_emb_dim:\n                    self._translate_pre_def2 = Linear(input_dim=emb_dim, output_dim=def_emb_dim)\n                    children.append(self._translate_pre_def2)\n                    def_lookup = Sequence([self._lookup, self._translate_pre_def2])\n                else:\n                    def_lookup = self._lookup\n            else:\n                def_lookup = None\n\n            if reader_type== \"rnn\":\n                self._def_reader = LSTMReadDefinitions(num_input_words=self._num_input_def_words,\n                    dim=def_emb_translate_dim,\n                    emb_dim=def_emb_dim, vocab=def_vocab, lookup=def_lookup)\n            elif reader_type == \"mean\":\n                if combiner_reader_translate:\n                    logger.warning(\"Translate in MeanPoolReadDefinitions is redundant\")\n                self._def_reader = MeanPoolReadDefinitions(num_input_words=self._num_input_def_words,\n                    translate=combiner_reader_translate,\n                    lookup=def_lookup, dim=def_emb_translate_dim,\n                    emb_dim=def_emb_dim, vocab=def_vocab)\n\n            self._combiner = MeanPoolCombiner(dim=def_dim, emb_dim=def_emb_translate_dim,\n                dropout=combiner_dropout, dropout_type=combiner_dropout_type,\n                def_word_gating=combiner_gating,\n                shortcut_unk_and_excluded=combiner_shortcut, num_input_words=num_input_words,\n                exclude_top_k=exclude_top_k, vocab=vocab,\n                compose_type=compose_type)\n            children.extend([self._def_reader, self._combiner])\n\n            if self._encoder == \"rnn\":\n                self._rnn_fork = Linear(input_dim=def_emb_dim, output_dim=4 * translate_dim)\n                # TODO(kudkudak): Better LSTM weight init\n                self._rnn_encoder = LSTM(dim=translate_dim, name='LSTM_encoder')\n                children.append(self._rnn_fork)\n                children.append(self._rnn_encoder)\n            elif self._encoder == \"sum\":\n                pass\n            else:\n                raise NotImplementedError(\"Not implemented encoder\")\n\n            if def_emb_translate_dim != emb_dim:\n                self._translate_pre_def = Linear(input_dim=emb_dim, output_dim=def_emb_translate_dim)\n                children.append(self._translate_pre_def)\n            else:\n                self._translate_pre_def = None\n\n            if self._translate_after_emb:\n                self._translation = Linear(input_dim=def_dim, output_dim=translate_dim)\n                self._translation_act = Rectifier()\n                children.append(self._translation)\n                children.append(self._translation_act)\n        else:\n            if self._encoder == \"rnn\":\n                self._translation = Linear(input_dim=emb_dim, output_dim=4 * translate_dim)\n                self._rnn_fork = self._translation\n                self._rnn_encoder = LSTM(dim=translate_dim, name='LSTM_encoder')\n                children.append(self._rnn_encoder)\n                children.append(self._translation)\n            elif self._encoder == \"sum\":\n                self._translation = Linear(input_dim=emb_dim, output_dim=translate_dim,\n                    weights_init=GlorotUniform(), biases_init=Constant(0))\n                self._translation_act = Rectifier()\n                children.append(self._translation)\n                children.append(self._translation_act)\n            else:\n                raise NotImplementedError(\"Not implemented encoder\")\n\n\n\n        if self._bn:\n            self._hyp_bn = BatchNormalization(input_dim=translate_dim, name=\"hyp_bn\", conserve_memory=False)\n            self._prem_bn = BatchNormalization(input_dim=translate_dim, name=\"prem_bn\", conserve_memory=False)\n            children += [self._hyp_bn, self._prem_bn]\n\n        self._mlp = []\n        current_dim = 2 * translate_dim  # Joint\n        for i in range(n_layers):\n            rect = Rectifier()\n            dense = Linear(input_dim=current_dim, output_dim=mlp_dim,\n                name=\"MLP_layer_\" + str(i), \\\n                weights_init=GlorotUniform(), \\\n                biases_init=Constant(0))\n            current_dim = mlp_dim\n            if self._bn:\n                bn = BatchNormalization(input_dim=current_dim, name=\"BN_\" + str(i), conserve_memory=False)\n                children.append(bn)\n            else:\n                bn = None\n\n            children += [dense, rect] #TODO: Strange place to put ReLU\n            self._mlp.append([dense, rect, bn])\n\n        self._pred = MLP([Softmax()], [current_dim, 3])\n        children.append(self._pred)\n\n        super(NLISimple, self).__init__(children=children, **kwargs)\n\n    def get_embeddings_lookups(self):\n        return [self._lookup]\n\n    def get_def_embeddings_lookups(self):\n        return [self._def_reader._def_lookup]\n\n    def set_def_embeddings(self, embeddings):\n        self._def_reader._def_lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    def set_embeddings(self, embeddings):\n        self._lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    @application\n    def apply(self, application_call,\n            s1_preunk, s1_mask, s2_preunk, s2_mask, def_mask=None, defs=None, s1_def_map=None,\n            s2_def_map=None, train_phase=True):\n        # Shortlist words (sometimes we want smaller vocab, especially when dict is small)\n        s1 = (tensor.lt(s1_preunk, self._num_input_words) * s1_preunk\n              + tensor.ge(s1_preunk, self._num_input_words) * self._vocab.unk)\n        s2 = (tensor.lt(s2_preunk, self._num_input_words) * s2_preunk\n              + tensor.ge(s2_preunk, self._num_input_words) * self._vocab.unk)\n\n        # Embeddings\n        s1_emb = self._lookup.apply(s1)\n        s2_emb = self._lookup.apply(s2)\n\n        application_call.add_auxiliary_variable(\n            1 * s1_emb,\n            name='s1_word_embeddings')\n\n        if self._retrieval is not None:\n            assert defs is not None\n\n            if self._translate_pre_def:\n                logger.info(\"Translate pre def\")\n                s1_emb = s1_emb.reshape((s1_emb.shape[0] * s1_emb.shape[1], s1_emb.shape[2]))\n                s2_emb = s2_emb.reshape((s2_emb.shape[0] * s2_emb.shape[1], s2_emb.shape[2]))\n                s1_emb = self._translate_pre_def.apply(s1_emb)\n                s2_emb = self._translate_pre_def.apply(s2_emb)\n                s1_emb = s1_emb.reshape((s1_preunk.shape[0], s1_preunk.shape[1], -1))\n                s2_emb = s2_emb.reshape((s2_preunk.shape[0], s2_preunk.shape[1], -1))\n\n            def_embs = self._def_reader.apply(defs, def_mask)\n\n            s1_transl = self._combiner.apply(\n                s1_emb, s1_mask,\n                def_embs, s1_def_map, word_ids=s1, train_phase=train_phase, call_name=\"s1\")\n\n            s2_transl = self._combiner.apply(\n                s2_emb, s2_mask,\n                def_embs, s2_def_map, word_ids=s2, train_phase=train_phase, call_name=\"s2\")\n\n            if self._translate_after_emb:\n                # Note: for some reader/combiner it can be redundant, but let's keep it\n                # often it will not be redundant (ex: LSTMDefReader)\n                s1_transl = s1_transl.reshape((s1_transl.shape[0] * s1_transl.shape[1], s1_transl.shape[2]))\n                s2_transl = s2_transl.reshape((s2_transl.shape[0] * s2_transl.shape[1], s2_transl.shape[2]))\n                s1_transl = self._translation.apply(s1_transl)\n                s2_transl = self._translation.apply(s2_transl)\n                s1_transl = self._translation_act.apply(s1_transl)\n                s2_transl = self._translation_act.apply(s2_transl)\n                s1_transl = s1_transl.reshape((s1_emb.shape[0], s1_emb.shape[1], -1))\n                s2_transl = s2_transl.reshape((s2_emb.shape[0], s2_emb.shape[1], -1))\n        else:\n            # Translate. Crucial for recovering useful information from embeddings\n            s1_emb_flatten = s1_emb.reshape((s1_emb.shape[0] * s1_emb.shape[1], s1_emb.shape[2]))\n            s2_emb_flatten = s2_emb.reshape((s2_emb.shape[0] * s2_emb.shape[1], s2_emb.shape[2]))\n\n            if self._translate_after_emb:\n                # Note: redundant for trainable (from scratch) embeddings\n                s1_transl = self._translation.apply(s1_emb_flatten)\n                s2_transl = self._translation.apply(s2_emb_flatten)\n                s1_transl = self._translation_act.apply(s1_transl)\n                s2_transl = self._translation_act.apply(s2_transl)\n                s1_transl = s1_transl.reshape((s1_emb.shape[0], s1_emb.shape[1], -1))\n                s2_transl = s2_transl.reshape((s2_emb.shape[0], s2_emb.shape[1], -1))\n                application_call.add_auxiliary_variable(\n                    1*s1_transl,\n                    name='s1_translated_word_embeddings')\n                assert s1_transl.ndim == 3\n            else:\n                s1_transl = s1_emb_flatten\n                s2_transl = s2_emb_flatten\n\n        if self._encoder == \"rnn\":\n            s1_transl = self._rnn_fork.apply(s1_transl)\n            s2_transl = self._rnn_fork.apply(s2_transl)\n\n        assert s1_transl.ndim == s2_transl.ndim == 3\n\n        # Construct entailment embedding\n        if self._encoder == \"sum\":\n            s1_emb_mask = s1_mask.dimshuffle((0, 1, \"x\"))\n            s2_emb_mask = s2_mask.dimshuffle((0, 1, \"x\"))\n\n            # TODO: This should be mean, might make learning harder otherwise\n            prem = (s1_emb_mask * s1_transl).sum(axis=1)\n            hyp = (s2_emb_mask * s2_transl).sum(axis=1)\n        else:\n            prem = self._rnn_encoder.apply(s1_transl.transpose(1, 0, 2), mask=s1_mask.transpose(1, 0))[0][-1]\n            hyp = self._rnn_encoder.apply(s2_transl.transpose(1, 0, 2), mask=s2_mask.transpose(1, 0))[0][-1]\n\n        if self._bn:\n            prem = self._prem_bn.apply(prem)\n            hyp = self._hyp_bn.apply(hyp)\n\n        joint = T.concatenate([prem, hyp], axis=1)\n        joint.name = \"MLP_input\"\n\n        if train_phase:\n            joint = apply_dropout(joint, drop_prob=self._dropout)\n\n        # MLP\n        for block in self._mlp:\n            dense, relu, bn = block\n            joint = dense.apply(joint)\n            joint = relu.apply(joint)\n\n            if train_phase:\n                joint = apply_dropout(joint, drop_prob=self._dropout)\n\n            if self._bn:\n                joint = bn.apply(joint)\n\n        return self._pred.apply(joint)\ndictlearn/nli_esim_model.py\nclass ESIM(Initializable):\n    \"\"\"\n    ESIM model based on https://github.com/NYU-MLL/multiNLI/blob/master/python/models/esim.py\n    \"\"\"\n\n    # seq_length, emb_dim, hidden_dim\n    def __init__(self, dim, emb_dim, vocab, def_emb_translate_dim=-1, def_dim=-1, encoder='bilstm', bn=True,\n            def_reader=None, def_combiner=None, dropout=0.5, num_input_words=-1,\n            # Others\n            **kwargs):\n\n        self._dropout = dropout\n        self._vocab = vocab\n        self._emb_dim = emb_dim\n        self._def_reader = def_reader\n        self._def_combiner = def_combiner\n\n        if encoder != 'bilstm':\n            raise NotImplementedError()\n\n        if def_emb_translate_dim < 0:\n            self.def_emb_translate_dim = emb_dim\n        else:\n            self.def_emb_translate_dim = def_emb_translate_dim\n\n        if def_dim < 0:\n            self._def_dim = emb_dim\n        else:\n            self._def_dim = def_dim\n\n        if num_input_words > 0:\n            logger.info(\"Restricting vocab to \" + str(num_input_words))\n            self._num_input_words = num_input_words\n        else:\n            self._num_input_words = vocab.size()\n\n        children = []\n\n        if self.def_emb_translate_dim != self._emb_dim:\n            self._translate_pre_def = Linear(input_dim=emb_dim, output_dim=def_emb_translate_dim)\n            children.append(self._translate_pre_def)\n        else:\n            self._translate_pre_def = None\n\n        ## Embedding\n        self._lookup = LookupTable(self._num_input_words, emb_dim, weights_init=GlorotUniform())\n        children.append(self._lookup)\n\n        if def_reader:\n            self._final_emb_dim = self._def_dim\n            self._def_reader = def_reader\n            self._def_combiner = def_combiner\n            children.extend([self._def_reader, self._def_combiner])\n        else:\n            self._final_emb_dim = self._emb_dim\n\n        ## BiLSTM\n        self._hyp_bidir_fork = Linear(self._def_dim if def_reader else self._emb_dim, 4 * dim, name='hyp_bidir_fork')\n        self._hyp_bidir = Bidirectional(LSTM(dim), name='hyp_bidir')\n        self._prem_bidir_fork = Linear(self._def_dim if def_reader else self._emb_dim, 4 * dim, name='prem_bidir_fork')\n        self._prem_bidir = Bidirectional(LSTM(dim), name='prem_bidir')\n        children.extend([self._hyp_bidir_fork, self._hyp_bidir])\n        children.extend([self._prem_bidir, self._prem_bidir_fork])\n\n        ## BiLSTM no. 2 (encoded attentioned embeddings)\n        self._hyp_bidir_fork2 = Linear(8 * dim, 4 * dim, name='hyp_bidir_fork2')\n        self._hyp_bidir2 = Bidirectional(LSTM(dim), name='hyp_bidir2')\n        self._prem_bidir_fork2 = Linear(8 * dim, 4 * dim, name='prem_bidir_fork2')\n        self._prem_bidir2 = Bidirectional(LSTM(dim), name='prem_bidir2')\n        children.extend([self._hyp_bidir_fork2, self._hyp_bidir2])\n        children.extend([self._prem_bidir2, self._prem_bidir_fork2])\n\n        self._rnns = [self._prem_bidir2, self._hyp_bidir2, self._prem_bidir, self._hyp_bidir]\n\n        ## MLP\n        if bn:\n            self._mlp = BatchNormalizedMLP([Tanh()], [8 * dim, dim], conserve_memory=False, name=\"mlp\")\n            self._pred = BatchNormalizedMLP([Softmax()], [dim, 3],  conserve_memory=False, name=\"pred_mlp\")\n        else:\n            self._mlp = MLP([Tanh()], [8 * dim, dim], name=\"mlp\")\n            self._pred = MLP([Softmax()], [dim, 3], name=\"pred_mlp\")\n\n        children.append(self._mlp)\n        children.append(self._pred)\n\n        ## Softmax\n        self._ndim_softmax = NDimensionalSoftmax()\n        children.append(self._ndim_softmax)\n\n        super(ESIM, self).__init__(children=children, **kwargs)\n\n    def get_embeddings_lookups(self):\n        return [self._lookup]\n\n    def set_embeddings(self, embeddings):\n        self._lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    def get_def_embeddings_lookups(self):\n        return [self._def_reader._def_lookup]\n\n    def set_def_embeddings(self, embeddings):\n        self._def_reader._def_lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    @application\n    def apply(self, application_call,\n            s1_preunk, s1_mask, s2_preunk, s2_mask, def_mask=None,\n            defs=None, s1_def_map=None, s2_def_map=None, train_phase=True):\n        # Shortlist words (sometimes we want smaller vocab, especially when dict is small)\n        s1 = (tensor.lt(s1_preunk, self._num_input_words) * s1_preunk\n              + tensor.ge(s1_preunk, self._num_input_words) * self._vocab.unk)\n        s2 = (tensor.lt(s2_preunk, self._num_input_words) * s2_preunk\n              + tensor.ge(s2_preunk, self._num_input_words) * self._vocab.unk)\n\n        ### Embed ###\n\n        s1_emb = self._lookup.apply(s1)\n        s2_emb = self._lookup.apply(s2)\n\n        application_call.add_auxiliary_variable(\n            1 * s1_emb,\n            name='s1_word_embeddings')\n\n        if self._def_reader:\n            assert defs is not None\n\n            def_embs = self._def_reader.apply(defs, def_mask)\n\n            if self._translate_pre_def:\n                logger.info(\"Translate pre def\")\n                s1_emb = s1_emb.reshape((s1_emb.shape[0] * s1_emb.shape[1], s1_emb.shape[2]))\n                s2_emb = s2_emb.reshape((s2_emb.shape[0] * s2_emb.shape[1], s2_emb.shape[2]))\n                s1_emb = self._translate_pre_def.apply(s1_emb)\n                s2_emb = self._translate_pre_def.apply(s2_emb)\n                s1_emb = s1_emb.reshape((s1_preunk.shape[0], s1_preunk.shape[1], -1))\n                s2_emb = s2_emb.reshape((s2_preunk.shape[0], s2_preunk.shape[1], -1))\n\n            s1_emb = self._def_combiner.apply(\n                s1_emb, s1_mask,\n                def_embs, s1_def_map, word_ids=s1, train_phase=train_phase, call_name=\"s1\")\n\n            s2_emb = self._def_combiner.apply(\n                s2_emb, s2_mask,\n                def_embs, s2_def_map, word_ids=s2, train_phase=train_phase, call_name=\"s2\")\n        else:\n            if train_phase and self._dropout > 0:\n                s1_emb = apply_dropout(s1_emb, drop_prob=self._dropout)\n                s2_emb = apply_dropout(s2_emb, drop_prob=self._dropout)\n\n        ### Encode ###\n\n        # TODO: Share this bilstm?\n        s1_bilstm, _ = self._prem_bidir.apply(flip01(self._prem_bidir_fork.apply(s1_emb)),\n            mask=s1_mask.T) # (batch_size, n_seq, 2 * dim)\n        s2_bilstm, _ = self._hyp_bidir.apply(flip01(self._hyp_bidir_fork.apply(s2_emb)),\n            mask=s2_mask.T) # (batch_size, n_seq, 2 * dim)\n        s1_bilstm = flip01(s1_bilstm)\n        s2_bilstm = flip01(s2_bilstm)\n        ### Attention ###\n\n        # Compute E matrix (eq. 11)\n        # E_ij = <s1[i], s2[j]>\n        # each call computes E[i, :]\n        def compute_e_row(s2_i, s1_bilstm, s1_mask):\n            b_size = s1_bilstm.shape[0]\n            # s2_i is (batch_size, emb_dim)\n            # s1_bilstm is (batch_size, seq_len, emb_dim)\n            # s1_mask is (batch_size, seq_len)\n            # s2_i = s2_i.reshape((s2_i.shape[0], s2_i.shape[1], 1))\n            s2_i = s2_i.reshape((b_size, s2_i.shape[1], 1))\n            s2_i = T.repeat(s2_i, 2, axis=2)\n            # s2_i is (batch_size, emb_dim, 2)\n            assert s1_bilstm.ndim == 3\n            assert s2_i.ndim == 3\n            score = T.batched_dot(s1_bilstm, s2_i) # (batch_size, seq_len, 1)\n            score = score[:, :, 0].reshape((b_size, -1)) # (batch_size, seq_len)\n            return score # E[i, :]\n\n        # NOTE: No point in masking here\n        E, _ = theano.scan(compute_e_row, sequences=[s1_bilstm.transpose(1, 0, 2)],\n            non_sequences=[s2_bilstm, s2_mask])\n        # (seq_len, batch_size, seq_len)\n        E = E.dimshuffle(1, 0, 2)\n        assert E.ndim == 3\n\n        s2s_att_weights = self._ndim_softmax.apply(E, extra_ndim=1)\n        application_call.add_auxiliary_variable(\n            s2s_att_weights.copy(), name='s2s_att_weights')\n\n        # (batch_size, seq_len, seq_len)\n\n        ### Compute tilde vectors (eq. 12 and 13) ###\n\n        def compute_tilde_vector(e_i, s, s_mask):\n            # e_i is (batch_size, seq_len)\n            # s_mask is (batch_size, seq_len)\n            # s_tilde_i = \\sum e_ij b_j, (batch_size, seq_len)\n            score = masked_softmax(e_i, s_mask, axis=1)\n            score = score.dimshuffle(0, 1, \"x\")\n\n            s_tilde_i = (score * (s * s_mask.dimshuffle(0, 1, \"x\"))).sum(axis=1)\n            return s_tilde_i\n\n        # (batch_size, seq_len, def_dim)\n        s1_tilde, _ = theano.scan(compute_tilde_vector,\n            sequences=[E.dimshuffle(1, 0, 2)], non_sequences=[s2_bilstm, s2_mask])\n        s1_tilde = s1_tilde.dimshuffle(1, 0, 2)\n        s2_tilde, _ = theano.scan(compute_tilde_vector,\n            sequences=[E.dimshuffle(2, 0, 1)], non_sequences=[s1_bilstm, s1_mask])\n        s2_tilde = s2_tilde.dimshuffle(1, 0, 2)\n\n        ### Compose (eq. 14 and 15) ###\n\n        # (batch_size, seq_len, 8 * dim)\n        s1_comp = T.concatenate([s1_bilstm, s1_tilde, s1_bilstm - s1_tilde, s1_bilstm * s1_tilde], axis=2)\n        s2_comp = T.concatenate([s2_bilstm, s2_tilde, s2_bilstm - s2_tilde, s2_bilstm * s2_tilde], axis=2)\n        ### Encode (eq. 16 and 17) ###\n\n        # (batch_size, seq_len, 8 * dim)\n        # TODO: Share this bilstm?\n        s1_comp_bilstm, _ = self._prem_bidir2.apply(self._prem_bidir_fork2.apply(flip01(s1_comp)), mask=s1_mask.T)  # (batch_size, n_seq, 2 * dim)\n        s2_comp_bilstm, _ = self._hyp_bidir2.apply(self._hyp_bidir_fork2.apply(flip01(s2_comp)), mask=s2_mask.T)  # (batch_size, n_seq, 2 * dim)\n        s1_comp_bilstm = flip01(s1_comp_bilstm)\n        s2_comp_bilstm = flip01(s2_comp_bilstm)\n        ### Pooling Layer ###\n\n        s1_comp_bilstm_ave = (s1_mask.dimshuffle(0, 1, \"x\") * s1_comp_bilstm).sum(axis=1) \\\n                            / s1_mask.sum(axis=1).dimshuffle(0, \"x\")\n\n        s1_comp_bilstm_max = T.max( ((1 - s1_mask.dimshuffle(0, 1, \"x\")) * -10000) + \\\n                                    (s1_mask.dimshuffle(0, 1, \"x\")) * s1_comp_bilstm, axis=1)\n\n        s2_comp_bilstm_ave = (s2_mask.dimshuffle(0, 1, \"x\") * s2_comp_bilstm).sum(axis=1) \\\n                             / s2_mask.sum(axis=1).dimshuffle(0, \"x\")\n        # (batch_size, dim)\n        s2_comp_bilstm_max = T.max(((1 - s2_mask.dimshuffle(0, 1, \"x\")) * -10000) + \\\n                                   (s2_mask.dimshuffle(0, 1, \"x\")) * s2_comp_bilstm, axis=1)\n\n        ### Final classifier ###\n\n        # MLP layer\n        # (batch_size, 8 * dim)\n        m = T.concatenate([s1_comp_bilstm_ave, s1_comp_bilstm_max, s2_comp_bilstm_ave, s2_comp_bilstm_max], axis=1)\n        pre_logits = self._mlp.apply(m)\n\n        if train_phase:\n            pre_logits = apply_dropout(pre_logits, drop_prob=self._dropout)\n\n        # Get prediction\n        self.logits = self._pred.apply(pre_logits)\n\n        return self.logits\n", "answers": ["    data = SNLIData(path=c['data_path'], layout=c['layout'], vocab=vocab)"], "length": 5411, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "6348b3e17f0fb021c8e9112c4c5f056d8462afedf6a6aa41"}
{"input": "import sys\nimport argparse\nfrom peregrine.iqgen.bits.satellite_gps import GPSSatellite\nfrom peregrine.iqgen.bits.satellite_glo import GLOSatellite\nfrom peregrine.iqgen.if_iface import LowRateConfig\nfrom peregrine.iqgen.if_iface import NormalRateConfig\nfrom peregrine.iqgen.if_iface import HighRateConfig\nfrom peregrine.iqgen.if_iface import CustomRateConfig\nfrom peregrine.iqgen.iqgen_main import computeDistanceDelay\nfrom peregrine.iqgen.iqgen_main import prepareArgsParser\nfrom peregrine.iqgen.iqgen_main import selectOutputConfig\nfrom peregrine.iqgen.iqgen_main import printOutputConfig\nfrom peregrine.iqgen.iqgen_main import computeEnabledBands\nfrom peregrine.iqgen.iqgen_main import selectEncoder\nfrom peregrine.iqgen.iqgen_main import makeProgressBar\nfrom peregrine.iqgen.bits.doppler_poly import Doppler as DopplerPoly\nfrom peregrine.iqgen.bits.doppler_sine import Doppler as DopplerSine\nfrom peregrine.iqgen.bits.signals import GPS\nfrom peregrine.iqgen.bits.message_const import Message as ConstMessage\nfrom peregrine.iqgen.bits.message_zeroone import Message as ZeroOneMessage\nfrom peregrine.iqgen.bits.message_cnav import Message as CNavMessage\nfrom peregrine.iqgen.bits.message_lnav import Message as LNavMessage\nfrom peregrine.iqgen.bits.message_glo import Message as GLOMessage\nfrom peregrine.iqgen.bits.amplitude_poly import AmplitudePoly\nfrom peregrine.iqgen.bits.amplitude_sine import AmplitudeSine\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1BitEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL2BitEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1L2BitEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1L2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1BitEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL2BitEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1L2BitEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1L2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_other import GPSGLONASSBitEncoder\nfrom peregrine.iqgen.bits.encoder_other import GPSGLONASSTwoBitsEncoder\nfrom peregrine.iqgen.bits.tcxo_sine import TCXOSine\nfrom peregrine.iqgen.bits.tcxo_poly import TCXOPoly\nfrom scipy.constants import c as C\n  '''\n  GLONASS L1 band parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--glo-sv', '1',\n      '--bands', 'l1',\n  ]\n  args = parser.parse_args(params)\n  # GLONASS and GPS satellites are all added to the same parameter list: gps_sv\n  assert args.gps_sv[0].isL1Enabled() == True\n  assert args.gps_sv[0].isL2Enabled() == False\n\n\ndef test_params_band_l2():\n  '''\n  GLONASS L2 band parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--glo-sv', '1',\n      '--bands', 'l2',\n  ]\n  args = parser.parse_args(params)\n  # GLONASS and GPS satellites are all added to the same parameter list: gps_sv\n  assert args.gps_sv[0].isL1Enabled() == False\n  assert args.gps_sv[0].isL2Enabled() == True\n\n\ndef test_params_band_l1_l2():\n  '''\n  GLONASS dual band parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--glo-sv', '1',\n      '--bands', 'l1+l2',\n  ]\n  args = parser.parse_args(params)\n  # GLONASS and GPS satellites are all added to the same parameter list: gps_sv\n  assert args.gps_sv[0].isL1Enabled() == True\n  assert args.gps_sv[0].isL2Enabled() == True\n\n\ndef test_params_doppler_zero():\n  '''\n  Zero doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'zero',\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n  assert isinstance(doppler, DopplerPoly)\n  assert doppler.distance0_m == 0.\n  assert doppler.tec_epm2 == 50.\n  assert doppler.coeffs == ()\n\n\ndef test_params_doppler_const():\n  '''\n  Constant doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'const',\n      '--doppler-value', '100'\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n  assert isinstance(doppler, DopplerPoly)\n  assert doppler.distance0_m == 0.\n  assert doppler.tec_epm2 == 50.\n\n  speed_mps = -C / float(GPS.L1CA.CENTER_FREQUENCY_HZ) * 100.\n  assert doppler.coeffs == (speed_mps, )\n\n\ndef test_params_doppler_linear():\n  '''\n  Linear doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'linear',\n      '--doppler-value', '100',\n      '--doppler-speed', '50',\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n  speed_mps = -C / float(GPS.L1CA.CENTER_FREQUENCY_HZ) * 100.\n  accel_mps2 = -C / float(GPS.L1CA.CENTER_FREQUENCY_HZ) * 50.\n  assert isinstance(doppler, DopplerPoly)\n  assert doppler.distance0_m == 0.\n  assert doppler.tec_epm2 == 50.\n  assert doppler.coeffs == (accel_mps2, speed_mps)\n\n\ndef test_params_doppler_sine():\n  '''\n  Sine doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'sine',\n      '--doppler-value', '100',\n      '--doppler-amplitude', '50',\n      '--doppler-period', '3',\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n", "context": "peregrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1L2BitEncoder(TwoBandsBitEncoder):\n  '''\n  Generic single bit encoder for GLONASS L1 and L2 signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 and L2 dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1L2BitEncoder, self).__init__(outputConfig.GLONASS.L1.INDEX,\n                                                outputConfig.GLONASS.L2.INDEX)\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1BitEncoder, self).__init__(outputConfig.GPS.L1.INDEX)\nperegrine/iqgen/bits/doppler_poly.py\nclass Doppler(DopplerBase):\n  '''\n  Doppler control for an object that has constant acceleration. Such signal has\n  constant doppler value with a possible sign invert.\n  '''\n\n  TWO_PI = scipy.constants.pi * 2\n\n  def __init__(self, distance0_m, tec_epm2, coeffs):\n    '''\n    Constructs doppler control object for linear acceleration.\n\n    Parameters\n    ----------\n    distance0_m : float\n      Distance to object in meters at time 0.\n    tec_epm2 : float\n      Total free electron content integrated along line of sight to the object\n      in electrons per m^2.\n    coeffs : array-like\n      Phase shift coefficients. Phase chift will be computed as:\n      C_n*t^n + C_(n-1)^(n-1) + ... + C_2*t^2 + C_1*t + C_0\n      C_n..C_0 - values for speed of light\n    '''\n    super(Doppler, self).__init__(distance0_m=distance0_m,\n                                  tec_epm2=tec_epm2)\n    self.coeffs = tuple([x for x in coeffs])\n    self.n_coeffs = len(coeffs)\n    self.speedPoly = None\n    self.distancePoly = None\n    if self.n_coeffs > 0:\n      new_coeffs = []\n      self.n_coeffs += 1\n      for idx, c in enumerate(coeffs):\n        order = self.n_coeffs - idx - 1\n        new_coeffs.append(c / order)\n      new_coeffs.append(0.)\n      self.distancePoly = numpy.poly1d(new_coeffs)\n      self.distanceCoeffs = new_coeffs\n      if self.n_coeffs > 1:\n        self.speedPoly = numpy.poly1d(coeffs)\n    else:\n      self.distanceCoeffs = None\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"DopplerPoly(coeffs={}, distance0_m={},\" \\\n           \" tec_epm2={} codeDopplerIgnored={})\". \\\n           format(self.coeffs, self.distance0_m,\n                  self.tec_epm2, self.codeDopplerIgnored)\n\n  def computeDistanceM(self, svTime_s):\n    '''\n    Computes doppler shift in meters.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which distance is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Distance to satellite in meters.\n    '''\n    poly = self.distancePoly\n    if poly is not None:\n      return poly(svTime_s)  # self.coeffs[cnt - 1]\n    else:\n      return 0.\n\n  def computeSpeedMps(self, svTime_s):\n    '''\n    Computes speed along the vector to satellite in meters per second.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which speed is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Speed of satellite in meters per second.\n    '''\n    poly = self.speedPoly\n    if poly is not None:\n      return poly(svTime_s)\n    else:\n      return 0.\n\n  def computeDopplerShiftM(self, userTimeAll_s):\n    '''\n    Method to compute metric doppler shift\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler shift in meters\n    '''\n    distancePoly = self.distancePoly\n    if distancePoly is not None:\n      # Slower, but simple\n      doppler_m = distancePoly(userTimeAll_s)\n    else:\n      # No phase shift\n      doppler_m = numpy.zeros_like(userTimeAll_s)\n    return doppler_m\n\n  def computeDopplerShiftHz(self, userTimeAll_s, carrierSignal):\n    '''\n    Method to compute doppler shift in Hz.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n    carrierSignal : object\n      Carrier signal parameters\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler frquency shift in hertz\n    '''\n    speedPoly = self.speedPoly\n    if speedPoly is not None:\n      # Slower, but simple\n      c0 = -float(carrierSignal.CENTER_FREQUENCY_HZ) / scipy.constants.c\n      doppler_hz = speedPoly(userTimeAll_s) * c0\n    else:\n      # No phase shift\n      doppler_hz = numpy.zeros_like(userTimeAll_s)\n    return doppler_hz\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GLONASS L1 signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1TwoBitsEncoder, self).__init__(\n        outputConfig.GLONASS.L1.INDEX)\nperegrine/iqgen/if_iface.py\nclass CustomRateConfig(object):\n  '''\n  Output control configuration for comparison tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  '''\n  NAME = \"Custom configuration for fast tests\"\n  SAMPLE_RATE_HZ = freq_profile_peregrine['sampling_freq']\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = NormalRateConfig.N_GROUPS\n  GROUP_DELAYS = NormalRateConfig.GROUP_DELAYS\n\n  class GPS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_peregrine['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_peregrine['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  class GLONASS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(6000000l + b * 562500l) for b in range(7)] + \\\n          [float(6000000l + b * 562500l) for b in range(-7, 0)]\n      INDEX = 2\n      NAME = GLONASS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(6000000l + b * 437500l) for b in range(7)] + \\\n          [float(6000000l + b * 437500l) for b in range(-7, 0)]\n      INDEX = 3\n      NAME = GLONASS_L2_NAME\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1L2TwoBitsEncoder(TwoBandsTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GLONASS L1 and L2 signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 and L2 dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1L2TwoBitsEncoder, self).__init__(outputConfig.GLONASS.L1.INDEX,\n                                                    outputConfig.GLONASS.L2.INDEX)\nperegrine/iqgen/bits/tcxo_poly.py\nclass TCXOPoly(TCXOBase):\n  '''\n  Polynomial TCXO control class.\n  '''\n\n  def __init__(self, coeffs):\n    '''\n    Constructs TCXO control object.\n\n    Parameters\n    ----------\n    coeffs : array-like\n      Coefficients for TCXO polynome. These coeffificens define a TCXO drift\n      over time in ppm.\n    '''\n    super(TCXOPoly, self).__init__()\n    self.coeffs = tuple([x for x in coeffs])\n    if coeffs:\n      # Recompute drift coefficients from speed of drift into distance of drift\n      new_coeffs = []\n      power_c = len(coeffs)\n      for idx, val in enumerate(coeffs):\n        power = power_c - idx\n        new_coeffs.append(val * 1e-6 / power)\n      new_coeffs.append(0)\n      self.poly = numpy.poly1d(new_coeffs)\n    else:\n      self.poly = None\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Provides string representation of the object\n    '''\n    return \"TCXOPoly: coeffs=%s\" % str(self.coeffs)\n\n  def computeTcxoTime(self, fromSample, toSample, outputConfig):\n    '''\n    Method generates time vector for the given sample index range depending on\n    TCXO behaviour.\n\n    Parameters\n    ----------\n    fromSample : int\n      Index of the first sample.\n    toSample: int\n      Index of the last sample plus 1.\n    outputConfig : object\n      Output configuration\n\n    Returns\n    -------\n    numpy.ndarray(shape=(toSample - fromSample), dtype=numpy.float)\n      Vector of the shifted time stamps for the given TCXO controller.\n    '''\n    poly = self.poly\n\n    if poly:\n      time0_s = fromSample / outputConfig.SAMPLE_RATE_HZ\n      timeX_s = toSample / outputConfig.SAMPLE_RATE_HZ\n      timeAll_s = numpy.linspace(time0_s,\n                                 timeX_s,\n                                 toSample - fromSample,\n                                 endpoint=False,\n                                 dtype=numpy.float)\n      result = poly(timeAll_s)\n    else:\n      result = None\n\n    return result\nperegrine/iqgen/bits/amplitude_poly.py\nclass AmplitudePoly(AmplitudeBase):\n  '''\n  Amplitude control with polynomial dependency over time.\n  '''\n\n  def __init__(self, units, coeffs):\n    '''\n    Constructs polynomial amplitude control object.\n\n    Parameters\n    coeffs : array-like\n      Polynomial coefficients\n    '''\n    super(AmplitudePoly, self).__init__(units)\n\n    self.coeffs = tuple([x for x in coeffs])\n    if len(coeffs) > 0:\n      self.poly = numpy.poly1d(coeffs)\n    else:\n      self.poly = None\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"AmplitudePoly(units={}, c={})\".format(self.units, self.coeffs)\n\n  def applyAmplitude(self, signal, userTimeAll_s, noiseParams):\n    '''\n    Applies amplitude modulation to signal.\n\n    This method applies polynomial modulation.\n\n    Parameters\n    ----------\n    signal : numpy.ndarray\n      Signal sample vector. Each element defines signal amplitude in range\n      [-1; +1]. This vector is modified in place.\n    userTimeAll_s : numpy.ndarray\n      Sample time vector. Each element defines sample time in seconds.\n    noiseParams : NoiseParameters\n      Noise parameters to adjust signal amplitude level.\n\n    Returns\n    -------\n    numpy.ndarray\n      Array with output samples\n    '''\n\n    poly = self.poly\n    if poly is not None:\n      amplitudeVector = poly(userTimeAll_s)\n      amplitudeVector = AmplitudeBase.convertUnits2Amp(amplitudeVector,\n                                                       self.units,\n                                                       noiseParams)\n      signal *= amplitudeVector\n    else:\n      amplitude = AmplitudeBase.convertUnits2Amp(1.,\n                                                 self.units,\n                                                 noiseParams)\n      signal *= amplitude\n\n    return signal\n\n  def computeSNR(self, noiseParams):\n    '''\n    Computes signal to noise ratio in dB.\n\n    noiseParams : NoiseParameters\n      Noise parameter container\n\n    Returns\n    -------\n    float\n      SNR in dB\n    '''\n    poly = self.poly\n    if poly is not None:\n      value = poly(0.)\n    else:\n      value = 1.\n\n    return AmplitudeBase.convertUnits2SNR(value, self.units, noiseParams)\nperegrine/iqgen/bits/message_lnav.py\nclass Message(object):\n  '''\n  GPS LNAV message generator\n  '''\n\n  def __init__(self, prn, tow0=1, n_msg=0, n_prefixBits=50):\n    '''\n    Constructs message object.\n\n    Parameters\n    ----------\n    prn : int\n      Satellite PRN\n    tow0 : int\n      Time of week in 6-second units for the first message\n    n_msg : int, optional\n      Number of messages to pre-generate for output\n    n_prefixBits : int, optional\n      Number of bits to issue before the first message\n    '''\n    super(Message, self).__init__()\n    self.prn = prn\n    self.n_prefixBits = n_prefixBits\n    self.n_msg0 = n_msg\n    self.tow0 = tow0\n    self.messageCount = 0\n    self.messageLen = n_prefixBits\n    self.nextTow = tow0\n    self.nextMsgId = 0\n    self.messageBits = numpy.zeros(n_prefixBits, dtype=numpy.uint8)\n    words = (n_prefixBits + 29) / 30\n    if words:\n      tmp = numpy.zeros(words * 30, dtype=numpy.uint8)\n      tmp[1::2] = 1\n      if words > 1:\n        self.updateParity(tmp[0:30])\n        for i in range(1, words - 1):\n          self.updateParity(tmp[i * 30 - 2: i * 30 + 30])\n        self.updateParity(tmp[words * 30 - 32: words * 30], True)\n      else:\n        self.updateParity(tmp[0: 30], True)\n      self.messageBits[:] = tmp[-n_prefixBits:]\n    self.a8 = numpy.ndarray(1, dtype=numpy.uint8)\n    self.a32 = numpy.ndarray(1, dtype=numpy.dtype('>u4'))\n    self.addMessages(n_msg)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"GPS LNAV: prn=%d pref=%d tow=%d\" % \\\n           (self.prn, self.n_prefixBits, self.nextTow)\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n\n    lastIdx = dataAll_idx[-1]\n    if lastIdx >= self.messageLen:\n      # Grow data bits\n      delta = lastIdx - self.messageLen + 1\n      newMsgCount = delta / 300\n      if delta % 300:\n        newMsgCount += 1\n      self.addMessages(newMsgCount)\n\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.symbolData, dataAll_idx , mode='wrap')\n    return self.messageBits[dataAll_idx]\n\n  def addMessages(self, newMsgCount):\n    '''\n    Generate additional LNAV messages\n\n    This method generates and encodes additional LNAV messages. The message\n    contents is added to the internal buffer.\n\n    Parameters\n    ----------\n    newMsgCount : int\n      Number of messages to generate\n    '''\n    if newMsgCount == 0:\n      return\n\n    newMessageLen = newMsgCount * 300 + self.messageLen\n    newMessageData = numpy.ndarray(newMessageLen, dtype=numpy.uint8)\n    newMessageData[:self.messageLen] = self.messageBits\n    for i in range(self.messageLen, newMessageLen, 300):\n      logger.info(\"Generating LNAV message: prn=%d tow=%d msg_id=%d\" %\n                  (self.prn, self.nextTow, self.nextMsgId))\n      lnav_msg = self.generateLNavMessage()\n      newMessageData[i:i + 300] = lnav_msg\n    self.messageLen = newMessageLen\n    self.messageBits = newMessageData\n    self.messageCount += newMsgCount\n\n    return\n\n  def generateLNavMessage(self):\n    '''\n    Produces additional GPS LNAV message.\n\n    Returns\n    -------\n    numpy.ndarray(shape=300, dtype=numpy.uint8)\n      Message bits.\n    '''\n    msgData = numpy.zeros(300, dtype=numpy.uint8)\n    msgData[1::2] = 1  # Zero + one everywhere\n\n    # TLM word\n    self.fillTlmWord(msgData[0:30], self.nextMsgId)\n    self.nextMsgId += 1\n    self.updateParity(msgData[0:30])\n    # logger.debug(\"TLM: %s\" % msgData[0:30])\n\n    # TOW word\n    self.fillTowWord(msgData[30:60], self.nextTow)\n    self.nextTow += 1\n    if self.nextTow == 7 * 24 * 60 * 10:\n      self.nextTow = 0\n    self.updateParity(msgData[28:60], True)\n    # logger.debug(\"TOW: %s\" % msgData[30:60])\n\n    self.updateParity(msgData[58:90])\n    self.updateParity(msgData[88:120])\n    self.updateParity(msgData[118:150])\n    self.updateParity(msgData[148:180])\n    self.updateParity(msgData[178:210])\n    self.updateParity(msgData[208:240])\n    self.updateParity(msgData[238:270])\n    self.updateParity(msgData[268:300], True)\n\n    return msgData\n\n  def getBits(self, value, nBits):\n    '''\n    Converts integer into bit array\n\n    Parameters\n    ----------\n    value : int\n      Integer value\n    nBits : number of bits to produce\n\n    Returns\n    -------\n    numpy.ndarray(shape=(`nBits`), dtype=numpy.uint8)\n      Parameter `value` represented as a bit array\n    '''\n    if nBits <= 8:\n      self.a8[0] = value\n      result = numpy.unpackbits(self.a8)\n    else:\n      self.a32[0] = value\n      result = numpy.unpackbits(self.a32.view(dtype=numpy.uint8))\n    return result[-nBits:]\n\n  def fillTlmWord(self, wordBits, msgId=0):\n    '''\n    Fills in TLM word contents.\n\n    Parameters\n    ----------\n    wordBits : numpy.ndarray(shape=30, type=numpy.uint8)\n      Destination array\n    '''\n    wordBits[0:8] = self.getBits(0b10001011, 8)  # Preamble\n    wordBits[8:22] = self.getBits(msgId, 14)  # TML message\n    wordBits[22] = 0  # Reserved\n    wordBits[23] = 0  # Integrity\n    return\n\n  def fillTowWord(self, wordBits, tow):\n    '''\n    Fills in TOW word contents.\n\n    Parameters\n    ----------\n    wordBits : numpy.ndarray(shape=30, type=numpy.uint8)\n      Destination array\n    '''\n    wordBits[0:17] = self.getBits(tow, 17)  # TOW count in 6 second units\n    wordBits[17] = 0  # Alert Flag\n    wordBits[18] = 0  # Anti-Spoof flag\n    wordBits[19:22] = self.getBits(0, 3)  # Sub-frame ID\n    return\n\n  def updateParity(self, dataBits, resolve=False):\n    '''\n    Updates data bits and computes parity.\n\n    When 32 bits are provided, they are used for parity computation and for\n    bit inversion.\n\n    Parameters\n    ----------\n    dataBits : numpy.ndarray(dtype=numpy.uint8)\n      30 or 32 element array\n    resolve: bool, optional\n      When specified, bits d23 and d24 of the GPS word are updated to ensure\n      that parity bits d29 and d30 are zeros.\n    '''\n    packed = numpy.packbits(dataBits)\n    acc = (packed[0] << 24) | (packed[1] << 16) | \\\n          (packed[2] << 8) | packed[3]\n    if len(dataBits) == 30:\n      acc >>= 2\n    elif acc & 0x40000000:\n      acc ^= 0x3FFFFFC0\n      dataBits[-30:-6] ^= 1\n\n    # D29 = D30*^d1^d3^d5^d6^d7^d9^d10^d14^d15^d16^d17^d18^d21^d22^d24\n    d29 = parity(acc & 0b01101011101100011111001101000000)\n    # D30 = D29*^d3^d5^d6^d8^d9^d10^d11^d13^d15^d19^d22^d23^d24\n    d30 = parity(acc & 0b10001011011110101000100111000000)\n\n    if resolve:\n      if d29:\n        acc ^= 0x80\n        d29 = False\n        d30 = not d30\n        dataBits[-8] ^= 1\n      if d30:\n        acc ^= 0x40\n        d30 = False\n        dataBits[-7] ^= 1\n\n    # D25 = D29*^d1^d2^d3^d5^d6^d10^d11^d12^d13^d14^d17^d18^d20^d23\n    dataBits[-6] = parity(acc & 0b10111011000111110011010010000000)\n    # D26 = D30*^d2^d3^d4^d6^d7^d11^d12^d13^d14^d15^d18^d19^d21^d24\n    dataBits[-5] = parity(acc & 0b01011101100011111001101001000000)\n    # D27 = D29*^d1^d3^d4^d5^d7^d8^d12^d13^d14^d15^d16^d19^d20^d22\n    dataBits[-4] = parity(acc & 0b10101110110001111100111000000000)\n    # D28 = D30*^d2^d4^d5^d6^d8^d9^d13^d14^d15^d16^d17^d20^d21^d23\n    dataBits[-3] = parity(acc & 0b01010111011000111110011010000000)\n    # D29 = D30*^d1^d3^d5^d6^d7^d9^d10^d14^d15^d16^d17^d18^d21^d22^d24\n    dataBits[-2] = d29\n    # D30 = D29*^d3^d5^d6^d8^d9^d10^d11^d13^d15^d19^d22^d23^d24\n    dataBits[-1] = d30\n\n    return\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1TwoBitsEncoder, self).__init__(outputConfig.GPS.L1.INDEX)\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1L2BitEncoder(TwoBandsBitEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A and L2 Civil signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A and L2 C dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1L2BitEncoder, self).__init__(outputConfig.GPS.L1.INDEX,\n                                            outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/satellite_gps.py\nclass GPSSatellite(Satellite):\n  '''\n  GPS satellite object.\n  '''\n\n  def __init__(self, prnNo):\n    '''\n    Constructs satellite object\n\n    Parameters\n    ----------\n    prnNo : int\n      GPS satellite number for selecting PRN.\n    '''\n    super(GPSSatellite, self).__init__(\"GPS{}\".format(prnNo))\n    self.prn = prnNo\n    self.l2clCodeType = '01'\n    self.l1caCode = GPS_L1CA_Code(prnNo)\n    self.l2cCode = GPS_L2C_Code(prnNo, self.l2clCodeType)\n    self.l1caEnabled = False\n    self.l2cEnabled = False\n    self.l1caMessage = DEFAULT_MESSAGE\n    self.l2cMessage = DEFAULT_MESSAGE\n    self.time0S = 0.\n    self.pr0M = 0.\n    self.phaseShift = 0.\n\n  def setL1CAEnabled(self, enableFlag):\n    '''\n    Enables or disable GPS L1 C/A sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L1 C/A samples\n    '''\n    self.l1caEnabled = enableFlag\n\n  def isL1CAEnabled(self):\n    '''\n    Tests if L1 C/A signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L1 C/A signal generation is enabled, False otherwise\n    '''\n    return self.l1caEnabled\n\n  def setL2CEnabled(self, enableFlag):\n    '''\n    Enables or disable GPS L2 C sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L2 C samples\n    '''\n    self.l2cEnabled = enableFlag\n\n  def isL2CEnabled(self):\n    '''\n    Tests if L2 C signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L2 C signal generation is enabled, False otherwise\n    '''\n    return self.l2cEnabled\n\n  def setL2CLCodeType(self, clCodeType):\n    '''\n    Change L1 CL code type if needed\n\n    Parameters\n    ----------\n    clCodeType : string\n      L2 CL code type: '00', '01' or '11'\n    '''\n    if self.l2clCodeType != clCodeType:\n      self.l2cCode = GPS_L2C_Code(self.prn, clCodeType)\n      self.l2clCodeType = clCodeType\n\n  def getL2CLCodeType(self):\n    '''\n    Get L2 CL code type\n\n    Returns\n    -------\n    string\n      L2 CL code type: '00', '01' or '11'\n    '''\n    return self.l2clCodeType\n\n  def setL1CAMessage(self, message):\n    '''\n    Configures data source for L1 C/A signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L1 C/A signal.\n    '''\n    self.l1caMessage = message\n\n  def setL2CMessage(self, message):\n    '''\n    Configures data source for L2 C signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L2 C signal.\n    '''\n    self.l2cMessage = message\n\n  def getL1CAMessage(self):\n    '''\n    Returns configured message object for GPS L1 C/A band\n\n    Returns\n    -------\n    object\n      L1 C/A message object\n    '''\n    return self.l1caMessage\n\n  def getL2CMessage(self):\n    '''\n    Returns configured message object for GPS L2 C band\n\n    Returns\n    -------\n    object\n      L2 C message object\n    '''\n    return self.l2cMessage\n\n  def getBatchSignals(self,\n                      userTimeAll_s,\n                      samples,\n                      outputConfig,\n                      noiseParams,\n                      band,\n                      debug):\n    '''\n    Generates signal samples.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(n_samples, dtype=numpy.float64)\n      Vector of observer's timestamps in seconds for the interval start.\n    samples : numpy.ndarray((4, n_samples))\n      Array to which samples are added.\n    outputConfig : object\n      Output configuration object.\n    noiseParams : NoiseParameters\n      Noise parameters object\n    band : Band\n      Band description object.\n    debug : bool\n      Debug flag\n\n    Returns\n    -------\n    list\n      Debug information\n    '''\n    result = []\n    if (self.l1caEnabled and band == outputConfig.GPS.L1):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCY_HZ\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GPS.L1CA,\n                                         intermediateFrequency_hz,\n                                         self.l1caMessage,\n                                         self.l1caCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GPSL1\", 'doppler': values[1]}\n      result.append(debugData)\n    if (self.l2cEnabled and band == outputConfig.GPS.L2):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCY_HZ\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GPS.L2C,\n                                         intermediateFrequency_hz,\n                                         self.l2cMessage,\n                                         self.l2cCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GPSL2\", 'doppler': values[1]}\n      result.append(debugData)\n    return result\n\n  def isBandEnabled(self, band, outputConfig):\n    '''\n    Checks if particular band is supported and enabled.\n\n    Parameters\n    ----------\n    band : Band\n      Band description object.\n    outputConfig : object\n      Output configuration\n\n    Returns:\n    bool\n      True, if the band is supported and enabled; False otherwise.\n    '''\n    result = None\n    if band == outputConfig.GPS.L1:\n      result = self.isL1CAEnabled()\n    elif band == outputConfig.GPS.L2:\n      result = self.isL2CEnabled()\n    else:\n      result = False\n    return result\nperegrine/iqgen/bits/message_zeroone.py\nclass Message(object):\n  '''\n  Message that contains zeros and ones\n  '''\n\n  def __init__(self):\n    '''\n    Constructs object.\n    '''\n    super(Message, self).__init__()\n    self.bits = numpy.asarray([0, 1], dtype=numpy.uint8)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"ZeroOne\"\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.bits, dataAll_idx , mode='wrap')\n    return self.bits[dataAll_idx & 1]\nperegrine/iqgen/bits/doppler_sine.py\nclass Doppler(DopplerBase):\n  '''\n  Doppler control for an object that has peridic acceleration.\n  '''\n\n  TWO_PI = scipy.constants.pi * 2.\n\n  def __init__(self, distance0_m,  tec_epm2, speed0_mps, amplutude_mps, period_s):\n    '''\n    Constructs doppler control object for linear acceleration.\n\n    Parameters\n    ----------\n    distance0_m : float\n      Distance to object in meters at time 0.\n    tec_epm2 : float\n      Total free electron content integrated along line of sight to the object\n      in electrons per m^2.\n    speed0_mps : float\n      Speed of satellite at time 0 in meters per second.\n    amplutude_mps : float\n      Amplitude of change\n    period_s : float\n      Period of change\n    '''\n    super(Doppler, self).__init__(distance0_m=distance0_m,\n                                  tec_epm2=tec_epm2)\n    self.speed0_mps = speed0_mps\n    self.amplutude_mps = amplutude_mps\n    self.period_s = period_s\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"SineDoppler(distance0_m={}, tec_epm2={},\" \\\n           \" speed0_mps={}, amplitude_mps={}, period_s={},\" \\\n           \" codeDopplerIgnored={})\".\\\n        format(self.distance0_m, self.tec_epm2, self.speed0_mps,\n               self.amplutude_mps, self.period_s, self.codeDopplerIgnored)\n\n  def computeDistanceM(self, svTime_s):\n    '''\n    Computes doppler shift in meters.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which distance is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Distance to satellite in meters.\n    '''\n    return self.distance0_m + self.speed0_mps * svTime_s + \\\n        self.amplutude_mps * \\\n        (1 - numpy.cos(Doppler.TWO_PI * svTime_s / self.period_s))\n\n  def computeSpeedMps(self, svTime_s):\n    '''\n    Computes speed along the vector to satellite in meters per second.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which speed is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Speed of satellite in meters per second.\n    '''\n    return self.speed0_mps + self.amplutude_mps * \\\n        numpy.sin(Doppler.TWO_PI * svTime_s / self.period_s)\n\n  def computeDopplerShiftM(self, userTimeAll_s):\n    '''\n    Method to compute metric doppler shift\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler shift in meters\n    '''\n    D_0 = self.speed0_mps\n    D_1 = self.amplutude_mps * self.period_s / self.twoPi\n    D_2 = self.twoPi / self.period_s\n\n    doppler_m = numpy.cos(D_2 * userTimeAll_s)\n    doppler_m -= 1.\n    doppler_m *= -D_1\n    if D_0:\n      doppler_m += D_0 * userTimeAll_s\n\n    return doppler_m\n\n  def computeDopplerShiftHz(self, userTimeAll_s, carrierSignal):\n    '''\n    Method to compute doppler shift in Hz.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n    carrierSignal : object\n      Carrier signal parameters\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler frquency shift in hertz\n    '''\n    D_0 = self.speed0_mps\n    D_1 = self.amplutude_mps\n    D_2 = self.twoPi / self.period_s\n\n    doppler_hz = numpy.sin(D_2 * userTimeAll_s) * D_1\n    if D_0:\n      doppler_hz += D_0\n    doppler_hz *= -float(carrierSignal.CENTER_FREQUENCY_HZ) / scipy.constants.c\n    return doppler_hz\nperegrine/iqgen/if_iface.py\nclass LowRateConfig(object):\n  '''\n  Output control configuration for quick tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  Galileo : object\n    Galileo band information\n  Beidou : object\n    Beidou band information\n  GLONASS : object\n    Glonass band information\n  '''\n  NAME = \"Low rate configuration for fast tests\"\n  SAMPLE_RATE_HZ = 24.84375e5\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = 4\n  GROUP_DELAYS = (0., 0., 0., 0.)\n\n  class GPS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_low_rate['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_low_rate['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  class GLONASS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(1200000 + b * 562500) for b in range(7)] + \\\n          [float(1200000 + b * 562500) for b in range(-7, 0)]\n      INDEX = 2\n      NAME = GLONASS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(1100000 + b * 437500) for b in range(7)] + \\\n          [float(1100000 + b * 437500) for b in range(-7, 0)]\n      INDEX = 3\n      NAME = GLONASS_L2_NAME\n\n  class Galileo(object):\n\n    class E1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 14.58e5\n      INDEX = 0\n      NAME = GALILEO_E1_NAME\n\n    class E6(object):\n      INTERMEDIATE_FREQUENCY_HZ = 43.75e5\n      INDEX = 2\n      NAME = GALILEO_E6_NAME\n\n    class E5b(object):\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e5\n      INDEX = 3\n      NAME = GALILEO_E5B_NAME\n\n  class Beidou(object):\n\n    class B1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 28.902e5\n      INDEX = 0\n      NAME = BEIDOU_B1_NAME\n\n    class B2:\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e5\n      INDEX = 3\n      NAME = BEIDOU_B2_NAME\n\n    class B3(object):\n      INTERMEDIATE_FREQUENCY_HZ = 33.52e5\n      INDEX = 2\n      NAME = BEIDOU_B3_NAME\nperegrine/iqgen/if_iface.py\nclass NormalRateConfig(object):\n  '''\n  Output control configuration for normal tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  Galileo : object\n    Galileo band information\n  Beidou : object\n    Beidou band information\n  GLONASS : object\n    Glonass band information\n  '''\n  NAME = \"Normal rate configuration equivalent to decimated data output\"\n  SAMPLE_RATE_HZ = 24.84375e6\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = LowRateConfig.N_GROUPS\n  GROUP_DELAYS = LowRateConfig.GROUP_DELAYS\n\n  class GPS(object):\n    '''\n    Parameters for GPS bands data generation.\n    '''\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_normal_rate['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_normal_rate['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  class GLONASS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(12000000l + b * 562500l) for b in range(7)] + \\\n          [float(12000000l + b * 562500l) for b in range(-7, 0)]\n      INDEX = 2\n      NAME = GLONASS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(11000000l + b * 437500l) for b in range(7)] + \\\n          [float(11000000l + b * 437500l) for b in range(-7, 0)]\n      INDEX = 3\n      NAME = GLONASS_L2_NAME\n\n  class Galileo(object):\n\n    class E1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 14.58e6\n      INDEX = 0\n      NAME = GALILEO_E1_NAME\n\n    class E6(object):\n      INTERMEDIATE_FREQUENCY_HZ = 43.75e6\n      INDEX = 2\n      NAME = GALILEO_E6_NAME\n\n    class E5b(object):\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e6\n      INDEX = 3\n      NAME = GALILEO_E5B_NAME\n\n  class Beidou(object):\n\n    class B1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 28.902e6\n      INDEX = 0\n      NAME = BEIDOU_B1_NAME\n\n    class B2:\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e6\n      INDEX = 3\n      NAME = BEIDOU_B2_NAME\n\n    class B3(object):\n      INTERMEDIATE_FREQUENCY_HZ = 33.52e6\n      INDEX = 2\n      NAME = BEIDOU_B3_NAME\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL2BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GLONASS L2 signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L2 band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL2BitEncoder, self).__init__(outputConfig.GLONASS.L2.INDEX)\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GLPNASS L1 signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1BitEncoder, self).__init__(outputConfig.GLONASS.L1.INDEX)\nperegrine/iqgen/if_iface.py\nclass HighRateConfig(object):\n  '''\n  Output control configuration for high data rate tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  Galileo : object\n    Galileo band information\n  Beidou : object\n    Beidou band information\n  GLONASS : object\n    Glonass band information\n  '''\n  NAME = \"High rate configuration equivalent to full rate data output\"\n  SAMPLE_RATE_HZ = 99.375e6\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = NormalRateConfig.N_GROUPS\n  GROUP_DELAYS = NormalRateConfig.GROUP_DELAYS\n\n  class GPS(object):\n    '''\n    Parameters for GPS bands data generation.\n    '''\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_high_rate['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_high_rate['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  GLONASS = NormalRateConfig.GLONASS\n  Galileo = NormalRateConfig.Galileo\n  Beidou = NormalRateConfig.Beidou\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL2BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GPS L2 Civil signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L2 C band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL2BitEncoder, self).__init__(outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/tcxo_sine.py\nclass TCXOSine(TCXOBase):\n  '''\n  Sine TCXO control class.\n  '''\n\n  def __init__(self, initial_ppm, amplitude_ppm, period_s):\n    '''\n    Constructs TCXO control object.\n\n    Parameters\n    ----------\n    initial_ppm : float\n      Initial drift in ppm\n    amplitude_ppm : float\n      Drift amplitude in ppm\n    period_s : float\n      Drift period in seconds\n    '''\n    super(TCXOSine, self).__init__()\n\n    self.initial_ppm = initial_ppm\n    self.amplitude_ppm = amplitude_ppm\n    self.period_s = period_s\n    self.c0 = -amplitude_ppm * 1e-6 * self.period_s / (2. * scipy.constants.pi)\n    self.c1 = 2. * scipy.constants.pi / period_s\n    self.c2 = initial_ppm * 1e-6\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Provides string representation of the object\n    '''\n    return \"TCXOSine: initial_ppm=%f amplitude_ppm=%f period_s=%f\" % \\\n           (self.initial_ppm, self.amplitude_ppm, self.period_s)\n\n  def computeTcxoTime(self, fromSample, toSample, outputConfig):\n    '''\n    Method generates time vector for the given sample index range depending on\n    TCXO behaviour.\n\n    Parameters\n    ----------\n    fromSample : int\n      Index of the first sample.\n    toSample: int\n      Index of the last sample plus 1.\n    outputConfig : object\n      Output configuration\n\n    Returns\n    -------\n    numpy.ndarray(shape=(toSample - fromSample), dtype=numpy.float)\n      Vector of the shifted time stamps for the given TCXO controller.\n    '''\n    c0 = self.c0\n    c1 = self.c1\n    c2 = self.c2\n    time0_s = fromSample / outputConfig.SAMPLE_RATE_HZ\n    timeX_s = toSample / outputConfig.SAMPLE_RATE_HZ\n\n    timeAll_s = numpy.linspace(time0_s,\n                               timeX_s,\n                               toSample - fromSample,\n                               endpoint=False,\n                               dtype=numpy.float)\n\n    result = numpy.cos(timeAll_s * c1)\n    result += -1.\n    result *= c0\n    if c2:\n      result += timeAll_s * c2\n\n    return result\nperegrine/iqgen/bits/message_const.py\nclass Message(object):\n  '''\n  Message consisting of same bits\n  '''\n\n  def __init__(self, bitValue):\n    '''\n    Initializes object.\n\n    Parameters\n    ----------\n    bitValue : int\n      Value for the bits. 1 for 0 bits, -1 for 1 bits.\n    '''\n    super(Message, self).__init__()\n    self.bitValue = bitValue\n    self.binValue = 1 if bitValue < 0 else 0\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"Const: bit value=%d\" % self.binValue\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n    result = numpy.ndarray(len(dataAll_idx), dtype=numpy.uint8)\n    result.fill(self.binValue)\n    return result\nperegrine/iqgen/bits/message_glo.py\nclass Message(object):\n  '''\n  GLONASS message generator\n  '''\n\n  def __init__(self, prn, tow0=1, n_msg=0, n_prefixBits=50):\n    '''\n    Constructs message object.\n\n    Parameters\n    ----------\n    prn : int\n      Satellite PRN\n    tow0 : int\n      Time of week in 6-second units for the first message\n    n_msg : int, optional\n      Number of messages to generate for output\n    n_prefixBits : int, optional\n      Number of bits to issue before the first message\n    '''\n    super(Message, self).__init__()\n    self.prn = prn\n    self.n_prefixBits = n_prefixBits\n    self.n_msg0 = n_msg\n    self.tow0 = tow0\n    self.messageCount = 0\n    self.messageLen = n_prefixBits\n    self.nextTk_h = tow0 / (60 * 60) % (60 * 60 * 24)\n    self.nextTk_m = tow0 / 60 % 60\n    self.nextTk_30s = 1 if tow0 / 30 % 2 else 0\n\n    self.nextMsgId = 1\n    self.messageBits = numpy.zeros(n_prefixBits, dtype=numpy.uint8)\n    self.messageBits[1::2] = 1\n    self.a8 = numpy.ndarray(1, dtype=numpy.uint8)\n    self.addMessages(n_msg)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"GLONASSS: prn=%d pref=%d tod=%02d:%02d:%02d\" % \\\n           (self.prn, self.n_prefixBits, self.nextTk_h, self.nextTk_m,\n            30 if self.nextTk_30s else 0)\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n\n    lastIdx = dataAll_idx[-1]\n    if lastIdx >= self.messageLen:\n      # Grow data bits\n      delta = lastIdx - self.messageLen + 1\n      newMsgCount = delta / 200\n      if delta % 200:\n        newMsgCount += 1\n      self.addMessages(newMsgCount)\n\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.symbolData, dataAll_idx , mode='wrap')\n    return self.messageBits[dataAll_idx]\n\n  def addMessages(self, newMsgCount):\n    '''\n    Generate additional GLONASS messages\n\n    This method generates and encodes additional LNAV messages. The message\n    contents is added to the internal buffer.\n\n    Parameters\n    ----------\n    newMsgCount : int\n      Number of messages to generate\n    '''\n    newMessageLen = newMsgCount * 200 + self.messageLen\n    newMessageData = numpy.ndarray(newMessageLen, dtype=numpy.uint8)\n    newMessageData[:self.messageLen] = self.messageBits\n    for i in range(self.messageLen, newMessageLen, 200):\n      if self.nextMsgId == 1:\n        logger.info(\"Starting new GLONASS frame: prn=%d frame tod=%02d:%02d:%02d\" %\n                    (self.prn,\n                     self.nextTk_h, self.nextTk_m,\n                     30 if self.nextTk_30s == 1 else 0))\n      logger.debug(\"Generating GLONASS string: prn=%d msg=%d\" %\n                   (self.prn, self.nextMsgId))\n      glo_msg = self.generateGloMessage()\n      # First 170 symbols are 85 bits of message\n      # Meander sequence: as per ICD, each data bit is added to 1/0 sequence\n      newMessageData[i:i + 85 * 2:2] = glo_msg ^ 1\n      newMessageData[i + 1:i + 85 * 2:2] = glo_msg\n      # Last 30 symbols is the time mark\n      newMessageData[i + 170:i + 200] = _TIME_MARK\n    self.messageLen = newMessageLen\n    self.messageBits = newMessageData\n    self.messageCount += newMsgCount\n\n  def generateGloMessage(self):\n    '''\n    Produces additional GLONASS message.\n    Currently the method generates only type 1 GLONASS strings with ToD.\n\n    Returns\n    -------\n    numpy.ndarray(shape=85, dtype=numpy.uint8)\n      Message bits.\n    '''\n    msgData = numpy.zeros(85, dtype=numpy.uint8)\n\n    if self.nextMsgId == 1:\n      self.fillString1(msgData)\n    else:\n      self.fillString2_15(msgData)\n\n    self.nextMsgId += 1\n    if self.nextMsgId == 16:\n      self.nextMsgId = 1\n\n      # Frame has changed - the frame length is 30 seconds\n      self.nextTk_30s += 1\n      while self.nextTk_30s >= 2:\n        self.nextTk_30s -= 2\n        self.nextTk_m += 1\n      while self.nextTk_m >= 60:\n        self.nextTk_m -= 60\n        self.nextTk_h += 1\n      while self.nextTk_h >= 24:\n        self.nextTk_h -= 24\n\n    self.updateParity(msgData)\n\n    return msgData\n\n  def fillString1(self, msgData):\n    msgData[0] = 0                                     # idle chip\n    msgData[1:5] = self.getBits(0b0001, 4)             # m[4]\n    # [2] - Reserved\n    msgData[7:9] = self.getBits(0b00, 2)               # P1[2]\n\n    msgData[9:14] = self.getBits(self.nextTk_h, 5)     # Tk[12]\n    msgData[14:20] = self.getBits(self.nextTk_m, 6)    # Tk[12]\n    msgData[26:27] = self.getBits(self.nextTk_30s, 1)  # Tk[12]\n    msgData[28::2] = 1  # Zero + one everywhere\n\n  def fillString2_15(self, msgData):\n    msgData[1::2] = 1  # Zero + one everywhere\n\n  def getBits(self, value, nBits):\n    '''\n    Converts integer into bit array\n\n    Parameters\n    ----------\n    value : int\n      Integer value\n    nBits : number of bits to produce\n\n    Returns\n    -------\n    numpy.ndarray(shape=(`nBits`), dtype=numpy.uint8)\n      Parameter `value` represented as a bit array\n    '''\n    if nBits <= 8:\n      self.a8[0] = value\n      result = numpy.unpackbits(self.a8)\n    else:  # pragma: no cover\n      assert False\n    return result[-nBits:]\n\n  def updateParity(self, dataBits):\n    '''\n    Updates data bits and computes parity.\n\n    When 85 bits are provided, they are used for parity computation and for\n    bit inversion.\n\n    Parameters\n    ----------\n    dataBits : numpy.ndarray(dtype=numpy.uint8)\n      85 element array\n    '''\n    packed = numpy.packbits(dataBits)\n    assert len(packed) == 11\n\n    hc = _HAMMING_COEFFS\n    for bIdx in range(8):\n      p = 0\n      for i in range(11):\n        p ^= parity(packed[i] & hc[bIdx][i])\n      dataBits[-(bIdx + 1)] = p\n      packed[10] |= p << bIdx\nperegrine/iqgen/bits/satellite_glo.py\nclass GLOSatellite(Satellite):\n  '''\n  GLONASS satellite object.\n  '''\n\n  def __init__(self, prnNo):\n    '''\n    Constructs satellite object\n\n    Parameters\n    ----------\n    prnNo : int\n      GPS satellite number for selecting PRN.\n    '''\n    super(GLOSatellite, self).__init__(\"GLONASS{}\".format(prnNo))\n    self.prn = prnNo\n    self.caCode = GLO_CA_Code(prnNo)\n    self.l1Enabled = False\n    self.l2Enabled = False\n    self.l1Message = DEFAULT_MESSAGE\n    self.l2Message = DEFAULT_MESSAGE\n    self.time0S = 0.\n    self.pr0M = 0.\n    self.phaseShift = 0.\n\n  def setL1Enabled(self, enableFlag):\n    '''\n    Enables or disable GLONASS L1 C/A sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L1 C/A samples\n    '''\n    self.l1Enabled = enableFlag\n\n  def isL1Enabled(self):\n    '''\n    Tests if L1 C/A signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L1 C/A signal generation is enabled, False otherwise\n    '''\n    return self.l1Enabled\n\n  def setL2Enabled(self, enableFlag):\n    '''\n    Enables or disable GLONASS L2 C sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L2 C samples\n    '''\n    self.l2Enabled = enableFlag\n\n  def isL2Enabled(self):\n    '''\n    Tests if L2 C signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L2 C signal generation is enabled, False otherwise\n    '''\n    return self.l2Enabled\n\n  def setL1Message(self, message):\n    '''\n    Configures data source for L1 C/A signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L1 C/A signal.\n    '''\n    self.l1Message = message\n    self.l2Message = message\n\n  def setL2Message(self, message):\n    '''\n    Configures data source for L2 C signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L2 C signal.\n    '''\n    pass\n\n  def getL1Message(self):\n    '''\n    Returns configured message object for GPS L1 C/A band\n\n    Returns\n    -------\n    object\n      L1 C/A message object\n    '''\n    return self.l1Message\n\n  def getL2Message(self):\n    '''\n    Returns configured message object for GPS L2 C band\n\n    Returns\n    -------\n    object\n      L2 C message object\n    '''\n    return self.l1Message\n\n  def getBatchSignals(self,\n                      userTimeAll_s,\n                      samples,\n                      outputConfig,\n                      noiseParams,\n                      band,\n                      debug):\n    '''\n    Generates signal samples.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(n_samples, dtype=numpy.float64)\n      Vector of observer's timestamps in seconds for the interval start.\n    samples : numpy.ndarray((4, n_samples))\n      Array to which samples are added.\n    outputConfig : object\n      Output configuration object.\n    noiseParams : NoiseParameters\n      Noise parameters object\n    band : Band\n      Band description object.\n    debug : bool\n      Debug flag\n\n    Returns\n    -------\n    list\n      Debug information\n    '''\n    result = []\n    if (self.l1Enabled and band == outputConfig.GLONASS.L1):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCIES_HZ[self.prn]\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GLONASS.L1S[self.prn],\n                                         intermediateFrequency_hz,\n                                         self.l1Message,\n                                         self.caCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GLOL1\", 'doppler': values[1]}\n      result.append(debugData)\n    if (self.l2Enabled and band == outputConfig.GLONASS.L2):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCIES_HZ[self.prn]\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GLONASS.L2S[self.prn],\n                                         intermediateFrequency_hz,\n                                         self.l2Message,\n                                         self.caCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GLOL2\", 'doppler': values[1]}\n      result.append(debugData)\n    return result\n\n  def isBandEnabled(self, band, outputConfig):\n    '''\n    Checks if particular band is supported and enabled.\n\n    Parameters\n    ----------\n    band : Band\n      Band description object.\n    outputConfig : object\n      Output configuration\n\n    Returns:\n    bool\n      True, if the band is supported and enabled; False otherwise.\n    '''\n    result = None\n    if band == outputConfig.GLONASS.L1:\n      result = self.isL1Enabled()\n    elif band == outputConfig.GLONASS.L2:\n      result = self.isL2Enabled()\n    else:\n      result = False\n    return result\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1L2TwoBitsEncoder(TwoBandsTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A and L2 Civil signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A and L2 C dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1L2TwoBitsEncoder, self).__init__(outputConfig.GPS.L1.INDEX,\n                                                outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL2TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GPS L2 Civil signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L2 C band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL2TwoBitsEncoder, self).__init__(outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/message_cnav.py\nclass Message(object):\n  '''\n  GPS LNAV message block.\n\n  The object provides proper-formatted CNAV messages with random contents.\n  '''\n\n  def __init__(self, prn, tow0=2, n_msg=0, n_prefixBits=50):\n    '''\n    Constructs message object.\n\n    Parameters\n    ----------\n    prn : int\n      Satellite PRN\n    tow0 : int\n      Time of week in 6-second units for the first message\n    n_msg : int, optional\n      Number of messages to generate for output\n    n_prefixBits : int, optional\n      Number of bits to issue before the first message\n    '''\n    super(Message, self).__init__()\n\n    if tow0 & 1:\n      logger.error(\"Initial ToW is not multiple of 2\")\n\n    self.prn = prn\n    self.tow0 = tow0\n    self.n_msg0 = n_msg\n    self.n_prefixBits = n_prefixBits\n\n    self.encoder = ConvEncoder27()\n    self.messageCount = 0\n    self.messageLen = n_prefixBits * 2\n    self.symbolData = numpy.zeros(self.messageLen, dtype=numpy.uint8)\n\n    prefixBits = numpy.zeros(self.n_prefixBits, dtype=numpy.uint8)\n    prefixBits[0::2] = 1\n    self.symbolData[:] = self.encoder.encode(prefixBits)\n    self.nextTow = tow0\n    self.addMessages(n_msg)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"GPS CNAV: prn=%d pref=%d tow=%d\" % \\\n           (self.prn, self.n_prefixBits, self.nextTow)\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n\n    lastIdx = dataAll_idx[-1]\n    if lastIdx >= self.messageLen:\n      # Grow data bits\n      delta = lastIdx - self.messageLen + 1\n      newMsgCount = delta / 600\n      if delta % 600:\n        newMsgCount += 1\n      self.addMessages(newMsgCount)\n\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.symbolData, dataAll_idx , mode='wrap')\n    return self.symbolData[dataAll_idx]\n\n  def addMessages(self, newMsgCount):\n    '''\n    Generate additional CNAV messages\n\n    This method generates and encodes additional CNAV messages. The message\n    contents is encoded using 2-7 convolution encoder and added to the internal\n    buffer.\n\n    Parameters\n    ----------\n    newMsgCount : int\n      Number of messages to generate\n    '''\n    newMessageLen = newMsgCount * 600 + self.messageLen\n    newSymbolData = numpy.ndarray(newMessageLen, dtype=numpy.uint8)\n    newSymbolData[:self.messageLen] = self.symbolData\n    for i in range(self.messageLen, newMessageLen, 600):\n      logger.info(\"Generating CNAV message: prn=%d tow=%d msg_id=%d\" %\n                  (self.prn, self.nextTow, 0))\n      cnav_msg = CNavRawMsg.generate(self.prn, 0, self.nextTow)\n      self.nextTow += 2\n      if self.nextTow == 7 * 24 * 60 * 10:\n        self.nextTow = 0\n      encoded = self.encoder.encode(cnav_msg)\n      newSymbolData[i:i + 600] = encoded\n    self.messageLen = newMessageLen\n    self.symbolData = newSymbolData\n    self.messageCount += newMsgCount\nperegrine/iqgen/bits/amplitude_sine.py\nclass AmplitudeSine(AmplitudeBase):\n  '''\n  Amplitude control with sine modulation over time.\n  '''\n\n  def __init__(self, units, initial, amplitude, period_s):\n    '''\n    Constructs sine amplitude control object.\n\n    Parameters\n    initial : float\n      Initial amplitude value (median)\n    amplitude : float\n      Amplitude of change\n    period_s : float\n      Period of change in seconds\n    '''\n    super(AmplitudeSine, self).__init__(units)\n    self.initial = initial\n    self.amplitude = amplitude\n    self.period_s = period_s\n    self.c = 2. * scipy.constants.pi / period_s\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"AmplitudeSine(units={}, base={}, amp={}, p={} s)\".\\\n        format(self.units, self.initial, self.amplitude, self.period_s)\n\n  def applyAmplitude(self, signal, userTimeAll_s, noiseParams):\n    '''\n    Applies amplitude modulation to signal.\n\n    Parameters\n    ----------\n    signal : numpy.ndarray\n      Signal sample vector. Each element defines signal amplitude in range\n      [-1; +1]. This vector is modified in place.\n    userTimeAll_s : numpy.ndarray\n      Sample time vector. Each element defines sample time in seconds.\n    noiseParams : NoiseParameters\n      Noise parameters to adjust signal amplitude level.\n\n    Returns\n    -------\n    numpy.ndarray\n      Array with output samples\n    '''\n\n    ampAll = numpy.sin(userTimeAll_s * self.c) * self.amplitude + self.initial\n\n    ampAll = AmplitudeBase.convertUnits2Amp(ampAll,\n                                            self.units,\n                                            noiseParams)\n    signal *= ampAll\n\n    return signal\n\n  def computeSNR(self, noiseParams):\n    '''\n    Computes signal to noise ratio in dB.\n\n    noiseParams : NoiseParameters\n      Noise parameter container\n\n    Returns\n    -------\n    float\n      SNR in dB\n    '''\n    value = self.initial\n    return AmplitudeBase.convertUnits2SNR(value, self.units, noiseParams)\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL2TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GLONASS L2 Civil signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L2 C band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL2TwoBitsEncoder, self).__init__(\n        outputConfig.GLONASS.L2.INDEX)\n", "answers": ["  assert isinstance(doppler, DopplerSine)"], "length": 6517, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "c78bbf3695db2bc16d0daf4cf8bfd6d1c7c13a32ff1383dd"}
{"input": "import android.Manifest;\nimport android.app.AlertDialog;\nimport android.app.ProgressDialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.widget.SwipeRefreshLayout;\nimport android.support.v7.view.ActionMode;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.Toolbar;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport com.daimajia.androidanimations.library.Techniques;\nimport com.daimajia.androidanimations.library.YoYo;\nimport com.nineoldandroids.animation.Animator;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport br.com.javace.javou.R;\nimport br.com.javace.javou.adapter.ParticipantAdapter;\nimport br.com.javace.javou.dao.ParticipantDao;\nimport br.com.javace.javou.interfaces.OnItemClickListener;\nimport br.com.javace.javou.interfaces.OnItemLongClickListener;\nimport br.com.javace.javou.interfaces.OnScrollListener;\nimport br.com.javace.javou.model.participant.Participant;\nimport br.com.javace.javou.model.raffle.Raffle;\nimport br.com.javace.javou.task.ParticipantDeleteTask;\nimport br.com.javace.javou.task.ParticipantPresenceTask;\nimport br.com.javace.javou.task.ParticipantSendTask;\nimport br.com.javace.javou.task.ParticipantTask;\nimport br.com.javace.javou.ui.activity.MainActivity;\nimport br.com.javace.javou.ui.activity.NewParticipantActivity;\nimport br.com.javace.javou.ui.activity.ParticipantDetailActivity;\nimport br.com.javace.javou.ui.activity.ParticipantFortunateActivity;\nimport br.com.javace.javou.ui.activity.RaffleActivity;\nimport br.com.javace.javou.ui.activity.ResumeActivity;\nimport br.com.javace.javou.ui.base.BaseActivity;\nimport br.com.javace.javou.ui.base.BaseFragment;\nimport br.com.javace.javou.util.Constant;\nimport br.liveo.searchliveo.SearchLiveo;\nimport br.liveo.searchliveo.interfaces.OnSearchListener;\nimport butterknife.BindView;\nimport butterknife.ButterKnife;\n        if (savedInstanceState == null){\n            loadParticipant();\n        }else{\n            isActionMode = savedInstanceState.getBoolean(Constant.ACTION_MODE);\n            mParticipants = savedInstanceState.getParcelableArrayList(Constant.PARTICIPANT);\n\n            if (getParticipants() != null){\n                resultAdapter(getParticipants());\n            }\n\n            if (isActionMode){\n                mPositionActionMode = savedInstanceState.getInt(Constant.POSITION);\n                showActionMode(mPositionActionMode);\n            }\n        }\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putBoolean(Constant.ACTION_MODE, isActionMode);\n        outState.putInt(Constant.POSITION, mPositionActionMode);\n        outState.putParcelableArrayList(Constant.PARTICIPANT, getParticipants());\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        // TODO Auto-generated method stub\n        super.onCreateOptionsMenu(menu, inflater);\n        inflater.inflate(R.menu.menu, menu);\n\n        menu.findItem(R.id.menu_discart).setVisible(false);\n        menu.findItem(R.id.menu_delete).setVisible(false);\n        isSearchView = false;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // TODO Auto-generated method stub\n        switch (item.getItemId()) {\n            case R.id.menu_search:\n                isSearchView = true;\n                mSearchLiveo.show();\n                break;\n            case R.id.menu_raffle:\n                raffleParticipant(true);\n                break;\n\n            case R.id.menu_woman:\n                raffleParticipant(false);\n                break;\n            case R.id.menu_send:\n                if (checkPermission()) {\n                    generateSendingFile();\n                }\n                break;\n            case R.id.menu_resume:\n                generateResume();\n                break;\n        }\n        return true;\n    }\n\n    private void generateResume() {\n        Intent intent = new Intent(getActivity(), ResumeActivity.class);\n        startActivityForResult(intent, 0, BaseActivity.ActivityAnimation.SLIDE_LEFT);\n    }\n\n    private void loadParticipant(){\n        mEndlessListener.resetEndlessRecyclerView();\n        new ParticipantTask(getActivity()){\n\n            @Override\n            protected void onPreExecute() {\n                super.onPreExecute();\n                mSwipeRefreshLayout.setRefreshing(true);\n            }\n\n            @Override\n            protected void onPostExecute(ArrayList<Participant> participants) {\n                super.onPostExecute(participants);\n\n                if (participants != null && participants.size() > 0){\n                    mParticipants = new ArrayList<>();\n                    mParticipants = participants;\n\n                    resultAdapter(mParticipants);\n                }\n\n                mSwipeRefreshLayout.setRefreshing(false);\n            }\n        }.execute();\n\n    }\n\n    private SwipeRefreshLayout.OnRefreshListener onRefresh = new SwipeRefreshLayout.OnRefreshListener() {\n        @Override\n        public void onRefresh() {\n            loadParticipant();\n        }\n    };\n\n    private void resultAdapter(ArrayList<Participant> participants){\n        mParticipantAdapter = new ParticipantAdapter(getActivity(), participants);\n        getParticipantAdapter().setOnClickListener(onClickListener);\n        getParticipantAdapter().setOnItemClickListener(onItemClickListener);\n        getParticipantAdapter().setOnItemLongClickListener(onItemLongClickListener);\n        mRecyclerView.setAdapter(getParticipantAdapter());\n    }\n\n    private void raffleParticipant(boolean isMan) {\n        if (mParticipants != null && mParticipants.size() > 0) {\n            Raffle raffle = new Raffle(mParticipants);\n\n            if (raffle.isValid() && isMan) {\n\n                Participant participant = raffle.getFortunate();\n                ParticipantDao participantDao = new ParticipantDao(getActivity());\n                participantDao.updateAsRaffled(participant);\n", "context": "app/src/main/java/br/com/javace/javou/ui/activity/MainActivity.java\npublic class MainActivity extends BaseActivity{\n\n    private ActionMode mAcitonMode;\n    private ParticipantFragment mParticipantFragment;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        setupInit(savedInstanceState);\n    }\n\n    private void setupInit(Bundle savedInstanceState){\n        //setupFragment(savedInstanceState);\n        Preference preference = new Preference(this);\n        if (preference.getString(Constant.FIRST_RUN) == null){\n            startActivityForResult(new Intent(this, SynchronizationActivity.class), 0);\n            preference.setString(Constant.FIRST_RUN, Constant.TAG);\n        }else{\n            setupFragment(savedInstanceState);\n        }\n    }\n\n    private void setupFragment(Bundle savedInstanceState){\n        if (savedInstanceState == null) {\n            mParticipantFragment = ParticipantFragment.newInstance();\n            getFragmentManager().beginTransaction().add(R.id.container, mParticipantFragment, Constant.PARTICIPANT).commit();\n        }else{\n            if (mParticipantFragment == null) {\n                mParticipantFragment = (ParticipantFragment) getFragmentManager().findFragmentByTag(Constant.PARTICIPANT);\n            }\n        }\n    }\n\n    public void showActionMode(String name){\n        mAcitonMode = startSupportActionMode(mParticipantFragment.actionModeCallback);\n        actionModeSetTitle(name);\n\n        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            getWindow().setStatusBarColor(ContextCompat.getColor(this, R.color.action_mode_primary_dark));\n        }\n    }\n\n    public void actionModeSetTitle(String name){\n        mAcitonMode.setTitle(name);\n    }\n\n    public void hideActionMode(){\n        if (mAcitonMode != null){\n            mAcitonMode.finish();\n            mAcitonMode = null;\n        }\n\n        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            getWindow().setStatusBarColor(ContextCompat.getColor(this, R.color.primary_dark));\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (mAcitonMode != null) {\n            hideActionMode();\n        }else{\n            super.onBackPressed();\n        }\n    }\n\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        switch (requestCode){\n            case 0:\n                mParticipantFragment = ParticipantFragment.newInstance();\n                getFragmentManager().beginTransaction().add(R.id.container, mParticipantFragment, Constant.PARTICIPANT).commit();\n                break;\n\n            default:\n                if (data != null) {\n                    if (requestCode == SearchLiveo.REQUEST_CODE_SPEECH_INPUT) {\n                        mParticipantFragment.onActivityResult(requestCode, resultCode, data);\n                    }\n                }\n                break;\n        }\n    }\n\n    @TargetApi(Build.VERSION_CODES.M)\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (mParticipantFragment != null){\n            mParticipantFragment.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        }\n    }\n}\napp/src/main/java/br/com/javace/javou/interfaces/OnItemLongClickListener.java\npublic interface OnItemLongClickListener {\n    void onItemLongClick(View v, int position);\n}\napp/src/main/java/br/com/javace/javou/ui/activity/ParticipantFortunateActivity.java\npublic class ParticipantFortunateActivity extends BaseActivity{\n\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.txt_name) TextView txtName;\n    @BindView(R.id.txt_email) TextView txtEmail;\n    @BindView(R.id.txt_phone) TextView txtPhone;\n    @BindView(R.id.img_photo) ImageView imgPhoto;\n    @BindView(R.id.layout_phone) LinearLayout mLayoutPhone;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_participant_fortunate);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitle(getString(R.string.participant_fortunate));\n        this.setSupportActionBar(mToolbar);\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n\n        Participant participant = getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n\n        if (participant != null) {\n            txtName.setText(participant.getName());\n            txtEmail.setText(participant.getEmail());\n\n            mLayoutPhone.setVisibility(View.GONE);\n            if (!TextUtils.isEmpty(participant.getPhone())){\n                txtPhone.setText(participant.getPhone());\n                mLayoutPhone.setVisibility(View.VISIBLE);\n            }\n\n            if (participant.getSex()) {\n                imgPhoto.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_suricate_girl));\n            }\n        }\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        finish(ActivityAnimation.SLIDE_RIGHT);\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/base/BaseFragment.java\npublic class BaseFragment extends Fragment {\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        getActivity().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n    }\n\n    public enum ActivityAnimation {\n        SLIDE_LEFT, SLIDE_RIGHT\n    }\n\n    public void startActivity(Intent intent, final BaseActivity.ActivityAnimation animation) {\n        startActivity(intent);\n        putAnimation(getActivity(), animation);\n    }\n\n    public void startActivityForResult(Intent intent, int requestCode, final BaseActivity.ActivityAnimation animation) {\n        startActivityForResult(intent, requestCode);\n        putAnimation(getActivity(), animation);\n    }\n\n\n    private static void putAnimation(final Activity source, final BaseActivity.ActivityAnimation animation) {\n        try {\n            Method method = Activity.class.getMethod(\"overridePendingTransition\", int.class, int.class);\n\n            int[] animations = getAnimation(animation);\n            method.invoke(source, animations[0], animations[1]);\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    private static int[] getAnimation(final BaseActivity.ActivityAnimation animation) {\n\n        int exitAnim;\n        int enterAnim;\n\n        switch (animation) {\n            case SLIDE_RIGHT:\n                enterAnim = R.anim.slide_right_enter;\n                exitAnim = R.anim.slide_right_exit;\n                break;\n\n            case SLIDE_LEFT:\n            default:\n                enterAnim = R.anim.slide_left_enter;\n                exitAnim = R.anim.slide_left_exit;\n                break;\n        }\n\n        return new int[]{enterAnim, exitAnim};\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/activity/ResumeActivity.java\npublic class ResumeActivity extends BaseActivity {\n\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.txt_shape_total_raffled) TextView mTxtShapeTotalReffled;\n    @BindView(R.id.txt_shape_total_attendence) TextView mTxtShapeTotalAttendence;\n    @BindView(R.id.txt_shape_total_registrations) TextView mTxtShapeTotalRegistrations;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_resume);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitle(getString(R.string.resume_event));\n        this.setSupportActionBar(mToolbar);\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        generateResume();\n    }\n\n    private void generateResume() {\n        ParticipantDao dao = new ParticipantDao(this);\n        Resume resume = dao.generateResume();\n        mTxtShapeTotalRegistrations.setText(String.format(Locale.getDefault(), \"%d\", resume.getTotalRegistrations()));\n        mTxtShapeTotalAttendence.setText(String.format(Locale.getDefault(), \"%d\", resume.getTotalAttendance()));\n        mTxtShapeTotalReffled.setText(String.format(Locale.getDefault(), \"%d\", resume.getTotalRaffled()));\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        finish(ActivityAnimation.SLIDE_RIGHT);\n        return super.onOptionsItemSelected(item);\n    }\n}\napp/src/main/java/br/com/javace/javou/dao/ParticipantDao.java\npublic class ParticipantDao {\n\n    private Context mContext;\n    private ClasseDB classeDB;\n    private SQLiteDatabase db = null;\n    private static ParticipantDao instance;\n\n    public ParticipantDao(Context context) {\n        super();\n        this.mContext = context;\n\n    }\n\n    public static ParticipantDao getInstance(Context context) {\n        if (instance == null) {\n            synchronized (ParticipantDao.class) {\n                if (instance == null) {\n                    instance = new ParticipantDao(context);\n                }\n            }\n        }\n        return instance;\n    }\n\n    private void openConnection() {\n\n        try {\n            this.classeDB = ClasseDB.getInstance(this.mContext);\n            db = classeDB.getWritableDatabase();\n        } catch (Exception e) {\n\n            Log.e(Constant.TAG, \"Erro ao abrir conex?es ParticipantDao\");\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            if (null != db) {\n                db.close();\n                db = null;\n                classeDB.close();\n            }\n\n        } catch (Exception e) {\n            Log.e(Constant.TAG, \"Erro ao fechar conex?es ParticipantDao\");\n        }\n    }\n\n    public void synchronizeParticipant(List<String[]> participants) {\n\n        if (participants != null) {\n            try {\n                openConnection();\n                for (String[] participant : participants) {\n                    try {\n\n                        if (!participant[0].equals(\"NOME\")) {\n\n                            ContentValues campos = new ContentValues();\n\n                            campos.put(Constant.PARTICIPANT_name, participant[0]);\n                            campos.put(Constant.PARTICIPANT_email, participant[1].toLowerCase());\n                            campos.put(Constant.PARTICIPANT_code, participant[5]);\n\n                            //campos.put(Constant.PARTICIPANT_phone, \"\");\n                            campos.put(Constant.PARTICIPANT_phone, Util.replacePhone(participant[13]));\n\n                            campos.put(Constant.PARTICIPANT_attend, 0);\n                            campos.put(Constant.PARTICIPANT_nameEvent, \"JAVOU! #09 - Casos de Sucesso\");\n\n                            String birthDate = participant[16];\n                            campos.put(Constant.PARTICIPANT_birthDate, birthDate);\n\n                            String company = WordUtils.capitalizeFully(participant[17].toLowerCase());\n                            campos.put(Constant.PARTICIPANT_company, company);\n\n                            campos.put(Constant.PARTICIPANT_sex, !participant[20].equals(\"Masculino\"));\n\n                            int shirtSize = 5;\n                            if (!participant[3].contains(\"SEM Blusa\")) {\n                                shirtSize = Util.replaceShirtSize(participant[21]);\n                            }\n                            campos.put(Constant.PARTICIPANT_shirtSize, shirtSize);\n\n                            try {\n                                Long row = db.insertOrThrow(Constant.TABLE_PARTICIPANT, Constant.DATABASE, campos);\n                                Log.d(\"ParticipantDao\", row.toString());\n                            } catch (Exception e) {\n                                e.getMessage();\n                                Log.e(Constant.TAG, \"insert: \" + mContext.getString(R.string.app_name));\n                            }\n                        }\n\n                    } catch (Exception e) {\n                        e.getStackTrace();\n                    }\n                }\n\n                closeConnection();\n            }catch (Exception e){\n                e.getStackTrace();\n            }\n        }\n    }\n\n    public boolean insert(Participant participant) {\n\n        if (participant != null) {\n\n            try {\n                openConnection();\n\n                ContentValues campos = new ContentValues();\n\n                campos.put(Constant.PARTICIPANT_name, participant.getName());\n                campos.put(Constant.PARTICIPANT_phone, participant.getPhone());\n                campos.put(Constant.PARTICIPANT_email, participant.getEmail());\n                campos.put(Constant.PARTICIPANT_photo, participant.getPhoto());\n                campos.put(Constant.PARTICIPANT_shirtSize, participant.getShirtSize());\n                campos.put(Constant.PARTICIPANT_attend, participant.isAttend() ? 1 : 0);\n                campos.put(Constant.PARTICIPANT_nameEvent, participant.getNameEvent());\n                campos.put(Constant.PARTICIPANT_birthDate, participant.getBirthDate());\n                campos.put(Constant.PARTICIPANT_sex, participant.isSex() ? 1 : 0);\n                campos.put(Constant.PARTICIPANT_company, participant.getCompany());\n\n                try {\n                    return ( db.insertOrThrow(Constant.TABLE_PARTICIPANT, Constant.DATABASE, campos) != -1);\n                } catch (Exception e) {\n                    e.getMessage();\n                    Log.e(Constant.TAG, \"insert: \" + mContext.getString(R.string.app_name));\n                }\n\n            } finally {\n                closeConnection();\n            }\n        }\n\n        return false;\n    }\n\n    public boolean update(Participant participant) {\n\n        try {\n            openConnection();\n\n            ContentValues campos = new ContentValues();\n\n            campos.put(Constant.PARTICIPANT_name, participant.getName());\n            campos.put(Constant.PARTICIPANT_phone, participant.getPhone());\n            campos.put(Constant.PARTICIPANT_email, participant.getEmail());\n            campos.put(Constant.PARTICIPANT_photo, participant.getPhoto());\n            campos.put(Constant.PARTICIPANT_shirtSize, participant.getShirtSize());\n            campos.put(Constant.PARTICIPANT_attend, participant.isAttend() ? 1 : 0);\n            campos.put(Constant.PARTICIPANT_nameEvent, participant.getNameEvent());\n            campos.put(Constant.PARTICIPANT_birthDate, participant.getBirthDate());\n            campos.put(Constant.PARTICIPANT_sex, participant.isSex() ? 1 : 0);\n            campos.put(Constant.PARTICIPANT_company, participant.getCompany());\n\n            String args[] = new String[]{String.valueOf(participant.getId())};\n            return (db.update(Constant.TABLE_PARTICIPANT, campos, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao update: \", e);\n            Log.e(Constant.TAG, \"update: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n    }\n\n    public boolean updatePresence(Participant participant) {\n\n        try {\n            openConnection();\n\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(Constant.PARTICIPANT_attend, participant.isAttend() ? 0 : 1);\n\n            String args[] = new String[]{String.valueOf(participant.getId())};\n            return (db.update(Constant.TABLE_PARTICIPANT, contentValues, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao updatePresence: \", e);\n            Log.e(Constant.TAG, \"updatePresence: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n    }\n\n    public boolean delete(int id) {\n\n        try {\n            openConnection();\n\n            String args[] = new String[]{String.valueOf(id)};\n            return (db.delete(Constant.TABLE_PARTICIPANT, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao delete: \", e);\n            Log.e(Constant.TAG, \"delete: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n    }\n\n    public ArrayList<Participant> getAll() {\n\n        Participant participant;\n        ArrayList<Participant> lParticipant = new ArrayList<>();\n\n        Cursor cursor;\n        try {\n\n            openConnection();\n            cursor = db.query(Constant.TABLE_PARTICIPANT, Constant.PARTICIPANT_COLS, null, null, null,\n                    null, Constant.PARTICIPANT_name + \" ASC\");\n\n            while (cursor.moveToNext()) {\n                participant = new Participant();\n\n                participant.setId(cursor.getInt(0));\n                participant.setName(cursor.getString(1));\n                participant.setPhone(cursor.getString(2));\n                participant.setEmail(cursor.getString(3));\n                participant.setPhoto(cursor.getString(4));\n\n                //identifying who will be the type of group\n                int shirtSize = cursor.getInt(5);\n                participant.setGroup(true);\n                participant.setShirtSize(shirtSize);\n\n                participant.setAttend(cursor.getInt(6) == 1);\n                participant.setNameEvent(cursor.getString(7));\n\n                participant.setBirthDate(cursor.getString(8));\n                participant.setSex(cursor.getInt(9) == 1);\n                participant.setRaffled(cursor.getInt(10) == 1);\n                participant.setCompany(cursor.getString(11));\n                participant.setCode(cursor.getInt(12));\n\n                lParticipant.add(participant);\n            }\n            cursor.close();\n            return lParticipant;\n        } catch (Exception e) {\n            Log.e(Constant.TAG, \"Erro ParticipantDao getAll: \", e);\n        } finally {\n            closeConnection();\n        }\n\n        return null;\n    }\n\n    public boolean updateAsRaffled(Participant participantFortunate) {\n\n        try {\n            openConnection();\n\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(Constant.PARTICIPANT_raffled, 1);\n\n            String args[] = new String[]{String.valueOf(participantFortunate.getId())};\n            return (db.update(Constant.TABLE_PARTICIPANT, contentValues, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao updateAsRaffled: \", e);\n            Log.e(Constant.TAG, \"updateAsRaffled: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n\n    }\n\n    public int getTotalRegistrations(){\n        openConnection();\n        Cursor mCount= db.rawQuery(\"select count(*) from \" + Constant.TABLE_PARTICIPANT, null);\n        mCount.moveToFirst();\n        int totalRegistrations= mCount.getInt(0);\n        mCount.close();\n        closeConnection();\n        return totalRegistrations;\n    }\n\n    public int getTotalAttendance(){\n        openConnection();\n        Cursor mCount= db.rawQuery(\"select count(*) from \" + Constant.TABLE_PARTICIPANT + \" WHERE attend=1\", null);\n        mCount.moveToFirst();\n        int totalAttendance= mCount.getInt(0);\n        mCount.close();\n        closeConnection();\n        return totalAttendance;\n    }\n\n    public int getTotalRaffled(){\n        openConnection();\n        Cursor mCount= db.rawQuery(\"select count(*) from \" + Constant.TABLE_PARTICIPANT + \" WHERE attend=1 and raffled=1\", null);\n        mCount.moveToFirst();\n        int totalRaffled= mCount.getInt(0);\n        mCount.close();\n        closeConnection();\n        return totalRaffled;\n    }\n\n    public Resume generateResume() {\n        Resume resume = new Resume();\n        resume.setTotalRegistrations(getTotalRegistrations());\n        resume.setTotalAttendance(getTotalAttendance());\n        resume.setTotalRaffled(getTotalRaffled());\n        return resume;\n    }\n\n}\napp/src/main/java/br/com/javace/javou/interfaces/OnScrollListener.java\npublic abstract class OnScrollListener extends RecyclerView.OnScrollListener {\n\n    private int currentPage = 1;\n    private int totalItemCount;\n    private int visibleItemCount;\n    private int firstVisibleItem;\n\n    private int lastVisibleItem = 0;\n    private boolean checkScroll = true;\n\n    private boolean loading = false;\n    private int currentTotalItems = 0;\n\n    private LinearLayoutManager mLinearLayoutManager;\n    private FloatingActionButton mFloatingActionButton;\n    public OnScrollListener(LinearLayoutManager linearLayoutManager, FloatingActionButton floatingActionButton) {\n        this.mLinearLayoutManager = linearLayoutManager;\n        this.mFloatingActionButton = floatingActionButton;\n    }\n\n    public OnScrollListener(LinearLayoutManager linearLayoutManager) {\n        this.mLinearLayoutManager = linearLayoutManager;\n    }\n\n    @Override\n    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n        super.onScrolled(recyclerView, dx, dy);\n\n        visibleItemCount = recyclerView.getChildCount();\n        totalItemCount = mLinearLayoutManager.getItemCount();\n        firstVisibleItem = mLinearLayoutManager.findFirstVisibleItemPosition();\n\n        if (totalItemCount < currentTotalItems) {\n            this.currentPage = 1;\n            this.currentTotalItems = totalItemCount;\n\n            if (totalItemCount == 0) {\n                this.loading = true;\n            }\n        }\n\n        if (loading && (totalItemCount > currentTotalItems)) {\n            loading = false;\n            currentTotalItems = totalItemCount;\n        }\n\n        if (!loading && (totalItemCount - visibleItemCount)<=(firstVisibleItem + 5)) {\n            onLoadMore(currentPage++);\n            loading = true;\n        }\n\n        if (lastVisibleItem != firstVisibleItem) {\n            if (lastVisibleItem < firstVisibleItem) {\n                if (checkScroll) {\n                    checkScroll = false;\n                    showHideFloatButton(true);\n                    onScroll(recyclerView, dx, dy, true);\n                }\n            } else {\n                if (!checkScroll) {\n                    checkScroll = true;\n                    showHideFloatButton(false);\n                    onScroll(recyclerView, dx, dy, false);\n                }\n            }\n        }\n\n        lastVisibleItem = firstVisibleItem;\n    }\n\n    public void resetEndlessRecyclerView(){\n        this.currentTotalItems = 0;\n        this.loading = false;\n    }\n\n    public abstract void onScroll(RecyclerView recyclerView, int dx, int dy, boolean onScroll);\n    public abstract void onLoadMore(int currentPage);\n\n    //Hide or show the FloatingActionButton based on the list scroll\n    private void showHideFloatButton(boolean status) {\n        if (status) {\n            mFloatingActionButton.setAlpha(1f);\n            mFloatingActionButton.setTranslationY(0f);\n            mFloatingActionButton.animate().alpha(0f)\n                    .translationY(mFloatingActionButton.getHeight())\n                    .setDuration(175L)\n                    .setListener(new AnimatorListenerAdapter() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            mFloatingActionButton.setVisibility(FrameLayout.GONE);\n                        }\n                    }).start();\n        } else {\n            mFloatingActionButton.setVisibility(View.VISIBLE);\n            mFloatingActionButton.setAlpha(0f);\n            mFloatingActionButton.setTranslationY(mFloatingActionButton.getHeight());\n            mFloatingActionButton.animate()\n                    .alpha(1f)\n                    .translationY(0f)\n                    .setDuration(175L)\n                    .setListener(new AnimatorListenerAdapter() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            mFloatingActionButton.setVisibility(FrameLayout.VISIBLE);\n                        }\n                    })\n                    .start();\n        }\n    }\n}\napp/src/main/java/br/com/javace/javou/interfaces/OnItemClickListener.java\npublic interface OnItemClickListener {\n    void onItemClick(View v, int position);\n}\napp/src/main/java/br/com/javace/javou/model/participant/Participant.java\npublic class Participant implements Parcelable {\n\n    private int id;\n    private int code;\n    private boolean sex;\n    private String name;\n    private String phone;\n    private String email;\n    private String photo;\n    private int shirtSize;\n    private boolean group;\n    private boolean attend;\n    private String company;\n    private String nameEvent;\n    private String birthDate;\n    private boolean raffled;\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeInt(this.getId());\n        dest.writeInt(this.getCode());\n        dest.writeByte(isSex() ? (byte) 1 : (byte) 0);\n        dest.writeString(this.getName());\n        dest.writeString(this.getPhone());\n        dest.writeString(this.getEmail());\n        dest.writeString(this.getPhoto());\n        dest.writeInt(this.getShirtSize());\n        dest.writeByte(isGroup() ? (byte) 1 : (byte) 0);\n        dest.writeByte(isAttend() ? (byte) 1 : (byte) 0);\n        dest.writeString(this.getCompany());\n        dest.writeString(this.getNameEvent());\n        dest.writeString(this.getBirthDate());\n        dest.writeByte(isRaffled() ? (byte) 1 : (byte) 0);\n    }\n\n    public Participant() {\n    }\n\n    protected Participant(Parcel in) {\n        this.setId(in.readInt());\n        this.setCode(in.readInt());\n        this.setSex(in.readByte() != 0);\n        this.setName(in.readString());\n        this.setPhone(in.readString());\n        this.setEmail(in.readString());\n        this.setPhoto(in.readString());\n        this.setShirtSize(in.readInt());\n        this.setGroup(in.readByte() != 0);\n        this.setAttend(in.readByte() != 0);\n        this.setCompany(in.readString());\n        this.setNameEvent(in.readString());\n        this.setBirthDate(in.readString());\n        this.setRaffled(in.readByte() != 0);\n    }\n\n    public static final Parcelable.Creator<Participant> CREATOR = new Parcelable.Creator<Participant>() {\n        public Participant createFromParcel(Parcel source) {\n            return new Participant(source);\n        }\n\n        public Participant[] newArray(int size) {\n            return new Participant[size];\n        }\n    };\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public void setCode(int code) {\n        this.code = code;\n    }\n\n    public boolean isSex() {\n        return sex;\n    }\n\n    public void setSex(boolean sex) {\n        this.sex = sex;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getPhoto() {\n        return photo;\n    }\n\n    public void setPhoto(String photo) {\n        this.photo = photo;\n    }\n\n    public int getShirtSize() {\n        return shirtSize;\n    }\n\n    public void setShirtSize(int shirtSize) {\n        this.shirtSize = shirtSize;\n    }\n\n    public boolean isGroup() {\n        return group;\n    }\n\n    public void setGroup(boolean group) {\n        this.group = group;\n    }\n\n    public boolean isAttend() {\n        return attend;\n    }\n\n    public void setAttend(boolean attend) {\n        this.attend = attend;\n    }\n\n    public String getCompany() {\n        return company;\n    }\n\n    public void setCompany(String company) {\n        this.company = company;\n    }\n\n    public String getNameEvent() {\n        return nameEvent;\n    }\n\n    public void setNameEvent(String nameEvent) {\n        this.nameEvent = nameEvent;\n    }\n\n    public String getBirthDate() {\n        return birthDate;\n    }\n\n    public void setBirthDate(String birthDate) {\n        this.birthDate = birthDate;\n    }\n\n    public boolean isRaffled() {\n        return raffled;\n    }\n\n    public void setRaffled(boolean raffled) {\n        this.raffled = raffled;\n    }\n\n    public boolean getSex() {\n        return sex;\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantSendTask.java\npublic class ParticipantSendTask extends AsyncTask<Void, Void, Boolean> {\n\n    private ArrayList<Participant> mParticipant;\n\n    protected ParticipantSendTask(ArrayList<Participant> participant){\n        this.mParticipant = participant;\n    }\n\n    @Override\n    protected Boolean doInBackground(Void... params) {\n\n        CSVWriter writer;\n        boolean isAttend = false;\n\n        try {\n            writer = new CSVWriter(new FileWriter(Constant.PATH_FILE_JAVOU));\n            List<String[]> data = new ArrayList<>();\n\n            data.add(Constant.FILE_COLS);\n\n            for (Participant participant : mParticipant) {\n                if (participant.isAttend()) {\n                    isAttend = true;\n                    String sex = (participant.isSex() ? \"F\" : \"M\");\n                    data.add(new String[]{String.valueOf(participant.getCode()), participant.getName(), participant.getEmail(), participant.getPhone(), sex, participant.getCompany()});\n                }\n            }\n\n            writer.writeAll(data);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return isAttend;\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantDeleteTask.java\npublic class ParticipantDeleteTask extends AsyncTask<Void, Void, Boolean> {\n\n    private int mId;\n    private Context mContext;\n    public ParticipantDeleteTask(Context context, int id){\n        this.mId = id;\n        this.mContext = context;\n    }\n\n    @Override\n    protected Boolean doInBackground(Void... params) {\n        ParticipantDao participantDao = ParticipantDao.getInstance(mContext);\n        return participantDao.delete(mId);\n    }\n}\napp/src/main/java/br/com/javace/javou/util/Constant.java\npublic class Constant {\n    public static String TAG = \"Javou\";\n    public static final String NAME_EVENT = \"Setic - AppJavou\";\n\n    public static final int DATABASE_VERSION = 1;\n    public static final String DATABASE = \"javou.db\";\n    private static final String NAME_FILE = \"/javou.csv\";\n\n    public static String POSITION = \"POSITION\";\n    public static String FIRST_RUN = \"FIRST_RUN\";\n    static String PREFERENCES_APP = \"JAVOU\";\n    public static String ACTION_MODE = \"ACTION_MODE\";\n    public static String PARTICIPANT = \"Participant\";\n\n    public static String INSERT = \"INSERT\";\n\n    //Tablet participant\n    public static final String TABLE_PARTICIPANT = \"participant\";\n    private static final String PARTICIPANT_id = \"id\";\n    public static final String PARTICIPANT_name = \"name\";\n    public static final String PARTICIPANT_phone = \"phone\";\n    public static final String PARTICIPANT_email = \"email\";\n    public static final String PARTICIPANT_photo = \"photo\";\n    public static final String PARTICIPANT_shirtSize = \"shirtSize\";\n    public static final String PARTICIPANT_attend = \"attend\";\n    public static final String PARTICIPANT_nameEvent = \"nameEvent\";\n    public static final String PARTICIPANT_birthDate = \"birthDate\";\n    public static final String PARTICIPANT_sex = \"sex\";\n    public static final String PARTICIPANT_raffled = \"raffled\";\n    public static final String PARTICIPANT_company = \"company\";\n    public static final String PARTICIPANT_code = \"code\";\n\n    public static String[] CREATE_TABLE() {\n        String CREATE_PARTICIPANT = \" CREATE TABLE participant ( \"\n                + \" id INTEGER CONSTRAINT 'PK_PARTICIPANT' PRIMARY KEY AUTOINCREMENT, \"\n                + \" code INT NULL DEFAULT 0, \"\n                + \" name VARCHAR(100) NOT NULL, \"\n                + \" phone VARCHAR(100) NOT NULL, \"\n                + \" email VARCHAR(250) NULL, \"\n                + \" photo TEXT NULL, \"\n                + \" shirtSize INT NULL DEFAULT 0, \"\n                + \" attend INT NULL DEFAULT 0, \"\n                + \" nameEvent VARCHAR(100) NULL, \"\n                + \" birthDate VARCHAR(10) NULL, \"\n                + \" sex CHAR(1) NULL, \"\n                + \" raffled INT NULL DEFAULT 0, \"\n                + \" company VARCHAR(250) NULL ); \";\n        return new String[] {CREATE_PARTICIPANT};\n    }\n\n    public static final String PATH_FILE_JAVOU = android.os.Environment.getExternalStorageDirectory().getAbsolutePath() + NAME_FILE;\n\n    public static final String PARTICIPANT_COLS[] = {\n            PARTICIPANT_id,\n            PARTICIPANT_name,\n            PARTICIPANT_phone,\n            PARTICIPANT_email,\n            PARTICIPANT_photo,\n            PARTICIPANT_shirtSize,\n            PARTICIPANT_attend,\n            PARTICIPANT_nameEvent,\n            PARTICIPANT_birthDate,\n            PARTICIPANT_sex,\n            PARTICIPANT_raffled,\n            PARTICIPANT_company,\n            PARTICIPANT_code\n    };\n\n    public static final String FILE_COLS[] = {\n            \"CODIGO\", \"NOME\", \"EMAIL\", \"CELULAR\", \"SEXO\", \"EMPRESA\"\n    };\n\n}\napp/src/main/java/br/com/javace/javou/ui/base/BaseActivity.java\npublic class BaseActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n    }\n\n    public enum ActivityAnimation {\n        SLIDE_LEFT, SLIDE_RIGHT\n    }\n\n    public void startActivity(Intent intent, final ActivityAnimation animation) {\n        startActivity(intent);\n        putAnimation(this, animation);\n    }\n\n    public void startActivityForResult(Intent intent, int requestCode, final ActivityAnimation animation) {\n        startActivityForResult(intent, requestCode);\n        putAnimation(this, animation);\n    }\n\n    public void finish(final ActivityAnimation animation) {\n        finish();\n        putAnimation(this, animation);\n    }\n\n    private static void putAnimation(final Activity source,\n                                     final ActivityAnimation animation) {\n        try {\n            Method method = Activity.class.getMethod(\"overridePendingTransition\", int.class, int.class);\n\n            int[] animations = getAnimation(animation);\n            method.invoke(source, animations[0], animations[1]);\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    private static int[] getAnimation(final ActivityAnimation animation) {\n        int exitAnim;\n        int enterAnim;\n\n        switch (animation) {\n            case SLIDE_RIGHT:\n                enterAnim = R.anim.slide_right_enter;\n                exitAnim = R.anim.slide_right_exit;\n                break;\n\n            case SLIDE_LEFT:\n            default:\n                enterAnim = R.anim.slide_left_enter;\n                exitAnim = R.anim.slide_left_exit;\n                break;\n        }\n\n        return new int[]{enterAnim, exitAnim};\n    }\n}\nsearchliveo/src/main/java/br/liveo/searchliveo/interfaces/OnSearchListener.java\npublic interface OnSearchListener {\n    void changedSearch(CharSequence text);\n}\napp/src/main/java/br/com/javace/javou/ui/activity/ParticipantDetailActivity.java\npublic class ParticipantDetailActivity extends BaseActivity {\n\n    private ProgressDialog mDialog;\n    private Participant mParticipant;\n\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.txt_email) TextView mTxtEmail;\n    @BindView(R.id.txt_phone) TextView mTxtPhone;\n    @BindView(R.id.txt_attend) TextView mTxtAttend;\n    @BindView(R.id.img_photo) ImageView mImgPhoto;\n    @BindView(R.id.txt_shirt_size) TextView mTxtShirtSize;\n    @BindView(R.id.float_edit) FloatingActionButton mFloatEdit;\n    @BindView(R.id.collapsing_toolbar) CollapsingToolbarLayout mCollapsingToolbar;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_participant_detail);\n\n        ButterKnife.bind(this);\n        this.setSupportActionBar(mToolbar);\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n\n        mFloatEdit.setOnClickListener(onClickEdit);\n        mParticipant = getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n        mCollapsingToolbar.setTitle(mParticipant != null ? mParticipant.getName() : getString(R.string.app_name));\n\n        if (mParticipant != null){\n            mTxtEmail.setText(mParticipant.getEmail());\n            mTxtPhone.setText(mParticipant.getPhone());\n\n            GradientDrawable gradientDrawable = (GradientDrawable) mTxtShirtSize.getBackground();\n            gradientDrawable.setColor(ContextCompat.getColor(this, Util.shirtSizeColor[mParticipant.getShirtSize()]));\n            mTxtShirtSize.setText(getString(Util.shirtSize[mParticipant.getShirtSize()]));\n\n            if (mParticipant.isAttend()) {\n                mTxtAttend.setText(getString(R.string.attended_event));\n                mTxtAttend.setCompoundDrawablesWithIntrinsicBounds(R.drawable.ic_check_green_18dp, 0, 0, 0);\n            }\n\n            if (mParticipant.getPhoto() != null && !mParticipant.getPhoto().equals(\"\")) {\n                Glide.with(this).load(mParticipant.getPhoto()).centerCrop().into(mImgPhoto);\n            }else{\n                Glide.with(this).load(R.drawable.ic_suricate).centerCrop().into(mImgPhoto);\n            }\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.menu, menu);\n        menu.findItem(R.id.menu_send).setVisible(false);\n        menu.findItem(R.id.menu_search).setVisible(false);\n        menu.findItem(R.id.menu_raffle).setVisible(false);\n        menu.findItem(R.id.menu_discart).setVisible(false);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                finish(ActivityAnimation.SLIDE_RIGHT);\n                break;\n\n            case R.id.menu_delete:\n                confirmDelete();\n                break;\n        }\n        return true;\n    }\n\n    private View.OnClickListener onClickEdit  = new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            Intent intent = new Intent(getApplicationContext(), NewParticipantActivity.class);\n            intent.putExtra(Constant.PARTICIPANT, mParticipant);\n            startActivityForResult(intent, 1, BaseActivity.ActivityAnimation.SLIDE_LEFT);\n        }\n    };\n\n\n//    private void deleteParticipant(){\n//        showDialog();\n//        ParseObject gameScore = new ParseObject(Constant.PARTICIPANT);\n//        gameScore.setObjectId(mParticipant.getObjectId());\n//        gameScore.deleteInBackground(new DeleteCallback() {\n//            @Override\n//            public void done(ParseException error) {\n//                if (error == null) {\n//                    Intent intent = new Intent();\n//                    intent.putExtra(Constant.PARTICIPANT, true);\n//                    setResult(0, intent);\n//                    finish();\n//                    Toast.makeText(getApplicationContext(), R.string.warning_delete_participante, Toast.LENGTH_SHORT).show();\n//                } else {\n//                    Toast.makeText(getApplicationContext(), R.string.error_delete_participante, Toast.LENGTH_SHORT).show();\n//                }\n//\n//                hideDialog();\n//            }\n//        });\n//    }\n\n    private void showDialog() {\n        mDialog = ProgressDialog.show(this, getString(R.string.wait),\n                getString(R.string.warning_delete_wait_participante));\n    }\n\n    private void hideDialog(){\n        if (mDialog != null){\n            mDialog.dismiss();\n        }\n    }\n\n    private void confirmDelete(){\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\n        builder.setMessage(getString(R.string.warning_participant_excluded));\n        builder.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                //TODO\n                //deleteParticipant();\n                dialog.dismiss();\n            }\n        });\n        builder.setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                //TODO\n                dialog.dismiss();\n            }\n        });\n        AlertDialog dialog = builder.create();\n        dialog.show();\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n}\napp/src/main/java/br/com/javace/javou/model/raffle/Raffle.java\npublic class Raffle{\n\n    private Random randomGenerator;\n    private ArrayList<Participant> participants;\n\n    public Raffle(ArrayList<Participant> participants) {\n        this.randomGenerator = new Random();\n        this.participants = participants;\n    }\n\n    private List<Participant> getParticipantsAttend(){\n        List<Participant> attendees = new ArrayList<>();\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled()) //It can be drawn\n                attendees.add(participant);\n        }\n        return attendees;\n    }\n\n    private List<Participant> getParticipantsAttendSex(){\n        List<Participant> attendees = new ArrayList<>();\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled() && participant.getSex()) //It can be drawn\n                attendees.add(participant);\n        }\n        return attendees;\n    }\n\n    public boolean isValid(){\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled())\n                return true;\n        }\n        return false;\n    }\n\n    public boolean isValidSex(){\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled() && participant.getSex())\n                return true;\n        }\n        return false;\n    }\n\n    public Participant getFortunate() {\n        List<Participant> participantsAttend = getParticipantsAttend();\n\n        if(participantsAttend.isEmpty()) {\n            return null;\n        }\n\n        int index = randomGenerator.nextInt(participantsAttend.size());\n        Participant participantFortunate = participantsAttend.get(index);\n        participantFortunate.setRaffled(true);\n        return participantFortunate;\n    }\n\n    public Participant getFortunateSex() {\n        List<Participant> participantsAttend = getParticipantsAttendSex();\n\n        if(participantsAttend.isEmpty()) {\n            return null;\n        }\n\n        int index = randomGenerator.nextInt(participantsAttend.size());\n        Participant participantFortunate = participantsAttend.get(index);\n        participantFortunate.setRaffled(true);\n        return participantFortunate;\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantPresenceTask.java\npublic class ParticipantPresenceTask extends AsyncTask<Void, Void, Boolean> {\n\n    private Context mContext;\n    private Participant mParticipant;\n\n    public ParticipantPresenceTask(Context context, Participant participant){\n        this.mContext = context;\n        this.mParticipant = participant;\n    }\n\n    @Override\n    protected Boolean doInBackground(Void... params) {\n        ParticipantDao participantDao = ParticipantDao.getInstance(mContext);\n        return participantDao.updatePresence(mParticipant);\n    }\n}\nsearchliveo/src/main/java/br/liveo/searchliveo/SearchLiveo.java\npublic class SearchLiveo extends FrameLayout {\n\n    private Activity mContext;\n\n    private EditText mEdtSearch;\n\n    private ImageView mImgArrowSearch;\n    private ImageView mImgVoiceSearch;\n    private ImageView mImgCloseSearch;\n\n    private RecyclerView mRecyclerView;\n    private RelativeLayout mViewSearch;\n\n    private int mColorPrimaryDark;\n\n    private boolean active = false;\n    private boolean isVoice = true;\n\n    private int mColorIcon = -1;\n    private int mColorIconArrow = -1;\n    private int mColorIconVoice = -1;\n    private int mColorIconClose = -1;\n\n    private int mStatusBarHideColor = -1;\n    private int mStatusBarShowColor = -1;\n    private OnSearchListener mSearchListener;\n\n    private static String SEARCH_TEXT = \"SEARCH_TEXT\";\n    public static int REQUEST_CODE_SPEECH_INPUT = 7777;\n    private static String STATE_TO_SAVE = \"STATE_TO_SAVE\";\n    private static String INSTANCE_STATE = \"INSTANCE_STATE\";\n\n    /**\n     * Start context and the listener Search Live library.\n     * Use this method when you are using an Activity\n     *\n     * @param context - Context Activity\n     */\n    public SearchLiveo with(Context context) {\n\n        if (this.mContext == null) {\n            try {\n                this.mContext = (Activity) context;\n                this.mSearchListener = (OnSearchListener) context;\n            } catch (ClassCastException e) {\n                throw new ClassCastException(mContext.getString(R.string.warning_listener));\n            }\n        }else{\n            build();\n        }\n\n        return this;\n    }\n\n    /**\n     * Start context and the listener Search Live library.\n     * Use this method when you are using an Fragment\n     *\n     * @param getActivity - Context Fragment\n     * @param context - Listener\n     */\n    public SearchLiveo with(Activity getActivity, OnSearchListener context) {\n\n        if (this.mContext == null) {\n            try {\n                this.mContext = getActivity;\n                this.mSearchListener = context;\n            } catch (ClassCastException e) {\n                throw new ClassCastException(mContext.getString(R.string.warning_fragment_listener));\n            }\n        }else{\n            build();\n        }\n\n        return this;\n    }\n\n    public void build(){\n\n        if (this.mSearchListener == null){\n            throw new ClassCastException(mContext.getString(R.string.warning_listener));\n        }\n\n        try {\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                Resources.Theme theme = this.mContext.getTheme();\n                TypedArray typedArray = theme.obtainStyledAttributes(new int[]{android.R.attr.colorPrimaryDark});\n                setColorPrimaryDark(typedArray.getResourceId(0, 0));\n            }\n        }catch (Exception e){\n            e.getStackTrace();\n        }\n    }\n\n    public SearchLiveo(Context context) {\n        this(context, null);\n    }\n\n    public SearchLiveo(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public SearchLiveo(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        if(!isInEditMode()) {\n            init(context);\n            initAttribute(context, attrs, defStyleAttr);\n        }\n    }\n\n    private void init(Context context){\n        View view = LayoutInflater.from(context).inflate(R.layout.search_liveo, this, true);\n\n        mEdtSearch = (EditText) view.findViewById(R.id.edt_search);\n\n        mImgArrowSearch = (ImageView) view.findViewById(R.id.img_arrow_search);\n        mImgVoiceSearch = (ImageView) view.findViewById(R.id.img_voice_search);\n\n        mImgCloseSearch = (ImageView) view.findViewById(R.id.img_close_search);\n        mImgCloseSearch.setVisibility(isVoice() ? View.GONE : View.VISIBLE);\n\n        mRecyclerView = (RecyclerView) view.findViewById(R.id.recycler_search_view);\n\n        View toolbarShadow = view.findViewById(R.id.toolbar_shadow);\n        toolbarShadow.setVisibility(GONE);\n\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {\n            toolbarShadow.setVisibility(View.VISIBLE);\n        }\n\n        mViewSearch = (RelativeLayout) view.findViewById(R.id.view_search);\n        mViewSearch.setVisibility(View.INVISIBLE);\n\n        mEdtSearch.setOnKeyListener(onKeyListener);\n\n        mImgArrowSearch.setOnClickListener(onClickSearchArrow);\n        mRecyclerView.setOnClickListener(onClickRecyclerView);\n        mImgVoiceSearch.setOnClickListener(onClickVoiceSearch);\n        mImgCloseSearch.setOnClickListener(onClickCloseSearch);\n\n        mEdtSearch.setOnEditorActionListener(onEditorActionListener);\n        mEdtSearch.addTextChangedListener(new OnTextWatcherEdtSearch());\n    }\n\n    private void initAttribute(Context context, AttributeSet attributeSet, int defStyleAttr) {\n        TypedArray attr = context.obtainStyledAttributes(attributeSet, R.styleable.search_liveo, defStyleAttr, 0);\n        if (attr != null) {\n            try {\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_hint)) {\n                    hint(attr.getString(R.styleable.search_liveo_search_liveo_hint));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_text_color)) {\n                    mEdtSearch.setTextColor(attr.getColor(R.styleable.search_liveo_search_liveo_text_color, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_hint_color)) {\n                    mEdtSearch.setHintTextColor(attr.getColor(R.styleable.search_liveo_search_liveo_hint_color, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_icon)) {\n                    setColorIcon(attr.getColor(R.styleable.search_liveo_search_liveo_color_icon, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_arrow)) {\n                    setColorIconArrow(attr.getColor(R.styleable.search_liveo_search_liveo_color_arrow, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_voice)) {\n                    setColorIconVoice(attr.getColor(R.styleable.search_liveo_search_liveo_color_voice, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_close)) {\n                    setColorIconClose(attr.getColor(R.styleable.search_liveo_search_liveo_color_close, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_background)) {\n                    mViewSearch.setBackgroundColor(attr.getColor(R.styleable.search_liveo_search_liveo_background, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_status_bar_show_color)) {\n                    setStatusBarShowColor(attr.getColor(R.styleable.search_liveo_search_liveo_status_bar_show_color, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_status_bar_hide_color)) {\n                    setStatusBarHideColor(attr.getColor(R.styleable.search_liveo_search_liveo_status_bar_hide_color, -1));\n                }\n            } finally {\n                attr.recycle();\n            }\n        }\n    }\n\n    /**\n     * Set a new background color. If you do not use this method and standard color is white SearchLiveo.\n     * In his layout.xml you can use the \"app:searchLiveoBackground=\"@color/...\"\" attribute\n     *\n     * @param resId color attribute - colors.xml file\n     */\n    public SearchLiveo backgroundResource(int resId){\n        mViewSearch.setBackgroundResource(resId);\n        return this;\n    }\n\n    /**\n     * Set a new background color. If you do not use this method and standard color is white SearchLiveo.\n     * In his layout.xml you can use the \"app:searchLiveoBackground=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo backgroundColor(int color){\n        mViewSearch.setBackgroundColor(ContextCompat.getColor(mContext, color));\n        return this;\n    }\n\n    /**\n     * Set a new text color.\n     * In his layout.xml you can use the \"app:searchLiveoTextColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo textColor(int color){\n        mEdtSearch.setTextColor(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new hint color.\n     * In his layout.xml you can use the \"app:searchLiveoHintColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo hintColor(int color){\n        mEdtSearch.setHintTextColor(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new text.\n     * @param text \"valeu\"\n     */\n    public SearchLiveo text(String text){\n        mEdtSearch.setText(text);\n        return this;\n    };\n\n    /**\n     * Set a new hint.\n     * In his layout.xml you can use the \"app:searchLiveoHint=\"value\"\" attribute\n     * @param text \"valeu\"\n     */\n    public SearchLiveo hint(String text){\n        mEdtSearch.setHint(text);\n        return this;\n    };\n\n    /**\n     * Set a new text.\n     * @param text string attribute - string.xml file\n     */\n    public SearchLiveo text(int text){\n        mEdtSearch.setText(mContext.getString(text));\n        return this;\n    };\n\n    /**\n     * Set a new hint.\n     * In his layout.xml you can use the \"app:searchLiveoHint=\"@string/...\"\" attribute\n     * @param text string attribute - string.xml file\n     */\n    public SearchLiveo hint(int text){\n        mEdtSearch.setHint(mContext.getString(text));\n        return this;\n    };\n\n    /**\n     * Set a new color for all icons (arrow, voice and close).\n     * In his layout.xml you can use the \"app:searchLiveoColorIcon=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIcon(int color){\n        this.setColorIcon(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for back arrow\n     * In his layout.xml you can use the \"app:searchLiveoColorArrow=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIconArrow(int color){\n        this.setColorIconArrow(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for voice\n     * In his layout.xml you can use the \"app:searchLiveoColorVoice=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIconVoice(int color){\n        this.setColorIconVoice(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for close\n     * In his layout.xml you can use the \"app:searchLiveoColorClose=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIconClose(int color){\n        this.setColorIconClose(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for statusBar when the SearchLiveo is closed\n     * In his layout.xml you can use the \"app:searchLiveoStatusBarHideColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo statusBarHideColor(int color){\n        setStatusBarHideColor(ContextCompat.getColor(mContext, color));\n        return this;\n    }\n\n    /**\n     * Set a new color for statusBar when the SearchLiveo for visible\n     * In his layout.xml you can use the \"app:searchLiveoStatusBarShowColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo statusBarShowColor(int color){\n        setStatusBarShowColor(ContextCompat.getColor(mContext, color));\n        return this;\n    }\n\n    /**\n     * Hide voice icon\n     */\n    public SearchLiveo hideVoice(){\n        setIsVoice(false);\n        mImgVoiceSearch.setVisibility(View.GONE);\n        return this;\n    }\n\n    /**\n     * Show voice icon\n     */\n    public SearchLiveo showVoice(){\n        setIsVoice(true);\n        mImgVoiceSearch.setVisibility(View.VISIBLE);\n        return this;\n    }\n\n    private void colorIcon(){\n        if (getColorIcon() != -1 && getColorIconArrow() == -1)  {\n            mImgArrowSearch.setColorFilter(this.getColorIcon());\n        }\n\n        if (getColorIcon() != -1 && getColorIconVoice() == -1)  {\n            mImgVoiceSearch.setColorFilter(this.getColorIcon());\n        }\n\n        if (getColorIcon() != -1 && getColorIconClose() == -1)  {\n            mImgCloseSearch.setColorFilter(this.getColorIcon());\n        }\n    };\n\n    private void colorIconArrow(){\n        if (getColorIconArrow() != -1) {\n            mImgArrowSearch.setColorFilter(this.getColorIconArrow());\n        }\n    };\n\n    private void colorIconVoice(){\n        if (this.getColorIconVoice() != -1) {\n            mImgVoiceSearch.setColorFilter(this.getColorIconVoice());\n        }else{\n            mImgVoiceSearch.clearColorFilter();\n        }\n    };\n\n    private void colorIconClose(){\n        if (this.getColorIconClose() != -1) {\n            mImgCloseSearch.setColorFilter(this.getColorIconClose());\n        }else{\n            mImgCloseSearch.clearColorFilter();\n        }\n    };\n\n    private OnKeyListener onKeyListener = new OnKeyListener() {\n        @Override\n        public boolean onKey(View v, int keyCode, KeyEvent event) {\n            if (event.getAction() == KeyEvent.ACTION_DOWN) {\n                if (keyCode == KeyEvent.KEYCODE_BACK) {\n                    hide();\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    private TextView.OnEditorActionListener onEditorActionListener = new TextView.OnEditorActionListener() {\n        @Override\n        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n            if (actionId == EditorInfo.IME_ACTION_SEARCH) {\n                hide();\n                mContext.runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                hideSoftInputFromWindow(mRecyclerView.getWindowToken(), 0);\n                    }\n                });\n                return true;\n            }\n            return false;\n        }\n    };\n\n    private OnClickListener onClickVoiceSearch = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            startVoice(mEdtSearch);\n        }\n    };\n\n    private OnClickListener onClickCloseSearch = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            if (mEdtSearch.getText().toString().length() != 0) {\n                mEdtSearch.setText(\"\");\n                mContext.runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                    }\n                });\n            }\n        }\n    };\n\n    private OnClickListener onClickSearchArrow = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            hide();\n        }\n    };\n\n    private OnClickListener onClickRecyclerView = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            hide();\n        }\n    };\n\n    /**\n     * If SearchView is active(show), this method returns the value true\n     */\n    public boolean isActive() {\n        return active;\n    }\n\n    private void setActive(boolean active) {\n        this.active = active;\n    }\n\n    public boolean isVoice() {\n        return isVoice;\n    }\n\n    public void setIsVoice(boolean isVoice) {\n        this.isVoice = isVoice;\n    }\n\n    public int getStatusBarHideColor() {\n        return mStatusBarHideColor;\n    }\n\n    public void setStatusBarHideColor(int mStatusBarHideColor) {\n        this.mStatusBarHideColor = mStatusBarHideColor;\n    }\n\n    public int getStatusBarShowColor() {\n        return mStatusBarShowColor;\n    }\n\n    public void setStatusBarShowColor(int mStatusBarShowColor) {\n        this.mStatusBarShowColor = mStatusBarShowColor;\n    }\n\n    private int getColorIcon() {\n        return mColorIcon;\n    }\n\n    private void setColorIcon(int colorIcon) {\n        this.mColorIcon = colorIcon;\n        this.colorIcon();\n    }\n\n    public int getColorIconArrow() {\n        return mColorIconArrow;\n    }\n\n    public void setColorIconArrow(int color) {\n        this.mColorIconArrow = color;\n        this.colorIconArrow();\n    }\n\n    public int getColorIconVoice() {\n        return mColorIconVoice;\n    }\n\n    public void setColorIconVoice(int color) {\n        this.mColorIconVoice = color;\n        this.colorIconVoice();\n    }\n\n    public int getColorIconClose() {\n        return mColorIconClose;\n    }\n\n    public void setColorIconClose(int color) {\n        this.mColorIconClose = color;\n        this.colorIconClose();\n    }\n\n    private class OnTextWatcherEdtSearch implements TextWatcher {\n\n        @Override\n        public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n        }\n\n        @Override\n        public void onTextChanged(CharSequence s, int start, int before, int count) {\n            try {\n                if (mEdtSearch.getText().toString().length() == 0) {\n                    mImgCloseSearch.setVisibility(isVoice() ? View.GONE : View.VISIBLE);\n                    mImgVoiceSearch.setVisibility(isVoice() ? View.VISIBLE : View.GONE);\n                    mImgVoiceSearch.setImageResource(R.drawable.ic_keyboard_voice_color_24dp);\n                    colorIconVoice();\n                } else {\n                    mImgVoiceSearch.setVisibility(View.GONE);\n                    mImgCloseSearch.setVisibility(View.VISIBLE);\n                    mImgCloseSearch.setImageResource(R.drawable.ic_close_color_24dp);\n                    colorIconClose();\n                }\n\n                colorIcon();\n                colorIconArrow();\n                mSearchListener.changedSearch(mEdtSearch.getText().toString());\n            } catch (Exception e) {\n                e.getStackTrace();\n            }\n        }\n\n        @Override\n        public void afterTextChanged(Editable s) {\n\n        }\n    }\n\n    /**\n     * Hide SearchLiveo\n     */\n    public void hide() {\n        try {\n            hideAnimation();\n            setActive(false);\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    /**\n     * Show SearchLiveo\n     */\n    public SearchLiveo show() {\n        setActive(true);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n            try {\n                showAnimation();\n            } catch (ClassCastException e) {\n                throw new ClassCastException(mContext.getString(R.string.warning_with));\n            }\n\n        } else {\n\n            Animation mFadeIn = AnimationUtils.loadAnimation(mContext.getApplicationContext(), android.R.anim.fade_in);\n            mViewSearch.setEnabled(true);\n            mViewSearch.setVisibility(View.VISIBLE);\n            mViewSearch.setAnimation(mFadeIn);\n\n            mContext.runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                            toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                }\n            });\n        }\n\n        mEdtSearch.requestFocus();\n        return this;\n    }\n\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP)\n    private void showAnimation(){\n        try {\n\n            if (getStatusBarShowColor() != -1) {\n                mContext.getWindow().setStatusBarColor(getStatusBarShowColor());\n            }else {\n                mContext.getWindow().setStatusBarColor(ContextCompat.getColor(mContext, R.color.search_liveo_primary_dark));\n            }\n\n            final Animator animator = ViewAnimationUtils.createCircularReveal(mViewSearch,\n                    mViewSearch.getWidth() - (int) dpToPixel(24, this.mContext),\n                    (int) dpToPixel(23, this.mContext), 0,\n                    (float) Math.hypot(mViewSearch.getWidth(), mViewSearch.getHeight()));\n            animator.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                }\n\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mContext.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                    toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                        }\n                    });\n                }\n\n                @Override\n                public void onAnimationCancel(Animator animation) {\n\n                }\n\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n\n                }\n            });\n\n            animator.setDuration(300);\n            animator.start();\n        }catch (Exception e){\n            e.getStackTrace();\n            mContext.runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                            toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                }\n            });\n        }\n\n        mViewSearch.setVisibility(View.VISIBLE);\n    }\n\n    private SearchLiveo hideAnimation() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n            if (getStatusBarHideColor() != -1) {\n                mContext.getWindow().setStatusBarColor(getStatusBarHideColor());\n            } else {\n                mContext.getWindow().setStatusBarColor(getColorPrimaryDark());\n            }\n\n            final Animator animatorHide = ViewAnimationUtils.createCircularReveal(mViewSearch,\n                    mViewSearch.getWidth() - (int) dpToPixel(24, mContext),\n                    (int) dpToPixel(23, mContext),\n                    (float) Math.hypot(mViewSearch.getWidth(), mViewSearch.getHeight()), 0);\n            animatorHide.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n\n                    mContext.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                    hideSoftInputFromWindow(mRecyclerView.getWindowToken(), 0);\n                        }\n                    });\n                }\n\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mViewSearch.setVisibility(View.GONE);\n                }\n\n                @Override\n                public void onAnimationCancel(Animator animation) {\n\n                }\n\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n\n                }\n            });\n            animatorHide.setDuration(200);\n            animatorHide.start();\n\n        } else {\n\n            mContext.runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                            hideSoftInputFromWindow(mRecyclerView.getWindowToken(), 0);\n                }\n            });\n\n            Animation mFadeOut = AnimationUtils.loadAnimation(mContext.getApplicationContext(), android.R.anim.fade_out);\n            mViewSearch.setAnimation(mFadeOut);\n            mViewSearch.setVisibility(View.INVISIBLE);\n        }\n\n        mEdtSearch.setText(\"\");\n        mViewSearch.setEnabled(false);\n        return this;\n    }\n\n    private int getColorPrimaryDark() {\n        return mColorPrimaryDark;\n    }\n\n    private void setColorPrimaryDark(int mColorPrimaryDark) {\n        this.mColorPrimaryDark = ContextCompat.getColor(mContext, mColorPrimaryDark);\n    }\n\n    private float dpToPixel(float dp, Context context) {\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n        return dp * (metrics.densityDpi / 160f);\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Bundle bundle = new Bundle();\n        bundle.putParcelable(INSTANCE_STATE, super.onSaveInstanceState());\n        bundle.putBoolean(STATE_TO_SAVE, this.isActive());\n\n        if (!mEdtSearch.getText().toString().trim().equals(\"\")){\n            bundle.putString(SEARCH_TEXT, mEdtSearch.getText().toString());\n        }\n\n        return bundle;\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n\n        if (state instanceof Bundle) {\n            Bundle bundle = (Bundle) state;\n            this.setActive(bundle.getBoolean(STATE_TO_SAVE));\n\n            String text = bundle.getString(SEARCH_TEXT, \"\");\n            if (!text.trim().equals(\"\")){\n                mEdtSearch.setText(text);\n            }\n\n            if (this.isActive()){\n                show();\n            }\n\n            state = bundle.getParcelable(INSTANCE_STATE);\n        }\n\n        super.onRestoreInstanceState(state);\n    }\n\n    private void startVoice(EditText editText) {\n        ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                hideSoftInputFromWindow(editText.getWindowToken(), 0);\n\n        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);\n        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);\n        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault());\n        intent.putExtra(RecognizerIntent.EXTRA_PROMPT, mContext.getString(R.string.searchview_voice));\n        try {\n            mContext.startActivityForResult(intent, REQUEST_CODE_SPEECH_INPUT);\n        } catch (ActivityNotFoundException a) {\n            Toast.makeText(mContext.getApplicationContext(), R.string.not_supported, Toast.LENGTH_SHORT).show();\n        }\n    }\n\n    public void resultVoice(int requestCode, int resultCode, Intent data){\n        if (requestCode == SearchLiveo.REQUEST_CODE_SPEECH_INPUT) {\n            if (resultCode == Activity.RESULT_OK && null != data) {\n                ArrayList<String> result = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                mEdtSearch.setText(result.get(0));\n            }\n        }\n    }\n}\napp/src/main/java/br/com/javace/javou/adapter/ParticipantAdapter.java\npublic class ParticipantAdapter extends RecyclerView.Adapter<ParticipantAdapter.ViewHolder> {\n\n    private int mBackground;\n    private Context mContext;\n    private HashSet<Integer> checkedItems;\n    private ArrayList<Participant> mParticipants;\n    private ArrayList<Participant> mSearchParticipants;\n\n    private static final int ITEM_VIEW_TYPE_ITEM = 1;\n    private static final int ITEM_VIEW_TYPE_HEADER = 0;\n\n    private static OnItemClickListener mOnClickListener;\n    private static OnItemClickListener mOnItemClickListener;\n    private static OnItemLongClickListener mOnItemLongClickListener;\n\n    public ParticipantAdapter(Context context, ArrayList<Participant> participants) {\n        this.mContext = context;\n        this.mParticipants = participants;\n        this.checkedItems = new HashSet<>();\n        this.mSearchParticipants = new ArrayList<>();\n        this.mSearchParticipants.addAll(this.mParticipants);\n\n        if (context != null) {\n            TypedValue mTypedValue = new TypedValue();\n            context.getTheme().resolveAttribute(android.R.attr.selectableItemBackground, mTypedValue, true);\n            this.mBackground = mTypedValue.resourceId;\n        }\n    }\n\n    class ViewHolder extends RecyclerView.ViewHolder {\n        View mContainer;\n\n        TextView mTitle;\n        TextView mName;\n        TextView mEmail;\n        TextView mShirtSize;\n\n        ViewHolder(View view) {\n            super(view);\n\n            mContainer = view;\n\n            mTitle = (TextView) view.findViewById(R.id.txt_title);\n            mName = (TextView) view.findViewById(R.id.txt_name);\n            mEmail = (TextView) view.findViewById(R.id.txt_email);\n            mShirtSize = (TextView) view.findViewById(R.id.txt_shirt_size);\n\n            if (mShirtSize != null) {\n                mShirtSize.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        // -1 Refers to the header\n                        int position = getAdapterPosition() - 1;\n                        if (mOnClickListener != null && position >= 0) {\n                            mOnClickListener.onItemClick(v, position);\n                        }\n                    }\n                });\n            }\n\n            mContainer.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    // -1 Refers to the header\n                    int position = getAdapterPosition() - 1;\n                    if (mOnItemClickListener != null && position >= 0) {\n                        mOnItemClickListener.onItemClick(v, position);\n                    }\n                }\n            });\n\n            mContainer.setOnLongClickListener(new View.OnLongClickListener() {\n                @Override\n                public boolean onLongClick(View v) {\n                    int position = getAdapterPosition() - 1;\n                    if (mOnItemLongClickListener != null && position >= 0) {\n                        mOnItemLongClickListener.onItemLongClick(v, position);\n                    }\n                    return true;\n                }\n            });\n        }\n    }\n\n    @Override\n    public ParticipantAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view;\n\n        if (viewType == ITEM_VIEW_TYPE_HEADER) {\n            view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fragment_participant_header, parent, false);\n            return new ViewHolder(view);\n        }\n\n        view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fragment_participant_item, parent, false);\n        view.setBackgroundResource(this.mBackground);\n        return new ViewHolder(view);\n    }\n\n    private boolean isHeader(int position) {\n        return position == 0;\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        return isHeader(position) ? ITEM_VIEW_TYPE_HEADER : ITEM_VIEW_TYPE_ITEM;\n    }\n\n    @Override\n    public void onBindViewHolder(ViewHolder holder, int position) {\n\n        if (mParticipants == null || mParticipants.size() == 0){\n            return;\n        }\n\n        if (isHeader(position)) {\n            holder.mTitle.setText(mParticipants.get(position).getNameEvent());\n            return;\n        }\n\n        // -1 Refers to the header\n        Participant participant = mParticipants.get(position - 1);\n\n        holder.mName.setText(participant.getName());\n        holder.mName.setCompoundDrawablesWithIntrinsicBounds(participant.isAttend() ? R.drawable.ic_check_green_18dp : 0, 0, 0, 0);\n\n        holder.mEmail.setText(participant.getEmail());\n\n        if (participant.isGroup()) {\n            int shirtSize = participant.getShirtSize();\n            holder.mShirtSize.setVisibility(View.VISIBLE);\n            GradientDrawable gradientDrawable = (GradientDrawable) holder.mShirtSize.getBackground();\n            gradientDrawable.setColor(ContextCompat.getColor(mContext, Util.shirtSizeColor[shirtSize]));\n            holder.mShirtSize.setText(this.mContext.getString(Util.shirtSize[shirtSize]));\n        }else{\n            holder.mShirtSize.setVisibility(View.INVISIBLE);\n        }\n\n        if (checkedItems.contains(position)) {\n            holder.mContainer.setBackgroundResource(R.drawable.seletor_long_click_item);\n        } else {\n            holder.mContainer.setBackgroundResource(this.mBackground);\n        }\n    }\n\n    public void readAttendParticipant(int position, boolean attend){\n        mParticipants.get(position).setAttend(attend);\n        notifyDataSetChanged();\n    }\n\n    public void remove(int position){\n        mParticipants.remove(position);\n        notifyDataSetChanged();\n    }\n\n    @Override\n    public int getItemCount() {\n        // +1 Refers to the header\n        return (mParticipants == null ? 0 : mParticipants.size()+1);\n    }\n\n    public void setOnClickListener(OnItemClickListener onClickListener) {\n        mOnClickListener = onClickListener;\n    }\n\n    public void setOnItemClickListener(OnItemClickListener onItemClickListener) {\n        mOnItemClickListener = onItemClickListener;\n    }\n\n    public void setOnItemLongClickListener(OnItemLongClickListener onItemLongClickListener) {\n        mOnItemLongClickListener = onItemLongClickListener;\n    }\n\n    public void resetarCheck() {\n        this.checkedItems.clear();\n        this.notifyDataSetChanged();\n    }\n\n    public void setChecked(int position, boolean checked) {\n        resetarCheck();\n\n        if (checked) {\n            this.checkedItems.add(position);\n        } else {\n            this.checkedItems.remove(position);\n        }\n\n        this.notifyDataSetChanged();\n    }\n\n    public void searchParticipantes(CharSequence charText) {\n\n        charText = Util.removeAccent((String) charText).toLowerCase(Locale.getDefault());\n\n        mParticipants.clear();\n        if (charText.length() == 0) {\n            mParticipants.addAll(mSearchParticipants);\n        } else {\n            for (Participant participant: mSearchParticipants) {\n                String name = Util.removeAccent(participant.getName());\n                if (name.toLowerCase(Locale.getDefault()).contains(charText)) {\n                    mParticipants.add(participant);\n                }\n            }\n        }\n\n        notifyDataSetChanged();\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/activity/NewParticipantActivity.java\npublic class NewParticipantActivity extends BaseActivity{\n\n    private int mShirtSize = 0;\n    private ProgressDialog mDialog;\n    private Participant mParticipant;\n\n    @BindView(R.id.img_sex) ImageView mImgSex;\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.sw_sex) SwitchCompat mSwSex;\n\n    @BindView(R.id.edt_code) EditText mEdtCode;\n    @BindView(R.id.edt_name) EditText mEdtName;\n    @BindView(R.id.edt_email) EditText mEdtEmail;\n    @BindView(R.id.edt_phone) EditText mEdtPhone;\n    @BindView(R.id.edt_company) EditText mEdtCompany;\n    @BindView(R.id.sw_attend) SwitchCompat mSwAttend;\n\n    @BindView(R.id.txt_shirt_size_p) TextView mTxtShirtSizeP;\n    @BindView(R.id.txt_shirt_size_m) TextView mTxtShirtSizeM;\n    @BindView(R.id.txt_shirt_size_g) TextView mTxtShirtSizeG;\n    @BindView(R.id.txt_shirt_size_gg) TextView mTxtShirtSizeGG;\n    @BindView(R.id.txt_shirt_size_eg) TextView mTxtShirtSizeEG;\n\n    @BindView(R.id.layout_code) LinearLayout mLayoutCode;\n    @BindView(R.id.layout_name) LinearLayout mLayoutName;\n    @BindView(R.id.layout_email) LinearLayout mLayoutEmail;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n        // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_new_participant);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitle(getString(R.string.new_participant));\n        mToolbar.setNavigationIcon(R.drawable.ic_done_white_24dp);\n        this.setSupportActionBar(mToolbar);\n\n        setupOnClickListener();\n        if (savedInstanceState != null){\n            mShirtSize = savedInstanceState.getInt(Constant.PARTICIPANT_shirtSize, 0);\n        }\n\n        boolean isInsert = getIntent().getExtras().getBoolean(Constant.INSERT, false);\n        if (!isInsert){\n            mParticipant = getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n            setupUpdate(mParticipant);\n        }\n\n        colorDefaultShirtSize(mShirtSize);\n        ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            actionBar.setDisplayHomeAsUpEnabled(true);\n        }\n\t}\n\n    private void setupUpdate(Participant participant){\n        mEdtCode.setEnabled(false);\n        mEdtCode.setText(String.valueOf(participant.getCode()));\n        mEdtName.setText(participant.getName());\n        mEdtPhone.setText(participant.getPhone());\n        mEdtEmail.setText(participant.getEmail());\n        mShirtSize = participant.getShirtSize();\n        mSwAttend.setChecked(participant.isAttend());\n        mSwSex.setChecked(participant.isSex());\n        mEdtCompany.setText(participant.getCompany());\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.menu, menu);\n        menu.findItem(R.id.menu_raffle).setVisible(false);\n        menu.findItem(R.id.menu_delete).setVisible(false);\n        menu.findItem(R.id.menu_search).setVisible(false);\n        menu.findItem(R.id.menu_send).setVisible(false);\n        menu.findItem(R.id.menu_resume).setVisible(false);\n        return true;\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(Constant.PARTICIPANT_shirtSize, mShirtSize);\n    }\n\n    private CompoundButton.OnCheckedChangeListener onCheckedAttend = new CompoundButton.OnCheckedChangeListener() {\n        @Override\n        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n            mSwAttend.setCompoundDrawablesWithIntrinsicBounds(isChecked ? R.drawable.ic_check_green_18dp : 0, 0, 0, 0);\n        }\n    };\n\n    private CompoundButton.OnCheckedChangeListener onCheckedSex = new CompoundButton.OnCheckedChangeListener() {\n        @Override\n        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n            mSwSex.setText(isChecked ? R.string.female : R.string.male);\n            mImgSex.setColorFilter(ContextCompat.getColor(NewParticipantActivity.this, isChecked ? R.color.shirt_size_g : R.color.shirt_size_m));\n            mImgSex.setImageDrawable(ContextCompat.getDrawable(NewParticipantActivity.this, isChecked ? R.drawable.ic_favorite_grey600_24dp : R.drawable.ic_android_grey600_24dp));\n\n            if (isChecked){\n                YoYo.with(Techniques.Landing).playOn(mImgSex);\n            }\n        }\n    };\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n\n        switch (item.getItemId()){\n            case android.R.id.home:\n                    if (validation()){\n                        if (mParticipant == null) {\n                            saveParticipant();\n                        }else{\n                            updateParticipant();\n                        }\n                    }\n                break;\n\n            case R.id.menu_discart:\n                finish(ActivityAnimation.SLIDE_RIGHT);\n                break;\n        }\n\n        return true;\n    }\n\n    private void setupOnClickListener(){\n        mSwAttend.setOnCheckedChangeListener(onCheckedAttend);\n        mSwAttend.setChecked(true);\n\n        mSwSex.setOnCheckedChangeListener(onCheckedSex);\n        mSwSex.setChecked(false);\n\n        mTxtShirtSizeP.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeM.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeG.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeGG.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeEG.setOnClickListener(onClickShirtSize);\n    }\n\n    private boolean validation(){\n\t\tboolean result = true;\n\n        if (mEdtCode.getText().toString().trim().equals(\"\")){\n            result = false;\n            mEdtCode.requestFocus();\n            YoYo.with(Techniques.Shake).playOn(mLayoutCode);\n            Toast.makeText(getApplicationContext(), R.string.warning_no_code, Toast.LENGTH_SHORT).show();\n        }else if (mEdtName.getText().toString().trim().equals(\"\")){\n            result = false;\n            mEdtName.requestFocus();\n            YoYo.with(Techniques.Shake).playOn(mLayoutName);\n            Toast.makeText(getApplicationContext(), R.string.warning_no_name, Toast.LENGTH_SHORT).show();\n        }else if (mEdtEmail.getText().toString().trim().equals(\"\")){\n            result = false;\n            mEdtEmail.requestFocus();\n            YoYo.with(Techniques.Shake).playOn(mLayoutEmail);\n            Toast.makeText(getApplicationContext(), R.string.warning_no_email, Toast.LENGTH_SHORT).show();\n        }\n\n\t\treturn result;\n\t}\n\n    private void saveParticipant(){\n        showDialog();\n\n        Participant participant = new Participant();\n        participant.setCode(Integer.valueOf(mEdtCode.getText().toString()));\n        participant.setName(mEdtName.getText().toString());\n        participant.setPhone(mEdtPhone.getText().toString());\n        participant.setEmail(mEdtEmail.getText().toString());\n        participant.setShirtSize(mShirtSize);\n        participant.setAttend(mSwAttend.isChecked());\n        participant.setNameEvent(Constant.NAME_EVENT);\n        participant.setBirthDate(\"\");\n        participant.setRaffled(false);\n        participant.setSex(mSwSex.isChecked());\n        participant.setCompany(mEdtCompany.getText().toString());\n\n        new ParticipantInsertTask(this, participant){\n            @Override\n            protected void onPreExecute() {\n                super.onPreExecute();\n                showDialog();\n            }\n\n            @Override\n            protected void onPostExecute(Boolean result) {\n                super.onPostExecute(result);\n\n                if (result){\n                    Intent intent = new Intent();\n                    intent.putExtra(Constant.PARTICIPANT, true);\n                    setResult(0, intent);\n                    finish(ActivityAnimation.SLIDE_RIGHT);\n                    Toast.makeText(getApplicationContext(), R.string.warning_save_participante, Toast.LENGTH_SHORT).show();\n                }else{\n                    Toast.makeText(getApplicationContext(), R.string.error_save_participante, Toast.LENGTH_SHORT).show();\n                }\n\n                hideDialog();\n            }\n        }.execute();\n    }\n\n    private void updateParticipant(){\n        showDialog();\n\n        Participant participant = new Participant();\n        participant.setId(mParticipant.getId());\n        participant.setCode(Integer.valueOf(mEdtCode.getText().toString()));\n        participant.setName(mEdtName.getText().toString());\n        participant.setPhone(mEdtPhone.getText().toString());\n        participant.setEmail(mEdtEmail.getText().toString());\n        participant.setShirtSize(mShirtSize);\n        participant.setAttend(mSwAttend.isChecked());\n        participant.setNameEvent(mParticipant.getNameEvent());\n        participant.setBirthDate(mParticipant.getBirthDate());\n        participant.setRaffled(mParticipant.isRaffled());\n        participant.setSex(mSwSex.isChecked());\n        participant.setCompany(mEdtCompany.getText().toString());\n\n        new ParticipantUpdateTask(this, participant){\n            @Override\n            protected void onPreExecute() {\n                super.onPreExecute();\n                showDialog();\n            }\n\n            @Override\n            protected void onPostExecute(Boolean result) {\n                super.onPostExecute(result);\n\n                if (result){\n                    Intent intent = new Intent();\n                    intent.putExtra(Constant.PARTICIPANT, true);\n                    setResult(0, intent);\n                    finish(ActivityAnimation.SLIDE_RIGHT);\n                    Toast.makeText(getApplicationContext(), R.string.warning_save_participante, Toast.LENGTH_SHORT).show();\n                }else{\n                    Toast.makeText(getApplicationContext(), R.string.error_save_participante, Toast.LENGTH_SHORT).show();\n                }\n\n                hideDialog();\n            }\n        }.execute();\n    }\n\n    private View.OnClickListener onClickShirtSize = new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            resetColorShirtSize();\n\n            switch (v.getId()){\n\n                case R.id.txt_shirt_size_p:\n                    mShirtSize = 0;\n                    break;\n\n                case R.id.txt_shirt_size_m:\n                    mShirtSize = 1;\n                    break;\n\n                case R.id.txt_shirt_size_g:\n                    mShirtSize = 2;\n                    break;\n\n                case R.id.txt_shirt_size_gg:\n                    mShirtSize = 3;\n                    break;\n\n                case R.id.txt_shirt_size_eg:\n                    mShirtSize = 4;\n                    break;\n\n            }\n\n            colorDefaultShirtSize(mShirtSize);\n        }\n    };\n\n    private void resetColorShirtSize(){\n        GradientDrawable gradientDrawable = (GradientDrawable) mTxtShirtSizeP.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeM.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeG.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeGG.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeEG.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n    }\n\n    private void colorDefaultShirtSize(int shirtSize){\n        resetColorShirtSize();\n        GradientDrawable gradientDrawable;\n\n        switch (shirtSize) {\n            case 0:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeP.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeP);\n                break;\n\n            case 1:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeM.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeM);\n                break;\n\n            case 2:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeG.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeG);\n                break;\n\n            case 3:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeGG.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeGG);\n                break;\n\n            case 4:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeEG.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeEG);\n                break;\n        }\n    }\n\n    private class AnimatorShirtSize implements Animator.AnimatorListener{\n\n        private int mPosition;\n        private GradientDrawable mGradientDrawable;\n\n        public AnimatorShirtSize(GradientDrawable gradientDrawable, int position){\n            this.mPosition = position;\n            this.mGradientDrawable = gradientDrawable;\n        }\n\n        @Override\n        public void onAnimationStart(Animator animation) {\n            if (mGradientDrawable != null) {\n                mGradientDrawable.setColor(ContextCompat.getColor(NewParticipantActivity.this, Util.shirtSizeColor[mPosition]));\n            }\n        }\n\n        @Override\n        public void onAnimationEnd(Animator animation) {\n        }\n\n        @Override\n        public void onAnimationCancel(Animator animation) {\n\n        }\n\n        @Override\n        public void onAnimationRepeat(Animator animation) {\n\n        }\n    }\n\n    private void showDialog() {\n        mDialog = ProgressDialog.show(this, getString(R.string.wait),\n                getString(R.string.warning_save_wait_participante));\n    }\n\n    private void hideDialog(){\n        if (mDialog != null){\n            mDialog.dismiss();\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/activity/RaffleActivity.java\npublic class RaffleActivity extends BaseActivity {\n\n    private boolean isFinishOk = false;\n    private Participant mParticipantFortunate;\n    @BindView(R.id.animated_load) AnimatedCircleLoadingView mAnimatedLoad;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_raffle_main);\n        ButterKnife.bind(this);\n\n        mParticipantFortunate =  getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n        mAnimatedLoad.setOnClickListener(onClickAnimLoad);\n        startPercentMockThread();\n    }\n\n    private View.OnClickListener onClickAnimLoad = new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            if (isFinishOk) {\n                isFinishOk = false;\n                Toast.makeText(getApplicationContext(), \"Terminou\", Toast.LENGTH_SHORT).show();\n            }\n        }\n    };\n\n    private void startLoading() {\n        mAnimatedLoad.startDeterminate();\n    }\n\n    private void startPercentMockThread() {\n        startLoading();\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1500);\n                    for (int i = 0; i <= 100; i++) {\n                        Thread.sleep(10);\n                        changePercent(i);\n                    }\n                    Thread.sleep(3000);\n                    ParticipantDao participantDao = new ParticipantDao(getApplicationContext());\n                    participantDao.updateAsRaffled(mParticipantFortunate);\n                    Intent intent = new Intent(getBaseContext(), ParticipantFortunateActivity.class);\n                    intent.putExtra(Constant.PARTICIPANT, mParticipantFortunate);\n                    startActivityForResult(intent, 0, BaseActivity.ActivityAnimation.SLIDE_LEFT);\n                    finish();\n\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        new Thread(runnable).start();\n    }\n\n    private void changePercent(final int percent) {\n        runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                if (mAnimatedLoad != null) {\n                    mAnimatedLoad.setPercent(percent);\n\n                    if (percent == 100){\n                        isFinishOk = true;\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantTask.java\npublic class ParticipantTask extends AsyncTask<Void, Void, ArrayList<Participant>> {\n\n    private Context mContext;\n    public ParticipantTask(Context context){\n        this.mContext = context;\n    }\n\n    @Override\n    protected ArrayList<Participant> doInBackground(Void... params) {\n        ParticipantDao participantDao = ParticipantDao.getInstance(mContext);\n        return participantDao.getAll();\n    }\n}\n", "answers": ["                Intent intent = new Intent(getActivity(), ParticipantFortunateActivity.class);"], "length": 6652, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "ac6b60475fb35309a7b102618c3472231e77b5bfc8326ece"}
{"input": "import concurrent.futures\nimport contextlib\nimport os\nimport time\nimport unittest.mock\nfrom redis import Redis\nfrom redis.commands.core import Script\nfrom redis.exceptions import TimeoutError\nfrom pottery import ContextTimer\nfrom pottery import ExtendUnlockedLock\nfrom pottery import QuorumIsImpossible\nfrom pottery import QuorumNotAchieved\nfrom pottery import Redlock\nfrom pottery import ReleaseUnlockedLock\nfrom pottery import TooManyExtensions\nfrom pottery import synchronize\nfrom pottery.base import logger\nfrom tests.base import TestCase\n# --------------------------------------------------------------------------- #\n#   test_redlock.py                                                           #\n#                                                                             #\n#   Copyright © 2015-2022, Rajiv Bakulesh Shah, original author.              #\n#                                                                             #\n#   Licensed under the Apache License, Version 2.0 (the \"License\");           #\n#   you may not use this file except in compliance with the License.          #\n#   You may obtain a copy of the License at:                                  #\n#       http://www.apache.org/licenses/LICENSE-2.0                            #\n#                                                                             #\n#   Unless required by applicable law or agreed to in writing, software       #\n#   distributed under the License is distributed on an \"AS IS\" BASIS,         #\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #\n#   See the License for the specific language governing permissions and       #\n#   limitations under the License.                                            #\n# --------------------------------------------------------------------------- #\n'Distributed Redis-powered lock tests.'\n\n\n\n\n\n\nclass RedlockTests(TestCase):\n    'Distributed Redis-powered lock tests.'\n\n    def setUp(self):\n        super().setUp()\n        self.redlock = Redlock(\n            masters={self.redis},\n            key='printer',\n            auto_release_time=.2,\n        )\n\n    def test_acquire_fails_within_auto_release_time(self):\n        self.redlock.auto_release_time = .001\n        assert not self.redlock._acquire_masters()\n\n    def test_acquire_and_time_out(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        time.sleep(self.redlock.auto_release_time * 2)\n        assert not self.redis.exists(self.redlock.key)\n\n    def test_acquire_same_lock_twice_blocking_without_timeout(self):\n        assert not self.redis.exists(self.redlock.key)\n        with ContextTimer() as timer, \\\n             unittest.mock.patch.object(logger, 'info') as info:\n            assert self.redlock.acquire()\n            assert self.redis.exists(self.redlock.key)\n            assert self.redlock.acquire()\n            assert self.redis.exists(self.redlock.key)\n            assert timer.elapsed() / 1000 >= self.redlock.auto_release_time\n            assert info.call_count == 1, f'_logger.info() called {info.call_count} times'\n\n    @unittest.skipIf('CI' in os.environ, 'this unit test is flaky on CI')  # pragma: no cover\n    def test_acquire_same_lock_twice_blocking_with_timeout(self):\n        with unittest.mock.patch.object(logger, 'info') as info:\n            assert not self.redis.exists(self.redlock.key)\n            assert self.redlock.acquire()\n            assert self.redis.exists(self.redlock.key)\n            assert not self.redlock.acquire(timeout=0)\n            assert not self.redlock.acquire(timeout=0.025)\n            assert self.redis.exists(self.redlock.key)\n            assert info.call_count == 1, f'_logger.info() called {info.call_count} times'\n\n    def test_acquire_same_lock_twice_non_blocking_without_timeout(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        assert not self.redlock.acquire(blocking=False)\n        assert self.redis.exists(self.redlock.key)\n        time.sleep(self.redlock.auto_release_time * 2)\n        assert not self.redis.exists(self.redlock.key)\n\n    def test_acquire_same_lock_twice_non_blocking_with_timeout(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        with self.assertRaises(ValueError):\n            self.redlock.acquire(blocking=False, timeout=0)\n        assert self.redis.exists(self.redlock.key)\n\n    def test_acquired(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert not self.redlock.locked()\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        assert self.redlock.locked()\n        time.sleep(self.redlock.auto_release_time * 2)\n        assert not self.redis.exists(self.redlock.key)\n        assert not self.redlock.locked()\n\n    def test_extend(self):\n        assert not self.redis.exists(self.redlock.key)\n        with self.assertRaises(ExtendUnlockedLock):\n            self.redlock.extend()\n        assert self.redlock.acquire()\n        for extension_num in range(Redlock._NUM_EXTENSIONS):\n            with self.subTest(extension_num=extension_num):\n                self.redlock.extend()\n", "context": "pottery/exceptions.py\nclass ExtendUnlockedLock(PrimitiveError, RuntimeError):\n    'Attempting to extend an unlocked Redlock.'\npottery/exceptions.py\nclass ReleaseUnlockedLock(PrimitiveError, RuntimeError):\n    'Attempting to release an unlocked Redlock.'\npottery/exceptions.py\nclass QuorumNotAchieved(PrimitiveError, RuntimeError):\n    'Consensus-based algorithm could not achieve quorum.'\npottery/timer.py\nclass ContextTimer:\n    '''Measure the execution time of small code snippets.\n\n    Note that ContextTimer measures wall (real-world) time, not CPU time; and\n    that .elapsed() returns time in milliseconds.\n\n    You can use ContextTimer stand-alone...\n\n        >>> import time\n        >>> timer = ContextTimer()\n        >>> timer.start()\n        >>> time.sleep(0.1)\n        >>> 100 <= timer.elapsed() < 200\n        True\n        >>> timer.stop()\n        >>> time.sleep(0.1)\n        >>> 100 <= timer.elapsed() < 200\n        True\n\n    ...or as a context manager:\n\n        >>> tests = []\n        >>> with ContextTimer() as timer:\n        ...     time.sleep(0.1)\n        ...     tests.append(100 <= timer.elapsed() < 200)\n        >>> time.sleep(0.1)\n        >>> tests.append(100 <= timer.elapsed() < 200)\n        >>> tests\n        [True, True]\n    '''\n\n    __slots__ = ('_started', '_stopped')\n\n    def __init__(self) -> None:\n        self._started = 0.0\n        self._stopped = 0.0\n\n    def __enter__(self) -> ContextTimer:\n        self.__start()\n        return self\n\n    @overload\n    def __exit__(self,\n                 exc_type: None,\n                 exc_value: None,\n                 exc_traceback: None,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    @overload\n    def __exit__(self,\n                 exc_type: Type[BaseException],\n                 exc_value: BaseException,\n                 exc_traceback: TracebackType,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    def __exit__(self,\n                 exc_type: Type[BaseException] | None,\n                 exc_value: BaseException | None,\n                 exc_traceback: TracebackType | None,\n                 ) -> Literal[False]:\n        self.__stop()\n        return False\n\n    def start(self) -> None:\n        if self._stopped:\n            raise RuntimeError('timer has already been stopped')\n        elif self._started:\n            raise RuntimeError('timer has already been started')\n        else:\n            self._started = timeit.default_timer()\n\n    # Preserve the Open-Closed Principle with name mangling.\n    #   https://youtu.be/miGolgp9xq8?t=2086\n    #   https://stackoverflow.com/a/38534939\n    __start = start\n\n    def stop(self) -> None:\n        if self._stopped:\n            raise RuntimeError('timer has already been stopped')\n        elif self._started:\n            self._stopped = timeit.default_timer()\n        else:\n            raise RuntimeError(\"timer hasn't yet been started\")\n\n    __stop = stop\n\n    def elapsed(self) -> int:\n        if self._started:\n            stopped_or_current = self._stopped or timeit.default_timer()\n            elapsed = stopped_or_current - self._started\n            return round(elapsed * 1000)\n        else:\n            raise RuntimeError(\"timer hasn't yet been started\")\npottery/base.py\ndef random_key(*,\n               redis: Redis,\n               prefix: str = 'pottery:',\n               num_tries: int = 3,\n               ) -> str:\ndef _connection_args(redis: Redis) -> Tuple[str, int, int]:\n    def __init__(self, *, redis: Redis | None = None, key: str = '') -> None:\n    def __del__(self) -> None:\n    def redis(self) -> Redis:\n    def redis(self, value: Redis | None) -> None:\n    def key(self) -> str:\n    def key(self, value: str) -> None:\n    def _random_key(self) -> str:\n    def _encode(decoded_value: JSONTypes) -> str:\n    def _decode(encoded_value: AnyStr) -> JSONTypes:\n    def redis(self) -> Redis:  # pragma: no cover\n    def key(self) -> str:  # pragma: no cover\n    def clear(self: _HasRedisClientAndKey) -> None:\n    def redis(self) -> Redis:\n    def key(self) -> str:\n    def __watch_keys(self, *keys: str) -> Generator[Pipeline, None, None]:\n    def __context_managers(self,\n                           *others: Any,\n                           ) -> Generator[ContextManager[Pipeline], None, None]:\n    def _watch(self, *others: Any) -> Generator[Pipeline, None, None]:\n    def redis(self) -> Redis:\n    def key(self) -> str:\n    def _watch(self, *others: Any) -> Generator[Pipeline, None, None]:\n    def _same_redis(self, *others: Any) -> bool:\n    def __eq__(self, other: Any) -> bool:\n    def __iter__(self) -> Generator[JSONTypes, None, None]:\n    def _KEY_PREFIX(self) -> str:\n    def __init__(self,\n                 *,\n                 key: str,\n                 masters: Iterable[Redis] = frozenset(),\n                 raise_on_redis_errors: bool = False,\n                 ) -> None:\n    def key(self) -> str:\n    def key(self, value: str) -> None:\n    def _check_enough_masters_up(self,\n                                 raise_on_redis_errors: bool | None,\n                                 redis_errors: List[RedisError],\n                                 ) -> None:\nclass _Common:\nclass _Encodable:\nclass _HasRedisClientAndKey(Protocol):\nclass _Clearable:\nclass _Pipelined(abc.ABC):\nclass _Comparable(abc.ABC):\nclass Container(_Common, _Encodable, _Clearable, _Pipelined, _Comparable):\nclass Iterable_(abc.ABC):\nclass Primitive(abc.ABC):\nclass AIOPrimitive(Primitive):\n    _RANDOM_KEY_PREFIX: ClassVar[str] = 'pottery:'\n    _DEFAULT_MASTERS: ClassVar[FrozenSet[Redis]] = frozenset({_default_redis})\n    _DEFAULT_MASTERS: ClassVar[FrozenSet[AIORedis]] = frozenset()  # type: ignore\npottery/redlock.py\nclass Redlock(Scripts, Primitive):\n    '''Distributed Redis-powered lock.\n\n    This algorithm safely and reliably provides a mutually-exclusive locking\n    primitive to protect a resource shared across threads, processes, and even\n    machines, without a single point of failure.\n\n    Rationale and algorithm description:\n        http://redis.io/topics/distlock\n\n    Usage:\n\n        >>> from redis import Redis\n        >>> redis = Redis()\n        >>> printer_lock = Redlock(key='printer', masters={redis}, auto_release_time=.2)\n        >>> bool(printer_lock.locked())\n        False\n        >>> if printer_lock.acquire():\n        ...     # Critical section - print stuff here.\n        ...     print('printer_lock is locked')\n        printer_lock is locked\n        >>> printer_lock.release()\n        >>> bool(printer_lock.locked())\n        False\n\n    Redlocks time out (by default, after 10 seconds).  You should take care to\n    ensure that your critical section completes well within the timeout.  The\n    reasons that Redlocks time out are to preserve \"liveness\"\n    (http://redis.io/topics/distlock#liveness-arguments) and to avoid deadlocks\n    (in the event that a process dies inside a critical section before it\n    releases its lock).\n\n        >>> if printer_lock.acquire():\n        ...     # Critical section - print stuff here.\n        ...     time.sleep(printer_lock.auto_release_time)\n        >>> bool(printer_lock.locked())\n        False\n\n    If 10 seconds isn't enough to complete executing your critical section,\n    then you can specify your own timeout:\n\n        >>> printer_lock = Redlock(key='printer', masters={redis}, auto_release_time=.2)\n        >>> if printer_lock.acquire():\n        ...     # Critical section - print stuff here.\n        ...     time.sleep(printer_lock.auto_release_time / 2)\n        >>> bool(printer_lock.locked())\n        True\n        >>> time.sleep(printer_lock.auto_release_time / 2)\n        >>> bool(printer_lock.locked())\n        False\n\n    You can use a Redlock as a context manager:\n\n        >>> with Redlock(key='printer', masters={redis}) as printer_lock:\n        ...     # Critical section - print stuff here.\n        ...     print('printer_lock is locked')\n        printer_lock is locked\n        >>> bool(printer_lock.locked())\n        False\n\n        >>> with printer_lock:\n        ...     # Critical section - print stuff here.\n        ...     print('printer_lock is locked')\n        printer_lock is locked\n        >>> bool(printer_lock.locked())\n        False\n    '''\n\n    __slots__ = (\n        'auto_release_time',\n        'num_extensions',\n        'context_manager_blocking',\n        'context_manager_timeout',\n        '_uuid',\n        '_extension_num',\n    )\n\n    _KEY_PREFIX: ClassVar[str] = 'redlock'\n    _AUTO_RELEASE_TIME: ClassVar[float] = 10\n    _CLOCK_DRIFT_FACTOR: ClassVar[float] = 0.01\n    _RETRY_DELAY: ClassVar[float] = .2\n    _NUM_EXTENSIONS: ClassVar[int] = 3\n\n    def __init__(self,\n                 *,\n                 key: str,\n                 masters: Iterable[Redis] = frozenset(),\n                 raise_on_redis_errors: bool = False,\n                 auto_release_time: float = _AUTO_RELEASE_TIME,\n                 num_extensions: int = _NUM_EXTENSIONS,\n                 context_manager_blocking: bool = True,\n                 context_manager_timeout: float = -1,\n                 ) -> None:\n        '''Initialize a Redlock.\n\n        Keyword arguments:\n            key -- a string that identifies your resource\n            masters -- the Redis clients used to achieve quorum for this\n                Redlock's state\n            raise_on_redis_errors -- whether to raise the QuorumIsImplssible\n                exception when too many Redis masters throw errors\n            auto_release_time -- the timeout in seconds by which to\n                automatically release this Redlock, unless it's already been\n                released\n            num_extensions -- the number of times that this Redlock's lease can\n                be extended\n            context_manager_blocking -- when using this Redlock as a context\n                manager, whether to block when acquiring\n            context_manager_timeout -- if context_manager_blocking, how long to\n                wait when acquiring before giving up and raising the\n                QuorumNotAchieved exception\n        '''\n        if not context_manager_blocking and context_manager_timeout != -1:\n            raise ValueError(\"can't specify a timeout for a non-blocking call\")\n\n        super().__init__(\n            key=key,\n            masters=masters,\n            raise_on_redis_errors=raise_on_redis_errors,\n        )\n        self.auto_release_time = auto_release_time\n        self.num_extensions = num_extensions\n        self.context_manager_blocking = context_manager_blocking\n        self.context_manager_timeout = context_manager_timeout\n        self._uuid = ''\n        self._extension_num = 0\n\n    def __acquire_master(self, master: Redis) -> bool:\n        acquired = master.set(\n            self.key,\n            self._uuid,\n            px=int(self.auto_release_time * 1000),\n            nx=True,\n        )\n        return bool(acquired)\n\n    def __acquired_master(self, master: Redis) -> int:\n        if self._uuid:\n            ttl: int = cast(Script, self._acquired_script)(\n                keys=(self.key,),\n                args=(self._uuid,),\n                client=master,\n            )\n        else:\n            ttl = 0\n        return ttl\n\n    def __extend_master(self, master: Redis) -> bool:\n        auto_release_time_ms = int(self.auto_release_time * 1000)\n        extended = cast(Script, self._extend_script)(\n            keys=(self.key,),\n            args=(self._uuid, auto_release_time_ms),\n            client=master,\n        )\n        return bool(extended)\n\n    def __release_master(self, master: Redis) -> bool:\n        released = cast(Script, self._release_script)(\n            keys=(self.key,),\n            args=(self._uuid,),\n            client=master,\n        )\n        return bool(released)\n\n    def __drift(self) -> float:\n        return self.auto_release_time * self._CLOCK_DRIFT_FACTOR + .002\n\n    def _acquire_masters(self,\n                         *,\n                         raise_on_redis_errors: bool | None = None,\n                         ) -> bool:\n        self._uuid = str(uuid.uuid4())\n        self._extension_num = 0\n\n        with ContextTimer() as timer, BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__acquire_master, master)\n                futures.add(future)\n\n            num_masters_acquired, redis_errors = 0, []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    num_masters_acquired += future.result()\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.__acquire_masters() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if num_masters_acquired > len(self.masters) // 2:\n                        validity_time = self.auto_release_time\n                        validity_time -= self.__drift()\n                        validity_time -= timer.elapsed() / 1000\n                        if validity_time > 0:\n                            return True\n\n        with contextlib.suppress(ReleaseUnlockedLock):\n            self.__release(raise_on_redis_errors=raise_on_redis_errors)\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        return False\n\n    __acquire_masters = _acquire_masters\n\n    def acquire(self,\n                *,\n                blocking: bool = True,\n                timeout: float = -1,\n                raise_on_redis_errors: bool | None = None,\n                ) -> bool:\n        '''Lock the lock.\n\n        If blocking is True and timeout is -1, then wait for as long as\n        necessary to acquire the lock.  Return True.\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock_1 = Redlock(key='printer', masters={redis}, auto_release_time=.2)\n            >>> printer_lock_1.acquire()\n            True\n            >>> timer = ContextTimer()\n            >>> timer.start()\n            >>> printer_lock_2 = Redlock(key='printer', masters={redis})\n            >>> printer_lock_2.acquire()\n            True\n            >>> timer.elapsed() > printer_lock_1.auto_release_time * 1000\n            True\n            >>> printer_lock_2.release()\n\n        If blocking is True and timeout is not -1, then wait for up to timeout\n        seconds to acquire the lock.  Return True if the lock was acquired;\n        False if it wasn't.\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> printer_lock_2.acquire(timeout=.5)\n            True\n            >>> printer_lock_2.release()\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> printer_lock_2.acquire(timeout=.1)\n            False\n            >>> with contextlib.suppress(ReleaseUnlockedLock):\n            ...     printer_lock_1.release()\n\n        If blocking is False and timeout is -1, then try just once right now to\n        acquire the lock.  Return True if the lock was acquired; False if it\n        wasn't.\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> printer_lock_2.acquire(blocking=False)\n            False\n            >>> printer_lock_1.release()\n        '''\n        acquire_masters = functools.partial(\n            self.__acquire_masters,\n            raise_on_redis_errors=raise_on_redis_errors,\n        )\n\n        if blocking:\n            enqueued = False\n            with ContextTimer() as timer:\n                while timeout == -1 or timer.elapsed() / 1000 < timeout:\n                    if acquire_masters():\n                        if enqueued:\n                            self.__log_time_enqueued(timer, True)\n                        return True\n                    enqueued = True\n                    delay = random.uniform(0, self._RETRY_DELAY)  # nosec\n                    time.sleep(delay)\n            if enqueued:  # pragma: no cover\n                self.__log_time_enqueued(timer, False)\n            return False  # pragma: no cover\n\n        if timeout == -1:\n            return acquire_masters()\n\n        raise ValueError(\"can't specify a timeout for a non-blocking call\")\n\n    __acquire = acquire\n\n    def __log_time_enqueued(self, timer: ContextTimer, acquired: bool) -> None:\n        key_suffix = self.key.split(':', maxsplit=1)[1]\n        time_enqueued = math.ceil(timer.elapsed())\n        logger.info(\n            'source=pottery sample#redlock.enqueued.%s=%dms sample#redlock.acquired.%s=%d',\n            key_suffix,\n            time_enqueued,\n            key_suffix,\n            acquired,\n        )\n\n    def locked(self, *, raise_on_redis_errors: bool | None = None) -> float:\n        '''How much longer we'll hold the lock (unless we extend or release it).\n\n        If we don't currently hold the lock, then this method returns 0.\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock_1 = Redlock(key='printer', masters={redis})\n            >>> printer_lock_1.locked()\n            0\n\n            >>> printer_lock_2 = Redlock(key='printer', masters={redis})\n            >>> printer_lock_2.acquire()\n            True\n            >>> printer_lock_1.locked()\n            0\n            >>> printer_lock_2.release()\n\n        If we do currently hold the lock, then this method returns the current\n        lease's Time To Live (TTL) in ms.\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> 9 < printer_lock_1.locked() < 10\n            True\n            >>> printer_lock_1.release()\n        '''\n        with ContextTimer() as timer, BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__acquired_master, master)\n                futures.add(future)\n\n            ttls, redis_errors = [], []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    ttl = future.result() / 1000\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.locked() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if ttl:\n                        ttls.append(ttl)\n                        if len(ttls) > len(self.masters) // 2:  # pragma: no cover\n                            validity_time = min(ttls)\n                            validity_time -= self.__drift()\n                            validity_time -= timer.elapsed() / 1000\n                            return max(validity_time, 0)\n\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        return 0\n\n    def extend(self, *, raise_on_redis_errors: bool | None = None) -> None:\n        '''Extend our hold on the lock (if we currently hold it).\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock = Redlock(key='printer', masters={redis})\n            >>> printer_lock.acquire()\n            True\n            >>> 9 < printer_lock.locked() < 10\n            True\n            >>> time.sleep(1)\n            >>> 8 < printer_lock.locked() < 9\n            True\n            >>> printer_lock.extend()\n            >>> 9 < printer_lock.locked() < 10\n            True\n            >>> printer_lock.release()\n        '''\n        if self._extension_num >= self.num_extensions:\n            raise TooManyExtensions(self.key, self.masters)\n\n        with BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__extend_master, master)\n                futures.add(future)\n\n            num_masters_extended, redis_errors = 0, []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    num_masters_extended += future.result()\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.extend() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if num_masters_extended > len(self.masters) // 2:\n                        self._extension_num += 1\n                        return\n\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        raise ExtendUnlockedLock(\n            self.key,\n            self.masters,\n            redis_errors=redis_errors,\n        )\n\n    def release(self, *, raise_on_redis_errors: bool | None = None) -> None:\n        '''Unlock the lock.\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock = Redlock(key='printer', masters={redis})\n            >>> bool(printer_lock.locked())\n            False\n            >>> printer_lock.acquire()\n            True\n            >>> bool(printer_lock.locked())\n            True\n            >>> printer_lock.release()\n            >>> bool(printer_lock.locked())\n            False\n        '''\n        with BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__release_master, master)\n                futures.add(future)\n\n            num_masters_released, redis_errors = 0, []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    num_masters_released += future.result()\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.release() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if num_masters_released > len(self.masters) // 2:\n                        return\n\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        raise ReleaseUnlockedLock(\n            self.key,\n            self.masters,\n            redis_errors=redis_errors,\n        )\n\n    __release = release\n\n    def __enter__(self) -> Redlock:\n        '''You can use a Redlock as a context manager.\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> with Redlock(key='printer', masters={redis}) as printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n\n            >>> with printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n        '''\n        acquired = self.__acquire(\n            blocking=self.context_manager_blocking,\n            timeout=self.context_manager_timeout,\n        )\n        if acquired:\n            return self\n        raise QuorumNotAchieved(self.key, self.masters)\n\n    @overload\n    def __exit__(self,\n                 exc_type: None,\n                 exc_value: None,\n                 exc_traceback: None,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    @overload\n    def __exit__(self,\n                 exc_type: Type[BaseException],\n                 exc_value: BaseException,\n                 exc_traceback: TracebackType,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    def __exit__(self,\n                 exc_type: Type[BaseException] | None,\n                 exc_value: BaseException | None,\n                 traceback: TracebackType | None,\n                 ) -> Literal[False]:\n        '''You can use a Redlock as a context manager.\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> with Redlock(key='printer', masters={redis}) as printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n\n            >>> with printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n        '''\n        self.__release()\n        return False\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} key={self.key}>'\ntests/base.py\nclass TestCase(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls) -> None:\n        logger.setLevel(logging.CRITICAL)\n        warnings.filterwarnings('ignore', category=PotteryWarning)\n\n    def setUp(self) -> None:\n        super().setUp()\n\n        # Choose a random Redis database for this test.\n        self.redis_db = random.randint(1, 15)  # nosec\n        self.redis_url = f'redis://localhost:6379/{self.redis_db}'\n\n        # Set up our Redis clients.\n        self.redis = Redis.from_url(self.redis_url, socket_timeout=1)\n        self.redis_decoded_responses = Redis.from_url(\n            self.redis_url,\n            socket_timeout=1,\n            decode_responses=True,\n        )\n\n        # Clean up the Redis database before and after the test.\n        self.redis.flushdb()\n        self.addCleanup(self.redis.flushdb)\npottery/exceptions.py\nclass QuorumIsImpossible(PrimitiveError, RuntimeError):\n    'Too many Redis masters threw RedisErrors; quorum can not be achieved.'\npottery/redlock.py\ndef synchronize(*,\n                key: str,\n                masters: Iterable[Redis] = frozenset(),\n                raise_on_redis_errors: bool = False,\n                auto_release_time: float = Redlock._AUTO_RELEASE_TIME,\n                blocking: bool = True,\n                timeout: float = -1,\n                ) -> Callable[[F], F]:\n    '''Decorator to synchronize a function's execution across threads.\n\n    synchronize() is a decorator that allows only one thread to execute a\n    function at a time.  Under the hood, synchronize() uses a Redlock.  See\n    help(Redlock) for more details.\n\n    Keyword arguments:\n        key -- a string that identifies your resource\n        masters -- the Redis clients used to achieve quorum for this Redlock's\n            state\n        raise_on_redis_errors -- whether to raise the QuorumIsImplssible\n            exception when too many Redis masters throw errors\n        auto_release_time -- the timeout in seconds by which to automatically\n            release this Redlock, unless it's already been released\n        num_extensions -- the number of times that this Redlock's lease can be\n            extended\n        context_manager_blocking -- when using this Redlock as a context\n            manager, whether to block when acquiring\n        context_manager_timeout -- if context_manager_blocking, how long to wait\n            when acquiring before giving up and raising the QuorumNotAchieved\n            exception\n\n    Usage:\n\n        >>> @synchronize(key='synchronized-func', auto_release_time=1.5)\n        ... def func():\n        ...     # Only one thread can execute this function at a time.\n        ...     return True\n        ...\n        >>> func()\n        True\n    '''\n    RedlockFactory = functools.partial(\n        Redlock,\n        key=key,\n        masters=masters,\n        raise_on_redis_errors=raise_on_redis_errors,\n        auto_release_time=auto_release_time,\n        context_manager_blocking=blocking,\n        context_manager_timeout=timeout,\n    )\n\n    def decorator(func: F) -> F:\n        @functools.wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            redlock = RedlockFactory()\n            waiting_timer, holding_timer = ContextTimer(), ContextTimer()\n\n            try:\n                waiting_timer.start()\n                with redlock:\n                    waiting_timer.stop()\n                    holding_timer.start()\n                    return_value = func(*args, **kwargs)\n                holding_timer.stop()\n            finally:\n                _log_synchronize(func, redlock, waiting_timer, holding_timer)\n\n            return return_value\n        return cast(F, wrapper)\n    return decorator\npottery/exceptions.py\nclass TooManyExtensions(PrimitiveError, RuntimeError):\n    'Redlock has been extended too many times.'\n", "answers": ["        with self.assertRaises(TooManyExtensions):"], "length": 2794, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "c23c39e861f028aa9df65fe01489651a3c7237aeec7f80b4"}
{"input": "from ctypes import *\nfrom .cone_settings import ConeSettings\nfrom .enums import OPENSTATE, SOUND_FORMAT, SOUND_TYPE, TIMEUNIT\nfrom .flags import MODE\nfrom .fmodobject import FmodObject, _dll\nfrom .globalvars import get_class\nfrom .structobject import Structobject as so\nfrom .structures import TAG, VECTOR\nfrom .utils import check_type, ckresult, prepare_str\n\"\"\"Container for sample data that can be played on a\n:py:class:`~pyfmodex.channel.Channel`.\n\"\"\"\n\n# pylint: disable=too-many-public-methods\n# That's not our fault... :-)\n\n\n\n\nclass Sound(FmodObject):\n    \"\"\"Container for sample data that can be played on a\n    :py:class:`~pyfmodex.channel.Channel`.\n    \"\"\"\n\n    def add_sync_point(self, offset, offset_type, name):\n        \"\"\"Add a sync point at a specific time within the sound.\n\n        :param int offset: Offset value.\n        :param TIMEUNIT offset_type: Offset unit type.\n        :param str name: Sync point name.\n        :returns: Sync point.\n        \"\"\"\n        name = prepare_str(name, \"ascii\")\n        s_ptr = c_void_p()\n        self._call_fmod(\n            \"FMOD_Sound_AddSyncPoint\", offset, offset_type.value, name, byref(s_ptr)\n        )\n        return s_ptr.value\n\n    def delete_sync_point(self, point):\n        \"\"\"Delete a sync point within the sound.\n\n        :param point: Sync point.\n        \"\"\"\n        self._call_fmod(\"FMOD_Sound_DeleteSyncPoint\", c_void_p(point))\n\n    @property\n    def threed_cone_settings(self):\n        \"\"\"The inside and outside angles of the 3D projection cone and the\n        outside volume.\n\n        :type: ConeSettings\n        \"\"\"\n", "context": "pyfmodex/structures.py\nclass TAG(Structure):\n    \"\"\"Tag data / metadata description.\n\n    :ivar TAGTYPE type: Tag type.\n    :ivar TAGDATATYPE datatype: Tag data type.\n    :ivar str name: Name.\n    :ivar data: Tag data.\n    :ivar int datalen: Size of data.\n    :ivar bool updated: True if this tag has been updated since last being\n        accessed with :py:meth:`~pyfmodex.sound.Sound.get_tag`.\n    \"\"\"\n\n    _fields_ = [\n        (\"type\", c_int),\n        (\"datatype\", c_int),\n        (\"name\", c_char_p),\n        (\"data\", c_void_p),\n        (\"datalen\", c_uint),\n        (\"updated\", c_bool),\n    ]\npyfmodex/utils.py\ndef check_type(obj, cls, msg=\"Bad type of passed argument (%s), expected %s\"):\n    \"\"\"Verify if a given object is of a given type.\n\n    :param object obj: Object to verify.\n    :param class cls: Class to verify against.\n    :param str msg: Error message when TypeError is raised.\n    :raises TypeError: when object is not an instance of the expected class.\n    \"\"\"\n    if not isinstance(obj, cls):\n        raise TypeError(msg % (str(type(obj)), str(cls)))\npyfmodex/flags.py\nclass MODE(Flag):\n    \"\"\"Sound description bitfields, bitwise OR them together for loading and\n    describing sounds.\n\n    By default a sound will open as a static sound that is decompressed fully\n    into memory to PCM (i.e. equivalent of :py:attr:`CREATESAMPLE`). To have a\n    sound stream instead, use :py:attr:`CREATESTREAM`, or use the wrapper\n    function :py:meth:`~pyfmodex.system.System.create_stream`.\n\n    Some opening modes (i.e. :py:attr:`OPENUSER`, :py:attr:`OPENMEMORY`,\n    :py:attr:`OPENMEMORY_POINT`, :py:attr:`OPENRAW`) will need extra\n    information. This can be provided using the\n    :py:class:`~pyfmodex.structure_declarations.CREATESOUNDEXINFO` structure.\n\n    Specifying :py:attr:`OPENMEMORY_POINT` will POINT to your memory rather\n    allocating its own sound buffers and duplicating it internally. This means\n    you cannot free the memory while FMOD is using it, until after\n    :py:meth:`~pyfmodex.sound.Sound.release` is called.\n\n    With :py:attr:`OPENMEMORY_POINT`, for PCM formats, only WAV, FSB, and RAW\n    are supported. For compressed formats, only those formats supported by\n    :py:attr:`CREATECOMPRESSEDSAMPLE` are supported.\n\n    With :py:attr:`OPENMEMORY_POINT` and :py:attr:`OPENRAW` or PCM, if using\n    them together, note that you must pad the data on each side by 16 bytes.\n    This is so fmod can modify the ends of the data for looping / interpolation\n    / mixing purposes. If a wav file, you will need to insert silence, and then\n    reset loop points to stop the playback from playing that silence.\n    \"\"\"\n\n    #: Default for all modes listed below: :py:attr:`LOOP_OFF`,\n    #: :py:attr:`TWOD`, :py:attr:`THREED_WORLDRELATIVE`,\n    #: :py:attr:`THREED_INVERSEROLLOFF`.\n    DEFAULT = 0x0\n\n    #: For non looping sounds. (DEFAULT). Overrides :py:attr:`LOOP_NORMAL` /\n    #: :py:attr:`LOOP_BIDI`.\n    LOOP_OFF = 0x00000001\n\n    #: For forward looping sounds.\n    LOOP_NORMAL = 0x00000002\n\n    #: For bidirectional looping sounds. (only works on software mixed static\n    # sounds).\n    LOOP_BIDI = 0x00000004\n\n    #: Ignores any 3D processing. (DEFAULT).\n    TWOD = 0x00000008\n\n    #: Makes the sound positionable in 3D. Overrides :py:attr:`TWOD`.\n    THREED = 0x00000010\n\n    #: Decompress at runtime, streaming from the source provided (i.e. from\n    #: disk). Overrides :py:attr:`CREATESAMPLE` and\n    #: :py:attr:`CREATECOMPRESSEDSAMPLE`. Note a stream can only be played once\n    #: at a time due to a stream only having one stream buffer and file handle.\n    #: Open multiple streams to have them play concurrently.\n    CREATESTREAM = 0x00000080\n\n    #: Decompress at loadtime, decompressing or decoding whole file into memory\n    #: as the target sample format (ie PCM). Fastest for playback and most\n    #: flexible.\n    CREATESAMPLE = 0x00000100\n\n    #: Load MP2/MP3/FADPCM/IMAADPCM/Vorbis/AT9 or XMA into memory and leave it\n    #: compressed. Vorbis/AT9/FADPCM encoding only supported in the .FSB\n    #: container format. During playback the FMOD software mixer will decode it\n    #: in realtime as a 'compressed sample'. Overrides :py:attr:`CREATESAMPLE`.\n    #: If the sound data is not one of the supported formats, it will behave as\n    #: if it was created with :py:attr:`CREATESAMPLE` and decode the sound into\n    #: PCM.\n    CREATECOMPRESSEDSAMPLE = 0x00000200\n\n    #: Opens a user created static sample or stream. Use the\n    #: :py:class:`~pyfmodex.structure_declarations.CREATESOUNDEXINFO` structure\n    #: to specify format, defaultfrequency, numchannels, and optionally a read\n    #: callback. If a user created 'sample' is created with no read callback,\n    #: the sample will be empty. Use :py:meth:`~pyfmodex.sound.Sound.lock` and\n    #: :py:meth:`~pyfmodex.sound.Sound.unlock` to place sound data into the\n    #: sound if this is the case.\n    OPENUSER = 0x00000400\n\n    #: \"name_or_data\" will be interpreted as a pointer to memory instead of\n    #: filename for creating sounds. Use the\n    #: :py:class:`~pyfmodex.structure_declarations.CREATESOUNDEXINFO` structure\n    #: to specify length. If used with :py:attr:`CREATESAMPLE` or\n    #: :py:attr:`CREATECOMPRESSEDSAMPLE`, FMOD duplicates the memory into its\n    #: own buffers. Your own buffer can be freed after open, unless you are\n    #: using :py:attr:`NONBLOCKING`. Then, wait until the Sound is in the\n    #: :py:attr:`OPENSTATE_READY` state. If used with :py:attr:`CREATESTREAM`,\n    #: FMOD will stream out of the buffer whose pointer you passed in. In this\n    #: case, your own buffer should not be freed until you have finished with\n    #: and released the stream.\n    OPENMEMORY = 0x00000800\n\n    #: \"name_or_data\" will be interpreted as a pointer to memory instead of\n    #: filename for creating sounds. Use the\n    #: :py:class:`~pyfmodex.structure_declarations.CREATESOUNDEXINFO` structure\n    #: to specify length. This differs to :py:attr:`OPENMEMORY` in that it uses\n    #: the memory as is, without duplicating the memory into its own buffers.\n    #: Cannot be freed after open, only after Sound::release. Will not work if\n    #: the data is compressed and :py:attr:`CREATECOMPRESSEDSAMPLE` is not\n    #: used. Cannot be used in conjunction with\n    #: :py:attr:`~pyfmodex.structure_declarations.CREATESOUNDEXINFO.encryptionkey`.\n    OPENMEMORY_POINT = 0x10000000\n\n    #: Will ignore file format and treat as raw pcm. Use the\n    #: :py:class:`~pyfmodex.structure_declarations.CREATESOUNDEXINFO` structure\n    #: to specify format. Requires at least defaultfrequency, numchannels and\n    #: format to be specified before it will open. Must be little endian data.\n    OPENRAW = 0x00001000\n\n    #: Just open the file, don't prebuffer or read. Good for fast opens for\n    #: info, or when :py:meth:`~pyfmodex.sound.Sound.read_data` is to be used.\n    OPENONLY = 0x00002000\n\n    #: For :py:meth:`~pyfmodex.system.System.create_sound` - for accurate\n    #: :py:meth:`~pyfmodex.sound.Sound.get_length` /\n    #: :py:meth:`~pyfmodex.channel.Channel.set_position` on VBR MP3, and\n    #: MOD/S3M/XM/IT/MIDI files. Scans file first, so takes longer to open.\n    #: :py:attr:`OPENONLY` does not affect this.\n    ACCURATETIME = 0x00004000\n\n    #: For corrupted / bad MP3 files. This will search all the way through the\n    #: file until it hits a valid MPEG header. Normally only searches for 4K.\n    MPEGSEARCH = 0x00008000\n\n    #: For opening sounds and getting streamed subsounds (seeking)\n    #: asynchronously. Use :py:attr:`~pyfmodex.sound.Sound.open_state` to poll\n    #: the state of the sound as it opens or retrieves the subsound in the\n    #: background.\n    NONBLOCKING = 0x00010000\n\n    #: Unique sound, can only be played one at a time\n    UNIQUE = 0x00020000\n\n    #: Make the sound's position, velocity and orientation relative to the\n    #: listener.\n    THREED_HEADRELATIVE = 0x00040000\n\n    #: Make the sound position, velocity and orientation absolute (relative\n    #: to the world). (DEFAULT)\n    THREED_WORLDRELATIVE = 0x00080000\n\n    #: This sound will follow the inverse rolloff model where mindistance =\n    #: full volume, maxdistance = where sound stops attenuating, and rolloff is\n    #: fixed according to the global rolloff factor. (DEFAULT)\n    THREED_INVERSEROLLOFF = 0x00100000\n\n    #: This sound will follow a linear rolloff model where mindistance = full\n    #: volume, maxdistance = silence.\n    THREED_LINEARROLLOFF = 0x00200000\n\n    #: This sound will follow a linear-square rolloff model where mindistance =\n    #: full volume, maxdistance = silence.\n    THREED_LINEARSQUAREROLLOFF = 0x00400000\n\n    #: This sound will follow the inverse rolloff model at distances close to\n    #: mindistance and a linear-square rolloff close to maxdistance.\n    THREED_INVERSETAPEREDROLLOFF = 0x00800000\n\n    #: This sound will follow a rolloff model defined by\n    #: :py:attr:`~pyfmodex.sound.Sound.custom_rolloff`.\n    THREED_CUSTOMROLLOFF = 0x04000000\n\n    #: This sonds is not be affected by geometry occlusion. If not specified in\n    #: :py:attr:`~pyfmodex.sound.Sound.mode`, or\n    #: :py:attr:`~pyfmodex.channel_control.ChannelControl.mode`, the flag is\n    #: cleared and it is affected by geometry again.\n    THREED_IGNOREGEOMETRY = 0x40000000\n\n    #: Skips id3v2/asf/etc tag checks when opening a sound, to reduce seek/read\n    #: overhead when opening files.\n    IGNORETAGS = 0x02000000\n\n    #: Removes some features from samples to give a lower memory overhead, like\n    #: :py:attr:`~pyfmodex.sound.Sound.name`.\n    LOWMEM = 0x08000000\n\n    #: For sounds that start virtual (due to being quiet or low importance),\n    #: instead of swapping back to audible, and playing at the correct offset\n    #: according to time, this flag makes the sound play from the start.\n    VIRTUAL_PLAYFROMSTART = 0x80000000\npyfmodex/fmodobject.py\nclass FmodObject(object):\n    def __init__(self, ptr):\n    def _call_fmod(self, funcname, *args):\n    def __eq__(self, other):\npyfmodex/enums.py\nclass TIMEUNIT(Enum):\n    \"\"\"Time types used for position or length.\"\"\"\n\n    MS = 0x00000001  #: Milliseconds.\n\n    #: PCM samples, related to milliseconds * samplerate / 1000.\n    PCM = 0x00000002\n\n    #: Bytes, related to PCM samples * channels * datawidth (ie 16bit = 2\n    #: bytes).\n    PCMBYTES = 0x00000004\n\n    #: Raw file bytes of (compressed) sound data (does not include headers).\n    #: Only used by :py:meth:`~pyfmodex.sound.Sound.get_length` and\n    #: :py:meth:`~pyfmodex.channel.Channel.get_position`.\n    RAWBYTES = 0x00000008\n\n    #: Fractions of one PCM sample. Unsigned int range 0 to 0xFFFFFFFF. Used for\n    #: sub-sample granularity for :py:class:`~pyfmodex.dsp.DSP` purposes.\n    PCMFRACTION = 0x00000010\n\n    #: MOD/S3M/XM/IT. Order in a sequenced module format. Use\n    #: :py:attr:`~pyfmodex.sound.Sound.format` to determine the PCM format\n    #: being decoded to.\n    MODORDER = 0x00000100\n\n    #: MOD/S3M/XM/IT. Current row in a sequenced module format. Cannot use with\n    #: :py:meth:`~pyfmodex.channel.Channel.set_position`.\n    #: :py:meth:`~pyfmodex.sound.Sound.get_length` will return the number of\n    #: rows in the currently playing or seeked to pattern.\n    MODROW = 0x00000200\n\n    #: MOD/S3M/XM/IT. Current pattern in a sequenced module format. Cannot use\n    #: with :py:meth:`~pyfmodex.channel.Channel.set_position`.\n    #: :py:meth:`~pyfmodex.sound.Sound.get_length` will return the number of\n    #: patterns in the song and\n    #: :py:meth:`~pyfmodex.channel.Channel.get_position` will return the\n    #: currently playing pattern.\n    MODPATTERN = 0x00000400\npyfmodex/utils.py\ndef ckresult(result):\n    \"\"\"Check if the result of our C API call is OK.\n\n    :param RESULT result: C API call return code.\n    :raises FmodError: when return code from C API call is not OK.\n    \"\"\"\n    result = RESULT(result)\n    if result is not RESULT.OK:\n        raise FmodError(result)\npyfmodex/structures.py\nclass VECTOR(Structure):\n    \"\"\"Structure describing a point in 3D space.\n\n    FMOD uses a left handed coordinate system by default. To use a right handed\n    coordinate system specify\n    :py:attr:`~pyfmodex.flags.INIT_FLAGS.THREED_RIGHTHANDED` in\n    :py:meth:`~pyfmodex.system.System.init`.\n\n    :ivar float x: X coordinate in 3D space.\n    :ivar float y: Y coordinate in 3D space.\n    :ivar float z: Z coordinate in 3D space.\n    \"\"\"\n\n    _fields_ = [(\"x\", c_float), (\"y\", c_float), (\"z\", c_float)]\n\n    @staticmethod\n    def from_list(lst):\n        \"\"\"Instantiate a VECTOR from a list with three coordinate floats.\"\"\"\n        vec = VECTOR()\n        vec.x = lst[0]\n        vec.y = lst[1]\n        vec.z = lst[2]\n        return vec\n\n    def to_list(self):\n        \"\"\"The VECTOR as a list of three coordinate floats.\"\"\"\n        return [self.x, self.y, self.z]\npyfmodex/enums.py\nclass OPENSTATE(Enum):\n    \"\"\"These values describe what state a sound is in after the\n    :py:class:`~pyfmodex.flags.MODE` flag NONBLOCKING has been used to open it.\n\n    With streams, if you are using the :py:class:`~pyfmodex.flags.MODE` flag\n    NONBLOCKING, note that if the user calls\n    :py:meth:`~pyfmodex.sound.Sound.get_subsound`, a stream will go into\n    :py:attr:`SEEKING` state and sound related commands will raise\n    :py:exc:`~pyfmodex.exceptions.FmodError` with code\n    :py:attr:`~RESULT.NOTREADY`.\n\n    With streams, if you are using the :py:class:`~pyfmodex.flags.MODE` flag\n    NONBLOCKING, note that if the user calls\n    :py:meth:`~pyfmodex.channel.Channel.get_position`, a stream will go into\n    :py:attr:`SETPOSITION` state and sound related commands will raise\n    :py:exc:`~pyfmodex.exceptions.FmodError` with code\n    :py:attr:`~RESULT.NOTREADY`.\n    \"\"\"\n\n    READY = 0  #: Opened and ready to play.\n    LOADING = 1  #: Initial load in progress.\n\n    #: Failed to open - file not found, out of memory etc. See\n    #: :py:exc:`~pyfmodex.exceptions.FmodError` code from\n    #: :py:attr:`~pyfmodex.sound.Sound.open_state` for what happened.\n    ERROR = 2\n\n    CONNECTING = 3  #: Connecting to remote host (Internet sounds only).\n    BUFFERING = 4  #: Buffering data.\n    SEEKING = 5  #: Seeking to subsound and re-flushing stream buffer.\n\n    #: Ready and playing, but not possible to release at this time without\n    #: stalling the main thread.\n    PLAYING = 6\n\n    SETPOSITION = 7  #: Seeking within a stream to a different position.\n    MAX = 8  #: Maximum number of open state types.\npyfmodex/cone_settings.py\nclass ConeSettings:\n    \"\"\"Convenience wrapper class to handle 3D cone shape settings for simulated\n    occlusion which is based on direction.\n    \"\"\"\n\n    def __init__(self, sptr, class_name):\n        \"\"\"Constructor.\n\n        Creates ConeSettings for an FMOD object.\n\n        Usually not called directly, but through the\n        `cone_settings` or `threed_cone_settings` property of an FMOD object.\n\n        The :py:class:`~pyfmodex.flags.MODE` flag THREED must be set on this\n        object otherwise :py:const:`~pyfmodex.enums.RESULT.NEEDS3D` is\n        returned.\n\n        When\n        :py:meth:`~pyfmodex.channel_control.ChannelControl.cone_orientation` is\n        set and a 3D 'cone' is set up, attenuation will automatically occur for\n        a sound based on the relative angle of the direction the cone is\n        facing, vs the angle between the sound and the listener.\n\n        - If the relative angle is within the :py:attr:`inside_angle`, the\n          sound will not have any attenuation applied.\n        - If the relative angle is between the :py:attr:`inside_angle` and\n          :py:attr:`outside_angle`, linear volume attenuation (between 1 and\n          :py:attr:`outside_volume`) is applied between the two angles until it\n          reaches the :py:attr:`outside_angle`.\n        - If the relative angle is outside of the :py:attr:`outside_angle`\n          the volume does not attenuate any further.\n\n        :param sptr: pointer of the object having cone settings.\n        :param class_name: class of the object having cone settings (Channel or\n            ChannelGroup)\n        \"\"\"\n        self._sptr = sptr\n        self._in = c_float()\n        self._out = c_float()\n        self._outvol = c_float()\n        self._get_func = \"FMOD_%s_Get3DConeSettings\" % class_name\n        self._set_func = \"FMOD_%s_Set3DConeSettings\" % class_name\n        ckresult(\n            getattr(_dll, self._get_func)(\n                self._sptr, byref(self._in), byref(self._out), byref(self._outvol)\n            )\n        )\n\n    @property\n    def inside_angle(self):\n        \"\"\"Inside cone angle.\n\n        This is the angle spread within which the sound is unattenuated.\n        Between 0 and 360.\n\n        :type: int\n        \"\"\"\n        return self._in.value\n\n    @inside_angle.setter\n    def inside_angle(self, angle):\n        self._in = c_float(angle)\n        self._commit()\n\n    @property\n    def outside_angle(self):\n        \"\"\"Outside cone angle.\n\n        This is the angle spread outside of which the sound is attenuated to\n        its :py:attr:`outside_volume`. Between 0 and 360.\n\n        :type: int\n        \"\"\"\n        return self._out.value\n\n    @outside_angle.setter\n    def outside_angle(self, angle):\n        self._out = c_float(angle)\n        self._commit()\n\n    @property\n    def outside_volume(self):\n        \"\"\"Cone outside volume.\n\n        Between 0 and 1.\n\n        :type: float\n        \"\"\"\n        return self._outvol.value\n\n    @outside_volume.setter\n    def outside_volume(self, vol):\n        self._outvol = c_float(vol)\n        self._commit()\n\n    def _commit(self):\n        \"\"\"Apply a changed code setting.\"\"\"\n        ckresult(\n            getattr(_dll, self._set_func)(self._sptr, self._in, self._out, self._outvol)\n        )\npyfmodex/enums.py\nclass SOUND_TYPE(Enum):\n    \"\"\"These definitions describe the type of song being played.\"\"\"\n\n    UNKNOWN = 0  #: 3rd party / unknown plugin format.\n    AIFF = 1  #: AIFF.\n    ASF = 2  #: Microsoft Advanced Systems Format (i.e. WMA/ASF/WMV).\n    DLS = 3  #: Sound font / downloadable sound bank.\n    FLAC = 4  #: FLAC lossless codec.\n    FSB = 5  #: FMOD Sample Bank.\n    IT = 6  #: Impulse Tracker.\n    MIDI = 7  #: MIDI.\n    MOD = 8  #: Protracker / Fasttracker MOD.\n    MPEG = 9  #: MP2/MP3 MPEG.\n    OGGVORBIS = 10  #: Ogg vorbis.\n    PLAYLIST = 11  #: Information only from ASX/PLS/M3U/WAX playlists.\n    RAW = 12  #: Raw PCM data.\n    S3M = 13  #: ScreamTracker 3.\n    USER = 14  #: User created sound.\n    WAV = 15  #: Microsoft WAV.\n    XM = 16  #: FastTracker 2 XM.\n    XMA = 17  #: Xbox One XMA\n    AUDIOQUEUE = 18  #: iPhone hardware decoder, supports AAC, ALAC and MP3.\n    AT9 = 19  #: PS4 ATRAC 9 format.\n    VORBIS = 20  #: Vorbis.\n    MEDIA_FOUNDATION = 21  #: Windows Store Application built in system codecs.\n    MEDIACODEC = 22  #: Android MediaCodec\n    FADPCM = 23  #: FMOD Adaptive Differential Pulse Code Modulation.\n    OPUS = 24  #: Opus.\n    MAX = 25  #: Maximum number of sound types supported.\npyfmodex/enums.py\nclass SOUND_FORMAT(Enum):\n    \"\"\"These definitions describe the native format of the hardware or software\n    buffer that will be used.\n    \"\"\"\n\n    NONE = 0  #: Uninitalized / unknown.\n    PCM8 = 1  #: 8bit integer PCM data.\n    PCM16 = 2  #: 16bit integer PCM data.\n    PCM24 = 3  #: 24bit integer PCM data.\n    PCM32 = 4  #: 32bit integer PCM data.\n    PCMFLOAT = 5  #: 32bit floating point PCM data.\n\n    #: Sound data is in its native compressed format. See\n    #: :py:class:`~pyfmodex.flags.MODE` flag CREATECOMPRESSEDSAMPLE.\n    BITSTREAM = 6\n\n    MAX = 7  #: Maximum number of sound formats supported.\npyfmodex/utils.py\ndef prepare_str(string, encoding=None):\n    \"\"\"Encode a string to the file system encoding of our host.\n\n    Does nothing if string cannot be encoded.\n\n    :param str string: String to encode.\n    :param str encoding: Override encoding to use instead of native file system\n        encoding.\n    :returns: Encoded string.\n    :rtype: str\n    \"\"\"\n    if not encoding:\n        encoding = sys.getfilesystemencoding()\n    if hasattr(string, \"encode\"):\n        return string.encode(encoding)\n    return string\npyfmodex/structobject.py\nclass Structobject:\n    \"\"\"A 'bag' with keyword initialization, dict-semantics emulation and key\n    iteration.\n    \"\"\"\n\n    def __init__(self, **kw):\n        \"\"\"Initialize, and set attributes from all keyword arguments.\"\"\"\n        self.__members = []\n        for k in list(kw.keys()):\n            setattr(self, k, kw[k])\n            self.__remember(k)\n\n    def __remember(self, k):\n        \"\"\"Add k to the list of explicitly set values.\"\"\"\n        if k not in self.__members:\n            self.__members.append(k)\n\n    def __getitem__(self, key):\n        \"\"\"Equivalent of dict access by key.\"\"\"\n        try:\n            return getattr(self, key)\n        except AttributeError as attrerr:\n            raise KeyError(key) from attrerr\n\n    def __setitem__(self, key, value):\n        setattr(self, key, value)\n        self.__remember(key)\n\n    def has_key(self, key):\n        \"\"\"wheter this Structobject contains a value for the given key.\n\n        :rtype: bool\n        \"\"\"\n        return hasattr(self, key)\n\n    def keys(self):\n        \"\"\"All keys this Structobject has values for.\n\n        :rtype: list\n        \"\"\"\n        return self.__members\n\n    def iterkeys(self):\n        \"\"\"All keys this Structobject has values for.\n\n        :rtype: list\n        \"\"\"\n        return self.__members\n\n    def __iter__(self):\n        return iter(self.__members)\n\n    def __str__(self):\n        \"\"\"Describe those attributes explicitly set.\"\"\"\n        string = \"\"\n        for member in self.__members:\n            value = getattr(self, member)\n            if string:\n                string += \", \"\n            string += \"%string: %string\" % (member, repr(value))\n        return string\npyfmodex/globalvars.py\ndef get_class(classname):\n    \"\"\"Get the class object from the given string.\n\n    :param str classname: Class name.\n    :rtype: class\n    \"\"\"\n    return class_list[classname]\n", "answers": ["        return ConeSettings(self._ptr, self.__class__.__name__)"], "length": 2866, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "255975e85de5593ce3a5a78f2aeb7341f18b71db96e2d86a"}
{"input": "import abc\nimport binascii\nimport calendar\nimport copy\nimport hashlib\nimport os\nimport re\nimport six\nfrom datetime import datetime\nfrom cryptography.hazmat.primitives import constant_time\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom .fields import DSAPriv, DSAPub, DSASignature\nfrom .fields import ECDSAPub, ECDSAPriv, ECDSASignature\nfrom .fields import ECDHPub, ECDHPriv, ECDHCipherText\nfrom .fields import ElGCipherText, ElGPriv, ElGPub\nfrom .fields import OpaquePubKey\nfrom .fields import OpaquePrivKey\nfrom .fields import RSACipherText, RSAPriv, RSAPub, RSASignature\nfrom .fields import String2Key\nfrom .fields import SubPackets\nfrom .fields import UserAttributeSubPackets\nfrom .types import Packet\nfrom .types import Primary\nfrom .types import Private\nfrom .types import Public\nfrom .types import Sub\nfrom .types import VersionedPacket\nfrom ..constants import CompressionAlgorithm\nfrom ..constants import HashAlgorithm\nfrom ..constants import PubKeyAlgorithm\nfrom ..constants import SignatureType\nfrom ..constants import SymmetricKeyAlgorithm\nfrom ..constants import TrustFlags\nfrom ..constants import TrustLevel\nfrom ..decorators import sdproperty\nfrom ..errors import PGPDecryptionError\nfrom ..symenc import _decrypt\nfrom ..symenc import _encrypt\nfrom ..types import Fingerprint\n        return self.keymaterial.verify(subj, sigbytes, hash_alg)\n\n    def parse(self, packet):\n        super(PubKeyV4, self).parse(packet)\n\n        self.created = packet[:4]\n        del packet[:4]\n\n        self.pkalg = packet[0]\n        del packet[0]\n\n        # bound keymaterial to the remaining length of the packet\n        pend = self.header.length - 6\n        self.keymaterial.parse(packet[:pend])\n        del packet[:pend]\n\n\nclass PrivKeyV4(PrivKey, PubKeyV4):\n    __ver__ = 4\n\n    @classmethod\n    def new(cls, key_algorithm, key_size):\n        # build a key packet\n        pk = PrivKeyV4()\n        pk.pkalg = key_algorithm\n        if pk.keymaterial is None:\n            raise NotImplementedError(key_algorithm)\n        pk.keymaterial._generate(key_size)\n        pk.update_hlen()\n        return pk\n\n    def pubkey(self):\n        # return a copy of ourselves, but just the public half\n        pk = PubKeyV4() if not isinstance(self, PrivSubKeyV4) else PubSubKeyV4()\n        pk.created = self.created\n        pk.pkalg = self.pkalg\n\n        # copy over MPIs\n        for pm in self.keymaterial.__pubfields__:\n            setattr(pk.keymaterial, pm, copy.copy(getattr(self.keymaterial, pm)))\n\n        if self.pkalg == PubKeyAlgorithm.ECDSA:\n            pk.keymaterial.oid = self.keymaterial.oid\n\n        if self.pkalg == PubKeyAlgorithm.ECDH:\n            pk.keymaterial.oid = self.keymaterial.oid\n            pk.keymaterial.kdf = copy.copy(self.keymaterial.kdf)\n\n        pk.update_hlen()\n        return pk\n\n    @property\n    def protected(self):\n        return bool(self.keymaterial.s2k)\n\n    @property\n    def unlocked(self):\n        if self.protected:\n            return 0 not in list(self.keymaterial)\n        return True  # pragma: no cover\n\n    def protect(self, passphrase, enc_alg, hash_alg):\n        self.keymaterial.encrypt_keyblob(passphrase, enc_alg, hash_alg)\n        del passphrase\n        self.update_hlen()\n\n    def unprotect(self, passphrase):\n        self.keymaterial.decrypt_keyblob(passphrase)\n        del passphrase\n\n    def sign(self, sigdata, hash_alg):\n        return self.keymaterial.sign(sigdata, hash_alg)\n\n\nclass PrivSubKey(VersionedPacket, Sub, Private):\n    __typeid__ = 0x07\n    __ver__ = 0\n\n\nclass PrivSubKeyV4(PrivSubKey, PrivKeyV4):\n    __ver__ = 4\n\n\nclass CompressedData(Packet):\n    \"\"\"\n    5.6.  Compressed Data Packet (Tag 8)\n\n    The Compressed Data packet contains compressed data.  Typically, this\n    packet is found as the contents of an encrypted packet, or following\n    a Signature or One-Pass Signature packet, and contains a literal data\n    packet.\n\n    The body of this packet consists of:\n\n     - One octet that gives the algorithm used to compress the packet.\n\n     - Compressed data, which makes up the remainder of the packet.\n\n    A Compressed Data Packet's body contains an block that compresses\n    some set of packets.  See section \"Packet Composition\" for details on\n    how messages are formed.\n\n    ZIP-compressed packets are compressed with raw RFC 1951 [RFC1951]\n    DEFLATE blocks.  Note that PGP V2.6 uses 13 bits of compression.  If\n    an implementation uses more bits of compression, PGP V2.6 cannot\n    decompress it.\n\n    ZLIB-compressed packets are compressed with RFC 1950 [RFC1950] ZLIB-\n    style blocks.\n\n    BZip2-compressed packets are compressed using the BZip2 [BZ2]\n    algorithm.\n    \"\"\"\n    __typeid__ = 0x08\n\n    @sdproperty\n    def calg(self):\n        return self._calg\n\n    @calg.register(int)\n", "context": "src/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDHPriv(ECDSAPriv, ECDHPub):\n    def __bytearray__(self):\n        _b = ECDHPub.__bytearray__(self)\n        _b += self.s2k.__bytearray__()\n        if not self.s2k:\n            _b += self.s.to_mpibytes()\n\n            if self.s2k.usage == 0:\n                _b += self.chksum\n\n        else:\n            _b += self.encbytes\n\n        return _b\n\n    def __len__(self):\n        # because of the inheritance used for this, ECDSAPub.__len__ is called instead of ECDHPub.__len__\n        # the only real difference is self.kdf, so we can just add that\n        return super(ECDHPriv, self).__len__() + len(self.kdf)\n\n    def _generate(self, oid):\n        ECDSAPriv._generate(self, oid)\n        self.kdf.halg = self.oid.kdf_halg\n        self.kdf.encalg = self.oid.kek_alg\n\n    def publen(self):\n        return ECDHPub.__len__(self)\n\n    def parse(self, packet):\n        ECDHPub.parse(self, packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.s = MPI(packet)\n\n            if self.s2k.usage == 0:\n                self.chksum = packet[:2]\n                del packet[:2]\n\n        else:\n            ##TODO: this needs to be bounded to the length of the encrypted key material\n            self.encbytes = packet\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Packet(Dispatchable):\n    __typeid__ = -1\n    __headercls__ = Header\n\n    def __init__(self):\n        super(Packet, self).__init__()\n        self.header = self.__headercls__()\n        if isinstance(self.__typeid__, six.integer_types):\n            self.header.tag = self.__typeid__\n\n    @abc.abstractmethod\n    def __bytearray__(self):\n        return self.header.__bytearray__()\n\n    def __len__(self):\n        return len(self.header) + self.header.length\n\n    def __repr__(self):\n        return \"<{cls:s} [tag 0x{tag:02d}] at 0x{id:x}>\".format(cls=self.__class__.__name__, tag=self.header.tag, id=id(self))\n\n    def update_hlen(self):\n        self.header.length = len(self.__bytearray__()) - len(self.header)\n\n    @abc.abstractmethod\n    def parse(self, packet):\n        if self.header.tag == 0:\n            self.header.parse(packet)\nsrc/leap/mx/vendor/pgpy/decorators.py\ndef sdproperty(fget):\n    def defset(obj, val):  # pragma: no cover\n        raise TypeError(str(val.__class__))\n\n    class SDProperty(property):\n        def register(self, cls=None, fset=None):\n            return self.fset.register(cls, fset)\n\n        def setter(self, fset):\n            self.register(object, fset)\n            return type(self)(self.fget, self.fset, self.fdel, self.__doc__)\n\n    return SDProperty(fget, sdmethod(defset))\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ElGPub(PubKey):\n    __pubfields__ = ('p', 'g', 'y')\n\n    def __pubkey__(self):\n        raise NotImplementedError()\n\n    def parse(self, packet):\n        self.p = MPI(packet)\n        self.g = MPI(packet)\n        self.y = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass SubPackets(collections.MutableMapping, Field):\n    _spmodule = signature\n\n    def __init__(self):\n        super(SubPackets, self).__init__()\n        self._hashed_sp = collections.OrderedDict()\n        self._unhashed_sp = collections.OrderedDict()\n\n    def __bytearray__(self):\n        _bytes = bytearray()\n        _bytes += self.__hashbytearray__()\n        _bytes += self.__unhashbytearray__()\n        return _bytes\n\n    def __hashbytearray__(self):\n        _bytes = bytearray()\n        _bytes += self.int_to_bytes(sum(len(sp) for sp in self._hashed_sp.values()), 2)\n        for hsp in self._hashed_sp.values():\n            _bytes += hsp.__bytearray__()\n        return _bytes\n\n    def __unhashbytearray__(self):\n        _bytes = bytearray()\n        _bytes += self.int_to_bytes(sum(len(sp) for sp in self._unhashed_sp.values()), 2)\n        for uhsp in self._unhashed_sp.values():\n            _bytes += uhsp.__bytearray__()\n        return _bytes\n\n    def __len__(self):  # pragma: no cover\n        return sum(sp.header.length for sp in itertools.chain(self._hashed_sp.values(), self._unhashed_sp.values())) + 4\n\n    def __iter__(self):\n        for sp in itertools.chain(self._hashed_sp.values(), self._unhashed_sp.values()):\n            yield sp\n\n    def __setitem__(self, key, val):\n        # the key provided should always be the classname for the subpacket\n        # but, there can be multiple subpackets of the same type\n        # so, it should be stored in the format: [h_]<key>_<seqid>\n        # where:\n        #  - <key> is the classname of val\n        #  - <seqid> is a sequence id, starting at 0, for a given classname\n\n        i = 0\n        if isinstance(key, tuple):  # pragma: no cover\n            key, i = key\n\n        d = self._unhashed_sp\n        if key.startswith('h_'):\n            d, key = self._hashed_sp, key[2:]\n\n        while (key, i) in d:\n            i += 1\n\n        d[(key, i)] = val\n\n    def __getitem__(self, key):\n        if isinstance(key, tuple):  # pragma: no cover\n            return self._hashed_sp.get(key, self._unhashed_sp.get(key))\n\n        if key.startswith('h_'):\n            return [v for k, v in self._hashed_sp.items() if key[2:] == k[0]]\n\n        else:\n            return [v for k, v in itertools.chain(self._hashed_sp.items(), self._unhashed_sp.items()) if key == k[0]]\n\n    def __delitem__(self, key):\n        ##TODO: this\n        raise NotImplementedError\n\n    def __contains__(self, key):\n        return key in set(k for k, _ in itertools.chain(self._hashed_sp, self._unhashed_sp))\n\n    def __copy__(self):\n        sp = SubPackets()\n        sp._hashed_sp = self._hashed_sp.copy()\n        sp._unhashed_sp = self._unhashed_sp.copy()\n\n        return sp\n\n    def addnew(self, spname, hashed=False, **kwargs):\n        nsp = getattr(self._spmodule, spname)()\n        for p, v in kwargs.items():\n            if hasattr(nsp, p):\n                setattr(nsp, p, v)\n        nsp.update_hlen()\n        if hashed:\n            self['h_' + spname] = nsp\n\n        else:\n            self[spname] = nsp\n\n    def update_hlen(self):\n        for sp in self:\n            sp.update_hlen()\n\n    def parse(self, packet):\n        hl = self.bytes_to_int(packet[:2])\n        del packet[:2]\n\n        # we do it this way because we can't ensure that subpacket headers are sized appropriately\n        # for their contents, but we can at least output that correctly\n        # so instead of tracking how many bytes we can now output, we track how many bytes have we parsed so far\n        plen = len(packet)\n        while plen - len(packet) < hl:\n            sp = SignatureSP(packet)\n            self['h_' + sp.__class__.__name__] = sp\n\n        uhl = self.bytes_to_int(packet[:2])\n        del packet[:2]\n\n        plen = len(packet)\n        while plen - len(packet) < uhl:\n            sp = SignatureSP(packet)\n            self[sp.__class__.__name__] = sp\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass DSAPriv(PrivKey, DSAPub):\n    __privfields__ = ('x',)\n\n    def __privkey__(self):\n        params = dsa.DSAParameterNumbers(self.p, self.q, self.g)\n        pn = dsa.DSAPublicNumbers(self.y, params)\n        return dsa.DSAPrivateNumbers(self.x, pn).private_key(default_backend())\n\n    def _generate(self, key_size):\n        if any(c != 0 for c in self):  # pragma: no cover\n            raise PGPError(\"key is already populated\")\n\n        # generate some big numbers!\n        pk = dsa.generate_private_key(key_size, default_backend())\n        pkn = pk.private_numbers()\n\n        self.p = MPI(pkn.public_numbers.parameter_numbers.p)\n        self.q = MPI(pkn.public_numbers.parameter_numbers.q)\n        self.g = MPI(pkn.public_numbers.parameter_numbers.g)\n        self.y = MPI(pkn.public_numbers.y)\n        self.x = MPI(pkn.x)\n\n        del pkn\n        del pk\n\n        self._compute_chksum()\n\n    def parse(self, packet):\n        super(DSAPriv, self).parse(packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.x = MPI(packet)\n\n        else:\n            self.encbytes = packet\n\n        if self.s2k.usage in [0, 255]:\n            self.chksum = packet[:2]\n            del packet[:2]\n\n    def decrypt_keyblob(self, passphrase):\n        kb = super(DSAPriv, self).decrypt_keyblob(passphrase)\n        del passphrase\n\n        self.x = MPI(kb)\n\n        if self.s2k.usage in [254, 255]:\n            self.chksum = kb\n            del kb\n\n    def sign(self, sigdata, hash_alg):\n        signer = self.__privkey__().signer(hash_alg)\n        signer.update(sigdata)\n        return signer.finalize()\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Primary(Key):\n    pass\nsrc/leap/mx/vendor/pgpy/types.py\nclass Fingerprint(str):\n    \"\"\"\n    A subclass of ``str``. Can be compared using == and != to ``str``, ``unicode``, and other :py:obj:`Fingerprint` instances.\n\n    Primarily used as a key for internal dictionaries, so it ignores spaces when comparing and hashing\n    \"\"\"\n    @property\n    def keyid(self):\n        return str(self).replace(' ', '')[-16:]\n\n    @property\n    def shortid(self):\n        return str(self).replace(' ', '')[-8:]\n\n    def __new__(cls, content):\n        if isinstance(content, Fingerprint):\n            return content\n\n        # validate input before continuing: this should be a string of 40 hex digits\n        content = content.upper().replace(' ', '')\n        if not bool(re.match(r'^[A-F0-9]{40}$', content)):\n            raise ValueError(\"Expected: String of 40 hex digits\")\n\n        # store in the format: \"AAAA BBBB CCCC DDDD EEEE  FFFF 0000 1111 2222 3333\"\n        #                                               ^^ note 2 spaces here\n        spaces = [ ' ' if i != 4 else '  ' for i in range(10) ]\n        chunks = [ ''.join(g) for g in six.moves.zip_longest(*[iter(content)] * 4) ]\n        content = ''.join(j for i in six.moves.zip_longest(chunks, spaces, fillvalue='') for j in i).strip()\n\n        return str.__new__(cls, content)\n\n    def __eq__(self, other):\n        if isinstance(other, Fingerprint):\n            return str(self) == str(other)\n\n        if isinstance(other, (six.text_type, bytes, bytearray)):\n            if isinstance(other, (bytes, bytearray)):  # pragma: no cover\n                other = other.decode('latin-1')\n\n            other = str(other).replace(' ', '')\n            return any([self.replace(' ', '') == other,\n                        self.keyid == other,\n                        self.shortid == other])\n\n        return False  # pragma: no cover\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __hash__(self):\n        return hash(str(self.replace(' ', '')))\n\n    def __bytes__(self):\n        return binascii.unhexlify(six.b(self.replace(' ', '')))\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDHPub(PubKey):\n    __pubfields__ = ('x', 'y')\n\n    def __init__(self):\n        super(ECDHPub, self).__init__()\n        self.oid = None\n        self.kdf = ECKDF()\n\n    def __len__(self):\n        return sum([len(getattr(self, i)) - 2 for i in self.__pubfields__] +\n                   [3,\n                    len(self.kdf),\n                    len(encoder.encode(self.oid.value)) - 1])\n\n    def __pubkey__(self):\n        return ec.EllipticCurvePublicNumbers(self.x, self.y, self.oid.curve()).public_key(default_backend())\n\n    def __bytearray__(self):\n        _b = bytearray()\n        _b += encoder.encode(self.oid.value)[1:]\n        # 0x04 || x || y\n        # where x and y are the same length\n        _xy = b'\\x04' + self.x.to_mpibytes()[2:] + self.y.to_mpibytes()[2:]\n        _b += MPI(self.bytes_to_int(_xy, 'big')).to_mpibytes()\n        _b += self.kdf.__bytearray__()\n\n        return _b\n\n    def __copy__(self):\n        pkt = super(ECDHPub, self).__copy__()\n        pkt.oid = self.oid\n        pkt.kdf = copy.copy(self.kdf)\n        return pkt\n\n    def parse(self, packet):\n        \"\"\"\n        Algorithm-Specific Fields for ECDH keys:\n\n          o  a variable-length field containing a curve OID, formatted\n             as follows:\n\n             -  a one-octet size of the following field; values 0 and\n                0xFF are reserved for future extensions\n\n             -  the octets representing a curve OID, defined in\n                Section 11\n\n             -  MPI of an EC point representing a public key\n\n          o  a variable-length field containing KDF parameters,\n             formatted as follows:\n\n             -  a one-octet size of the following fields; values 0 and\n                0xff are reserved for future extensions\n\n             -  a one-octet value 01, reserved for future extensions\n\n             -  a one-octet hash function ID used with a KDF\n\n             -  a one-octet algorithm ID for the symmetric algorithm\n                used to wrap the symmetric key used for the message\n                encryption; see Section 8 for details\n        \"\"\"\n        oidlen = packet[0]\n        del packet[0]\n        _oid = bytearray(b'\\x06')\n        _oid.append(oidlen)\n        _oid += bytearray(packet[:oidlen])\n        # try:\n        oid, _  = decoder.decode(bytes(_oid))\n\n        # except:\n        #     raise PGPError(\"Bad OID octet stream: b'{:s}'\".format(''.join(['\\\\x{:02X}'.format(c) for c in _oid])))\n        self.oid = EllipticCurveOID(oid)\n        del packet[:oidlen]\n\n        # flen = (self.oid.bit_length // 8)\n        xy = bytearray(MPI(packet).to_mpibytes()[2:])\n        # xy = bytearray(MPI(packet).to_bytes(flen, 'big'))\n        # the first byte is just \\x04\n        del xy[:1]\n        # now xy needs to be separated into x, y\n        xylen = len(xy)\n        x, y = xy[:xylen // 2], xy[xylen // 2:]\n        self.x = MPI(self.bytes_to_int(x))\n        self.y = MPI(self.bytes_to_int(y))\n\n        self.kdf.parse(packet)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDHCipherText(CipherText):\n    __mpis__ = ('vX', 'vY')\n\n    @classmethod\n    def encrypt(cls, pk, *args):\n        \"\"\"\n        For convenience, the synopsis of the encoding method is given below;\n        however, this section, [NIST-SP800-56A], and [RFC3394] are the\n        normative sources of the definition.\n\n            Obtain the authenticated recipient public key R\n            Generate an ephemeral key pair {v, V=vG}\n            Compute the shared point S = vR;\n            m = symm_alg_ID || session key || checksum || pkcs5_padding;\n            curve_OID_len = (byte)len(curve_OID);\n            Param = curve_OID_len || curve_OID || public_key_alg_ID || 03\n            || 01 || KDF_hash_ID || KEK_alg_ID for AESKeyWrap || \"Anonymous\n            Sender    \" || recipient_fingerprint;\n            Z_len = the key size for the KEK_alg_ID used with AESKeyWrap\n            Compute Z = KDF( S, Z_len, Param );\n            Compute C = AESKeyWrap( Z, m ) as per [RFC3394]\n            VB = convert point V to the octet string\n            Output (MPI(VB) || len(C) || C).\n\n        The decryption is the inverse of the method given.  Note that the\n        recipient obtains the shared secret by calculating\n        \"\"\"\n        # *args should be:\n        # - m\n        #\n        _m, = args\n\n        # m may need to be PKCS5-padded\n        padder = PKCS7(64).padder()\n        m = padder.update(_m) + padder.finalize()\n\n        km = pk.keymaterial\n\n        ct = cls()\n\n        # generate ephemeral key pair, then store it in ct\n        v = ec.generate_private_key(km.oid.curve(), default_backend())\n        ct.vX = MPI(v.public_key().public_numbers().x)\n        ct.vY = MPI(v.public_key().public_numbers().y)\n\n        # compute the shared point S\n        s = v.exchange(ec.ECDH(), km.__pubkey__())\n\n        # derive the wrapping key\n        z = km.kdf.derive_key(s, km.oid, PubKeyAlgorithm.ECDH, pk.fingerprint)\n\n        # compute C\n        ct.c = aes_key_wrap(z, m, default_backend())\n\n        return ct\n\n    def decrypt(self, pk, *args):\n        km = pk.keymaterial\n        # assemble the public component of ephemeral key v\n        v = ec.EllipticCurvePublicNumbers(self.vX, self.vY, km.oid.curve()).public_key(default_backend())\n\n        # compute s using the inverse of how it was derived during encryption\n        s = km.__privkey__().exchange(ec.ECDH(), v)\n\n        # derive the wrapping key\n        z = km.kdf.derive_key(s, km.oid, PubKeyAlgorithm.ECDH, pk.fingerprint)\n\n        # unwrap and unpad m\n        _m = aes_key_unwrap(z, self.c, default_backend())\n\n        padder = PKCS7(64).unpadder()\n        return padder.update(_m) + padder.finalize()\n\n    def __init__(self):\n        super(ECDHCipherText, self).__init__()\n        self.c = bytearray(0)\n\n    def __bytearray__(self):\n        _bytes = bytearray()\n        _xy = b'\\x04' + self.vX.to_mpibytes()[2:] + self.vY.to_mpibytes()[2:]\n        _bytes += MPI(self.bytes_to_int(_xy, 'big')).to_mpibytes()\n        _bytes.append(len(self.c))\n        _bytes += self.c\n\n        return _bytes\n\n    def parse(self, packet):\n        # self.v = MPI(packet)\n        xy = bytearray(MPI(packet).to_mpibytes()[2:])\n        del xy[:1]\n        xylen = len(xy)\n        x, y = xy[:xylen // 2], xy[xylen // 2:]\n        self.vX = MPI(self.bytes_to_int(x))\n        self.vY = MPI(self.bytes_to_int(y))\n\n        clen = packet[0]\n        del packet[0]\n\n        self.c += packet[:clen]\n        del packet[:clen]\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass RSASignature(Signature):\n    __mpis__ = ('md_mod_n', )\n\n    def __sig__(self):\n        return self.md_mod_n.to_mpibytes()[2:]\n\n    def parse(self, packet):\n        self.md_mod_n = MPI(packet)\n\n    def from_signer(self, sig):\n        self.md_mod_n = MPI(self.bytes_to_int(sig))\nsrc/leap/mx/vendor/pgpy/symenc.py\ndef _encrypt(pt, key, alg, iv=None):\n    if iv is None:\n        iv = b'\\x00' * (alg.block_size // 8)\n\n    if alg.is_insecure:\n        raise PGPInsecureCipher(\"{:s} is not secure. Do not use it for encryption!\".format(alg.name))\n\n    if not callable(alg.cipher):\n        raise PGPEncryptionError(\"Cipher {:s} not supported\".format(alg.name))\n\n    try:\n        encryptor = Cipher(alg.cipher(key), modes.CFB(iv), default_backend()).encryptor()\n\n    except UnsupportedAlgorithm as ex:  # pragma: no cover\n        six.raise_from(PGPEncryptionError, ex)\n\n    else:\n        return bytearray(encryptor.update(pt) + encryptor.finalize())\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDSASignature(DSASignature):\n    def from_signer(self, sig):\n        seq, _ = decoder.decode(sig)\n        self.r = MPI(seq[0])\n        self.s = MPI(seq[1])\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Private(Key):\n    pass\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass String2Key(Field):\n    \"\"\"\n    3.7.  String-to-Key (S2K) Specifiers\n\n    String-to-key (S2K) specifiers are used to convert passphrase strings\n    into symmetric-key encryption/decryption keys.  They are used in two\n    places, currently: to encrypt the secret part of private keys in the\n    private keyring, and to convert passphrases to encryption keys for\n    symmetrically encrypted messages.\n\n    3.7.1.  String-to-Key (S2K) Specifier Types\n\n    There are three types of S2K specifiers currently supported, and\n    some reserved values:\n\n       ID          S2K Type\n       --          --------\n       0           Simple S2K\n       1           Salted S2K\n       2           Reserved value\n       3           Iterated and Salted S2K\n       100 to 110  Private/Experimental S2K\n\n    These are described in Sections 3.7.1.1 - 3.7.1.3.\n\n    3.7.1.1.  Simple S2K\n\n    This directly hashes the string to produce the key data.  See below\n    for how this hashing is done.\n\n       Octet 0:        0x00\n       Octet 1:        hash algorithm\n\n    Simple S2K hashes the passphrase to produce the session key.  The\n    manner in which this is done depends on the size of the session key\n    (which will depend on the cipher used) and the size of the hash\n    algorithm's output.  If the hash size is greater than the session key\n    size, the high-order (leftmost) octets of the hash are used as the\n    key.\n\n    If the hash size is less than the key size, multiple instances of the\n    hash context are created -- enough to produce the required key data.\n    These instances are preloaded with 0, 1, 2, ... octets of zeros (that\n    is to say, the first instance has no preloading, the second gets\n    preloaded with 1 octet of zero, the third is preloaded with two\n    octets of zeros, and so forth).\n\n    As the data is hashed, it is given independently to each hash\n    context.  Since the contexts have been initialized differently, they\n    will each produce different hash output.  Once the passphrase is\n    hashed, the output data from the multiple hashes is concatenated,\n    first hash leftmost, to produce the key data, with any excess octets\n    on the right discarded.\n\n    3.7.1.2.  Salted S2K\n\n    This includes a \"salt\" value in the S2K specifier -- some arbitrary\n    data -- that gets hashed along with the passphrase string, to help\n    prevent dictionary attacks.\n\n       Octet 0:        0x01\n       Octet 1:        hash algorithm\n       Octets 2-9:     8-octet salt value\n\n    Salted S2K is exactly like Simple S2K, except that the input to the\n    hash function(s) consists of the 8 octets of salt from the S2K\n    specifier, followed by the passphrase.\n\n    3.7.1.3.  Iterated and Salted S2K\n\n    This includes both a salt and an octet count.  The salt is combined\n    with the passphrase and the resulting value is hashed repeatedly.\n    This further increases the amount of work an attacker must do to try\n    dictionary attacks.\n\n       Octet  0:        0x03\n       Octet  1:        hash algorithm\n       Octets 2-9:      8-octet salt value\n       Octet  10:       count, a one-octet, coded value\n\n    The count is coded into a one-octet number using the following\n    formula:\n\n       #define EXPBIAS 6\n           count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);\n\n    The above formula is in C, where \"Int32\" is a type for a 32-bit\n    integer, and the variable \"c\" is the coded count, Octet 10.\n\n    Iterated-Salted S2K hashes the passphrase and salt data multiple\n    times.  The total number of octets to be hashed is specified in the\n    encoded count in the S2K specifier.  Note that the resulting count\n    value is an octet count of how many octets will be hashed, not an\n    iteration count.\n\n    Initially, one or more hash contexts are set up as with the other S2K\n    algorithms, depending on how many octets of key data are needed.\n    Then the salt, followed by the passphrase data, is repeatedly hashed\n    until the number of octets specified by the octet count has been\n    hashed.  The one exception is that if the octet count is less than\n    the size of the salt plus passphrase, the full salt plus passphrase\n    will be hashed even though that is greater than the octet count.\n    After the hashing is done, the data is unloaded from the hash\n    context(s) as with the other S2K algorithms.\n    \"\"\"\n    @sdproperty\n    def encalg(self):\n        return self._encalg\n\n    @encalg.register(int)\n    @encalg.register(SymmetricKeyAlgorithm)\n    def encalg_int(self, val):\n        self._encalg = SymmetricKeyAlgorithm(val)\n\n    @sdproperty\n    def specifier(self):\n        return self._specifier\n\n    @specifier.register(int)\n    @specifier.register(String2KeyType)\n    def specifier_int(self, val):\n        self._specifier = String2KeyType(val)\n\n    @sdproperty\n    def halg(self):\n        return self._halg\n\n    @halg.register(int)\n    @halg.register(HashAlgorithm)\n    def halg_int(self, val):\n        self._halg = HashAlgorithm(val)\n\n    @sdproperty\n    def count(self):\n        return (16 + (self._count & 15)) << ((self._count >> 4) + 6)\n\n    @count.register(int)\n    def count_int(self, val):\n        if val < 0 or val > 255:  # pragma: no cover\n            raise ValueError(\"count must be between 0 and 256\")\n        self._count = val\n\n    def __init__(self):\n        super(String2Key, self).__init__()\n        self.usage = 0\n        self.encalg = 0\n        self.specifier = 0\n        self.iv = None\n\n        # specifier-specific fields\n        # simple, salted, iterated\n        self.halg = 0\n\n        # salted, iterated\n        self.salt = bytearray()\n\n        # iterated\n        self.count = 0\n\n    def __bytearray__(self):\n        _bytes = bytearray()\n        _bytes.append(self.usage)\n        if bool(self):\n            _bytes.append(self.encalg)\n            _bytes.append(self.specifier)\n            if self.specifier >= String2KeyType.Simple:\n                _bytes.append(self.halg)\n            if self.specifier >= String2KeyType.Salted:\n                _bytes += self.salt\n            if self.specifier == String2KeyType.Iterated:\n                _bytes.append(self._count)\n            if self.iv is not None:\n                _bytes += self.iv\n        return _bytes\n\n    def __len__(self):\n        return len(self.__bytearray__())\n\n    def __bool__(self):\n        return self.usage in [254, 255]\n\n    def __nonzero__(self):\n        return self.__bool__()\n\n    def __copy__(self):\n        s2k = String2Key()\n        s2k.usage = self.usage\n        s2k.encalg = self.encalg\n        s2k.specifier = self.specifier\n        s2k.iv = self.iv\n        s2k.halg = self.halg\n        s2k.salt = copy.copy(self.salt)\n        s2k.count = self._count\n        return s2k\n\n    def parse(self, packet, iv=True):\n        self.usage = packet[0]\n        del packet[0]\n\n        if bool(self):\n            self.encalg = packet[0]\n            del packet[0]\n\n            self.specifier = packet[0]\n            del packet[0]\n\n            if self.specifier >= String2KeyType.Simple:\n                # this will always be true\n                self.halg = packet[0]\n                del packet[0]\n\n            if self.specifier >= String2KeyType.Salted:\n                self.salt = packet[:8]\n                del packet[:8]\n\n            if self.specifier == String2KeyType.Iterated:\n                self.count = packet[0]\n                del packet[0]\n\n            if iv:\n                self.iv = packet[:(self.encalg.block_size // 8)]\n                del packet[:(self.encalg.block_size // 8)]\n\n    def derive_key(self, passphrase):\n        ##TODO: raise an exception if self.usage is not 254 or 255\n        keylen = self.encalg.key_size\n        hashlen = self.halg.digest_size * 8\n\n        ctx = int(math.ceil((keylen / hashlen)))\n\n        # Simple S2K - always done\n        hsalt = b''\n        hpass = passphrase.encode('latin-1')\n\n        # salted, iterated S2K\n        if self.specifier >= String2KeyType.Salted:\n            hsalt = bytes(self.salt)\n\n        count = len(hsalt + hpass)\n        if self.specifier == String2KeyType.Iterated and self.count > len(hsalt + hpass):\n            count = self.count\n\n        hcount = (count // len(hsalt + hpass))\n        hleft = count - (hcount * len(hsalt + hpass))\n\n        hashdata = ((hsalt + hpass) * hcount) + (hsalt + hpass)[:hleft]\n\n        h = []\n        for i in range(0, ctx):\n            _h = self.halg.hasher\n            _h.update(b'\\x00' * i)\n            _h.update(hashdata)\n            h.append(_h)\n\n        # GC some stuff\n        del hsalt\n        del hpass\n        del hashdata\n\n        # and return the key!\n        return b''.join(hc.digest() for hc in h)[:(keylen // 8)]\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ElGPriv(PrivKey, ElGPub):\n    __privfields__ = ('x', )\n\n    def __privkey__(self):\n        raise NotImplementedError()\n\n    def _generate(self, key_size):\n        raise NotImplementedError(PubKeyAlgorithm.ElGamal)\n\n    def parse(self, packet):\n        super(ElGPriv, self).parse(packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.x = MPI(packet)\n\n        else:\n            self.encbytes = packet\n\n        if self.s2k.usage in [0, 255]:\n            self.chksum = packet[:2]\n            del packet[:2]\n\n    def decrypt_keyblob(self, passphrase):\n        kb = super(ElGPriv, self).decrypt_keyblob(passphrase)\n        del passphrase\n\n        self.x = MPI(kb)\n\n        if self.s2k.usage in [254, 255]:\n            self.chksum = kb\n            del kb\nsrc/leap/mx/vendor/pgpy/constants.py\nclass HashAlgorithm(IntEnum):\n    Invalid = 0x00\n    MD5 = 0x01\n    SHA1 = 0x02\n    RIPEMD160 = 0x03\n    _reserved_1 = 0x04\n    _reserved_2 = 0x05\n    _reserved_3 = 0x06\n    _reserved_4 = 0x07\n    SHA256 = 0x08\n    SHA384 = 0x09\n    SHA512 = 0x0A\n    SHA224 = 0x0B\n\n    def __init__(self, *args):\n        super(self.__class__, self).__init__()\n        self._tuned_count = 0\n\n    @property\n    def hasher(self):\n        return hashlib.new(self.name)\n\n    @property\n    def digest_size(self):\n        return self.hasher.digest_size\n\n    @property\n    def tuned_count(self):\n        if self._tuned_count == 0:\n            self.tune_count()\n\n        return self._tuned_count\n\n    def tune_count(self):\n        start = end = 0\n        htd = _hashtunedata[:]\n\n        while start == end:\n            # potentially do this multiple times in case the resolution of time.time is low enough that\n            # hashing 100 KiB isn't enough time to produce a measurable difference\n            # (e.g. if the timer for time.time doesn't have enough precision)\n            htd = htd + htd\n            h = self.hasher\n\n            start = time.time()\n            h.update(htd)\n            end = time.time()\n\n        # now calculate how many bytes need to be hashed to reach our expected time period\n        # GnuPG tunes for about 100ms, so we'll do that as well\n        _TIME = 0.100\n        ct = int(len(htd) * (_TIME / (end - start)))\n        c1 = ((ct >> (ct.bit_length() - 5)) - 16)\n        c2 = (ct.bit_length() - 11)\n        c = ((c2 << 4) + c1)\n\n        # constrain self._tuned_count to be between 0 and 255\n        self._tuned_count = max(min(c, 255), 0)\nsrc/leap/mx/vendor/pgpy/errors.py\nclass PGPDecryptionError(Exception):\n    \"\"\"Raised when decryption fails\"\"\"\n    pass\nsrc/leap/mx/vendor/pgpy/constants.py\nclass SymmetricKeyAlgorithm(IntEnum):\n    \"\"\"Supported symmetric key algorithms.\"\"\"\n    Plaintext = 0x00\n    #: .. warning::\n    #:     IDEA is insecure. PGPy only allows it to be used for decryption, not encryption!\n    IDEA = 0x01\n    #: Triple-DES with 168-bit key derived from 192\n    TripleDES = 0x02\n    #: CAST5 (or CAST-128) with 128-bit key\n    CAST5 = 0x03\n    #: Blowfish with 128-bit key and 16 rounds\n    Blowfish = 0x04\n    #: AES with 128-bit key\n    AES128 = 0x07\n    #: AES with 192-bit key\n    AES192 = 0x08\n    #: AES with 256-bit key\n    AES256 = 0x09\n    # Twofish with 256-bit key - not currently supported\n    Twofish256 = 0x0A\n    #: Camellia with 128-bit key\n    Camellia128 = 0x0B\n    #: Camellia with 192-bit key\n    Camellia192 = 0x0C\n    #: Camellia with 256-bit key\n    Camellia256 = 0x0D\n\n    @property\n    def cipher(self):\n        bs = {SymmetricKeyAlgorithm.IDEA: algorithms.IDEA,\n              SymmetricKeyAlgorithm.TripleDES: algorithms.TripleDES,\n              SymmetricKeyAlgorithm.CAST5: algorithms.CAST5,\n              SymmetricKeyAlgorithm.Blowfish: algorithms.Blowfish,\n              SymmetricKeyAlgorithm.AES128: algorithms.AES,\n              SymmetricKeyAlgorithm.AES192: algorithms.AES,\n              SymmetricKeyAlgorithm.AES256: algorithms.AES,\n              SymmetricKeyAlgorithm.Twofish256: namedtuple('Twofish256', ['block_size'])(block_size=128),\n              SymmetricKeyAlgorithm.Camellia128: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia192: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia256: algorithms.Camellia}\n\n        if self in bs:\n            return bs[self]\n\n        raise NotImplementedError(repr(self))\n\n    @property\n    def is_insecure(self):\n        insecure_ciphers = {SymmetricKeyAlgorithm.IDEA}\n        return self in insecure_ciphers\n\n    @property\n    def block_size(self):\n        return self.cipher.block_size\n\n    @property\n    def key_size(self):\n        ks = {SymmetricKeyAlgorithm.IDEA: 128,\n              SymmetricKeyAlgorithm.TripleDES: 192,\n              SymmetricKeyAlgorithm.CAST5: 128,\n              SymmetricKeyAlgorithm.Blowfish: 128,\n              SymmetricKeyAlgorithm.AES128: 128,\n              SymmetricKeyAlgorithm.AES192: 192,\n              SymmetricKeyAlgorithm.AES256: 256,\n              SymmetricKeyAlgorithm.Twofish256: 256,\n              SymmetricKeyAlgorithm.Camellia128: 128,\n              SymmetricKeyAlgorithm.Camellia192: 192,\n              SymmetricKeyAlgorithm.Camellia256: 256}\n\n        if self in ks:\n            return ks[self]\n\n        raise NotImplementedError(repr(self))\n\n    def gen_iv(self):\n        return os.urandom(self.block_size // 8)\n\n    def gen_key(self):\n        return os.urandom(self.key_size // 8)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass TrustFlags(FlagEnum):\n    Revoked = 0x20\n    SubRevoked = 0x40\n    Disabled = 0x80\n    PendingCheck = 0x100\nsrc/leap/mx/vendor/pgpy/symenc.py\ndef _decrypt(ct, key, alg, iv=None):\n    if iv is None:\n        \"\"\"\n        Instead of using an IV, OpenPGP prefixes a string of length\n        equal to the block size of the cipher plus two to the data before it\n        is encrypted. The first block-size octets (for example, 8 octets for\n        a 64-bit block length) are random, and the following two octets are\n        copies of the last two octets of the IV.\n        \"\"\"\n        iv = b'\\x00' * (alg.block_size // 8)\n\n    try:\n        decryptor = Cipher(alg.cipher(key), modes.CFB(iv), default_backend()).decryptor()\n\n    except UnsupportedAlgorithm as ex:  # pragma: no cover\n        six.raise_from(PGPDecryptionError, ex)\n\n    else:\n        return bytearray(decryptor.update(ct) + decryptor.finalize())\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass UserAttributeSubPackets(SubPackets):\n    \"\"\"\n    This is nearly the same as just the unhashed subpackets from above,\n    except that there isn't a length specifier. So, parse will only parse one packet,\n    appending that one packet to self.__unhashed_sp.\n    \"\"\"\n    _spmodule = userattribute\n\n    def __bytearray__(self):\n        _bytes = bytearray()\n        for uhsp in self._unhashed_sp.values():\n            _bytes += uhsp.__bytearray__()\n        return _bytes\n\n    def __len__(self):  # pragma: no cover\n        return sum(len(sp) for sp in self._unhashed_sp.values())\n\n    def parse(self, packet):\n        # parse just one packet and add it to the unhashed subpacket ordereddict\n        # I actually have yet to come across a User Attribute packet with more than one subpacket\n        # which makes sense, given that there is only one defined subpacket\n        sp = UserAttribute(packet)\n        self[sp.__class__.__name__] = sp\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Sub(Key):\n    pass\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass OpaquePrivKey(PrivKey, OpaquePubKey):  # pragma: no cover\n    def __privkey__(self):\n        return NotImplemented\n\n    def _generate(self, key_size):\n        # return NotImplemented\n        raise NotImplementedError()\n\n    def decrypt_keyblob(self, passphrase):\n        return NotImplemented\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass RSAPriv(PrivKey, RSAPub):\n    __privfields__ = ('d', 'p', 'q', 'u')\n\n    def __privkey__(self):\n        return rsa.RSAPrivateNumbers(self.p, self.q, self.d,\n                                     rsa.rsa_crt_dmp1(self.d, self.p),\n                                     rsa.rsa_crt_dmq1(self.d, self.q),\n                                     rsa.rsa_crt_iqmp(self.p, self.q),\n                                     rsa.RSAPublicNumbers(self.e, self.n)).private_key(default_backend())\n\n    def _generate(self, key_size):\n        if any(c != 0 for c in self):  # pragma: no cover\n            raise PGPError(\"key is already populated\")\n\n        # generate some big numbers!\n        pk = rsa.generate_private_key(65537, key_size, default_backend())\n        pkn = pk.private_numbers()\n\n        self.n = MPI(pkn.public_numbers.n)\n        self.e = MPI(pkn.public_numbers.e)\n        self.d = MPI(pkn.d)\n        self.p = MPI(pkn.p)\n        self.q = MPI(pkn.q)\n        # from the RFC:\n        # \"- MPI of u, the multiplicative inverse of p, mod q.\"\n        # or, simply, p^-1 mod p\n        # rsa.rsa_crt_iqmp(p, q) normally computes q^-1 mod p,\n        # so if we swap the values around we get the answer we want\n        self.u = MPI(rsa.rsa_crt_iqmp(pkn.q, pkn.p))\n\n        del pkn\n        del pk\n\n        self._compute_chksum()\n\n    def parse(self, packet):\n        super(RSAPriv, self).parse(packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.d = MPI(packet)\n            self.p = MPI(packet)\n            self.q = MPI(packet)\n            self.u = MPI(packet)\n\n            if self.s2k.usage == 0:\n                self.chksum = packet[:2]\n                del packet[:2]\n\n        else:\n            ##TODO: this needs to be bounded to the length of the encrypted key material\n            self.encbytes = packet\n\n    def decrypt_keyblob(self, passphrase):\n        kb = super(RSAPriv, self).decrypt_keyblob(passphrase)\n        del passphrase\n\n        self.d = MPI(kb)\n        self.p = MPI(kb)\n        self.q = MPI(kb)\n        self.u = MPI(kb)\n\n        if self.s2k.usage in [254, 255]:\n            self.chksum = kb\n            del kb\n\n    def sign(self, sigdata, hash_alg):\n        signer = self.__privkey__().signer(padding.PKCS1v15(), hash_alg)\n        signer.update(sigdata)\n        return signer.finalize()\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass OpaquePubKey(PubKey):  # pragma: no cover\n    def __init__(self):\n        super(OpaquePubKey, self).__init__()\n        self.data = bytearray()\n\n    def __iter__(self):\n        yield self.data\n\n    def __pubkey__(self):\n        return NotImplemented\n\n    def __bytearray__(self):\n        return self.data\n\n    def parse(self, packet):\n        ##TODO: this needs to be length-bounded to the end of the packet\n        self.data = packet\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass VersionedPacket(Packet):\n    __headercls__ = VersionedHeader\n\n    def __init__(self):\n        super(VersionedPacket, self).__init__()\n        if isinstance(self.__ver__, six.integer_types):\n            self.header.version = self.__ver__\n\n    def __repr__(self):\n        return \"<{cls:s} [tag 0x{tag:02d}][v{ver:d}] at 0x{id:x}>\".format(cls=self.__class__.__name__, tag=self.header.tag,\n                                                                          ver=self.header.version, id=id(self))\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass RSAPub(PubKey):\n    __pubfields__ = ('n', 'e')\n\n    def __pubkey__(self):\n        return rsa.RSAPublicNumbers(self.e, self.n).public_key(default_backend())\n\n    def verify(self, subj, sigbytes, hash_alg):\n        # zero-pad sigbytes if necessary\n        sigbytes = (b'\\x00' * (self.n.byte_length() - len(sigbytes))) + sigbytes\n        verifier = self.__pubkey__().verifier(sigbytes, padding.PKCS1v15(), hash_alg)\n        verifier.update(subj)\n\n        try:\n            verifier.verify()\n\n        except InvalidSignature:\n            return False\n\n        return True\n\n    def parse(self, packet):\n        self.n = MPI(packet)\n        self.e = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass RSACipherText(CipherText):\n    __mpis__ = ('me_mod_n', )\n\n    @classmethod\n    def encrypt(cls, encfn, *args):\n        ct = cls()\n        ct.me_mod_n = MPI(cls.bytes_to_int(encfn(*args)))\n        return ct\n\n    def decrypt(self, decfn, *args):\n        return decfn(*args)\n\n    def parse(self, packet):\n        self.me_mod_n = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Public(Key):\n    pass\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass DSASignature(Signature):\n    __mpis__ = ('r', 's')\n\n    def __sig__(self):\n        # return the signature data into an ASN.1 sequence of integers in DER format\n        seq = Sequence()\n        for i in self:\n            seq.setComponentByPosition(len(seq), Integer(i))\n\n        return encoder.encode(seq)\n\n    def from_signer(self, sig):\n        ##TODO: just use pyasn1 for this\n        def _der_intf(_asn):\n            if _asn[0] != 0x02:  # pragma: no cover\n                raise ValueError(\"Expected: Integer (0x02). Got: 0x{:02X}\".format(_asn[0]))\n            del _asn[0]\n\n            if _asn[0] & 0x80:  # pragma: no cover\n                llen = _asn[0] & 0x7F\n                del _asn[0]\n\n                flen = self.bytes_to_int(_asn[:llen])\n                del _asn[:llen]\n\n            else:\n                flen = _asn[0] & 0x7F\n                del _asn[0]\n\n            i = self.bytes_to_int(_asn[:flen])\n            del _asn[:flen]\n            return i\n\n        if isinstance(sig, bytes):\n            sig = bytearray(sig)\n\n        # this is a very limited asn1 decoder - it is only intended to decode a DER encoded sequence of integers\n        if not sig[0] == 0x30:\n            raise NotImplementedError(\"Expected: Sequence (0x30). Got: 0x{:02X}\".format(sig[0]))\n        del sig[0]\n\n        # skip the sequence length field\n        if sig[0] & 0x80:  # pragma: no cover\n            llen = sig[0] & 0x7F\n            del sig[:llen + 1]\n\n        else:\n            del sig[0]\n\n        self.r = MPI(_der_intf(sig))\n        self.s = MPI(_der_intf(sig))\n\n    def parse(self, packet):\n        self.r = MPI(packet)\n        self.s = MPI(packet)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass TrustLevel(IntEnum):\n    Unknown = 0\n    Expired = 1\n    Undefined = 2\n    Never = 3\n    Marginal = 4\n    Fully = 5\n    Ultimate = 6\nsrc/leap/mx/vendor/pgpy/constants.py\nclass SignatureType(IntEnum):\n    BinaryDocument = 0x00\n    CanonicalDocument = 0x01\n    Standalone = 0x02\n    Generic_Cert = 0x10\n    Persona_Cert = 0x11\n    Casual_Cert = 0x12\n    Positive_Cert = 0x13\n    Subkey_Binding = 0x18\n    PrimaryKey_Binding = 0x19\n    DirectlyOnKey = 0x1F\n    KeyRevocation = 0x20\n    SubkeyRevocation = 0x28\n    CertRevocation = 0x30\n    Timestamp = 0x40\n    ThirdParty_Confirmation = 0x50\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass DSAPub(PubKey):\n    __pubfields__ = ('p', 'q', 'g', 'y')\n\n    def __pubkey__(self):\n        params = dsa.DSAParameterNumbers(self.p, self.q, self.g)\n        return dsa.DSAPublicNumbers(self.y, params).public_key(default_backend())\n\n    def verify(self, subj, sigbytes, hash_alg):\n        verifier = self.__pubkey__().verifier(sigbytes, hash_alg)\n        verifier.update(subj)\n\n        try:\n            verifier.verify()\n\n        except InvalidSignature:\n            return False\n\n        return True\n\n    def parse(self, packet):\n        self.p = MPI(packet)\n        self.q = MPI(packet)\n        self.g = MPI(packet)\n        self.y = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ElGCipherText(CipherText):\n    __mpis__ = ('gk_mod_p', 'myk_mod_p')\n\n    @classmethod\n    def encrypt(cls, encfn, *args):\n        raise NotImplementedError()\n\n    def decrypt(self, decfn, *args):\n        raise NotImplementedError()\n\n    def parse(self, packet):\n        self.gk_mod_p = MPI(packet)\n        self.myk_mod_p = MPI(packet)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass PubKeyAlgorithm(IntEnum):\n    Invalid = 0x00\n    #: Signifies that a key is an RSA key.\n    RSAEncryptOrSign = 0x01\n    RSAEncrypt = 0x02  # deprecated\n    RSASign = 0x03     # deprecated\n    #: Signifies that a key is an ElGamal key.\n    ElGamal = 0x10\n    #: Signifies that a key is a DSA key.\n    DSA = 0x11\n    #: Signifies that a key is an ECDH key.\n    ECDH = 0x12\n    #: Signifies that a key is an ECDSA key.\n    ECDSA = 0x13\n    FormerlyElGamalEncryptOrSign = 0x14  # deprecated - do not generate\n    # DiffieHellman = 0x15  # X9.42\n\n    @property\n    def can_gen(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign,\n                        PubKeyAlgorithm.DSA,\n                        PubKeyAlgorithm.ECDSA,\n                        PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_encrypt(self):  # pragma: no cover\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.ElGamal, PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_sign(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.DSA, PubKeyAlgorithm.ECDSA}\n\n    @property\n    def deprecated(self):\n        return self in {PubKeyAlgorithm.RSAEncrypt,\n                        PubKeyAlgorithm.RSASign,\n                        PubKeyAlgorithm.FormerlyElGamalEncryptOrSign}\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDSAPub(PubKey):\n    __pubfields__ = ('x', 'y')\n\n    def __init__(self):\n        super(ECDSAPub, self).__init__()\n        self.oid = None\n\n    def __len__(self):\n        return sum([len(getattr(self, i)) - 2 for i in self.__pubfields__] +\n                   [3, len(encoder.encode(self.oid.value)) - 1])\n\n    def __pubkey__(self):\n        return ec.EllipticCurvePublicNumbers(self.x, self.y, self.oid.curve()).public_key(default_backend())\n\n    def __bytearray__(self):\n        _b = bytearray()\n        _b += encoder.encode(self.oid.value)[1:]\n        # 0x04 || x || y\n        # where x and y are the same length\n        _xy = b'\\x04' + self.x.to_mpibytes()[2:] + self.y.to_mpibytes()[2:]\n        _b += MPI(self.bytes_to_int(_xy, 'big')).to_mpibytes()\n\n        return _b\n\n    def __copy__(self):\n        pkt = super(ECDSAPub, self).__copy__()\n        pkt.oid = self.oid\n        return pkt\n\n    def verify(self, subj, sigbytes, hash_alg):\n        verifier = self.__pubkey__().verifier(sigbytes, ec.ECDSA(hash_alg))\n        verifier.update(subj)\n\n        try:\n            verifier.verify()\n\n        except InvalidSignature:\n            return False\n\n        return True\n\n    def parse(self, packet):\n        oidlen = packet[0]\n        del packet[0]\n        _oid = bytearray(b'\\x06')\n        _oid.append(oidlen)\n        _oid += bytearray(packet[:oidlen])\n        # try:\n        oid, _  = decoder.decode(bytes(_oid))\n\n        # except:\n        #     raise PGPError(\"Bad OID octet stream: b'{:s}'\".format(''.join(['\\\\x{:02X}'.format(c) for c in _oid])))\n        self.oid = EllipticCurveOID(oid)\n        del packet[:oidlen]\n\n        # flen = (self.oid.bit_length // 8)\n        xy = bytearray(MPI(packet).to_mpibytes()[2:])\n        # xy = bytearray(MPI(packet).to_bytes(flen, 'big'))\n        # the first byte is just \\x04\n        del xy[:1]\n        # now xy needs to be separated into x, y\n        xylen = len(xy)\n        x, y = xy[:xylen // 2], xy[xylen // 2:]\n        self.x = MPI(self.bytes_to_int(x))\n        self.y = MPI(self.bytes_to_int(y))\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDSAPriv(PrivKey, ECDSAPub):\n    __privfields__ = ('s', )\n\n    def __privkey__(self):\n        ecp = ec.EllipticCurvePublicNumbers(self.x, self.y, self.oid.curve())\n        return ec.EllipticCurvePrivateNumbers(self.s, ecp).private_key(default_backend())\n\n    def _generate(self, oid):\n        if any(c != 0 for c in self):  # pragma: no cover\n            raise PGPError(\"Key is already populated!\")\n\n        self.oid = EllipticCurveOID(oid)\n\n        if not self.oid.can_gen:\n            raise ValueError(\"Curve not currently supported: {}\".format(oid.name))\n\n        pk = ec.generate_private_key(self.oid.curve(), default_backend())\n        pubn = pk.public_key().public_numbers()\n        self.x = MPI(pubn.x)\n        self.y = MPI(pubn.y)\n        self.s = MPI(pk.private_numbers().private_value)\n\n    def parse(self, packet):\n        super(ECDSAPriv, self).parse(packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.s = MPI(packet)\n\n            if self.s2k.usage == 0:\n                self.chksum = packet[:2]\n                del packet[:2]\n\n        else:\n            ##TODO: this needs to be bounded to the length of the encrypted key material\n            self.encbytes = packet\n\n    def decrypt_keyblob(self, passphrase):\n        kb = super(ECDSAPriv, self).decrypt_keyblob(passphrase)\n        del passphrase\n\n        self.s = MPI(kb)\n\n    def sign(self, sigdata, hash_alg):\n        signer = self.__privkey__().signer(ec.ECDSA(hash_alg))\n        signer.update(sigdata)\n        return signer.finalize()\nsrc/leap/mx/vendor/pgpy/constants.py\nclass CompressionAlgorithm(IntEnum):\n    #: No compression\n    Uncompressed = 0x00\n    #: ZIP DEFLATE\n    ZIP = 0x01\n    #: ZIP DEFLATE with zlib headers\n    ZLIB = 0x02\n    #: Bzip2\n    BZ2 = 0x03\n\n    def compress(self, data):\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.compress(data)[2:-4]\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.compress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.compress(data)\n\n        raise NotImplementedError(self)\n\n    def decompress(self, data):\n        if six.PY2:\n            data = bytes(data)\n\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.decompress(data, -15)\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.decompress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.decompress(data)\n\n        raise NotImplementedError(self)\n", "answers": ["    @calg.register(CompressionAlgorithm)"], "length": 5356, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "06fbfb05b70f3785fce8b643e46a6b1f493921c2580332e3"}
{"input": "import sys\nimport numpy\n    import os\n    import ClearMap.ImageProcessing.SpotDetection as self\n    import ClearMap.IO as io  \n    import ClearMap.Settings as settings\n    import numpy;\nfrom ClearMap.ImageProcessing.IlluminationCorrection import correctIllumination\nfrom ClearMap.ImageProcessing.BackgroundRemoval import removeBackground\nfrom ClearMap.ImageProcessing.Filter.DoGFilter import filterDoG\nfrom ClearMap.ImageProcessing.MaximaDetection import findExtendedMaxima, findPixelCoordinates, findIntensity, findCenterOfMaxima\nfrom ClearMap.ImageProcessing.CellSizeDetection import detectCellShape, findCellSize, findCellIntensity\nfrom ClearMap.Utils.Timer import Timer\nfrom ClearMap.Utils.ParameterTools import getParameter\n    Extended Max: threshold   : 5\n    Extended Max: localMaxSize: 5\n    Extended Max: hMax        : None\n    Extended Max: elapsed time: 0:00:00\n    Cell Centers: elapsed time: 0:00:00\n    Cell Shape: cellShapeThreshold: 1\n    Cell Shape:: elapsed time: 0:00:00\n    Cell Size:: elapsed time: 0:00:00\n    Cell Intensity: cellIntensityMethod: Max\n    Cell Intensity:: elapsed time: 0:00:00\n    Cell Intensity: cellIntensityMethod: Max\n    Cell Intensity:: elapsed time: 0:00:00\n    Cell Intensity: cellIntensityMethod: Max\n    Cell Intensity:: elapsed time: 0:00:00\n    Found 38 cells !\n    \nAfter execution this example inspect the result of the cell detection in \nthe folder 'Test/Data/CellShape/cellshape\\_\\\\d{3}.tif'.\n\"\"\"\n#:copyright: Copyright 2015 by Christoph Kirst, The Rockefeller University, New York City\n#:license: GNU, see LICENSE.txt for details.\n\n\n\n\n\n\n##############################################################################\n# Spot detection\n##############################################################################\n\ndef detectSpots(img, detectSpotsParameter = None, correctIlluminationParameter = None, removeBackgroundParameter = None,\n                filterDoGParameter = None, findExtendedMaximaParameter = None, detectCellShapeParameter = None,\n                verbose = False, out = sys.stdout, **parameter):\n    \"\"\"Detect Cells in 3d grayscale image using DoG filtering and maxima detection\n    \n    Effectively this function performs the following steps:\n        * illumination correction via :func:`~ClearMap.ImageProcessing.IlluminationCorrection.correctIllumination`\n        * background removal via :func:`~ClearMap.ImageProcessing.BackgroundRemoval.removeBackground`\n        * difference of Gaussians (DoG) filter via :func:`~ClearMap.ImageProcessing.Filter.filterDoG`\n        * maxima detection via :func:`~ClearMap.ImageProcessing.MaximaDetection.findExtendedMaxima`\n        * cell shape detection via :func:`~ClearMap.ImageProcessing.CellSizeDetection.detectCellShape`\n        * cell intensity and size measurements via: :func:`~ClearMap.ImageProcessing.CellSizeDetection.findCellIntensity`,\n          :func:`~ClearMap.ImageProcessing.CellSizeDetection.findCellSize`. \n    \n    Note: \n        Processing steps are done in place to save memory.\n        \n    Arguments:\n        img (array): image data\n        detectSpotParameter: image processing parameter as described in the individual sub-routines\n        verbose (bool): print progress information\n        out (object): object to print progress information to\n        \n    Returns:\n        tuple: tuple of arrays (cell coordinates, raw intensity, fully filtered intensty, illumination and background corrected intensity [, cell size])\n    \"\"\"\n\n    timer = Timer();\n    \n    # normalize data -> to check\n    #img = img.astype('float');\n    #dmax = 0.075 * 65535;\n    #ids = img > dmax;\n    #img[ids] = dmax;\n    #img /= dmax; \n    #out.write(timer.elapsedTime(head = 'Normalization'));\n    #img = dataset[600:1000,1600:1800,800:830];\n    #img = dataset[600:1000,:,800:830];\n    \n    # correct illumination\n    correctIlluminationParameter = getParameter(detectSpotsParameter, \"correctIlluminationParameter\", correctIlluminationParameter);\n    img1 = img.copy();\n    img1 = correctIllumination(img1, correctIlluminationParameter = correctIlluminationParameter, verbose = verbose, out = out, **parameter)   \n\n    # background subtraction in each slice\n    #img2 = img.copy();\n    removeBackgroundParameter = getParameter(detectSpotsParameter, \"removeBackgroundParameter\", removeBackgroundParameter);\n    img2 = removeBackground(img1, removeBackgroundParameter = removeBackgroundParameter, verbose = verbose, out = out, **parameter)   \n    \n    # mask\n    #timer.reset();\n    #if mask == None: #explicit mask\n    #    mask = img > 0.01;\n    #    mask = binary_opening(mask, self.structureELement('Disk', (3,3,3)));\n    #img[img < 0.01] = 0; # masking in place  # extended maxima\n    #out.write(timer.elapsedTime(head = 'Mask'));    \n    \n    #DoG filter\n    filterDoGParameter = getParameter(detectSpotsParameter, \"filterDoGParameter\", filterDoGParameter);\n    dogSize = getParameter(filterDoGParameter, \"size\", None);\n    #img3 = img2.copy();    \n    img3 = filterDoG(img2, filterDoGParameter = filterDoGParameter, verbose = verbose, out = out, **parameter);\n    \n    # normalize    \n    #    imax = img.max();\n    #    if imax == 0:\n    #        imax = 1;\n    #    img /= imax;\n    \n    # extended maxima\n    findExtendedMaximaParameter = getParameter(detectSpotsParameter, \"findExtendedMaximaParameter\", findExtendedMaximaParameter);\n    hMax = getParameter(findExtendedMaximaParameter, \"hMax\", None);\n    imgmax = findExtendedMaxima(img3, findExtendedMaximaParameter = findExtendedMaximaParameter, verbose = verbose, out = out, **parameter);\n    \n    #center of maxima\n    if not hMax is None:\n        centers = findCenterOfMaxima(img, imgmax, verbose = verbose, out = out, **parameter);\n    else:\n        centers = findPixelCoordinates(imgmax, verbose = verbose, out = out, **parameter);\n    \n    #cell size detection\n    detectCellShapeParameter = getParameter(detectSpotsParameter, \"detectCellShapeParameter\", detectCellShapeParameter);\n    cellShapeThreshold = getParameter(detectCellShapeParameter, \"threshold\", None);\n    if not cellShapeThreshold is None:\n        \n        # cell shape via watershed\n        imgshape = detectCellShape(img2, centers, detectCellShapeParameter = detectCellShapeParameter, verbose = verbose, out = out, **parameter);\n        \n        #size of cells        \n", "context": "ClearMap/ImageProcessing/CellSizeDetection.py\ndef findCellSize(imglabel, findCelSizeParameter = None, maxLabel = None, verbose = False, \n                 out = sys.stdout, **parameter):\n    \"\"\"Find cell size given cell shapes as labled image\n\n    Arguments:\n        imglabel (array or str): labeled image, where each cell has its own label\n        findCelSizeParameter (dict):\n            =========== =================== ===========================================================\n            Name        Type                Descritption\n            =========== =================== ===========================================================\n            *maxLabel*  (int or None)       maximal label to include, if None determine automatically\n            *verbose*   (bool or int)       print / plot information about this step \n            =========== =================== ===========================================================\n        verbose (bool): print progress info \n        out (object): object to write progress info to\n        \n    Returns:\n        array: measured intensities \n    \"\"\"    \n       \n    maxLabel = getParameter(findCelSizeParameter, \"maxLabel\", maxLabel);\n    verbose  = getParameter(findCelSizeParameter, \"verbose\",  verbose); \n    \n    if verbose:\n        writeParameter(out = out, head = 'Cell size detection:', maxLabel = maxLabel);    \n    \n    timer = Timer();\n    \n    if maxLabel is None:\n        maxLabel = int(imglabel.max());\n     \n    size = scipy.ndimage.measurements.sum(numpy.ones(imglabel.shape, dtype = bool), labels = imglabel, index = numpy.arange(1, maxLabel + 1));\n    \n    if verbose:\n        out.write(timer.elapsedTime(head = 'Cell size detection:') + '\\n');\n    \n    return size\nClearMap/ImageProcessing/CellSizeDetection.py\ndef findCellIntensity(img, imglabel, findCellIntensityParameter = None, maxLabel = None, method = 'Sum', verbose = False, \n                      out = sys.stdout, **parameter):\n    \"\"\"Find integrated cell intensity given cell shapes as labled image\n        \n    Arguments:\n        img (array or str): image data\n        imglabel (array or str): labeled image, where each cell has its own label\n        findCellIntensityParameter (dict):\n            =========== =================== ===========================================================\n            Name        Type                Descritption\n            =========== =================== ===========================================================\n            *maxLabel*  (int or None)       maximal label to include, if None determine automatically\n            *method*    (str)               method to use for measurment: 'Sum', 'Mean', 'Max', 'Min'\n            *verbose*   (bool or int)       print / plot information about this step \n            =========== =================== ===========================================================\n        verbose (bool): print progress info \n        out (object): object to write progress info to\n        \n    Returns:\n        array: measured intensities \n    \"\"\"    \n    \n    maxLabel = getParameter(findCellIntensityParameter, \"maxLabel\", maxLabel);\n    method   = getParameter(findCellIntensityParameter, \"method\", method);\n    verbose  = getParameter(findCellIntensityParameter, \"verbose\", verbose);\n    \n    if verbose:\n        writeParameter(out = out, head = 'Cell intensity detection:', method = method, maxLabel = maxLabel);  \n    \n    timer = Timer();\n    \n    if maxLabel is None:\n        maxLabel = imglabel.max();    \n    \n    if method.lower() == 'sum':\n        i = scipy.ndimage.measurements.sum(img, labels = imglabel, index = numpy.arange(1, maxLabel + 1));\n    elif method.lower() == 'mean':\n        i = scipy.ndimage.measurements.mean(img, labels = imglabel, index = numpy.arange(1, maxLabel + 1));\n    elif method.lower() == 'max':\n        i = scipy.ndimage.measurements.maximum(img, labels = imglabel, index = numpy.arange(1, maxLabel + 1));\n    elif method.lower() == 'min':\n        i = scipy.ndimage.measurements.minimum(img, labels = imglabel, index = numpy.arange(1, maxLabel + 1));\n    else:\n        raise RuntimeError('cellIntensity: unkown method %s!' % method);\n    \n    if verbose:\n        out.write(timer.elapsedTime(head = 'Cell intensity detection:') + '\\n');\n    \n    return i\nClearMap/ImageProcessing/BackgroundRemoval.py\ndef removeBackground(img, removeBackgroundParameter = None, size = None, save = None, verbose = False,\n                     subStack = None, out = sys.stdout, **parameter):\n    \"\"\"Remove background via subtracting a morphological opening from the original image \n    \n    Background removal is done z-slice by z-slice.\n    \n    Arguments:\n        img (array): image data\n        removeBackGroundParameter (dict):\n            ========= ==================== ===========================================================\n            Name      Type                 Descritption\n            ========= ==================== ===========================================================\n            *size*    (tuple or None)      size for the structure element of the morphological opening\n                                           if None, do not correct for any background\n            *save*    (str or None)        file name to save result of this operation\n                                           if None dont save to file\n            *verbose* (bool or int)        print / plot information about this step                                 \n            ========= ==================== ===========================================================\n        subStack (dict or None): sub-stack information \n        verbose (bool): print progress info \n        out (object): object to write progress info to\n        \n    Returns:\n        array: background corrected image\n    \"\"\"\n    \n    size = getParameter(removeBackgroundParameter, \"size\", size);\n    save = getParameter(removeBackgroundParameter, \"save\", save);    \n    verbose = getParameter(removeBackgroundParameter, \"verbose\", verbose);   \n    \n    if verbose:\n        writeParameter(out = out, head = 'Background Removal:', size = size, save = save);    \n    \n    if size is None:    \n        return img;\n        \n    img = io.readData(img);\n    \n    # change type to float in order to prevent \n    dtype = img.dtype;\n    img = numpy.array(img, dtype = float);\n    \n    timer = Timer();\n    # background subtraction in each slice\n    se = structureElement('Disk', size).astype('uint8');\n    for z in range(img.shape[2]):\n         #img[:,:,z] = img[:,:,z] - grey_opening(img[:,:,z], structure = structureElement('Disk', (30,30)));\n         #img[:,:,z] = img[:,:,z] - morph.grey_opening(img[:,:,z], structure = self.structureELement('Disk', (150,150)));\n         img[:,:,z] = img[:,:,z] - cv2.morphologyEx(img[:,:,z], cv2.MORPH_OPEN, se)\n    \n    img[img < 0] = 0;\n    img = numpy.array(img, dtype = dtype);\n    \n    if not save is None:\n        writeSubStack(save, img, subStack = subStack)\n\n    if verbose > 1:\n        plotTiling(10*img);\n\n    if verbose:\n        out.write(timer.elapsedTime(head = 'Background') + '\\n');\n    \n    return img\nClearMap/Utils/Timer.py\nclass Timer(object):\n    \"\"\"Class to stop time and print results in formatted way\n    \n    Attributes:\n        time (float): the time since the timer was started\n    \"\"\"\n    def __init__(self, verbose=False):\n        self.verbose = verbose;\n        self.start();\n\n    def start(self):\n        \"\"\"Start the timer\"\"\"\n        self.time = time.time();\n    \n    def reset(self):\n        \"\"\"Reset the timer\"\"\"\n        self.time = time.time();\n    \n    def elapsedTime(self, head = None, asstring = True):\n        \"\"\"Calculate elapsed time and return as formated string\n        \n        Arguments:\n            head (str or None): prefix to the string\n            asstring (bool): return as string or float\n        \n        Returns:\n            str or float: elapsed time\n        \"\"\"\n        \n        t = time.time();\n        \n        if asstring:\n            t = self.formatElapsedTime(t - self.time);\n            if head != None:\n                return head + \": elapsed time: \" + t;\n            else:\n                return \"Elapsed time: \" + t;\n        else:\n            return t - self.time;\n    \n    def printElapsedTime(self, head = None):\n        \"\"\"Print elapsed time as formated string\n        \n        Arguments:\n            head (str or None): prefix to the string\n        \"\"\"\n        print self.elapsedTime(head = head);\n    \n    def formatElapsedTime(self, t):\n        \"\"\"Format time to string\n        \n        Arguments:\n            t (float): time in seconds prefix\n        \n        Returns:\n            str: time as hours:minutes:seconds\n        \"\"\"\n        m, s = divmod(t, 60);\n        h, m = divmod(m, 60);\n        \n        return \"%d:%02d:%02d\" % (h, m, s);\nClearMap/ImageProcessing/MaximaDetection.py\ndef findExtendedMaxima(img, findExtendedMaximaParameter = None, hMax = None, size = 5, threshold = None, save = None, verbose = None,\n                       subStack = None,  out = sys.stdout, **parameter):\n    \"\"\"Find extended maxima in an image \n    \n    Effectively this routine performs a h-max transfrom, followed by a local maxima search and \n    thresholding of the maxima.\n    \n    Arguments:\n        img (array): image data\n        findExtendedMaximaParameter (dict):\n            =========== =================== ===========================================================\n            Name        Type                Descritption\n            =========== =================== ===========================================================\n            *hMax*      (float or None)     h parameter for the initial h-Max transform\n                                            if None, do not perform a h-max transform\n            *size*      (tuple)             size for the structure element for the local maxima filter\n            *threshold* (float or None)     include only maxima larger than a threshold\n                                            if None keep all localmaxima\n            *save*      (str or None)       file name to save result of this operation\n                                            if None do not save result to file\n            *verbose*   (bool or int)        print / plot information about this step                                             \n            =========== =================== ===========================================================\n        subStack (dict or None): sub-stack information \n        verbose (bool): print progress info \n        out (object): object to write progress info to\n        \n    Returns:\n        array: binary image with True pixel at extended maxima\n        \n    See Also:\n        :func:`hMaxTransform`, :func:`localMax`\n    \"\"\"\n    \n    hMax      = getParameter(findExtendedMaximaParameter, \"hMax\", hMax);\n    size      = getParameter(findExtendedMaximaParameter, \"size\", size);\n    threshold = getParameter(findExtendedMaximaParameter, \"threshold\", threshold);\n    save      = getParameter(findExtendedMaximaParameter, \"save\", save);\n    verbose   = getParameter(findExtendedMaximaParameter, \"verbose\", verbose);\n\n    if verbose:\n        writeParameter(out = out, head = 'Extended Max:', hMax = hMax, size = size, threshold = threshold, save = save);\n    \n    timer = Timer();\n    \n    ## extended maxima    \n    imgmax = hMaxTransform(img, hMax);\n        \n    #imgmax = regionalMax(imgmax, regionalMaxStructureElement);\n    imgmax = localMax(imgmax, size);\n    \n    #thresholding    \n    if not threshold is None:\n        imgmax = numpy.logical_and(imgmax, img >= threshold);\n    \n    if verbose > 1:\n        #plotTiling(img)\n        plotOverlayLabel(img * 0.01, imgmax.astype('int64'), alpha = False);\n        #plotOverlayLabel(img, imgmax.astype('int64'), alpha = True)     \n\n    if not save is None:#\n        writeSubStack(save, imgmax.astype('int8'), subStack = subStack)\n        \n    if verbose:\n        out.write(timer.elapsedTime(head = 'Extended Max') + '\\n');\n    \n    return imgmax\nClearMap/ImageProcessing/MaximaDetection.py\ndef findPixelCoordinates(imgmax, subStack = None, verbose = False, out = sys.stdout, **parameter):\n    \"\"\"Find coordinates of all pixel in an image with positive or True value\n           \n    Arguments:\n        img (array): image data\n        verbose (bool): print progress info \n        out (object): object to write progress info to\n        \n    Returns:\n        array: coordinates of centers of True pixels, shape is (n,d)  where n is number of maxima and d the dimension of the image\n    \"\"\"\n    \n    timer = Timer(); \n    \n    centers = numpy.nonzero(imgmax);\n    centers = numpy.vstack(centers).T;\n    \n    if verbose:\n        out.write(timer.elapsedTime(head = 'Cell Centers') + '\\n');\n    \n    return centers;\nClearMap/Utils/ParameterTools.py\ndef getParameter(parameter, key, default = None):\n    \"\"\"Gets a parameter from a dict, returns default value if not defined\n    \n    Arguments:\n        parameter (dict): parameter dictionary\n        key (object): key \n        default (object): deault return value if parameter not defined\n    \n    Returns:\n       object: parameter value for key\n    \"\"\"\n    \n    if not isinstance(parameter, dict):\n        return default;\n    \n    if key in parameter.keys():\n        return parameter[key];\n    else:\n        return default;\nClearMap/ImageProcessing/Filter/DoGFilter.py\ndef filterDoG(img, filterDoGParameter = None,  size = None, sigma = None, sigma2 = None, save = None, verbose = None,\n              subStack = None, out = sys.stdout, **parameter):\n    \"\"\"Difference of Gaussians (DoG) filter step\n    \n    Arguments:\n        img (array): image data\n        filterDoGParameter (dict):\n            ========= ==================== ================================================================\n            Name      Type                 Descritption\n            ========= ==================== ================================================================\n            *size*    (tuple or None)      size for the DoG filter \n                                           if None, do not correct for any background\n            *sigma*   (tuple or None)      std of outer Guassian, if None autmatically determined from size\n            *sigma2*  (tuple or None)      std of inner Guassian, if None autmatically determined from size\n            *save*    (str or None)        file name to save result of this operation\n                                           if None dont save to file \n            *verbose* (bool or int)        print progress information                            \n            ========= ==================== ================================================================\n        subStack (dict or None): sub-stack information \n        out (object): object to write progress info to\n        \n    Returns:\n        array: DoG filtered image\n    \"\"\"\n    \n    timer = Timer();  \n    \n    dogSize  = getParameter(filterDoGParameter, \"size\",  size);\n    dogSigma = getParameter(filterDoGParameter, \"sigma\", sigma);\n    dogSigma2= getParameter(filterDoGParameter, \"sigma2\",sigma2);\n    dogSave  = getParameter(filterDoGParameter, \"save\",  save);\n    verbose  = getParameter(filterDoGParameter, \"verbose\",  verbose);\n    \n    if verbose:\n        writeParameter(out = out, head = 'DoG:', size = dogSize, sigma = dogSigma, sigma2 = dogSigma2, save = dogSave);\n    #DoG filter\n    img = img.astype('float32'); # always convert to float for downstream processing\n        \n    if not dogSize is None:\n        fdog = filterKernel(ftype = 'DoG', size = dogSize, sigma = dogSigma, sigma2 = dogSigma2);\n        fdog = fdog.astype('float32');\n        #img = correlate(img, fdog);\n        #img = scipy.signal.correlate(img, fdog);\n        img = correlate(img, fdog);\n        #img = convolve(img, fdog, mode = 'same');\n        img[img < 0] = 0;\n    \n    if verbose > 1:\n        plotTiling(img);\n    \n    if not dogSave is None:\n        writeSubStack(dogSave, img, subStack = subStack);\n    \n    if verbose:\n        out.write(timer.elapsedTime(head = 'DoG') + '\\n');\n    \n    return img\nClearMap/ImageProcessing/IlluminationCorrection.py\ndef correctIllumination(img, correctIlluminationParameter = None, flatfield = None, background = None, scaling = None, save = None, verbose = False, \n                        subStack = None, out = sys.stdout, **parameter):\n    \"\"\"Correct illumination variations\n    \n     The intensity image :math:`I(x)` given a flat field :math:`F(x)` and \n     a background :math:`B(x)` the image is corrected to :math:`C(x)` as:\n     \n     .. math:\n         C(x) = \\\\frac{I(x) - B(x)}{F(x) - B(x)}\n         \n     If the background is not given :math:`B(x) = 0`. \n     \n     The correction is done slice by slice assuming the data was collected with \n     a light sheet microscope.\n     \n     The image is finally optionally scaled.\n  \n    Arguments:\n        img (array): image data\n        findCenterOfMaximaParameter (dict):\n            ============ ==================== ===========================================================\n            Name         Type                 Descritption\n            ============ ==================== ===========================================================\n            *flatfield*  (str, None or array) flat field intensities, if None d onot correct image for\n                                              illumination, if True the \n            *background* (str, None or array) background image as file name or array\n                                              if None background is assumed to be zero\n            *scaling*    (str or None)        scale the corrected result by this factor\n                                              if 'max'/'mean' scale to keep max/mean invariant\n            *save*       (str or None)        save the corrected image to file\n            *verbose*    (bool or int)        print / plot information about this step \n            ============ ==================== ===========================================================\n        subStack (dict or None): sub-stack information \n        verbose (bool): print progress info \n        out (object): object to write progress info to\n    \n    Returns:\n        array: illumination corrected image\n        \n        \n    References: \n        Fundamentals of Light Microscopy and Electronic Imaging, p 421        \n        \n    See Also:\n        :const:`DefaultFlatFieldLineFile`\n    \"\"\"  \n    \n    flatfield  = getParameter(correctIlluminationParameter, \"flatfield\",  flatfield);\n    background = getParameter(correctIlluminationParameter, \"background\", background);\n    scaling    = getParameter(correctIlluminationParameter, \"scaling\",    scaling);\n    save       = getParameter(correctIlluminationParameter, \"save\",       save);\n    verbose    = getParameter(correctIlluminationParameter, \"verbose\",    verbose);\n\n    if verbose:    \n        if flatfield is None or isinstance(flatfield, str) or flatfield is True:\n            fld = flatfield;\n        else:\n            fld = \"image of size %s\" % str(flatfield.shape);\n    \n        if background is None or isinstance(background, str):\n            bkg = background;\n        else:\n            bkg = \"image of size %s\" % str(background.shape);\n        \n        writeParameter(out = out, head = 'Illumination correction:', flatfield = fld, background = bkg, scaling = scaling, save = save);  \n    \n    \n    print subStack;\n \n    if not subStack is None:\n        x = subStack[\"x\"];\n        y = subStack[\"y\"];\n    else:\n        x = all;\n        y = all;\n    \n    #print \"sizes\", x, y, img.shape\n \n    #read data  \n \n    timer = Timer(); \n \n    if flatfield is None:\n        return img;\n        \n    elif flatfield is True:\n        # default flatfield correction\n    \n        if subStack is None:    \n            flatfield = flatfieldFromLine(DefaultFlatFieldLineFile, img.shape[0]);\n        else:\n            dataSize = io.dataSize(subStack[\"source\"]);\n            flatfield = flatfieldFromLine(DefaultFlatFieldLineFile, dataSize[0]);\n            \n    elif isinstance(flatfield, str):\n        # point or image file\n        if io.isPointFile(flatfield):\n            if subStack is None:    \n                flatfield = flatfieldFromLine(flatfield, img.shape[0]);\n            else:\n               dataSize = io.dataSize(subStack[\"source\"]);\n               flatfield = flatfieldFromLine(flatfield, dataSize[0]);\n        else:\n            flatfield = io.readData(flatfield);\n    \n    ffmean = flatfield.mean();    \n    ffmax = flatfield.max();\n\n    #correct for subset\n    flatfield = io.readData(flatfield, x = x, y = y);   \n    \n    background = io.readData(background, x = x, y = y);\n    \n    if flatfield.shape != img[:,:,0].shape:\n        raise RuntimeError(\"correctIllumination: flatfield does not match image size: %s vs %s\" % (flatfield.shape,  img[:,:,0].shape));\n    \n    #convert to float for scaling\n    dtype = img.dtype;\n    img = img.astype('float32');\n    flatfield = flatfield.astype('float32');\n    \n    # illumination correction in each slice\n    if background is None:\n        for z in range(img.shape[2]):\n            img[:,:,z] = img[:,:,z] / flatfield;\n    else:\n        if background.shape != flatfield.shape:\n            raise RuntimeError(\"correctIllumination: background does not match image size: %s vs %s\" % (background.shape,  img[:,:,0].shape));        \n        background = background.astype('float32');\n\n        flatfield = (flatfield - background);\n        for z in range(img.shape[2]):\n            img[:,:,z] = (img[:,:,z] - background) / flatfield;\n    \n        \n    # rescale\n    if scaling is True:\n        scaling = \"mean\";\n    \n    if isinstance(scaling, str):\n        if scaling.lower() == \"mean\":\n            # scale back by average flat field correction:\n            sf = ffmean;\n        elif scaling.lower() == \"max\":\n            sf = ffmax;\n        else:\n            raise RuntimeError('Scaling not \"Max\" or \"Mean\" but %s' % scaling);\n    else:\n        sf = scaling;\n      \n    if verbose:\n         writeParameter(out = out, head = 'Illumination correction:',  scaling = sf);\n    \n        \n    \n    if not sf is None:\n        img = img * sf;\n        img = img.astype(dtype);\n    \n    \n    #write result for inspection\n    if not save is None:\n        writeSubStack(save, img, subStack = subStack);    \n    \n    #plot result for inspection\n    if verbose > 1:\n        plotTiling(img);\n    \n    if verbose:\n        out.write(timer.elapsedTime(head = 'Illumination correction') + '\\n');    \n    \n    return img \nClearMap/ImageProcessing/CellSizeDetection.py\ndef detectCellShape(img, peaks, detectCellShapeParameter = None, threshold = None, save = None, verbose = False, \n                    subStack = None, out = sys.stdout, **parameter):\n    \"\"\"Find cell shapes as labeled image\n    \n    Arguments:\n        img (array): image data\n        peaks (array): point data of cell centers / seeds\n        detectCellShape (dict):\n            ============ =================== ===========================================================\n            Name         Type                Descritption\n            ============ =================== ===========================================================\n            *threshold*  (float or None)     threshold to determine mask, pixel below this are background\n                                             if None no mask is generated\n            *save*       (tuple)             size of the box on which to perform the *method*\n            *verbose*    (bool or int)       print / plot information about this step \n            ============ =================== ===========================================================\n        verbose (bool): print progress info \n        out (object): object to write progress info to\n        \n    Returns:\n        array: labeled image where each label indicates a cell \n    \"\"\"    \n    \n    threshold = getParameter(detectCellShapeParameter, \"threshold\", threshold);\n    save      = getParameter(detectCellShapeParameter, \"save\", save);    \n    verbose   = getParameter(detectCellShapeParameter, \"verbose\", verbose);  \n    \n    if verbose:\n        writeParameter(out = out, head = 'Cell shape detection:', threshold = threshold, save = save);    \n    \n    # extended maxima\n    timer = Timer();\n    \n    if threshold is None:\n        imgmask = None;\n    else:\n        imgmask = img > threshold;\n        \n    imgpeaks = voxelizePixel(peaks, dataSize = img.shape, weights = numpy.arange(1, peaks.shape[0]+1));\n    \n    imgws = watershed(-img, imgpeaks, mask = imgmask);\n    #imgws = watershed_ift(-img.astype('uint16'), imgpeaks);\n    #imgws[numpy.logical_not(imgmask)] = 0;\n    \n    if not save is None:\n        writeSubStack(save, imgws.astype('int32'), subStack = subStack);\n    \n    \n    if verbose > 1:\n        #plotTiling(img)\n        plotOverlayLabel(img * 0.01, imgws, alpha = False);\n        #plotOverlayLabel(img, imgmax.astype('int64'), alpha = True)     \n    \n    if verbose:\n        out.write(timer.elapsedTime(head = 'Cell Shape:') + '\\n');\n    \n    return imgws\nClearMap/ImageProcessing/MaximaDetection.py\ndef findIntensity(img, centers, findIntensityParameter = None, method = None, size = (3,3,3), verbose = False, \n                  out = sys.stdout, **parameter):\n    \"\"\"Find instensity value around centers in the image\n    \n    Arguments:\n        img (array): image data\n        findIntensityParameter (dict):\n            =========== =================== ===========================================================\n            Name        Type                Descritption\n            =========== =================== ===========================================================\n            *method*    (str, func, None)   method to use to determine intensity (e.g. \"Max\" or \"Mean\")\n                                            if None take intensities at the given pixels\n            *size*      (tuple)             size of the box on which to perform the *method*\n            *verbose*   (bool or int)       print / plot information about this step \n            =========== =================== ===========================================================\n        verbose (bool): print progress info \n        out (object): object to write progress info to\n        \n    Returns:\n        array: measured intensities \n    \"\"\"\n    \n    method  = getParameter(findIntensityParameter, \"method\", \"Max\"); \n    size    = getParameter(findIntensityParameter, \"size\", (3,3,3)); \n    verbose = getParameter(findIntensityParameter, \"verbose\", verbose); \n     \n    if verbose:\n        writeParameter(out = out, head = 'Cell Intensities:', method = method, size = size);\n\n    timer = Timer(); \n        \n    if centers.shape[0] == 0:\n        return numpy.zeros(0);\n    \n    if method is None:\n            return numpy.array([img[centers[i,0], centers[i,1], centers[i,2]] for i in range(centers.shape[0])]);        \n    \n    isize = img.shape;\n    #print isize\n    \n    offs = structureElementOffsets(size);\n    \n    if isinstance(method, basestring):\n        method = eval('numpy.' + method.lower());\n\n\n    intensities = numpy.zeros(centers.shape[0], dtype = img.dtype);\n    \n    for c in range(centers.shape[0]):\n        xmin = int(-offs[0,0] + centers[c,0]);\n        if xmin < 0:\n            xmin = 0;       \n        xmax = int(offs[0,1] + centers[c,0]);\n        if xmax > isize[0]:\n            xmax = isize[0];\n            \n        ymin = int(-offs[1,0] + centers[c,1]);\n        if ymin < 0:\n            ymin = 0;       \n        ymax = int(offs[1,1] + centers[c,1]);\n        if ymax > isize[1]:\n            ymax = isize[1];\n            \n        zmin = int(-offs[2,0] + centers[c,2]);\n        if zmin < 0:\n            zmin = 0;       \n        zmax = int(offs[1,1] + centers[c,2]);\n        if zmax > isize[2]:\n            zmax = isize[2];\n        \n        #print xmin, xmax, ymin, ymax, zmin, zmax\n        data = img[xmin:xmax, ymin:ymax, zmin:zmax];\n        \n        intensities[c] = method(data);\n    \n    if verbose:\n        out.write(timer.elapsedTime(head = 'Cell Intensities'));\n    \n    return intensities;\nClearMap/ImageProcessing/MaximaDetection.py\ndef findCenterOfMaxima(img, imgmax = None, label = None, findCenterOfMaximaParameter = None, save = None, verbose = False,\n                       subStack = None, out = sys.stdout, **parameter):\n    \"\"\"Find center of detected maxima weighted by intensity\n    \n    Arguments:\n        img (array): image data\n        findCenterOfMaximaParameter (dict):\n            ========= ==================== ===========================================================\n            Name      Type                 Descritption\n            ========= ==================== ===========================================================\n            *save*    (str or None)        saves result of labeling the differnet maxima\n                                           if None, do the lableling is not saved\n            *verbose* (bool or int)        print / plot information about this step         \n            ========= ==================== ===========================================================\n        subStack (dict or None): sub-stack information \n        verbose (bool): print progress info \n        out (object): object to write progress info to\n    \n    Returns:\n        array: coordinates of centers of maxima, shape is (n,d) where n is number of maxima and d the dimension of the image\n    \"\"\"\n    \n    save    = getParameter(findCenterOfMaximaParameter, \"save\", save);\n    verbose = getParameter(findCenterOfMaximaParameter, \"verbose\", verbose);\n    \n    if verbose:\n        writeParameter(out = out, head = 'Center of Maxima:', save = save);\n    \n    timer = Timer(); \n\n    #center of maxima\n    if label is None:\n        imglab, nlab = sm.label(imgmax);  \n    else:\n        imglab = label;\n        nlab = imglab.max();\n       \n    #print 'max', imglab.shape, img.shape\n    #print imglab.dtype, img.dtype\n    \n    if not save is None:\n        writeSubStack(save, imglab, subStack = subStack);\n    \n    if nlab > 0:\n        centers = numpy.array(sm.center_of_mass(img, imglab, index = numpy.arange(1, nlab)));    \n    \n        if verbose > 1:  \n            #plotOverlayLabel(img * 0.01, imglab, alpha = False);\n            #plotTiling(img)\n            imgc = numpy.zeros(img.shape);\n            for i in range(centers.shape[0]):\n                imgc[centers[i,0], centers[i,1], centers[i,2]] = 1;\n            plotOverlayLabel(img, imgc, alpha = False);\n            #plotOverlayLabel(img, imgmax.astype('int64'), alpha = True)     \n    \n        #return centers, imglab, mask\n        #cintensity = numpy.array([img[centers[i,0], centers[i,1], centers[i,2]] for i in range(centers.shape[0])]);\n        \n        if verbose:\n            out.write(timer.elapsedTime(head = 'Cell Centers'));\n        \n        #return ( centers, cintensity );\n        return centers;\n        \n    else:\n        \n        if verbose:\n            out.write('Cell Centers: No Cells found !');\n            #return ( numpy.zeros((0,3)), numpy.zeros(0) );\n        \n        #return empty set o coordinates\n        return numpy.zeros((0,3));\n", "answers": ["        csize = findCellSize(imgshape, maxLabel = centers.shape[0], out = out, **parameter);"], "length": 3561, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "e7bbb35f55ece95e727c9fe2423d5ad8587353fa646d0b80"}
{"input": "import com.badlogic.gdx.Game;\nimport com.badlogic.gdx.Gdx;\nimport com.badlogic.gdx.audio.Music;\nimport com.badlogic.gdx.math.Vector2;\nimport com.badlogic.gdx.utils.Array;\nimport com.fteams.sstrain.World;\nimport com.fteams.sstrain.assets.Assets;\nimport com.fteams.sstrain.config.GlobalConfiguration;\nimport com.fteams.sstrain.entities.Results;\nimport com.fteams.sstrain.objects.AccuracyMarker;\nimport com.fteams.sstrain.objects.AccuracyPopup;\nimport com.fteams.sstrain.objects.Circle;\nimport com.fteams.sstrain.objects.TapZone;\nimport com.fteams.sstrain.screens.ResultsScreen;\nimport com.fteams.sstrain.util.Accuracy;\nimport com.fteams.sstrain.util.SongUtils;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n        // otherwise just play the beatmap\n        {\n            time += delta;\n        }\n        oldTime = time;\n    }\n\n    private float calculateAccuracy() {\n        float sum = 0f;\n        List<Float> high = new ArrayList<>();\n        List<Float> low = new ArrayList<>();\n        for (AccuracyMarker hit : world.getAccuracyMarkers()) {\n            sum += hit.getTime();\n        }\n        float average = sum / world.getAccuracyMarkers().size;\n        for (AccuracyMarker value : world.getAccuracyMarkers()) {\n            if (value.getTime() >= average) {\n                high.add(value.getTime());\n            } else {\n                low.add(value.getTime());\n            }\n        }\n\n        Results.minAccuracy = calcAverage(low);\n        Results.maxAccuracy = calcAverage(high);\n        Results.unstableRating = 10 * calcDeviation(world.getAccuracyMarkers());\n\n        return sum / world.getAccuracyMarkers().size;\n    }\n\n    private float calcAverage(List<Float> values) {\n        float sum = 0;\n        for (Float value : values) {\n            sum += value;\n        }\n        return sum / values.size();\n    }\n\n    private float calcDeviation(Array<AccuracyMarker> values) {\n        if (values.size == 0)\n            return 0f;\n\n        float sum = 0f;\n        for (AccuracyMarker value : values) {\n            sum += value.getTime();\n        }\n\n        float mean = sum / values.size;\n        sum = 0f;\n        for (AccuracyMarker value : values) {\n            sum += (value.getTime() - mean) * (value.getTime() - mean);\n        }\n        return (float) Math.sqrt(sum / (values.size - 1));\n    }\n\n\n    private void processAccuracy(Accuracy accuracy, Accuracy accuracy2, boolean isHold) {\n        if (!isHold) {\n            if (accuracy == Accuracy.BAD) {\n                badCount++;\n                if (combo > largestCombo) {\n                    largestCombo = combo;\n                }\n                combo = 0;\n                world.combo = 0;\n            } else if (accuracy == Accuracy.NICE) {\n                goodCount++;\n                if (combo > largestCombo) {\n                    largestCombo = combo;\n                }\n                combo = 0;\n                world.combo = 0;\n            } else if (accuracy == Accuracy.GREAT) {\n                greatCount++;\n                combo++;\n                world.combo = combo;\n            } else if (accuracy == Accuracy.PERFECT) {\n                perfectCount++;\n                combo++;\n                world.combo = combo;\n            } else {\n                missCount++;\n                if (combo > largestCombo) {\n                    largestCombo = combo;\n                }\n                combo = 0;\n                world.combo = 0;\n            }\n        } else {\n            // no combo break\n            Accuracy lowest = accuracy.compareTo(accuracy2) >= 0 ? accuracy2 : accuracy;\n\n            if (lowest == Accuracy.BAD) {\n                badCount++;\n            } else if (lowest == Accuracy.NICE) {\n                goodCount++;\n            } else if (lowest == Accuracy.GREAT) {\n                greatCount++;\n            } else if (lowest == Accuracy.PERFECT) {\n                perfectCount++;\n            } else {\n                missCount++;\n            }\n            if (accuracy2.compareTo(Accuracy.NICE) > 0) {\n                combo++;\n                world.combo = combo;\n            } else {\n                if (combo > largestCombo) {\n                    largestCombo = combo;\n                }\n                combo = 0;\n                world.combo = 0;\n\n            }\n\n        }\n    }\n\n    private void playTapSoundForAccuracy(Accuracy accuracy) {\n        if (accuracy == Accuracy.PERFECT) {", "context": "core/src/com/fteams/sstrain/util/SongUtils.java\npublic class SongUtils {\n    public final static Long NOTE_TYPE_NORMAL = 1l;\n    public final static Long NOTE_TYPE_HOLD = 2l;\n\n    public final static Integer NOTE_SYNC_OFF = 0;\n    public final static Integer NOTE_SYNC_ON = 1;\n\n    public final static Long NOTE_NO_SWIPE = 0L;\n    public final static Long NOTE_SWIPE_LEFT = 1L;\n    public final static Long NOTE_SWIPE_RIGHT = 2L;\n\n    public final static Integer SORTING_MODE_FILE_NAME = 0;\n    public final static Integer SORTING_MODE_SONG_NAME = 1;\n    public final static Integer SORTING_MODE_SONG_ID = 2;\n    public final static Integer SORTING_MODE_ATTRIBUTE = 3;\n\n    public final static Integer SORTING_MODE_ASCENDING = 0;\n    public final static Integer SORTING_MODE_DESCENDING = 1;\n\n    public final static Integer SYNC_MODE_1 = 0;\n    public final static Integer SYNC_MODE_2 = 1;\n    public final static Integer SYNC_MODE_3 = 2;\n    public final static Integer SYNC_DISABLED = 3;\n\n    public final static Integer GAME_MODE_NORMAL = 0;\n    public final static Integer GAME_MODE_ABREPEAT = 1;\n\n    public final static String[] syncModes = {\"Default\", \"Constant Sync\", \"Initial Sync\", \"Disabled\"};\n    public final static Long[] noteSpeeds = {1800L, 1680L, 1560L, 1440L, 1320L, 1200L, 1050L, 900L, 750L, 600L, 450L};\n\n    public final static Double[] overallDiffPerfect = {79.5, 73.5, 67.5, 61.5, 56.5, 49.5, 43.5, 37.5, 31.5, 25.5, 19.5}; // -6\n    public final static Double[] overallDiffGreat = {139.5, 131.5, 123.5, 115.5, 107.5, 99.5, 91.5, 83.5, 75.5, 67.5, 59.5}; // -8\n    public final static Double[] overallDiffNice = {199.5, 189.5, 179.5, 169.5, 159.5, 149.5, 139.5, 129.5, 119.5, 109.5, 99.5}; // - 10\n    public final static Double[] overallDiffBad = {249.5, 237.5, 225.5, 213.5, 201.5, 189.5, 177.5, 165.5, 153.5, 141.5, 129.5};// - 12\n\n    public static Long getSpeedFromConfig(Integer noteSpeed) {\n        return noteSpeeds[noteSpeed];\n    }\n\n    public final static String[] attributes = {\"Cute\", \"Cool\", \"Passion\", \"ALL\"};\n\n    public static String getAttribute(Long attribute) {\n        if (attribute == null) {\n            return \"Unknown\";\n        }\n        if (attribute == 0) {\n            return \"TUTORIAL\";\n        }\n        return attributes[(int) (attribute - 1)];\n    }\n\n    public static int compare(int x, int y) {\n        return (x < y) ? -1 : ((x == y) ? 0 : 1);\n    }\n\n    public static int compare(long x, long y) {\n        return (x < y) ? -1 : ((x == y) ? 0 : 1);\n    }\n}\ncore/src/com/fteams/sstrain/screens/ResultsScreen.java\npublic class ResultsScreen implements Screen {\n\n    Stage stage = new Stage();\n    private Texture texture = Assets.mainMenuBackgroundTexture;\n    private Image splashImage = new Image(texture);\n    private Table table = new Table();\n    private Label difficulty = new Label(\"Difficulty:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label difficultyLabel;\n    private Label approachRateLabel = new Label(\"Approach Rate:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label approachRateConfigLabel;\n    private Label overallDifficultyLabel = new Label(\"Overall Difficulty:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label overallDifficultyConfigLabel;\n    private Label accuracyLabel = new Label(\"Avg. Accuracy:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label accuracyResultLabel;\n    private Label normalizedAccuracyLabel = new Label(\"% Accuracy:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label normalizedAccuracyResultLabel;\n    private Label accuracyRangeLabel = new Label(\"Accuracy Range:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label accuracyRangeResultLabel;\n    private Label unstableRatingLabel = new Label(\"Unstable Rating:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label unstableRatingValueLabel;\n    private Label badLabel = new Label(\"Bad:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label badResultLabel;\n    private Label goodLabel = new Label(\"Nice:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label goodResultLabel;\n    private Label greatLabel = new Label(\"Great\", Assets.menuSkin, \"song_style_result_values\");\n    private Label greatResultLabel;\n    private Label perfectLabel = new Label(\"Perfect:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label perfectResultLabel;\n    private Label missLabel = new Label(\"Miss:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label missResultLabel;\n    private Label comboLabel = new Label(\"Largest Combo:\", Assets.menuSkin, \"song_style_result_values\");\n    private Label comboResultLabel;\n    private Label titleLabel = new Label(\"Results/結果発表\", Assets.menuSkin, \"results_title\");\n\n    @Override\n    public void show() {\n        // title font scale = 1 for a 720 height\n        float fontScale = stage.getHeight() / GlobalConfiguration.BASE_HEIGHT;\n\n        splashImage.setHeight(stage.getHeight());\n        splashImage.setWidth(stage.getWidth());\n        stage.addActor(splashImage);\n        titleLabel.setX(stage.getWidth() / 2 - titleLabel.getWidth() / 2);\n        titleLabel.setY(stage.getHeight() - stage.getHeight() * 0.3f);\n        titleLabel.setFontScale(fontScale);\n\n        table.setFillParent(true);\n\n        difficultyLabel = new Label(Assets.selectedBeatmap.metadata.difficulty == null ? Assets.selectedBeatmap.metadata.difficulty + \"*\" : Assets.selectedBeatmap.metadata.difficultyName, Assets.menuSkin, \"song_style_result_values\");\n        approachRateConfigLabel = new Label(\"AR-\" + GlobalConfiguration.noteSpeed + \" (\" + SongUtils.getSpeedFromConfig(GlobalConfiguration.noteSpeed) + \" ms)\", Assets.menuSkin, \"song_style_result_values\");\n        overallDifficultyConfigLabel = new Label(\"OD-\" + GlobalConfiguration.overallDifficulty + \" (\" + SongUtils.overallDiffBad[GlobalConfiguration.overallDifficulty] + \" ms)\", Assets.menuSkin, \"song_style_result_values\");\n        accuracyResultLabel = new Label(String.format(\"%.2f\", Results.accuracy * 1000) + \" ms.\", Assets.menuSkin, \"song_style_result_values\");\n        accuracyRangeResultLabel = new Label(String.format(\"%.2f\", Results.minAccuracy * 1000) + \" ms. to \" + String.format(\"%.2f\", Results.maxAccuracy * 1000) + \" ms.\", Assets.menuSkin, \"song_style_result_values\");\n        normalizedAccuracyResultLabel = new Label(String.format(\"%.2f\", Results.normalizedAccuracy * 100f) + \"%\", Assets.menuSkin, \"song_style_result_values\");\n        unstableRatingValueLabel = new Label(String.format(\"%.2f\", Results.unstableRating * 1000), Assets.menuSkin, \"song_style_result_values\");\n        missResultLabel = new Label(Integer.toString(Results.miss), Assets.menuSkin, \"song_style_result_values\");\n        badResultLabel = new Label(Integer.toString(Results.bads), Assets.menuSkin, \"song_style_result_values\");\n        goodResultLabel = new Label(Integer.toString(Results.goods), Assets.menuSkin, \"song_style_result_values\");\n        greatResultLabel = new Label(Integer.toString(Results.greats), Assets.menuSkin, \"song_style_result_values\");\n        perfectResultLabel = new Label(Integer.toString(Results.perfects), Assets.menuSkin, \"song_style_result_values\");\n        comboResultLabel = new Label(Integer.toString(Results.combo) + (Results.combo == Assets.selectedBeatmap.notes.size() ? \" (FC)\" : \"\"), Assets.menuSkin, \"song_style_result_values\");\n\n        difficulty.setFontScale(fontScale);\n        approachRateConfigLabel.setFontScale(fontScale);\n        overallDifficultyConfigLabel.setFontScale(fontScale);\n        accuracyResultLabel.setFontScale(fontScale);\n        accuracyRangeResultLabel.setFontScale(fontScale);\n        normalizedAccuracyResultLabel.setFontScale(fontScale);\n        unstableRatingValueLabel.setFontScale(fontScale);\n        missResultLabel.setFontScale(fontScale);\n        badResultLabel.setFontScale(fontScale);\n        goodResultLabel.setFontScale(fontScale);\n        greatResultLabel.setFontScale(fontScale);\n        perfectResultLabel.setFontScale(fontScale);\n        comboResultLabel.setFontScale(fontScale);\n\n        difficultyLabel.setFontScale(fontScale);\n        approachRateLabel.setFontScale(fontScale);\n        overallDifficultyLabel.setFontScale(fontScale);\n        accuracyLabel.setFontScale(fontScale);\n        accuracyRangeLabel.setFontScale(fontScale);\n        normalizedAccuracyLabel.setFontScale(fontScale);\n        unstableRatingLabel.setFontScale(fontScale);\n        missLabel.setFontScale(fontScale);\n        badLabel.setFontScale(fontScale);\n        perfectLabel.setFontScale(fontScale);\n        goodLabel.setFontScale(fontScale);\n        greatLabel.setFontScale(fontScale);\n        comboLabel.setFontScale(fontScale);\n\n        Label songResultTitle = new Label(Assets.selectedBeatmap.metadata.songName.replaceAll(\"\\\\\\\\n\", \" \"), Assets.menuSkin, \"results_song_title\");\n        songResultTitle.setFontScale(fontScale);\n\n        table.add(songResultTitle).colspan(3).row();\n        table.add(titleLabel).colspan(3).padBottom(stage.getHeight() * 0.04f).row();\n\n        table.add(difficulty).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(difficultyLabel).fillX().row();\n        table.add(comboLabel).fillX().padBottom(20);\n        table.add().width(stage.getWidth() * 0.2f).padBottom(20);\n        table.add(comboResultLabel).fillX().padBottom(20).row();\n\n        table.add(approachRateLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(approachRateConfigLabel).fillX().row();\n        table.add(overallDifficultyLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(overallDifficultyConfigLabel).fillX().row();\n        table.add(normalizedAccuracyLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(normalizedAccuracyResultLabel).fillX().row();\n        table.add(accuracyLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(accuracyResultLabel).fillX().row();\n        table.add(accuracyRangeLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(accuracyRangeResultLabel).fillX().row();\n        table.add(unstableRatingLabel).padBottom(20).fillX();\n        table.add().width(stage.getWidth() * 0.2f).padBottom(20);\n        table.add(unstableRatingValueLabel).padBottom(20).fillX().row();\n\n        table.add(perfectLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(perfectResultLabel).fillX().row();\n        table.add(greatLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(greatResultLabel).fillX().row();\n        table.add(goodLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(goodResultLabel).fillX().row();\n        table.add(badLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(badResultLabel).fillX().row();\n        table.add(missLabel).fillX();\n        table.add().width(stage.getWidth() * 0.2f);\n        table.add(missResultLabel).fillX().row();\n\n        TextButton retryButton = new TextButton(\"Retry\", Assets.menuSkin, \"item1\");\n        TextButton continueButton = new TextButton(\"Continue\", Assets.menuSkin, \"item1\");\n\n        retryButton.getLabel().setFontScale(fontScale);\n        continueButton.getLabel().setFontScale(fontScale);\n\n        retryButton.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                ((Game) Gdx.app.getApplicationListener()).setScreen(new SongScreen());\n            }\n        });\n        continueButton.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                ((Game) Gdx.app.getApplicationListener()).setScreen(new SongSelectionScreen());\n            }\n        });\n\n        table.add(retryButton).width(stage.getWidth() * 0.3f).height(stage.getHeight() * 0.1f);\n        table.add().fillX();\n        table.add(continueButton).width(stage.getWidth() * 0.3f).height(stage.getHeight() * 0.1f).row();\n        stage.addActor(table);\n\n        Gdx.input.setInputProcessor(stage);\n    }\n\n    @Override\n    public void render(float delta) {\n        Gdx.gl.glClearColor(0, 0, 0, 1);\n        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);\n        stage.act();\n        stage.draw();\n    }\n\n    @Override\n    public void resize(int width, int height) {\n\n    }\n\n    @Override\n    public void pause() {\n\n    }\n\n    @Override\n    public void resume() {\n\n    }\n\n    @Override\n    public void hide() {\n        dispose();\n    }\n\n    @Override\n    public void dispose() {\n        stage.dispose();\n    }\n}\ncore/src/com/fteams/sstrain/util/Accuracy.java\npublic enum Accuracy {\n    PERFECT,\n    GREAT,\n    NICE,\n    BAD,\n    MISS,\n    NONE\n}\ncore/src/com/fteams/sstrain/objects/AccuracyMarker.java\npublic class AccuracyMarker {\n    // stay on screen for 5 seconds\n    public float displayTime = 5f;\n    private float time;\n    public boolean display;\n\n    public AccuracyMarker(float time) {\n        this.time = time;\n        display = true;\n    }\n\n    public void update(float delta) {\n        if (!display)\n            return;\n        displayTime -= delta;\n        if (displayTime <= 0) {\n            display = false;\n        }\n    }\n\n    public float getAlpha() {\n        float alpha = displayTime / 5f;\n        return (alpha >= 1f ? 1f : (alpha <= 0f ? 0f : alpha));\n    }\n\n    public float getTime() {\n        return time;\n    }\n}\ncore/src/com/fteams/sstrain/objects/AccuracyPopup.java\npublic class AccuracyPopup {\n\n    private float screenTime;\n    public boolean show;\n    public Accuracy accuracy;\n    public boolean soon;\n    public boolean fadeIn;\n    public float fadeTime = 0.25f;\n\n    public AccuracyPopup(Accuracy accuracy, boolean soon) {\n        this.screenTime = 0.5f;\n        this.accuracy = accuracy;\n        this.soon = soon;\n        fadeIn = true;\n        fadeTime = 0.25f;\n        show = true;\n    }\n\n    public void update(float delta) {\n        screenTime -= delta;\n        fadeTime -= delta;\n        if (screenTime <= 0 && show) {\n            show = false;\n        }\n        if (fadeTime <= 0 && fadeIn) {\n            fadeIn = false;\n        }\n    }\n\n    public float getSize() {\n        return 1f + (0.5f - screenTime);\n    }\n\n    public float getAlpha() {\n        float alpha = fadeIn ? 0.75f + screenTime : screenTime / 0.25f;\n        return (alpha >= 1f ? 1f : (alpha <= 0f ? 0f : alpha));\n    }\n}\ncore/src/com/fteams/sstrain/entities/Results.java\npublic class Results {\n    public static Integer combo;\n    public static float accuracy;\n    public static int miss;\n    public static int bads;\n    public static int goods;\n    public static int greats;\n    public static int perfects;\n    public static float maxAccuracy;\n    public static float minAccuracy;\n    public static float normalizedAccuracy;\n    public static float unstableRating;\n\n    public static void clear() {\n        combo = 0;\n        accuracy = 0;\n        miss = 0;\n        bads = 0;\n        goods = 0;\n        greats = 0;\n        perfects = 0;\n        maxAccuracy = 0;\n        minAccuracy = 0;\n        normalizedAccuracy = 0;\n        unstableRating = 0;\n    }\n\n\n    public static float getAccuracyMultiplierForAccuracy(Accuracy accuracy) {\n        if (accuracy == Accuracy.PERFECT) {\n            return 1.0f;\n        }\n        if (accuracy == Accuracy.GREAT) {\n            return 0.75f;\n        }\n        if (accuracy == Accuracy.NICE) {\n            return 0.50f;\n        }\n        if (accuracy == Accuracy.BAD) {\n            return 0.25f;\n        }\n        return 0f;\n    }\n\n    public static Accuracy getAccuracyFor(float timing) {\n        // Perfect\n        if (Math.abs(timing) < SongUtils.overallDiffPerfect[GlobalConfiguration.overallDifficulty] / 1000) {\n            return Accuracy.PERFECT;\n        }\n        if (Math.abs(timing) < SongUtils.overallDiffGreat[GlobalConfiguration.overallDifficulty]/ 1000) {\n            return Accuracy.GREAT;\n        }\n        if (Math.abs(timing) < SongUtils.overallDiffNice[GlobalConfiguration.overallDifficulty]/ 1000) {\n            return Accuracy.NICE;\n        }\n        if (Math.abs(timing) < SongUtils.overallDiffBad[GlobalConfiguration.overallDifficulty]/ 1000) {\n            return Accuracy.BAD;\n        }\n        return Accuracy.MISS;\n    }\n\n    // holds and swipes have bigger windows\n    public static Accuracy getAccuracyForSwipesAndHolds(float timing) {\n        return getAccuracyFor(timing * SWIPE_HOLD_MULTIPLIER);\n    }\n\n    public final static float SWIPE_HOLD_MULTIPLIER = 0.5f;\n}\ncore/src/com/fteams/sstrain/World.java\npublic class World {\n    int width;\n    int height;\n\n    public int combo;\n    public boolean started;\n    public boolean paused;\n    public int offsetX;\n    public int offsetY;\n\n    private Array<AccuracyMarker> accuracyMarkers;\n    private Array<AccuracyPopup> accuracyPopups;\n\n    Array<TapZone> tapZones = new Array<>();\n    Array<Circle> circles = new Array<>();\n\n    public float delay;\n\n    public World() {\n        createWorld();\n    }\n\n    private void createWorld() {\n        float x = 0f;\n        float y = 0f;\n\n        float h = 400;\n        float w = 600;\n\n        float radius = h * 0.065f;\n\n        Double noteSpeed = SongUtils.getSpeedFromConfig(GlobalConfiguration.noteSpeed) / 1000.0;\n\n        delay = Assets.selectedBeatmap.metadata.leadIn != null ? Assets.selectedBeatmap.metadata.leadIn : 0f;\n\n        if (delay < noteSpeed) {\n            delay += noteSpeed;\n        }\n\n        for (Note notesInfo : Assets.selectedBeatmap.notes) {\n\n            // we create a copy which is modified based on the live options - speed / a-b repeat\n            Note copy = copy(notesInfo);\n            if (GlobalConfiguration.playbackMode != null && GlobalConfiguration.playbackMode.equals(SongUtils.GAME_MODE_ABREPEAT)) {\n                if (GlobalConfiguration.aTime != null) {\n                    if (copy.timing < GlobalConfiguration.aTime) {\n                        continue;\n                    }\n                }\n                if (GlobalConfiguration.bTime != null) {\n                    if (copy.timing > GlobalConfiguration.bTime + 2f) {\n                        continue;\n                    }\n                }\n            }\n            if (GlobalConfiguration.playbackRate != null) {\n                copy.timing = copy.timing / GlobalConfiguration.playbackRate;\n\n            }\n\n            x = (copy.endPos - 3) * radius * 4;\n            Circle mark = new Circle(x, 0, copy, noteSpeed, delay);\n            circles.add(mark);\n        }\n//        System.out.println(\"Loaded: \" + circles.size + \" notes\");\n\n        linkCircles(circles);\n        linkSyncCircles(circles);\n\n        circles.sort();\n\n        int zoneId = 1;\n        tapZones = new Array<>();\n\n        for (int i = 0; i < 11; i++) {\n            if (i % 2 == 0)\n                continue;\n\n            x = (i * 2 - 10) * radius;\n\n            TapZone zone = new TapZone(x, -249.0f, zoneId++);\n            tapZones.add(zone);\n        }\n        tapZones.sort();\n        this.accuracyMarkers = new Array<>();\n        this.accuracyPopups = new Array<>();\n        paused = false;\n    }\n\n    private Note copy(Note notesInfo) {\n        Note copy = new Note();\n        copy.status = notesInfo.status;\n        copy.timing = notesInfo.timing;\n        copy.id = notesInfo.id;\n        copy.nextNoteId = notesInfo.nextNoteId;\n        copy.prevNoteId = notesInfo.prevNoteId;\n        copy.endPos = notesInfo.endPos;\n        copy.startPos = notesInfo.startPos;\n        copy.groupId = notesInfo.groupId;\n        copy.sync = notesInfo.sync;\n        copy.type = notesInfo.type;\n        return copy;\n    }\n\n    private void linkCircles(Array<Circle> circles) {\n        for (int i = 0; i < circles.size; i++) {\n            Circle current = circles.get(i);\n            if (current.note.nextNoteId == 0)\n                continue;\n\n            Circle next = findNext(circles, current.note.nextNoteId);\n\n            // next can be null in A-B repeat mode since not all the circles are loaded.\n            if (next != null) {\n                current.setNextNote(next);\n                current.nextNote.setPreviousNote(current);\n            }\n            // 2 side relation\n        }\n    }\n\n    private Circle findNext(Array<Circle> circles, Long nextNoteId) {\n        for (Circle circle : circles) {\n            if (circle.note.id.equals(nextNoteId))\n                return circle;\n        }\n        return null;\n    }\n\n    private void linkSyncCircles(Array<Circle> circles) {\n        for (int i = 0; i < circles.size; i++) {\n            Circle mark = circles.get(i);\n            if (mark.note.sync != 0) {\n                Circle next = findNextSync(circles, mark.note.timing, mark.note.id);\n                if (next != null) {\n                    mark.nextSyncNote = next;\n                }\n            }\n        }\n\n    }\n\n    private Circle findNextSync(Array<Circle> circles, Double timing, Long id) {\n        for (int i = 0; i < circles.size; i++) {\n            Circle circle = circles.get(i);\n            if (circle.note.timing.equals(timing) && circle.note.id > id) {\n                return circle;\n            }\n        }\n        return null;\n    }\n\n    public Array<TapZone> getTapZones() {\n        return tapZones;\n    }\n\n    public Array<Circle> getCircles() {\n        return circles;\n    }\n\n    public Array<AccuracyMarker> getAccuracyMarkers() {\n        return accuracyMarkers;\n    }\n\n    public Array<AccuracyPopup> getAccuracyPopups() {\n        return accuracyPopups;\n    }\n\n    public void setSize(int width, int height, int offsetX, int offsetY) {\n        this.width = width;\n        this.height = height;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n    }\n}\ncore/src/com/fteams/sstrain/config/GlobalConfiguration.java\npublic class GlobalConfiguration {\n\n    // package info\n    public static String appVersionName;\n\n    public static int songVolume;\n    public static int feedbackVolume;\n    // offset in milliseconds\n    public static int offset;\n    public static int inputOffset;\n    public static int noteSpeed;\n    public static int overallDifficulty;\n    // path to beatmaps\n    public static String pathToBeatmaps;\n    public static boolean playHintSounds;\n    public static int sortOrder;\n    // sorting related\n    public static int sortMode;\n\n    // display the line in the live screen\n    public static boolean displayLine;\n\n    // sync config\n    public static int syncMode;\n\n    public final static int BASE_HEIGHT = 720;\n\n    // not stored/remembered variables:\n    public static Float playbackRate;\n    public static Integer playbackMode;\n    public static Float aTime;\n    public static Float bTime;\n\n\n    public static void loadConfiguration() {\n        Preferences prefs = Gdx.app.getPreferences(\"ss_train_config\");\n        offset = prefs.getInteger(\"offset\", 0);\n        inputOffset = prefs.getInteger(\"input_offset\", 0);\n        songVolume = prefs.getInteger(\"song_vol\", 100);\n        feedbackVolume = prefs.getInteger(\"feedback_vol\", 100);\n        pathToBeatmaps = prefs.getString(\"path_to_beatmaps\", Gdx.files.getExternalStoragePath() + \"sstrain\");\n        playHintSounds = prefs.getBoolean(\"play_hint_sounds\", false);\n        noteSpeed = prefs.getInteger(\"note_speed\", 6);\n        overallDifficulty = prefs.getInteger(\"overall_difficulty\", 7);\n        displayLine = prefs.getBoolean(\"display_line\", true);\n        // default to song name sorting\n        sortMode = prefs.getInteger(\"sorting_mode\", SongUtils.SORTING_MODE_SONG_NAME);\n        // default ascending order\n        sortOrder = prefs.getInteger(\"sorting_order\", SongUtils.SORTING_MODE_ASCENDING);\n        // sync mode\n        syncMode = prefs.getInteger(\"sync_mode\", SongUtils.SYNC_MODE_1);\n\n    }\n\n    public static void storeConfiguration() {\n        Preferences prefs = Gdx.app.getPreferences(\"ss_train_config\");\n        prefs.putInteger(\"offset\", offset);\n        prefs.putInteger(\"input_offset\", inputOffset);\n        prefs.putInteger(\"song_vol\", songVolume);\n        prefs.putInteger(\"feedback_vol\", feedbackVolume);\n        prefs.putString(\"path_to_beatmaps\", pathToBeatmaps);\n        prefs.putBoolean(\"play_hint_sounds\", playHintSounds);\n        prefs.putInteger(\"note_speed\", noteSpeed);\n        prefs.putInteger(\"overall_difficulty\", overallDifficulty);\n        prefs.putBoolean(\"display_line\", displayLine);\n        prefs.putInteger(\"sorting_mode\", sortMode);\n        prefs.putInteger(\"sorting_order\", sortOrder);\n        prefs.putInteger(\"sync_mode\", syncMode);\n        prefs.flush();\n    }\n}\ncore/src/com/fteams/sstrain/assets/Assets.java\npublic class Assets {\n\n    public static AssetManager internalManager = new AssetManager(new InternalFileHandleResolver());\n    public static AssetManager externalManager = new AssetManager(new ExternalFileHandleResolver());\n\n    static {\n        externalManager.setLoader(List.class, new SimplifiedBeatmapLoader(new ExternalFileHandleResolver()));\n    }\n\n    public static final String BEATMAP_HOME = \"sstrain/beatmaps/\";\n    public static final String SOUNDFILES_HOME = \"sstrain/soundfiles/\";\n\n    public static Beatmap selectedBeatmap;\n    public static BeatmapGroup selectedGroup;\n\n    public static TextureAtlas atlas;\n\n    public static Skin menuSkin;\n    public static Sound noHitTapSound;\n    public static Sound niceTapSound;\n    public static Sound greatTapSound;\n    public static Sound perfectTapSound;\n    public static Sound niceSwipeSound;\n    public static Sound greatSwipeSound;\n    public static Sound perfectSwipeSound;\n\n    public static BitmapFont font;\n    public static BitmapFont songFont;\n\n    public static Texture mainMenuBackgroundTexture;\n    public static Texture holdBG;\n\n    public static Array<BeatmapGroup> songGroup;\n\n    // In here we'll put everything that needs to be loaded in this format:\n    // manager.load(\"file location in assets\", fileType.class);\n    //\n    // libGDX AssetManager currently supports: Pixmap, Texture, BitmapFont,\n    //     TextureAtlas, TiledAtlas, TiledMapRenderer, Music and Sound.\n    public static void queueLoading() {\n        internalManager.load(\"textures/textures.pack.atlas\", TextureAtlas.class);\n        internalManager.load(\"hitsounds/no_hit_tap.mp3\", Sound.class);\n        internalManager.load(\"hitsounds/tap_nice.mp3\", Sound.class);\n        internalManager.load(\"hitsounds/tap_great.mp3\", Sound.class);\n        internalManager.load(\"hitsounds/tap_perfect.mp3\", Sound.class);\n        internalManager.load(\"hitsounds/swipe_nice.mp3\", Sound.class);\n        internalManager.load(\"hitsounds/swipe_great.mp3\", Sound.class);\n        internalManager.load(\"hitsounds/swipe_perfect.mp3\", Sound.class);\n        internalManager.load(\"bigimages/main_menu_background.jpg\", Texture.class);\n        internalManager.load(\"images/hold_background.png\", Texture.class);\n        internalManager.load(\"fonts/combo-font.fnt\", BitmapFont.class);\n        internalManager.load(\"fonts/song-font.fnt\", BitmapFont.class);\n        reloadBeatmaps();\n    }\n\n    // thanks to libgdx, the manager will not actually load maps which were already loaded,\n    // so if the same file comes again, it will be skipped\n    public static void reloadBeatmaps() {\n        if (Gdx.files.absolute(Gdx.files.getExternalStoragePath() + BEATMAP_HOME).exists()) {\n            for (String fileName : Gdx.files.absolute(Gdx.files.getExternalStoragePath() + BEATMAP_HOME).file().list()) {\n                String fullPath = Gdx.files.getExternalStoragePath() + BEATMAP_HOME + fileName;\n                // if for any reason the user placed .osu/.osz files in the datafiles, we process them\n                if (Gdx.files.absolute(fullPath).isDirectory() || (!fileName.endsWith(\".json\")))\n                    continue;\n\n                externalManager.load(BEATMAP_HOME + fileName, List.class);\n            }\n        } else {\n            (Gdx.files.absolute(Gdx.files.getExternalStoragePath() + \"beatmaps\")).mkdirs();\n            (Gdx.files.absolute(Gdx.files.getExternalStoragePath() + BEATMAP_HOME)).mkdirs();\n            (Gdx.files.absolute(Gdx.files.getExternalStoragePath() + SOUNDFILES_HOME)).mkdirs();\n        }\n    }\n\n    // unlike the simple reload, in the hard reload we unload everything from the external manager\n    // and force a reload of the beatmaps - this will cause .osz files which weren't extracted\n    // to be processed, .osu files to be converted and music files within the .osz packages\n    // to be copied over to the /beatmaps/soundfiles/ folder.\n    public static void hardReloadBeatmaps() {\n        selectedBeatmap = null;\n        selectedGroup = null;\n        externalManager.clear();\n        reloadBeatmaps();\n    }\n\n    //In here we'll create our skin, so we only have to create it once.\n    public static void setMenuSkin() {\n        if (menuSkin == null)\n            menuSkin = new Skin(Gdx.files.internal(\"skins/menuSkin.json\"), internalManager.get(\"textures/textures.pack.atlas\", TextureAtlas.class));\n    }\n\n    public static void setTextures() {\n        if (atlas == null)\n            atlas = internalManager.get(\"textures/textures.pack.atlas\");\n\n        if (mainMenuBackgroundTexture == null)\n            mainMenuBackgroundTexture = internalManager.get(\"bigimages/main_menu_background.jpg\");\n\n        if (holdBG == null)\n            holdBG = internalManager.get(\"images/hold_background.png\");\n    }\n\n    public static void setFonts() {\n        if (font == null) {\n            font = internalManager.get(\"fonts/combo-font.fnt\");\n        }\n        if (songFont == null) {\n            songFont= internalManager.get(\"fonts/song-font.fnt\");\n        }\n\n    }\n\n    public static void setHitsounds() {\n        if (noHitTapSound == null)\n            noHitTapSound = internalManager.get(\"hitsounds/no_hit_tap.mp3\");\n        if (niceTapSound == null)\n            niceTapSound = internalManager.get(\"hitsounds/tap_nice.mp3\");\n        if (greatTapSound == null)\n            greatTapSound = internalManager.get(\"hitsounds/tap_great.mp3\");\n        if (perfectTapSound == null)\n            perfectTapSound = internalManager.get(\"hitsounds/tap_perfect.mp3\");\n        if (niceSwipeSound == null)\n            niceSwipeSound = internalManager.get(\"hitsounds/swipe_nice.mp3\");\n        if (greatSwipeSound == null)\n            greatSwipeSound = internalManager.get(\"hitsounds/swipe_great.mp3\");\n        if (perfectSwipeSound == null)\n            perfectSwipeSound = internalManager.get(\"hitsounds/swipe_perfect.mp3\");\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static void setSongs() {\n        if (songGroup == null) {\n            songGroup = new Array<>();\n        } else {\n            songGroup.clear();\n        }\n\n        Array<String> assets = externalManager.getAssetNames();\n        Map<Long, BeatmapGroup> groupMap = new HashMap<>();\n\n        for (String string : assets) {\n            List<Beatmap> beatmaps = externalManager.get(string, List.class);\n            if (!beatmaps.isEmpty()) {\n                Metadata metadata = beatmaps.get(0).metadata;\n                Long liveId = metadata.id;\n                if (groupMap.get(liveId) == null) {\n                    BeatmapGroup group = new BeatmapGroup();\n                    group.metadata = new BaseMetadata();\n                    group.metadata.id = metadata.id;\n                    group.metadata.composer = metadata.composer;\n                    group.metadata.lyricist = metadata.lyricist;\n                    group.metadata.songFile = metadata.songFile;\n                    group.metadata.songName = metadata.songName;\n                    group.metadata.attribute = metadata.attribute;\n                    group.metadata.duration = metadata.duration;\n                    group.beatmaps = new Array<>();\n                    groupMap.put(liveId, group);\n                }\n\n                BeatmapGroup group = groupMap.get(liveId);\n                for (Beatmap beatmap : beatmaps) {\n                    group.beatmaps.add(beatmap);\n                }\n                group.beatmaps.sort();\n            }\n        }\n        for (Long liveId : groupMap.keySet()) {\n            songGroup.add(groupMap.get(liveId));\n        }\n        songGroup.sort();\n    }\n\n    public static boolean update() {\n        return internalManager.update() && externalManager.update();\n    }\n\n    public static float getProgress() {\n        return (internalManager.getProgress() + externalManager.getProgress()) / 2;\n    }\n}\ncore/src/com/fteams/sstrain/objects/TapZone.java\npublic class TapZone implements Comparable<TapZone>{\n\n    Integer id;\n\n    public boolean pressed;\n    public boolean warn;\n\n    Vector2 position = new Vector2();\n    public float touchTime = -1f;\n\n    public TapZone(float x, float y, int i) {\n        this.id = i;\n        this.position.x = x;\n        this.position.y = y;\n        pressed = false;\n        warn = false;\n    }\n\n    public void update(float delta) {\n\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public Vector2 getPosition() {\n        return position;\n    }\n\n    @Override\n    public int compareTo(TapZone o) {\n        return SongUtils.compare(id, o.id);\n    }\n}\ncore/src/com/fteams/sstrain/objects/Circle.java\npublic class Circle implements Comparable<Circle> {\n\n    public Note note;\n\n    public Vector2 origin = new Vector2();\n    public Vector2 position = new Vector2();\n    Vector2 velocity = new Vector2();\n\n    public boolean hold;\n    public Long destination;\n    Double speed;\n    public Circle nextNote;\n    public Circle previousNote;\n    public Circle nextSyncNote;\n\n    float spawnTime;\n    float despawnTime;\n    float startWaitTime;\n    float endWaitTime;\n\n    float size;\n\n    public float hitTime;\n    float previousTime;\n    long previousSystemTime;\n\n    public boolean visible;\n    public boolean holding;\n    public boolean waiting;\n    public boolean soundPlayed;\n    public boolean miss;\n\n    public float alpha = 1f;\n\n    public Accuracy accuracy;\n    public boolean processed;\n\n    // holds consist of 2 notes out of which the first one must have type 2\n    // the second one will either be a type 2 or a type 1 with some effect\n    // notes with type 1 can be linked to other notes IF the effect != 0 and the groupID is set.\n\n    public Circle(float x, float y, Note note, Double noteSpeed, float delay) {\n\n        float timing = (float) (delay + note.timing * 1f + GlobalConfiguration.offset * 1f / 1000f);\n\n        this.origin.x = x;\n        this.origin.y = y;\n        this.position.x = x;\n        this.position.y = y;\n        this.note = note;\n        this.hold = (note.type & SongUtils.NOTE_TYPE_HOLD) != 0;\n        // position goes 1-5\n        this.destination = note.endPos;\n        this.speed = noteSpeed;\n        this.spawnTime = (float) (timing - speed);\n        this.startWaitTime = (float) (timing - (hold || !note.status.equals(SongUtils.NOTE_NO_SWIPE) ? 2f : 1f) * SongUtils.overallDiffBad[GlobalConfiguration.overallDifficulty] / 1000f);\n        this.endWaitTime = (float) (timing + (hold || !note.status.equals(SongUtils.NOTE_NO_SWIPE) ? 2f : 1f) * SongUtils.overallDiffBad[GlobalConfiguration.overallDifficulty] / 1000f);\n        this.despawnTime = timing * 1.0f;\n        this.size = 1f;\n        this.previousSystemTime = 0L;\n\n        hitTime = -9f;\n        previousTime = 0f;\n\n        initializeVelocity();\n        initializeStates();\n    }\n\n    private void initializeStates() {\n        visible = false;\n        holding = false;\n        soundPlayed = false;\n        miss = false;\n    }\n\n    public void setPreviousNote(Circle previousNote) {\n        this.previousNote = previousNote;\n        if (previousNote != null) {\n            if (previousNote.hold && previousNote.previousNote == null) {\n                this.startWaitTime = (float) (despawnTime - 2f * SongUtils.overallDiffBad[GlobalConfiguration.overallDifficulty] / 1000f);\n                this.endWaitTime = (float) (despawnTime + 2f * SongUtils.overallDiffBad[GlobalConfiguration.overallDifficulty] / 1000f);\n\n            }\n        }\n\n    }\n\n    public void setNextNote(Circle nextNote) {\n        this.nextNote = nextNote;\n    }\n\n    private void initializeVelocity() {\n        // unless the arc movement is implemented,\n        // the notes will simply fall from the top towards the tap zones\n        velocity.x = 0;\n        velocity.y = (float) (-249 / speed);\n    }\n\n    public void update(float time) {\n\n        if (miss || (accuracy != null && !holding)) {\n            if (visible) {\n                visible = false;\n            }\n            return;\n        }\n\n        if (spawnTime <= time && despawnTime > time && !visible) {\n            visible = true;\n        }\n\n        if (spawnTime >= time && visible)\n            visible = false;\n\n        if (visible && despawnTime <= time) {\n            if (GlobalConfiguration.playHintSounds && !soundPlayed) {\n                // hint sounds play at 50% of the volume\n                if (note.status.equals(SongUtils.NOTE_NO_SWIPE)) {\n                    Assets.perfectTapSound.play(GlobalConfiguration.feedbackVolume / 200f);\n                } else {\n                    Assets.perfectSwipeSound.play(GlobalConfiguration.feedbackVolume / 200f);\n                }\n                soundPlayed = true;\n            }\n\n            if (holding) {\n                alpha = 1f;\n            } else {\n                alpha = MathUtils.clamp((endWaitTime - time) / (endWaitTime - despawnTime), 0f, 1f);\n                if (alpha == 0f)\n                    visible = false;\n            }\n        }\n\n        if (visible) {\n            // TODO: implement parabolic movement of the notes towards the player and use the origin spot instead of spawning from the same lane (more SS-like)\n            float scl = time - spawnTime;\n            if (holding) {\n                position.set(origin.cpy().x, origin.cpy().y - 249);\n            } else\n                position.set(origin.cpy().add(velocity.cpy().scl(scl)));\n        }\n        if (startWaitTime <= time && endWaitTime > time && !waiting && accuracy == null) {\n            waiting = true;\n        }\n\n        processMiss(time);\n        previousTime = time;\n        previousSystemTime = System.currentTimeMillis();\n    }\n\n\n    private void processMiss(float time) {\n        // miss if we miss the first note\n        if (nextNote != null && hold && !holding && endWaitTime <= time && accuracy == null && !miss) {\n            waiting = false;\n            miss = true;\n            accuracy = Accuracy.MISS;\n            nextNote.miss = true;\n            nextNote.accuracy = Accuracy.MISS;\n            nextNote.processed = true;\n            nextNote.waiting = false;\n//            System.out.println(\"MISS-001: didn't hit the note (\" + note.id + \")\");\n        } else if (nextNote == null && endWaitTime <= time && !miss && accuracy == null) {\n            waiting = false;\n            miss = true;\n            accuracy = Accuracy.MISS;\n//            System.out.println(\"MISS-002: didn't hit the note (\" + note.id + \")\");\n        } else if (nextNote != null && !hold && endWaitTime <= time && accuracy == null && !miss) {\n            waiting = false;\n            miss = true;\n            accuracy = Accuracy.MISS;\n//            System.out.println(\"MISS-003: didn't hit the note (\" + note.id + \")\");\n        }\n        if (hold && !miss) {\n            // miss if we hold for too long\n            if (nextNote != null && nextNote.endWaitTime <= time && nextNote.accuracy == null) {\n                miss = true;\n                holding = false;\n                waiting = false;\n//                System.out.println(\"MISS-004: held for too long (\" + note.id + \")\");\n                accuracy = Accuracy.MISS;\n            }\n        }\n    }\n\n    public Accuracy hit() {\n//        System.out.println(\"H>\" + note.id);\n\n        // HIT DOESN'T COUNT FOR HOLD RELEASE!\n        if (previousNote != null && previousNote.hold)\n            return Accuracy.NONE;\n\n        float delta = (System.currentTimeMillis() - previousSystemTime) / 1000f;\n        float hit = previousTime + delta - despawnTime - GlobalConfiguration.inputOffset / 1000f;\n\n        Accuracy accuracy = hold ? Results.getAccuracyForSwipesAndHolds(hit) : Results.getAccuracyFor(hit);\n        // If the note was tapped too early, we ignore the tap\n        if (despawnTime > previousTime && accuracy == Accuracy.MISS) {\n            return Accuracy.NONE;\n        }\n        hitTime = hit;\n        waiting = false;\n        if (hold) {\n            hitTime *= Results.SWIPE_HOLD_MULTIPLIER;\n            holding = true;\n        } else {\n            visible = false;\n        }\n        this.accuracy = accuracy;\n        return accuracy;\n    }\n\n    public Accuracy release() {\n//        System.out.println(\"R>\" + note.id);\n        // if a non-hold is released it it counts as a miss.\n        // some songs have notes with type 1 and status != 0 for release so we check if the previous note was a hold\n        if (previousNote != null && previousNote.hold && !note.status.equals(SongUtils.NOTE_NO_SWIPE)) {\n            accuracy = Accuracy.MISS;\n            miss = true;\n            visible = false;\n            previousNote.release();\n            waiting = false;\n            // only type 2 can gain from a release.\n            // type 1 with status calls release on swipe\n            return accuracy;\n        }\n        // RELEASE DOESN'T COUNT FOR HOLD START\n        if (holding) {\n            holding = false;\n            visible = false;\n        }\n        if (nextNote != null)\n            return Accuracy.NONE;\n\n        float delta = (System.currentTimeMillis() - previousSystemTime) / 1000f;\n        float hit = previousTime + delta - despawnTime - GlobalConfiguration.inputOffset / 1000f;\n        accuracy = Results.getAccuracyForSwipesAndHolds(hit);\n        previousNote.release();\n        waiting = false;\n        // miss if we release before we start waiting\n        if (accuracy == Accuracy.MISS) {\n            waiting = false;\n            visible = false;\n            miss = true;\n            processed = true;\n//            System.out.println(\"MISS-005: released hold too early (\" + note.id + \")\");\n        } else {\n            hitTime = hit;\n            hitTime *= Results.SWIPE_HOLD_MULTIPLIER;\n        }\n        return accuracy;\n    }\n\n    public Accuracy swipeLeft() {\n        // some songs have notes with type 2 and status != 0\n        if (note.status.equals(SongUtils.NOTE_NO_SWIPE) || note.status.equals(SongUtils.NOTE_SWIPE_RIGHT)) {\n            return Accuracy.NONE;\n        }\n        if (previousNote != null && previousNote.hold) {\n            previousNote.release();\n        }\n\n        if (previousNote != null && previousNote.previousNote != null) {\n            if (previousNote.previousNote.note.status.equals(note.status) && !previousNote.isDone()) {\n                return Accuracy.NONE;\n            }\n        }\n        float delta = (System.currentTimeMillis() - previousSystemTime) / 1000f;\n        float hit = previousTime + delta - despawnTime - GlobalConfiguration.inputOffset / 1000f;\n        Accuracy accuracy = Results.getAccuracyForSwipesAndHolds(hit);\n        // If the note was tapped too early, we ignore the tap\n        if (despawnTime > previousTime && accuracy == Accuracy.MISS) {\n            return Accuracy.NONE;\n        }\n        hitTime = hit;\n        hitTime *= Results.SWIPE_HOLD_MULTIPLIER;\n        waiting = false;\n        this.accuracy = accuracy;\n        visible = false;\n        return accuracy;\n    }\n\n    public Accuracy swipeRight() {\n        // some songs have notes with type 2 and status != 0\n        // legne on pro, for instance.\n        if (note.status.equals(SongUtils.NOTE_NO_SWIPE) || note.status.equals(SongUtils.NOTE_SWIPE_LEFT)) {\n            return Accuracy.NONE;\n        }\n        if (previousNote != null && previousNote.hold) {\n            previousNote.release();\n        }\n\n        if (previousNote != null && previousNote.previousNote != null) {\n            if (previousNote.previousNote.note.status.equals(note.status) && !previousNote.isDone()) {\n                return Accuracy.NONE;\n            }\n        }\n\n        float delta = (System.currentTimeMillis() - previousSystemTime) / 1000f;\n        float hit = previousTime + delta - despawnTime - GlobalConfiguration.inputOffset / 1000f;\n        Accuracy accuracy = Results.getAccuracyForSwipesAndHolds(hit);\n        // If the note was tapped too early, we ignore the tap\n        if (despawnTime > previousTime && accuracy == Accuracy.MISS) {\n            return Accuracy.NONE;\n        }\n        hitTime = hit;\n        hitTime *= Results.SWIPE_HOLD_MULTIPLIER;\n        waiting = false;\n        this.accuracy = accuracy;\n        visible = false;\n        return accuracy;\n    }\n\n    public boolean isDone() {\n        return miss || (accuracy != null && !holding);\n    }\n\n    @Override\n    public int compareTo(Circle o) {\n        if (o == null)\n            return 1;\n        // if the notes have the same timing, sort them by destination\n        if (note.timing.equals(o.note.timing)) {\n            return SongUtils.compare(note.endPos, o.note.endPos);\n        }\n\n        return Double.compare(note.timing, o.note.timing);\n    }\n}\n", "answers": ["            Assets.perfectTapSound.play(GlobalConfiguration.feedbackVolume / 100f);"], "length": 4505, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "443c1278e5d9623fee6148ef1c0cc93d266d7561f4c35d8e"}
{"input": "import java.io.File;\r\nimport java.io.IOException;\r\nimport static java.lang.System.exit;\r\nimport com.beust.jcommander.Parameter;\r\nimport com.beust.jcommander.Parameters;\r\nimport com.zklogtool.data.DataDirTransactionLogFileList;\r\nimport com.zklogtool.data.Transaction;\r\nimport com.zklogtool.data.TransactionIterator;\r\nimport com.zklogtool.data.TransactionLog;\r\nimport com.zklogtool.data.TransactionLogFileList;\r\nimport com.zklogtool.data.TransactionState;\r\nimport com.zklogtool.monitor.TransactionListener;\r\nimport com.zklogtool.monitor.TransactionMonitor;\r\nimport com.zklogtool.printer.DataDecoder;\r\nimport com.zklogtool.printer.TransactionPrinter;\r\nimport com.zklogtool.printer.UnicodeDecoder;\r\nimport com.zklogtool.reader.TransactionLogReaderFactory;\r\nimport com.zklogtool.util.PropertiesReader;\r\n/* \r\n * Copyright 2014 Alen Caljkusic.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npackage com.zklogtool.cli;\r\n\r\n\r\n/**\r\n * Represents <b>log</b> command and holds logic for <b>log</b> command\r\n * execution. It is also used by jCommander for command parameters.\r\n *\r\n */\r\n@Parameters(commandDescription = \"Display transaction log entries\")\r\npublic class CommandLog {\r\n\r\n    /**\r\n     * If true zklogtool will monitor transaction log directory and printout new\r\n     * transactions as they are written to disk. Tool will never exit on it's\r\n     * own.\r\n     *\r\n     */\r\n    @Parameter(names = Arguments.FOLLOW, description = \"Output appended data as the transactions are written to logs\")\r\n    public boolean follow = false;\r\n\r\n    /**\r\n     * When <code>Arguments.FOLLOW</code> option is used user may choose to\r\n     * printout only transactions that were written to disk after zklogtool\r\n     * started.\r\n     *\r\n     */\r\n    @Parameter(names = Arguments.START_WITH_LAST_TRANSACTION, description = \"Start printout from last written transaction. Can only be used with follow option\")\r\n    public boolean startWithLastTransaction = false;\r\n\r\n    /**\r\n     * Directory that holds Zookeeper transaction log files.\r\n     *\r\n     */\r\n    @Parameter(names = Arguments.DATA_LOG_DIR, description = \"Zookeeper log direcory path\")\r\n    public String dataLogDir;\r\n\r\n    /**\r\n     * Single Zookeeper transaction log file.\r\n     *\r\n     */\r\n    @Parameter(names = Arguments.LOG_FILE, description = \"Zookeeper transaction log file path\")\r\n    public String logFile;\r\n\r\n    /**\r\n     * Zookeeper configuration file. Zookeeper configuration file tells\r\n     * zookeeper where to store transaction log files and snapshot files.\r\n     * zklogtool can read locations from configuration file.\r\n     *\r\n     */\r\n    @Parameter(names = Arguments.PROPERTIES_FILE, description = \"Zookeeper configuration file path\")\r\n    public String propertiesFile;\r\n\r\n    /**\r\n     * Decoder that converts znodes byte array to <code>String</code> that can\r\n     * be printed to output. Znode holds data in form of a byte array. That byte\r\n     * array must be decoded in something that can be printed to output in order\r\n     * to display it.\r\n     *\r\n     */\r\n    @Parameter(names = Arguments.DATA_DECODER, description = \"Decoder used to display znode's data byte array\")\r\n    public String dataDecoder = \"UnicodeDecoder\";\r\n\r\n    /**\r\n     * Holds logic for <b>log</b> command execution.\r\n     *\r\n     * @throws InterruptedException Thrown if interrupted during execution.\r\n     */\r\n    public void execute() throws InterruptedException {\r\n\r\n        TransactionLog transactionLog = null;\r\n        TransactionLogReaderFactory factory = new TransactionLogReaderFactory();\r\n        final StringBuilder print = new StringBuilder();\r\n        DataDecoder decoder = null;\r\n\r\n        if (dataDecoder.contentEquals(\"UnicodeDecoder\")) {\r\n            decoder = new UnicodeDecoder();\r\n        } else {\r\n\r\n            System.err.println(\"Decoder not recognized\");\r\n            exit(1);\r\n        }\r\n\r\n        final TransactionPrinter printer = new TransactionPrinter(print, decoder);\r\n\r\n        if (dataLogDir != null) {\r\n\r\n            File transactionLogDir = new File(dataLogDir);\r\n\r\n            if (!checkDirectoryValid(transactionLogDir)) {\r\n                exit(1);\r\n            }\r\n\r\n            TransactionLogFileList l = new DataDirTransactionLogFileList(transactionLogDir);\r\n\r\n            transactionLog = new TransactionLog(l, factory);\r\n\r\n        } else if (logFile != null) {\r\n\r\n            File transactionLogFile = new File(logFile);\r\n\r\n            //check file\r\n            if (!checkFileValid(transactionLogFile)) {\r\n                exit(1);\r\n            }\r\n\r\n            transactionLog = new TransactionLog(transactionLogFile, factory);\r\n\r\n        } else if (propertiesFile != null) {\r\n\r\n            File properties = new File(propertiesFile);\r\n\r\n            if (!checkFileValid(properties)) {\r\n                exit(1);\r\n            }\r\n\r\n            PropertiesReader propertiesReader = null;\r\n\r\n            try {\r\n                propertiesReader = new PropertiesReader(properties);\r\n            } catch (IOException e) {\r\n                System.err.println(\"Problem with reading properties file: \" + properties.getAbsolutePath());\r\n                exit(1);\r\n            }\r\n\r\n            String transactionLogDirPath = propertiesReader.getTransactionLogDir();\r\n\r\n            if (transactionLogDirPath == null) {\r\n\r\n                System.err.println(\"Problem in properties file: \" + properties.getAbsolutePath());\r\n                exit(1);\r\n\r\n            }\r\n\r\n            File transactionLogDir = new File(transactionLogDirPath);\r\n\r\n            if (!checkDirectoryValid(transactionLogDir)) {\r\n                exit(1);\r\n            }\r\n\r\n            TransactionLogFileList l = new DataDirTransactionLogFileList(transactionLogDir);\r\n\r\n            transactionLog = new TransactionLog(l, factory);\r\n\r\n        }\r\n\r\n        if (follow) {\r\n\r\n            TransactionMonitor ts = new TransactionMonitor(transactionLog);\r\n\r\n            ts.addListener(new TransactionListener() {\r\n\r\n                @Override\r\n                public void onTransaction(Transaction t) {\r\n\r\n                    printer.print(t);\r\n                    System.out.println(print);\r\n                    print.setLength(0);\r\n\r\n                }\r\n\r\n                @Override\r\n                public void onPartialTransaction() {\r\n\r\n                    //do nothing\r\n                }\r\n\r\n                @Override\r\n                public void onCorruption() {\r\n\r\n                    //print error and exit\r\n                    System.err.println(\"Data corruption\");\r\n                    exit(1);\r\n\r\n                }\r\n\r\n            });\r\n\r\n            if (startWithLastTransaction) {\r\n\r\n                ts.startAtLastTransaction();\r\n\r\n            } else {\r\n\r\n                ts.startAtFirstTransaction();\r\n\r\n            }\r\n\r\n            //there must be a better way\r\n            synchronized (this) {\r\n                wait();\r\n            }\r\n\r\n            //not really needed\r\n            exit(0);\r\n\r\n        } else {\r\n\r\n            TransactionIterator transactionIterator = transactionLog.iterator();\r\n\r", "context": "zklogtool/src/main/java/com/zklogtool/util/PropertiesReader.java\npublic class PropertiesReader {\n\n    File propertiesFile;\n    Properties prop;\n\n    /**\n     *\n     * @param propertiesFile Zookeeper configuration file.\n     * @throws IOException Thrown if there is a problem with reading\n     * <code>propertiesFile</code>.\n     */\n    public PropertiesReader(File propertiesFile) throws IOException {\n\n        this.propertiesFile = propertiesFile;\n\n        prop = new Properties();\n        prop.load(new FileInputStream(propertiesFile));\n\n    }\n\n    /**\n     *\n     * @return Directory where transaction log files are stored.\n     */\n    public String getTransactionLogDir() {\n\n        if (prop.containsKey(\"dataLogDir\")) {\n            return prop.getProperty(\"dataLogDir\") + \"/version-2\";\n        } else if (prop.containsKey(\"dataDir\")) {\n            return prop.getProperty(\"dataDir\") + \"/version-2\";\n        } else {\n            return null;\n        }\n\n    }\n\n    /**\n     *\n     * @return Directory where snapshot files are stored.\n     */\n    public String getSnapshotDir() {\n\n        if (prop.containsKey(\"dataDir\")) {\n            return prop.getProperty(\"dataDir\") + \"/version-2\";\n        } else {\n            return null;\n        }\n\n    }\n\n    public File getPropertiesFile() {\n        return propertiesFile;\n    }\n\n}\nzklogtool/src/main/java/com/zklogtool/data/DataDirTransactionLogFileList.java\npublic class DataDirTransactionLogFileList implements TransactionLogFileList {\r\n\r\n    private File dataDir;\r\n    private DataDirHelper dataDirHelper;\r\n\r\n    /**\r\n     *\r\n     * @param dataDir Directory where transaction log files are stored.\r\n     */\r\n    public DataDirTransactionLogFileList(File dataDir) {\r\n        this.dataDir = dataDir;\r\n        dataDirHelper = new DataDirHelper(dataDir, null);\r\n    }\r\n\r\n    /**\r\n     * Returns chronologically first transaction log file from directory\r\n     * injected in constructor. That is file that has lowest zxid in filename.\r\n     *\r\n     * @return Chronologically first transaction log file from directory\r\n     * injected in constructor.\r\n     * @throws NoFileException Thrown if there are no transaction log files at\r\n     * all in directory injected in constructor.\r\n     */\r\n    @Override\r\n    public File getFirstTransactionLog() throws NoFileException {\r\n\r\n        List<File> transactionLogs = dataDirHelper.getSortedLogList();\r\n\r\n        if (!transactionLogs.isEmpty()) {\r\n            return transactionLogs.get(0);\r\n        } else {\r\n            throw new NoFileException(\"No transaction log found in \" + dataDir.getAbsolutePath());\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Returns transaction log file that chronologically succeeds\r\n     * <code>previousTransactionLog</code>. That is file with next lowest zxid\r\n     * number in name.\r\n     *\r\n     * @param previousTransactionLog Transaction log file that chronologically\r\n     * precedes transaction log that is to be returned.\r\n     * @return Transaction log file that chronologically succeeds\r\n     * <code>previousTransactionLog</code>.\r\n     * @throws NoFileException Thrown if there is no transaction log file with\r\n     * higher zxid number in directory injected in constructor.\r\n     */\r\n    @Override\r\n    public File getNextTransactionLog(File previousTransactionLog) throws NoFileException {\r\n\r\n        List<File> transactionLogs = dataDirHelper.getSortedLogList();\r\n\r\n        for (int i = 0; i < transactionLogs.size() - 1; i++) {\r\n\r\n            if (previousTransactionLog.getAbsolutePath().contentEquals(transactionLogs.get(i).getAbsolutePath())) {\r\n                return transactionLogs.get(i + 1);\r\n            }\r\n\r\n        }\r\n\r\n        throw new NoFileException(\"No transaction log found in \" + dataDir.getAbsolutePath() \r\n                + \"that succeeds\" + previousTransactionLog.toString());\r\n\r\n    }\r\n\r\n}\r\nzklogtool/src/main/java/com/zklogtool/data/TransactionLogFileList.java\npublic interface TransactionLogFileList {\r\n\r\n    /**\r\n     *\r\n     * @return First transaction log file to be processed.\r\n     * @throws NoFileException Thrown if file is not (yet) accessible.\r\n     */\r\n    File getFirstTransactionLog() throws NoFileException;\r\n\r\n    /**\r\n     *\r\n     * @param previousTransactionLog Transaction log file that precedes\r\n     * file that is to be returned. \r\n     * @return Transaction log file that succeeds\r\n     * <code>previousTransactionLog</code> transaction log file.\r\n     * @throws NoFileException Thrown if file is not (yet) accessible.\r\n     */\r\n    File getNextTransactionLog(File previousTransactionLog) throws NoFileException;\r\n\r\n}\r\nzklogtool/src/main/java/com/zklogtool/printer/TransactionPrinter.java\npublic class TransactionPrinter {\r\n\r\n    StringBuilder sb;\r\n    DataDecoder dd;\r\n\r\n    int indentation;\r\n\r\n    /**\r\n     *\r\n     * @param sb <code>StringBuilder</code> to which information is be appended\r\n     * @param dd Decoder used to convert transaction data byte array to\r\n     * <code>String</code>. Transaction types that hold data are create and\r\n     * setData.\r\n     */\r\n    public TransactionPrinter(StringBuilder sb, DataDecoder dd) {\r\n        this.sb = sb;\r\n        this.dd = dd;\r\n\r\n        indentation = 0;\r\n    }\r\n\r\n    public int getIndentation() {\r\n        return indentation;\r\n    }\r\n\r\n    /**\r\n     * Indentation if number of tab characters appended in front of actual data.\r\n     *\r\n     * @param indentation Positive integer that represents indentation.\r\n     */\r\n    public void setIndentation(int indentation) {\r\n        this.indentation = indentation;\r\n    }\r\n\r\n    private void println(String s) {\r\n        for (int i = 0; i < indentation; i++) {\r\n            sb.append(\"\\t\");\r\n        }\r\n        sb.append(s).append(lineSeparator());\r\n    }\r\n\r\n    private void printOperation(String operation) {\r\n        println(\"Operation:\\t\" + operation);\r\n    }\r\n\r\n    private void printPath(String path) {\r\n        println(\"Path:\\t\\t\" + path);\r\n    }\r\n\r\n    private void printEphermal(boolean ephermal) {\r\n        println(\"Ephermal:\\t\" + ephermal);\r\n    }\r\n\r\n    private void printParentCVersion(int parentCVersion) {\r\n        println(\"ParentCVersion:\\t\" + parentCVersion);\r\n    }\r\n\r\n    private void printVersion(int version) {\r\n        println(\"Version:\\t\" + version);\r\n    }\r\n\r\n    private void printTimeout(int timeOut) {\r\n        println(\"Timeout:\\t\" + timeOut);\r\n    }\r\n\r\n    private void printError(int error) {\r\n        println(\"Error:\\t\\t\" + error);\r\n    }\r\n\r\n    private void printHeader(TxnHeader txnHeader) {\r\n        println(\"Zxid:\\t\\t\" + Util.longToHexString(txnHeader.getZxid()));\r\n        println(\"Cxid:\\t\\t\" + Util.longToHexString(txnHeader.getCxid()));\r\n        println(\"Client id:\\t\" + Util.longToHexString(txnHeader.getClientId()));\r\n        println(\"Time:\\t\\t\" + new Date(txnHeader.getTime()));\r\n    }\r\n\r\n    private void printRecord(Record r, int type) {\r\n\r\n        switch (type) {\r\n\r\n            case OpCode.create:\r\n\r\n                //check if you should use CreateTxnV0 instead\r\n                CreateTxn createTxn = (CreateTxn) r;\r\n                printOperation(\"create\");\r\n                printPath(createTxn.getPath());\r\n                printEphermal(createTxn.getEphemeral());\r\n                printParentCVersion(createTxn.getParentCVersion());\r\n                printACL(createTxn.getAcl());\r\n                printData(createTxn.getData());\r\n                break;\r\n\r\n            case OpCode.delete:\r\n\r\n                DeleteTxn deleteTxn = (DeleteTxn) r;\r\n                printOperation(\"delete\");\r\n                printPath(deleteTxn.getPath());\r\n                break;\r\n\r\n            case OpCode.setData:\r\n\r\n                SetDataTxn setDataTxn = (SetDataTxn) r;\r\n                printOperation(\"setData\");\r\n                printPath(setDataTxn.getPath());\r\n                printData(setDataTxn.getData());\r\n                printVersion(setDataTxn.getVersion());\r\n                break;\r\n\r\n            case OpCode.setACL:\r\n                SetACLTxn setACLTxn = (SetACLTxn) r;\r\n                printOperation(\"setACL\");\r\n                printPath(setACLTxn.getPath());\r\n                printACL(setACLTxn.getAcl());\r\n                printVersion(setACLTxn.getVersion());\r\n                break;\r\n\r\n            case OpCode.check:\r\n                CheckVersionTxn checkVersionTxn = (CheckVersionTxn) r;\r\n                printOperation(\"check\");\r\n                printPath(checkVersionTxn.getPath());\r\n                printVersion(checkVersionTxn.getVersion());\r\n                break;\r\n\r\n            case OpCode.multi:\r\n                MultiTxn multiTxn = (MultiTxn) r;\r\n                printOperation(\"multi\");\r\n                indentation++;\r\n\r\n                for (Txn txn : multiTxn.getTxns()) {\r\n                    ByteBuffer bb = wrap(txn.getData());\r\n                    Record record = null;\r\n                    switch (txn.getType()) {\r\n                        case OpCode.create:\r\n                            record = new CreateTxn();\r\n                            break;\r\n                        case OpCode.delete:\r\n                            record = new DeleteTxn();\r\n                            break;\r\n                        case OpCode.setData:\r\n                            record = new SetDataTxn();\r\n                            break;\r\n                        case OpCode.error:\r\n                            record = new ErrorTxn();\r\n                            break;\r\n                        case OpCode.check:\r\n                            record = new CheckVersionTxn();\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n\r\n                    try {\r\n\r\n                        byteBuffer2Record(bb, record);\r\n                        printRecord(record, txn.getType());\r\n\r\n                    } catch (IOException ex) {\r\n                        //this should never happen\r\n                    }\r\n                }\r\n\r\n                indentation--;\r\n\r\n                break;\r\n\r\n            //create and close session use the same txn\r\n            case OpCode.createSession:\r\n                CreateSessionTxn createSessionTxn = (CreateSessionTxn) r;\r\n                printOperation(\"createSession\");\r\n                printTimeout(createSessionTxn.getTimeOut());\r\n                break;\r\n\r\n            case OpCode.closeSession:\r\n                CreateSessionTxn closeSessionTxn = (CreateSessionTxn) r;\r\n                printOperation(\"closeSession\");\r\n                break;\r\n\r\n            case OpCode.error:\r\n                ErrorTxn errorTxn = (ErrorTxn) r;\r\n                printOperation(\"error\");\r\n                printError(errorTxn.getErr());\r\n                break;\r\n\r\n            //there is also SetMaxChildrenTxn but not sure if needed\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param t <code>Transaction</code> to print information from.\r\n     */\r\n    public void print(Transaction t) {\r\n\r\n        TxnHeader h = t.getTxnHeader();\r\n        Record r = t.getTxnRecord();\r\n\r\n        printHeader(h);\r\n        printRecord(r, h.getType());\r\n\r\n    }\r\n\r\n    private void printData(byte[] b) {\r\n\r\n        if (b != null) {\r\n            println(\"Data:\\t\\t\" + dd.decode(b));\r\n        } else {\r\n            println(\"Data:\\t\\tnull\");\r\n        }\r\n\r\n    }\r\n\r\n    private void printACL(List<ACL> acl) {\r\n\r\n        println(\"ACL:\");\r\n\r\n        indentation += 2;\r\n\r\n        for (ACL a : acl) {\r\n\r\n            String perms = getACLString(a.getPerms());\r\n            String id = a.getId().getId();\r\n            String scheme = a.getId().getScheme();\r\n\r\n            println(scheme + \":\" + id + \"  \" + perms);\r\n        }\r\n\r\n        indentation -= 2;\r\n\r\n    }\r\n\r\n}\r\nzklogtool/src/main/java/com/zklogtool/monitor/TransactionMonitor.java\npublic class TransactionMonitor {\n\n    boolean running = false;\n    TransactionLog transactionLog;\n    TransactionIterator iterator;\n\n    List<TransactionListener> listeners = new ArrayList<>();\n\n    Thread monitorThread = new Thread() {\n\n        public void run() {\n\n            TransactionState lastState = null;\n\n            while (running) {\n\n                try {\n\n                    while (iterator.nextTransactionState() == TransactionState.OK) {\n\n                        notifyOnTransaction(iterator.next());\n\n                    }\n\n                    TransactionState n = iterator.nextTransactionState();\n\n                    if (n == TransactionState.INCOMPLETE && n != lastState) {\n                        notifyOnPartialTransaction();\n                    } else if (n == TransactionState.CORRUPTION && n != lastState) {\n                        notifyOnCorruption();\n                    }\n\n                    lastState = n;\n\n                    sleep(50);\n\n                } catch (InterruptedException ex) {\n                    //boring\n                }\n            }\n        }\n\n    };\n\n    /**\n     *\n     * @param transactionLog <code>TransactionLog</code> to monitor for new\n     * <code>Transaction</code>s.\n     */\n    public TransactionMonitor(final TransactionLog transactionLog) {\n\n        this.transactionLog = transactionLog;\n\n        monitorThread.setName(\"TransactionMonitor thread\");\n\n    }\n\n    /**\n     * Start <code>TransactionMonitor</code> in a way that it notifies listeners\n     * about all already written transactions and than continues monitoring.\n     *\n     */\n    public void startAtFirstTransaction() {\n\n        if (!running) {\n\n            iterator = transactionLog.iterator();\n\n            running = true;\n\n            monitorThread.start();\n\n        }\n\n    }\n\n    /**\n     * Start <code>TransactionMonitor</code> in a way that it notifies listeners\n     * only about transactions that were not written before monitoring started.\n     *\n     */\n    public void startAtLastTransaction() {\n\n        if (!running) {\n\n            iterator = transactionLog.iterator();\n\n            while (iterator.nextTransactionState() == TransactionState.OK) {\n\n                iterator.next();\n\n            }\n\n            running = true;\n\n            monitorThread.start();\n        }\n\n    }\n\n    /**\n     * Stops monitoring thread.\n     *\n     */\n    public void stop() {\n\n        running = false;\n\n    }\n\n    /**\n     *\n     * @param l <code>TransactionListener</code> to be added to listeners list.\n     */\n    public void addListener(TransactionListener l) {\n\n        listeners.add(l);\n\n    }\n\n    /**\n     *\n     * @param l <code>TransactionListener</code> to be removed from listeners\n     * list.\n     */\n    public void removeListener(TransactionListener l) {\n\n        listeners.remove(l);\n\n    }\n\n    private void notifyOnTransaction(Transaction t) {\n\n        //listener could change transaction, not safe, maybe send a copy\n        for (TransactionListener l : listeners) {\n            l.onTransaction(t);\n        }\n    }\n\n    private void notifyOnPartialTransaction() {\n\n        for (TransactionListener l : listeners) {\n            l.onPartialTransaction();\n        }\n\n    }\n\n    private void notifyOnCorruption() {\n\n        for (TransactionListener l : listeners) {\n            l.onCorruption();\n        }\n\n    }\n\n}\nzklogtool/src/main/java/com/zklogtool/printer/DataDecoder.java\npublic interface DataDecoder {\n   \n    /**\n     *\n     * @param data\n     * @return\n     */\n    public String decode(byte[] data);\n    \n}\nzklogtool/src/main/java/com/zklogtool/data/Transaction.java\npublic class Transaction {\n\n    private TxnHeader txnHeader;\n    private Record txnRecord;\n\n    public Transaction(TxnHeader txnHeader, Record txnRecord) {\n        super();\n        this.txnHeader = txnHeader;\n        this.txnRecord = txnRecord;\n    }\n\n    public TxnHeader getTxnHeader() {\n        return txnHeader;\n    }\n\n    public void setTxnHeader(TxnHeader txnHeader) {\n        this.txnHeader = txnHeader;\n    }\n\n    public Record getTxnRecord() {\n        return txnRecord;\n    }\n\n    public void setTxnRecord(Record txnRecord) {\n        this.txnRecord = txnRecord;\n    }\n\n}\nzklogtool/src/main/java/com/zklogtool/data/TransactionLog.java\npublic class TransactionLog implements Iterable<Transaction> {\n\n    final TransactionLogFileList transactionLogList;\n    final TransactionLogReaderFactory factory;\n\n    /**\n     * Constructs <code>TransactionLog</code> that provides iterator over\n     * <code>Transactions</code> in one transaction log file\n     * <code>transactionLogFile</code>.\n     *\n     * @param transactionLogFile Transaction log file to iterate over.\n     * @param factory <code>TransactionLogReaderFactory</code> that provides\n     * <code>TransactionLogFileReader</code> to be used.\n     */\n    public TransactionLog(final File transactionLogFile, TransactionLogReaderFactory factory) {\n\n        this.transactionLogList = new TransactionLogFileList() {\n\n            @Override\n            public File getFirstTransactionLog() throws NoFileException {\n                return transactionLogFile;\n            }\n\n            @Override\n            public File getNextTransactionLog(File previousTransactionLog) throws NoFileException {\n                throw new NoFileException(\"\");\n            }\n\n        };\n\n        this.factory = factory;\n\n    }\n\n    /**\n     * Constructs <code>TransactionLog</code> that provides iterator over\n     * <code>Transactions</code> written in multiple transaction log files.\n     * Transaction log files are provided by\n     * <code>transactionLogFileList</code>.\n     *\n     * @param transactionLogFileList Provides transaction log files to iterate\n     * over.\n     * @param factory <code>TransactionLogReaderFactory</code> that provides\n     * <code>TransactionLogFileReader</code> to be used.\n     */\n    public TransactionLog(TransactionLogFileList transactionLogFileList, TransactionLogReaderFactory factory) {\n\n        this.transactionLogList = transactionLogFileList;\n        this.factory = factory;\n\n    }\n\n    @Override\n    public TransactionIterator iterator() {\n\n        return new TransactionLogIterator(transactionLogList, factory);\n    }\n\n    /**\n     * Implements <code>TransactionIterator</code>. Remove operation is not\n     * supported.\n     *\n     */\n    public class TransactionLogIterator implements TransactionIterator {\n\n        private TransactionLogFileReader reader;\n        private TransactionLogFileList transactionLogList;\n\n        private Transaction t;\n        private TransactionState s;\n\n        private TransactionLogIterator(TransactionLogFileList transactionLogFileList, TransactionLogReaderFactory factory) {\n\n            this.transactionLogList = transactionLogFileList;\n\n            loadNextTransaction();\n\n        }\n\n        @Override\n        public boolean hasNext() {\n\n            if (nextTransactionState() == TransactionState.OK) {\n                return true;\n            } else {\n                return false;\n            }\n\n        }\n\n        @Override\n        public Transaction next() {\n\n            if (hasNext()) {\n\n                Transaction temp = t;\n\n                loadNextTransaction();\n\n                return temp;\n\n            } else {\n                throw new NoSuchElementException(\"No such element\");\n            }\n\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n\n        /**\n         *\n         * @return TransactionState of the next <code>Transaction</code> in\n         * iteration.\n         */\n        @Override\n        public TransactionState nextTransactionState() {\n\n            if (s != TransactionState.OK) {\n                loadNextTransaction();\n            }\n\n            return s;\n        }\n\n        private void loadNextTransaction() {\n\n            try {\n\n                if (reader == null) {\n\n                    reader = factory.getReader(transactionLogList.getFirstTransactionLog());\n\n                }\n\n                t = reader.getNextTransaction();\n\n                if (t != null) {\n                    s = TransactionState.OK;\n                } else {\n                    s = TransactionState.EMPTY;\n\n                    try {\n\n                        reader = factory.getReader(transactionLogList.getNextTransactionLog(reader.getTransactionLogFile()));\n\n                    } catch (NoFileException ex) {\n                        // this is ok, there is no next file so default behaviour is to stick with current file\n                    }\n                }\n\n            } catch (IncompleteTransactionException ex) {\n\n                s = TransactionState.INCOMPLETE;\n\n            } catch (CRCValidationException ex) {\n\n                s = TransactionState.CORRUPTION;\n\n            } catch (IOException ex) {\n\n                s = TransactionState.CORRUPTION;\n\n            } catch (NoFileException ex) {\n\n                s = TransactionState.EMPTY;\n\n            }\n\n        }\n\n    }\n\n}\nzklogtool/src/main/java/com/zklogtool/data/TransactionIterator.java\npublic interface TransactionIterator extends Iterator<Transaction> {\n\n    /**\n     *\n     * @return <code>TransactionState</code> of the next\n     * <code>Transaction</code>.\n     */\n    public TransactionState nextTransactionState();\n\n}\nzklogtool/src/main/java/com/zklogtool/data/TransactionState.java\npublic enum TransactionState {\n\n    /**\n     * Transaction is completely written and CRC is successfully validated.\n     */\n    OK,\n    /**\n     * Transaction is not written at all.\n     */\n    EMPTY,\n    /**\n     * Part of transaction is written.\n     */\n    INCOMPLETE,\n    /**\n     * Part or entire transaction is written but CRC validation has failed.\n     */\n    CORRUPTION\n}\nzklogtool/src/main/java/com/zklogtool/reader/TransactionLogReaderFactory.java\npublic class TransactionLogReaderFactory {\n\n    public TransactionLogFileReader getReader(File transactionLog) throws FileNotFoundException, IOException {\n\n        return new TransactionLogFileReader(transactionLog);\n\n    }\n\n}\nzklogtool/src/main/java/com/zklogtool/monitor/TransactionListener.java\npublic interface TransactionListener {\n\n    /**\n     * Called when transaction is entirely written to transaction log.\n     *\n     * @param t <code>Transaction</code> written to transaction log file.\n     */\n    void onTransaction(Transaction t);\n\n    /**\n     * Called when transaction is not entirely written to transaction log file.\n     *\n     */\n    void onPartialTransaction();\n\n    /**\n     * Called when there is corruption detected while reading transaction log\n     * file.\n     *\n     */\n    void onCorruption();\n\n}\nzklogtool/src/main/java/com/zklogtool/printer/UnicodeDecoder.java\npublic class UnicodeDecoder implements DataDecoder {\n\n    @Override\n    public String decode(byte[] data) {\n\n        //maybe should check charset before \n        return new String(data);\n    }\n\n}\n", "answers": ["            while (transactionIterator.nextTransactionState() == TransactionState.OK) {\r"], "length": 2594, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "19066882a192c514e9f9dd3c6c835142c4c457c6e7dcd833"}
{"input": "import com.yahoo.sql4d.BaseStatementMeta;\nimport com.yahoo.sql4d.CrudProgram;\nimport com.yahoo.sql4d.CrudStatementMeta;\nimport com.yahoo.sql4d.query.RequestType;\nimport static com.yahoo.sql4d.sql4ddriver.Util.*;\nimport com.yahoo.sql4d.DCompiler;\nimport com.yahoo.sql4d.DeleteProgram;\nimport com.yahoo.sql4d.DropProgram;\nimport com.yahoo.sql4d.InsertProgram;\nimport com.yahoo.sql4d.Program;\nimport com.yahoo.sql4d.QueryProgram;\nimport com.yahoo.sql4d.delete.DeleteMeta;\nimport com.yahoo.sql4d.drop.DropMeta;\nimport com.yahoo.sql4d.insert.InsertMeta;\nimport com.yahoo.sql4d.query.QueryMeta;\nimport com.yahoo.sql4d.query.nodes.Interval;\nimport com.yahoo.sql4d.query.select.SelectQueryMeta;\nimport com.yahoo.sql4d.sql4ddriver.rowmapper.DruidBaseBean;\nimport com.yahoo.sql4d.sql4ddriver.sql.MysqlAccessor;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport org.joda.time.DateTime;\nimport org.json.JSONArray;\nimport scala.util.Either;\nimport scala.util.Left;\nimport scala.util.Right;\nimport scala.Tuple2;\n/**\n * Copyright 2014 Yahoo! Inc. Licensed under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License. See accompanying\n * LICENSE file.\n */\npackage com.yahoo.sql4d.sql4ddriver;\n\n\n\n/**\n * TODO: Use logger. Database driver for druid. Does not conform\n * to javax.sql.DataSource. \n * \n * Possible druid responses :\n *\n * For groupBy the response is as follows. [ { \"version\" : \"v1\", \"timestamp\" :\n * \"2013-07-12T04:00:00.000Z\", \"event\" : { ... } }, { \"version\" : \"v1\",\n * \"timestamp\" : \"2013-07-12T04:00:00.000Z\", \"event\" : { ... } },... ] \n * \n * For timeseries the response is as follows [ { \"timestamp\":\n * \"2012-01-01T00:00:00.000Z\", \"result\": { \"sample_name1\": <some_value>,\n * \"sample_name2\": <some_value>, \"sample_divide\": <some_value> } }, {\n * \"timestamp\": \"2012-01-02T00:00:00.000Z\", \"result\": { \"sample_name1\":\n * <some_value>, \"sample_name2\": <some_value>, \"sample_divide\": <some_value> } }\n * ]\n * \n * For TopN query the response is as follows [ { \"timestamp\":\n * \"2013-08-31T00:00:00.000Z\", \"result\": [ { \"dim1\": \"dim1_val\", \"count\": 111,\n * \"some_metrics\": 10669, \"average\": 96.11711711711712 }, {.... } ] } ]\n *\n * @author srikalyan\n */\npublic class DDataSource {\n\n    private BrokerAccessor broker; \n    private CoordinatorAccessor coordinator; \n    private OverlordAccessor overlord; \n    \n    private MysqlAccessor dbAccessor;\n    \n    private static int MAX_CONNS_IN_POOL = 150;\n    private static int MAX_BROKER_CONNS = 100;\n    private static int MAX_COORD_CONNS = 50;\n    private static int MAX_OVERLORD_CONNS = 50;\n\n    public DDataSource(String bHost, int bPort) {\n        this(bHost, bPort, null, 0);\n    }\n\n    public DDataSource(String bHost, int bPort, String cHost, int cPort) {\n        this(bHost, bPort, cHost, cPort, null, 0);\n    }\n\n    public DDataSource(String bHost, int bPort, String cHost, int cPort, String oHost, int oPort) {\n        this(bHost, bPort, cHost, cPort, oHost, oPort, \"localhost\", 3306, \"druid\", \"diurd\", \"druid\");\n    }\n\n    public DDataSource(String bHost, int bPort, String cHost, int cPort, String oHost, int oPort, String sqlHost, int sqlPort, String sqlId, String sqlPasswd, String dbName) {\n        broker = new BrokerAccessor(bHost, bPort, MAX_BROKER_CONNS);\n        coordinator = new CoordinatorAccessor(cHost, cPort, MAX_COORD_CONNS);\n        overlord = new OverlordAccessor(oHost, oPort, MAX_OVERLORD_CONNS);\n        dbAccessor = new MysqlAccessor(sqlHost, sqlPort, sqlId, sqlPasswd, dbName);\n    }\n\n    /**\n     * Call if a custom pool size, and fine grained control on connections per route.\n     * NOTE: This must be called prior to instantiating DDataSource for the settings\n     * to be effective.\n     * @param maxConnsInPool\n     * @param maxBrokerConns\n     * @param maxCoordConns\n     * @param maxOverlordConns \n     */\n    public static void adjustPoolSettings(int maxConnsInPool, int maxBrokerConns, int maxCoordConns, int maxOverlordConns) {\n        MAX_CONNS_IN_POOL = maxConnsInPool;\n        MAX_BROKER_CONNS = maxBrokerConns;\n        MAX_COORD_CONNS = maxCoordConns;\n        MAX_OVERLORD_CONNS = maxOverlordConns;\n        DruidNodeAccessor.setMaxConnections(MAX_CONNS_IN_POOL);\n    }\n    \n    /**\n     * NOTE: This must be called prior to instantiating DDataSource for the settings\n     * to be effective.\n     * @param pHost\n     * @param pPort \n     */\n    public static void setProxy(String pHost, int pPort) {\n        DruidNodeAccessor.setProxy(pHost, pPort);\n    }\n    \n    private String preprocessSqlQuery(String sqlQuery, NamedParameters namedParams) {\n        if (namedParams != null) {\n            return namedParams.deParameterize(sqlQuery);\n        }\n        return sqlQuery;\n    }\n\n    /**\n     * Get an in memory representation of broken SQL query. This may require \n     * contacting druid for resolving dimensions Vs metrics for SELECT queries\n     * hence it also optionally accepts HTTP request headers to be sent out.\n     *\n     * @param sqlQuery\n     * @param namedParams\n     * @param reqHeaders\n     * @return\n     * @throws java.lang.Exception\n     */\n    public Program<BaseStatementMeta> getCompiledAST(String sqlQuery, NamedParameters namedParams, Map<String, String> reqHeaders) throws Exception {\n        Program<BaseStatementMeta> pgm = DCompiler.compileSql(preprocessSqlQuery(sqlQuery, namedParams));\n        for (BaseStatementMeta stmnt : pgm.getAllStmnts()) {\n            if (stmnt instanceof QueryMeta) {\n                QueryMeta query = (QueryMeta) stmnt;\n                if (query.queryType == RequestType.SELECT) {//classifyColumnsToDimAndMetrics\n                    Either<String, Tuple2<List<String>, List<String>>> dataSourceDescRes = coordinator.aboutDataSource(stmnt.dataSource, reqHeaders);\n                    if (dataSourceDescRes.isLeft()) {\n                        throw new Exception(\"Datasource info either not available (or)could not be loaded .\" + dataSourceDescRes.left().get());\n                    } else {\n                        ((SelectQueryMeta) query).postProcess(dataSourceDescRes.right().get());\n                    }\n                }", "context": "Sql4DCompiler/src/main/java/com/yahoo/sql4d/delete/DeleteMeta.java\npublic class DeleteMeta extends CrudStatementMeta {\n\n    public String id;// UUid\n    public Interval interval = null;\n    public List<Interval> segmentsToDelete = null;// This will be determined at runtime.\n    public List<String> dimensions = new ArrayList<>();// This will be determined at runtime.\n    public List<String> metrics = new ArrayList<>();// This will be determined at runtime.\n\n    public DeleteMeta() {\n    }\n\n    public DeleteMeta(String dataSource, Interval interval) {\n        super(dataSource);\n        this.interval = interval;\n    }\n\n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n\n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n    /**\n     * Retain segments only overlapping with the range.\n     * @param allSegments \n     */\n    public void filterSegments(List<Interval> allSegments) {\n        segmentsToDelete = Lists.newArrayList(Iterables.filter(allSegments, new Predicate<Interval>() {\n            @Override\n            public boolean apply(Interval i) {\n                return i.fallsIn(interval);\n            }\n        }));\n    }\n\n    @Override\n    public Map<String, Object> getDataMap() {\n        // For each instance of data generation generate a new id.\n        id = String.format(\"kill_%s_%s_%s_%s\", dataSource, interval.getStartTime(), interval.getEndTime(), new DateTime().toString());\n        Map<String, Object> map = super.getDataMap();\n        map.put(\"type\", \"kill\");\n        map.put(\"dataSource\", dataSource);\n        map.put(\"interval\", interval.toString());\n        map.put(\"id\", id);\n        return map;\n    }\n\n\n    public <T> void postProcess(T anyContext) {\n\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/CrudProgram.java\npublic abstract class CrudProgram<T extends CrudStatementMeta> extends Program<T>{\n    public boolean waitForCompletion = true;\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/query/RequestType.java\npublic enum RequestType {\n    GROUPBY, TIMESERIES, TOPN, SEARCH, SELECT, TIMEBOUNDARY, UNKNOWN;\n\n    public String getName() {\n        if (this == TIMEBOUNDARY) {\n            return \"timeBoundary\";\n        }\n        return this.name().toLowerCase();\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/DropProgram.java\npublic class DropProgram extends CrudProgram<DropMeta>{\n    public DropProgram() {\n        this.type = Type.DROP;\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n        for (DropMeta dMeta: getAllStmnts()) {\n            System.out.println(dMeta.toString());\n        }\n        return buffer.toString();\n    }\n    \n    /**\n     * TODO: Do all semantic checks here. 1st field should be timestamp.\n     * @throws java.lang.Exception\n     */\n    @Override\n    public void isValid() throws Exception {\n    }\n\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/query/select/SelectQueryMeta.java\npublic class SelectQueryMeta  extends PlainDimQueryMeta {\n\n    public final PagingSpec pagingSpec = new PagingSpec(null, 5);\n    public List<String> fetchMetrics = new ArrayList<>();\n    \n    \n    private static final JSONObject EMPTY_JSON = new JSONObject();\n    \n    public SelectQueryMeta() {\n        queryType = RequestType.SELECT;\n    }\n\n    public SelectQueryMeta(QueryMeta q) {\n        super(q);\n        queryType = RequestType.SELECT;\n    }\n\n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n    \n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n    \n    @Override\n    public Map<String, Object> getDataMap() {\n        Map<String, Object> map = super.getDataMap();\n        Map<String, Object> pagingSpecMap = new LinkedHashMap<>();\n        if (pagingSpec != null) {\n            if (pagingSpec.pagingIdentifiers == null) {\n                pagingSpecMap.put(\"pagingIdentifiers\", EMPTY_JSON);\n            } else {\n                pagingSpecMap.put(\"pagingIdentifiers\", pagingSpec.pagingIdentifiers);\n            }\n            pagingSpecMap.put(\"threshold\", pagingSpec.threshold);\n        }\n        map.put(\"pagingSpec\", pagingSpecMap);\n        if (fetchMetrics != null) {\n            map.put(\"metrics\", new JSONArray(fetchMetrics));\n        }\n        return map;\n    }\n    \n    /**\n     * This method must be called prior to calling {@link SelectQueryMeta#getDataMap() }.\n     * Essentially splits columns into Dimensions and Metrics.\n     * @param <T>\n     * @param anyContext\n     */\n    @Override\n    public <T> void postProcess(T anyContext) {\n        Tuple2<List<String>, List<String>> dimsAndMetrics = (Tuple2<List<String>, List<String>>)anyContext;\n        List<String> dims = dimsAndMetrics._1();\n        List<String> metrics = dimsAndMetrics._2();\n        Iterator<Map.Entry<String, String>> colIter = fetchDimensions.entrySet().iterator();\n        while (colIter.hasNext()) {\n            Map.Entry<String, String> entry = colIter.next();\n            if (dims.contains(entry.getKey())) {\n                //No action.\n            } else if (metrics.contains(entry.getKey())) {\n                fetchMetrics.add(entry.getKey());\n                colIter.remove();\n            } else {//TODO: Handle error\n                \n            }\n        }\n    }\n    \n    public static SelectQueryMeta promote(QueryMeta qMeta) {\n        return new SelectQueryMeta(qMeta);\n    }\n    \n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/InsertProgram.java\npublic class InsertProgram extends CrudProgram<InsertMeta>{\n    public static InsertProgram getInsertInstance() {\n        return new InsertProgram(Type.INSERT);\n    } \n    \n    public static InsertProgram getInsertHadoopInstance() {\n        return new InsertProgram(Type.INSERT_HADOOP);\n    } \n\n    public static InsertProgram getInsertRTInstance() {\n        return new InsertProgram(Type.INSERT_REALTIME);\n    } \n\n    private InsertProgram(Type type) {\n        this.type = type;\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n        for (InsertMeta iMeta: getAllStmnts()) {\n            System.out.println(iMeta.toString());\n        }\n        return buffer.toString();\n    }\n    \n    /**\n     * TODO: Do all semantic checks here. 1st field should be timestamp.\n     * @throws java.lang.Exception\n     */\n    @Override\n    public void isValid() throws Exception {\n    }\n\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/DeleteProgram.java\npublic class DeleteProgram extends CrudProgram<DeleteMeta>{\n    public DeleteProgram() {\n        this.type = Type.DELETE;\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n        for (DeleteMeta dMeta: getAllStmnts()) {\n            System.out.println(dMeta.toString());\n        }\n        return buffer.toString();\n    }\n    \n    /**\n     * TODO: Do all semantic checks here. 1st field should be timestamp.\n     * @throws java.lang.Exception\n     */\n    @Override\n    public void isValid() throws Exception {\n    }\n\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/insert/InsertMeta.java\npublic abstract class InsertMeta extends CrudStatementMeta {\n\n    public String dataFormat = \"tsv\";//\n    public String delimiter = \",\";\n    public String listDelimiter = \"\\n\";\n    public List<AggItem> aggregations = new ArrayList<>();\n    public Map<String, String> fetchDimensions = new LinkedHashMap<>();\n    public Set<String> orderedColumns = new LinkedHashSet<>();//For maintaining the insert order of data columns.\n\n    public GranularitySpec granularitySpec = new GranularitySpec(\"day\");\n\n    public InsertMeta() {\n    }\n\n    public InsertMeta(String dataSource) {\n        super(dataSource);\n    }\n\n    // Could be a dimension or metric.\n    public void addColumnInOrder(String column) {\n        orderedColumns.add(column);\n    }\n        \n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n\n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n\n    @Override\n    public Map<String, Object> getDataMap() {\n        Map<String, Object> map = super.getDataMap();\n        map.put(\"dataSource\", dataSource);\n        return map;\n    }\n\n    //TODO: IOConfig should be called before dataSchema to ensure proper format values etc are filled in.\n    // See getFirehose() method to see what dependencies are being filled in. This dependency should \n    // be removed in future.\n    public Map<String, Object> getSpec() {\n        return ImmutableMap.<String, Object>of(\n                \"ioConfig\", getIoConfig(),\n                \"dataSchema\", getDataSchema(),\n                \"tuningConfig\", getTuningConfig());\n    }\n\n    public Map<String, Object> getDimensionSpec() {\n        List<String> dims = getDimensions(fetchDimensions);\n        return ImmutableMap.<String, Object>of(\n                \"dimensions\", dims.subList(1, dims.size()),\n                \"dimensionExclusions\", ImmutableList.<String>of(),\n                \"spatialDimensions\", ImmutableList.<String>of());\n    }\n    \n    public List<JSONObject> getMetricsSpec() {\n        ImmutableList.Builder<JSONObject> builder = ImmutableList.<JSONObject>builder();\n        for (AggItem item : aggregations) {\n            builder.add(item.getJson());\n        }\n        return builder.build();\n    }\n\n    public Map<String, Object> getParser() {\n        return ImmutableMap.<String, Object>of(\n                \"type\", \"string\",\n                \"parseSpec\", getParseSpec());\n    }\n\n    public Map<String, Object> getParseSpec() {\n        ImmutableMap.Builder builder = ImmutableMap.<String, Object>builder();\n        builder.put(\"format\", dataFormat).\n                put(\"timestampSpec\", getTimestampSpec()).\n                put(\"dimensionsSpec\", getDimensionSpec());\n        if (delimiter != null) {\n            builder.put(\"delimiter\", delimiter);\n        }\n        if (listDelimiter != null) {\n            builder.put(\"listDelimiter\", listDelimiter);\n        }\n        builder.put(\"columns\", orderedColumns);\n        return builder.build();\n    }\n    \n    public Map<String, Object> getDataSchema() {\n        return ImmutableMap.<String, Object>of(\n                \"dataSource\", dataSource,\n                \"parser\", getParser(),\n                \"metricsSpec\", getMetricsSpec(),\n                \"granularitySpec\", granularitySpec.getJson()\n                );\n    }\n    \n    public abstract Map<String, Object> getTimestampSpec();\n    public abstract Map<String, Object> getIoConfig();\n    public abstract Map<String, Object> getTuningConfig();\n\n    public <T> void postProcess(T anyContext) {\n\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/QueryProgram.java\npublic class QueryProgram extends Program<QueryMeta>{\n    public final List<String> primaryJoinableHooks = new ArrayList<>();// Has 'N-1' items\n    public final List<String> joinTypes = new ArrayList<>();// Has 'N-1' items\n\n    public QueryProgram() {\n        this.type = Type.QUERY;\n    }\n        \n    \n    public void addJoinHook(String hook) {\n        primaryJoinableHooks.add(hook);\n    }\n    \n    public void addJoinType(String type) {\n        joinTypes.add(type);\n    }\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n        int i = 0;\n        for (QueryMeta qMeta: getAllStmnts()) {\n            buffer.append(qMeta.toString());\n            buffer.append(\"\\n\");\n            if (i == numStmnts() - 1) {\n                break;\n            }\n            if (numStmnts() > 1) {\n                buffer.append(\" joined with \");\n                buffer.append(primaryJoinableHooks.get(i++));\n                buffer.append(\"\\n\");\n            }\n            \n        }\n        return buffer.toString();\n    }\n    \n    /**\n     * TODO: This method should be a full blown functional but right now address \n     * only partial semantics.\n     * Do all semantic checks here.\n     * @throws java.lang.Exception\n     */\n    @Override\n    public void isValid() throws Exception {\n        if (numStmnts() >= 2) {\n            if (primaryJoinableHooks.size() > 0) {\n                for (String joinField:primaryJoinableHooks) {\n                    if (joinField.equals(\"timestamp\")) {// timestamp is implicitly present in the result.\n                        continue;\n                    }\n                    for (QueryMeta query: getAllStmnts()) {\n                        boolean isPresent = false;\n                        if (query instanceof BaseAggQueryMeta) {// Since BaseAggQueryMeta is also a PlainDimQueryMeta we go with former first.\n                            for (AggItem item:((BaseAggQueryMeta)query).aggregations) {\n                                if (joinField.equals(item.fieldName) || (item.asName != null && joinField.equals(item.asName))) {\n                                    isPresent = true;\n                                }\n                            }\n                        }\n                        if (query instanceof PlainDimQueryMeta) {\n                            Map<String, String> dims = ((PlainDimQueryMeta)query).fetchDimensions;\n                            for (Map.Entry<String, String> entry :dims.entrySet()) {\n                                if (joinField.equals(entry.getKey()) || (entry.getValue() != null && joinField.equals(entry.getValue()))) {\n                                    isPresent = true;\n                                }\n                            }\n                        }\n                        if (!isPresent) {\n                            String error = joinField + \" mentioned in the composite key should appear in all the data sources being queried and joined.\";\n                            throw new Exception(error);\n                        }\n                    }\n                }\n            } else {\n                String error = \"Need atleast one field to join on\";\n                throw new Exception(error);\n            }\n        }\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/CrudStatementMeta.java\npublic abstract class CrudStatementMeta extends BaseStatementMeta {\n    public CrudStatementMeta() {\n    }\n\n    public CrudStatementMeta(String dataSource) {\n        this.dataSource = dataSource;\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/query/nodes/Interval.java\npublic class Interval {\n    public String startTime;\n    public String endTime;\n    public int days;// Includes partial days as well.\n    \n    public Interval(String startTime, String endTime) {\n        this.startTime = startTime.replaceAll(\"'\", \"\");\n        this.endTime = endTime.replaceAll(\"'\", \"\");\n        days = Days.daysBetween(getStartTime().withTimeAtStartOfDay() , getEndTime().withTimeAtStartOfDay() ).getDays() + 1;\n    }\n\n    /**\n     * Interval should be of form 2014-10-31T00:00:00.000-07:00/2014-11-01T00:00:00.000-07:00\n     * @param interval \n     */\n    public Interval(String interval) {\n        String[] dates = interval.split(\"/\");\n        Preconditions.checkArgument(dates.length == 2);\n        this.startTime = dates[0].replaceAll(\"'\", \"\");\n        this.endTime = dates[1].replaceAll(\"'\", \"\");\n        days = Days.daysBetween(getStartTime().withTimeAtStartOfDay() , getEndTime().withTimeAtStartOfDay() ).getDays() + 1;\n    }\n\n    public DateTime getStartTime() {\n        return TimeUtils.getDateTime(startTime);\n    }\n\n    public DateTime getEndTime() {\n        return TimeUtils.getDateTime(endTime);\n    }\n\n    public int getDays() {\n        return days;\n    }\n    \n    public Interval getInterval(int daysOffset, int startHourOffset, int endHourOffset) {\n        DateTime baseDateTime = getStartTime().withTime(0, 0, 0, 0).plusDays(daysOffset);\n        return new Interval(baseDateTime.plusHours(startHourOffset).toString(), \n                baseDateTime.plusHours(endHourOffset).minusSeconds(1).toString());\n    }\n\n    public Interval expandIntervalByDay(int days) {\n        return new Interval(getStartTime().minusDays(days).toString(), \n                getEndTime().plusDays(days).toString());\n    }\n\n    public Interval expandEndTimeByDay(int days) {\n        return new Interval(getStartTime().toString(), \n                getEndTime().plusDays(days).toString());\n    }\n\n    public Interval expandIntervalBySec(int secs) {\n        return new Interval(getStartTime().minusSeconds(secs).toString(), \n                getEndTime().plusSeconds(secs).toString());\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s/%s\", startTime, endTime);\n    }\n    \n    public boolean fallsIn(Interval range) {\n        return range.getStartTime().isBefore(getStartTime()) && range.getEndTime().isAfter(getEndTime());\n    }\n\n}\nSql4Ddriver/src/main/java/com/yahoo/sql4d/sql4ddriver/sql/MysqlAccessor.java\npublic class MysqlAccessor extends BasePoolableObjectFactory<Tuple2<DataSource, Connection>> {\n\n    private final String connectorUrl = \"jdbc:mysql://%s:%d/%s?autoReconnectForPools=true\";\n    private String host = \"localhost\";\n    private int port = 3306;\n    private String id = \"druid\";//druid by default.\n    private String password = \"diurd\";//diurd by default.\n    private String db = \"druid\";//druid by default\n    private ObjectPool<Tuple2<DataSource, Connection>> pool = null ;\n\n    static {\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\").newInstance();\n        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n    public MysqlAccessor() {\n        this(\"localhost\", 3306, \"druid\", \"diurd\", \"druid\");\n    }\n\n    public MysqlAccessor(String host, int port) {\n        this(host, port, \"druid\", \"diurd\", \"druid\");\n    }\n\n    public MysqlAccessor(String host, int port, String id, String passwd) {\n        this(host, port, id, passwd, \"druid\");\n    }\n\n    public MysqlAccessor(String host, int port, String id, String passwd, String db) {\n        this.host = host;\n        this.port = port;\n        this.id = id;\n        this.password = passwd;\n        this.db = db;\n        init();\n    }\n    \n    private void init() {\n        GenericObjectPool.Config config = new GenericObjectPool.Config();\n        config.maxActive = 2;//TODO: Make this configurable.\n        config.testOnBorrow = true;\n        config.testWhileIdle = true;\n        config.timeBetweenEvictionRunsMillis = 10000;\n        config.minEvictableIdleTimeMillis = 60000;\n        GenericObjectPoolFactory genericObjectPoolFactory = new GenericObjectPoolFactory(this, config);\n        pool = genericObjectPoolFactory.createPool();\n    }\n    \n    @Override\n    public Tuple2<DataSource, Connection> makeObject() throws Exception {\n        DataSource ds = new DriverManagerDataSource(format(connectorUrl, host, port, db), id, password);\n        return new Tuple2<>(ds, ds.getConnection());\n    }\n\n    @Override\n    public void destroyObject(Tuple2<DataSource, Connection> connTuple) throws Exception {\n        connTuple._2().close();\n    }\n\n    @Override\n    public boolean validateObject(Tuple2<DataSource, Connection> conn) {\n        try {\n            return conn._2().isValid(0);\n        } catch (SQLException ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n            try {//Could be due to stale connection. Invalidate the object.\n                pool.invalidateObject(conn);\n            } catch (Exception ex1) {//TODO: Something serious with DB.\n                Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex1);\n            }\n        }\n        return false;\n    }\n    \n    public Tuple2<DataSource, Connection> getConnection() {\n        try {\n            return pool.borrowObject();\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return null;\n    }\n\n    public void returnConnection(Tuple2<DataSource, Connection> con) {\n        try {\n            if (con != null) {\n                pool.returnObject(con);\n            }\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n\n    public void shutdown() {\n        try {\n            pool.clear();\n            pool.close();\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n    \n    public List<Map<String, Object>> query(Map<String, String> params, String query) {\n        List<Map<String, Object>> result = null;\n        Tuple2<DataSource, Connection> conn = null;\n        try {\n            conn = getConnection();\n            NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(conn._1());\n            result = jdbcTemplate.queryForList(query, params);\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        } finally {\n            returnConnection(conn);\n        }\n        return result;\n    }\n\n    /**\n     * Suitable for CRUD operations where no result set is expected.\n     * @param params\n     * @param query \n     * @return  \n     */\n    public boolean execute(Map<String, String> params, String query) {\n        final AtomicBoolean result = new AtomicBoolean(false);\n        Tuple2<DataSource, Connection> conn = null;\n        try {\n            conn = getConnection();\n            NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(conn._1());\n            jdbcTemplate.execute(query, params, new PreparedStatementCallback<Void>() {\n                @Override\n                public Void doInPreparedStatement(PreparedStatement ps) {\n                    try {\n                        result.set(ps.execute());\n                    } catch(SQLException e) {\n                        result.set(false);\n                    }\n                    return null;\n                }\n            });\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n            result.set(false);\n        } finally {\n            returnConnection(conn);\n        }\n        return result.get();\n    }\n    \n    public List<Map<String, Object>> segmentsInRange(String table, Interval interval) {\n        return query(ImmutableMap.of(\"dataSource\", table,\n                \"iStart\", interval.startTime,\n                \"iEnd\", interval.endTime), DAODictionary.SEGMENTS_IN_RANGE);\n    }\n\n    public List<Map<String, Object>> usedSegmentsInRange(String table, Interval interval) {\n        return query(ImmutableMap.of(\"dataSource\", table,\n                \"iStart\", interval.startTime,\n                \"iEnd\", interval.endTime,\n                \"used\", \"1\"), DAODictionary.USED_SEGMENTS_IN_RANGE);\n    }\n\n    public boolean disableSegmentsInRange(String table, Interval interval) {\n        return execute(ImmutableMap.of(\"dataSource\", table,\n                \"iStart\", interval.startTime,\n                \"iEnd\", interval.endTime), DAODictionary.DISABLE_SEGMENTS_IN_RANGE);\n    }\n\n    public boolean disableAllSegments(String table) {\n        return execute(ImmutableMap.of(\"dataSource\", table), DAODictionary.DISABLE_ALL_SEGMENTS);\n    }\n\n    public static void main(String[] args) {\n        MysqlAccessor accessor = new MysqlAccessor();\n        System.out.println(accessor.usedSegmentsInRange(\"abf2\", new Interval(\"2014-10-31/2014-11-01\")));\n        accessor.shutdown();\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/query/QueryMeta.java\npublic class QueryMeta extends BaseStatementMeta {\n    public Granularity granularity = new Granularity(\"all\");\n    public Filter filter;\n    public List<Interval> intervals = new ArrayList<>(); \n    public List<Pair<Integer, Integer>> microIntervals = new ArrayList<>(); // If empty or if intervals list size > 1 then this is not used.\n    public RequestType queryType;\n    \n    public QueryMeta() {\n    }\n\n    public QueryMeta(QueryMeta q) {\n        super(q);\n        this.granularity = q.granularity;\n        this.filter = q.filter;\n        this.intervals = q.intervals;\n        this.microIntervals = q.microIntervals;\n    }\n    \n    public QueryMeta(String dataSource, Granularity granularity, Filter filter, List<Interval> intervals, List<Pair<Integer, Integer>> microIntervals) {\n        super(dataSource);\n        this.granularity = granularity;\n        this.filter = filter;\n        this.intervals = intervals;\n        this.microIntervals = microIntervals;\n    }\n\n    \n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n    \n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n    @Override\n    public Map<String, Object> getDataMap() {\n        Map<String, Object> map = super.getDataMap();\n        map.put(\"queryType\", queryType.getName());\n        if (queryType == RequestType.TIMEBOUNDARY) {\n            return map;\n        }\n        if (granularity != null) {\n            if (granularity.gComplex != null) {\n                map.put(\"granularity\", granularity.getJson());\n            } else {\n                map.put(\"granularity\", granularity.gSimple);\n            }\n        }\n        if (filter != null) {\n            map.put(\"filter\", filter.getJson());\n        }\n\n        JSONArray intervalsArray = new JSONArray();\n        if (!intervals.isEmpty()) {\n            if (intervals.size() == 1 && !microIntervals.isEmpty()) {\n                Interval grandInterval = intervals.get(0);\n                // Break the single interval into micro intervals.\n                for (int i = 0; i < grandInterval.getDays();i++) {\n                    for (Pair<Integer, Integer> pair:microIntervals) {\n                        Interval microInterval = grandInterval.getInterval(i, pair.a, pair.a + pair.b);// a = start hour of day, b = number of hours from there of.\n                        intervalsArray.put(microInterval.toString());\n                    }\n                }\n            } else {\n                for (Interval interval:intervals) {\n                    intervalsArray.put(interval.toString());\n                }\n            }\n            JSONObject finalIntervalJson = new JSONObject();\n            finalIntervalJson.put(\"type\", \"intervals\");\n            finalIntervalJson.put(\"intervals\", intervalsArray);\n            map.put(\"intervals\", finalIntervalJson);\n        }\n        return map;\n    }\n    \n}\nSql4Ddriver/src/main/java/com/yahoo/sql4d/sql4ddriver/rowmapper/DruidBaseBean.java\npublic class DruidBaseBean<T extends DruidBaseBean> extends Serializer<T> {\n    private static final DateTimeFormatter dateOnlyFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd\");\n    private static final DateTimeFormatter dateTimeFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss\");\n    private static final DateTimeFormatter dateTimeWithSubSecFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\");\n    private static final DateTimeFormatter dateTimeAndTZFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ssZZ\");\n    private static final DateTimeFormatter dateTimeWithSubSecAndTZFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZZ\");\n\n    public static void main(String[] args) {\n        System.out.println(dateTimeFormat.parseDateTime(\"2014-05-25T16:45:49\"));\n        System.out.println(dateTimeAndTZFormat.parseDateTime(\"2014-05-25T16:45:49+00:00\"));\n        System.out.println(dateTimeAndTZFormat.parseDateTime(\"2014-05-25T16:45:49Z\"));\n        System.out.println(dateTimeWithSubSecFormat.parseDateTime(\"2014-05-25T16:45:49.100\"));\n        System.out.println(dateTimeWithSubSecAndTZFormat.parseDateTime(\"2014-05-25T16:45:49.000Z\"));\n    }\n\n    public String timestamp;// TODO: Crazy,though getDeclaredMethods can be used to access private fields, it is not possible on subclasses.\n\n    public void setTimestamp(String timestamp) {\n        this.timestamp = timestamp;\n    }\n\n    public String getTimestamp() {\n        return timestamp;\n    }\n    \n    public Map<String, Object> toMap() {\n        Map<String, Object> map = new ObjectMapper().convertValue(this, Map.class);\n        // The following 2 comes from Serializer.\n        map.remove(\"acceptsNull\");\n        map.remove(\"immutable\");\n        return map;        \n    }\n\n    @Override\n    public String toString() {\n        return toMap().toString();\n    }\n\n    @Override\n    public void write(Kryo kryo, Output output, T t) {\n        Map<String, Object> map = toMap();\n        for (String key:map.keySet()) {\n            Object value = map.get(key);\n            kryo.writeClass(output, value.getClass());\n            kryo.writeObjectOrNull(output, key, String.class);\n            kryo.writeObjectOrNull(output, value, value.getClass());\n        }\n    }\n\n    @Override\n    public T read(Kryo kryo, Input input, Class<T> type) {\n        T retValue = null;\n        try {\n            retValue = type.newInstance();\n            Registration reg = kryo.readClass(input);\n            String key = kryo.readObjectOrNull(input, String.class);\n            Object value = kryo.readObjectOrNull(input, reg.getType());\n            Util.applyKVToBean(retValue, key, value);\n        } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | IllegalArgumentException | InvocationTargetException ex) {\n            Logger.getLogger(DruidBaseBean.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return retValue;\n    }\n    \n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/DCompiler.java\npublic class DCompiler {\n    /**\n     * To avoid instantiation.\n     */\n    private DCompiler() {\n    }\n    /**\n     * Sql->Json.\n     * @param query\n     * @return \n     */\n    public static Program compileSql(String query) {\n        try {\n            ANTLRStringStream in = new ANTLRStringStream(query);\n            druidGLexer lexer = new druidGLexer(in);\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\n            druidGParser parser = new druidGParser(tokens);\n            Program pgm = parser.program();\n            return pgm;\n        } catch (RecognitionException ex) {\n            System.out.println(ex);\n            Logger.getLogger(DCompiler.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return null;\n    }\n    \n    public static void main(String[] args) {\n        //Program p = compileSql(\"select UNIQUE(referer) AS refe, referer FROM miab_hourly_v2 WHERE interval BETWEEN 2014-11-05T08:18:00.000Z AND 2014-11-05T08:20:00.000Z  BREAK BY 'day' GROUP BY referer;\");\n        Program p = compileSql(\"INSERT INTO abf (timestamp , provider , title, uuid, DOUBLE_SUM(click) AS click)  VALUES ('2014-10-31 00:00:00','sri','SE','fsd-sdf-dfgdf','2') WHERE interval BETWEEN '2013-08-31' AND '2023-09-01'  BREAK BY 'day';\");\n        System.out.println(p);\n    }\n}\nSql4Ddriver/src/main/java/com/yahoo/sql4d/sql4ddriver/Util.java\npublic class Util {\n    public static final void newLine() {\n        System.out.println();\n    }\n    \n    public static final void print(char c) {\n        System.out.print(c);\n        System.out.flush();\n    }\n\n    public static final void print(String message) {\n        System.out.print(message);\n        System.out.flush();\n    }\n\n    public static final void println(String message) {\n        System.out.println(message);\n        System.out.flush();\n    }\n\n    public static final void printf(String format, Object ...args) {\n        System.out.printf(format, args);\n        System.out.flush();\n    }\n\n    public static final String repeat(String item, int n) {\n        StringBuilder buff = new StringBuilder();\n        for (int i = 0;i < n;i++) {\n            buff.append(item);\n        }\n        return buff.toString();\n    }\n\n    public static void printTable(JSONArray jsonArray) {\n        if (jsonArray.length() == 0) {\n            return;\n        }\n        JSONObject sample = jsonArray.getJSONObject(0);\n        if (sample.has(\"event\")) {// GroupBy\n            for (int i = 0;i < jsonArray.length();i++) {\n                JSONObject jsonItem = jsonArray.getJSONObject(i);\n                JSONObject event = jsonItem.getJSONObject(\"event\");\n                \n                // Print headers.\n                if (i == 0) {\n                    printf(\"%-10s  |\", \"timestamp\");\n                    for (Object key: event.keySet()) {\n                        printf(\"%-10s  |\", key);\n                    }\n                    newLine();\n                }\n                println(repeat(\"-\", (event.keySet().size() + 1) * 10));\n                // Print data.\n                printf(\"%-10s  |\", jsonItem.getString(\"timestamp\"));\n                for (Object key: event.keySet()) {\n                    printf(\"%-10s  |\", event.get(key.toString()));\n                }\n                newLine();\n            }\n        } else if (sample.has(\"result\")) {// Could be timeseries/topN\n            if (sample.optJSONObject(\"result\") != null) {// Timeseries\n                JSONObject sampleResult = sample.optJSONObject(\"result\");\n                // Print headers.\n                printf(\"%-10s  |\", \"timestamp\");\n                for (Object key: sampleResult.keySet()) {\n                    printf(\"%-10s  |\", key);\n                }\n                newLine();\n                println(repeat(\"-\", (sampleResult.keySet().size() + 1) * 10));\n                // Print data.\n                for (int i = 0;i < jsonArray.length();i++) {\n                    JSONObject jsonItem = jsonArray.getJSONObject(i);\n                    printf(\"%-10s  |\", jsonItem.getString(\"timestamp\"));\n                    JSONObject result = jsonItem.getJSONObject(\"result\");\n                    for (Object key: result.keySet()) {\n                        printf(\"%-10s  |\", result.get(key.toString()));\n                    }\n                    newLine();\n                }\n            } else if (sample.optJSONArray(\"result\") != null) {// TopN\n                // There should be only 1 item in here.\n                JSONObject jsonItem = jsonArray.getJSONObject(0);\n                \n                JSONArray result = jsonItem.getJSONArray(\"result\");\n                // Print headers.\n                printf(\"%-10s  |\", \"timestamp\");\n                if (result.length() == 0) {// Nothing to be printed\n                    return;\n                }\n                for (Object key: result.getJSONObject(0).keySet()) {\n                    printf(\"%-10s  |\", key);\n                }\n                newLine();\n                println(repeat(\"-\", (result.getJSONObject(0).keySet().size() + 1) * 10));\n                for (int j = 0;j < result.length();j++) {\n                    printf(\"%-10s  |\", jsonItem.getString(\"timestamp\"));\n                    JSONObject deepItem = result.getJSONObject(j);\n                    for (Object key: deepItem.keySet()) {\n                        printf(\"%-10s  |\", deepItem.get(key.toString()));\n                    }\n                    newLine();\n                }\n                newLine();\n            }\n        } \n    }\n    \n    public static void printTable(List<String> baseFieldNames, Map<Object, List<Object>> baseAllRows) {\n        for(String header:baseFieldNames) {\n            printf(\"%-10s  |\", header);\n        }\n        newLine();\n        for(List<Object> row:baseAllRows.values()) {\n            for (Object rowColValue:row) {\n                printf(\"%-10s  |\", rowColValue);\n            }\n            newLine();\n        }\n    }\n\n    public static void printTable(List<String> baseFieldNames, List<List<Object>> baseAllRows) {\n        for(String header:baseFieldNames) {\n            printf(\"%-10s  |\", header);\n        }\n        newLine();\n        for(List<Object> row:baseAllRows) {\n            for (Object rowColValue:row) {\n                printf(\"%-10s  |\", rowColValue);\n            }\n            newLine();\n        }\n    }\n\n    public static <T extends DruidBaseBean> void printTable(List<T> baseAllRows) {\n        if (baseAllRows == null || baseAllRows.isEmpty()) {\n            return;\n        }\n        List<Method> setters = getAllSetters(baseAllRows.get(0).getClass());\n        for(Method setter:setters) {\n            printf(\"%-10s  |\", setter.getName().substring(3));\n        }\n        newLine();\n        List<Method> getters = getAllGetters(baseAllRows.get(0).getClass());\n        for(T row:baseAllRows) {\n            for(Method getter:getters) {\n                try {\n                    printf(\"%-10s  |\", getter.invoke(row));\n                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\n                    Logger.getLogger(Util.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n            newLine();\n        }\n    }\n    \n    public static List<Method> getAllSetters(Class<?> clazz) {\n        Method[] allMethods = clazz.getMethods();\n        List<Method> setters = new ArrayList<>();\n        for(Method method : allMethods) {\n            if(method.getName().startsWith(\"set\")) {\n                setters.add(method);\n            }\n        }    \n        return setters;\n    }\n\n    public static List<Method> getAllGetters(Class<?> clazz) {\n        Method[] allMethods = clazz.getMethods();\n        List<Method> getters = new ArrayList<>();\n        for(Method method : allMethods) {\n            if(method.getName().startsWith(\"get\") && !method.getName().equals(\"getClass\")) {\n                getters.add(method);\n            }\n        }    \n        return getters;\n    }\n    \n    public static String getterMethodName(String key) {\n        return \"get\" + capitalize(key);\n    }\n\n    public static String setterMethodName(String key) {\n        return \"set\" + capitalize(key);\n    }\n\n    public static String capitalize(String word) {\n        StringBuilder buff = new StringBuilder(word);\n        if (word.charAt(0) != '_') {\n            buff.setCharAt(0, Character.toUpperCase(word.charAt(0)));\n        }\n        for (int i = 1; i < buff.length(); i++) {\n            if (buff.charAt(i - 1) == '_') {\n                buff.setCharAt(i, Character.toUpperCase(word.charAt(i)));\n            }\n        }\n        return buff.toString().replace(\"_\", \"\");\n    }\n\n    public static Either<JSONArray, JSONObject> asJsonType(String str) throws JSONException {\n        JSONArray possibleResArray = null;\n        try {\n            possibleResArray = new JSONArray(str);\n            return new Left<>(possibleResArray);\n        } catch (JSONException je) {\n            JSONObject possibleResObj = new JSONObject(str);\n            return new Right<>(possibleResObj);\n        }\n    }    \n    \n    /**\n     * More granular(sets the property of a bean based on a key value).\n     *\n     * @param bean\n     * @param key\n     * @param value\n     * @throws NoSuchMethodException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws InvocationTargetException\n     */\n    public static void applyKVToBean(Object bean, String key, Object value) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        Method getterMethod = bean.getClass().getMethod(Util.getterMethodName(key));\n        Method setterMethod = bean.getClass().getMethod(Util.setterMethodName(key), getterMethod.getReturnType());\n        setterMethod.invoke(bean, value);\n    }\n    \n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/drop/DropMeta.java\npublic class DropMeta extends CrudStatementMeta {\n\n    public String id;// UUid\n    public Interval interval = null;// This should be filled with time boundary at runtime.\n    public List<String> dimensions = new ArrayList<>();// This will be determined at runtime.\n    public List<String> metrics = new ArrayList<>();// This will be determined at runtime.\n\n    public DropMeta() {\n    }\n\n    public DropMeta(String dataSource, Interval interval) {\n        super(dataSource);\n        this.interval = interval;\n    }\n\n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n\n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n\n    @Override\n    public Map<String, Object> getDataMap() {\n        // For each instance of data generation generate a new id.\n        id = String.format(\"kill_%s_%s_%s_%s\", dataSource, interval.getStartTime(), interval.getEndTime(), new DateTime().toString());\n        Map<String, Object> map = super.getDataMap();\n        map.put(\"type\", \"kill\");\n        map.put(\"dataSource\", dataSource);\n        map.put(\"interval\", interval.toString());\n        map.put(\"id\", id);\n        return map;\n    }\n\n\n    public <T> void postProcess(T anyContext) {\n\n    }\n}\n", "answers": ["            } else if (stmnt instanceof InsertMeta) {//TODO: Handle this."], "length": 4029, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "53794171ac56dbe5880c3fda119232cddf8f02c7b91371d3"}
{"input": "import datetime\nimport random\nfrom fints.exceptions import FinTSError\nfrom .formals import (\n    AlgorithmParameterIVName, AlgorithmParameterName, CompressionFunction,\n    DateTimeType, EncryptionAlgorithm, EncryptionAlgorithmCoded,\n    HashAlgorithm, IdentifiedRole, KeyName, KeyType, OperationMode,\n    SecurityApplicationArea, SecurityDateTime,\n    SecurityIdentificationDetails, SecurityMethod, SecurityProfile,\n    SecurityRole, SignatureAlgorithm, UsageEncryption, UserDefinedSignature,\n)\nfrom .message import FinTSMessage\nfrom .segments.message import HNSHA2, HNSHK4, HNVSD1, HNVSK3\nfrom .types import SegmentSequence\n\n\n\nclass EncryptionMechanism:\n    def encrypt(self, message: FinTSMessage):\n        raise NotImplemented()\n\n    def decrypt(self, message: FinTSMessage):\n        raise NotImplemented()\n\n\nclass AuthenticationMechanism:\n    def sign_prepare(self, message: FinTSMessage):\n        raise NotImplemented()\n    \n    def sign_commit(self, message: FinTSMessage):\n        raise NotImplemented()\n    \n    def verify(self, message: FinTSMessage):\n        raise NotImplemented()\n\n\nclass PinTanDummyEncryptionMechanism(EncryptionMechanism):\n    def __init__(self, security_method_version=1):\n        super().__init__()\n        self.security_method_version = security_method_version\n\n    def encrypt(self, message: FinTSMessage):\n        assert message.segments[0].header.type == 'HNHBK'\n        assert message.segments[-1].header.type == 'HNHBS'\n\n        plain_segments = message.segments[1:-1]\n        del message.segments[1:-1]\n\n        _now = datetime.datetime.now()\n\n        message.segments.insert(\n            1,\n            HNVSK3(\n                security_profile=SecurityProfile(SecurityMethod.PIN, self.security_method_version),\n                security_function='998',\n                security_role=SecurityRole.ISS,\n                security_identification_details=SecurityIdentificationDetails(\n                    IdentifiedRole.MS,\n                    identifier=message.dialog.client.system_id,\n                ),\n                security_datetime=SecurityDateTime(\n                    DateTimeType.STS,\n                    _now.date(),\n                    _now.time(),\n                ),\n                encryption_algorithm=EncryptionAlgorithm(\n", "context": "fints/formals.py\nclass KeyName(DataElementGroup):\n    bank_identifier = DataElementGroupField(type=BankIdentifier)\n    user_id = DataElementField(type='id')\n    key_type = CodeField(KeyType, length=1, _d=\"Schlüsselart\")\n    key_number = DataElementField(type='num', max_length=3)\n    key_version = DataElementField(type='num', max_length=3)\nfints/formals.py\nclass SecurityDateTime(DataElementGroup):\n    date_time_type = CodeField(DateTimeType, max_length=3)\n    date = DataElementField(type='dat', required=False)\n    time = DataElementField(type='tim', required=False)\nfints/message.py\nclass FinTSMessage(SegmentSequence):\n    DIRECTION = None\n    # Auto-Numbering, dialog relation, security base\n\n    def __init__(self, dialog=None, *args, **kwargs):\n        self.dialog = dialog\n        self.next_segment_number = 1\n        super().__init__(*args, **kwargs)\n\n    def __iadd__(self, segment: FinTS3Segment):\n        if not isinstance(segment, FinTS3Segment):\n            raise TypeError(\"Can only append FinTS3Segment instances, not {!r}\".format(segment))\n        segment.header.number = self.next_segment_number\n        self.next_segment_number += 1\n        self.segments.append(segment)\n        return self\n\n    def response_segments(self, ref, *args, **kwargs):\n        for segment in self.find_segments(*args, **kwargs):\n            if segment.header.reference == ref.header.number:\n                yield segment\n\n    def responses(self, ref, code=None):\n        for segment in self.response_segments(ref, HIRMS2):\n            for response in segment.responses:\n                if code is None or response.code == code:\n                    yield response\nfints/formals.py\nclass OperationMode(RepresentableEnum):\n    CBC = '2'  #: Cipher Block Chaining\n    ISO_9796_1 = '16'  #: ISO 9796-1 (bei RDH)\n    ISO_9796_2_RANDOM = '17'  #: ISO 9796-2 mit Zufallszahl (bei RDH)\n    PKCS1V15 = '18'  #: RSASSA-PKCS#1 V1.5 (bei RDH); RSAES-PKCS#1 V1.5 (bei RAH, RDH)\n    PSS = '19'  #: RSASSA-PSS (bei RAH, RDH)\n    ZZZ = '999'  #: Gegenseitig vereinbart (DDV: Retail-MAC)\nfints/formals.py\nclass AlgorithmParameterIVName(RepresentableEnum):\n    IVC = '1' #: Initialization value, clear text\nfints/formals.py\nclass AlgorithmParameterName(RepresentableEnum):\n    KYE = '5' #: Symmetrischer Schlüssel, verschlüsselt mit symmetrischem Schlüssel\n    KYP = '6' #: Symmetrischer Schlüssel, verschlüsselt mit öffentlichem Schlüssel\nfints/types.py\nclass SegmentSequence:\n    \"\"\"A sequence of FinTS3Segment objects\"\"\"\n\n    def __init__(self, segments=None):\n        if isinstance(segments, bytes):\n            from .parser import FinTS3Parser\n            parser = FinTS3Parser()\n            data = parser.explode_segments(segments)\n            segments = [parser.parse_segment(segment) for segment in data]\n        self.segments = list(segments) if segments else []\n\n    def render_bytes(self) -> bytes:\n        from .parser import FinTS3Serializer\n        return FinTS3Serializer().serialize_message(self)\n\n    def __repr__(self):\n        return \"{}.{}({!r})\".format(self.__class__.__module__, self.__class__.__name__, self.segments)\n\n    def print_nested(self, stream=None, level=0, indent=\"    \", prefix=\"\", first_level_indent=True, trailer=\"\", print_doc=True, first_line_suffix=\"\"):\n        import sys\n        stream = stream or sys.stdout\n        stream.write(\n            ((prefix + level * indent) if first_level_indent else \"\")\n            + \"{}.{}([\".format(self.__class__.__module__, self.__class__.__name__)\n            + first_line_suffix\n            + \"\\n\"\n        )\n        for segment in self.segments:\n            docstring = print_doc and segment.__doc__\n            if docstring:\n                docstring = docstring.splitlines()[0].strip()\n            if docstring:\n                docstring = \" # {}\".format(docstring)\n            else:\n                docstring = \"\"\n            segment.print_nested(stream=stream, level=level + 1, indent=indent, prefix=prefix, first_level_indent=True, trailer=\",\", print_doc=print_doc,\n                                 first_line_suffix=docstring)\n        stream.write((prefix + level * indent) + \"]){}\\n\".format(trailer))\n\n    def find_segments(self, query=None, version=None, callback=None, recurse=True, throw=False):\n        \"\"\"Yields an iterable of all matching segments.\n\n        :param query: Either a str or class specifying a segment type (such as 'HNHBK', or :class:`~fints.segments.message.HNHBK3`), or a list or tuple of strings or classes.\n                     If a list/tuple is specified, segments returning any matching type will be returned.\n        :param version: Either an int specifying a segment version, or a list or tuple of ints.\n                        If a list/tuple is specified, segments returning any matching version will be returned.\n        :param callback: A callable that will be given the segment as its sole argument and must return a boolean indicating whether to return this segment.\n        :param recurse: If True (the default), recurse into SegmentSequenceField values, otherwise only look at segments in this SegmentSequence.\n        :param throw: If True, a FinTSNoResponseError is thrown if no result is found. Defaults to False.\n\n        The match results of all given parameters will be AND-combined.\n        \"\"\"\n        found_something = False\n\n        if query is None:\n            query = []\n        elif isinstance(query, str) or not isinstance(query, (list, tuple, Iterable)):\n            query = [query]\n\n        if version is None:\n            version = []\n        elif not isinstance(version, (list, tuple, Iterable)):\n            version = [version]\n\n        if callback is None:\n            callback = lambda s: True\n\n        for s in self.segments:\n            if ((not query) or any((isinstance(s, t) if isinstance(t, type) else s.header.type == t) for t in query)) and \\\n                    ((not version) or any(s.header.version == v for v in version)) and \\\n                    callback(s):\n                yield s\n                found_something = True\n\n            if recurse:\n                for name, field in s._fields.items():\n                    val = getattr(s, name)\n                    if val and hasattr(val, 'find_segments'):\n                        for v in val.find_segments(query=query, version=version, callback=callback, recurse=recurse):\n                            yield v\n                            found_something = True\n\n        if throw and not found_something:\n            raise FinTSNoResponseError(\n                'The bank\\'s response did not contain a response to your request, please inspect debug log.'\n            )\n\n    def find_segment_first(self, *args, **kwargs):\n        \"\"\"Finds the first matching segment.\n\n        Same parameters as find_segments(), but only returns the first match, or None if no match is found.\"\"\"\n\n        for m in self.find_segments(*args, **kwargs):\n            return m\n\n        return None\n\n    def find_segment_highest_version(self, query=None, version=None, callback=None, recurse=True, default=None):\n        \"\"\"Finds the highest matching segment.\n\n        Same parameters as find_segments(), but returns the match with the highest version, or default if no match is found.\"\"\"\n        # FIXME Test\n\n        retval = None\n\n        for s in self.find_segments(query=query, version=version, callback=callback, recurse=recurse):\n            if not retval or s.header.version > retval.header.version:\n                retval = s\n\n        if retval is None:\n            return default\n\n        return retval\nfints/formals.py\nclass SecurityProfile(DataElementGroup):\n    \"\"\"Sicherheitsprofil\"\"\"\n    security_method = CodeField(enum=SecurityMethod, length=3, _d=\"Sicherheitsverfahren\")\n    security_method_version = DataElementField(type='num', _d=\"Version des Sicherheitsverfahrens\")\nfints/formals.py\nclass SecurityMethod(RepresentableEnum):\n    DDV = 'DDV'\n    RAH = 'RAH'\n    RDH = 'RDH'\n    PIN = 'PIN'\nfints/segments/message.py\nclass HNSHA2(FinTS3Segment):\n    \"\"\"Signaturabschluss, version 2\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    security_reference = DataElementField(type='an', max_length=14, _d=\"Sicherheitskontrollreferenz\")\n    validation_result = DataElementField(type='bin', max_length=512, required=False, _d=\"Validierungsresultat\")\n    user_defined_signature = DataElementGroupField(type=UserDefinedSignature, required=False, _d=\"Benutzerdefinierte Signatur\")\nfints/formals.py\nclass KeyType(RepresentableEnum):\n    \"\"\"Schlüsselart\"\"\"\n    D = 'D'  #: Schlüssel zur Erzeugung digitaler Signaturen\n    S = 'S'  #: Signierschlüssel\n    V = 'V'  #: Chiffrierschlüssel\nfints/formals.py\nclass CompressionFunction(RepresentableEnum):\n    \"\"\"Komprimierungsfunktion, version 2\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    NULL = '0'  #: Keine Kompression\n    LZW = '1'  #: Lempel, Ziv, Welch\n    COM = '2'  #: Optimized LZW\n    LZSS = '3'  #: Lempel, Ziv\n    LZHuf = '4'  #: LZ + Huffman Coding\n    ZIP = '5'  #: PKZIP\n    GZIP = '6'  #: deflate (http://www.gzip.org/zlib)\n    BZIP2 = '7'  #: bzip2 (http://sourceware.cygnus.com/bzip2/)\n    ZZZ = '999'  #: Gegenseitig vereinbart\nfints/formals.py\nclass SecurityIdentificationDetails(DataElementGroup):\n    identified_role = CodeField(IdentifiedRole, max_length=3)\n    cid = DataElementField(type='bin', max_length=256)\n    identifier = DataElementField(type='id')\nfints/segments/message.py\nclass HNSHK4(FinTS3Segment):\n    \"\"\"Signaturkopf, version 4\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    security_profile = DataElementGroupField(type=SecurityProfile, _d=\"Sicherheitsprofil\")\n    security_function = DataElementField(type='code', max_length=3, _d=\"Sicherheitsfunktion, kodiert\")\n    security_reference = DataElementField(type='an', max_length=14, _d=\"Sicherheitskontrollreferenz\")\n    security_application_area = CodeField(SecurityApplicationArea, max_length=3, _d=\"Bereich der Sicherheitsapplikation, kodiert\")\n    security_role = CodeField(SecurityRole, max_length=3, _d=\"Rolle des Sicherheitslieferanten, kodiert\")\n    security_identification_details = DataElementGroupField(type=SecurityIdentificationDetails, _d=\"Sicherheitsidentifikation, Details\")\n    security_reference_number = DataElementField(type='num', max_length=16, _d=\"Sicherheitsreferenznummer\")\n    security_datetime = DataElementGroupField(type=SecurityDateTime, _d=\"Sicherheitsdatum und -uhrzeit\")\n    hash_algorithm = DataElementGroupField(type=HashAlgorithm, _d=\"Hashalgorithmus\")\n    signature_algorithm = DataElementGroupField(type=SignatureAlgorithm, _d=\"Signaturalgorithmus\")\n    key_name = DataElementGroupField(type=KeyName, _d=\"Schlüsselname\")\n    certificate = DataElementGroupField(type=Certificate, required=False, _d=\"Zertifikat\")\nfints/formals.py\nclass SecurityApplicationArea(RepresentableEnum):\n    \"\"\"Bereich der Sicherheitsapplikation, kodiert, version 2\n\n    Informationen darüber, welche Daten vom kryptographischen Prozess verarbeitet werden.\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    SHM = '1'  #: Signaturkopf und HBCI-Nutzdaten\n    SHT = '2'  #: Von Signaturkopf bis Signaturabschluss\nfints/formals.py\nclass IdentifiedRole(RepresentableEnum):\n    MS = '1' #: Message Sender\n    MR = '2' #: Message Receiver\nfints/segments/message.py\nclass HNVSD1(FinTS3Segment):\n    \"\"\"Verschlüsselte Daten, version 1\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    data = SegmentSequenceField(_d=\"Daten, verschlüsselt\")\nfints/formals.py\nclass EncryptionAlgorithmCoded(RepresentableEnum):\n    TWOKEY3DES = '13' #: 2-Key-Triple-DES\n    AES256 = '14' #: AES-256\nfints/formals.py\nclass UserDefinedSignature(DataElementGroup):\n    pin = PasswordField(max_length=99)\n    tan = DataElementField(type='an', max_length=99, required=False)\nfints/formals.py\nclass UsageEncryption(RepresentableEnum):\n    OSY = '2'  #: Owner Symmetric\nfints/formals.py\nclass HashAlgorithm(DataElementGroup):\n    usage_hash = DataElementField(type='code', max_length=3)\n    hash_algorithm = DataElementField(type='code', max_length=3)\n    algorithm_parameter_name = DataElementField(type='code', max_length=3)\n    algorithm_parameter_value = DataElementField(type='bin', max_length=512, required=False)\nfints/exceptions.py\nclass FinTSError(Exception):\n    pass\nfints/formals.py\nclass EncryptionAlgorithm(DataElementGroup):\n    usage_encryption = CodeField(UsageEncryption, max_length=3)\n    operation_mode = CodeField(OperationMode, max_length=3)\n    encryption_algorithm = CodeField(EncryptionAlgorithmCoded, max_length=3)\n    algorithm_parameter_value = DataElementField(type='bin', max_length=512)\n    algorithm_parameter_name = CodeField(AlgorithmParameterName, max_length=3)\n    algorithm_parameter_iv_name = CodeField(AlgorithmParameterIVName, max_length=3)\n    algorithm_parameter_iv_value = DataElementField(type='bin', max_length=512, required=False)\nfints/formals.py\nclass SignatureAlgorithm(DataElementGroup):\n    usage_signature = DataElementField(type='code', max_length=3)\n    signature_algorithm = DataElementField(type='code', max_length=3)\n    operation_mode = DataElementField(type='code', max_length=3)\nfints/formals.py\nclass SecurityRole(RepresentableEnum):\n    \"\"\"Rolle des Sicherheitslieferanten, kodiert, version 2\n\n    Kodierte Information über das Verhältnis desjenigen, der bezüglich der zu si-chernden Nachricht die Sicherheit gewährleistet.\n    Die Wahl ist von der bankfachlichen Auslegung der Signatur, respektive vom vertraglichen Zustand zwischen Kunde und Kreditinstitut abhängig.\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    ISS = '1'  #: Erfasser, Erstsignatur\n    CON = '3'  #: Unterstützer, Zweitsignatur\n    WIT = '4'  #: Zeuge/Übermittler, nicht Erfasser\nfints/segments/message.py\nclass HNVSK3(FinTS3Segment):\n    \"\"\"Verschlüsselungskopf, version 3\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    security_profile = DataElementGroupField(type=SecurityProfile, _d=\"Sicherheitsprofil\")\n    security_function = DataElementField(type='code', max_length=3, _d=\"Sicherheitsfunktion, kodiert\")\n    security_role = CodeField(SecurityRole, max_length=3, _d=\"Rolle des Sicherheitslieferanten, kodiert\")\n    security_identification_details = DataElementGroupField(type=SecurityIdentificationDetails, _d=\"Sicherheitsidentifikation, Details\")\n    security_datetime = DataElementGroupField(type=SecurityDateTime, _d=\"Sicherheitsdatum und -uhrzeit\")\n    encryption_algorithm = DataElementGroupField(type=EncryptionAlgorithm, _d=\"Verschlüsselungsalgorithmus\")\n    key_name = DataElementGroupField(type=KeyName, _d=\"Schlüsselname\")\n    compression_function = CodeField(CompressionFunction, max_length=3, _d=\"Komprimierungsfunktion\")\n    certificate = DataElementGroupField(type=Certificate, required=False, _d=\"Zertifikat\")\nfints/formals.py\nclass DateTimeType(RepresentableEnum):\n    STS = '1'  #: Sicherheitszeitstempel\n    CRT = '6'  #: Certificate Revocation Time\n", "answers": ["                    UsageEncryption.OSY,"], "length": 1428, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "1aba661e70d8c4cb3564a8a855d5aa403bc1b6580abaa9a6"}
{"input": "import static org.joni.BitStatus.bsAll;\nimport static org.joni.BitStatus.bsAt;\nimport static org.joni.BitStatus.bsClear;\nimport static org.joni.BitStatus.bsOnAt;\nimport static org.joni.BitStatus.bsOnAtSimple;\nimport static org.joni.Option.isCaptureGroup;\nimport static org.joni.Option.isFindCondition;\nimport static org.joni.Option.isIgnoreCase;\nimport static org.joni.Option.isMultiline;\nimport static org.joni.ast.ListNode.newAlt;\nimport static org.joni.ast.ListNode.newList;\nimport static org.joni.ast.QuantifierNode.isRepeatInfinite;\nimport java.util.IllegalFormatConversionException;\nimport org.jcodings.CaseFoldCodeItem;\nimport org.jcodings.ObjPtr;\nimport org.jcodings.Ptr;\nimport org.jcodings.constants.CharacterType;\nimport org.joni.ast.AnchorNode;\nimport org.joni.ast.BackRefNode;\nimport org.joni.ast.CClassNode;\nimport org.joni.ast.CTypeNode;\nimport org.joni.ast.CallNode;\nimport org.joni.ast.EncloseNode;\nimport org.joni.ast.ListNode;\nimport org.joni.ast.Node;\nimport org.joni.ast.QuantifierNode;\nimport org.joni.ast.StringNode;\nimport org.joni.constants.internal.AnchorType;\nimport org.joni.constants.internal.EncloseType;\nimport org.joni.constants.internal.NodeType;\nimport org.joni.constants.internal.StackPopLevel;\nimport org.joni.constants.internal.TargetInfo;\n/*\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage org.joni;\n\n\n\n\nfinal class Analyser extends Parser {\n\n    protected Analyser(Regex regex, Syntax syntax, byte[]bytes, int p, int end, WarnCallback warnings) {\n        super(regex, syntax, bytes, p, end, warnings);\n    }\n\n    protected final void compile() {\n        if (Config.DEBUG) Config.log.println(encStringToString(bytes, getBegin(), getEnd()));\n        reset();\n\n        regex.numMem = 0;\n        regex.numRepeat = 0;\n        regex.numNullCheck = 0;\n        //regex.repeatRangeAlloc = 0;\n        regex.repeatRangeLo = null;\n        regex.repeatRangeHi = null;\n        regex.numCombExpCheck = 0;\n\n        if (Config.USE_CEC) regex.numCombExpCheck = 0;\n\n\n        Node root = parseRegexp(); // onig_parse_make_tree\n        regex.numMem = env.numMem;\n\n        if (Config.USE_NAMED_GROUP) {\n            /* mixed use named group and no-named group */\n            if (env.numNamed > 0 && syntax.captureOnlyNamedGroup() && !isCaptureGroup(regex.options)) {\n                if (env.numNamed != env.numMem) {\n                    root = disableNoNameGroupCapture(root);\n                } else {\n                    numberedRefCheck(root);\n                }\n            }\n        } // USE_NAMED_GROUP\n\n        if (Config.USE_NAMED_GROUP) {\n            if (env.numCall > 0) {\n                env.unsetAddrList = new UnsetAddrList(env.numCall);\n                setupSubExpCall(root);\n                // r != 0 ???\n                subexpRecursiveCheckTrav(root);\n                // r < 0 -< err, FOUND_CALLED_NODE = 1\n                subexpInfRecursiveCheckTrav(root);\n                // r != 0  recursion infinite ???\n                regex.numCall = env.numCall;\n            } else {\n                regex.numCall = 0;\n            }\n        } // USE_NAMED_GROUP\n\n        if (Config.DEBUG_PARSE_TREE && Config.DEBUG_PARSE_TREE_RAW) Config.log.println(\"<RAW TREE>\\n\" + root + \"\\n\");\n\n        Node.TopNode top = Node.newTop(root);\n        setupTree(root, 0);\n        root = top.getRoot();\n\n        if (Config.DEBUG_PARSE_TREE) Config.log.println(\"<TREE>\\n\" + root + \"\\n\");\n\n        regex.captureHistory = env.captureHistory;\n        regex.btMemStart = env.btMemStart;\n\n        if (isFindCondition(regex.options)) {\n            regex.btMemEnd = bsAll();\n        } else {\n            regex.btMemEnd = env.btMemEnd;\n            regex.btMemEnd |= regex.captureHistory;\n        }\n\n        if (Config.USE_CEC) {\n            if (env.backrefedMem == 0 || (Config.USE_SUBEXP_CALL && env.numCall == 0)) {\n                setupCombExpCheck(root, 0);\n\n                if (Config.USE_SUBEXP_CALL && env.hasRecursion) {\n                    env.numCombExpCheck = 0;\n                } else { // USE_SUBEXP_CALL\n                    if (env.combExpMaxRegNum > 0) {\n                        for (int i=1; i<env.combExpMaxRegNum; i++) {", "context": "src/org/joni/Option.java\npublic static boolean isIgnoreCase(int option) {\n    return (option & IGNORECASE) != 0;\n}\nsrc/org/joni/ast/CTypeNode.java\npublic final class CTypeNode extends Node {\n    public final int ctype;\n    public final boolean not;\n    public final boolean asciiRange;\n\n    public CTypeNode(int type, boolean not, boolean asciiRange) {\n        super(CTYPE);\n        this.ctype= type;\n        this.not = not;\n        this.asciiRange = asciiRange;\n    }\n\n    @Override\n    public String getName() {\n        return \"Character Type\";\n    }\n\n    @Override\n    public String toString(int level) {\n        StringBuilder value = new StringBuilder();\n        value.append(\"\\n  ctype: \" + ctype);\n        value.append(\", not: \" + not);\n        value.append(\", ascii: \" + asciiRange);\n        return value.toString();\n    }\n\n}\nsrc/org/joni/BitStatus.java\npublic static int bsOnAt(int stats, int n) {\n    if (n < BIT_STATUS_BITS_NUM) {\n        stats |= (1 << n);\n    } else {\n        stats |= 1;\n    }\n    return stats;\n}\nsrc/org/joni/ast/Node.java\npublic abstract class Node implements NodeType {\n    public Node parent;\n    protected int type;\n\n    Node(int type) {\n        this.type = type;\n    }\n\n    public final int getType() {\n        return type;\n    }\n\n    public final int getType2Bit() {\n        return 1 << getType();\n    }\n\n    protected void setChild(Node tgt){\n        // default definition\n    }\n\n    protected Node getChild(){\n        // default definition\n        return null;\n    };\n\n    public void replaceWith(Node with) {\n        with.parent = parent;\n        parent.setChild(with);\n        parent = null;\n    }\n\n    public abstract String getName();\n    protected abstract String toString(int level);\n\n    public String getAddressName() {\n        return getName() + \":0x\" + Integer.toHexString(System.identityHashCode(this));\n    }\n\n    public final String toString() {\n        StringBuilder s = new StringBuilder();\n        s.append(\"<\" + getAddressName() + \" (\" + (parent == null ? \"NULL\" : parent.getAddressName())  + \")>\");\n        return s + toString(0);\n    }\n\n    protected static String pad(Object value, int level) {\n        if (value == null) return \"NULL\";\n\n        StringBuilder pad = new StringBuilder(\"  \");\n        for (int i=0; i<level; i++) pad.append(pad);\n\n        return value.toString().replace(\"\\n\",  \"\\n\" + pad);\n    }\n\n    public final boolean isSimple() {\n        return (getType2Bit() & SIMPLE) != 0;\n    }\n\n    public static TopNode newTop(Node root) {\n        return new TopNode(root);\n    }\n\n    public static final class TopNode extends Node {\n        private Node root;\n\n        TopNode(Node root) {\n            super(-1);\n            root.parent = this;\n            setChild(root);\n        }\n\n        public Node getRoot() {\n            return root;\n        }\n\n        @Override\n        public void setChild(Node node) {\n            node.parent = this;\n            root = node;\n        }\n\n        @Override\n        public Node getChild() {\n            return root;\n        }\n\n        @Override\n        public String getName() {\n            return \"ROOT\";\n        }\n\n        @Override\n        public String toString(int level) {\n            return \"\\n\" + pad(root, level + 1);\n        }\n    }\n}\nsrc/org/joni/ast/QuantifierNode.java\npublic static boolean isRepeatInfinite(int n) {\n    return n == REPEAT_INFINITE;\n}\nsrc/org/joni/constants/internal/EncloseType.java\npublic interface EncloseType {\n    final int MEMORY                = 1<<0;\n    final int OPTION                = 1<<1;\n    final int STOP_BACKTRACK        = 1<<2;\n    final int CONDITION             = 1<<3;\n    final int ABSENT                = 1<<4;\n\n    final int ALLOWED_IN_LB         = MEMORY | OPTION;\n    final int ALLOWED_IN_LB_NOT     = OPTION;\n}\nsrc/org/joni/BitStatus.java\npublic static int bsClear() {\n    return 0;\n}\nsrc/org/joni/ast/AnchorNode.java\npublic final class AnchorNode extends Node {\n    public final int type;\n    public final boolean asciiRange;\n    public Node target;\n    public int charLength;\n\n    public AnchorNode(int type, boolean asciiRange) {\n        super(ANCHOR);\n        this.type = type;\n        charLength = -1;\n        this.asciiRange = asciiRange;\n    }\n\n    public AnchorNode(int type) {\n        this(type, false);\n    }\n\n    @Override\n    protected void setChild(Node child) {\n        target = child;\n    }\n\n    @Override\n    protected Node getChild() {\n        return target;\n    }\n\n    public void setTarget(Node tgt) {\n        target = tgt;\n        tgt.parent = this;\n    }\n\n    @Override\n    public String getName() {\n        return \"Anchor\";\n    }\n\n    @Override\n    public String toString(int level) {\n        StringBuilder value = new StringBuilder();\n        value.append(\"\\n  type: \" + typeToString());\n        value.append(\", ascii: \" + asciiRange);\n        value.append(\"\\n  target: \" + pad(target, level + 1));\n        return value.toString();\n    }\n\n    public String typeToString() {\n        StringBuilder type = new StringBuilder();\n        if (isType(AnchorType.BEGIN_BUF)) type.append(\"BEGIN_BUF \");\n        if (isType(AnchorType.BEGIN_LINE)) type.append(\"BEGIN_LINE \");\n        if (isType(AnchorType.BEGIN_POSITION)) type.append(\"BEGIN_POSITION \");\n        if (isType(AnchorType.END_BUF)) type.append(\"END_BUF \");\n        if (isType(AnchorType.SEMI_END_BUF)) type.append(\"SEMI_END_BUF \");\n        if (isType(AnchorType.END_LINE)) type.append(\"END_LINE \");\n        if (isType(AnchorType.WORD_BOUND)) type.append(\"WORD_BOUND \");\n        if (isType(AnchorType.NOT_WORD_BOUND)) type.append(\"NOT_WORD_BOUND \");\n        if (isType(AnchorType.WORD_BEGIN)) type.append(\"WORD_BEGIN \");\n        if (isType(AnchorType.WORD_END)) type.append(\"WORD_END \");\n        if (isType(AnchorType.PREC_READ)) type.append(\"PREC_READ \");\n        if (isType(AnchorType.PREC_READ_NOT)) type.append(\"PREC_READ_NOT \");\n        if (isType(AnchorType.LOOK_BEHIND)) type.append(\"LOOK_BEHIND \");\n        if (isType(AnchorType.LOOK_BEHIND_NOT)) type.append(\"LOOK_BEHIND_NOT \");\n        if (isType(AnchorType.ANYCHAR_STAR)) type.append(\"ANYCHAR_STAR \");\n        if (isType(AnchorType.ANYCHAR_STAR_ML)) type.append(\"ANYCHAR_STAR_ML \");\n        return type.toString();\n    }\n\n    private boolean isType(int type) {\n        return (this.type & type) != 0;\n    }\n\n}\nsrc/org/joni/ast/CallNode.java\npublic final class CallNode extends StateNode {\n    public final byte[]name;\n    public final int nameP;\n    public final int nameEnd;\n\n    public int groupNum;\n    public EncloseNode target;\n    public UnsetAddrList unsetAddrList;\n\n    public CallNode(byte[]name, int nameP, int nameEnd, int gnum) {\n        super(CALL);\n        this.name = name;\n        this.nameP = nameP;\n        this.nameEnd = nameEnd;\n        this.groupNum = gnum; /* call by number if gnum != 0 */\n    }\n\n    @Override\n    protected void setChild(Node newChild) {\n        target = (EncloseNode)newChild;\n    }\n\n    @Override\n    protected Node getChild() {\n        return target;\n    }\n\n    public void setTarget(EncloseNode tgt) {\n        target = tgt;\n        tgt.parent = this;\n    }\n\n    @Override\n    public String getName() {\n        return \"Call\";\n    }\n\n    @Override\n    public String toString(int level) {\n        StringBuilder value = new StringBuilder(super.toString(level));\n        value.append(\"\\n  name: \" + new String(name, nameP, nameEnd - nameP));\n        value.append(\", groupNum: \" + groupNum);\n        value.append(\"\\n  unsetAddrList: \" + pad(unsetAddrList, level + 1));\n        value.append(\"\\n  target: \" + pad(target.getAddressName(), level + 1));\n        return value.toString();\n    }\n\n}\nsrc/org/joni/constants/internal/AnchorType.java\npublic interface AnchorType {\n    final int BEGIN_BUF         = (1<<0);\n    final int BEGIN_LINE        = (1<<1);\n    final int BEGIN_POSITION    = (1<<2);\n    final int END_BUF           = (1<<3);\n    final int SEMI_END_BUF      = (1<<4);\n    final int END_LINE          = (1<<5);\n\n    final int WORD_BOUND        = (1<<6);\n    final int NOT_WORD_BOUND    = (1<<7);\n    final int WORD_BEGIN        = (1<<8);\n    final int WORD_END          = (1<<9);\n    final int PREC_READ         = (1<<10);\n    final int PREC_READ_NOT     = (1<<11);\n    final int LOOK_BEHIND       = (1<<12);\n    final int LOOK_BEHIND_NOT   = (1<<13);\n\n    final int ANYCHAR_STAR      = (1<<14);   /* \".*\" optimize info */\n    final int ANYCHAR_STAR_ML   = (1<<15);   /* \".*\" optimize info (multi-line) */\n\n    final int ANYCHAR_STAR_MASK = (ANYCHAR_STAR | ANYCHAR_STAR_ML);\n    final int END_BUF_MASK      = (END_BUF | SEMI_END_BUF);\n\n    final int KEEP              = (1<<16);\n\n    final int ALLOWED_IN_LB =     ( LOOK_BEHIND |\n                                    LOOK_BEHIND_NOT |\n                                    BEGIN_LINE |\n                                    END_LINE |\n                                    BEGIN_BUF |\n                                    BEGIN_POSITION |\n                                    KEEP |\n                                    WORD_BOUND |\n                                    NOT_WORD_BOUND |\n                                    WORD_BEGIN |\n                                    WORD_END );\n\n\n    final int ALLOWED_IN_LB_NOT = ( LOOK_BEHIND |\n                                    LOOK_BEHIND_NOT |\n                                    BEGIN_LINE |\n                                    END_LINE |\n                                    BEGIN_BUF |\n                                    BEGIN_POSITION |\n                                    KEEP |\n                                    WORD_BOUND |\n                                    NOT_WORD_BOUND |\n                                    WORD_BEGIN |\n                                    WORD_END );\n}\nsrc/org/joni/ast/BackRefNode.java\npublic final class BackRefNode extends StateNode {\n    public final int back[];\n    public int backNum;\n    public int nestLevel;\n\n    private BackRefNode(int backNum, int[]backRefs, boolean byName, ScanEnvironment env) {\n        super(BREF);\n        this.backNum = backNum;\n        if (byName) setNameRef();\n\n        for (int i=0; i<backNum; i++) {\n            if (backRefs[i] <= env.numMem && env.memNodes[backRefs[i]] == null) {\n                setRecursion(); /* /...(\\1).../ */\n                break;\n            }\n        }\n        back = backRefs;\n    }\n\n    public BackRefNode(int backNum, int[]backRefs, boolean byName, boolean existLevel, int nestLevel, ScanEnvironment env) {\n        this(backNum, backRefs, byName, env);\n\n        if (Config.USE_BACKREF_WITH_LEVEL && existLevel) {\n            setNestLevel();\n            this.nestLevel = nestLevel;\n        }\n    }\n\n    public void renumber(int[]map) {\n        if (!isNameRef()) throw new ValueException(ErrorMessages.NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED);\n\n        int oldNum = backNum;\n\n        int pos = 0;\n        for (int i=0; i<oldNum; i++) {\n            int n = map[back[i]];\n            if (n > 0) {\n                back[pos] = n;\n                pos++;\n            }\n        }\n        backNum = pos;\n    }\n\n    @Override\n    public String getName() {\n        return \"Back Ref\";\n    }\n\n    @Override\n    public String toString(int level) {\n        StringBuilder sb = new StringBuilder(super.toString(level));\n        sb.append(\"\\n  backNum: \" + backNum);\n        String backs = \"\";\n        for (int i=0; i<back.length; i++) backs += back[i] + \", \";\n        sb.append(\"\\n  back: \" + backs);\n        sb.append(\"\\n  nextLevel: \" + nestLevel);\n        return sb.toString();\n    }\n}\nsrc/org/joni/ast/ListNode.java\npublic final class ListNode extends Node {\n    public Node value;\n    public ListNode tail;\n\n    private ListNode(Node value, ListNode tail, int type) {\n        super(type);\n        this.value = value;\n        if (value != null) value.parent = this;\n        this.tail = tail;\n        if (tail != null) tail.parent = this;\n    }\n\n    public static ListNode newAlt(Node value, ListNode tail) {\n        return new ListNode(value, tail, ALT);\n    }\n\n    public static ListNode newList(Node value, ListNode tail) {\n        return new ListNode(value, tail, LIST);\n    }\n\n    public static ListNode listAdd(ListNode list, Node value) {\n        ListNode n = newList(value, null);\n        if (list != null) {\n            while (list.tail != null) list = list.tail;\n            list.setTail(n);\n        }\n        return n;\n    }\n\n    public void toListNode() {\n        type = LIST;\n    }\n\n    @Override\n    protected void setChild(Node child) {\n        value = child;\n    }\n\n    @Override\n    protected Node getChild() {\n        return value;\n    }\n\n    public void setValue(Node value) {\n        this.value = value;\n        value.parent = this;\n    }\n\n    public void setTail(ListNode tail) {\n        this.tail = tail;\n    }\n\n    @Override\n    public String getName() {\n        switch (type) {\n        case ALT:\n            return \"Alt\";\n        case LIST:\n            return \"List\";\n        default:\n            throw new InternalException(ErrorMessages.PARSER_BUG);\n        }\n    }\n\n    @Override\n    public String toString(int level) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"\\n  value: \" + pad(value, level + 1));\n        sb.append(\"\\n  tail: \" + (tail == null ? \"NULL\" : tail.toString()));\n        return sb.toString();\n    }\n}\nsrc/org/joni/Option.java\npublic static boolean isFindCondition(int option) {\n    return (option & (FIND_LONGEST | FIND_NOT_EMPTY)) != 0;\n}\nsrc/org/joni/constants/internal/StackPopLevel.java\npublic interface StackPopLevel {\n    final int FREE      = 0;\n    final int MEM_START = 1;\n    final int ALL       = 2;\n\n}\nsrc/org/joni/ast/ListNode.java\npublic static ListNode newList(Node value, ListNode tail) {\n    return new ListNode(value, tail, LIST);\n}\nsrc/org/joni/Option.java\npublic static boolean isMultiline(int option) {\n    return (option & MULTILINE) != 0;\n}\nsrc/org/joni/constants/internal/TargetInfo.java\npublic interface TargetInfo {\n    final int ISNOT_EMPTY   = 0;\n    final int IS_EMPTY      = 1;\n    final int IS_EMPTY_MEM  = 2;\n    final int IS_EMPTY_REC  = 3;\n}\nsrc/org/joni/ast/ListNode.java\npublic static ListNode newAlt(Node value, ListNode tail) {\n    return new ListNode(value, tail, ALT);\n}\nsrc/org/joni/constants/internal/NodeType.java\npublic interface NodeType {\n    /* node type */\n    final int  STR        = 0;\n    final int  CCLASS     = 1;\n    final int  CTYPE      = 2;\n    final int  CANY       = 3;\n    final int  BREF       = 4;\n    final int  QTFR       = 5;\n    final int  ENCLOSE    = 6;\n    final int  ANCHOR     = 7;\n    final int  LIST       = 8;\n    final int  ALT        = 9;\n    final int  CALL       = 10;\n\n    final int BIT_STR        = 1 << STR;\n    final int BIT_CCLASS     = 1 << CCLASS;\n    final int BIT_CTYPE      = 1 << CTYPE;\n    final int BIT_CANY       = 1 << CANY;\n    final int BIT_BREF       = 1 << BREF;\n    final int BIT_QTFR       = 1 << QTFR;\n    final int BIT_ENCLOSE    = 1 << ENCLOSE;\n    final int BIT_ANCHOR     = 1 << ANCHOR;\n    final int BIT_LIST       = 1 << LIST;\n    final int BIT_ALT        = 1 << ALT;\n    final int BIT_CALL       = 1 << CALL;\n\n    /* allowed node types in look-behind */\n    final int ALLOWED_IN_LB = ( BIT_LIST |\n                                BIT_ALT |\n                                BIT_STR |\n                                BIT_CCLASS |\n                                BIT_CTYPE |\n                                BIT_CANY |\n                                BIT_ANCHOR |\n                                BIT_ENCLOSE |\n                                BIT_QTFR |\n                                BIT_CALL );\n\n    final int SIMPLE =        ( BIT_STR |\n                                BIT_CCLASS |\n                                BIT_CTYPE |\n                                BIT_CANY |\n                                BIT_BREF);\n\n}\nsrc/org/joni/ast/QuantifierNode.java\npublic final class QuantifierNode extends StateNode {\n    public static final int REPEAT_INFINITE = -1;\n    public Node target;\n    public int lower;\n    public int upper;\n    public boolean greedy;\n\n    public int targetEmptyInfo;\n\n    public Node headExact;\n    public Node nextHeadExact;\n    public boolean isRefered;           /* include called node. don't eliminate even if {0} */\n\n    // USE_COMBINATION_EXPLOSION_CHECK\n    public int  combExpCheckNum;        /* 1,2,3...: check,  0: no check  */\n\n    public QuantifierNode(int lower, int upper, boolean byNumber) {\n        super(QTFR);\n        this.lower = lower;\n        this.upper = upper;\n        greedy = true;\n        targetEmptyInfo = TargetInfo.ISNOT_EMPTY;\n\n        if (byNumber) setByNumber();\n    }\n\n    @Override\n    protected void setChild(Node child) {\n        target = child;\n    }\n\n    @Override\n    protected Node getChild() {\n        return target;\n    }\n\n    public void setTarget(Node tgt) {\n        target = tgt;\n        tgt.parent = this;\n    }\n\n    @Override\n    public String getName() {\n        return \"Quantifier\";\n    }\n\n    @Override\n    public String toString(int level) {\n        StringBuilder value = new StringBuilder(super.toString(level));\n        value.append(\"\\n  lower: \" + lower);\n        value.append(\", upper: \" + upper);\n        value.append(\", greedy: \" + greedy);\n        value.append(\", isRefered: \" + isRefered);\n        value.append(\", targetEmptyInfo: \" + targetEmptyInfo);\n        value.append(\", combExpCheckNum: \" + combExpCheckNum);\n        value.append(\"\\n  headExact: \" + pad(headExact, level + 1));\n        value.append(\"\\n  nextHeadExact: \" + pad(nextHeadExact, level + 1));\n        value.append(\"\\n  target: \" + pad(target, level + 1));\n        return value.toString();\n    }\n\n    public boolean isAnyCharStar() {\n        return greedy && isRepeatInfinite(upper) && target.getType() == CANY;\n    }\n\n    /* ?:0, *:1, +:2, ??:3, *?:4, +?:5 */\n    protected int popularNum() {\n        if (greedy) {\n            if (lower == 0) {\n                if (upper == 1) return 0;\n                else if (isRepeatInfinite(upper)) return 1;\n            } else if (lower == 1) {\n                if (isRepeatInfinite(upper)) return 2;\n            }\n        } else {\n            if (lower == 0) {\n                if (upper == 1) return 3;\n                else if (isRepeatInfinite(upper)) return 4;\n            } else if (lower == 1) {\n                if (isRepeatInfinite(upper)) return 5;\n            }\n        }\n        return -1;\n    }\n\n    protected void copy(QuantifierNode other) {\n        state = other.state;\n        setTarget(other.target);\n        other.target = null;\n        lower = other.lower;\n        upper = other.upper;\n        greedy = other.greedy;\n        targetEmptyInfo = other.targetEmptyInfo;\n        headExact = other.headExact;\n        nextHeadExact = other.nextHeadExact;\n        isRefered = other.isRefered;\n        combExpCheckNum = other.combExpCheckNum;\n    }\n\n    static enum ReduceType {\n        ASIS,       /* as is */\n        DEL,        /* delete parent */\n        A,          /* to '*'    */\n        AQ,         /* to '*?'   */\n        QQ,         /* to '??'   */\n        P_QQ,       /* to '+)??' */\n    }\n\n    static final ReduceType[][]REDUCE_TABLE = {\n      {DEL,     A,      A,      QQ,     AQ,     ASIS}, /* '?'  */\n      {DEL,     DEL,    DEL,    P_QQ,   P_QQ,   DEL},  /* '*'  */\n      {A,       A,      DEL,    ASIS,   P_QQ,   DEL},  /* '+'  */\n      {DEL,     AQ,     AQ,     DEL,    AQ,     AQ},   /* '??' */\n      {DEL,     DEL,    DEL,    DEL,    DEL,    DEL},  /* '*?' */\n      {ASIS,    ASIS,   ASIS,   AQ,     AQ,     DEL}   /* '+?' */\n    };\n\n\n    public void reduceNestedQuantifier(QuantifierNode other) {\n        int pnum = popularNum();\n        int cnum = other.popularNum();\n\n        if (pnum < 0 || cnum < 0) return;\n\n        switch(REDUCE_TABLE[cnum][pnum]) {\n        case DEL:\n            // no need to set the parent here...\n            copy(other);\n            break;\n\n        case A:\n            setTarget(other.target);\n            lower = 0;\n            upper = REPEAT_INFINITE;\n            greedy = true;\n            break;\n\n        case AQ:\n            setTarget(other.target);\n            lower = 0;\n            upper = REPEAT_INFINITE;\n            greedy = false;\n            break;\n\n        case QQ:\n            setTarget(other.target);\n            lower = 0;\n            upper = 1;\n            greedy = false;\n            break;\n\n        case P_QQ:\n            setTarget(other);\n            lower = 0;\n            upper = 1;\n            greedy = false;\n            other.lower = 1;\n            other.upper = REPEAT_INFINITE;\n            other.greedy = true;\n            return;\n\n        case ASIS:\n            setTarget(other);\n            return;\n        }\n        // ??? remove the parent from target ???\n        other.target = null; // remove target from reduced quantifier\n    }\n\n    static final String PopularQStr[] = new String[] {\"?\", \"*\", \"+\", \"??\", \"*?\", \"+?\"};\n    static final String ReduceQStr[] = new String[] {\"\", \"\", \"*\", \"*?\", \"??\", \"+ and ??\", \"+? and ?\"};\n\n    public int setQuantifier(Node tgt, boolean group, ScanEnvironment env, byte[]bytes, int p, int end) {\n        if (lower == 1 && upper == 1) {\n            if (env.syntax.op3OptionECMAScript()) {\n                setTarget(tgt);\n            }\n            return 1;\n        }\n\n        switch(tgt.getType()) {\n\n        case STR:\n            if (!group) {\n                StringNode sn = (StringNode)tgt;\n                if (sn.canBeSplit(env.enc)) {\n                    StringNode n = sn.splitLastChar(env.enc);\n                    if (n != null) {\n                        setTarget(n);\n                        return 2;\n                    }\n                }\n            }\n            break;\n\n        case QTFR:\n            /* check redundant double repeat. */\n            /* verbose warn (?:.?)? etc... but not warn (.?)? etc... */\n            QuantifierNode qnt = (QuantifierNode)tgt;\n            int nestQNum = popularNum();\n            int targetQNum = qnt.popularNum();\n\n            if (Config.USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR) {\n                if (nestQNum >= 0 && targetQNum >= 0 && env.syntax.warnReduntantNestedRepeat()) {\n                    switch(REDUCE_TABLE[targetQNum][nestQNum]) {\n                    case ASIS:\n                        break;\n                    case DEL:\n                        env.warnings.warn(\"regular expression has redundant nested repeat operator \" + PopularQStr[targetQNum] + \" /\" + new String(bytes, p, end) + \"/\");\n                        break;\n                    default:\n                        env.warnings.warn(\"nested repeat operator '\" + PopularQStr[targetQNum] + \"' and '\" + PopularQStr[nestQNum] +\n                                \"' was replaced with '\" + ReduceQStr[REDUCE_TABLE[targetQNum][nestQNum].ordinal()] + \"' in regular expression \" + \"/\" + new String(bytes, p, end) + \"/\");\n                    }\n                }\n            } // USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR\n\n            if (targetQNum >= 0) {\n                if (nestQNum >= 0) {\n                    reduceNestedQuantifier(qnt);\n                    return 0;\n                } else if (targetQNum == 1 || targetQNum == 2) { /* * or + */\n                    /* (?:a*){n,m}, (?:a+){n,m} => (?:a*){n,n}, (?:a+){n,n} */\n                    if (!isRepeatInfinite(upper) && upper > 1 && greedy) {\n                        upper = lower == 0 ? 1 : lower;\n                    }\n                }\n            }\n\n        default:\n            break;\n        }\n\n        setTarget(tgt);\n        return 0;\n    }\n\n    public static boolean isRepeatInfinite(int n) {\n        return n == REPEAT_INFINITE;\n    }\n}\nsrc/org/joni/ast/StringNode.java\npublic final class StringNode extends Node implements StringType {\n    private static final int NODE_STR_MARGIN = 16;\n    private static final int NODE_STR_BUF_SIZE = 24;\n    public static final StringNode EMPTY = new StringNode(null, Integer.MAX_VALUE, Integer.MAX_VALUE);\n\n    public byte[]bytes;\n    public int p;\n    public int end;\n    public int flag;\n\n    public StringNode(int size) {\n        super(STR);\n        this.bytes = new byte[size];\n    }\n\n    public StringNode() {\n        this(NODE_STR_BUF_SIZE);\n    }\n\n    public static StringNode fromCodePoint(int code, Encoding enc) {\n        StringNode str = new StringNode(Config.ENC_CODE_TO_MBC_MAXLEN);\n        str.end = enc.codeToMbc(code, str.bytes, str.p);\n        return str;\n    }\n\n    public StringNode(byte[]bytes, int p, int end) {\n        super(STR);\n        this.bytes = bytes;\n        this.p = p;\n        this.end = end;\n        setShared();\n    }\n\n    /* Ensure there is ahead bytes available in node's buffer\n     * (assumes that the node is not shared)\n     */\n    private void ensure(int ahead) {\n        int len = (end - p) + ahead;\n        if (len >= bytes.length) {\n            byte[]tmp = new byte[len + NODE_STR_MARGIN];\n            System.arraycopy(bytes, p, tmp, 0, end - p);\n            bytes = tmp;\n        }\n    }\n\n    /* COW and/or ensure there is ahead bytes available in node's buffer\n     */\n    private void modifyEnsure(int ahead) {\n        if (isShared()) {\n            int len = (end - p) + ahead;\n            byte[]tmp = new byte[len + NODE_STR_MARGIN];\n            System.arraycopy(bytes, p, tmp, 0, end - p);\n            bytes = tmp;\n            end = end - p;\n            p = 0;\n            clearShared();\n        } else {\n            ensure(ahead);\n        }\n    }\n\n    @Override\n    public String getName() {\n        return \"String\";\n    }\n\n    public int length() {\n        return end - p;\n    }\n\n    public int length(Encoding enc) {\n        return enc.strLength(bytes, p, end);\n    }\n\n    public StringNode splitLastChar(Encoding enc) {\n        StringNode n = null;\n        if (end > p) {\n            int prev = enc.prevCharHead(bytes, p, end, end);\n            if (prev != -1 && prev > p) { /* can be split */\n                n = new StringNode(bytes, prev, end);\n                if (isRaw()) n.setRaw();\n                end = prev;\n            }\n        }\n        return n;\n    }\n\n    public boolean canBeSplit(Encoding enc) {\n        if (end > p) {\n            return enc.length(bytes, p, end) < (end - p);\n        }\n        return false;\n    }\n\n    public void set(byte[]bytes, int p, int end) {\n        this.bytes = bytes;\n        this.p = p;\n        this.end = end;\n        setShared();\n    }\n\n    public void catBytes(byte[]cat, int catP, int catEnd) {\n        int len = catEnd - catP;\n        modifyEnsure(len);\n        System.arraycopy(cat, catP, bytes, end, len);\n        end += len;\n    }\n\n    public void catByte(byte c) {\n        modifyEnsure(1);\n        bytes[end++] = c;\n    }\n\n    public void catCode(int code, Encoding enc) {\n        modifyEnsure(Config.ENC_CODE_TO_MBC_MAXLEN);\n        end += enc.codeToMbc(code, bytes, end);\n    }\n\n    public void setRaw() {\n        flag |= NSTR_RAW;\n    }\n\n    public void clearRaw() {\n        flag &= ~NSTR_RAW;\n    }\n\n    public boolean isRaw() {\n        return (flag & NSTR_RAW) != 0;\n    }\n\n    public void setAmbig() {\n        flag |= NSTR_AMBIG;\n    }\n\n    public void clearAmbig() {\n        flag &= ~NSTR_AMBIG;\n    }\n\n    public boolean isAmbig() {\n        return (flag & NSTR_AMBIG) != 0;\n    }\n\n    public void setDontGetOptInfo() {\n        flag |= NSTR_DONT_GET_OPT_INFO;\n    }\n\n    public void clearDontGetOptInfo() {\n        flag &= ~NSTR_DONT_GET_OPT_INFO;\n    }\n\n    public boolean isDontGetOptInfo() {\n        return (flag & NSTR_DONT_GET_OPT_INFO) != 0;\n    }\n\n    public void setShared() {\n        flag |= NSTR_SHARED;\n    }\n\n    public void clearShared() {\n        flag &= ~NSTR_SHARED;\n    }\n\n    public boolean isShared() {\n        return (flag & NSTR_SHARED) != 0;\n    }\n\n    public String flagsToString() {\n        StringBuilder flags = new StringBuilder();\n        if (isRaw()) flags.append(\"RAW \");\n        if (isAmbig()) flags.append(\"AMBIG \");\n        if (isDontGetOptInfo()) flags.append(\"DONT_GET_OPT_INFO \");\n        if (isShared()) flags.append(\"SHARED \");\n        return flags.toString();\n    }\n\n    @Override\n    public String toString(int level) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"\\n  flags: \" + flagsToString());\n        sb.append(\"\\n  bytes: '\");\n        for (int i=p; i<end; i++) {\n            if ((bytes[i] & 0xff) >= 0x20 && (bytes[i] & 0xff) < 0x7f) {\n                sb.append((char)bytes[i]);\n            } else {\n                sb.append(String.format(\"[0x%02x]\", bytes[i]));\n            }\n        }\n        sb.append(\"'\");\n        return sb.toString();\n    }\n}\nsrc/org/joni/BitStatus.java\npublic static boolean bsAt(int stats, int n) {\n    return (n < BIT_STATUS_BITS_NUM ? stats & (1 << n) : (stats & 1)) != 0;\n}\nsrc/org/joni/BitStatus.java\npublic static int bsAll() {\n    return -1;\n}\nsrc/org/joni/Option.java\npublic static boolean isCaptureGroup(int option) {\n    return (option & CAPTURE_GROUP) != 0;\n}\nsrc/org/joni/ast/EncloseNode.java\npublic final class EncloseNode extends StateNode implements EncloseType {\n    public final int type;          // enclose type\n    public int regNum;\n    public int option;\n    public Node target;             /* EncloseNode : ENCLOSE_MEMORY */\n    public int callAddr;            // AbsAddrType\n    public int minLength;           // OnigDistance\n    public int maxLength;           // OnigDistance\n    public int charLength;\n    public int optCount;            // referenced count in optimize_node_left()\n    public Node containingAnchor;   //\n\n    // node_new_enclose / onig_node_new_enclose\n    public EncloseNode(int type) {\n        super(ENCLOSE);\n        this.type = type;\n        callAddr = -1;\n    }\n\n    public static EncloseNode newMemory(int option, boolean isNamed) {\n        EncloseNode en = new EncloseNode(MEMORY);\n        if (Config.USE_SUBEXP_CALL) en.option = option;\n        if (isNamed) en.setNamedGroup();\n        return en;\n    }\n\n    public static EncloseNode newOption(int option) {\n        EncloseNode en = new EncloseNode(OPTION);\n        en.option = option;\n        return en;\n    }\n\n    @Override\n    protected void setChild(Node child) {\n        target = child;\n    }\n\n    @Override\n    protected Node getChild() {\n        return target;\n    }\n\n    public void setTarget(Node tgt) {\n        target = tgt;\n        tgt.parent = this;\n    }\n\n    @Override\n    public String getName() {\n        return \"Enclose\";\n    }\n\n    @Override\n    public String toString(int level) {\n        StringBuilder value = new StringBuilder(super.toString(level));\n        value.append(\"\\n  type: \" + typeToString());\n        value.append(\"\\n  regNum: \" + regNum);\n        value.append(\", option: \" + Option.toString(option));\n        value.append(\", callAddr: \" + callAddr);\n        value.append(\", minLength: \" + minLength);\n        value.append(\", maxLength: \" + maxLength);\n        value.append(\", charLength: \" + charLength);\n        value.append(\", optCount: \" + optCount);\n        value.append(\"\\n  target: \" + pad(target, level + 1));\n        return value.toString();\n    }\n\n    public String typeToString() {\n        StringBuilder types = new StringBuilder();\n        if (isStopBacktrack()) types.append(\"STOP_BACKTRACK \");\n        if (isMemory()) types.append(\"MEMORY \");\n        if (isOption()) types.append(\"OPTION \");\n        if (isCondition()) types.append(\"CONDITION \");\n        if (isAbsent()) types.append(\"ABSENT \");\n        return types.toString();\n    }\n\n    public void setEncloseStatus(int flag) {\n        state |= flag;\n    }\n\n    public void clearEncloseStatus(int flag) {\n        state &= ~flag;\n    }\n\n    public boolean isMemory() {\n        return (type & MEMORY) != 0;\n    }\n\n    public boolean isOption() {\n        return (type & OPTION) != 0;\n    }\n\n    public boolean isCondition() {\n        return (type & CONDITION) != 0;\n    }\n\n    public boolean isStopBacktrack() {\n        return (type & STOP_BACKTRACK) != 0;\n    }\n\n    public boolean isAbsent() {\n        return (type & ABSENT) != 0;\n    }\n}\nsrc/org/joni/BitStatus.java\npublic static int bsOnAtSimple(int stats, int n) {\n    if (n < BIT_STATUS_BITS_NUM) stats |= (1 << n);\n    return stats;\n}\nsrc/org/joni/ast/CClassNode.java\npublic final class CClassNode extends Node {\n    private static final int FLAG_NCCLASS_NOT = 1 << 0;\n\n    private int flags;\n    public final BitSet bs = new BitSet();  // conditional creation ?\n    public CodeRangeBuffer mbuf;            /* multi-byte info or NULL */\n\n    // node_new_cclass\n    public CClassNode() {\n        super(CCLASS);\n    }\n\n    public void clear() {\n        bs.clear();\n        flags = 0;\n        mbuf = null;\n    }\n\n    @Override\n    public String getName() {\n        return \"Character Class\";\n    }\n\n    @Override\n    public String toString(int level) {\n        StringBuilder value = new StringBuilder();\n        value.append(\"\\n  flags: \" + flagsToString());\n        value.append(\"\\n  bs: \" + pad(bs, level + 1));\n        value.append(\"\\n  mbuf: \" + pad(mbuf, level + 1));\n        return value.toString();\n    }\n\n    public String flagsToString() {\n        StringBuilder flags = new StringBuilder();\n        if (isNot()) flags.append(\"NOT \");\n        return flags.toString();\n    }\n\n    public boolean isEmpty() {\n        return mbuf == null && bs.isEmpty();\n    }\n\n    void addCodeRangeToBuf(ScanEnvironment env, int from, int to) {\n        addCodeRangeToBuf(env, from, to, true);\n    }\n\n    void addCodeRangeToBuf(ScanEnvironment env, int from, int to, boolean checkDup) {\n        mbuf = CodeRangeBuffer.addCodeRangeToBuff(mbuf, env, from, to, checkDup);\n    }\n\n    // add_code_range, be aware of it returning null!\n    public void addCodeRange(ScanEnvironment env, int from, int to) {\n        addCodeRange(env, from, to, true);\n    }\n\n    public void addCodeRange(ScanEnvironment env, int from, int to, boolean checkDup) {\n        mbuf = CodeRangeBuffer.addCodeRange(mbuf, env, from, to, checkDup);\n    }\n\n    void addAllMultiByteRange(ScanEnvironment env) {\n        mbuf = CodeRangeBuffer.addAllMultiByteRange(env, mbuf);\n    }\n\n    public void clearNotFlag(ScanEnvironment env) {\n        if (isNot()) {\n            bs.invert();\n            if (!env.enc.isSingleByte()) {\n                mbuf = CodeRangeBuffer.notCodeRangeBuff(env, mbuf);\n            }\n            clearNot();\n        }\n    }\n\n    public int isOneChar() {\n        if (isNot()) return -1;\n        int c = -1;\n        if (mbuf != null) {\n            int[]range = mbuf.getCodeRange();\n            c = range[1];\n            if (range[0] == 1 && c == range[2]) {\n                if (c < BitSet.SINGLE_BYTE_SIZE && bs.at(c)) {\n                    c = -1;\n                }\n            } else {\n                return -1;\n            }\n        }\n\n        for (int i = 0; i < BitSet.BITSET_SIZE; i++) {\n            int b1 = bs.bits[i];\n            if (b1 != 0) {\n                if ((b1 & (b1 - 1)) == 0 && c == -1) {\n                    c = BitSet.BITS_IN_ROOM * i + Integer.bitCount(b1 - 1);\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return c;\n    }\n\n    // and_cclass\n    public void and(CClassNode other, ScanEnvironment env) {\n        boolean not1 = isNot();\n        BitSet bsr1 = bs;\n        CodeRangeBuffer buf1 = mbuf;\n        boolean not2 = other.isNot();\n        BitSet bsr2 = other.bs;\n        CodeRangeBuffer buf2 = other.mbuf;\n\n        if (not1) {\n            BitSet bs1 = new BitSet();\n            bsr1.invertTo(bs1);\n            bsr1 = bs1;\n        }\n\n        if (not2) {\n            BitSet bs2 = new BitSet();\n            bsr2.invertTo(bs2);\n            bsr2 = bs2;\n        }\n\n        bsr1.and(bsr2);\n\n        if (bsr1 != bs) {\n            bs.copy(bsr1);\n            bsr1 = bs;\n        }\n\n        if (not1) {\n            bs.invert();\n        }\n\n        CodeRangeBuffer pbuf = null;\n\n        if (!env.enc.isSingleByte()) {\n            if (not1 && not2) {\n                pbuf = CodeRangeBuffer.orCodeRangeBuff(env, buf1, false, buf2, false);\n            } else {\n                pbuf = CodeRangeBuffer.andCodeRangeBuff(buf1, not1, buf2, not2, env);\n\n                if (not1) {\n                    pbuf = CodeRangeBuffer.notCodeRangeBuff(env, pbuf);\n                }\n            }\n            mbuf = pbuf;\n        }\n\n    }\n\n    // or_cclass\n    public void or(CClassNode other, ScanEnvironment env) {\n        boolean not1 = isNot();\n        BitSet bsr1 = bs;\n        CodeRangeBuffer buf1 = mbuf;\n        boolean not2 = other.isNot();\n        BitSet bsr2 = other.bs;\n        CodeRangeBuffer buf2 = other.mbuf;\n\n        if (not1) {\n            BitSet bs1 = new BitSet();\n            bsr1.invertTo(bs1);\n            bsr1 = bs1;\n        }\n\n        if (not2) {\n            BitSet bs2 = new BitSet();\n            bsr2.invertTo(bs2);\n            bsr2 = bs2;\n        }\n\n        bsr1.or(bsr2);\n\n        if (bsr1 != bs) {\n            bs.copy(bsr1);\n            bsr1 = bs;\n        }\n\n        if (not1) {\n            bs.invert();\n        }\n\n        if (!env.enc.isSingleByte()) {\n            CodeRangeBuffer pbuf = null;\n            if (not1 && not2) {\n                pbuf = CodeRangeBuffer.andCodeRangeBuff(buf1, false, buf2, false, env);\n            } else {\n                pbuf = CodeRangeBuffer.orCodeRangeBuff(env, buf1, not1, buf2, not2);\n                if (not1) {\n                    pbuf = CodeRangeBuffer.notCodeRangeBuff(env, pbuf);\n                }\n            }\n            mbuf = pbuf;\n        }\n    }\n\n    // add_ctype_to_cc_by_range // Encoding out!\n    public void addCTypeByRange(int ctype, boolean not, ScanEnvironment env, int sbOut, int mbr[]) {\n        int n = mbr[0];\n        int i;\n\n        if (!not) {\n            for (i=0; i<n; i++) {\n                for (int j=CR_FROM(mbr, i); j<=CR_TO(mbr, i); j++) {\n                    if (j >= sbOut) {\n                        if (j > CR_FROM(mbr, i)) {\n                            addCodeRangeToBuf(env, j, CR_TO(mbr, i));\n                            i++;\n                        }\n                        // !goto sb_end!, remove duplication!\n                        for (; i<n; i++) {\n                            addCodeRangeToBuf(env, CR_FROM(mbr, i), CR_TO(mbr, i));\n                        }\n                        return;\n                    }\n                    bs.set(env, j);\n                }\n            }\n            // !sb_end:!\n            for (; i<n; i++) {\n                addCodeRangeToBuf(env, CR_FROM(mbr, i), CR_TO(mbr, i));\n            }\n\n        } else {\n            int prev = 0;\n\n            for (i=0; i<n; i++) {\n                for (int j=prev; j < CR_FROM(mbr, i); j++) {\n                    if (j >= sbOut) {\n                        // !goto sb_end2!, remove duplication\n                        prev = sbOut;\n                        for (i=0; i<n; i++) {\n                            if (prev < CR_FROM(mbr, i)) addCodeRangeToBuf(env, prev, CR_FROM(mbr, i) - 1);\n                            prev = CR_TO(mbr, i) + 1;\n                        }\n                        if (prev < 0x7fffffff/*!!!*/) addCodeRangeToBuf(env, prev, 0x7fffffff);\n                        return;\n                    }\n                    bs.set(env, j);\n                }\n                prev = CR_TO(mbr, i) + 1;\n            }\n\n            for (int j=prev; j<sbOut; j++) {\n                bs.set(env, j);\n            }\n\n            // !sb_end2:!\n            prev = sbOut;\n            for (i=0; i<n; i++) {\n                if (prev < CR_FROM(mbr, i)) addCodeRangeToBuf(env, prev, CR_FROM(mbr, i) - 1);\n                prev = CR_TO(mbr, i) + 1;\n            }\n            if (prev < 0x7fffffff/*!!!*/) addCodeRangeToBuf(env, prev, 0x7fffffff);\n        }\n    }\n\n    private static int CR_FROM(int[] range, int i) {\n        return range[(i * 2) + 1];\n    }\n\n    private static int CR_TO(int[] range, int i) {\n        return range[(i * 2) + 2];\n    }\n\n    // add_ctype_to_cc\n    public void addCType(int ctype, boolean not, boolean asciiRange, ScanEnvironment env, IntHolder sbOut) {\n        Encoding enc = env.enc;\n        int[]ranges = enc.ctypeCodeRange(ctype, sbOut);\n        if (ranges != null) {\n            if (asciiRange) {\n                CClassNode ccWork = new CClassNode();\n                ccWork.addCTypeByRange(ctype, not, env, sbOut.value, ranges);\n                if (not) {\n                    ccWork.addCodeRangeToBuf(env, 0x80, CodeRangeBuffer.LAST_CODE_POINT, false);\n                } else {\n                    CClassNode ccAscii = new CClassNode();\n                    if (enc.minLength() > 1) {\n                        ccAscii.addCodeRangeToBuf(env, 0x00, 0x7F);\n                    } else {\n                        ccAscii.bs.setRange(env, 0x00, 0x7F);\n                    }\n                    ccWork.and(ccAscii, env);\n                }\n                or(ccWork, env);\n            } else {\n                addCTypeByRange(ctype, not, env, sbOut.value, ranges);\n            }\n            return;\n        }\n\n        int maxCode = asciiRange ? 0x80 : BitSet.SINGLE_BYTE_SIZE;\n        switch(ctype) {\n        case CharacterType.ALPHA:\n        case CharacterType.BLANK:\n        case CharacterType.CNTRL:\n        case CharacterType.DIGIT:\n        case CharacterType.LOWER:\n        case CharacterType.PUNCT:\n        case CharacterType.SPACE:\n        case CharacterType.UPPER:\n        case CharacterType.XDIGIT:\n        case CharacterType.ASCII:\n        case CharacterType.ALNUM:\n            if (not) {\n                for (int c=0; c<BitSet.SINGLE_BYTE_SIZE; c++) {\n                    if (!enc.isCodeCType(c, ctype)) bs.set(env, c);\n                }\n                addAllMultiByteRange(env);\n            } else {\n                for (int c=0; c<BitSet.SINGLE_BYTE_SIZE; c++) {\n                    if (enc.isCodeCType(c, ctype)) bs.set(env, c);\n                }\n            }\n            break;\n\n        case CharacterType.GRAPH:\n        case CharacterType.PRINT:\n            if (not) {\n                for (int c=0; c<BitSet.SINGLE_BYTE_SIZE; c++) {\n                    if (!enc.isCodeCType(c, ctype) || c >= maxCode) bs.set(env, c);\n                }\n                if (asciiRange) addAllMultiByteRange(env);\n            } else {\n                for (int c=0; c<maxCode; c++) {\n                    if (enc.isCodeCType(c, ctype)) bs.set(env, c);\n                }\n                if (!asciiRange) addAllMultiByteRange(env);\n            }\n            break;\n\n        case CharacterType.WORD:\n            if (!not) {\n                for (int c=0; c<maxCode; c++) {\n                    if (enc.isSbWord(c)) bs.set(env, c);\n                }\n                if (!asciiRange) addAllMultiByteRange(env);\n            } else {\n                for (int c=0; c<BitSet.SINGLE_BYTE_SIZE; c++) {\n                    if (enc.codeToMbcLength(c) > 0 && /* check invalid code point */\n                            !(enc.isWord(c) || c >= maxCode)) bs.set(env, c);\n                }\n                if (asciiRange) addAllMultiByteRange(env);\n            }\n            break;\n\n        default:\n            throw new InternalException(ErrorMessages.PARSER_BUG);\n        } // switch\n    }\n\n    public static enum CCVALTYPE {\n        SB,\n        CODE_POINT,\n        CLASS\n    }\n\n    public static enum CCSTATE {\n        VALUE,\n        RANGE,\n        COMPLETE,\n        START\n    }\n\n    public static final class CCStateArg {\n        public int from;\n        public int to;\n        public boolean fromIsRaw;\n        public boolean toIsRaw;\n        public CCVALTYPE inType;\n        public CCVALTYPE type;\n        public CCSTATE state;\n    }\n\n    public void nextStateClass(CCStateArg arg, CClassNode ascCC, ScanEnvironment env) {\n        if (arg.state == CCSTATE.RANGE) throw new SyntaxException(ErrorMessages.CHAR_CLASS_VALUE_AT_END_OF_RANGE);\n\n        if (arg.state == CCSTATE.VALUE && arg.type != CCVALTYPE.CLASS) {\n            if (arg.type == CCVALTYPE.SB) {\n                bs.set(env, arg.from);\n                if (ascCC != null) ascCC.bs.set(arg.from);\n            } else if (arg.type == CCVALTYPE.CODE_POINT) {\n                addCodeRange(env, arg.from, arg.from);\n                if (ascCC != null) ascCC.addCodeRange(env, arg.from, arg.from, false);\n            }\n        }\n        arg.state = CCSTATE.VALUE;\n        arg.type = CCVALTYPE.CLASS;\n    }\n\n    public void nextStateValue(CCStateArg arg, CClassNode ascCc, ScanEnvironment env) {\n        switch(arg.state) {\n        case VALUE:\n            if (arg.type == CCVALTYPE.SB) {\n                bs.set(env, arg.from);\n                if (ascCc != null) ascCc.bs.set(arg.from);\n            } else if (arg.type == CCVALTYPE.CODE_POINT) {\n                addCodeRange(env, arg.from, arg.from);\n                if (ascCc != null) ascCc.addCodeRange(env, arg.from, arg.from, false);\n            }\n            break;\n\n        case RANGE:\n            if (arg.inType == arg.type) {\n                if (arg.inType == CCVALTYPE.SB) {\n                    if (arg.from > 0xff || arg.to > 0xff) throw new ValueException(ErrorMessages.ERR_INVALID_CODE_POINT_VALUE);\n\n                    if (arg.from > arg.to) {\n                        if (env.syntax.allowEmptyRangeInCC()) {\n                            // goto ccs_range_end\n                            arg.state = CCSTATE.COMPLETE;\n                            break;\n                        } else {\n                            throw new ValueException(ErrorMessages.EMPTY_RANGE_IN_CHAR_CLASS);\n                        }\n                    }\n                    bs.setRange(env, arg.from, arg.to);\n                    if (ascCc != null) ascCc.bs.setRange(null, arg.from, arg.to);\n                } else {\n                    addCodeRange(env, arg.from, arg.to);\n                    if (ascCc != null) ascCc.addCodeRange(env, arg.from, arg.to, false);\n                }\n            } else {\n                if (arg.from > arg.to) {\n                    if (env.syntax.allowEmptyRangeInCC()) {\n                        // goto ccs_range_end\n                        arg.state = CCSTATE.COMPLETE;\n                        break;\n                    } else {\n                        throw new ValueException(ErrorMessages.EMPTY_RANGE_IN_CHAR_CLASS);\n                    }\n                }\n                bs.setRange(env, arg.from, arg.to < 0xff ? arg.to : 0xff);\n                addCodeRange(env, arg.from, arg.to);\n                if (ascCc != null) {\n                    ascCc.bs.setRange(null, arg.from, arg.to < 0xff ? arg.to : 0xff);\n                    ascCc.addCodeRange(env, arg.from, arg.to, false);\n                }\n            }\n            // ccs_range_end:\n            arg.state = CCSTATE.COMPLETE;\n            break;\n\n        case COMPLETE:\n        case START:\n            arg.state = CCSTATE.VALUE;\n            break;\n\n        default:\n            break;\n\n        } // switch\n\n        arg.fromIsRaw = arg.toIsRaw;\n        arg.from = arg.to;\n        arg.type = arg.inType;\n    }\n\n    // onig_is_code_in_cc_len\n    boolean isCodeInCCLength(int encLength, int code) {\n        boolean found;\n\n        if (encLength > 1 || code >= BitSet.SINGLE_BYTE_SIZE) {\n            if (mbuf == null) {\n                found = false;\n            } else {\n                found = CodeRange.isInCodeRange(mbuf.getCodeRange(), code);\n            }\n        } else {\n            found = bs.at(code);\n        }\n\n        if (isNot()) {\n            return !found;\n        } else {\n            return found;\n        }\n    }\n\n    // onig_is_code_in_cc\n    public boolean isCodeInCC(Encoding enc, int code) {\n        int len;\n        if (enc.minLength() > 1) {\n            len = 2;\n        } else {\n            len = enc.codeToMbcLength(code);\n        }\n        return isCodeInCCLength(len, code);\n    }\n\n    public void setNot() {\n        flags |= FLAG_NCCLASS_NOT;\n    }\n\n    public void clearNot() {\n        flags &= ~FLAG_NCCLASS_NOT;\n    }\n\n    public boolean isNot() {\n        return (flags & FLAG_NCCLASS_NOT) != 0;\n    }\n}\n", "answers": ["                            if (bsAt(env.backrefedMem, i)) {"], "length": 5421, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "fb3b6309cd6ab41ea9b398d8beb6e4ac5130c90d5aa1164d"}
{"input": "from django.conf import settings\nfrom django.conf.urls import url, include\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.views.generic.base import TemplateView, RedirectView\nfrom rest_framework.documentation import include_docs_urls\nfrom dashboard.services.urls import api_urls\nfrom dashboard.views import (\n    TranStatusPackageView, TranStatusReleasesView, TranStatusReleaseView, DeletePackageView, DeleteGraphRuleView,\n    TransPlatformSettingsView, LanguagesSettingsView, PackageSettingsView, AddPackageCIPipeline, hide_ci_pipeline,\n    JobsView, JobsLogsView, JobsArchiveView, JobsLogsPackageView, NewPackageView, UpdatePackageView, TransCoverageView,\n    StreamBranchesSettingsView, NewReleaseBranchView, GraphRulesSettingsView, NewGraphRuleView, YMLBasedJobs,\n    NewLanguageView, UpdateLanguageView, NewLanguageSetView, UpdateLanguageSetView, NewTransPlatformView,\n    UpdateTransPlatformView, UpdateGraphRuleView, JobDetailView, refresh_package, release_graph, schedule_job,\n    tabular_data, export_packages, generate_reports, read_file_logs, get_build_tags, change_lang_status,\n    LanguageDetailView, LanguageReleaseView, TerritoryView, CleanUpJobs, get_repo_branches, get_target_langs,\n    refresh_ci_pipeline, graph_data, job_template, PipelineDetailView, PipelineHistoryView, PipelineConfigurationView,\n    ReleasePipelinesView, PipelinesView, AddCIPipeline, get_workflow_steps, get_pipeline_job_template,\n    ajax_save_pipeline_config, ajax_run_pipeline_config, ajax_toggle_pipeline_config, ajax_delete_pipeline_config\n)\n# Copyright 2016 Red Hat, Inc.\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\n# django\n\n# third-party\n\n# dashboard\n\nLOGIN_URL = \"oidc_authentication_init\" if settings.FAS_AUTH else \"admin:index\"\n\n\napp_job_urls = [\n    url(r'^$', login_required(JobsView.as_view(), login_url=LOGIN_URL), name=\"jobs\"),\n    url(r'^cleanup$', login_required(CleanUpJobs.as_view(), login_url=LOGIN_URL), name=\"jobs-cleanup\"),\n    url(r'^logs$', JobsLogsView.as_view(), name=\"jobs-logs\"),\n    url(r'^archive$', JobsArchiveView.as_view(), name=\"jobs-archive\"),\n    url(r'^templates$', YMLBasedJobs.as_view(), name=\"jobs-yml-based\"),\n    url(r'^log/(?P<job_id>[0-9a-f-]+)/detail$', JobDetailView.as_view(), name=\"log-detail\"),\n    url(r'^logs/package/(?P<package_name>[\\w\\-\\+]+)$', JobsLogsPackageView.as_view(),\n        name=\"jobs-logs-package\")\n]\n\napp_pipeline_urls = [\n    url(r'^$', PipelinesView.as_view(), name=\"pipelines\"),\n    url(r'^release/(?P<release_slug>[\\w\\-\\+]+)$', ReleasePipelinesView.as_view(), name=\"release-pipelines\"),\n    url(r'^new$', staff_member_required(AddCIPipeline.as_view(), login_url=LOGIN_URL), name=\"add-ci-pipeline\"),\n    url(r'^(?P<pipeline_id>[0-9a-f-]+)/details$', PipelineDetailView.as_view(), name=\"pipeline-details\"),\n    url(r'^(?P<pipeline_id>[0-9a-f-]+)/history$', PipelineHistoryView.as_view(), name=\"pipeline-history\"),\n    url(r'^(?P<pipeline_id>[0-9a-f-]+)/configurations$', PipelineConfigurationView.as_view(),\n        name=\"pipeline-configuration\"),\n]\n\napp_setting_urls = [\n    url(r'^$', RedirectView.as_view(permanent=False, url='/settings/languages'), name=\"settings\"),\n    url(r'^languages$', RedirectView.as_view(permanent=True, url='/languages')),\n    url(r'^translation-platforms$', RedirectView.as_view(permanent=True, url='/translation-platforms')),\n    url(r'^packages$', RedirectView.as_view(permanent=True, url='/packages')),\n    url(r'^products$', RedirectView.as_view(permanent=True, url='/products')),\n    url(r'^graph-rules$', RedirectView.as_view(permanent=True, url='/coverage')),\n    url(r'^notification$', TemplateView.as_view(template_name=\"settings/notification.html\"),\n        name=\"settings-notification\"),\n]\n\najax_urls = [\n    url(r'^schedule-job$', schedule_job, name=\"ajax-schedule-job\"),\n    url(r'^graph-data$', graph_data, name=\"ajax-graph-data\"),\n    url(r'^tabular-data$', tabular_data, name=\"ajax-tabular-data\"),\n    url(r'^refresh-package$', refresh_package, name=\"ajax-refresh-package\"),\n    url(r'^release-graph$', release_graph, name=\"ajax-release-graph\"),\n    url(r'^generate-reports$', generate_reports, name=\"ajax-releases-report\"),\n    url(r'^read-file-logs$', read_file_logs, name=\"ajax-read-logs\"),\n    url(r'^build-tags$', get_build_tags, name=\"ajax-build-tags\"),\n    url(r'^repo-branches$', get_repo_branches, name=\"ajax-repo-branches\"),\n    url(r'^job-template$', job_template, name=\"ajax-job-template\"),\n    url(r'^change-lang-status$', staff_member_required(change_lang_status),\n        name=\"ajax-change-lang-status\"),\n    url(r'^remove-pipeline$', login_required(hide_ci_pipeline),\n        name=\"ajax-remove-pipeline\"),\n    url(r'^refresh-pipeline$', refresh_ci_pipeline,\n        name=\"ajax-refresh-pipeline\"),\n    url(r'^target-langs$', get_target_langs, name=\"ajax-target-langs\"),\n", "context": "dashboard/views.py\ndef job_template(request):\n    \"\"\"\n    Select Job Template\n    \"\"\"\n    if request.is_ajax():\n        post_params = request.POST.dict()\n        selected_template = post_params.get('template', '')\n        context = Context(\n            {'META': request.META,\n             'job_template': selected_template}\n        )\n        template_string = \"\"\"\n                            {% load tag_job_form from custom_tags %}\n                            {% tag_job_form job_template %}\n                        \"\"\"\n        return HttpResponse(Template(template_string).render(context))\n    return HttpResponse(status=500)\ndashboard/views.py\ndef get_pipeline_job_template(request):\n    \"\"\"\n    Get Job Template for a CI Pipeline Event\n    :param request: Request object\n    :return: HttpResponse object\n    \"\"\"\n    if not request.is_ajax():\n        return HttpResponse(\"Not an Ajax Call\", status=400)\n\n    post_params = request.POST.dict()\n    pipeline_action = post_params.get('pipelineAction', '')\n    pipeline_uuid = post_params.get('pipelineUUID', '')\n    context = Context(\n        {'META': request.META,\n         'tenant': request.tenant,\n         'pipeline_action': pipeline_action,\n         'pipeline_uuid': pipeline_uuid}\n    )\n    template_string = \"\"\"\n                            {% load tag_pipeline_job_params from custom_tags %}\n                            {% tag_pipeline_job_params tenant pipeline_uuid pipeline_action %}\n                        \"\"\"\n    return HttpResponse(Template(template_string).render(context))\ndashboard/views.py\ndef schedule_job(request):\n    \"\"\"\n    Handles job schedule AJAX POST request\n    \"\"\"\n    message = \"&nbsp;&nbsp;<span class='text-warning'>Request could not be processed.</span>\"\n    if request.is_ajax():\n        job_type = request.POST.dict().get('job')\n        active_user = getattr(request, 'user', None)\n        active_user_email = active_user.email \\\n            if active_user and not active_user.is_anonymous else 'anonymous@transtats.org'\n        if job_type == TS_JOB_TYPES[0]:\n            transplatform_sync_manager = TransplatformSyncManager(**{'active_user_email': active_user_email})\n            job_uuid = transplatform_sync_manager.syncstats_initiate_job()\n            if job_uuid:\n                message = \"&nbsp;&nbsp;<span class='pficon pficon-ok'></span>\" + \\\n                          \"&nbsp;Job created and logged! UUID: <a href='/jobs/logs'>\" + str(job_uuid) + \"</a>\"\n                transplatform_sync_manager.sync_trans_stats()\n            else:\n                message = \"&nbsp;&nbsp;<span class='text-danger'>Alas! Something unexpected happened.</span>\"\n        elif job_type == TS_JOB_TYPES[1]:\n            relschedule_sync_manager = ReleaseScheduleSyncManager(**{'active_user_email': active_user_email})\n            job_uuid = relschedule_sync_manager.syncschedule_initiate_job()\n            if job_uuid:\n                message = \"&nbsp;&nbsp;<span class='pficon pficon-ok'></span>\" + \\\n                          \"&nbsp;Job created and logged! UUID: <a href='/jobs/logs'>\" + str(job_uuid) + \"</a>\"\n                relschedule_sync_manager.sync_release_schedule()\n            else:\n                message = \"&nbsp;&nbsp;<span class='text-danger'>Alas! Something unexpected happened.</span>\"\n        elif job_type in (TS_JOB_TYPES[2], TS_JOB_TYPES[3], TS_JOB_TYPES[5], TS_JOB_TYPES[6], TS_JOB_TYPES[7],\n                          TS_JOB_TYPES[8], TS_JOB_TYPES[9], 'YMLbasedJob'):\n\n            if job_type in TS_CI_JOBS and 'anonymous' in active_user_email:\n                message = \"&nbsp;&nbsp;<span class='text-warning'>Please login to continue.</span>\"\n                return HttpResponse(message, status=403)\n            job_params = request.POST.dict().get('params')\n            if not job_params:\n                message = \"&nbsp;&nbsp;<span class='text-danger'>Job params missing.</span>\"\n                return HttpResponse(message, status=500)\n            req_params, fields = [str(param).upper() for param in ast.literal_eval(job_params)], []\n            fields.extend(req_params + ['YML_FILE'])\n            not_available = [field for field in fields if not request.POST.dict().get(field)]\n            if len(not_available) > 0:\n                message = \"&nbsp;&nbsp;<span class='text-danger'>Provide value for %s</span>\" % not_available[0]\n                return HttpResponse(message, status=500)\n            else:\n                fields.append('DRY_RUN')\n                fields.append('SCRATCH')\n                job_manager = YMLBasedJobManager(\n                    **{field: request.POST.dict().get(field) for field in fields},\n                    **{'params': req_params, 'type': job_type},\n                    **{'active_user_email': active_user_email}\n                )\n                try:\n                    job_uuid = job_manager.execute_job()\n                except Exception:\n                    message = \"&nbsp;&nbsp;<span class='text-danger'>Alas! Something unexpected happened.</span>\"\n                    return HttpResponse(message, status=500)\n                else:\n                    if not request.POST.dict().get('SCRATCH', '') == 'ScratchRun':\n                        message = \"&nbsp;&nbsp;<span class='text-success'>Success. Job URL: \" \\\n                                  \"<a href='/jobs/log/\" + str(job_uuid) + \"/detail'\" \\\n                                  \" data-toggle='tooltip' title='Copy this link to share!'>\" + \\\n                                  str(job_uuid) + \"</a></span>\"\n                    else:\n                        message = \"&nbsp;&nbsp;<span class='text-success'>Success.</span>\"\n        elif job_type == TS_JOB_TYPES[4]:\n            buildtags_sync_manager = BuildTagsSyncManager(**{'active_user_email': active_user_email})\n            job_uuid = buildtags_sync_manager.syncbuildtags_initiate_job()\n            if job_uuid:\n                message = \"&nbsp;&nbsp;<span class='pficon pficon-ok'></span>\" + \\\n                          \"&nbsp;Job created and logged! UUID: <a href='/jobs/logs'>\" + str(job_uuid) + \"</a>\"\n                buildtags_sync_manager.sync_build_tags()\n            else:\n                message = \"&nbsp;&nbsp;<span class='text-danger'>Alas! Something unexpected happened.</span>\"\n    return HttpResponse(message)\ndashboard/views.py\nclass PipelineHistoryView(ManagersMixin, PipelineDetailView):\n    \"\"\"\n    Pipeline Sync Logs View\n    \"\"\"\n    template_name = \"ci/pipeline_history.html\"\n\n    def get_context_data(self, **kwargs):\n        context_data = super(PipelineHistoryView, self).get_context_data(**kwargs)\n        sync_logs = self.jobs_log_manager.get_job_logs(\n            remarks=self.object.ci_package.package_name, no_pipeline=False)\n        if sync_logs:\n            context_data[\"logs\"] = sync_logs.filter(**dict(ci_pipeline=self.object))\n        return context_data\ndashboard/views.py\nclass TranStatusReleaseView(ManagersMixin, TemplateView):\n    \"\"\"\n    Translation Status Release View\n    \"\"\"\n    template_name = \"releases/release_view.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(TranStatusReleaseView, self).get_context_data(**kwargs)\n        if not self.release_branch_manager.is_relbranch_exist(\n                kwargs.get('release_branch', '')):\n            raise Http404(\"Release does not exist.\")\n        langs = self.inventory_manager.get_locale_lang_tuple()\n        if langs:\n            context['languages'] = sorted(langs, key=lambda x: x[1])\n        relbranches = self.release_branch_manager.get_relbranch_name_slug_tuple()\n        context['releases'] = relbranches\n        release_stream = self.release_branch_manager.get_release_branches(\n            relbranch=kwargs.get('release_branch'), fields=['product_slug']).get()\n        if release_stream:\n            context['release_stream'] = release_stream.product_slug.product_slug\n        context['release_branch'] = kwargs.get('release_branch')\n        return context\ndashboard/views.py\nclass JobsLogsView(ManagersMixin, ListView):\n    \"\"\"\n    Logs List View\n    \"\"\"\n    template_name = \"jobs/logs.html\"\n    context_object_name = 'logs'\n\n    def get_queryset(self):\n        job_logs = self.jobs_log_manager.get_job_logs()\n        return job_logs[:50]\ndashboard/views.py\nclass NewLanguageSetView(SuccessMessageMixin, CreateView):\n    \"\"\"\n    New language set view\n    \"\"\"\n    template_name = \"languages/language_set_new.html\"\n    form_class = LanguageSetForm\n    success_message = '%(lang_set_name)s was added successfully!'\n\n    def get_success_url(self):\n        return reverse('language-set-new')\ndashboard/views.py\nclass DeletePackageView(ManagersMixin, SuccessMessageMixin, DeleteView):\n    \"\"\"\n    Delete Package view\n    \"\"\"\n    template_name = 'packages/package_delete.html'\n    model = Package\n    slug_field = 'package_name'\n    success_message = '%(package_name)s was removed successfully!'\n\n    def get(self, request, *args, **kwargs):\n        if kwargs.get('slug') and not request.user.is_superuser:\n            raise PermissionDenied\n        return super(DeletePackageView, self).get(request, *args, **kwargs)\n\n    def get_success_url(self):\n        return reverse('settings-packages')\n\n    def delete(self, request, *args, **kwargs):\n        self.object = self.get_object()\n        # delete all associated jobs\n        Job.objects.filter(job_remarks=self.object.package_name).delete()\n        # delete all related sync stats and pipelines\n        SyncStats.objects.filter(package_name=self.object).delete()\n        CIPipeline.objects.filter(ci_package=self.object).delete()\n        # delete all cached build details\n        CacheBuildDetails.objects.filter(package_name=self.object).delete()\n        # now, remove the package\n        self.object.delete()\n        # return to packages list view\n        return HttpResponseRedirect(self.get_success_url())\ndashboard/views.py\nclass UpdateLanguageSetView(SuccessMessageMixin, UpdateView):\n    \"\"\"\n    Update language set view\n    \"\"\"\n    template_name = \"languages/language_set_update.html\"\n    model = LanguageSet\n    form_class = LanguageSetForm\n    slug_field = 'lang_set_slug'\n    success_message = '%(lang_set_name)s was updated successfully!'\n\n    def get_success_url(self):\n        return reverse('language-set-update', args=[self.object.lang_set_slug])\ndashboard/views.py\nclass NewPackageView(ManagersMixin, FormView):\n    \"\"\"\n    New Package Form View\n    \"\"\"\n    template_name = \"packages/package_new.html\"\n\n    def get_success_url(self):\n        return reverse('package-new')\n\n    def get_initial(self):\n        initials = {}\n        if self.request.tenant == RELSTREAM_SLUGS[0] or self.request.tenant == RELSTREAM_SLUGS[1]:\n            initials.update(dict(transplatform_slug=WEBLATE_SLUGS[1]))\n        if self.request.tenant == RELSTREAM_SLUGS[3]:\n            initials.update(dict(transplatform_slug=TRANSIFEX_SLUGS[0]))\n        default_product = self.request.tenant\n        initials.update(dict(release_streams=default_product))\n        return initials\n\n    def get_form(self, form_class=None, data=None):\n        kwargs = {}\n        active_platforms = \\\n            self.inventory_manager.get_transplatform_slug_url()\n        active_streams = self.inventory_manager.get_relstream_slug_name()\n        kwargs.update({'platform_choices': active_platforms})\n        kwargs.update({'products_choices': active_streams})\n        kwargs.update({'initial': self.get_initial()})\n        if data:\n            kwargs.update({'data': data})\n        return NewPackageForm(**kwargs)\n\n    def post(self, request, *args, **kwargs):\n        post_data = {k: v[0] if len(v) == 1 else v for k, v in request.POST.lists()}\n        form = self.get_form(data=post_data)\n        post_params = form.cleaned_data\n        # Check for required fields\n        required_params = ('package_name', 'upstream_url', 'transplatform_slug', 'release_streams')\n        if not set(required_params) <= set(post_params.keys()):\n            messages.add_message(request, messages.ERROR, (\n                'One of the required fields is missing.'))\n            return render(request, self.template_name, {'form': form})\n        # Validate package with translation platform\n        validate_package = self.packages_manager.validate_package(**post_params)\n        if not validate_package:\n            errors = form._errors.setdefault('package_name', ErrorList())\n            errors.append(\"Not found at selected translation platform\")\n        if validate_package and form.is_valid():\n            post_params['package_name'] = validate_package\n            active_user = getattr(request, 'user', None)\n            if active_user:\n                post_params['created_by'] = active_user.email\n            if not self.packages_manager.add_package(**post_params):\n                messages.add_message(request, messages.ERROR, (\n                    'Alas! Something unexpected happened. Please try adding your package again!'\n                ))\n            else:\n                messages.add_message(request, messages.SUCCESS, (\n                    'Great! Package added successfully.'\n                ))\n                t = threading.Thread(\n                    target=self.packages_manager.refresh_package,\n                    args=[post_params['package_name']]\n                )\n                t.setDaemon(True)\n                t.start()\n            return HttpResponseRedirect(self.get_success_url())\n        return render(request, self.template_name, {'form': form, 'POST': 'invalid'})\ndashboard/views.py\ndef hide_ci_pipeline(request):\n    \"\"\"\n    Hide CI Pipeline\n    :param request: Request object\n    :return: HttpResponse object\n    \"\"\"\n    if not request.is_ajax():\n        return HttpResponse(\"Not an Ajax Call\", status=400)\n    post_params = request.POST.dict()\n    package_owner = post_params.get('user', '')\n    ci_pipeline_id = post_params.get('pipeline_id', '')\n    if not package_owner and not ci_pipeline_id:\n        return HttpResponse(\"Invalid Parameters\", status=422)\n    if not request.user.email == package_owner and not request.user.is_staff:\n        return HttpResponse(\"Access Denied\", status=403)\n    ci_pipeline_manager = CIPipelineManager()\n    # delete all associated jobs\n    Job.objects.filter(ci_pipeline_id=ci_pipeline_id).delete()\n    # delete all associated pipeline configs\n    PipelineConfig.objects.filter(ci_pipeline_id=ci_pipeline_id).delete()\n    if ci_pipeline_manager.toggle_visibility(ci_pipeline_id):\n        return HttpResponse(\"Pipeline successfully removed.\", status=202)\n    return HttpResponse(status=500)\ndashboard/views.py\nclass TranStatusReleasesView(ManagersMixin, TemplateView):\n    \"\"\"\n    Translation Status Releases View\n    This view is for current landing page.\n    \"\"\"\n    template_name = \"releases/release_list.html\"\n\n    def get(self, request, *args, **kwargs):\n        http_meta = self.request.META.copy()\n        self.log_visitor(http_meta)\n        return super(TranStatusReleasesView, self).get(request, *args, **kwargs)\n\n    def get_context_data(self, **kwargs):\n        \"\"\"\n        Build the Context Data\n        \"\"\"\n        context = super(TranStatusReleasesView, self).get_context_data(**kwargs)\n        relbranches = self.release_branch_manager.get_relbranch_name_slug_tuple()\n        context['releases'] = relbranches\n        products = self.inventory_manager.get_release_streams()\n        if self.request.tenant in RELSTREAM_SLUGS:\n            products = products.filter(**{'product_slug': self.request.tenant})\n        context['relstreams'] = products\n        product_releases = self.release_branch_manager.get_branches_of_relstreams(products)\n        p_releases_dict = {}\n        if product_releases is not None and isinstance(product_releases, dict):\n            for product, releases in product_releases.items():\n                p_releases_dict[product] = len(releases) or 0\n        context['p_releases_dict'] = p_releases_dict if p_releases_dict \\\n            else {p.product_slug: 0 for p in products}\n        context.update(self.get_summary())\n        return context\ndashboard/views.py\nclass TransCoverageView(ManagersMixin, TemplateView):\n    \"\"\"\n    Translation Coverage View\n    \"\"\"\n    template_name = \"coverage/coverage_rule_view.html\"\n\n    def get(self, request, *args, **kwargs):\n        rule = self.graph_manager.get_graph_rules(\n            graph_rule=kwargs.get('coverage_rule', '')\n        )\n        if not rule:\n            raise Http404(\"Coverage rule does not exist.\")\n        elif not rule.get().rule_visibility_public and \\\n                not request.user.is_authenticated:\n            raise PermissionDenied\n        return super(TransCoverageView, self).get(\n            request, *args, **kwargs)\n\n    def get_context_data(self, **kwargs):\n        \"\"\"\n        Build the Context Data\n        \"\"\"\n        context = super(TransCoverageView, self).get_context_data(**kwargs)\n        graph_rules = self.graph_manager.get_graph_rules(only_active=True)\n        if graph_rules:\n            context['rules'] = graph_rules\n        return context\ndashboard/views.py\ndef ajax_delete_pipeline_config(request):\n    \"\"\"\n    Delete Pipeline Configuration\n    :param request: Request object\n    :return: HttpResponse object\n    \"\"\"\n    if not request.is_ajax():\n        return HttpResponse(\"Not an Ajax Call\", status=400)\n\n    post_params = request.POST.dict().copy()\n    pipeline_config_manager = PipelineConfigManager()\n    if pipeline_config_manager.delete_pipeline_configuration(\n            pipeline_config_id=post_params.get('p_config_id')):\n        return HttpResponse(\"Ok\", status=204)\n    return HttpResponse(\"Something went wrong.\", status=500)\ndashboard/views.py\nclass NewReleaseBranchView(ManagersMixin, FormView):\n    \"\"\"\n    New Release Branch View\n    \"\"\"\n    template_name = \"releases/product_release_new.html\"\n\n    def _get_relstream(self):\n        try:\n            release_stream = self.inventory_manager.get_release_streams(\n                stream_slug=self.kwargs.get('stream_slug'), only_active=True\n            ).get()\n        except:\n            raise Http404(\"Product does not exist.\")\n        else:\n            return release_stream\n\n    def _get_langsets(self):\n        return self.inventory_manager.get_langsets()\n\n    def get_context_data(self, **kwargs):\n        context = super(NewReleaseBranchView, self).get_context_data(**kwargs)\n        context['relstream'] = self._get_relstream()\n        return context\n\n    def get_initial(self):\n        initials = {}\n        initials.update(dict(lang_set='default'))\n        initials.update(dict(enable_flags=['track_trans_flag', 'sync_calendar']))\n        return initials\n\n    def get_form(self, form_class=None, data=None):\n        kwargs = {}\n        release_stream = self._get_relstream()\n        lang_sets = self._get_langsets()\n        kwargs.update({'action_url': reverse('settings-stream-branches-new', args=[release_stream.product_slug])})\n        kwargs.update({'phases_choices': tuple([(phase, phase) for phase in release_stream.product_phases])})\n        kwargs.update({'langset_choices': tuple([(set.lang_set_slug, set.lang_set_name) for set in lang_sets])})\n        kwargs.update({'initial': self.get_initial()})\n        if data:\n            kwargs.update({'data': data})\n        return NewReleaseBranchForm(**kwargs)\n\n    def post(self, request, *args, **kwargs):\n        post_data = {k: v[0] if len(v) == 1 else v for k, v in request.POST.lists()}\n        form = self.get_form(data=post_data)\n        post_params = form.cleaned_data\n        relstream = kwargs.get('stream_slug')\n        # Check for required params\n        required_params = ('release_name', 'current_phase', 'lang_set', 'calendar_url')\n        if not set(required_params) <= set(post_params.keys()):\n            return render(request, self.template_name, {'form': form})\n        relbranch_slug, schedule_json = \\\n            self.release_branch_manager.validate_branch(relstream, **post_params)\n        if not schedule_json:\n            errors = form._errors.setdefault('calendar_url', ErrorList())\n            errors.append(\"Please check calendar URL, could not parse required dates!\")\n        if schedule_json:\n            success_url = reverse('settings-stream-branches-new', args=[relstream])\n            post_params['schedule_json_str'] = json.dumps(schedule_json)\n            post_params['release_slug'] = relbranch_slug\n            active_user = getattr(request, 'user', None)\n            if active_user:\n                post_params['created_by'] = active_user.email\n            if not self.release_branch_manager.add_relbranch(relstream, **post_params):\n                messages.add_message(request, messages.ERROR, (\n                    'Alas! Something unexpected happened. Please try adding release branch again!'\n                ))\n            else:\n                messages.add_message(request, messages.SUCCESS, (\n                    'Great! Release branch added successfully.'\n                ))\n            return HttpResponseRedirect(success_url)\n        return render(request, self.template_name, {\n            'form': form, 'relstream': self._get_relstream(), 'POST': 'invalid'\n        })\ndashboard/views.py\nclass CleanUpJobs(ManagersMixin, TemplateView):\n    \"\"\"\n    Predefined Jobs View\n    \"\"\"\n    template_name = \"jobs/jobs_cleanup.html\"\n\n    def post(self, request, *args, **kwargs):\n        post_data = {k: v[0] if len(v) == 1 else v for k, v in request.POST.lists()}\n        sync_stat_to_hide = []\n        for k, v in post_data.items():\n            if '|' in k:\n                sync_stat_to_hide.append(tuple(k.split('|')))\n        if sync_stat_to_hide:\n            sync_stats_manager = SyncStatsManager()\n            for stat in sync_stat_to_hide:\n                sync_stats_manager.toggle_visibility(\n                    stats_source=stat[0], project_version=stat[1]\n                )\n        return render(request, self.template_name, self.get_context_data(**kwargs))\n\n    def get_context_data(self, **kwargs):\n        context = super(CleanUpJobs, self).get_context_data(**kwargs)\n        sync_stats_manager = SyncStatsManager()\n        sync_stats = sync_stats_manager.get_sync_stats()\n        if sync_stats:\n            sync_stats = sync_stats.order_by().values(\n                'project_version', 'source'\n            ).distinct().exclude(project_version=\"Upstream\").order_by('project_version')\n        context['sync_stats'] = sync_stats\n        return context\ndashboard/views.py\nclass NewLanguageView(SuccessMessageMixin, CreateView):\n    \"\"\"\n    New language view\n    \"\"\"\n    template_name = \"languages/language_new.html\"\n    form_class = NewLanguageForm\n    success_message = '%(lang_name)s was added successfully!'\n\n    def get_success_url(self):\n        return reverse('language-new')\ndashboard/views.py\nclass PipelineConfigurationView(ManagersMixin, PipelineDetailView):\n    \"\"\"\n    Pipeline Configurations View\n    \"\"\"\n    template_name = \"ci/pipeline_configuration.html\"\n\n    def get_context_data(self, **kwargs):\n        context_data = super(PipelineConfigurationView, self).get_context_data(**kwargs)\n        context_data['pipeline_config_events'] = PIPELINE_CONFIG_EVENTS\n        return context_data\ndashboard/views.py\ndef generate_reports(request):\n    \"\"\"\n    Generates Reports\n    \"\"\"\n    if request.is_ajax():\n        post_params = request.POST.dict()\n        report_subject = post_params.get('subject', '')\n        reports_manager = ReportsManager()\n        if report_subject == 'releases':\n            try:\n                releases_summary = reports_manager.analyse_releases_status()\n            except Exception as e:\n                return HttpResponse(status=500)\n            if releases_summary:\n                context = Context(\n                    {'META': request.META,\n                     'relsummary': releases_summary,\n                     'last_updated': datetime.now()}\n                )\n                template_string = \"\"\"\n                                {% load tag_releases_summary from custom_tags %}\n                                {% tag_releases_summary %}\n                            \"\"\"\n                return HttpResponse(Template(template_string).render(context))\n        if report_subject == 'packages':\n            packages_summary = reports_manager.analyse_packages_status()\n            if packages_summary:\n                context = Context(\n                    {'META': request.META,\n                     'pkgsummary': packages_summary,\n                     'last_updated': datetime.now()}\n                )\n                template_string = \"\"\"\n                                    {% load tag_packages_summary from custom_tags %}\n                                    {% tag_packages_summary %}\n                                \"\"\"\n                return HttpResponse(Template(template_string).render(context))\n        if report_subject == 'location':\n            country_code = post_params.get('country_code', '')\n            location_summary = reports_manager.refresh_stats_required_by_territory()\n            if location_summary:\n                context = Context(\n                    {'META': request.META,\n                     'location_summary': location_summary,\n                     'last_updated': datetime.now(),\n                     'country_code': country_code}\n                )\n                template_string = \"\"\"\n                                    {% load tag_location_summary from custom_tags %}\n                                    {% tag_location_summary country_code %}\n                                \"\"\"\n                return HttpResponse(Template(template_string).render(context))\n    return HttpResponse(status=500)\ndashboard/views.py\nclass NewGraphRuleView(ManagersMixin, FormView):\n    \"\"\"\n    New Graph Rule View\n    \"\"\"\n    template_name = \"coverage/coverage_rule_new.html\"\n\n    def get_success_url(self):\n        return reverse('settings-graph-rules-new')\n\n    def get_initial(self):\n        initials = {}\n        initials.update(dict(rule_relbranch='main'))\n        return initials\n\n    def get_form(self, form_class=None, data=None):\n        kwargs = {}\n        pkgs = self.packages_manager.get_package_name_tuple(check_mapping=True)\n        langs = self.inventory_manager.get_locale_lang_tuple()\n        release_branches_tuple = \\\n            self.release_branch_manager.get_relbranch_name_slug_tuple()\n        b_tags = []\n        build_system_tags = self.inventory_manager.get_relstream_build_tags()\n        for release, tags in build_system_tags.items():\n            for tag in tags:\n                b_tags.append((tag, tag))\n        kwargs.update({'packages': pkgs})\n        kwargs.update({'languages': langs})\n        kwargs.update({'branches': release_branches_tuple})\n        kwargs.update({'tags': tuple(b_tags)})\n        kwargs.update({'initial': self.get_initial()})\n        if data:\n            kwargs.update({'data': data})\n        return NewGraphRuleForm(**kwargs)\n\n    def post(self, request, *args, **kwargs):\n        post_data = {k: v[0] if len(v) == 1 else v for k, v in request.POST.lists()}\n        form = self.get_form(data=post_data)\n        post_params = form.cleaned_data\n        # check for required params\n        required_params = ('rule_name', 'rule_relbranch', 'rule_packages',\n                           'tags_selection', 'lang_selection')\n        if not set(required_params) <= set(post_params.keys()):\n            return render(request, self.template_name, {'form': form})\n        elif post_params.get('tags_selection') == 'pick' and post_params.get('rule_build_tags'):\n            post_params['rule_build_tags'] = []\n        elif post_params.get('tags_selection') == 'select' and not post_params.get('rule_build_tags'):\n            errors = form._errors.setdefault('rule_build_tags', ErrorList())\n            errors.append(\"Please select build tags to be included in coverage rule.\")\n            return render(request, self.template_name, {'form': form})\n        elif post_params.get('lang_selection') == 'select' and not post_params.get('rule_langs'):\n            errors = form._errors.setdefault('rule_langs', ErrorList())\n            errors.append(\"Please select languages to be included in coverage rule.\")\n            return render(request, self.template_name, {'form': form})\n        rule_slug = self.graph_manager.slugify_graph_rule_name(post_params['rule_name'])\n        if not rule_slug:\n            errors = form._errors.setdefault('rule_name', ErrorList())\n            errors.append(\"This name cannot be slugify. Please try again.\")\n        pkgs_not_participate = self.graph_manager.validate_package_branch_participation(\n            post_params['rule_relbranch'], post_params['rule_packages']\n        )\n        if pkgs_not_participate and len(pkgs_not_participate) >= 1:\n            errors = form._errors.setdefault('rule_packages', ErrorList())\n            err_msg = (\"Translation progress of \" + pkgs_not_participate[0] +\n                       \" is not being tracked for \" + post_params['rule_relbranch'])\n            errors.append(err_msg)\n        tags_not_participate = self.graph_manager.validate_tags_product_participation(\n            post_params['rule_relbranch'], post_params['rule_build_tags']\n        )\n        if tags_not_participate and len(tags_not_participate) >= 1:\n            errors = form._errors.setdefault('rule_build_tags', ErrorList())\n            err_msg = (\"Build Tag \" + tags_not_participate[0] + \" does not belong to \" +\n                       post_params['rule_relbranch'] + \" release.\")\n            errors.append(err_msg)\n        if rule_slug and not pkgs_not_participate and not tags_not_participate:\n            post_params['rule_name'] = rule_slug\n            active_user = getattr(request, 'user', None)\n            if active_user:\n                post_params['created_by'] = active_user.email\n            if not self.graph_manager.add_graph_rule(**post_params):\n                messages.add_message(request, messages.ERROR, (\n                    'Alas! Something unexpected happened. Please try adding your rule again!'\n                ))\n            else:\n                messages.add_message(request, messages.SUCCESS, (\n                    'Great! Coverage rule added successfully.'\n                ))\n            return HttpResponseRedirect(self.get_success_url())\n        return render(request, self.template_name, {'form': form, 'POST': 'invalid'})\ndashboard/views.py\nclass PackageSettingsView(ManagersMixin, ListView):\n    \"\"\"\n    Packages Settings View\n    \"\"\"\n    template_name = \"packages/package_list.html\"\n    context_object_name = 'packages'\n\n    def get_queryset(self):\n        return self.packages_manager.get_packages()\ndashboard/views.py\nclass PipelinesView(ManagersMixin, ListView):\n    \"\"\"\n    Pipelines View\n    \"\"\"\n    template_name = \"ci/list_pipelines.html\"\n    context_object_name = 'pipelines'\n\n    def get_queryset(self):\n        tenant_releases = \\\n            self.release_branch_manager.get_release_branches(relstream=self.request.tenant)\n        active_pipelines = self.ci_pipeline_manager.get_ci_pipelines(releases=tenant_releases)\n        return active_pipelines.order_by('ci_package_id').order_by('ci_release_id')\ndashboard/views.py\ndef get_build_tags(request):\n    \"\"\"\n    Get Build System Tags\n    \"\"\"\n    if request.is_ajax():\n        post_params = request.POST.dict()\n        product_build = post_params.get('buildsys', '')\n        product_slug, build_system = tuple(product_build.split('-'))\n        inventory_manager = InventoryManager()\n        tags = inventory_manager.get_build_tags(\n            build_system, product_slug\n        )\n        if tags:\n            context = Context(\n                {'META': request.META,\n                 'build_tags': tags,\n                 'product': product_slug,\n                 'buildsys': build_system}\n            )\n            template_string = \"\"\"\n                                {% load tag_build_tags from custom_tags %}\n                                {% tag_build_tags buildsys product %}\n                            \"\"\"\n            return HttpResponse(Template(template_string).render(context))\n    return HttpResponse(status=500)\ndashboard/views.py\nclass YMLBasedJobs(JobsView):\n    \"\"\"\n    YML Based Jobs View\n    \"\"\"\n    template_name = \"jobs/jobs_yml_based.html\"\ndashboard/views.py\ndef tabular_data(request):\n    \"\"\"\n    Prepares and dispatch tabular data\n    \"\"\"\n    if request.is_ajax():\n        post_params = request.POST.dict()\n        if 'package' in request.POST.dict():\n            context = Context(\n                {'META': request.META,\n                 'package_name': post_params['package']}\n            )\n            template_string = \"\"\"\n                {% load tag_tabular_form from custom_tags %}\n                {% tag_tabular_form package_name %}\n            \"\"\"\n            return HttpResponse(Template(template_string).render(context))\n    return HttpResponse(status=500)\ndashboard/views.py\nclass JobsView(ManagersMixin, TemplateView):\n    \"\"\"\n    Predefined Jobs View\n    \"\"\"\n    template_name = \"jobs/jobs_home.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(JobsView, self).get_context_data(**kwargs)\n        jobs_count, last_ran_on, last_ran_type = \\\n            self.jobs_log_manager.get_joblog_stats()\n        context['jobs_count'] = jobs_count\n        context['job_last_ran_on'] = last_ran_on\n        context['job_last_ran_type'] = last_ran_type\n        packages = self.packages_manager.get_package_name_tuple()\n        if packages:\n            context['packages'] = packages\n        return context\ndashboard/views.py\nclass UpdateGraphRuleView(ManagersMixin, SuccessMessageMixin, UpdateView):\n    \"\"\"\n    Update Graph Rule view\n    \"\"\"\n    template_name = 'coverage/coverage_rule_update.html'\n    model = GraphRule\n    slug_field = 'rule_name'\n    form_class = UpdateGraphRuleForm\n    success_message = '%(rule_name)s was updated successfully!'\n\n    def get(self, request, *args, **kwargs):\n        if kwargs.get('slug') and not request.user.is_staff:\n            rule = self.graph_manager.get_graph_rules(graph_rule=kwargs['slug'],\n                                                      only_active=True).get()\n            if not rule.created_by == request.user.email and \\\n                    not request.user.is_superuser:\n                raise PermissionDenied\n        return super(UpdateGraphRuleView, self).get(request, *args, **kwargs)\n\n    def get_success_url(self):\n        return reverse('graph-rule-update', args=[self.kwargs['slug']])\ndashboard/views.py\nclass AddCIPipeline(ManagersMixin, FormView):\n    \"\"\"\n    Add CI Pipeline View\n    \"\"\"\n    template_name = 'ci/add_pipeline.html'\n    success_message = '%(ci_pipeline_uuid)s was added successfully!'\n\n    def get(self, request, *args, **kwargs):\n        if not request.user.is_staff:\n            raise PermissionDenied\n        return super(AddCIPipeline, self).get(request, *args, **kwargs)\n\n    def get_form(self, form_class=None, data=None):\n\n        def _sort_choices_by_name(choices):\n            \"\"\"\n            sort choices by name of a form field\n            :param choices: list of tuples\n            :return: sorted list of tuples\n            \"\"\"\n            return sorted(choices, key=lambda choice: choice[1])\n\n        kwargs = {}\n        ci_platforms = self.inventory_manager.get_translation_platforms(ci=True)\n        ci_platform_choices = tuple([(platform.platform_id, platform.__str__)\n                                     for platform in ci_platforms])\n        kwargs.update(dict(ci_platform_choices=ci_platform_choices))\n        packages = self.packages_manager.get_packages()\n        releases = self.release_branch_manager.get_release_branches()\n        package_choices = tuple([(package.package_id, package.package_name) for package in packages])\n        release_choices = tuple([(release.release_id, release.__str__) for release in releases])\n        kwargs.update(dict(package_choices=_sort_choices_by_name(package_choices)))\n        kwargs.update(dict(release_choices=release_choices))\n        if data:\n            kwargs.update({'data': data})\n        return CreateCIPipelineForm(**kwargs)\n\n    def get_success_url(self):\n        return reverse('add-ci-pipeline')\n\n    def post(self, request, *args, **kwargs):\n        post_data = {k: v[0] if len(v) == 1 else v for k, v in request.POST.lists()}\n        form = self.get_form(data=post_data)\n\n        context_data = dict()\n        context_data['form'] = form\n\n        if form.is_valid():\n            post_params = form.cleaned_data\n            # Assumption: Project URL starts with Platform API URL (which is saved in db)\n            if post_params['ci_platform'].api_url not in post_params['ci_project_web_url']:\n                errors = form._errors.setdefault('ci_project_web_url', ErrorList())\n                errors.append(\"Project URL does NOT belong to the selected platform.\")\n                return render(request, self.template_name, context=context_data)\n            if post_params['ci_release'] not in self.packages_manager.get_package_releases(\n                    package_name=post_params['ci_package'].package_name):\n                errors = form._errors.setdefault('ci_release', ErrorList())\n                errors.append(\"Release does NOT belong to the selected package.\")\n                return render(request, self.template_name, context=context_data)\n            p_uuid, p_details = self.ci_pipeline_manager.ci_platform_project_details(\n                post_params['ci_platform'], post_params['ci_project_web_url']\n            )\n            if not p_details:\n                errors = form._errors.setdefault('ci_project_web_url', ErrorList())\n                errors.append(\"Project details could not be fetched for the given URL.\")\n                return render(request, self.template_name, context=context_data)\n            post_params['ci_project_details_json_str'] = json.dumps(p_details)\n            if p_details.get('project_jobs'):\n                post_params['ci_platform_jobs_json_str'] = json.dumps(p_details['project_jobs'])\n            if not self.ci_pipeline_manager.save_ci_pipeline(post_params):\n                messages.add_message(request, messages.ERROR, (\n                    'Alas! Something unexpected happened. Please try adding pipeline again!'\n                ))\n            else:\n                messages.add_message(request, messages.SUCCESS, (\n                    'Great! CI Pipeline added successfully.'\n                ))\n            return HttpResponseRedirect(self.get_success_url())\n        return render(request, self.template_name, context=context_data)\ndashboard/views.py\nclass TerritoryView(ManagersMixin, TemplateView):\n    \"\"\"\n    Territory View\n    \"\"\"\n    template_name = \"geolocation/territory_view.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(TerritoryView, self).get_context_data(**kwargs)\n        country_name = self.request.GET.get('name', '')\n        if country_name:\n            context['country_name'] = country_name\n        territory_locales, territory_languages, two_char_country_code = \\\n            self.geo_location_manager.get_locales_from_territory_id(\n                kwargs.get('country_code', '')\n            )\n        if two_char_country_code:\n            context['two_char_country_code'] = two_char_country_code\n        if territory_locales and territory_languages:\n            territory_locale_language = dict(zip(territory_locales,\n                                                 territory_languages))\n            context['territory_locales'] = territory_locale_language\n        territory_timezones = \\\n            self.geo_location_manager.get_timezones_from_territory_id(\n                kwargs.get('country_code', '')\n            )\n        if territory_timezones:\n            context['territory_timezones'] = territory_timezones\n        keyboards, input_methods = \\\n            self.geo_location_manager.get_keyboards_from_territory_id(\n                kwargs.get('country_code', '')\n            )\n        if keyboards:\n            context['territory_keyboards'] = keyboards\n        if input_methods:\n            context['territory_input_methods'] = input_methods\n        return context\ndashboard/views.py\ndef graph_data(request):\n    \"\"\"\n    Prepares and dispatch graph data\n    \"\"\"\n    graph_dataset = {}\n    if request.is_ajax():\n        graph_manager = GraphManager()\n        if 'package' in request.POST.dict() and 'locale' in request.POST.dict():\n            package = request.POST.dict().get('package')\n            locale = request.POST.dict().get('locale')\n            graph_dataset = graph_manager.get_stats_by_pkg_per_lang(package, locale)\n        elif 'package' in request.POST.dict():\n            package = request.POST.dict().get('package')\n            graph_dataset = graph_manager.get_trans_stats_by_package(package)\n        elif 'graph_rule' in request.POST.dict():\n            graph_rule = request.POST.dict().get('graph_rule')\n            graph_dataset = graph_manager.get_trans_stats_by_rule(graph_rule)\n    return JsonResponse(graph_dataset)\ndashboard/views.py\nclass DeleteGraphRuleView(DeleteView):\n    \"\"\"\n    Delete Graph Rule View\n    \"\"\"\n    template_name = 'coverage/coverage_rule_delete.html'\n    model = GraphRule\n    slug_field = 'rule_name'\n    success_url = reverse_lazy('settings-graph-rules')\n\n    def get_object(self, queryset=None):\n\n        obj = super(DeleteGraphRuleView, self).get_object()\n        if not obj.created_by == self.request.user.email and \\\n                not self.request.user.is_superuser:\n            raise PermissionDenied\n        return obj\ndashboard/views.py\ndef get_target_langs(request):\n    \"\"\"\n    Get Target Languages for a CI Pipeline\n    :param request: Request object\n    :return: HttpResponse object\n    \"\"\"\n    if not request.is_ajax():\n        return HttpResponse(\"Not an Ajax Call\", status=400)\n\n    post_params = request.POST.dict()\n    ci_pipeline = post_params.get('ci_pipeline', '')\n    context = Context(\n        {'META': request.META,\n         'ci_pipeline': ci_pipeline}\n    )\n    template_string = \"\"\"\n                        {% load tag_target_langs from custom_tags %}\n                        {% tag_target_langs ci_pipeline %}\n                    \"\"\"\n    return HttpResponse(Template(template_string).render(context))\ndashboard/views.py\nclass NewTransPlatformView(SuccessMessageMixin, CreateView):\n    \"\"\"\n    New TransPlatform view\n    \"\"\"\n    template_name = \"platforms/platform_new.html\"\n    form_class = NewTransPlatformForm\n    success_message = '%(platform_slug)s was added successfully!'\n\n    def get_success_url(self):\n        return reverse('transplatform-new')\ndashboard/views.py\nclass TransPlatformSettingsView(ManagersMixin, ListView):\n    \"\"\"\n    Translation Platform Settings View\n    \"\"\"\n    template_name = \"platforms/platform_list.html\"\n    context_object_name = 'platforms'\n\n    def get_queryset(self):\n        return self.inventory_manager.get_translation_platforms()\n\n    def get_context_data(self, **kwargs):\n        context = super(TransPlatformSettingsView, self).get_context_data(**kwargs)\n        platforms_set = self.inventory_manager.get_transplatforms_set()\n        if isinstance(platforms_set, tuple):\n            active_platforms, inactive_platforms = platforms_set\n            context['active_platforms_len'] = len(active_platforms)\n            context['inactive_platforms_len'] = len(inactive_platforms)\n        # Join supported platform names with ',' and make it titlecase\n        context['transplatform_engines'] = ', '.join(TRANSPLATFORM_ENGINES).title()\n        return context\ndashboard/views.py\nclass AddPackageCIPipeline(ManagersMixin, FormView):\n    \"\"\"\n    Add Package CI Pipeline View\n    \"\"\"\n    template_name = 'ci/add_pipeline.html'\n    success_message = '%(ci_pipeline_uuid)s was added successfully!'\n\n    def get(self, request, *args, **kwargs):\n        if kwargs.get('slug') and not request.user.is_staff:\n            pkg = self.packages_manager.get_packages(pkgs=[kwargs['slug']]).get()\n            if not pkg.created_by == request.user.email and \\\n                    not request.user.is_superuser:\n                raise PermissionDenied\n        return super(AddPackageCIPipeline, self).get(request, *args, **kwargs)\n\n    def get_context_data(self, **kwargs):\n        context_data = super(AddPackageCIPipeline, self).get_context_data(**kwargs)\n        if self.kwargs.get(\"slug\"):\n            context_data[\"package_name\"] = self.kwargs.get(\"slug\")\n        return context_data\n\n    def get_form(self, form_class=None, data=None):\n        kwargs = {}\n        ci_platforms = self.inventory_manager.get_translation_platforms(ci=True)\n        ci_platform_choices = tuple([(platform.platform_id, platform.__str__)\n                                     for platform in ci_platforms])\n        kwargs.update(dict(ci_platform_choices=ci_platform_choices))\n        pkg_releases = self.packages_manager.get_package_releases(\n            package_name=self.kwargs['slug']\n        )\n        pkg_release_choices = tuple([(release.release_id, release.__str__)\n                                     for release in pkg_releases])\n        kwargs.update(dict(pkg_release_choices=pkg_release_choices))\n        if data:\n            kwargs.update({'data': data})\n        return NewCIPipelineForm(**kwargs)\n\n    def get_success_url(self):\n        return reverse('package-add-ci-pipeline', args=[self.kwargs.get('slug')])\n\n    def post(self, request, *args, **kwargs):\n        post_data = {k: v[0] if len(v) == 1 else v for k, v in request.POST.lists()}\n        form = self.get_form(data=post_data)\n\n        context_data = dict()\n        context_data['form'] = form\n        package_name = self.kwargs.get('slug')\n        context_data.update(dict(package_name=package_name))\n\n        if form.is_valid():\n            post_params = form.cleaned_data\n            # Assumption: Project URL starts with Platform API URL (which is saved in db)\n            if post_params['ci_platform'].api_url not in post_params['ci_project_web_url']:\n                errors = form._errors.setdefault('ci_project_web_url', ErrorList())\n                errors.append(\"Project URL does NOT belong to the selected platform.\")\n                return render(request, self.template_name, context=context_data)\n            post_params['ci_package'] = self.packages_manager.get_packages(\n                pkgs=[package_name]).get()\n            p_uuid, p_details = self.ci_pipeline_manager.ci_platform_project_details(\n                post_params['ci_platform'], post_params['ci_project_web_url']\n            )\n            if not p_details:\n                errors = form._errors.setdefault('ci_project_web_url', ErrorList())\n                errors.append(\"Project details could not be fetched for the given URL.\")\n                return render(request, self.template_name, context=context_data)\n            post_params['ci_project_details_json_str'] = json.dumps(p_details)\n            if p_details.get('project_jobs'):\n                post_params['ci_platform_jobs_json_str'] = json.dumps(p_details['project_jobs'])\n            if not self.ci_pipeline_manager.save_ci_pipeline(post_params):\n                messages.add_message(request, messages.ERROR, (\n                    'Alas! Something unexpected happened. Please try adding pipeline again!'\n                ))\n            else:\n                messages.add_message(request, messages.SUCCESS, (\n                    'Great! CI Pipeline added successfully.'\n                ))\n            return HttpResponseRedirect(self.get_success_url())\n        return render(request, self.template_name, context=context_data)\ndashboard/views.py\nclass UpdateLanguageView(SuccessMessageMixin, UpdateView):\n    \"\"\"\n    Update language view\n    \"\"\"\n    template_name = 'languages/language_update.html'\n    model = Language\n    form_class = UpdateLanguageForm\n    success_message = '%(lang_name)s was updated successfully!'\n\n    def get_success_url(self):\n        return reverse('language-update', args=[self.object.locale_id])\ndashboard/views.py\nclass JobDetailView(DetailView):\n    \"\"\"\n    Job Log Detail View\n    \"\"\"\n    template_name = \"jobs/log_detail.html\"\n    context_object_name = 'log'\n    model = Job\n    slug_field = 'job_uuid'\n    slug_url_kwarg = 'job_id'\ndashboard/views.py\nclass LanguageDetailView(ManagersMixin, DetailView):\n    \"\"\"\n    Languages Detail View\n    \"\"\"\n    template_name = \"languages/language_view.html\"\n    context_object_name = 'language'\n    model = Language\n    slug_field = 'locale_id'\n    slug_url_kwarg = 'locale_id'\n\n    def get_context_data(self, **kwargs):\n        context = super(LanguageDetailView, self).get_context_data(**kwargs)\n        locale_lang_tuple = self.inventory_manager.get_locale_lang_tuple()\n        release_summary = self.reports_manager.get_reports('releases')\n        if release_summary:\n            release_summary = release_summary.get()\n        language_teams = \\\n            self.inventory_manager.get_platform_language_team_contact(\n                kwargs['object'].locale_id\n            )\n        if language_teams:\n            context[\"language_teams\"] = language_teams\n        context[\"locale_lang\"] = locale_lang_tuple\n        if release_summary:\n            release_report_json = release_summary.report_json\n            if self.request.tenant in RELSTREAM_SLUGS:\n                release_report_json = {k: v for k, v in release_summary.report_json.items()\n                                       if self.request.tenant.lower() in v.get('slug').lower()}\n            context[\"release_summary\"] = release_report_json\n            context[\"last_updated\"] = release_summary.report_updated\n        return context\ndashboard/views.py\nclass UpdateTransPlatformView(SuccessMessageMixin, UpdateView):\n    \"\"\"\n    Update TransPlatform view\n    \"\"\"\n    template_name = \"platforms/platform_update.html\"\n    form_class = UpdateTransPlatformForm\n    success_message = '%(platform_slug)s was updated successfully!'\n    model = Platform\n    slug_field = 'platform_slug'\n\n    def get_success_url(self):\n        return reverse('transplatform-update', args=[self.object.platform_slug])\ndashboard/views.py\ndef refresh_ci_pipeline(request):\n    \"\"\"\n    Refresh CI Pipeline\n    :param request: Request object\n    :return: HttpResponse object\n    \"\"\"\n    if not request.is_ajax():\n        return HttpResponse(\"Not an Ajax Call\", status=400)\n    post_params = request.POST.dict()\n    package_owner = post_params.get('user', '')\n    ci_pipeline_id = post_params.get('pipeline_id', '')\n    if not package_owner and not ci_pipeline_id:\n        return HttpResponse(\"Invalid Parameters\", status=422)\n    ci_pipeline_manager = CIPipelineManager()\n    if ci_pipeline_manager.refresh_ci_pipeline(ci_pipeline_id):\n        return HttpResponse(\"Pipeline successfully refreshed.\", status=202)\n    return HttpResponse(status=500)\ndashboard/views.py\ndef read_file_logs(request):\n    message = ''\n    if request.is_ajax():\n        post_params = request.POST.dict()\n        job_params = [str(param).upper() for param in ast.literal_eval(post_params.get('params', ''))]\n        job_manager = YMLBasedJobManager(\n            **{'params': job_params, 'type': post_params.get('job', 'YMLbasedJob')}\n        )\n        suffix = job_manager.job_suffix(\n            [post_params.get(param, '') for param in job_params][:3]\n        )\n        log_file_path = job_manager.job_log_file + \".%s.%s\" % (suffix, job_manager.type)\n        log_file = Path(log_file_path)\n        if log_file.is_file():\n            with open(log_file_path) as f:\n                content = f.readlines()\n                content = [x.strip() for x in content]\n                message = \"<br/>\".join(content)\n    return HttpResponse(message)\ndashboard/views.py\nclass TranStatusPackageView(ManagersMixin, TemplateView):\n    \"\"\"\n    Translation Status Package View\n    \"\"\"\n    template_name = \"packages/package_view.html\"\n\n    def get(self, request, *args, **kwargs):\n        response = super(TranStatusPackageView, self).get(\n            request, *args, **kwargs)\n        if not self.packages_manager.is_package_exist(\n                kwargs.get('package_name', '')):\n            raise Http404(\"Package does not exist.\")\n        return response\n\n    def get_context_data(self, **kwargs):\n        \"\"\"\n        Build the Context Data\n        \"\"\"\n        context = super(TranStatusPackageView, self).get_context_data(**kwargs)\n        packages = self.packages_manager.get_package_name_tuple()\n        langs = self.inventory_manager.get_locale_lang_tuple()\n        if packages:\n            context['packages'] = packages\n        if langs:\n            context['languages'] = sorted(langs, key=lambda x: x[1])\n        return context\ndashboard/views.py\nclass UpdatePackageView(ManagersMixin, SuccessMessageMixin, UpdateView):\n    \"\"\"\n    Update Package view\n    \"\"\"\n    template_name = 'packages/package_update.html'\n    model = Package\n    slug_field = 'package_name'\n    form_class = UpdatePackageForm\n    success_message = '%(package_name)s was updated successfully!'\n\n    def get(self, request, *args, **kwargs):\n        if kwargs.get('slug') and not request.user.is_staff:\n            pkg = self.packages_manager.get_packages(pkgs=[kwargs['slug']]).get()\n            if not pkg.created_by == request.user.email and \\\n                    not request.user.is_superuser:\n                raise PermissionDenied\n        return super(UpdatePackageView, self).get(request, *args, **kwargs)\n\n    def get_success_url(self):\n        return reverse('package-update', args=[self.object.package_name])\ndashboard/views.py\nclass ReleasePipelinesView(ManagersMixin, ListView):\n    \"\"\"\n    Release Pipelines View\n    \"\"\"\n    template_name = \"ci/list_pipelines.html\"\n    context_object_name = 'pipelines'\n\n    def get_queryset(self):\n        tenant_releases = \\\n            self.release_branch_manager.get_release_branches(relstream=self.request.tenant)\n        active_pipelines = self.ci_pipeline_manager.get_ci_pipelines(releases=tenant_releases)\n        return active_pipelines.filter(\n            ci_release__release_slug=self.kwargs['release_slug']\n        ).order_by('ci_package__package_name')\ndashboard/views.py\ndef refresh_package(request):\n    \"\"\"\n    Package sync and re-build mappings\n    \"\"\"\n    if request.is_ajax():\n        post_params = request.POST.dict()\n        package_manager = PackagesManager()\n        task_type = post_params.get('task', '')\n        if task_type == \"mapBranches\" and post_params.get('package'):\n            ERR_MSG = \"Something unexpected happened while mapping branches.\"\n            try:\n                if package_manager.build_branch_mapping(post_params['package']):\n                    context = Context(\n                        {'META': request.META,\n                         'package_name': post_params['package']}\n                    )\n                    template_string = \"\"\"\n                        {% load tag_branch_mapping from custom_tags %}\n                        {% tag_branch_mapping package_name %}\n                    \"\"\"\n                    return HttpResponse(Template(template_string).render(context))\n            except Exception as e:\n                return HttpResponse(status=500, content=ERR_MSG, content_type=\"text/html\")\n        elif task_type == \"latestBuilds\" and post_params.get('package'):\n            ERR_MSG = \"Something unexpected happened while fetching latest builds.\"\n            try:\n                if package_manager.fetch_latest_builds(post_params['package']):\n                    context = Context(\n                        {'META': request.META, 'package_name': post_params['package']}\n                    )\n                    template_string = \"\"\"\n                        {% load tag_latest_builds from custom_tags %}\n                        {% tag_latest_builds package_name %}\n                    \"\"\"\n                    return HttpResponse(Template(template_string).render(context))\n            except Exception as e:\n                return HttpResponse(status=500, content=ERR_MSG, content_type=\"text/html\")\n        elif task_type == \"statsDiff\" and post_params.get('package'):\n            graph_manager = GraphManager()\n            pkg = post_params['package']\n            package_stats = graph_manager.get_trans_stats_by_package(pkg)\n            ERR_MSG = \"Make sure all mapped versions/tags are sync'd for stats.\"\n            package_branch_mapping = graph_manager.package_manager.get_pkg_branch_mapping(pkg)\n            if package_stats and package_branch_mapping:\n                try:\n                    graph_manager.package_manager.calculate_stats_diff(\n                        pkg, package_stats, package_branch_mapping\n                    )\n                except Exception as e:\n                    return HttpResponse(status=500, content=ERR_MSG, content_type=\"text/html\")\n                else:\n                    context = Context(\n                        {'META': request.META,\n                         'package_name': post_params['package']}\n                    )\n                    template_string = \"\"\"\n                                        {% load tag_stats_diff from custom_tags %}\n                                        {% tag_stats_diff package_name %}\n                                    \"\"\"\n                    return HttpResponse(Template(template_string).render(context))\n            else:\n                return HttpResponse(status=500, content=ERR_MSG, content_type=\"text/html\")\n        elif task_type == \"syncPlatform\" and post_params.get('package'):\n            if package_manager.refresh_package(post_params['package']):\n                return HttpResponse(status=200)\n        elif task_type == \"details\" and post_params.get('package'):\n            context = Context(\n                {'META': request.META,\n                 'package_name': post_params['package'],\n                 'user': request.user}\n            )\n            template_string = \"\"\"\n                    {% load tag_package_details from custom_tags %}\n                    {% tag_package_details package_name user %}\n            \"\"\"\n            return HttpResponse(Template(template_string).render(context))\n    return HttpResponse(status=500)\ndashboard/views.py\ndef ajax_save_pipeline_config(request):\n    \"\"\"\n    Save Pipeline Configuration\n    :param request: Request object\n    :return: HttpResponse object\n    \"\"\"\n    if not request.is_ajax():\n        return HttpResponse(\"Not an Ajax Call\", status=400)\n\n    post_params = request.POST.dict().copy()\n    pipeline_package = post_params.get('package')\n    pipeline_repo_type = post_params.get('cloneType') or \\\n        post_params.get('downloadType') or \\\n        post_params.get('uploadType')\n    pipeline_repo_branch = post_params.get('cloneBranch') or \\\n        post_params.get('downloadBranch') or \\\n        post_params.get('uploadBranch')\n    pipeline_target_langs = post_params.get('downloadTargetLangs') or \\\n        post_params.get('uploadTargetLangs')\n    pipeline_config_manager = PipelineConfigManager()\n    pipeline_branches = [pipeline_repo_branch]\n    if pipeline_repo_branch == \"%RESPECTIVE%\":\n        pipeline_branches = pipeline_config_manager.package_manager.git_branches(\n            package_name=pipeline_package, repo_type=pipeline_repo_type\n        )\n    u_email = request.user.email\n    if pipeline_config_manager.process_save_pipeline_config(\n            pipeline_repo_type, pipeline_repo_branch, pipeline_branches,\n            pipeline_target_langs, u_email, **post_params\n    ):\n        return HttpResponse(\"Pipeline configuration saved.\", status=201)\n    return HttpResponse(\"Saving pipeline configuration failed.\", status=500)\ndashboard/views.py\ndef export_packages(request, **kwargs):\n    \"\"\"\n    Exports packages to CSV\n    \"\"\"\n    if request.method == 'GET' and kwargs.get('format', '') == 'csv':\n        file_name = \"ts-packages-%s.csv\" % datetime.today().strftime('%d-%m-%Y')\n        packages_manager = PackagesManager()\n        required_fields = ['package_name', 'upstream_url', 'platform_url',\n                           'products', 'release_branch_mapping']\n        packages = packages_manager.get_packages(pkg_params=required_fields)\n        response = HttpResponse(content_type='text/csv', status=200)\n        response['Content-Disposition'] = 'attachment; filename=\"' + file_name + '\"'\n        writer = csv.writer(response)\n        writer.writerow([field.replace('_', ' ').title() for field in required_fields])\n        for package in packages:\n            writer.writerow(\n                [package.package_name, package.upstream_url,\n                 package.platform_url, ', '.join(package.products),\n                 package.release_branch_mapping if package.release_branch_mapping\n                 else ''])\n        return response\n    return HttpResponse(status=500)\ndashboard/views.py\nclass LanguageReleaseView(ManagersMixin, TemplateView):\n    \"\"\"\n    Language Release View\n    \"\"\"\n\n    template_name = \"languages/language_release_view.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LanguageReleaseView, self).get_context_data(**kwargs)\n        language_query = \\\n            self.inventory_manager.get_locales(pick_locales=[kwargs['locale']])\n        if language_query:\n            context[\"language\"] = language_query.get()\n        return context\ndashboard/views.py\nclass PipelineDetailView(DetailView):\n    \"\"\"\n    Pipeline Detail View\n    \"\"\"\n    template_name = \"ci/pipeline_jobs.html\"\n    context_object_name = 'ci_pipeline'\n    model = CIPipeline\n    slug_field = 'ci_pipeline_uuid'\n    slug_url_kwarg = 'pipeline_id'\ndashboard/views.py\nclass GraphRulesSettingsView(ManagersMixin, ListView):\n    \"\"\"\n    Graph Rules Settings View\n    \"\"\"\n    template_name = \"coverage/coverage_rule_list.html\"\n    context_object_name = 'rules'\n\n    def get_queryset(self):\n        return self.graph_manager.get_graph_rules(only_active=True)\ndashboard/views.py\ndef ajax_run_pipeline_config(request):\n    \"\"\"\n    Save Pipeline Configuration\n    :param request: Request object\n    :return: HttpResponse object\n    \"\"\"\n    if not request.is_ajax():\n        return HttpResponse(\"Not an Ajax Call\", status=400)\n\n    post_params = request.POST.dict().copy()\n    pipeline_config_manager = PipelineConfigManager()\n    pipeline_config = pipeline_config_manager.get_pipeline_configs(\n        pipeline_config_ids=[post_params.get('pipeline_config_id')]).first()\n\n    job_log_id, message = \"\", \"Ok\"\n\n    for branch in pipeline_config.pipeline_config_repo_branches:\n        respective_job_template = pipeline_config_manager.get_job_action_template(\n            pipeline_config.ci_pipeline, pipeline_config.pipeline_config_event)\n\n        t_params = respective_job_template.job_template_params\n        job_data = {param.upper(): '' for param in t_params}\n        if '%RESPECTIVE%' in pipeline_config.pipeline_config_yaml:\n            pipeline_config.pipeline_config_yaml.replace('%RESPECTIVE%', branch)\n        job_data.update(dict(YML_FILE=pipeline_config.pipeline_config_yaml))\n\n        job_type = pipeline_config.pipeline_config_json.get('job', {}).get('type')\n        job_pkg = pipeline_config.pipeline_config_json.get('job', {}).get('package')\n        temp_path = 'false/{0}/'.format(\"-\".join([job_pkg, job_type, branch]))\n\n        if 'PACKAGE_NAME' in job_data:\n            job_data['PACKAGE_NAME'] = job_pkg\n        if 'REPO_BRANCH' in job_data:\n            job_data['REPO_BRANCH'] = branch\n\n        job_manager = YMLBasedJobManager(\n            **job_data, **{'params': [p.upper() for p in t_params],\n                           'type': job_type},\n            **{'active_user_email': request.user.email},\n            **{'sandbox_path': temp_path},\n            **{'job_log_file': temp_path + '.log'}\n        )\n\n        try:\n            if os.path.isdir(temp_path):\n                shutil.rmtree(temp_path)\n            os.mkdir(temp_path)\n            job_log_id = job_manager.execute_job()\n            message = \"&nbsp;&nbsp;<span class='pficon pficon-ok'></span>\" + \\\n                      \"&nbsp;<span class='text-success'>Success</span>. \" + \\\n                      \"See <a href='/jobs/log/{}/detail'>Log</a> and the History.\".format(\n                          str(job_log_id))\n        except Exception as e:\n            return HttpResponse(\"Something went wrong. See History.\", status=500)\n        finally:\n            shutil.rmtree(temp_path)\n    return HttpResponse(message, status=201)\ndashboard/views.py\nclass LanguagesSettingsView(ManagersMixin, ListView):\n    \"\"\"\n    Languages List View\n    \"\"\"\n    template_name = \"languages/language_list.html\"\n    context_object_name = 'locales'\n\n    def get_queryset(self):\n        return self.inventory_manager.get_locales()\n\n    def get_context_data(self, **kwargs):\n        context = super(LanguagesSettingsView, self).get_context_data(**kwargs)\n        locales_set = self.inventory_manager.get_locales_set()\n        language_sets = self.inventory_manager.get_langsets()\n        langset_color_dict = {}\n        for langset in language_sets:\n            langset_color_dict.update({langset.lang_set_slug: langset.lang_set_color})\n        locale_groups = self.inventory_manager.get_all_locales_groups()\n        if isinstance(locales_set, tuple) and len(locales_set) >= 3:\n            active_locales, inactive_locales, aliases = locales_set\n            context['active_locales_len'] = len(active_locales)\n            context['inactive_locales_len'] = len(inactive_locales)\n            context['aliases_len'] = len(aliases)\n            context['language_sets'] = language_sets\n            context['langset_color_dict'] = langset_color_dict\n            context['locale_groups'] = locale_groups\n        return context\ndashboard/views.py\ndef get_repo_branches(request):\n    \"\"\"\n    Get Repository Branch(es)\n    \"\"\"\n\n    if request.is_ajax():\n        post_params = request.POST.dict()\n        package = post_params.get('package', '')\n        repo_type = post_params.get('repoType', '')\n        context = Context(\n            {'META': request.META,\n             'package': package,\n             'repo_type': repo_type}\n        )\n        template_string = \"\"\"\n                            {% load tag_repo_branches from custom_tags %}\n                            {% tag_repo_branches package repo_type %}\n                        \"\"\"\n        return HttpResponse(Template(template_string).render(context))\n    return HttpResponse(status=500)\ndashboard/views.py\nclass JobsArchiveView(ManagersMixin, ListView):\n    \"\"\"\n    Archive List View\n    \"\"\"\n    template_name = \"jobs/archive.html\"\n    context_object_name = 'logs'\n\n    def get_queryset(self):\n        job_logs = self.jobs_log_manager.get_job_logs()\n        return job_logs[50:]\ndashboard/views.py\ndef change_lang_status(request):\n    \"\"\"\n    Enable or disable language. Checks the given parameters, if all parameters are correct then changes status\n    of the language. The request should be an ajax call having data in following format,\n\n        {'language': <locale_id>, 'status': <'enable'/'disable'>}\n\n    :param request: Request object\n    :returns: HttpResponse object\n    \"\"\"\n    if request.is_ajax():\n        post_params = request.POST.dict()\n        language = post_params.get('language', '')\n        new_lang_status = post_params.get('status', '')\n        inventory_manager = InventoryManager()\n        available_languages = [language.locale_id for language in inventory_manager.get_locales()]\n        if language and new_lang_status:\n            if language not in available_languages:\n                return HttpResponse('Language not available', status=422)\n            if new_lang_status not in ['enable', 'disable']:\n                return HttpResponse(\"Status should be 'enable' or 'disable'\", status=422)\n            try:\n                language_object = Language.objects.get(locale_id=language)\n                language_object.lang_status = True if new_lang_status == 'enable' else False\n                language_object.save()\n            except Exception as status_change_error:\n                return HttpResponse(\"Something went wrong.\", status=500)\n            else:\n                return HttpResponse(\"language {0}d successfully!\".format(new_lang_status), status=202)\n        else:\n            return HttpResponse(\"Parameters missing\", status=422)\n    else:\n        return HttpResponse(\"Not an ajax call\", status=400)\ndashboard/views.py\nclass StreamBranchesSettingsView(ManagersMixin, TemplateView):\n    \"\"\"\n    Stream Branches Settings View\n    \"\"\"\n    template_name = \"releases/product_release_list.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(StreamBranchesSettingsView, self).get_context_data(**kwargs)\n        relstream_slug = kwargs.get('stream_slug')\n        if relstream_slug:\n            try:\n                release_stream = self.inventory_manager.get_release_streams(stream_slug=relstream_slug).get()\n                release_branches = self.release_branch_manager.get_release_branches(relstream=relstream_slug)\n            except:\n                raise Http404(\"Product does not exist.\")\n            else:\n                context['relstream'] = release_stream\n                context['relbranches'] = release_branches\n        return context\ndashboard/views.py\ndef release_graph(request):\n    \"\"\"\n    Generates release graph\n    \"\"\"\n    graph_dataset = {}\n    if request.is_ajax():\n        post_params = request.POST.dict()\n        if post_params.get('relbranch') and post_params.get('lang'):\n            context = Context(\n                {'META': request.META,\n                 'relbranch': post_params['relbranch'],\n                 'locale': post_params['lang']}\n            )\n            template_string = \"\"\"\n                {% load tag_workload_per_lang from custom_tags %}\n                {% tag_workload_per_lang relbranch locale %}\n            \"\"\"\n            return HttpResponse(Template(template_string).render(context))\n        elif post_params.get('relbranch') and post_params.get('combine'):\n            context = Context(\n                {'META': request.META,\n                 'relbranch': post_params['relbranch']}\n            )\n            template_string = \"\"\"\n                {% load tag_workload_combined from custom_tags %}\n                {% tag_workload_combined relbranch %}\n            \"\"\"\n            return HttpResponse(Template(template_string).render(context))\n        elif post_params.get('relbranch') and post_params.get('detail'):\n            context = Context(\n                {'META': request.META,\n                 'relbranch': post_params['relbranch']}\n            )\n            template_string = \"\"\"\n                {% load tag_workload_detailed from custom_tags %}\n                {% tag_workload_detailed relbranch %}\n            \"\"\"\n            return HttpResponse(Template(template_string).render(context))\n        elif post_params.get('relbranch') and post_params.get('threshold'):\n            context = Context(\n                {'META': request.META,\n                 'relbranch': post_params['relbranch'],\n                 'threshold': post_params['threshold']}\n            )\n            template_string = \"\"\"\n                {% load tag_threshold_based from custom_tags %}\n                {% tag_threshold_based relbranch threshold %}\n            \"\"\"\n            return HttpResponse(Template(template_string).render(context))\n        elif post_params.get('relbranch'):\n            graph_manager = GraphManager()\n            graph_dataset = graph_manager.get_workload_graph_data(post_params['relbranch'])\n    return JsonResponse(graph_dataset)\ndashboard/views.py\ndef ajax_toggle_pipeline_config(request):\n    \"\"\"\n    Toggle Pipeline Configuration\n    :param request: Request object\n    :return: HttpResponse object\n    \"\"\"\n    if not request.is_ajax():\n        return HttpResponse(\"Not an Ajax Call\", status=400)\n\n    post_params = request.POST.dict().copy()\n    pipeline_config_manager = PipelineConfigManager()\n    if pipeline_config_manager.toggle_pipeline_configuration(\n            pipeline_config_id=post_params.get('p_config_id')):\n        return HttpResponse(\"Ok\", status=204)\n    return HttpResponse(\"Something went wrong.\", status=500)\ndashboard/views.py\ndef get_workflow_steps(request):\n    \"\"\"\n    Get Workflow Steps for a CI Pipeline\n    :param request: Request object\n    :return: HttpResponse object\n    \"\"\"\n    if not request.is_ajax():\n        return HttpResponse(\"Not an Ajax Call\", status=400)\n\n    post_params = request.POST.dict()\n    ci_pipeline = post_params.get('ci_pipeline', '')\n    context = Context(\n        {'META': request.META,\n         'ci_pipeline': ci_pipeline}\n    )\n    template_string = \"\"\"\n                        {% load tag_workflow_steps_dropdown from custom_tags %}\n                        {% tag_workflow_steps_dropdown ci_pipeline %}\n                    \"\"\"\n    return HttpResponse(Template(template_string).render(context))\ndashboard/views.py\nclass JobsLogsPackageView(ManagersMixin, ListView):\n    \"\"\"\n    Logs List per Package View\n    \"\"\"\n    template_name = \"jobs/logs.html\"\n    context_object_name = 'logs'\n\n    def get_queryset(self):\n        job_logs = []\n        pkg_name = self.request.resolver_match.kwargs.get('package_name')\n        if pkg_name:\n            job_logs = self.jobs_log_manager.get_job_logs(\n                remarks=pkg_name, result=True\n            )\n        return job_logs\n", "answers": ["    url(r'^workflow-steps$', get_workflow_steps, name=\"ajax-workflow-steps\"),"], "length": 5212, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "0248bac03f920e83efc114d842cbb4fe9c4e0f5ce207cd10"}
{"input": "package com.wanikani.androidnotifier.stats;\nimport java.util.Date;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Vector;\nimport android.content.res.Resources;\nimport android.view.View;\nimport com.wanikani.androidnotifier.MainActivity;\nimport com.wanikani.androidnotifier.MeterSpec;\nimport com.wanikani.androidnotifier.R;\nimport com.wanikani.androidnotifier.graph.HistogramChart;\nimport com.wanikani.androidnotifier.graph.HistogramPlot;\nimport com.wanikani.androidnotifier.graph.IconizableChart;\nimport com.wanikani.androidnotifier.graph.HistogramPlot.Sample;\nimport com.wanikani.wklib.Connection.Meter;\nimport com.wanikani.wklib.Item;\nimport com.wanikani.wklib.ItemLibrary;\nimport com.wanikani.wklib.Kanji;\nimport com.wanikani.wklib.Radical;\nimport com.wanikani.wklib.SRSLevel;\nimport com.wanikani.wklib.UserInformation;\nimport com.wanikani.wklib.Vocabulary;\n\n\n\n\n/* \n *  Copyright (c) 2013 Alberto Cuda\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npublic class ItemAgeChart implements NetworkEngine.Chart {\n\t\n\tprivate class ResourceData {\n\t\t\n\t\tMeter meter;\n\t\t\n\t\tEnumMap<SRSLevel, String> tags;\n\t\t\n\t\tEnumMap<SRSLevel, Integer> colors;\n\t\t\n\t\tString notEnoughData;\n\t\t", "context": "src/com/wanikani/androidnotifier/graph/HistogramPlot.java\npublic class HistogramPlot extends View {\n\n\tpublic static class Series {\n\t\t\n\t\tpublic String name;\n\t\t\n\t\tpublic int color;\n\t\t\n\t\tpublic Series (String name, int color)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.color = color;\n\t\t}\t\t\t\n\t\t\n\t\tpublic Series (int color)\n\t\t{\n\t\t\tthis.color = color;\n\t\t}\n\t\t\n\t\tpublic Series ()\n\t\t{\n\t\t\t/* empty */\n\t\t}\n\t\t\n\t\tpublic void set (String name, int color)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.color = color;\n\t\t}\t\t\t\t\t\n\t}\n\t\n\tpublic static class Sample {\n\t\t\n\t\tpublic Series series;\n\t\t\n\t\tpublic long value;\n\t\t\n\t\tpublic Sample (Series series, long value)\n\t\t{\n\t\t\tthis.series = series;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tpublic Sample (Series series)\n\t\t{\n\t\t\tthis.series = series;\n\t\t}\n\t\t\n\t\tpublic Sample ()\n\t\t{\n\t\t\t/* empty */\n\t\t}\t\t\n\t}\n\t\n\tpublic static class Samples {\n\t\t\n\t\tpublic String tag;\n\t\t\n\t\tpublic List<Sample> samples;\n\t\t\n\t\tpublic Samples (String tag)\n\t\t{\n\t\t\tthis.tag = tag;\n\t\t\tsamples = new Vector<Sample> ();\n\t\t}\n\t\t\n\t\tpublic long getTotal ()\n\t\t{\n\t\t\tlong ans;\n\t\t\t\n\t\t\tans = 0;\n\t\t\tfor (Sample s : samples)\n\t\t\t\tans += s.value;\n\t\t\t\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tpublic boolean isEmpty ()\n\t\t{\n\t\t\treturn getTotal () == 0;\n\t\t}\n\t\t\n\t}\n\t\t\n\t/**\n\t * The listener that intercepts motion and fling gestures.\n\t */\n\tprivate class GestureListener extends GestureDetector.SimpleOnGestureListener {\n\t\t\n\t\t@Override\n\t\tpublic boolean onDown (MotionEvent mev)\n\t\t{\n\t\t\tscroller.forceFinished (true);\n\t\t\tViewCompat.postInvalidateOnAnimation (HistogramPlot.this);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean onScroll (MotionEvent mev1, MotionEvent mev2, float dx, float dy)\n\t\t{\n\t\t\tstrictScroll |= dx != 0;\t\t\t\n\t\t\tvp.scroll ((int) dx, (int) dy);\n\t\t\tViewCompat.postInvalidateOnAnimation (HistogramPlot.this);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onFling (MotionEvent mev1, MotionEvent mev2, float vx, float vy)\n\t\t{\t\t\t\n\t\t\tstrictScroll |= vx != 0;\t\t\t\n\t\t\tscroller.forceFinished (true);\n\t\t\tscroller.fling (vp.getAbsPosition (), 0, (int) -vx, 0, 0, \n\t\t\t\t\t\t\tvp.barToAbsPosition (vp.bars) + 2000000, 0, 0);\n\t\t\tViewCompat.postInvalidateOnAnimation (HistogramPlot.this);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * A repository of all the sizes and measures. Currently no variables\n\t * can be customized, however I've kept them separated from their default\n\t * values, so allowing layouts to override these default is just a matter of adding\n\t * an attributes parser.\n\t */\n\tprivate static class Measures {\n\t\t\n\t\t/// Default margin around the diagram\n\t\tpublic float DEFAULT_MARGIN = 24;\n\t\t\n\t\t/// Default number of pixels per bar\n\t\tpublic float DEFAULT_DIP_PER_BAR = 20;\n\t\t\t\t\n\t\t/// Default gap between bars\n\t\tpublic float DEFAULT_GAP = 8;\n\t\t\n\t\t/// Default label font size\n\t\tpublic float DEFAULT_DATE_LABEL_FONT_SIZE = 12;\n\t\t\n\t\t/// Default axis width\n\t\tpublic int DEFAULT_AXIS_WIDTH = 2;\n\t\t\n\t\t/// Default space between axis and label\n\t\tpublic int DEFAULT_HEADROOM = 10;\n\t\t\n\t\t/// Default number of items represented by a vertical mark\n\t\tpublic int DEFAULT_YAXIS_GRID = 100;\n\n\t\t/// The plot area\n\t\tpublic RectF plotArea;\n\t\t\n\t\t/// The complete view area\n\t\tpublic RectF viewArea;\n\t\t\n\t\t/// Actual margin around the diagram\n\t\tpublic float margin;\n\t\t\n\t\t/// Actual number of pixels per bar\n\t\tpublic float dipPerBar;\n\t\t\n\t\t/// Actual gap between bars\n\t\tpublic float gap;\n\t\t\n\t\t/// Actual label font size\n\t\tpublic float axisWidth;\n\t\t\n\t\t/// Actual space between axis and label\n\t\tpublic int headroom = 10;\n\n\t\t/// Actual font siz\n\t\tpublic float dateLabelFontSize;\n\t\t\n\t\t/// Actual number of items represented by a vertical mark\n\t\tpublic int yaxisGrid;\n\t\t\t\t\n\t\t/**\n\t\t * Constructor\n\t\t * @param ctxt the context \n\t\t * @param attrs attributes of the plot. Currently ignored\n\t\t */\n\t\tpublic Measures (Context ctxt, AttributeSet attrs)\n\t\t{\n\t\t\tDisplayMetrics dm;\n\t\t\tTypedArray a;\n\t\t\t\n\t\t\ta = ctxt.obtainStyledAttributes (attrs, R.styleable.HistogramPlot);\n\t\t\t\t \t\t\t\t\t\t\t\t\n\t\t\tdm = ctxt.getResources ().getDisplayMetrics ();\n\t\t\t\n\t\t\tmargin = DEFAULT_MARGIN;\n\t\t\tdipPerBar = DEFAULT_DIP_PER_BAR;\n\t\t\tgap = DEFAULT_GAP;\n\t\t\taxisWidth = DEFAULT_AXIS_WIDTH;\n\t\t\theadroom = DEFAULT_HEADROOM;\n\t\t\tdateLabelFontSize = DEFAULT_DATE_LABEL_FONT_SIZE;\n\t\t\tyaxisGrid = a.getInteger (R.styleable.HistogramPlot_ticks, DEFAULT_YAXIS_GRID);\n\t\t\t\n\t\t\tdateLabelFontSize = TypedValue.applyDimension (TypedValue.COMPLEX_UNIT_SP, \n\t\t\t\t\t \t\t\t\t\t\t\t\t\t   dateLabelFontSize, dm);\n\t\t\t\n\t\t\ta.recycle ();\t\t\n\n\t\t\tupdateSize (new RectF ());\n\t\t}\n\t\t\n\t\tpublic void updateLabelPaint (Paint paint)\n\t\t{\n\t\t\tdipPerBar = paint.measureText (\" 999 \");\n\t\t}\n\n\t\t/**\n\t\t * Called when the plot changes it size. Updates the inner plot rect\n\t\t * @param rect the new plot size\n\t\t */\n\t\tpublic void updateSize (RectF rect)\n\t\t{\n\t\t\tviewArea = new RectF (rect);\n\t\t\tplotArea = new RectF (rect);\n\t\t\t\n\t\t\tplotArea.top += margin;\n\t\t\tplotArea.bottom -= margin;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Makes sure that the margin is large enough to display the time axis labels.\n\t\t * @param mm minimum margin\n\t\t */\n\t\tpublic void ensureFontMargin (long mm)\n\t\t{\n\t\t\tmargin = mm + headroom;\n\t\t\tupdateSize (viewArea);\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * A collection of all the paint objects that will be needed when drawing\n\t * on the canvas. We create them beforehand and recycle them for performance\n\t * reasons.\n\t */\n\tprivate static class PaintAssets {\n\n\t\t/// Paint used to draw the axis\n\t\tPaint axisPaint;\n\n\t\t/// Paint used to draw the grids\t\t\t\t\n\t\tPaint gridPaint;\n\t\t\n\t\t/// Paint used to draw labels\n\t\tPaint labelPaint;\n\t\t\n\t\t/// Paint used to draw total amount\n\t\tPaint levelupPaint;\n\t\t\n\t\t/// Paint used to draw total amount, when drawn inside the bar\n\t\tPaint levelupPaintInside;\n\n\t\t/// Series to paint map\n\t\tMap<Series, Paint> series;\n\t\t\n\t\t/**\n\t\t * Constructor. Creates all the paints, using the chart attributes and\n\t\t * measures\n\t\t * @param res the resources\n\t\t * @param attrs the chart attributes\n\t\t * @param meas measures object\n\t\t */\n\t\tpublic PaintAssets (Resources res, AttributeSet attrs, Measures meas)\n\t\t{\n\t\t\tFontMetrics fm;\n\t\t\tfloat points [];\n\t\t\t\n\t\t\taxisPaint = new Paint ();\n\t\t\taxisPaint.setColor (Color.BLACK);\n\t\t\taxisPaint.setStrokeWidth (meas.axisWidth);\n\t\t\t\n\t\t\tpoints = new float [] { 1, 1 };\n\t\t\tgridPaint = new Paint ();\n\t\t\tgridPaint.setColor (Color.BLACK);\n\t\t\tgridPaint.setPathEffect (new DashPathEffect (points, 0));\n\t\t\t\n\t\t\tlevelupPaint = new Paint ();\n\t\t\tlevelupPaint.setColor (res.getColor (R.color.levelup));\n\t\t\tlevelupPaint.setTextAlign (Paint.Align.CENTER);\n\t\t\tlevelupPaint.setTextSize ((int) meas.dateLabelFontSize);\n\t\t\tlevelupPaint.setAntiAlias (true);\n\t\t\t\n\t\t\tlevelupPaintInside = new Paint ();\n\t\t\tlevelupPaintInside.setColor (Color.WHITE);\n\t\t\tlevelupPaintInside.setTextAlign (Paint.Align.CENTER);\n\t\t\tlevelupPaintInside.setTextSize ((int) meas.dateLabelFontSize);\n\t\t\tlevelupPaintInside.setAntiAlias (true);\n\n\t\t\tlabelPaint = new Paint ();\n\t\t\tlabelPaint.setColor (Color.BLACK);\n\t\t\tlabelPaint.setTextAlign (Paint.Align.CENTER);\n\t\t\tlabelPaint.setTextSize ((int) meas.dateLabelFontSize);\n\t\t\tlabelPaint.setAntiAlias (true);\n\t\t\tmeas.updateLabelPaint (labelPaint);\n\t\t\t\n\t\t\tfm = labelPaint.getFontMetrics ();\n\t\t\tmeas.ensureFontMargin ((int) (fm.bottom - fm.ascent));\t\t\t\n\t\t\t\n\t\t\tseries = new Hashtable<Series, Paint> ();\n\t\t}\t\t\n\t\t\n\t\t/**\n\t\t * Called when the series set changes. Recreates the mapping between\n\t\t * series and paint objects\n\t\t * @param series the new series\n\t\t */\n\t\tpublic void setSeries (List<Series> series)\n\t\t{\n\t\t\tPaint p;\n\t\t\t\n\t\t\tthis.series.clear ();\n\t\t\tfor (Series s : series) {\n\t\t\t\tp = new Paint ();\n\t\t\t\tp.setColor (s.color);\n\t\t\t\tp.setStyle (Paint.Style.FILL_AND_STROKE);\n\t\t\t\tp.setAntiAlias (true);\n\t\t\t\tthis.series.put (s, p);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * This object tracks the position of the interval of the plot which is\n\t * currently visible.\n\t */\n\tprivate static class Viewport {\n\t\t\n\t\t/// The measure object\n\t\tMeasures meas;\n\t\t\n\t\t/// The first (leftmost) tag \n\t\tfloat t0;\n\t\t\n\t\t/// The last (rightmost) tag\n\t\tfloat t1;\n\t\t\n\t\t/// Size of interval (<tt>t1-t0</tt>) \n\t\tfloat interval;\n\t\t\n\t\t/// Max value of Y axis\n\t\tlong yMax;\n\t\t\n\t\t/// Y scale\n\t\tfloat yScale;\n\t\t\n\t\t/// Number of bars\n\t\tint bars;\n\t\t\n\t\t/**\n\t\t * Constructor\n\t\t * @param meas the measure object\n\t\t * @param bars the number of bars\n\t\t * @param yMax max value of Y axis\n\t\t */\n\t\tpublic Viewport (Measures meas, int bars, long yMax)\n\t\t{\t\t\t\n\t\t\tthis.meas = meas;\n\t\t\tthis.bars = bars;\n\t\t\tthis.yMax = yMax;\n\t\t\t\n\t\t\tt1 = bars;\n\t\t\t\n\t\t\tupdateSize ();\n\t\t}\n\t\t\t\t\n\t\t/**\n\t\t * Called when the plot area changes\n\t\t */\n\t\tpublic void updateSize ()\n\t\t{\n\t\t\tboolean firstRun;\n\t\t\t\n\t\t\tfirstRun = interval == 0;\n\t\t\t\n\t\t\tinterval = meas.plotArea.width () / (meas.dipPerBar + meas.gap);\n\t\t\tyScale = meas.plotArea.height () / yMax;\n\t\t\tif (!firstRun)\n\t\t\t\tt0 = t1 - interval;\n\t\t\t\n\t\t\tadjust ();\n\t\t}\n\t\t\n\t\t/**\n\t\t * Updates the lower and upper edges after the viewport is resized \n\t\t */\n\t\tprivate void adjust ()\n\t\t{\n\t\t\tif (t0 < 0)\n\t\t\t\tt0 = 0;\n\t\t\telse if (t0 > bars - interval)\n\t\t\t\tt0 = bars - interval;\n\n\t\t\tt1 = t0 + interval;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Returns the number of pixels between the left margin of the viewport\n\t\t * and the first bar. Of course these pixels are not displayed because they\n\t\t * are outside the viewport.\n\t\t * @return the number of pixels\n\t\t */\n\t\tpublic int getAbsPosition ()\n\t\t{\n\t\t\treturn barToAbsPosition (t0);\n\t\t}\n\t\t\n\t\t/**\n\t\t * Moves the viewport, putting its left margin at a number of pixels to\n\t\t * the right of first bar\n\t\t * @param pos the new position\n\t\t */\n\t\tpublic void setAbsPosition (int pos)\n\t\t{\n\t\t\tsetBar (absPositionToBar (pos));\n\t\t}\n\t\t\n\t\t/**\n\t\t * Moves the viewport, putting its left margin on the left of a given bar\n\t\t * @param bar the bar\n\t\t */\n\t\tpublic void setBar (float bar)\n\t\t{\n\t\t\tt0 = bar;\n\t\t\tt1 = t0 + interval;\n\t\t\tadjust ();\n\t\t}\n\t\t\n\t\t\n\t\t/**\n\t\t * Returns the number of pixels between the leftmost bar and a given bar\n\t\t * @param bar a bar\n\t\t * @return the number of pixels\n\t\t */\n\t\tpublic int getRelPosition (int bar)\n\t\t{\n\t\t\treturn (int) ((bar - t0) * (meas.dipPerBar + meas.gap));\n\t\t}\n\t\t\n\t\t/**\n\t\t * Converts item numbers to pixel\n\t\t * @param y item numbers\n\t\t * @return the number of pixel\n\t\t */\n\t\tpublic float getY (float y)\n\t\t{\n\t\t\treturn meas.plotArea.bottom - y * yScale;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Scrolls the viewport by a given interval\n\t\t * @param dx the horizontal interval\n\t\t * @param dy the vertical interval (ignored)\n\t\t */\n\t\tpublic void scroll (int dx, int dy)\n\t\t{\n\t\t\tsetAbsPosition (getAbsPosition () + dx);\n\t\t}\n\n\t\t/**\n\t\t * Returns the number of pixels between a given day and the\n\t\t * day of subscription.\n\t\t * @param bar a bar\n\t\t * @return the number of pixels\n\t\t */\n\t\tpublic int barToAbsPosition (float bar)\n\t\t{\n\t\t\treturn (int) (bar * (meas.dipPerBar + meas.gap));\n\t\t}\n\t\t\n\t\t/**\n\t\t * Returns the day, given the number of pixels from subscription day\n\t\t * @param pos number of pixels\n\t\t * @return the bar number\n\t\t */\n\t\tpublic float absPositionToBar (int pos)\n\t\t{\n\t\t\treturn ((float) pos) / (meas.dipPerBar + meas.gap);\n\t\t}\n\t\t\n\t\t/**\n\t\t * A floor operation that always points to -inf.\n\t\t * @param d a number \n\t\t * @return the floor\n\t\t */\n\t\tprivate int floor (float d)\n\t\t{\n\t\t\treturn (int) (d > 0 ? Math.floor (d) : Math.ceil (d));\n\t\t}\n\t\t\n\t\t/**\n\t\t * A ceil operation that always points to +inf.\n\t\t * @param d a number \n\t\t * @return the ceil\n\t\t */\n\t\tprivate int ceil (float d)\n\t\t{\n\t\t\treturn (int) (d > 0 ? Math.ceil (d) : Math.floor (d));\n\t\t}\n\n\t\t/**\n\t\t * Returns the rightmost complete bar represented in this viewport.\n\t\t * This differs from {@link #t1} because it is an integer\n\t\t * @return the bar\n\t\t */\n\t\tpublic int rightmostBar ()\n\t\t{\n\t\t\treturn floor (t1);\n\t\t}\n\t\t\n\t\t/**\n\t\t * Returns the leftmost complete bar represented in this viewport.\n\t\t * This differs from {@link #t0} because it is an integer\n\t\t * @return the bar\n\t\t */\n\t\tpublic int leftmostBar ()\n\t\t{\n\t\t\treturn ceil (t0);\n\t\t}\n\t\t\n\t}\n\t\t\t\n\t/// The scroller object that tracks fling gestures\n\tprivate Scroller scroller;\n\t\n\t/// The android gesture detector\n\tprivate GestureDetector gdect;\n\t\n\t/// Our gesture listener\n\tprivate GestureListener glist;\n\t\n\t/// The measure object\n\tprivate Measures meas;\n\t\n\t/// The current viewport\n\tprivate Viewport vp;\n\t\n\t/// The paint objects\n\tprivate PaintAssets pas;\n\t\n\t/// <tt>true</tt> during fling gestures\n\tprivate boolean scrolling;\n\t\n\tprivate boolean strictScroll;\n\t\n\tprivate boolean drawTotal;\n\t\n\t/// The actual data\n\tprivate List<Samples> bars;\n\t\n\t/**\n\t * Constructor\n\t * @param ctxt the context\n\t * @param attrs the attributes\n\t */\n\tpublic HistogramPlot (Context ctxt, AttributeSet attrs)\n\t{\n\t\tsuper (ctxt, attrs);\n\t\t\n\t\tscroller = new Scroller (ctxt);\n\t\tglist = new GestureListener ();\n\t\tgdect = new GestureDetector (ctxt, glist);\n\t\t\n\t\tloadAttributes (ctxt, attrs);\n\t}\n\t\t\n\t/**\n\t * Constructs the objects that use attributes.\n\t * @param ctxt the context\n\t * @param attrs the attributes\n\t */\n\tvoid loadAttributes (Context ctxt, AttributeSet attrs)\n\t{\t\t\t\t\n\t\tTypedArray a;\n\n\t\tmeas = new Measures (ctxt, attrs);\n\t\tpas = new PaintAssets (getResources (), attrs, meas);\n\t\t\n\t\ta = ctxt.obtainStyledAttributes (attrs, R.styleable.HistogramPlot);\n\t\tdrawTotal = a.getBoolean (R.styleable.HistogramPlot_drawTotal, true);\n\t\ta.recycle ();\n\t}\n\t\t\n\t/**\n\t * Sets the data samples.\n\t * @param series a list of series that will be referenced by <tt>data</tt> \n\t * @param bars a list of samples, each representing a bar\n\t * @param cap maximum Y value admitted (may be smaller if bars are smaller than that)\n\t */\n\tpublic void setData (List<Series> series, List<Samples> bars, long cap)\n\t{\n\t\tsetData (series, bars, cap, -1);\n\t}\n\n\t/**\n\t * Sets the data samples.\n\t * @param series a list of series that will be referenced by <tt>data</tt> \n\t * @param bars a list of samples, each representing a bar\n\t * @param cap maximum Y value admitted (may be smaller if bars are smaller than that)\n\t * @param bar which bar to align to (set it to a negative value not to align it)\n\t */\n\tpublic void setData (List<Series> series, List<Samples> bars, long cap, int bar)\n\t{\n\t\tpas.setSeries (series);\n\t\tvp = new Viewport (meas, bars.size (), getMaxY (bars, cap));\n\t\tif (bar >= 0)\n\t\t\tvp.setBar (bar);\n\t\tthis.bars = bars;\n\t\t\n\t\tinvalidate ();\n\t}\n\t\n\tstatic private long getMaxY (List<Samples> bars, long cap)\n\t{\n\t\tlong ans, current, rmax;\n\t\t\n\t\tans = rmax = 0;\n\t\tfor (Samples bar : bars) {\n\t\t\tcurrent = 0;\n\t\t\tfor (Sample s : bar.samples)\n\t\t\t\tcurrent += s.value;\n\t\t\tif (cap <= 0 || current < cap)\n\t\t\t\tans = Math.max (ans, current);\n\t\t\trmax = Math.max (rmax, current);\n\t\t}\n\t\t\n\t\treturn ans != 0 ? ans : rmax;\n\t}\n\n\t@Override\n\tpublic boolean onTouchEvent (MotionEvent mev)\n\t{\n\t\tboolean ans;\n\n\t\tswitch (mev.getAction ()) {\n\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\tscrolling = true;\n\t\t\tstrictScroll = false;\n\t\t\tbreak;\n\n\t\tcase MotionEvent.ACTION_UP:\n\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\tscrolling = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tans = gdect.onTouchEvent (mev);\n\t\t\n\t\treturn ans || super.onTouchEvent (mev);\n\t}\n\t\n\t@Override\n\tprotected void onSizeChanged (int width, int height, int ow, int oh)\n\t{\n\t\tmeas.updateSize (new RectF (0, 0, width, height));\n\t\tvp.updateSize ();\n\t\t\n\t\tinvalidate ();\n\t}\n\n\t@Override\n    public void computeScroll () \n\t{\n        super.computeScroll ();\n        \n        if (scroller.computeScrollOffset ()) {\n        \tvp.setAbsPosition (scroller.getCurrX ());\n\t\t\tViewCompat.postInvalidateOnAnimation (this);\n        }\n\t}\n\t\n\t@Override\n\tprotected void onDraw (Canvas canvas)\n\t{\t\t\t\n\t\tfloat left, right, tagLabelBaseline;\n\t\tint d, lo, hi, ascent;\n\t\tSamples bar;\n\t\t\n\t\tcanvas.drawLine (meas.plotArea.left, meas.plotArea.bottom,\n\t\t\t\t         meas.plotArea.right, meas.plotArea.bottom, pas.axisPaint);\n\t\tlo = vp.leftmostBar () - 1;\t/* We want broken bars too :) */\n\t\thi = vp.rightmostBar () + 1;\n\t\t\t\t\n\t\tascent = (int) pas.labelPaint.getFontMetrics ().ascent;\n\t\t\n\t\ttagLabelBaseline = meas.plotArea.bottom - ascent + meas.headroom / 2;\n\t\t\n\t\tfor (d = lo; d <= hi; d++) {\n\t\t\t\n\t\t\tif (d < 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (d >= bars.size ())\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tleft = vp.getRelPosition (d);\n\t\t\tright = left + vp.meas.dipPerBar;\n\t\t\tbar = bars.get (d);\n\n\t\t\tdrawBar (canvas, bar, left, right);\n\t\t\t\n\t\t\tcanvas.drawText (bar.tag, (left + right) / 2, tagLabelBaseline, pas.labelPaint);\n\t\t}\n\t\t\n\t\tif (meas.yaxisGrid > 0) {\n\t\t\tfor (d = meas.yaxisGrid; vp.getY (d) >= meas.plotArea.top; d += meas.yaxisGrid) {\n\t\t\t\tcanvas.drawLine (meas.plotArea.left, vp.getY (d), \n\t\t\t\t\t\t\t \tmeas.plotArea.right, vp.getY (d), pas.gridPaint);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected void drawBar (Canvas canvas, Samples bar, float left, float right)\n\t{\n\t\tlong base, height;\n\t\tfloat top, tbl;\n\t\tPaint lpaint;\n\t\tPaint paint;\n\t\tPath path;\n\t\tRectF rect;\n\t\t\n\t\ttop = vp.getY (vp.yMax);\n\t\tbase = 0;\n\t\tfor (Sample sample : bar.samples) {\n\t\t\tif (sample.value > 0) {\n\t\t\t\theight = sample.value;\n\t\t\t\t\n\t\t\t\tif (base > vp.yMax)\n\t\t\t\t\t;\n\t\t\t\telse if (base + height > vp.yMax) {\n\t\t\t\t\tpath = new Path ();\n\t\t\t\t\tpath.moveTo (left, vp.getY (base));\n\t\t\t\t\tpath.lineTo (left, top);\n\t\t\t\t\tpath.lineTo (left + (right - left) / 3, top - 10);\n\t\t\t\t\tpath.lineTo (left + (right - left) * 2 / 3, top + 5);\n\t\t\t\t\tpath.lineTo (right, top);\n\t\t\t\t\tpath.lineTo (right, vp.getY (base));\n\t\t\t\t\tpath.close ();\n\t\t\t\t\tcanvas.drawPath (path, pas.series.get (sample.series));\n\t\t\t\t} else {\t\t\t\t\n\t\t\t\t\trect = new RectF (left, vp.getY (base + height), right, vp.getY (base));\n\t\t\t\t\trect.intersect (meas.plotArea);\n\t\t\t\t\tpaint = pas.series.get (sample.series);\n\t\t\t\t\tpaint.setStyle (Style.FILL);\n\t\t\t\t\tcanvas.drawRect (rect, paint);\n\t\t\t\t\tpaint.setStyle (Style.STROKE);\n\t\t\t\t\tcanvas.drawRect (rect, paint);\n\t\t\t\t}\n\t\t\t\tbase += height;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (base <= vp.yMax) {\n\t\t\tlpaint = pas.levelupPaint;\n\t\t\ttbl = vp.getY (base) - meas.headroom / 2;\n\t\t} else {\n\t\t\tlpaint = pas.levelupPaintInside; \n\t\t\ttbl = vp.getY (vp.yMax) + meas.margin;\n\t\t}\n\t\t\t\t\t\n\t\tif (base > 0 && drawTotal)\n\t\t\tcanvas.drawText (Long.toString (base), (left + right) / 2, tbl, lpaint);\n\t}\n\t\n\t/**\n\t * True if scrolling \n\t * @return <tt>true</tt> if scrolling\n\t */\n\tpublic boolean scrolling (boolean strict)\n\t{\n\t\treturn scrolling && (!strict || strictScroll);\n\t}\n}\nsrc/com/wanikani/androidnotifier/graph/HistogramChart.java\npublic class HistogramChart extends IconizableChart {\n\n\t/// The real histogram\n\tHistogramPlot plot;\n\t\n\t/// The legend\n\tLinearLayout legend;\n\t\n\t/// The alert layout\n\tView alertPanel;\n\t\n\t/// The alert message\n\tTextView alertMessage;\n\t\n\t/**\n\t * Constructor. It only shows the spinner and the title, until \n\t * {@link #setData(List)} gets called.\n\t * @param ctxt context\n\t * @param attrs attributes\n\t */\n\tpublic HistogramChart (Context ctxt, AttributeSet attrs)\n\t{\n\t\tsuper (ctxt, attrs, R.layout.histogramchart);\n\t\t\t\n\t\tplot = (HistogramPlot) findViewById (R.id.hc_plot);\n\t\tlegend = (LinearLayout) findViewById (R.id.hc_legend);\n\t\talertPanel = findViewById (R.id.hc_lay_alert);\n\t\talertMessage = (TextView) findViewById (R.id.hc_alert);\n\t\t\n\t\tplot.loadAttributes (ctxt, attrs);\n\t}\n\t\n\t/**\n\t * Updates the plot with fresh data. Stops the spinner, if shown.\n\t * @param series the series\n\t * @param bars the values\n\t * @param cap the cap\n\t */\n\tpublic void setData (List<HistogramPlot.Series> series, List<HistogramPlot.Samples> bars, long cap)\n\t{\n\t\tsetData (series, bars, cap, -1);\n\t}\n\n\tpublic void setData (List<HistogramPlot.Series> series, List<HistogramPlot.Samples> bars, long cap, int bar)\n\t{\n\t\tLinearLayout item;\t\t\n\t\t\n\t\tplot.setData (series, bars, cap, bar);\n\t\t\n\t\tlegend.removeAllViews ();\n\t\tfor (HistogramPlot.Series s : series) {\n\t\t\tif (s.name != null) {\n\t\t\t\titem = (LinearLayout) inflater.inflate (R.layout.legend, null); \n\t\t\t\tcustomizeItem (item, s);\n\t\t\t\tlegend.addView (item);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdataAvailable ();\n\t}\t\n\t\n\t/**\n\t * Fills a new legend item.\n\t * @param item the item to fill\n\t * @param series the series the item shall describe\n\t */\n\t@SuppressWarnings (\"deprecation\")\n\tprotected void customizeItem (LinearLayout item, HistogramPlot.Series series)\n\t{\n\t\tDrawable tag;\n\t\t\n\t\ttag = new ColorDrawable (series.color);\n\t\titem.findViewById (R.id.leg_color).setBackgroundDrawable (tag);\n\t\t((TextView) item.findViewById (R.id.leg_description)).\n\t\t\tsetText (series.name);\n\t}\n\t\n\t/**\n\t * Tells if a scroll gesture is currently going on.\n\t * @return <tt>true</tt> if it is so\n\t */\n\tpublic boolean scrolling (boolean strict)\n\t{\n\t\treturn plot.scrolling (strict);\n\t}\n\t\n\t/**\n\t * Shows an alert message\n\t * @param msg the message\n\t * @param ocl the listener which receives an event when clicked\n\t */\n\tpublic void alert (String msg, View.OnClickListener ocl)\n\t{\n\t\tdataAvailable ();\n\t\talertPanel.setVisibility (View.VISIBLE);\n\t\talertMessage.setText (Html.fromHtml (\"<font color=\\\"blue\\\"><u>\" + msg + \"</u></font>\"));\n\t\talertMessage.setClickable (true);\n\t\talertMessage.setOnClickListener (ocl);\n\t}\n\t\n\t/**\n\t * Shows an alert message\n\t * @param msg the message\n\t */\n\tpublic void alert (String msg)\n\t{\n\t\tdataAvailable ();\n\t\talertPanel.setVisibility (View.VISIBLE);\n\t\talertMessage.setText (msg);\n\t\talertMessage.setClickable (false);\n\t}\n\n\tpublic void hideAlert ()\n\t{\n\t\talertPanel.setVisibility (View.GONE);\n\t}\n}\nsrc/com/wanikani/androidnotifier/graph/IconizableChart.java\npublic abstract class IconizableChart extends LinearLayout {\n\t\n\tpublic static interface DataSource {\n\t\t\n\t\tpublic void loadData ();\n\t\t\n\t\tpublic void flush ();\n\t\t\n\t}\n\t\n\tclass IconizeButtonListener implements View.OnClickListener {\n\t\t\n\t\t@Override\n\t\tpublic void onClick (View view)\n\t\t{\n\t\t\ttoggle ();\n\t\t}\n\t\t\n\t}\n\n\tprotected enum State {\n\t\t\n\t\tCLOSED  {\n\t\t\tpublic State evRefresh ()\n\t\t\t{\n\t\t\t\treturn ICONIZED_RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evToggle ()\n\t\t\t{\n\t\t\t\treturn RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evDataAvailable ()\n\t\t\t{\n\t\t\t\treturn ICONIZED;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evError ()\n\t\t\t{\n\t\t\t\treturn ERROR_ICONIZED;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean spinning ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpublic boolean canClose ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean isOpen ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\t\t\t\n\t\t},\n\t\t\n\t\tICONIZED_RETRIEVING  {\n\n\t\t\tpublic State evRefresh ()\n\t\t\t{\n\t\t\t\treturn ICONIZED_RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evToggle ()\n\t\t\t{\n\t\t\t\treturn RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evDataAvailable ()\n\t\t\t{\n\t\t\t\treturn ICONIZED;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evError ()\n\t\t\t{\n\t\t\t\treturn ERROR_ICONIZED;\n\t\t\t}\n\n\t\t\tpublic boolean spinning ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpublic boolean canClose ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpublic boolean isOpen ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\t\t\t\n\t\t},\n\t\t\n\t\tRETRIEVING  {\n\n\t\t\tpublic State evRefresh ()\n\t\t\t{\n\t\t\t\treturn RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evToggle ()\n\t\t\t{\n\t\t\t\treturn ICONIZED_RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evDataAvailable ()\n\t\t\t{\n\t\t\t\treturn OPEN;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evError ()\n\t\t\t{\n\t\t\t\treturn ERROR;\n\t\t\t}\n\n\t\t\tpublic boolean spinning ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpublic boolean canClose ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpublic boolean isOpen ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\t\t\t\n\t\t},\n\n\t\tICONIZED  {\n\n\t\t\tpublic State evRefresh ()\n\t\t\t{\n\t\t\t\treturn ICONIZED_RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evToggle ()\n\t\t\t{\n\t\t\t\treturn OPEN;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evDataAvailable ()\n\t\t\t{\n\t\t\t\treturn ICONIZED;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evError ()\n\t\t\t{\n\t\t\t\treturn ERROR_ICONIZED;\n\t\t\t}\n\n\t\t\tpublic boolean spinning ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpublic boolean canClose ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean isOpen ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\t\t\t\t\t\t\n\t\t},\n\t\t\n\t\tOPEN  {\n\n\t\t\tpublic State evRefresh ()\n\t\t\t{\n\t\t\t\treturn REFRESHING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evToggle ()\n\t\t\t{\n\t\t\t\treturn ICONIZED;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evDataAvailable ()\n\t\t\t{\n\t\t\t\treturn OPEN;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evError ()\n\t\t\t{\n\t\t\t\treturn ERROR;\n\t\t\t}\n\n\t\t\tpublic boolean spinning ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpublic boolean canClose ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean isOpen ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\t\t\t\t\t\t\n\t\t},\t\t\n\t\t\n\t\tERROR  {\n\n\t\t\tpublic State evRefresh ()\n\t\t\t{\n\t\t\t\treturn ICONIZED_RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evToggle ()\n\t\t\t{\n\t\t\t\treturn ERROR_ICONIZED;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evDataAvailable ()\n\t\t\t{\n\t\t\t\treturn OPEN;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evError ()\n\t\t\t{\n\t\t\t\treturn ERROR;\n\t\t\t}\n\n\t\t\tpublic boolean spinning ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpublic boolean canClose ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean isOpen ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\t\t\t\t\n\t\t\t\n\t\t\tpublic boolean isError ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\t\t\n\n\t\tERROR_ICONIZED  {\n\n\t\t\tpublic State evRefresh ()\n\t\t\t{\n\t\t\t\treturn ICONIZED_RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evToggle ()\n\t\t\t{\n\t\t\t\treturn ERROR;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evDataAvailable ()\n\t\t\t{\n\t\t\t\treturn ICONIZED;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evError ()\n\t\t\t{\n\t\t\t\treturn ERROR_ICONIZED;\n\t\t\t}\n\n\t\t\tpublic boolean spinning ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpublic boolean canClose ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean isOpen ()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\t\t\t\t\t\t\n\t\t},\n\n\t\tREFRESHING  {\n\n\t\t\tpublic State evRefresh ()\n\t\t\t{\n\t\t\t\treturn REFRESHING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evToggle ()\n\t\t\t{\n\t\t\t\treturn ICONIZED_RETRIEVING;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evDataAvailable ()\n\t\t\t{\n\t\t\t\treturn OPEN;\n\t\t\t}\n\t\t\t\n\t\t\tpublic State evError ()\n\t\t\t{\n\t\t\t\treturn ERROR;\n\t\t\t}\n\n\t\t\tpublic boolean spinning ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpublic boolean canClose ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean isOpen ()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\t\t\t\t\t\t\t\t\t\n\t\t};\n\t\t\n\t\tpublic abstract State evRefresh ();\n\t\t\n\t\tpublic abstract State evToggle ();\n\t\t\n\t\tpublic abstract State evDataAvailable ();\n\t\t\n\t\tpublic abstract State evError ();\n\t\t\n\t\tpublic abstract boolean spinning ();\n\t\t\n\t\tpublic abstract boolean canClose ();\n\t\t\n\t\tpublic abstract boolean isOpen ();\n\t\t\n\t\tpublic boolean isError ()\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\t\n\t/// The inflater\n\tLayoutInflater inflater;\n\t\n\t/// The caption\n\tView head;\n\t\n\t/// The chart title\n\tTextView title;\n\t\t\n\t/// A spinner, which is displayed when no data has been published yet\n\tProgressBar spinner;\n\t\n\t/// The actual contents\n\tView contents;\n\t\n\t/// Iconize button\n\tImageButton icb;\n\t\n\tState state;\n\t\n\t/// Expander open bitmap\n\tBitmap openBmp;\n\t\n\t/// Expander close bitmap\n\tBitmap closeBmp;\n\t\n\t/// Data has been requested yet\n\tboolean dataRequested;\n\t\n\t/// Data source\n\tDataSource dsource;\n\t\n\t/// Error panel\n\tTextView errorPanel;\n\t\n\t/**\n\t * Constructor. It only shows the spinner and the title, until \n\t * {@link #setData(List)} gets called.\n\t * @param ctxt context\n\t * @param attrs attributes\n\t * @param id the layout id\n\t */\n\tpublic IconizableChart (Context ctxt, AttributeSet attrs, int id)\n\t{\n\t\tsuper (ctxt, attrs);\n\t\t\t\n\t\tResources res;\n\t\t\n\t\tinflater = (LayoutInflater) \n\t\t\t\tctxt.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t\t\n\t\tinflater.inflate (id, this);\n\t\t\t\t\n\t\thead = findViewById (R.id.gt_head);\n\t\ttitle = (TextView) findViewById (R.id.gt_title);\n\t\tspinner = (ProgressBar) findViewById (R.id.gt_spinner);\n\t\tcontents = findViewById (R.id.gt_contents);\n\t\ticb = (ImageButton) findViewById (R.id.gt_button);\n\t\ticb.setOnClickListener (new IconizeButtonListener ());\n\t\t\n\t\terrorPanel = (TextView) findViewById (R.id.gt_error);\n\t\t\n\t\tres = getResources ();\n\t\topenBmp = BitmapFactory.decodeResource (res, R.drawable.expander_open);\n\t\tcloseBmp = BitmapFactory.decodeResource (res, R.drawable.expander_close);\n\t\t\n\t\tsetState (State.CLOSED);\n\t\t\n\t\tloadAttributes (ctxt, attrs);\n\t}\n\t\n\t/**\n\t * Performs the actual job of reading the attributes and updating \n\t * the look. Meant for cascading (which is not done at this stage).\n\t * @param ctxt the context\n\t * @param attrs the attributes\n\t */\n\tvoid loadAttributes (Context ctxt, AttributeSet attrs)\n\t{\n\t\tLinearLayout.LayoutParams params;\n\t\tTypedArray a;\n\t\tString tas;\n\t\t\t\t\n\t\ta = ctxt.obtainStyledAttributes (attrs, R.styleable.PieChart);\n\t\t\n\t\ttas = a.getString (R.styleable.PieChart_title);\n\t\tif (tas == null) {\n\t\t\tparams = (LinearLayout.LayoutParams) contents.getLayoutParams ();\n\t\t\tparams.setMargins (0, 0, 0, 0);\n\t\t\tcontents.setPadding (0, 0, 0, 0);\n\t\t\t\n\t\t\thead.setVisibility (View.GONE);\n\t\t\tsetOpen (true);\n\t\t} else\n\t\t\ttitle.setText (tas);\n\t\t\t\t\n\t\ta.recycle ();\n\t}\n\t\n\tprivate void setState (State state)\n\t{\n\t\tBitmap bmp;\n\n\t\tthis.state = state;\n\t\t\n\t\tbmp = (state.canClose ()) ? closeBmp : openBmp;\n\t\ticb.setImageBitmap (bmp);\n\t\t\n\t\tspinner.setVisibility (state.spinning () ? View.VISIBLE : View.GONE);\n\t\tcontents.setVisibility (state.isOpen () ? View.VISIBLE : View.GONE);\n\t\terrorPanel.setVisibility (state.isError () ? View.VISIBLE : View.GONE);\n\t}\n\t\n\tpublic void setOpen (boolean open)\n\t{\n\t\tif (open != state.isOpen ())\n\t\t\ttoggle ();\n\t}\n\t\n\tpublic boolean isOpen ()\n\t{\n\t\treturn state.canClose ();\n\t}\n\t\n\tprivate void toggle ()\n\t{\n\t\tsetState (state.evToggle ());\n\t\tif (!dataRequested) {\n\t\t\tdataRequested = true;\n\t\t\tloadData ();\n\t\t}\n\t}\n\t\n\tprotected void dataAvailable ()\n\t{\n\t\tsetState (state.evDataAvailable ());\n\t}\n\t\n\tprotected void startRefresh ()\n\t{\n\t\tsetState (state.evRefresh ());\n\t}\n\t\n\tpublic void flush ()\n\t{\n\t\tif (dsource != null)\n\t\t\tdsource.flush ();\n\t\tif (isOpen ()) {\n\t\t\tloadData ();\n\t\t\tsetState (state.evRefresh ());\n\t\t}\n\t}\n\t\n\tpublic void setDataSource (DataSource dsource)\n\t{\n\t\tthis.dsource = dsource;\n\t}\n\t\n\tprotected void loadData ()\n\t{\n\t\tif (dsource != null)\n\t\t\tdsource.loadData ();\n\t}\n\t\n\tpublic void setError ()\n\t{\n\t\tdataAvailable ();\n\t\tsetState (state.evError ());\n\t}\n\t\n\tpublic void setError (String msg)\n\t{\n\t\terrorPanel.setText (msg);\n\t\tsetError ();\n\t}\n}\nsrc/com/wanikani/wklib/Vocabulary.java\npublic class Vocabulary extends Item {\n\n\tprivate static class Factory implements Item.Factory<Vocabulary> {\n\n\t\tpublic Vocabulary deserialize (JSONObject obj)\n\t\t\tthrows JSONException\n\t\t{\n\t\t\treturn new Vocabulary (obj);\n\t\t}\n\t}\n\n\tprivate static class ItemFactory implements Item.Factory<Item> {\n\n\t\tpublic Vocabulary deserialize (JSONObject obj)\n\t\t\tthrows JSONException\n\t\t{\n\t\t\treturn new Vocabulary (obj);\n\t\t}\n\t}\n\n\tpublic static final long serialVersionUID = 1L;\t\n\n\tpublic final static Item.Factory<Vocabulary> FACTORY = new Factory ();\n\t\n\tpublic final static Item.Factory<Item> ITEM_FACTORY = new ItemFactory ();\n\n\tpublic String kana;\n\t\n\tpublic Vocabulary (JSONObject obj)\n\t\tthrows JSONException\n\t{\n\t\tsuper (obj, Item.Type.VOCABULARY);\n\t\t\n\t\tkana = Util.getString (obj, \"kana\");\n\t}\n\t\n\tpublic Vocabulary ()\n\t{\n\t\tsuper (Item.Type.VOCABULARY);\n\t}\n\t\t\t\t\n\tprotected String getClassURLComponent ()\n\t{\n\t\treturn \"vocabulary\";\n\t}\n\t\n\tpublic boolean matches (String s)\n\t{\n\t\treturn super.matches (s) ||\n\t\t\t\tkana.contains (s);\n\t}\n}\nsrc/com/wanikani/wklib/UserInformation.java\npublic class UserInformation {\n\n\tpublic String username;\n\t\n\tpublic String gravatar;\n\t\n\tpublic Bitmap gravatarBitmap;\n\t\n\tpublic int level;\n\t\n\tpublic String title;\n\t\n\tpublic String about;\n\t\n\tpublic String website;\n\t\n\tpublic String twitter;\n\t\n\tpublic int topicsCount;\n\t\n\tpublic int postsCount;\n\t\n\tpublic Date creationDate;\n\t\n\tpublic Date vacationDate;\n\t\n\tprivate static final long ONE_DAY = 24 * 60 * 60 * 1000;\n\t\n\tUserInformation (JSONObject obj)\n\t\tthrows JSONException\n\t{\n\t\tusername = Util.getString (obj, \"username\");\n\t\tgravatar = Util.getString (obj, \"gravatar\");\n\t\tlevel = Util.getInt (obj, \"level\");\n\t\ttitle = Util.getString (obj, \"title\");\n\t\tabout = Util.getString (obj, \"about\");\n\t\twebsite = Util.getString (obj, \"website\");\n\t\ttwitter = Util.getString (obj, \"twitter\");\n\t\ttopicsCount = Util.getInt (obj, \"topics_count\");\n\t\tpostsCount = Util.getInt (obj, \"posts_count\");\n\t\tcreationDate = Util.getDate (obj, \"creation_date\");\n\t\tvacationDate = Util.getDate (obj, \"vacation_date\");\n\t}\n\t\n\tprivate static Calendar getNormalizedCalendar (Date date)\n\t{\n\t\tCalendar ans;\n\t\t\n\t\tans = Calendar.getInstance ();\n\t\tans.setTime (date);\n\t\tans.set (Calendar.HOUR, 1);\n\t\tans.set (Calendar.MINUTE, 2);\n\t\tans.set (Calendar.SECOND, 3);\n\t\tans.set (Calendar.MILLISECOND, 4);\n\t\t\n\t\treturn ans;\n\t}\n\t\n\tpublic int getDay ()\n\t{\n\t\treturn getDay (new Date ());\n\t}\n\t\n\tpublic int getDay (Date d)\n\t{\n\t\treturn getDay (creationDate, d);\n\t}\n\t\n\tpublic static int getDay (Date origin, Date d)\n\t{\n\t\tCalendar cal1, cal2;\n\t\t\n\t\tcal1 = getNormalizedCalendar (origin);\n\t\tcal2 = getNormalizedCalendar (d);\n\t\treturn (int) ((cal2.getTimeInMillis () - cal1.getTimeInMillis ()) / ONE_DAY);\n\t}\n}\nsrc/com/wanikani/wklib/Connection.java\npublic interface Meter {\n\t\t\n\tpublic void count (int data);\n\t\t\n\tpublic void sync ();\n\t\t\n}\nsrc/com/wanikani/wklib/SRSLevel.java\npublic enum SRSLevel {\n\n\tAPPRENTICE, GURU, MASTER, ENLIGHTEN, BURNED;\n\t\n\tstatic Map<Integer, SRSLevel> omap;\n\t\n\tstatic {\n\t\tomap = new Hashtable<Integer, SRSLevel> ();\n\t\t\n\t\tfor (SRSLevel srs : EnumSet.allOf (SRSLevel.class))\n\t\t\tomap.put (srs.ordinal (), srs);\n\t}\n\t\n\tpublic static SRSLevel fromString (String s)\n\t{\n\t\tif (s.equals (\"apprentice\"))\n\t\t\treturn APPRENTICE;\n\t\telse if (s.equals (\"guru\"))\n\t\t\treturn GURU;\n\t\telse if (s.equals (\"master\"))\n\t\t\treturn MASTER;\n\t\telse if (s.equals (\"enlighten\"))\n\t\t\treturn ENLIGHTEN;\n\t\telse if (s.equals (\"burned\"))\n\t\t\treturn BURNED;\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static SRSLevel fromOrdinal (int ordinal)\n\t{\n\t\treturn omap.get (ordinal);\n\t}\n}\nsrc/com/wanikani/androidnotifier/MainActivity.java\npublic class MainActivity extends FragmentActivity implements Runnable {\n\t\n\t/**\n\t * The pager model. It also broadcasts requests to all the\n\t * tabs throught the @link Tab interface.\n\t */\n\tpublic class PagerAdapter extends FragmentPagerAdapter {\n        \n\t\t/// The tabs\n\t\tList<Tab> tabs;\n\t\t\n\t\t/**\n\t\t * Constructor.\n\t\t * @param fm the fragment manager\n\t\t * @param tabs the list of tabs\n\t\t */\n\t\tpublic PagerAdapter (FragmentManager fm, List<Tab> tabs) \n\t\t{\n\t\t\tsuper (fm);\n\t\t\t\n\t\t\tthis.tabs = tabs;\n\t    }\n\n\t\t @Override\n\t     public int getCount () \n\t\t {\n\t\t\t return tabs.size ();\n\t     }\n\n\t\t @Override\n\t     public Fragment getItem (int position) \n\t\t {\n\t         return (Fragment) tabs.get (position);\n\t     }\n\t\t \n\t\t @Override\n\t\t public CharSequence getPageTitle (int position) \n\t\t {\n\t\t\tResources res;\n\t\t\t\t\n\t\t\tres = getResources ();\n\t\t\t\t\n\t\t\treturn res.getString (tabs.get (position).getName ());\n\t\t }\n\t\t \n\t\t public void replace (Tab tab)\n\t\t {\n\t\t\t int i;\n\t\t\t \n\t\t\t for (i = 0; i < tabs.size (); i++)\n\t\t\t\t if (tabs.get (i).getClass ().equals (tab))\n\t\t\t\t\t tabs.set (i, tab);\n\t\t }\n\t\t \n\t\t /**\n\t\t  * Broadcasts the spin event, which is sent when data refresh\n\t\t  * is started or completed\n\t\t  * @see Tab#spin(boolean)\n\t\t  * @param enable if <code>true</code>, refresh is started\n\t\t  */\n\t\t public void spin (boolean enable)\n\t\t {\n\t\t\t for (Tab tab : tabs)\n\t\t\t\t tab.spin (enable);\n\t\t }\n\t\t \n\t\t /**\n\t\t  * Broadcasts the refresh-complete event, which is sent to the\n\t\t  * tabs, providing fresh dashboard data\n\t\t  * @see Tab#refreshComplete(DashboardData)\n\t\t  * @param dd dashboard data\n\t\t  */\n\t\t public void refreshComplete (DashboardData dd)\n\t\t {\n\t\t\t for (Tab tab : tabs)\n\t\t\t\t tab.refreshComplete (dd);\n\t\t }\n\t\t \n\t\t public void flushDatabase ()\n\t\t {\n\t\t\t for (Tab tab : tabs)\n\t\t\t\t tab.flushDatabase ();\n\t\t }\n\t\t \n\t\t /**\n\t\t  * Broadcasts the flush request, to clear all the tabs' caches \n\t\t  * @see Tab#flush()\n\t\t  * @param rtype the type of refresh\n\t\t  * @param idx the tab currently in foreground\n\t\t  */\n\t\t public void flush (Tab.RefreshType rtype, int idx)\n\t\t {\n\t\t\t Tab fgtab;\n\t\t\t \n\t\t\t if (conn != null) {\n\t\t\t\t switch (rtype) {\n\t\t\t\t case FULL_EXPLICIT:\t\t\t\t \n\t\t\t\t case FULL_IMPLICIT:\t\t\t\t \n\t\t\t\t\t conn.flush ();\n\t\t\t\t\t /* fall through */\n\t\t\t\t \n\t\t\t\t case MEDIUM:\t\t\t\t \t\t\t\t \n\t\t\t\t case LIGHT:\n\t\t\t\t }\n\t\t\t }\n\t\t\t \n\t\t\t fgtab = idx < 0 || idx >= tabs.size () ? null : tabs.get (idx);\n\n\t\t\t for (Tab tab : tabs)\n\t\t\t\t tab.flush (rtype, fgtab == tab);\t\t\t \n\t\t }\n\t\t \n\t\t /**\n\t\t  * Returns the index of a tab.\n\t\t  * @param c its contents\n\t\t  */\n\t\t public int getTabIndex (Tab.Contents c)\n\t\t {\n\t\t\t int i;\n\t\t\t \n\t\t\t for (i = 0; i < tabs.size (); i++)\n\t\t\t\t if (tabs.get (i).contains (c))\n\t\t\t\t\t return i;\n\t\t\t \n\t\t\t return -1;\n\t\t }\n\t\t \n\t\t public boolean backButton ()\n\t\t {\n\t\t\t int idx;\n\t\t\t \n\t\t\t idx = pager.getCurrentItem ();\n\t\t\t return idx >= 0 && idx < tabs.size () ?\n\t\t\t\t\t tabs.get (idx).backButton () : false;\n\t\t }\n    }\n\n\t/**\n\t * A receiver that gets notifications on several occasions:\n\t * <ul>\n\t * \t<li>@link {@link SettingsActivity#ACT_CREDENTIALS}: We need this\n\t * \t\t\tboth to update the credentials used to fill the stats\n\t * \t\t\tscreen, and to enable notifications if the user chose so.\n\t * \t<li>@link {@link SettingsActivity#ACT_NOTIFY}: Enable the notification\n\t * \t\t\tflag\n\t * \t<li>@link {@link #ACTION_REFRESH}: force a refresh onto the dashboard.\n\t *  <li>@link {@link #ACTION_CLEAR}: force a complete refresh (including stats)\n\t * </ul>\n\t * All the events that cause a refresh of dashboard data, will also\n\t * trigger a cache flush.\n\t */\n\tprivate class Receiver extends BroadcastReceiver {\n\t\t\n\t\t/**\n\t\t * Handles credentials change notifications\n\t\t * \t@param ctxt local context\n\t\t * \t@param i the intent\t\t\n\t\t */\n\t\t@Override\n\t\tpublic void onReceive (Context ctxt, Intent i)\n\t\t{\n\t\t\tTab.RefreshType rtype;\n\t\t\tUserLogin ul;\n\t\t\tString action;\n\t\t\t\n\t\t\t/* This check is meant to avoid a somehow strange race condition: \n\t\t\t * if a WebReviewActivity is started by tapping on the notification (i.e. the app is\n\t\t\t * NOT active), and is closed right before starting the MainActivity, the ACTION_REFRESH\n\t\t\t * is delivered by the wrong (dying) thread. This causes a ViewRoot$CalledFromWrongThreadException \n\t\t\t * It looks like an Android bug... but I'm not so sure. At any rate this check\n\t\t\t * does no harm\n\t\t\t */\n\t\t\tif (!Looper.getMainLooper ().equals (Looper.myLooper ()))\n\t\t\t\treturn;\n\t\t\t\n\t\t\taction = i.getAction ();\n\t\t\tif (action.equals (SettingsActivity.ACT_CREDENTIALS)) {\n\t\t\t\tul = new UserLogin (i.getStringExtra (SettingsActivity.E_USERKEY));\n\t\t\t\n\t\t\t\tupdateCredentials ();\t\t\t\t\n\t\t\t\tenableNotifications (i.getBooleanExtra (SettingsActivity.E_ENABLED, true));\n\t\t\t} else if (action.equals (SettingsActivity.ACT_NOTIFY))\n\t\t\t\tenableNotifications (i.getBooleanExtra (SettingsActivity.E_ENABLED, true));\t\t\t\n\t\t\telse if (action.equals (ACTION_REFRESH)) {\n\t\t\t\trtype = i.getBooleanExtra (E_FLUSH_CACHES, true) ? \n\t\t\t\t\t\tTab.RefreshType.FULL_IMPLICIT : Tab.RefreshType.MEDIUM;\n\t\t\t\trefresh (rtype);\n\t\t\t} else if (action.equals (ACTION_CLEAR))\n\t\t\t\tflushDatabase ();\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * A task that gets called whenever stats need to be refreshed.\n\t * In order to keep the GUI responsive, we do this through an AsyncTask\n\t */\n\tprivate class RefreshTask extends AsyncTask<Connection, Void, DashboardData > {\n\t\t\n\t\t/// The default \"turtle\" avatar\n\t\tBitmap defAvatar;\n\t\t\n\t\t/**\n\t\t * Called before starting the task, inside the activity thread.\n\t\t */\n\t\t@Override\n\t\tprotected void onPreExecute ()\n\t\t{\n\t\t\tDrawable d;\n\t\t\t\n\t\t\tstartRefresh ();\n\n\t\t\td = getResources ().getDrawable (R.drawable.default_avatar);\n\t\t\tdefAvatar = ((BitmapDrawable) d).getBitmap ();\n\t\t}\n\t\t\n\t\t/**\n\t\t * Performs the real job, by using the provided\n\t\t * connection to obtain the study queue.\n\t\t * \t@param conn a connection to the WaniKani API site\n\t\t */\n\t\t@Override\n\t\tprotected DashboardData doInBackground (Connection... conn)\n\t\t{\n\t\t\tConnection.Meter meter;\n\t\t\tDashboardData dd;\n\t\t\tUserInformation ui;\n\t\t\tStudyQueue sq;\n\t\t\tint size;\n\n\t\t\tsize = getResources ().getDimensionPixelSize (R.dimen.m_avatar_size);\n\t\t\tmeter = MeterSpec.T.DASHBOARD_REFRESH.get (MainActivity.this);\n\t\t\ttry {\n\t\t\t\tsq = conn [0].getStudyQueue (meter);\n\t\t\t\t/* getUserInformation should be called after at least one\n\t\t\t\t * of the other calls, so we give Connection a chance\n\t\t\t\t * to cache its contents */\n\t\t\t\tui = conn [0].getUserInformation (meter);\n\t\t\t\tconn [0].resolve (meter, ui, size, defAvatar);\n\n\t\t\t\tdd = new DashboardData (ui, sq);\n\t\t\t\tif (dd.gravatar != null)\n\t\t\t\t\tsaveAvatar (dd);\n\t\t\t\telse\n\t\t\t\t\trestoreAvatar (dd);\n\t\t\t} catch (IOException e) {\n\t\t\t\tdd = new DashboardData (e);\n\t\t\t}\n\t\t\t\n\t\t\treturn dd;\n\t\t}\t\n\t\t\t\t\t\t\n\t\t/**\n\t\t * Called at completion of the job, inside the Activity thread.\n\t\t * Updates the stats and the status page.\n\t\t * \t@param dd the results encoded by \n\t\t *\t\t{@link #doInBackground(Connection...)}\n\t\t */\n\t\t@Override\n\t\tprotected void onPostExecute (DashboardData dd)\n\t\t{\n\t\t\ttry {\n\t\t\t\tdd.wail ();\n\t\t\t\t\n\t\t\t\trefreshComplete (dd, true);\n\t\t\t\t\n\t\t\t\tnew RefreshTaskPartII ().execute (conn);\n\t\t\t} catch (AuthenticationException e) {\n\t\t\t\terror (R.string.status_msg_unauthorized);\n\t\t\t} catch (IOException e) {\n\t\t\t\terror (R.string.status_msg_error);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * A task that gets called whenever the stats need to be refreshed, part II.\n\t * This task retrieves all the data that is not needed to display the dashboard,\n\t * so it can be run after the splash screen disappears (and the startup is faster). \n\t */\n\tprivate class RefreshTaskPartII extends AsyncTask<Connection, Void, DashboardData.OptionalData> {\n\n\t\t/**\n\t\t * Called before starting the task, inside the activity thread.\n\t\t */\n\t\t@Override\n\t\tprotected void onPreExecute ()\n\t\t{\n\t\t\t/* empty */\n\t\t}\n\t\t\n\t\t/**\n\t\t * Performs the real job, by using the provided\n\t\t * connection to obtain the SRS distribution and the LevelProgression.\n\t\t * If any operation goes wrong, the data is simply not retrieved (this\n\t\t * is meant to be data of lesser importance), so it should be ok anyway.\n\t\t * \t@param conn a connection to the WaniKani API site\n\t\t */\n\t\t@Override\n\t\tprotected DashboardData.OptionalData doInBackground (Connection... conn)\n\t\t{\n\t\t\tDashboardData.OptionalDataStatus srsStatus, lpStatus, ciStatus;\n\t\t\tSRSDistribution srs;\n\t\t\tExtendedLevelProgression elp;\n\t\t\tItemLibrary<Item> critical;\n\t\t\tint cis;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tsrs = conn [0].getSRSDistribution(MeterSpec.T.DASHBOARD_REFRESH.get (MainActivity.this));\n\t\t\t\tsrsStatus = DashboardData.OptionalDataStatus.RETRIEVED;\n\t\t\t} catch (IOException e) {\n\t\t\t\tsrs = null;\n\t\t\t\tsrsStatus = DashboardData.OptionalDataStatus.FAILED;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\telp = conn [0].getExtendedLevelProgression (MeterSpec.T.DASHBOARD_REFRESH.get (MainActivity.this));\n\t\t\t\tlpStatus = DashboardData.OptionalDataStatus.RETRIEVED;\n\t\t\t} catch (IOException e) {\n\t\t\t\telp = null;\n\t\t\t\tlpStatus = DashboardData.OptionalDataStatus.FAILED;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcritical = conn [0].getCriticalItems (MeterSpec.T.DASHBOARD_REFRESH.get (MainActivity.this));\n\t\t\t\tciStatus = DashboardData.OptionalDataStatus.RETRIEVED;\n\t\t\t\tcis = critical.list.size ();\n\t\t\t} catch (IOException e) {\n\t\t\t\tciStatus = DashboardData.OptionalDataStatus.FAILED;\n\t\t\t\tcis = 0;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\treturn new DashboardData.OptionalData (srs, srsStatus, elp, lpStatus, cis, ciStatus);\n\t\t}\t\n\t\t\t\t\t\t\n\t\t/**\n\t\t * Called at completion of the job, inside the Activity thread.\n\t\t * Updates the stats and the status page.\n\t\t * \t@param dd the results encoded by \n\t\t *\t\t{@link #doInBackground(Connection...)}\n\t\t */\n\t\t@Override\n\t\tprotected void onPostExecute (DashboardData.OptionalData od)\n\t\t{\n\t\t\t/* Data may disappear when we get an unauthorized code */\n\t\t\tif (dd != null) {\n\t\t\t\tdd.setOptionalData (od);\n\t\t\t\n\t\t\t\trefreshComplete (dd, false);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * The listener of menu-related events. We intercept the refresh request\n\t * and deliver the event to the main class\n\t */\n\tprivate class MenuListener extends MenuHandler.Listener {\n\t\t\n\t\tpublic MenuListener ()\n\t\t{\n\t\t\tsuper (MainActivity.this);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void refresh ()\n\t\t{\n\t\t\tMainActivity.this.refresh (Tab.RefreshType.FULL_EXPLICIT);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void settingsChanged ()\n\t\t{\t\t\t\n\t\t\tif (dd != null)\n\t\t\t\trefreshComplete (dd, false);\n\t\t}\t\t\n\n\t\t@Override\n\t\tpublic void importFile ()\n\t\t{\n\t\t\tIntent intent;\n\t\t\t\n\t\t\tintent = new Intent (MainActivity.this, ImportActivity.class);\n\t\t\tintent.setAction (Intent.ACTION_DEFAULT);\n\t\t\tstartActivity (intent);\n\t\t}\n\t}\n\t\n\tprivate class DBFixupListener implements DatabaseFixup.Listener {\n\t\t\n\t\t@Override\n\t\tpublic void done (boolean ok)\n\t\t{\n\t\t\tsetDBFixup (ok ? FixupState.DONE : FixupState.FAILED);\n\t\t}\n\t\t\n\t}\n\n\tenum FixupState {\n\t\t\n\t\tNOT_RUNNING,\n\t\t\n\t\tRUNNING,\n\t\t\n\t\tDONE,\n\t\t\n\t\tFAILED\n\t\t\n\t}\n\t\n\t/** The prefix */\n\tprivate static final String PREFIX = MainActivity.class + \".\";\n\t\n\t/*** The avatar bitmap filename */\n\tprivate static final String AVATAR_FILENAME = \"avatar.png\";\n\t\t\n\t/** The key checked by {@link #onCreate} to make \n\t *  sure that the statistics contained in the bundle are valid\n\t * @see #onCreate\n\t * @see #onSaveInstanceState */\n\tprivate static final String BUNDLE_VALID = PREFIX + \"bundle_valid\";\n\t\n\t/**\n\t * The key stored into the bundle to keep the items cache\n\t */\n\tprivate static final String ITEMS_CACHE = PREFIX + \"ITEMS_CACHE\";\n\t\n\t/**\n\t * The key stored into the bundle to keep track of the current tab\n\t */\n\tprivate static final String CURRENT_TAB = PREFIX + \"current_tab\";\n\t\n\t/**\n\t * The key stored into the bundle to keep track of refresh operations\n\t */\n\tprivate static final String REFRESHING = PREFIX + \"refreshing\";\n\t\n\t/**\n\t * The key stored into the bundle to keep track of db fixup operations\n\t */\n\tprivate static final String FIXUP_STATE = PREFIX + \"fixup_state\";\n\t\n\n\t/** The broadcast receiver that handles all the actions */\n\tprivate Receiver receiver;\n\n\t/** The object that implements the WaniKani API client */\n\tprivate Connection conn;\n\t\n\t/** The information displayed on the dashboard. It is built\n\t * from the objects returned by the WaniKani API*/\n\tprivate DashboardData dd;\n\t\n\t/** The asynchronous task that performs the actual queries */\n\tRefreshTask rtask;\n\t\n\t/** The object that notifies us when the refresh timeout expires */\n\tAlarm alarm;\n\t\n\t/** The pager */\n\tLowPriorityViewPager pager;\n\t\n\t/** Pager adapter instance */\n\tPagerAdapter pad;\n\t\t\n\t/** The dashboard height, in dip */\n\tprivate int DASHBOARD_HEIGHT = 430;\n\t\n\t/** The dashboard-stats combo fragment */\n\tDashboardStatsFragment dsf; \n\t\n\t/** The dashboard fragment */\n\tDashboardFragment dashboardf;\n\t\n\t/** The items fragment */\n\tItemsFragment itemsf;\n\t\n\t/** The stats fragment */\n\tStatsFragment statsf;\n\t\n\t/** The menu handler */\n\tMenuHandler mh;\n\n\t/** Is this activity visible? */\n\tboolean visible;\n\t\n\t/** Current layout */\n\tSettingsActivity.Layout layout;\n\t\n\t/** Was the last instance of this activity refreshing before being destroyed? */\n\tboolean resumeRefresh;\n\t\n\t/** Are we fixing the db up? */\n\tFixupState dbfixup;\n\t\n\t/** An action that should be invoked to force refresh. This is used typically\n\t *  when reviews complete\n\t */\n\tpublic static final String ACTION_REFRESH = PREFIX + \"REFRESH\";\n\t\n\t/** An action that should be invoked when the history DB is changed\n\t */\n\tpublic static final String ACTION_CLEAR = PREFIX + \"CLEAR\";\n\n\t/**\n\t * Extra parameter to {@link #ACTION_REFRESH}, to tell if caches should be flushed \n\t * or not.\n\t */\n\tpublic static final String E_FLUSH_CACHES = PREFIX + \"flushCaches\";\n\t\n\t/** \n\t * Called when the activity is first created.  We register the\n\t * listeners and create the \n\t * {@link com.wanikani.wklib.Connection} object that will perform the\n\t * queries for us.  In some cases (e.g. a change in the\n\t * orientation of the display), the activity is destroyed and\n\t * immediately recreated: to avoid querying the website, we\n\t * use the bundle to retains the stats. To make sure that the\n\t * bundle is actually valid (e.g. the previous instance of the\n\t * activity actually succeeded in retrieving the data), we\n\t * look for the {@link #BUNDLE_VALID} key.\n\t * \t@see #onSaveInstanceState()\n\t *  @param bundle the bundle, or <code>null</code>\n\t */\n\t@Override\n\tpublic void onCreate (Bundle bundle) \n\t{\t\n\t    super.onCreate (bundle);\n\n\t    receiver = new Receiver ();\n\t    alarm = new Alarm ();\n\t    mh = new MenuHandler (this, new MenuListener ());\n\t    dbfixup = FixupState.NOT_RUNNING;\n\n\t    /* Must be placed first, because fragments need this early */\n\t    conn = SettingsActivity.newConnection (this);\n\t\tconn.cache = new ItemsDatabase (this).getCache ();\n\n\t    if (dsf == null)\n\t    \tdsf = new DashboardStatsFragment ();\n\t    if (dashboardf == null)\n\t    \tdashboardf = new DashboardFragment ();\n\t    if (itemsf == null)\n\t    \titemsf = new ItemsFragment ();\n\t    if (statsf == null)\n\t    \tstatsf = new StatsFragment ();\n\t    \n\t\tsetContentView (R.layout.main);\n\t\tswitchTo (R.id.f_splash);\n\n\t\tpager = (LowPriorityViewPager) findViewById (R.id.pager);\n        pager.setMain (this);\n\t    setLayout ();\n\t    \t\t\n        registerIntents ();\n\t    \n\t    if (!SettingsActivity.credentialsAreValid (this))\n\t    \tmh.settings ();\n\n\t    if (bundle != null && bundle.containsKey (BUNDLE_VALID)) {\n\t    \tdd = new DashboardData (bundle);\n\t\t\tpager.setCurrentItem (bundle.getInt (CURRENT_TAB));\n\t\t\t/* -- I'm temporarily keeping this code just in case we decide to make disk caching optional -- */\n\t\t\t/*\n\t\t\ttry {\n\t\t\t\tconn.cache = (ItemsCache) bundle.getSerializable (ITEMS_CACHE);\n\t\t\t} catch (Throwable t) {\n\t\t\t\t\n\t\t\t}\n\t\t\t*/\n\t\t\tresumeRefresh = bundle.getBoolean (REFRESHING);\n\t\t\t\n\t\t\tdbfixup = (FixupState) bundle.getSerializable (FIXUP_STATE);\n\t    } else\n\t    \tpager.setCurrentItem (pad.getTabIndex (Tab.Contents.DASHBOARD), false);\n\t}\n\t\n\t/**\n\t * Wraps {@link SettingsActivity#getLayout(Context)} making sure\n\t * that {@link SettingsActivity.Layout#AUTO} is never returned.\n\t * It is translated into one of the concrete enums by looking at the size\n\t * of the device.\n\t * @return the layout\n\t */\n\tprotected SettingsActivity.Layout getLayout ()\n\t{\n\t\tSettingsActivity.Layout ans;\n\t\tDisplayMetrics dm;\n\t\tfloat hdip;\n\n\t\tans = SettingsActivity.getLayout (this);\n\t\tif (ans != SettingsActivity.Layout.AUTO)\n\t\t\treturn ans;\n\t\t\t\t\t\n\t\tdm = new DisplayMetrics ();\n\t\tgetWindowManager ().getDefaultDisplay ().getMetrics (dm);\n\t\thdip = (Math.max (dm.heightPixels, dm.widthPixels)) / dm.density;\n\t\t\t\n\t\treturn hdip >= DASHBOARD_HEIGHT * 1.5 ? \n\t\t\t\tSettingsActivity.Layout.LARGE : SettingsActivity.Layout.SMALL;\n\t}\n\n\t/**\n\t * Populates the adapter and enforces the layout, using the preferences.\n\t */\n\tvoid setLayout ()\n\t{\n\t\tList<Tab> tabs;\n\t\t\n\t    tabs = new Vector<Tab> ();\n\n\t    layout = getLayout ();\n\t    \n\t    switch (layout) {\n\t    case AUTO:\n\t    case SMALL:\n\t    \ttabs.add (statsf);\n\t    \ttabs.add (dashboardf);\n\t    \ttabs.add (itemsf);\n\t    \tbreak;\n\t    \t\n\t    case LARGE:\n\t    \ttabs.add (dsf);\n\t    \ttabs.add (itemsf);\n\t    }\t\t\n        pad = new PagerAdapter (getSupportFragmentManager (), tabs);\n        pager.setAdapter (pad);\n\t}\n\t\n\t/**\n\t * Called by each tab to register itself to the activity and get called\n\t * when something interesting happens\n\t * @param tab the tab\n\t */\n\tvoid register (Tab tab)\n\t{\n\t\tif (pad != null)\t\t\t\n\t\t\tpad.replace (tab);\n\t\t\n\t\tif (tab instanceof DashboardStatsFragment)\n\t\t\tdsf = (DashboardStatsFragment) tab;\n\t\telse if (tab instanceof DashboardFragment)\n\t\t\tdashboardf = (DashboardFragment) tab;\n\t\telse if (tab instanceof ItemsFragment)\n\t\t\titemsf = (ItemsFragment) tab;\n\t\telse if (tab instanceof StatsFragment)\n\t\t\tstatsf = (StatsFragment) tab;\n\t}\n\t\n\t@Override\n\tpublic void onStart ()\n\t{\n\t    super.onStart ();\n\t    \n\t    DashboardData ldd;\n\t    \n\t    /* A refresh task may be going on, if the review activity\n\t     * has sent a refresh request before disappearing\n\t     */\n\t    if (rtask == null) {\n\t    \tldd = dd;\n\t    \tdd = null;\n\t    \tif (ldd != null) {\n\t    \t\trefreshComplete (ldd, false);\n\t    \t\tif (resumeRefresh)\n\t    \t\t\trefresh (Tab.RefreshType.LIGHT);\n\t    \t\telse if (ldd.isIncomplete ())\n\t    \t\t\trefreshOptional ();\n\t    \t} else {\n\t    \t\tldd = DashboardData.fromPreferences (this, DashboardData.Source.MAIN_ACTIVITY);\n\t    \t\tif (ldd == null || ldd.nextReviewDate == null || ldd.nextReviewDate.before (new Date ()))\n\t    \t\t\tldd = DashboardData.fromPreferences (this, DashboardData.Source.NOTIFICATION_SERVICE);\n\t    \t\tif (ldd == null || ldd.nextReviewDate == null || ldd.nextReviewDate.before (new Date ()))\n\t    \t\t\t;\t    \t\t\n\t    \t\telse\n\t    \t\t\trefreshComplete (ldd, false);\n\t    \t\t\n\t    \t\trefresh (Tab.RefreshType.FULL_IMPLICIT);\n\t    \t}\n\t    }\n\t    \n\t    resumeRefresh = false;\n\t}\n\t\n\t/**\n\t * The OS calls this method when destroying the view.\n\t * This implementation stores the stats into the bundle, if they\n\t * have been successfully retrieved.\n\t * \t@see #onCreate(Bundle)\n\t *  @param bundle the bundle where to store the stats\n\t */\n\t@Override\n\tpublic void onSaveInstanceState (Bundle bundle)\n\t{\n\t\tsuper.onSaveInstanceState (bundle);\n\t\t\n\t\tif (dd != null) {\n\t\t\tdd.serialize (bundle);\n\t\t\tbundle.putBoolean (BUNDLE_VALID, true);\n\t\t\t/* -- Needed only if we decide to provide memory cache too\n\t\t\tif (conn != null)\n\t\t\t\tbundle.putSerializable (ITEMS_CACHE, conn.cache);\n\t\t\t*/\n\t\t\tbundle.putInt (CURRENT_TAB, pager.getCurrentItem ());\n\t\t\tbundle.putBoolean (REFRESHING, rtask != null);\n\t\t\tbundle.putSerializable (FIXUP_STATE, dbfixup);\n\t\t}\n\t}\n\t\n\t/**\n\t * Called when the application resumes.\n\t * We notify this the alarm to adjust its timers in case\n\t * they were tainted by a deep sleep mode transition.\n\t */\n\t@Override\n\tpublic void onResume ()\n\t{\n\t\tsuper.onResume ();\n\t\t\t\t\n\t\talarm.screenOn ();\n\t\tvisible = true;\n\n\t\tif (layout != getLayout ())\n\t\t\treboot ();\n\t}\n\t\t\n\t/**\n\t * Restarts the activity \n\t */\n\tprivate void reboot ()\n\t{\n\t\tIntent i;\n\t\t\n\t\ti = new Intent (this, getClass ());\n\t\ti.setAction (Intent.ACTION_MAIN);\n\t\t\n\t\tstartActivity (i);\n\t\tfinish ();\n\t}\n\t\n\t/**\n\t * Called when the application pauses.\n\t * Update the @link #visible flag.\n\t */\n\t@Override\n\tpublic void onPause ()\n\t{\n\t\tsuper.onPause ();\n\t\t\t\t\n\t\tvisible = false;\n\t}\n\n\t/**\n\t * Called on dashboard destruction. \n\t * Destroys the listeners of the changes in the settings, and the \n\t * refresher thread.\n\t */\n\t@Override\n\tpublic void onDestroy ()\n\t{\t\n\t\tsuper.onDestroy ();\n\t\t\n\t\tunregisterIntents ();\t\t\n\t\talarm.stopAlarm ();\n\t\tmh.unregister (this);\n\t}\n\n\t/**\n\t * Registers the intent listeners.\n\t * Currently the intents we listen to are:\n\t * <ul>\n\t * \t<li>{@link SettingsActivity#ACT_CREDENTIALS}, when the credentials are changed\n\t *  <li>{@link SettingsActivity#ACT_NOTIFY}, when notifications are enabled or disabled\n\t *  <li>{@link #ACTION_REFRESH}, when the dashboard should refreshed\n\t * </ul>\n\t * Both intents are triggered by {@link SettingsActivity}\n\t */\n\tprivate void registerIntents ()\n\t{\n\t\tIntentFilter filter;\n\t\tLocalBroadcastManager lbm;\n\t\t\t\t\n\t\tlbm = LocalBroadcastManager.getInstance (this);\n\t\t\n\t\tfilter = new IntentFilter (SettingsActivity.ACT_CREDENTIALS);\n\t\tfilter.addAction (SettingsActivity.ACT_NOTIFY);\n\t\tfilter.addAction (ACTION_REFRESH);\n\t\tfilter.addAction (ACTION_CLEAR);\n\t\tlbm.registerReceiver (receiver, filter);\n\t\t\n\t\tfilter = new IntentFilter (ACTION_REFRESH);\n\t\tregisterReceiver (receiver, filter);\n\t}\n\t\n\t/**\n\t * Unregister the intent listeners that were registered by {@link #registerIntent}. \n\t */\n\tprivate void unregisterIntents ()\n\t{\n\t\tLocalBroadcastManager lbm;\n\t\t\n\t\tlbm = LocalBroadcastManager.getInstance (this);\n\t\t\n\t\tlbm.unregisterReceiver (receiver);\n\t\tunregisterReceiver (receiver);\n\t}\n\t\n\t/**\n\t * Associates the menu description to the menu key (or action bar).\n\t * The XML description is <code>main.xml</code>\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) \n\t{\n\t\tgetMenuInflater().inflate (R.menu.main, menu);\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Menu handler. Relays the call to the common {@link MenuHandler}.\n\t * \t@param item the selected menu item\n\t */\n\t@Override\n\tpublic boolean onOptionsItemSelected (MenuItem item)\n\t{\n\t\treturn mh.onOptionsItemSelected (item) || super.onOptionsItemSelected (item);\n\t}\n\n\t/**\n\t * Called to update the credentials. It also triggers a refresh of \n\t * the GUI.\n\t * @param login the new credentials\n\t */\n\tprivate void updateCredentials ()\n\t{\n\t\tconn = SettingsActivity.newConnection (this);\n\t\tconn.cache = new ItemsDatabase (this).getCache ();\n\t\t\n\t\trefresh (Tab.RefreshType.FULL_IMPLICIT);\n\t}\n\n\t/**\n\t * Called when the refresh timeout expires.\n\t * We call {@link #refresh()}, but we keep caches.\n\t */\n\tpublic void run ()\n\t{\n\t\trefresh (Tab.RefreshType.LIGHT);\n\t}\n\n\t/**\n\t * Called when the GUI needs to be refreshed. \n\t * It starts an asynchrous task that actually performs the job and\n\t * optionally clears the cache any fragment may hold.\n\t * \t@param rtype the type of refresh \n\t */\n\tprivate void refresh (Tab.RefreshType rtype)\n\t{\t\t\n\t\t\tif (rtask != null)\n\t\t\t\trtask.cancel (false);\n\t\t\t\n\t\t\tpad.flush (rtype, pager.getCurrentItem ());\n\t\t\t\n\t\t\trtask = new RefreshTask ();\n\t\t\trtask.execute (conn);\t\t\t\n\t}\n\t\n\t/**\n\t * Called when optional data needs to be refreshed. This happens in\n\t * some strange situations, e.g. when the application is stopped before\n\t * optional data, and then is resumed from a bundle. I'm not even\n\t * sure it can happen, however...\n\t */\n\tprivate void refreshOptional ()\n\t{\n\t\t\tnew RefreshTaskPartII ().execute (conn);\t\t\t\n\t}\n\n\t/**\n\t * Stores the avatar locally. Needed to avoid storing it into the\n\t * bundle. Useful also to have a fallback when we can't reach the\n\t * server.\n\t * @param dd the data, containing a valid avatar bitmap. If null, this\n\t * \tmethod does nothing\n\t */\n\tprotected void saveAvatar (DashboardData dd)\n\t{\n\t\tOutputStream os;\n\t\t\n\t\tif (dd == null || dd.gravatar == null)\n\t\t\treturn;\n\t\t\n\t\tos = null;\n\t\ttry {\n\t\t\tos = openFileOutput (AVATAR_FILENAME, Context.MODE_PRIVATE);\n\t\t\tdd.gravatar.compress(Bitmap.CompressFormat.PNG, 90, os);\n\t\t} catch (IOException e) {\n\t\t\t/* Life goes on... */\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (os != null)\n\t\t\t\t\tos.close ();\n\t\t\t} catch (IOException e) {\n\t\t\t\t/* Probably next decode will go wrong */\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Restores the avatar from local storage.\n\t * @param dd the data, that will be filled with the bitmap, if everything\n\t * \tgoes fine\n\t */\n\tprotected void restoreAvatar (DashboardData dd)\n\t{\n\t\tInputStream is;\n\t\t\n\t\tif (dd == null)\n\t\t\treturn;\n\t\t\n\t\tis= null;\n\t\ttry {\n\t\t\tis = openFileInput (AVATAR_FILENAME);\n\t\t\tdd.gravatar = BitmapFactory.decodeStream (is);\n\t\t} catch (IOException e) {\n\t\t\t/* Life goes on... */\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (is != null)\n\t\t\t\t\tis.close ();\n\t\t\t} catch (IOException e) {\n\t\t\t\t/* At least we tried */\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Schedules a new refresh. Should be called right after\n\t * a refresh operation completes\n\t */\n\tprotected void reschedule ()\n\t{\n\t\tlong delay, refresh;\n\n\t\t/* Should not happen, because rescheduling makes sense only\n\t\t * when at least one successful retrieval completes. However...*/\n\t\tif (dd == null)\n\t\t\treturn;\n\t\t\n\t\trefresh = SettingsActivity.getRefreshTimeout (this) * 60 * 1000; \n\t\tif (dd.nextReviewDate != null)\n\t\t\tdelay = dd.nextReviewDate.getTime () - System.currentTimeMillis ();\n\t\telse\n\t\t\tdelay = refresh;\n\t\t\n\t\tif (delay > refresh || dd.reviewsAvailable > 0)\n\t\t\tdelay = refresh;\n\t\t\n\t\t/* May happen if local clock is not perfectly synchronized with WK clock */\n\t\tif (delay < 1000)\n\t\t\tdelay = 10000;\n\t\t\n\t\talarm.schedule (this, delay);\t\t\n\t}\n\n\t/**\n\t * Called by {@link RefreshTask} when asynchronous data \n\t * retrieval is completed.\n\t * @param dd the retrieved data\n\t * @param intermediate if this is an updated, and more will come\n\t */\n\tprivate void refreshComplete (DashboardData dd, boolean intermediate)\n\t{\n\t\tif (this.dd == null)\n\t\t\tswitchTo (R.id.f_main);\n\t\telse\n\t\t\tdd.merge (this.dd);\n\n\t\tif (!intermediate) {\n\t\t\tdd.serialize (this, DashboardData.Source.MAIN_ACTIVITY);\n\t\t\tpad.spin (false);\n\t\t}\n\n\t\tthis.dd = dd;\n\t\t\n\t\tshareData (dd);\n\t\t\n\t\trtask = null;\n\n\t\tif (dd.gravatar == null)\n\t\t\trestoreAvatar (dd);\n\t\t\n\t\tpad.refreshComplete (dd);\n\n\t\treschedule ();\n\t}\n\n\t/**\n\t * Called when notifications are enabled or disabled.\n\t * It actually starts or terminates the {@link NotificationService}. \n\t * @param enable <code>true</code> if should be started; <code>false</code>\n\t * if should be stopped\n\t */\n\tprivate void enableNotifications (boolean enable)\n\t{\n\t\tIntent intent;\n\t\t\n\t\tif (enable) {\n\t\t\tintent = new Intent (this, NotificationService.class);\n\t\t\tintent.setAction (NotificationService.ACTION_BOOT_COMPLETED);\n\t\t\tstartService (intent);\n\t\t}\n\t}\n\n\t/**\n\t * Sends fresh dashboard data to the notification service.\n\t * @param dd the data\n\t */\n\tprivate void shareData (DashboardData dd)\n\t{\n\t\tIntent intent;\n\t\tBundle b;\n\t\t\n\t\t/* If the current activity is not visible, leave the notification service\n\t\t * decide whether to update data or not (there's some code in it to avoid\n\t\t * displaying the icon while reviews are going on, and this call would\n\t\t * break it) */\n\t\tif (visible && dd != null) {\n\t\t\tintent = new Intent (this, NotificationService.class);\n\t\t\tintent.setAction (NotificationService.ACTION_NEW_DATA);\n\t\t\tb = new Bundle ();\n\t\t\tdd.serialize (b);\n\t\t\tintent.putExtra (NotificationService.KEY_DD, b);\n\t\t\t\n\t\t\tstartService (intent);\n\t\t}\t\t\n\t}\n\n\t/**\n\t * Called when retrieveing data from WaniKani. Updates the \n\t * status message or switches to the splash screen, depending\n\t * on the current state  \n\t */\n\tprivate void startRefresh ()\n\t{\n\t\tif (dd == null)\n\t\t\tswitchTo (R.id.f_splash);\n\t\telse\n\t\t\tpad.spin (true);\n\t}\n\n\t/**\n\t * Displays an error message, choosing the best way to do that.\n\t * If we did not gather any stats, the only thing we can do is to display\n\t * the error page and hope for the best\n\t * @param id resource string ID\n\t */\n\tprivate void error (int id)\n\t{\n\t\tResources res;\n\t\tString s;\n\t\tTextView tw;\n\n\t\t/* If the API code is invalid, switch to error screen even if we have\n\t\t * already opened the dashboard */\n\t\tif (id == R.string.status_msg_unauthorized)\n\t\t\tdd = null;\n\t\t\n\t\tif (dd == null)\n\t\t\tswitchTo (R.id.f_error);\n\t\telse {\n\t\t\tpad.spin (false);\n\t\t\t/* Publish old version. Stats fragment needs this to make graphs \"slide\" */\n\t\t\tpad.refreshComplete (dd);\n\t\t\treschedule ();\n\t\t}\n\t\t\n\t\tres = getResources ();\n\t\tif (id == R.string.status_msg_unauthorized)\n\t\t\ts = SettingsActivity.diagnose (this, res);\n\t\telse\n\t\t\ts = res.getString (id);\n\t\n\t\ttw = (TextView) findViewById (R.id.tv_alert);\n\t\tif (tw != null)\n\t\t\ttw.setText (s);\n\t}\n\n\t/**\n\t * Called when the \"Review\" button is clicked. According\n\t * to user preferences, it sill start either an integrated WebView\n\t * or an external browser.\n\t */\n\tpublic void review ()\n\t{\n\t\tIntent intent;\n\t\t\n\t\tintent = new Intent (MainActivity.this, NotificationService.class);\t\t\t\n\t\tintent.setAction (NotificationService.ACTION_HIDE_NOTIFICATION);\t\t\t\n\t\tstartService (intent);\n\t\t\n\t\topen (SettingsActivity.getURL (this));\n\t}\n\t\n\t/**\n\t * Called when the \"Unlock\" button is clicked. According\n\t * to user preferences, it sill start either an integrated WebView\n\t * or an external browser. \n\t */\n\tpublic void lessons ()\n\t{\n\t\topen (SettingsActivity.getLessonURL (this));\n\t}\n\t\n\t/**\n\t * Called to open an item page.\n\t * @param url the url page\n\t */\n\tpublic void item (String url)\n\t{\n\t\topen (url);\n\t}\n\t\n\t/**\n\t * Called to open the forum page.\n\t */\n\tpublic void chat ()\n\t{\n\t\topen (SettingsActivity.getChatURL (this));\n\t}\n\n\t/**\n\t * Called to open the review summary page.\n\t */\n\tpublic void reviewSummary ()\n\t{\n\t\topen (SettingsActivity.getReviewSummaryURL (this));\n\t}\n\n\t/**\n\t * Open an URL. Depending on the integrated browser key, it chooses\n\t * whether to use the internal or the external browser.\n\t * \t@param url the URL to open\n\t */\n\tprotected void open (String url)\n\t{\n\t\tIntent intent;\n\t\t\t\n\t\tif (SettingsActivity.getUseIntegratedBrowser (this)) {\n\t\t\tintent = SettingsActivity.getWebViewIntent (MainActivity.this);\n\t\t\tintent.setAction (WebReviewActivity.OPEN_ACTION);\n\t\t} else\n\t\t\tintent = new Intent (Intent.ACTION_VIEW);\n\t\t\n\t\tintent.setData (Uri.parse (url));\n\t\tstartActivity (intent);\t\t\n\t}\n\t\n\t/**\n\t * Shows the items tab, and applies a filter to displays only the apprentice items\n\t * of a given kind. Needed by the dashboard to implement the \"remaining items\"\n\t * feature\n\t * @param type the type to display. Theorically it could be null, but\n\t * \tdo we really want to?\n\t */\n\tpublic void showRemaining (Item.Type type)\n\t{\n\t\tpager.setCurrentItem (pad.getTabIndex (Tab.Contents.ITEMS), true);\n\t\titemsf.setLevelFilter (dd.level);\n\t\titemsf.showSearchDialog (true, SRSLevel.APPRENTICE, type);\n\t}\n\n\t/**\n\t * Shows the items tab, and applies a filter to displays only the items of a specific type.\n\t * Needed by the dashboard to implement the \"total items\" feature\n\t * @param type the type to display. Theorically it could be null, but\n\t * \tdo we really want to?\n\t */\n\tpublic void showTotal (Item.Type type)\n\t{\n\t\tpager.setCurrentItem (pad.getTabIndex (Tab.Contents.ITEMS), true);\n\t\titemsf.setLevelFilter (dd.level);\n\t\titemsf.showSearchDialog (true, null, type, false, false);\t\t\n\t}\n\n\t/**\n\t * Shows the items tab, and applies a filter to displays only the critical items.\n\t * Needed by the dashboard to implement the \"critical items\" feature\n\t */\n\tpublic void showCritical ()\n\t{\n\t\tpager.setCurrentItem (pad.getTabIndex (Tab.Contents.ITEMS), true);\n\t\titemsf.setFilter (ItemsFragment.FilterType.CRITICAL);\n\t\titemsf.hideSearchDialog ();\n\t}\n\n\tpublic void showThisLevel (Item.Type type, SRSLevel srs, boolean invert)\n\t{\n\t\tpager.setCurrentItem (pad.getTabIndex (Tab.Contents.ITEMS), true);\n\t\titemsf.setLevelFilter (dd.level);\n\t\titemsf.showSearchDialog (true, srs, type, true, invert);\t\t\n\t}\n\t\n\t/**\n\t * Shows the items tab, and shows the search dialog\n\t */\n\tpublic void showSearch ()\n\t{\n\t\tint idx;\n\t\t\n\t\tidx = pad.getTabIndex (Tab.Contents.ITEMS);\n\t\tif (pager.getCurrentItem () != idx) {\n\t\t\tpager.setCurrentItem (pad.getTabIndex (Tab.Contents.ITEMS), true);\n\t\t\titemsf.showSearchDialog (true, null, null);\n\t\t} else\n\t\t\titemsf.showSearchDialog (false, null, null);\n\t}\n\n\t/**\n\t * Returns the latest version of the dashboard data. Used by tabs.\n\t * @return the dashboard data \n\t */\n\tpublic DashboardData getDashboardData ()\n\t{\n\t\treturn dd;\n\t}\n\t\n\t/**\n\t * Returns the WKLib connection\n\t * @return the connection \n\t */\n\tpublic Connection getConnection ()\n\t{\n\t\treturn conn;\n\t}\n\n\t/**\n\t * Tells whether if a given tab is intercepting scroll events\n\t * @return true if it does\n\t */\n\tpublic boolean scrollLock (int item)\n\t{\n\t\treturn pad.tabs.get (item).scrollLock (); \n\t}\n\t\n\t/**\n\t * Updates the splash screen with the version ID\n\t * \t@param view the view\n\t */\n\tprivate void setVersion (View view)\n\t{\n\t\tPackageManager pmgr;\n\t\tPackageInfo pinfo;\n\t\tResources res;\n\t\tTextView tv;\n\t\t\n\t\tpmgr = getPackageManager ();\n\t\tres = getResources ();\n\t\ttry {\n\t\t\tpinfo = pmgr.getPackageInfo (getPackageName (), 0);\n\t\t\ttv = (TextView) view.findViewById (R.id.splash_version);\n\t\t\ttv.setText (res.getString (R.string.tag_version, pinfo.versionName));\n\t\t} catch (NameNotFoundException e) {\n\t\t\t/* leave it as it is */\n\t\t}\t\t\t\t\n\t}\n\t\n\t/**\n\t * Switches to one of the three screeens (main, dashboard or error)\n\t * @param id the id to switch to\n\t */\n\tpublic void switchTo (int id)\n\t{\n\t\tView view;\n\t\t\n\t\tview = findViewById (R.id.f_main);\n\t\tview.setVisibility (id == R.id.f_main ? View.VISIBLE : View.INVISIBLE);\n\n\t\tview = findViewById (R.id.f_splash);\n\t\tsetVersion (view);\n\t\tview.setVisibility (id == R.id.f_splash ? View.VISIBLE : View.INVISIBLE);\n\n\t\tview = findViewById (R.id.f_error);\n\t\tview.setVisibility (id == R.id.f_error ? View.VISIBLE : View.INVISIBLE);\n\t}\n\t\n\t@Override\n\tpublic boolean onSearchRequested ()\n\t{\n\t\tshowSearch ();\n\t\t\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void onBackPressed ()\n\t{\n\t\tif (!pad.backButton())\n\t\t\tsuper.onBackPressed ();\n\t}\n\t\n\tpublic void dbFixup ()\n\t{\n\t\tsetDBFixup (FixupState.RUNNING);\n\t\t\n\t\tnew DatabaseFixup (this, conn).asyncRun(new DBFixupListener ());\n\t}\n\t\n\tprivate void setDBFixup (FixupState dbfixup)\n\t{\n\t\tthis.dbfixup = dbfixup;\n\t\t\n\t\tif (statsf != null && statsf.isResumed ())\n\t\t\tstatsf.setFixup (dbfixup);\n\t}\n\t\n\tprivate void flushDatabase ()\n\t{\n\t\tpad.flushDatabase ();\n\t}\n}\nsrc/com/wanikani/androidnotifier/MeterSpec.java\npublic class MeterSpec implements Connection.Meter {\n\n\tpublic enum T {\n\t\t\n\t\tDASHBOARD_REFRESH,\n\t\t\t\n\t\tITEMS,\n\n\t\tRECONSTRUCT_DIALOG,\n\n\t\tNOTIFY_TIMEOUT,\n\n\t\tNOTIFY_CHANGE_CONNECTIVITY,\n\n\t\tNOTIFY_DAILY_JOBS,\n\n\t\tOTHER_STATS,\n\t\t\n\t\tMORE_STATS,\t\t\n\t\t\n\t\tOTHER_STATS_TOTAL {\n\t\t\tpublic T [] getComponents ()\n\t\t\t{\n\t\t\t\treturn new T [] { \n\t\t\t\t\tOTHER_STATS,\n\t\t\t\t\tMORE_STATS\n\t\t\t\t};\n\t\t\t}\t\t\t\n\t\t},\n\n\n\t\tAPPLICATION {\n\t\t\tpublic T [] getComponents ()\n\t\t\t{\n\t\t\t\treturn new T [] { \n\t\t\t\t\tDASHBOARD_REFRESH,\n\t\t\t\t\tITEMS,\n\t\t\t\t\tRECONSTRUCT_DIALOG,\n\t\t\t\t\tOTHER_STATS,\n\t\t\t\t\tMORE_STATS\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\t\n\t\tSERVICE {\n\t\t\tpublic T [] getComponents ()\n\t\t\t{\n\t\t\t\treturn new T [] { \n\t\t\t\t\tNOTIFY_TIMEOUT,\n\t\t\t\t\tNOTIFY_CHANGE_CONNECTIVITY,\n\t\t\t\t\tNOTIFY_DAILY_JOBS\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\t\n\t\tOVERALL {\t\t\t\n\t\t\tpublic T [] getComponents ()\n\t\t\t{\n\t\t\t\treturn new T [] { \n\t\t\t\t\tAPPLICATION,\n\t\t\t\t\tSERVICE\n\t\t\t\t};\n\t\t\t}\t\t\t\n\t\t};\n\t\t\n\t\tpublic Meter get (Context ctxt)\n\t\t{\n\t\t\treturn instantiate (ctxt);\n\t\t}\n\t\t\n\t\tpublic Counter getCounter (Context ctxt, AmountType at)\n\t\t{\n\t\t\treturn instantiate (ctxt).getCounter (at);\n\t\t}\n\t\t\n\t\tprotected MeterSpec instantiate (Context ctxt)\n\t\t{\n\t\t\treturn new MeterSpec (ctxt, this);\n\t\t}\n\t\t\n\t\tpublic T [] getComponents () \n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tpublic enum AmountType {\n\t\t\n\t\tSINCE_LAST_RESET {\t\t\t\n\t\t\tpublic float getRatio (long elapsed)\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t},\n\t\t\n\t\tAVG_DAY {\n\t\t\tpublic float getRatio (long elapsed)\n\t\t\t{\n\t\t\t\treturn 24f * 60f * 60f / (1 + elapsed / 1000);\n\t\t\t}\n\t\t},\n\t\t\n\t\tAVG_MONTH {\n\t\t\tpublic float getRatio (long elapsed)\n\t\t\t{\n\t\t\t\treturn AVG_DAY.getRatio (elapsed) * 30;\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic abstract float getRatio (long elapsed);\n\t\t\n\t\tpublic String getUnit () \n\t\t{\n\t\t\treturn \"Bytes\";\n\t\t}\n\t}\n\t\n\tpublic static class Counter {\n\t\t\n\t\tpublic AmountType at;\n\t\t\n\t\tpublic long mobile;\n\t\t\n\t\tpublic long wifi;\n\n\t\tpublic long unknown;\n\t\t\n\t\tpublic Counter (AmountType at, long mobile, long wifi, long unknown)\n\t\t{\n\t\t\tthis.at = at;\n\t\t\tthis.mobile = mobile;\n\t\t\tthis.wifi = wifi;\n\t\t\tthis.unknown = unknown;\n\t\t}\n\t\t\n\t\tpublic long total ()\n\t\t{\n\t\t\treturn mobile + wifi + unknown;\n\t\t}\n\t}\n\t\t\n\tprivate static final String PREFIX = MeterSpec.class.toString ();\n\t\n\tprivate static final String START_TIME = PREFIX + \"START_TIME\";\n\t\n\tprivate ConnectivityManager cmgr;\n\t\n\tprivate SharedPreferences prefs;\n\t\n\tprivate T type;\n\t\n\tprivate int count;\n\t\n\tprivate static final String CTAG_UNKNOWN = \"u.\"; \n\n\tprivate static final String CTAG_MOBILE = \"m.\";\n\t\n\tprivate static final String CTAG_WIFI = \"w.\";\n\t\n\tprivate static final String PREFERENCES_FILE = \"meters.xml\";\n\t\n\tprivate static Object mutex = new Object ();\n\n\tprivate MeterSpec (Context ctxt, T type)\n\t{\n\t\tthis.type = type;\n\t\t\n\t\tprefs = prefs (ctxt);\n\t\tcmgr = (ConnectivityManager) ctxt.getSystemService (Context.CONNECTIVITY_SERVICE);\n\t}\n\t\n\tstatic SharedPreferences prefs (Context ctxt)\n\t{\n\t\tint flags;\n\t\t\n\t\tflags = Context.MODE_PRIVATE;\n\t\tif (Build.VERSION.SDK_INT >= 11)\n\t\t\tflags |= Context.MODE_MULTI_PROCESS;\n\t\treturn ctxt.getSharedPreferences (PREFERENCES_FILE, flags);\t\t\n\t}\n\t\n\tpublic void count (int bytes)\n\t{\n\t\tcount += bytes;\n\t}\n\t\n\tpublic static Date getLastReset (SharedPreferences prefs)\n\t{\n\t\tsynchronized (mutex) {\n\t\t\tif (!prefs.contains (START_TIME)) \n\t\t\t\tprefs.edit ().putLong (START_TIME, System.currentTimeMillis ()).commit ();\t\t\t\n\t\t}\n\t\t\n\t\treturn new Date (prefs.getLong (START_TIME, System.currentTimeMillis ()));\n\t}\n\t\n\tpublic void sync ()\n\t{\n\t\tString key;\n\t\tEditor e;\n\t\t\n\t\tkey = getKey (type, connectivity ());\n\t\t\n\t\tsynchronized (mutex) {\n\t\t\te = prefs.edit ();\n\t\t\tif (!prefs.contains (START_TIME))\n\t\t\t\te.putLong (START_TIME, System.currentTimeMillis ());\n\t\t\t\n\t\t\te.putLong (key, prefs.getLong (key, 0) + count);\n\t\t\te.commit ();\n\t\t}\n\t\tcount = 0;\n\t}\n\t\n\tprivate static String getKey (T type, String connectivity)\n\t{\n\t\treturn PREFIX + type.name () + \".\" + connectivity;\n\t}\n\t\n\tprivate String connectivity ()\n\t{\n\t\tNetworkInfo info;\n\t\t\n\t\tif (cmgr == null)\n\t\t\treturn CTAG_UNKNOWN;\n\t\t\n\t\tinfo = cmgr.getActiveNetworkInfo ();\n\t\tif (info == null)\n\t\t\treturn CTAG_UNKNOWN; \t\t\n\t\telse if (info.getType () == ConnectivityManager.TYPE_MOBILE)\n\t\t\treturn CTAG_MOBILE;\n\t\telse\n\t\t\treturn CTAG_WIFI;\n\t}\n\n\tprivate static void addValue (SharedPreferences prefs, T t, Counter counter)\n\t{\n\t\tT components [];\n\t\tint i;\n\t\t\n\t\tcomponents = t.getComponents ();\n\t\tif (components != null) {\n\t\t\tfor (i = 0; i < components.length; i++)\n\t\t\t\taddValue (prefs, components [i], counter);\t\t\t\n\t\t} else {\n\t\t\tcounter.mobile += prefs.getLong (getKey (t, CTAG_MOBILE), 0);\n\t\t\tcounter.wifi += prefs.getLong (getKey (t, CTAG_WIFI), 0);\n\t\t\tcounter.unknown += prefs.getLong (getKey (t, CTAG_UNKNOWN), 0);\n\t\t}\n\t}\n\t\t\n\tprivate Counter getCounter (AmountType at)\n\t{\n\t\tCounter ans;\n\t\tDate date;\n\t\tfloat ratio;\n\t\t\n\t\tans = new Counter (at, 0, 0, 0);\n\t\tsynchronized (mutex) {\n\t\t\taddValue (prefs, type, ans);\n\t\t\tdate = getLastReset (prefs); \n\t\t}\n\t\tratio = at.getRatio (System.currentTimeMillis () - date.getTime ());\n\t\tans.mobile *= ratio;\n\t\tans.wifi *= ratio;\n\t\tans.unknown *= ratio;\n\t\t\n\t\treturn ans;\n\t}\n\t\n\tpublic static void reset (Context ctxt)\n\t{\n\t\tEditor e;\n\t\t\n\t\tsynchronized (mutex) {\n\t\t\te = prefs (ctxt).edit ();\n\t\t\te.putLong (START_TIME, System.currentTimeMillis ());\n\t\t\tfor (T type : T.values ()) {\n\t\t\t\te.putLong (getKey (type, CTAG_MOBILE), 0);\n\t\t\t\te.putLong (getKey (type, CTAG_WIFI), 0);\n\t\t\t\te.putLong (getKey (type, CTAG_UNKNOWN), 0);\n\t\t\t}\n\t\t\te.commit ();\n\t\t}\n\t}\t\n}\nsrc/com/wanikani/wklib/Radical.java\npublic class Radical extends Item {\n\n\tprivate static class Factory implements Item.Factory<Radical> {\n\n\t\tpublic Radical deserialize (JSONObject obj)\n\t\t\tthrows JSONException\n\t\t{\n\t\t\treturn new Radical (obj);\n\t\t}\n\t}\n\n\tprivate static class ItemFactory implements Item.Factory<Item> {\n\n\t\tpublic Radical deserialize (JSONObject obj)\n\t\t\tthrows JSONException\n\t\t{\n\t\t\treturn new Radical (obj);\n\t\t}\n\t}\n\n\tpublic static final long serialVersionUID = 1L;\n\t\n\tpublic static final Item.Factory<Radical> FACTORY = new Factory ();\n\n\tpublic static final Item.Factory<Item> ITEM_FACTORY = new ItemFactory ();\n\t\n\tpublic String image;\n\t\n\tprivate String hyphenatedMeaning;\n\t\n\tpublic Radical (JSONObject obj)\n\t\tthrows JSONException\n\t{\n\t\tsuper (obj, Item.Type.RADICAL);\n\t\t\n\t\timage = Util.getString (obj, \"image\");\n\t\t\n\t\tfixup ();\n\t}\t\n\t\n\tpublic Radical ()\n\t{\n\t\tsuper (Item.Type.RADICAL);\n\t}\n\t\n\t@Override\n\tprotected boolean hasReading ()\n\t{\n\t\treturn false;\n\t}\n\n\tpublic String getItemURLComponent ()\n\t{\n\t\treturn hyphenatedMeaning;\n\t}\n\n\tprotected String getClassURLComponent ()\n\t{\n\t\treturn \"radicals\";\n\t}\n\t\n\t@Override\n\tpublic void fixup ()\n\t{\n\t\thyphenatedMeaning = meaning;\n\t\tmeaning = meaning.replace ('-', ' ');\n\t}\n}\nsrc/com/wanikani/wklib/Item.java\npublic abstract class Item implements Serializable {\n\t\n\tpublic static final long serialVersionUID = 1L;\n\t\n\tpublic static class SortByToxicity implements Comparator<Item> {\n\t\t\n\t\tboolean ascending;\n\t\t\n\t\tComparator<Item> secondKey;\n\n\t\tpublic final static SortByToxicity INSTANCE = new SortByToxicity (false);\n\n\t\tpublic final static SortByToxicity INSTANCE_ASCENDING = new SortByToxicity (true);\n\n\t\tprivate SortByToxicity (boolean ascending)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\t\n\t\t\tsecondKey = ascending ? SortByMaxStreaks.INSTANCE : SortByTime.INSTANCE_ASCENDING;\n\t\t}\n\t\t\n\t\tpublic SortByToxicity (boolean ascending, Comparator<Item> secondKey)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\tthis.secondKey = secondKey;\n\t\t}\n\t\t\n\t\tpublic int compare (Item a, Item b)\n\t\t{\n\t\t\tint ans, am, bm;\n\t\t\t\n\t\t\t/* Klooge to make sure that when percentage is unknown,\n\t\t\t * items go at the end of the list */\n\t\t\tam = a.stats != null && !a.stats.burned ? \n\t\t\t\t\t(a.stats.reading != null ? a.stats.reading.incorrect : 0) + \n\t\t\t\t\t(a.stats.meaning != null ? a.stats.meaning.incorrect : 0)  : -1; \n\t\t\t\t\t\t\t\t\t\t\n\t\t\tbm = b.stats != null && !b.stats.burned ? \n\t\t\t\t\t(b.stats.reading != null ? b.stats.reading.incorrect : 0) + \n\t\t\t\t\t(b.stats.meaning != null ? b.stats.meaning.incorrect : 0)  : -1;\n\t\t\t\t\t\n\t\t\tif (am < 0 && ascending)\n\t\t\t\tam = -1;\n\t\t\tif (bm < 0 && ascending)\n\t\t\t\tbm = -1;\n\t\t\t\n\t\t\tans = am - bm;\n\t\n\t\t\tans = ascending ? ans : -ans;\n\n\t\t\treturn ans == 0 ? secondKey.compare (a, b) : ans;\n\t\t}\n\t}\n\t\n\tpublic static class SortByMaxStreaks implements Comparator<Item> {\n\t\t\n\t\tboolean ascending;\n\t\t\n\t\tComparator<Item> secondKey;\n\n\t\tpublic final static SortByMaxStreaks INSTANCE = new SortByMaxStreaks (false);\n\n\t\tpublic final static SortByMaxStreaks INSTANCE_ASCENDING = new SortByMaxStreaks (true);\n\n\t\tprivate SortByMaxStreaks (boolean ascending)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\t\n\t\t\tsecondKey = ascending ? SortByErrors.INSTANCE : SortByErrors.INSTANCE_ASCENDING;\n\t\t}\n\t\t\n\t\tpublic SortByMaxStreaks (boolean ascending, Comparator<Item> secondKey)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\tthis.secondKey = secondKey;\n\t\t}\n\t\t\n\t\tpublic int compare (Item a, Item b)\n\t\t{\n\t\t\tint ans, am, bm;\n\t\t\t\n\t\t\t/* Klooge to make sure that when percentage is unknown,\n\t\t\t * items go at the end of the list */\n\t\t\tam = a.stats != null ? \n\t\t\t\t\t(a.stats.reading != null ? a.stats.reading.maxStreak : 0) + \n\t\t\t\t\t(a.stats.meaning != null ? a.stats.meaning.maxStreak : 0)  : -1; \n\t\t\t\t\t\t\t\t\t\t\n\t\t\tbm = b.stats != null ? \n\t\t\t\t\t(b.stats.reading != null ? b.stats.reading.maxStreak : 0) + \n\t\t\t\t\t(b.stats.meaning != null ? b.stats.meaning.maxStreak : 0)  : -1; \n\n\t\t\tif (am < 0 && ascending)\n\t\t\t\tam = -1;\n\t\t\tif (bm < 0 && ascending)\n\t\t\t\tbm = -1;\n\t\t\t\n\t\t\tans = am - bm;\n\t\n\t\t\tans = ascending ? ans : -ans;\n\n\t\t\treturn ans == 0 ? secondKey.compare (a, b) : ans;\n\t\t}\n\t}\n\n\tpublic static class SortByErrors implements Comparator<Item> {\n\t\t\n\t\tboolean ascending;\n\t\t\n\t\tComparator<Item> secondKey;\n\n\t\tpublic final static SortByErrors INSTANCE = new SortByErrors (false);\n\n\t\tpublic final static SortByErrors INSTANCE_ASCENDING = new SortByErrors (true);\n\n\t\tprivate SortByErrors (boolean ascending)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\t\n\t\t\tsecondKey = ascending ? SortByTime.INSTANCE_ASCENDING : SortByTime.INSTANCE;\n\t\t}\n\t\t\n\t\tpublic SortByErrors (boolean ascending, Comparator<Item> secondKey)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\tthis.secondKey = secondKey;\n\t\t}\n\t\t\n\t\tpublic int compare (Item a, Item b)\n\t\t{\n\t\t\tint ans, ap, bp;\n\t\t\t\n\t\t\t/* Klooge to make sure that when percentage is unknown,\n\t\t\t * items go at the end of the list */\n\t\t\tap = a.percentage;\n\t\t\tif (ap < 0 && !ascending)\n\t\t\t\tap = 101;\n\t\t\tbp = b.percentage;\n\t\t\tif (bp < 0 && !ascending)\n\t\t\t\tbp = 101;\n\t\t\t\n\t\t\tans = bp - ap;\n\t\n\t\t\tans = ascending ? ans : -ans;\n\n\t\t\treturn ans == 0 ? secondKey.compare (a, b) : ans;\n\t\t}\n\t}\n\t\n\n\tpublic static class SortByTime implements Comparator<Item> {\n\t\t\n\t\tboolean ascending;\n\n\t\tpublic final static SortByTime INSTANCE = new SortByTime (false);\n\n\t\tpublic final static SortByTime INSTANCE_ASCENDING = new SortByTime (true);\n\t\t\n\t\tprivate SortByTime (boolean ascending)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t}\n\t\t\n\t\tpublic int compare (Item a, Item b)\n\t\t{\n\t\t\tDate ula, ulb;\n\t\t\tint ans;\n\n\t\t\tula = a.getUnlockedDate ();\n\t\t\tulb = b.getUnlockedDate ();\n\n\t\t\t/* Non-unlocked items should always appear last */\n\t\t\tif (ula != null) {\n\t\t\t\tif (ulb != null)\n\t\t\t\t\tans = ula.compareTo (ulb);\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (ulb != null)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn ascending ? ans : -ans;\n\t\t}\n\t}\n\t\n\tpublic static class SortByAvailable implements Comparator<Item> {\n\t\t\n\t\tboolean ascending;\n\n\t\tpublic final static SortByAvailable INSTANCE = new SortByAvailable (false);\n\n\t\tpublic final static SortByAvailable INSTANCE_ASCENDING = new SortByAvailable (true);\n\t\t\n\t\tprivate SortByAvailable (boolean ascending)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t}\n\t\t\n\t\tpublic int compare (Item a, Item b)\n\t\t{\n\t\t\tDate ala, alb;\n\t\t\tboolean ba, bb;\n\t\t\tint ans;\n\n\t\t\tba = a.stats != null && a.stats.burned;\n\t\t\tbb = b.stats != null && b.stats.burned;\n\t\t\t\n\t\t\t/* Burned items go last */\n\t\t\tif (ba && !bb)\n\t\t\t\treturn 1;\n\t\t\tif (!ba && bb)\n\t\t\t\treturn -1;\n\t\t\t\n\t\t\tala = a.getAvailableDate ();\n\t\t\talb = b.getAvailableDate ();\n\t\t\t\n\t\t\t/* Non-unlocked items should always appear last */\n\t\t\tif (ala != null) {\n\t\t\t\tif (alb != null)\n\t\t\t\t\tans = -ala.compareTo (alb);\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (alb != null)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn ascending ? ans : -ans;\n\t\t}\n\t}\n\t\n\tpublic static class SortByLevel implements Comparator<Item> {\n\t\t\n\t\tboolean ascending;\n\t\t\n\t\tComparator<Item> secondKey;\n\t\t\n\t\tpublic final static SortByLevel INSTANCE = new SortByLevel (false);\n\n\t\tpublic final static SortByLevel INSTANCE_ASCENDING = new SortByLevel (true);\n\n\t\tprivate SortByLevel (boolean ascending)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\tsecondKey = ascending ? SortBySRS.INSTANCE_ASCENDING : SortBySRS.INSTANCE;\n\t\t}\n\t\t\n\t\tpublic SortByLevel (boolean ascending, Comparator<Item> secondKey)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\tthis.secondKey = secondKey;\n\t\t}\n\n\t\tpublic int compare (Item a, Item b)\n\t\t{\n\t\t\tint ans;\n\t\t\t\n\t\t\tans = a.level - b.level;\n\t\t\t\n\t\t\tans = ascending ? ans : -ans;\n\n\t\t\treturn ans == 0 ? secondKey.compare (a, b) : ans;\n\t\t}\n\t}\n\n\tpublic static class SortBySRS implements Comparator<Item> {\n\t\t\n\t\tboolean ascending;\n\t\t\n\t\tComparator<Item> secondKey;\n\t\t\n\t\tpublic final static SortBySRS INSTANCE = new SortBySRS (false);\n\n\t\tpublic final static SortBySRS INSTANCE_ASCENDING = new SortBySRS (true);\n\n\t\tprivate SortBySRS (boolean ascending)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\tsecondKey = ascending ? SortByAvailable.INSTANCE_ASCENDING : \n\t\t\t\t\tSortByAvailable.INSTANCE;\n\t\t}\n\t\t\n\t\tpublic SortBySRS (boolean ascending, Comparator<Item> secondKey)\n\t\t{\n\t\t\tthis.ascending = ascending;\n\t\t\tthis.secondKey = secondKey;\n\t\t}\n\n\t\tpublic int compare (Item a, Item b)\n\t\t{\n\t\t\tint ans;\n\t\t\t\n\t\t\tif (a.stats != null && b.stats != null)\n\t\t\t\tans = a.stats.srs.compareTo (b.stats.srs);\n\t\t\telse if (a.stats != null)\n\t\t\t\tans = 1;\n\t\t\telse if (b.stats != null)\n\t\t\t\tans = -1;\n\t\t\telse\n\t\t\t\tans = 0;\n\t\t\t\n\t\t\tans = ascending ? ans : -ans;\n\n\t\t\treturn ans == 0 ? secondKey.compare (a, b) : ans;\n\t\t}\n\t}\n\n\tpublic static class SortByType implements Comparator<Item> {\n\t\t\n\t\tComparator<Item> secondKey;\n\t\t\n\t\tpublic final static SortByType INSTANCE = new SortByType (false);\n\n\t\tpublic final static SortByType INSTANCE_ASCENDING = new SortByType (true);\n\n\t\tprivate SortByType (boolean ascending)\n\t\t{\n\t\t\tsecondKey = ascending ? SortByLevel.INSTANCE_ASCENDING : SortByLevel.INSTANCE;\n\t\t}\n\t\t\n\t\tpublic SortByType (boolean ascending, Comparator<Item> secondKey)\n\t\t{\n\t\t\tthis.secondKey = secondKey;\n\t\t}\n\n\t\tpublic int compare (Item a, Item b)\n\t\t{\n\t\t\tint ans;\n\t\t\t\n\t\t\tans = a.type.compareTo (b.type);\n\t\t\t\n\t\t\treturn ans == 0 ? secondKey.compare (a, b) : ans;\n\t\t}\n\t}\n\n\tpublic interface Factory<T extends Item> {\n\t\t\n\t\tpublic T deserialize (JSONObject obj)\n\t\t\tthrows JSONException;\n\t\t\n\t};\n\t\t\n\tpublic static enum Type {\n\t\t\n\t\tRADICAL\t{\n\t\t\tpublic Factory<Item> getFactory ()\n\t\t\t{\n\t\t\t\treturn Radical.ITEM_FACTORY;\n\t\t\t}\n\t\t},\n\t\tKANJI {\n\t\t\tpublic Factory<Item> getFactory ()\n\t\t\t{\n\t\t\t\treturn Kanji.ITEM_FACTORY;\n\t\t\t}\n\t\t},\n\t\tVOCABULARY {\n\t\t\tpublic Factory<Item> getFactory ()\n\t\t\t{\n\t\t\t\treturn Vocabulary.ITEM_FACTORY;\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic static Type fromString (String s)\n\t\t{\n\t\t\tif (s.equals (\"radical\"))\n\t\t\t\treturn RADICAL;\n\t\t\telse if (s.equals (\"kanji\"))\n\t\t\t\treturn KANJI;\n\t\t\telse if (s.equals (\"vocabulary\"))\n\t\t\t\treturn VOCABULARY;\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic abstract Factory<Item> getFactory ();\n\n\t}\n\t\n\tpublic static class Performance implements Serializable {\n\t\t\t\t\n\t\tpublic static final long serialVersionUID = 1L;\n\t\t\n\t\tpublic int correct;\n\t\t\n\t\tpublic int incorrect;\n\t\t\n\t\tpublic int maxStreak;\n\t\t\n\t\tpublic int currentStreak;\n\t\t\n\t\tPerformance (JSONObject obj, String prefix)\n\t\t\tthrows JSONException\n\t\t{\n\t\t\tcorrect = Util.getInt (obj, prefix + \"_correct\");\n\t\t\tincorrect = Util.getInt (obj, prefix + \"_incorrect\");\n\t\t\tmaxStreak = Util.getInt (obj, prefix + \"_max_streak\");\n\t\t\tcurrentStreak = Util.getInt (obj, prefix + \"_current_streak\");\n\t\t}\n\t\t\n\t\tpublic Performance ()\n\t\t{\n\t\t\t/* empty */\n\t\t}\n\t\t\n\t};\n\t\n\tpublic static class Stats implements Serializable {\n\t\t\n\t\tpublic static final long serialVersionUID = 1L;\n\n\t\tpublic SRSLevel srs;\n\t\t\n\t\tprivate Date unlockedDate;\n\t\t\n\t\tpublic Date availableDate;\n\t\t\n\t\tpublic Date burnedDate;\n\t\t\n\t\tpublic boolean burned;\n\t\t\t\t\n\t\tpublic Item.Performance reading;\n\t\t\n\t\tpublic Item.Performance meaning;\t\t\n\n\t\tpublic String readingNote;\n\t\t\n\t\tpublic String meaningNote;\n\t\t\n\t\tpublic String userSynonyms [];\n\t\t\n\t\tStats (JSONObject obj, boolean hasReading)\n\t\t\tthrows JSONException\n\t\t{\n\t\t\tJSONArray synonyms;\n\t\t\tString s;\n\t\t\tint i;\n\t\t\t\n\t\t\ts = obj.getString (\"srs\");\n\t\t\tsrs = SRSLevel.fromString (s);\n\t\t\tif (srs == null)\n\t\t\t\tthrow new JSONException (\"Bad SRS: \" + s);\n\t\t\t\n\t\t\tunlockedDate = Util.getDate (obj, \"unlocked_date\");\n\t\t\tavailableDate = Util.getDate (obj, \"available_date\"); \n\t\t\tburnedDate = Util.getDate (obj, \"burned_date\");\n\t\t\tburned = Util.getBoolean (obj, \"burned\");\n\t\t\t\n\t\t\tif (hasReading)\n\t\t\t\treading = new Item.Performance (obj, \"reading\");\t\t\t\n\t\t\tmeaning = new Item.Performance (obj, \"meaning\");\n\t\t\t\n\t\t\tmeaningNote = Util.getString (obj, \"meaning_note\");\n\t\t\tif (obj.has (\"reading_note\"))\n\t\t\t\treadingNote = Util.getString (obj, \"reading_note\");\n\t\t\tif (!obj.isNull (\"user_synonyms\")) {\n\t\t\t\tsynonyms = obj.getJSONArray (\"user_synonyms\");\n\t\t\t\tuserSynonyms = new String [synonyms.length ()];\n\t\t\t\tfor (i = 0; i < userSynonyms.length; i++)\n\t\t\t\t\tuserSynonyms [i] = synonyms.getString (i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Stats ()\n\t\t{\n\t\t\t/* empty */\n\t\t}\n\t};\n\t\n\tprivate static class DynamicFactory implements Item.Factory<Item> {\n\n\t\tpublic Item deserialize (JSONObject obj)\n\t\t\tthrows JSONException\n\t\t{\n\t\t\tType type;\n\t\t\tString s;\n\t\t\t\n\t\t\ts = obj.getString (\"type\");\n\t\t\ttype = Type.fromString (s);\n\t\t\tif (type == null)\n\t\t\t\tthrow new JSONException (\"Unexpected type: \" + s);\n\n\t\t\treturn type.getFactory ().deserialize (obj);\n\t\t}\n\t}\n\t\n\tpublic static final Factory<Item> FACTORY = new DynamicFactory ();\n\n\tpublic Type type;\n\t\n\tpublic String character;\n\t\n\tpublic String meaning;\n\t\n\tpublic int level;\n\t\n\tpublic Stats stats;\n\t\n\tpublic int percentage;\n\t\n\tprivate Date unlockedDate;\n\t\t\n\tpublic Date instanceCreationDate;\n\t\n\tprotected Item (JSONObject obj, Type type)\n\t\tthrows JSONException\n\t{\n\t\tthis.type = type;\n\t\t\n\t\tinstanceCreationDate = new Date ();\n\t\tcharacter = Util.getString (obj, \"character\");\n\t\tmeaning = Util.getString (obj, \"meaning\");\n\t\tlevel = Util.getInt (obj, \"level\");\n\t\t\n\t\tif (!obj.isNull (\"user_specific\"))\n\t\t\tstats = new Stats (obj.getJSONObject (\"user_specific\"), hasReading ());\n\t\t\n\t\t/* Only for critical items */\n\t\tif (!obj.isNull (\"percentage\"))\n\t\t\tpercentage = obj.optInt (\"percentage\");\n\t\telse if (stats != null)\n\t\t\tsetStats (stats);\n\t\telse\n\t\t\tpercentage = -1;\t/* No info */\n\t\t\t\n\t\t\n\t\t/* Only for recent unlocks */\n\t\tunlockedDate = Util.getDate (obj, \"unlocked_date\");\n\t}\n\t\n\tprotected Item (Type type)\n\t{\n\t\tthis.type = type;\n\t\t\n\t\tpercentage = -1;\n\t}\n\t\n\tpublic void setStats (Stats stats)\n\t{\n\t\tint num, den;\n\n\t\tthis.stats = stats;\n\t\t\n\t\tnum = stats.meaning.correct;\n\t\tden = stats.meaning.correct + stats.meaning.incorrect;\n\t\tif (stats.reading != null) {\n\t\t\tnum += stats.reading.correct;\n\t\t\tden += stats.reading.correct + stats.reading.incorrect;\n\t\t}\n\t\tpercentage = den != 0 ? num * 100 / den : 100; \t\t\n\t}\n\t\n\tpublic Date getUnlockedDate ()\n\t{\n\t\treturn \tunlockedDate != null ? unlockedDate :\n\t\t\t\t\tstats == null ? null : stats.unlockedDate;\n\t}\n\t\n\tpublic void setUnlockedDate (Date date)\n\t{\n\t\tunlockedDate = date;\n\t\tif (stats != null)\n\t\t\tstats.unlockedDate = date;\n\t}\n\t\n\tpublic Date getAvailableDate ()\n\t{\n\t\treturn stats == null ? null : stats.availableDate;\n\t}\n\n\tprotected boolean hasReading ()\n\t{\n\t\treturn true;\n\t}\n\t\n\tpublic String getItemURLComponent ()\n\t{\n\t\treturn character;\n\t}\n\t\n\tprotected abstract String getClassURLComponent ();\n\t\n\tpublic String getURL (boolean tls)\n\t{\n\t\tString scheme;\n\t\t\n\t\tscheme = tls ? \"https\" : \"http\";\n\t\t\n\t\treturn scheme + \"://www.wanikani.com/\" + \n\t\t\t\tgetClassURLComponent () + \"/\" + getItemURLComponent ();\n\t}\n\t\n\tpublic boolean matches (String s)\n\t{\n\t\treturn meaning.contains (s) ||\n\t\t\t\t(character != null && character.contains (s));\n\t}\n\t\n\tpublic void fixup ()\n\t{\n\t\t/* empty */\n\t}\n}\nsrc/com/wanikani/wklib/ItemLibrary.java\npublic class ItemLibrary<T extends Item> implements Serializable {\n\n\tpublic static final long serialVersionUID = 1L;\n\t\n\tpublic List<T> list;\n\t\n\tpublic ItemLibrary (Item.Factory<T> f, JSONArray array)\n\t\tthrows JSONException\n\t{\n\t\tint i;\n\t\t\n\t\tlist = new Vector<T> (array.length ());\n\t\tfor (i = 0; i < array.length (); i++)\n\t\t\tlist.add (f.deserialize (array.getJSONObject (i)));\n\t}\n\t\n\tpublic ItemLibrary (ItemLibrary<? extends T> lib)\n\t{\n\t\tlist = new Vector<T> ();\n\t\t\n\t\tadd (lib);\n\t}\n\n\tpublic ItemLibrary (T item)\n\t{\n\t\tlist = new Vector<T> ();\n\t\t\n\t\tadd (item);\n\t}\n\t\n\tpublic ItemLibrary ()\n\t{\n\t\tlist = new Vector<T> ();\n\t}\n\t\n\tpublic ItemLibrary<T> add (ItemLibrary<? extends T> lib)\n\t{\n\t\tlist.addAll (lib.list);\n\t\t\n\t\treturn this;\n\t}\n\n\tpublic ItemLibrary<T> add (T item)\n\t{\n\t\tlist.add (item);\n\t\t\n\t\treturn this;\n\t}\n}\nsrc/com/wanikani/androidnotifier/graph/HistogramPlot.java\npublic static class Sample {\n\t\t\n\tpublic Series series;\n\t\t\n\tpublic long value;\n\t\t\n\tpublic Sample (Series series, long value)\n\t{\n\t\tthis.series = series;\n\t\tthis.value = value;\n\t}\n\n\tpublic Sample (Series series)\n\t{\n\t\tthis.series = series;\n\t}\n\t\t\n\tpublic Sample ()\n\t{\n\t\t/* empty */\n\t}\t\t\n}\nsrc/com/wanikani/wklib/Kanji.java\npublic class Kanji extends Item {\n\t\n\tstatic class Factory implements Item.Factory<Kanji> {\n\n\t\tpublic Kanji deserialize (JSONObject obj)\n\t\t\tthrows JSONException\n\t\t{\n\t\t\treturn new Kanji (obj);\n\t\t}\n\t}\n\t\n\tstatic class ItemFactory implements Item.Factory<Item> {\n\n\t\tpublic Item deserialize (JSONObject obj)\n\t\t\tthrows JSONException\n\t\t{\n\t\t\treturn new Kanji (obj);\n\t\t}\n\t}\n\n\tpublic static final Item.Factory<Kanji> FACTORY = new Factory ();\n\n\tpublic static final Item.Factory<Item> ITEM_FACTORY = new ItemFactory ();\n\n\tpublic static enum Reading {\n\t\t\n\t\tONYOMI, \n\t\t\n\t\tKUNYOMI,\n\t\t\n\t\tNANORI; \n\t\t\n\t\tpublic static Reading fromString (String s)\n\t\t{\n\t\t\tif (s.equals (\"onyomi\"))\n\t\t\t\treturn ONYOMI;\n\t\t\telse if (s.equals (\"kunyomi\"))\n\t\t\t\treturn KUNYOMI;\n\t\t\telse if (s.equals (\"nanori\"))\n\t\t\t\treturn NANORI;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t};\n\t\n\tpublic static final long serialVersionUID = 1L;\n\n\tpublic String onyomi;\n\t\n\tpublic String kunyomi;\n\t\n\tpublic String nanori;\n\t\n\tpublic Reading importantReading;\n\t\t\n\tpublic Kanji (JSONObject obj)\n\t\tthrows JSONException\n\t{\n\t\tsuper (obj, Item.Type.KANJI);\n\n\t\tString s;\n\t\t\n\t\tonyomi = Util.getString (obj, \"onyomi\");\n\t\tkunyomi = Util.getString (obj, \"kunyomi\");\n\t\tnanori = Util.getString (obj, \"nanori\");\n\t\ts = Util.getString (obj, \"important_reading\");\n\t\timportantReading = Reading.fromString (s);\n\t\tif (importantReading == null)\n\t\t\timportantReading = Reading.ONYOMI;\n\t}\n\t\n\tpublic Kanji ()\n\t{\n\t\tsuper (Item.Type.KANJI);\n\t}\n\t\t\n\tpublic Item deserialize (JSONObject obj)\n\t\tthrows JSONException\n\t{\n\t\treturn new Kanji (obj);\n\t}\n\n\t@Override\n\tprotected String getClassURLComponent ()\n\t{\n\t\treturn \"kanji\";\n\t}\n\t\n\tpublic boolean matches (String s)\n\t{\n\t\treturn super.matches (s) ||\n\t\t\t\t(onyomi != null && onyomi.contains (s)) ||\n\t\t\t\t(kunyomi != null && kunyomi.contains (s));\n\t}\n\t\n}\n", "answers": ["\t\tpublic ResourceData (MainActivity main)"], "length": 11715, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "1669bcf267046f0b7b25014a091ffec46e7d9239d98ddddd"}
{"input": "from pyorient.exceptions import PyOrientBadMethodCallException\nfrom .base import BaseMessage\nfrom ..constants import DB_OPEN_OP, DB_TYPE_DOCUMENT, DB_COUNT_RECORDS_OP, FIELD_BYTE, FIELD_INT, \\\n    FIELD_SHORT, FIELD_STRING, FIELD_STRINGS, FIELD_BYTES, FIELD_BOOLEAN, NAME, SUPPORTED_PROTOCOL, \\\n    VERSION, DB_TYPES, DB_CLOSE_OP, DB_EXIST_OP, STORAGE_TYPE_PLOCAL, \\\n    STORAGE_TYPE_LOCAL, DB_CREATE_OP, \\\n    DB_DROP_OP, DB_RELOAD_OP, DB_SIZE_OP, DB_LIST_OP, STORAGE_TYPES, FIELD_LONG\nfrom ..utils import need_connected, need_db_opened\nfrom ..otypes import OrientRecord, OrientCluster, OrientVersion, OrientNode\nfrom ..serializations import OrientSerialization\n\n        return info, clusters, self._node_list\n        # self._cluster_map = self._orientSocket.cluster_map = \\\n        #     Information([clusters, response, self._orientSocket])\n\n        # return self._cluster_map\n\n    def set_db_name(self, db_name):\n        self._db_name = db_name\n        return self\n\n    def set_db_type(self, db_type):\n        if db_type in DB_TYPES:\n            # user choice storage if present\n            self._db_type = db_type\n        else:\n            raise PyOrientBadMethodCallException(\n                db_type + ' is not a valid database type', []\n            )\n        return self\n\n    def set_client_id(self, _cid):\n        self._client_id = _cid\n        return self\n\n    def set_user(self, _user):\n        self._user = _user\n        return self\n\n    def set_pass(self, _pass):\n        self._pass = _pass\n        return self\n\n\n#\n# DB CLOSE\n#\n# Closes the database and the network connection to the OrientDB Server\n# instance. No return is expected. The socket is also closed.\n#\n# Request: empty\n# Response: no response, the socket is just closed at server side\n#\nclass DbCloseMessage(BaseMessage):\n    def __init__(self, _orient_socket):\n        super(DbCloseMessage, self).__init__(_orient_socket)\n\n        # order matters\n        self._append(( FIELD_BYTE, DB_CLOSE_OP ))\n\n    @need_connected\n    def prepare(self, params=None):\n        return super(DbCloseMessage, self).prepare()\n\n    def fetch_response(self):\n        # set database closed\n        self._orientSocket.db_opened = None\n        super(DbCloseMessage, self).close()\n        return 0\n\n\n#\n# DB EXISTS\n#\n# Asks if a database exists in the OrientDB Server instance. It returns true (non-zero) or false (zero).\n#\n# Request: (database-name:string) <-- before 1.0rc1 this was empty (server-storage-type:string - since 1.5-snapshot)\n# Response: (result:byte)\n#\n# server-storage-type can be one of the supported types:\n# plocal as a persistent database\n# memory, as a volatile database\n#\nclass DbExistsMessage(BaseMessage):\n    def __init__(self, _orient_socket):\n        super(DbExistsMessage, self).__init__(_orient_socket)\n\n        self._db_name = ''\n        self._storage_type = ''\n\n        if self.get_protocol() > 16:  # 1.5-SNAPSHOT\n            self._storage_type = STORAGE_TYPE_PLOCAL\n        else:\n            self._storage_type = STORAGE_TYPE_LOCAL\n\n        # order matters\n        self._append(( FIELD_BYTE, DB_EXIST_OP ))\n\n    @need_connected\n    def prepare(self, params=None):\n\n        if isinstance(params, tuple) or isinstance(params, list):\n            try:\n                self._db_name = params[0]\n                # user choice storage if present\n                self.set_storage_type(params[1])\n\n            except IndexError:\n                # Use default for non existent indexes\n                pass\n\n        if self.get_protocol() >= 6:\n            self._append(( FIELD_STRING, self._db_name ))  # db_name\n\n        if self.get_protocol() >= 16:\n            # > 16 1.5-snapshot\n            # custom choice server_storage_type\n            self._append(( FIELD_STRING, self._storage_type ))\n\n        return super(DbExistsMessage, self).prepare()\n\n    def fetch_response(self):\n        self._append(FIELD_BOOLEAN)\n        return super(DbExistsMessage, self).fetch_response()[0]\n\n    def set_db_name(self, db_name):\n        self._db_name = db_name\n        return self\n\n    def set_storage_type(self, storage_type):\n", "context": "pyorient/constants.py\nDB_SIZE_OP                 = chr(8)\npyorient/constants.py\nDB_CREATE_OP               = chr(4)\npyorient/constants.py\nSUPPORTED_PROTOCOL = 36\npyorient/constants.py\nFIELD_BYTES = {\"type\": BYTES, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nFIELD_BOOLEAN = {\"type\": BOOLEAN, \"bytes\": 1, \"struct\": None}\npyorient/constants.py\nSTORAGE_TYPE_PLOCAL = 'plocal'\npyorient/constants.py\nVERSION = \"1.5.5\"\npyorient/constants.py\nSTORAGE_TYPE_LOCAL  = 'local'\npyorient/constants.py\nFIELD_INT = {\"type\": INT, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nDB_CLOSE_OP                = chr(5)\npyorient/constants.py\nFIELD_STRING = {\"type\": STRING, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nDB_EXIST_OP                = chr(6)\npyorient/constants.py\nDB_RELOAD_OP               = chr(73)\npyorient/constants.py\nDB_COUNT_RECORDS_OP        = chr(9)\npyorient/otypes.py\nclass OrientNode(object):\n    def __init__(self, node_dict=None):\n        \"\"\"\n        Represent a server node in a multi clusered configuration\n\n        TODO: extends this object with different listeners if we're going to support in the driver an abstarction of the HTTP protocol, for now we are not interested in that\n\n        :param node_dict: dict with starting configs (usaully from a db_open, db_reload record response)\n        \"\"\"\n        #: node name\n        self.name = None\n\n        #: node is\n        self.id = None\n\n        #: datetime object the node was started\n        self.started_on = None\n\n        #: binary listener host\n        self.host = None\n\n        #: binary lister port\n        self.port = None\n\n        if node_dict is not None:\n            self._parse_dict(node_dict)\n\n    def _parse_dict(self, node_dict):\n        self.id = node_dict['id']\n        self.name = node_dict['name']\n        self.started_on = node_dict['startedOn']\n        listener = None\n        for l in node_dict['listeners']:\n            if l['protocol'] == 'ONetworkProtocolBinary':\n                listener = l\n                break\n\n        if listener:\n            listen = listener['listen'].split(':')\n            self.host = listen[0]\n            self.port = listen[1]\n\n    def __str__(self):\n        return self.name\npyorient/otypes.py\nclass OrientVersion(object):\n\n    def __init__(self, release):\n        \"\"\"\n        Object representing Orient db release Version\n\n        :param release: String release\n        \"\"\"\n\n        #: string full OrientDB release\n        self.release = release\n\n        #: Major version\n        self.major = None\n\n        #: Minor version\n        self.minor = None\n\n        #: build number\n        self.build = None\n\n        #: string build version\n        self.subversion = None\n\n        self._parse_version(release)\n\n    def _parse_version( self, string_release ):\n\n        import re\n        if not isinstance(string_release, str):\n            string_release = string_release.decode()\n\n        try:\n            version_info = string_release.split( \".\" )\n            self.major = version_info[0]\n            self.minor = version_info[1]\n            self.build = version_info[2]\n        except IndexError:\n            pass\n\n        regx = re.match('.*([0-9]+).*', self.major )\n        self.major = regx.group(1)\n\n        try:\n            _temp = self.minor.split( \"-\" )\n            self.minor = _temp[0]\n            self.subversion = _temp[1]\n        except IndexError:\n            pass\n\n        try:\n            regx = re.match( '([0-9]+)[\\.\\- ]*(.*)', self.build )\n            self.build = regx.group(1)\n            self.subversion = regx.group(2)\n        except TypeError:\n            pass\n\n        self.major = int( self.major )\n        self.minor = int( self.minor )\n        self.build = 0 if self.build is None else int( self.build )\n        self.subversion = '' if self.subversion is None else str( self.subversion )\n\n    def __str__(self):\n        return self.release\npyorient/constants.py\nDB_TYPE_DOCUMENT    = 'document'\npyorient/constants.py\nFIELD_SHORT = {\"type\": SHORT, \"bytes\": 2, \"struct\": None}\npyorient/otypes.py\nclass OrientRecord(object):\n    \"\"\"\n    Object that represent an Orient Document / Record\n\n    \"\"\"\n    oRecordData = property(lambda self: self.__o_storage)\n\n    def __str__(self):\n        rep = \"\"\n        if self.__o_storage:\n            rep = str( self.__o_storage )\n        if self.__o_class is not None:\n            rep = \"'@\" + str(self.__o_class) + \"':\" + rep + \"\"\n        if self.__version is not None:\n            rep = rep + \",'version':\" + str(self.__version)\n        if self.__rid is not None:\n            rep = rep + \",'rid':'\" + str(self.__rid) + \"'\"\n        return '{' + rep + '}'\n\n    @staticmethod\n    def addslashes(string):\n        l = [ \"\\\\\", '\"', \"'\", \"\\0\", ]\n        for i in l:\n            if i in string:\n                string = string.replace( i, '\\\\' + i )\n        return string\n\n    def __init__(self, content=None):\n\n        self.__rid = None\n        self.__version = None\n        self.__o_class = None\n        self.__o_storage = {}\n\n        if not content:\n            content = {}\n        for key in content.keys():\n            if key == '__rid':  # Ex: select @rid, field from v_class\n                self.__rid = content[ key ]\n                # self.__rid = OrientRecordLink( content[ key ][ 1: ] )\n            elif key == '__version':  # Ex: select @rid, @version from v_class\n                self.__version = content[key]\n            elif key == '__o_class':\n                self.__o_class = content[ key ]\n            elif key[0:1] == '@':\n                # special case dict\n                # { '@my_class': { 'accommodation': 'hotel' } }\n                self.__o_class = key[1:]\n                for _key, _value in content[key].items():\n                    if isinstance(_value, basestring):\n                        self.__o_storage[_key] = self.addslashes( _value )\n                    else:\n                        self.__o_storage[_key] = _value\n            elif key == '__o_storage':\n                self.__o_storage = content[key]\n            else:\n                self.__o_storage[key] = content[key]\n\n    def _set_keys(self, content=dict):\n        for key in content.keys():\n                self._set_keys( content[key] )\n\n    @property\n    def _in(self):\n        try:\n            return self.__o_storage['in']\n        except KeyError:\n            return None\n\n    @property\n    def _out(self):\n        try:\n            return self.__o_storage['out']\n        except KeyError:\n            return None\n\n    @property\n    def _rid(self):\n        return self.__rid\n\n    @property\n    def _version(self):\n        return self.__version\n\n    @property\n    def _class(self):\n        return self.__o_class\n\n    def update(self, **kwargs):\n        self.__rid = kwargs.get('__rid', None)\n        self.__version = kwargs.get('__version', None)\n        if self.__o_class is None:\n            self.__o_class = kwargs.get('__o_class', None)\n\n    \"\"\" This method is for backward compatibility when someone\n        use 'getattr(record, a_key)' \"\"\"\n    def __getattr__(self, item):\n        \"\"\"\n        :param item: string\n        :return: mixed\n        :raise: AttributeError\n        \"\"\"\n        try:\n            return self.__o_storage[item]\n        except KeyError:\n            raise AttributeError( \"'OrientRecord' object has no attribute \"\n                                  \"'\" + item + \"'\" )\npyorient/messages/base.py\nclass BaseMessage(object):\n\n    def __init__(self, sock=OrientSocket):\n        \"\"\"\n        :type sock: OrientSocket\n        \"\"\"\n        sock.get_connection()\n        self._orientSocket = sock\n        self._protocol = self._orientSocket.protocol\n        self._session_id = self._orientSocket.session_id\n\n        # handles token auth\n        self._auth_token = self._orientSocket.auth_token\n        self._request_token = False\n\n        self._header = []\n        \"\"\":type : list of [str]\"\"\"\n\n        self._body = []\n        \"\"\":type : list of [str]\"\"\"\n\n        self._fields_definition = []\n        \"\"\":type : list of [object]\"\"\"\n\n        self._command = chr(0)\n        self._db_opened = self._orientSocket.db_opened\n        self._connected = self._orientSocket.connected\n\n        self._node_list = []\n        \"\"\":type : list of [OrientNode]\"\"\"\n\n        self._serializer = None\n\n        self._output_buffer = b''\n        self._input_buffer = b''\n\n        # callback function for async queries\n        self._callback = None\n\n        # callback for push received from the server\n        self._push_callback = None\n\n        self._need_token = True\n\n        global in_transaction\n        in_transaction = False\n\n    def get_serializer(self):\n        \"\"\"\n        Lazy return of the serialization, we retrive the type from the :class: `OrientSocket <pyorient.orient.OrientSocket>` object\n        :return: an Instance of the serializer suitable for decoding or encoding\n        \"\"\"\n        if self._orientSocket.serialization_type==OrientSerialization.Binary:\n            return OrientSerialization.get_impl(self._orientSocket.serialization_type,\n                                                self._orientSocket._props)\n        else:\n            return OrientSerialization.get_impl(self._orientSocket.serialization_type)\n\n    def get_orient_socket_instance(self):\n        return self._orientSocket\n\n    def is_connected(self):\n        return self._connected is True\n\n    def database_opened(self):\n        return self._db_opened\n\n    def get_cluster_map(self):\n        \"\"\":type : list of [OrientNode]\"\"\"\n        return self._node_list\n\n\n    def set_session_token( self, token='' ):\n        \"\"\"\n        :param token: Set the request to True to use the token authentication\n        :type token: bool|string\n        :return: self\n        \"\"\"\n        if token != '' and token is not None:\n            if type(token) is bool:\n                self._request_token = token\n            elif type(token) is str or type(token) is bytes:\n                self._request_token = True\n                self._auth_token = token\n                self._db_opened = True\n                self._connected = True\n                self._update_socket_token()\n        return self\n\n    def get_session_token( self ):\n        \"\"\"\n        Retrieve the session token to reuse after\n        :return:\n        \"\"\"\n        return self._auth_token\n\n    def _update_socket_id(self):\n        \"\"\"Force update of socket id from inside the class\"\"\"\n        self._orientSocket.session_id = self._session_id\n        return self\n\n    def _update_socket_token(self):\n        \"\"\"Force update of socket token from inside the class\"\"\"\n        self._orientSocket.auth_token = self._auth_token\n        return self\n\n    def _reset_fields_definition(self):\n        self._fields_definition = []\n\n    def prepare(self, *args):\n\n        # session_id\n        self._fields_definition.insert( 1, ( FIELD_INT, self._session_id ) )\n\n\n        \"\"\"\n        #  Token authentication handling\n        #  we must recognize ConnectMessage and DbOpenMessage messages\n        \"\"\"\n        if self._need_token and self._request_token is True:\n            self._fields_definition.insert(\n                2, ( FIELD_STRING, self._auth_token )\n            )\n\n        self._output_buffer = b''.join(\n            self._encode_field( x ) for x in self._fields_definition\n        )\n        return self\n\n    def get_protocol(self):\n        if self._protocol < 0:\n            self._protocol = self._orientSocket.protocol\n        return self._protocol\n\n    def _decode_header(self):\n\n        # read header's information\n        self._header = [ self._decode_field( FIELD_BYTE ),\n                         self._decode_field( FIELD_INT ) ]\n\n        # decode message errors and raise an exception\n        if self._header[0] == 1:\n\n            # Parse the error\n            exception_class = b''\n            exception_message = b''\n\n            more = self._decode_field( FIELD_BOOLEAN )\n\n            while more:\n                # read num bytes by the field definition\n                exception_class += self._decode_field( FIELD_STRING )\n                exception_message += self._decode_field( FIELD_STRING )\n                more = self._decode_field( FIELD_BOOLEAN )\n\n                if self.get_protocol() > 18:  # > 18 1.6-snapshot\n                    # read serialized version of exception thrown on server side\n                    # useful only for java clients\n                    serialized_exception = self._decode_field( FIELD_STRING )\n                    # trash\n                    del serialized_exception\n\n            raise PyOrientCommandException(\n                exception_class.decode( 'utf8' ),\n                [ exception_message.decode( 'utf8' ) ]\n            )\n\n        elif self._header[0] == 3:\n            # Push notification, Node cluster changed\n            # TODO: UNTESTED CODE!!!\n            # FIELD_BYTE (OChannelBinaryProtocol.PUSH_DATA);  # WRITE 3\n            # FIELD_INT (Integer.MIN_VALUE);  # SESSION ID = 2^-31\n            # 80: \\x50 Request Push 1 byte: Push command id\n            push_command_id = self._decode_field(FIELD_BYTE)\n            push_message = self._decode_field( FIELD_STRING )\n            _, payload = self.get_serializer().decode(push_message)\n            if self._push_callback:\n                self._push_callback(push_command_id, payload)\n\n            end_flag = self._decode_field( FIELD_BYTE )\n\n            # this flag can be set more than once\n            while end_flag == 3:\n                self._decode_field( FIELD_INT )  # FAKE SESSION ID = 2^-31\n                op_code = self._decode_field( FIELD_BYTE )  # 80: 0x50 Request Push\n\n                # REQUEST_PUSH_RECORD\t        79\n                # REQUEST_PUSH_DISTRIB_CONFIG\t80\n                # REQUEST_PUSH_LIVE_QUERY\t    81\n                if op_code == 80:\n                    # for node in\n                    payload = self.get_serializer().decode(\n                        self._decode_field( FIELD_STRING )\n                    )  # JSON WITH THE NEW CLUSTER CFG\n\n                    # reset the nodelist\n                    self._node_list = []\n                    for node in payload['members']:\n                        self._node_list.append( OrientNode( node ) )\n\n                end_flag = self._decode_field( FIELD_BYTE )\n\n            # Try to set the new session id???\n            self._header[1] = self._decode_field( FIELD_INT )  # REAL SESSION ID\n            pass\n\n        from .connection import ConnectMessage\n        from .database import DbOpenMessage\n        \"\"\"\n        #  Token authentication handling\n        #  we must recognize ConnectMessage and DbOpenMessage messages\n            TODO: change this check avoiding cross import,\n            importing a subclass in a super class is bad\n        \"\"\"\n        if not isinstance(self, (ConnectMessage, DbOpenMessage)) \\\n                and self._request_token is True:\n            token_refresh = self._decode_field(FIELD_STRING)\n            if token_refresh != b'':\n                self._auth_token = token_refresh\n                self._update_socket_token()\n\n    def _decode_body(self):\n        # read body\n        for field in self._fields_definition:\n            self._body.append( self._decode_field( field ) )\n\n        # clear field stack\n        self._reset_fields_definition()\n        return self\n\n    def _decode_all(self):\n        self._decode_header()\n        self._decode_body()\n\n    def fetch_response(self, *_continue):\n        \"\"\"\n        # Decode header and body\n        # If flag continue is set( Header already read ) read only body\n        :param _continue:\n        :return:\n        \"\"\"\n        if len(_continue) is not 0:\n            self._body = []\n            self._decode_body()\n            self.dump_streams()\n        # already fetched, get last results as cache info\n        elif len(self._body) is 0:\n            self._decode_all()\n            self.dump_streams()\n        return self._body\n\n    def dump_streams(self):\n        if is_debug_active():\n            if len( self._output_buffer ):\n                print(\"\\nRequest :\")\n                hexdump( self._output_buffer )\n                # print(repr(self._output_buffer))\n            if len( self._input_buffer ):\n                print(\"\\nResponse:\")\n                hexdump( self._input_buffer )\n                # print(repr(self._input_buffer))\n\n    def _append(self, field):\n        \"\"\"\n        @:rtype self: BaseMessage\n        @type field: object\n        \"\"\"\n        self._fields_definition.append( field )\n        return self\n\n    def __str__(self):\n\n        return \"\\n_output_buffer: \\n\" + hexdump( self._output_buffer, 'return' ) \\\n               + \"\\n\\n_input_buffer: \\n\" + hexdump( self._input_buffer, 'return' )\n\n    def send(self):\n        if self._orientSocket.in_transaction is False:\n            self._orientSocket.write( self._output_buffer )\n            self._reset_fields_definition()\n        if is_debug_active():\n            self.dump_streams()\n            # reset output buffer\n            self._output_buffer = b\"\"\n\n        return self\n\n    def close(self):\n        self._orientSocket.close()\n\n    @staticmethod\n    def _encode_field(field):\n\n        # tuple with type\n        t, v = field\n        _content = None\n\n        if t['type'] == INT:\n            _content = struct.pack(\"!i\", v)\n        elif t['type'] == SHORT:\n            _content = struct.pack(\"!h\", v)\n        elif t['type'] == LONG:\n            _content = struct.pack(\"!q\", v)\n        elif t['type'] == BOOLEAN:\n            if sys.version_info[0] < 3:\n                _content = chr(1) if v else chr(0)\n            else:\n                _content = bytes([1]) if v else bytes([0])\n        elif t['type'] == BYTE:\n            if sys.version_info[0] < 3:\n                _content = v\n            else:\n                _content = bytes([ord(v)])\n        elif t['type'] == BYTES:\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRING:\n            if sys.version_info[0] >= 3:\n                if isinstance(v, str):\n                    v = v.encode('utf-8')\n            else:\n                if isinstance(v, unicode):\n                    v = v.encode('utf-8')\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRINGS:\n            _content = b''\n            for s in v:\n                if sys.version_info[0] >= 3:\n                    if isinstance(s, str):\n                        s = s.encode('utf-8')\n                else:\n                    if isinstance(s, unicode):\n                        s = s.encode('utf-8')\n                _content += struct.pack(\"!i\", len(s)) + s\n\n        return _content\n\n    def _decode_field(self, _type):\n        _value = b\"\"\n        # read buffer length and decode value by field definition\n        if _type['bytes'] is not None:\n            _value = self._orientSocket.read( _type['bytes'] )\n        # if it is a string decode first 4 Bytes as INT\n        # and try to read the buffer\n        if _type['type'] == STRING or _type['type'] == BYTES:\n\n            _len = struct.unpack('!i', _value)[0]\n            if _len == -1 or _len == 0:\n                _decoded_string = b''\n            else:\n                _decoded_string = self._orientSocket.read( _len )\n\n            self._input_buffer += _value\n            self._input_buffer += _decoded_string\n\n            return _decoded_string\n\n        elif _type['type'] == RECORD:\n\n            # record_type\n            record_type = self._decode_field( _type['struct'][0] )\n\n            rid = \"#\" + str( self._decode_field( _type['struct'][1] ) )\n            rid += \":\" + str( self._decode_field( _type['struct'][2] ) )\n            \n            version = self._decode_field( _type['struct'][3] )\n            content = self._decode_field( _type['struct'][4] )\n            return {'rid': rid, 'record_type': record_type,\n                    'content': content, 'version': version}\n\n        elif _type['type'] == LINK:\n\n            rid = \"#\" + str( self._decode_field( _type['struct'][0] ) )\n            rid += \":\" + str( self._decode_field( _type['struct'][1] ) )\n            return rid\n\n        else:\n            self._input_buffer += _value\n\n            if _type['type'] == BOOLEAN:\n                return ord(_value) == 1\n            elif _type['type'] == BYTE:\n                return ord(_value)\n            elif _type['type'] == CHAR:\n                return _value\n            elif _type['type'] == SHORT:\n                return struct.unpack('!h', _value)[0]\n            elif _type['type'] == INT:\n                return struct.unpack('!i', _value)[0]\n            elif _type['type'] == LONG:\n                return struct.unpack('!q', _value)[0]\n\n    def _read_async_records(self):\n        \"\"\"\n        # async-result-type byte as trailing byte of a record can be:\n        # 0: no records remain to be fetched\n        # 1: a record is returned as a result set\n        # 2: a record is returned as pre-fetched to be loaded in client's\n        #       cache only. It's not part of the result set but the client\n        #       knows that it's available for later access\n        \"\"\"\n        _status = self._decode_field( FIELD_BYTE )  # status\n\n        while _status != 0:\n\n            try:\n\n                # if a callback for the cache is not set, raise exception\n                if not hasattr(self._callback, '__call__'):\n                    raise AttributeError()\n\n                _record = self._read_record()\n\n                if _status == 1:  # async record type\n                    # async_records.append( _record )  # save in async\n                    self._callback( _record )  # save in async\n                elif _status == 2:  # cache\n                    # cached_records.append( _record )  # save in cache\n                    self._callback( _record )  # save in cache\n\n            except AttributeError:\n                # AttributeError: 'RecordLoadMessage' object has\n                # no attribute '_command_type'\n                raise PyOrientBadMethodCallException(\n                    str(self._callback) + \" is not a callable function\", [])\n            finally:\n                # read new status and flush the debug buffer\n                _status = self._decode_field( FIELD_BYTE )  # status\n\n    def _read_record(self):\n        \"\"\"\n        # The format depends if a RID is passed or an entire\n            record with its content.\n\n        # In case of null record then -2 as short is passed.\n\n        # In case of RID -3 is passes as short and then the RID:\n            (-3:short)(cluster-id:short)(cluster-position:long).\n\n        # In case of record:\n            (0:short)(record-type:byte)(cluster-id:short)\n            (cluster-position:long)(record-version:int)(record-content:bytes)\n\n        :raise: PyOrientNullRecordException\n        :return: OrientRecordLink,OrientRecord\n        \"\"\"\n        marker = self._decode_field( FIELD_SHORT )  # marker\n\n        if marker is -2:\n            raise PyOrientNullRecordException('NULL Record', [])\n        elif marker is -3:\n            res = OrientRecordLink( self._decode_field( FIELD_TYPE_LINK ) )\n        else:\n            # read record\n            __res = self._decode_field( FIELD_RECORD )\n            \n            if self._orientSocket.serialization_type==OrientSerialization.Binary:\n                class_name, data = self.get_serializer().decode(__res['content'])\n            else:\n                # bug in orientdb csv serialization in snapshot 2.0\n                class_name, data = self.get_serializer().decode(__res['content'].rstrip())\n\n\n            res = OrientRecord(\n                dict(\n                    __o_storage=data,\n                    __o_class=class_name,\n                    __version=__res['version'],\n                    __rid=__res['rid']\n                )\n            )\n\n        self.dump_streams()  # debug log\n        self._output_buffer = b''\n        self._input_buffer = b''\n\n        return res\npyorient/constants.py\nFIELD_LONG = {\"type\": LONG, \"bytes\": 8, \"struct\": None}\npyorient/constants.py\nDB_DROP_OP                 = chr(7)\npyorient/constants.py\nDB_TYPES            = (\n    DB_TYPE_DOCUMENT,\n    DB_TYPE_GRAPH,\n)\npyorient/exceptions.py\nclass PyOrientBadMethodCallException(PyOrientException):\n    pass\npyorient/constants.py\nFIELD_STRINGS = {\"type\": STRINGS, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nFIELD_BYTE = {\"type\": BYTE, \"bytes\": 1, \"struct\": None}\npyorient/otypes.py\nclass OrientCluster(object):\n    def __init__(self, name, cluster_id, cluster_type=None, segment=None):\n        \"\"\"\n        Information regarding a Cluster on the Orient Server\n        :param name: str name of the cluster\n        :param id: int id of the cluster\n        :param type: cluster type (only for version <24 of the protocol)\n        :param segment: cluster segment (only for version <24 of the protocol)\n        \"\"\"\n        #: str name of the cluster\n        self.name = name\n        #: int idof the cluster\n        self.id = cluster_id\n        self.type = cluster_type\n        self.segment = segment\n\n    def __str__(self):\n        return \"%s: %d\" % (self.name, self.id)\n\n    def __eq__(self, other):\n        return self.name == other.name and self.id == other.id\n\n    def __ne__(self, other):\n        return self.name != other.name or self.id != other.id\npyorient/constants.py\nDB_LIST_OP                 = chr(74)\npyorient/constants.py\nNAME = \"OrientDB Python binary client (pyorient)\"\npyorient/serializations.py\nclass OrientSerialization(object):\n    \"\"\"\n    Enum representing the available serialization\n    \"\"\"\n    #: CSV the default serialization\n    CSV = \"ORecordDocument2csv\"\n\n    #: Now unimplemented\n    Binary = \"ORecordSerializerBinary\"\n\n    @classmethod\n    def get_impl(cls, impl, props=None):\n        impl_map = {\n            cls.CSV: OrientSerializationCSV,\n            cls.Binary: OrientSerializationBinary,\n        }\n        implementation = impl_map.get(impl, False)\n        if not implementation:\n            raise PyOrientBadMethodCallException(\n                impl + ' is not an available serialization type', []\n            )\n        if impl == cls.Binary:\n            if not binary_support:\n                raise Exception( \"To support Binary Serialization, pyorient_native must be installed\" )\n            return implementation(props)\n        else:\n            return implementation()\npyorient/constants.py\nSTORAGE_TYPES       = (\n    STORAGE_TYPE_LOCAL,\n    STORAGE_TYPE_PLOCAL,\n    STORAGE_TYPE_MEMORY,\n)\npyorient/constants.py\nDB_OPEN_OP                 = chr(3)\n", "answers": ["        if storage_type in STORAGE_TYPES:"], "length": 2885, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "ad9311699fd6da3dd844b69dd8346276b1b73fb65bf83fd7"}
{"input": "import testasyouthink.function.CheckedSupplier;\nimport testasyouthink.function.Functions;\nimport testasyouthink.preparation.Preparation;\nimport testasyouthink.GivenWhenThenDsl.PreparationStage.AndGivenArgument;\nimport testasyouthink.GivenWhenThenDsl.PreparationStage.AndGivenTwoArguments;\nimport testasyouthink.GivenWhenThenDsl.VerificationStage.Then;\nimport testasyouthink.GivenWhenThenDsl.VerificationStage.ThenFailure;\nimport testasyouthink.GivenWhenThenDsl.VerificationStage.ThenWithoutResult;\nimport testasyouthink.function.CheckedBiConsumer;\nimport testasyouthink.function.CheckedBiFunction;\nimport testasyouthink.function.CheckedConsumer;\n/*-\n * #%L\n * Test As You Think\n * %%\n * Copyright (C) 2017 - 2018 Xavier Pigeon and TestAsYouThink contributors\n * %%\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Lesser Public License for more details.\n * \n * You should have received a copy of the GNU General Lesser Public\n * License along with this program.  If not, see\n * <http://www.gnu.org/licenses/lgpl-3.0.html>.\n * #L%\n */\n\npackage testasyouthink;\n\n\npublic class GivenArgumentWhenSteps<$SystemUnderTest, $Argument> implements AndGivenArgument<$SystemUnderTest,\n        $Argument> {\n\n    private final Functions functions = Functions.INSTANCE;\n    private final Preparation<$SystemUnderTest> preparation;\n    private final ThenStepFactory thenStepFactory = ThenStepFactory.INSTANCE;\n\n    GivenArgumentWhenSteps(Preparation<$SystemUnderTest> preparation) {this.preparation = preparation;}\n\n    @Override\n    public <$Argument2> AndGivenTwoArguments<$SystemUnderTest, $Argument, $Argument2> andArgument(\n            CheckedSupplier<$Argument2> givenStep) {\n        preparation.recordGivenStep(givenStep);\n        return new GivenTwoArgumentsWhenSteps<>(preparation);\n    }\n\n    @Override\n    public <$Argument2> AndGivenTwoArguments<$SystemUnderTest, $Argument, $Argument2> andArgument(\n            Class<$Argument2> mutableArgumentClass, CheckedConsumer<$Argument2> givenStep) {\n        preparation.recordGivenStep(mutableArgumentClass, givenStep);\n        return new GivenTwoArgumentsWhenSteps<>(preparation);\n    }\n\n    @Override\n    public <$Argument2> AndGivenTwoArguments<$SystemUnderTest, $Argument, $Argument2> andArgument(String description,\n            CheckedSupplier<$Argument2> givenStep) {\n        return andArgument(givenStep);\n    }\n\n    @Override\n    public <$Argument2> AndGivenTwoArguments<$SystemUnderTest, $Argument, $Argument2> andArgument(String description,\n            $Argument2 argument) {\n        preparation.recordGivenStep(functions.toCheckedSupplier(argument));\n        return new GivenTwoArgumentsWhenSteps<>(preparation);\n    }\n\n    @Override", "context": "test-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface ThenWithoutResult<$SystemUnderTest> {\n\n    AndThenWithoutResult<$SystemUnderTest> then(CheckedRunnable thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> then(String expectationSpecification, CheckedRunnable thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> then(CheckedConsumer<$SystemUnderTest> thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> then(String expectationSpecification,\n            CheckedConsumer<$SystemUnderTest> thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> then(CheckedBooleanSupplier thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> thenSutRepliesWithin(long timeLimit);\n\n    AndThenWithoutResult<$SystemUnderTest> thenSutRepliesWithin(Duration durationLimit);\n\n    void thenItSucceeds();\n\n    AndThenWithoutResultStandardOutputCaptured<$SystemUnderTest> thenStandardOutput(\n            CheckedConsumer<File> thenStep);\n\n    AndThenWithoutResultStandardOutputCaptured<$SystemUnderTest> thenStandardOutput(\n            String expectationSpecification, CheckedConsumer<File> thenStep);\n}\ntest-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface ThenFailure {\n\n    AndThenFailure thenItFails();\n}\ntest-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface Then<$SystemUnderTest, $Result> {\n\n    AndThen<$SystemUnderTest, $Result> then(CheckedConsumer<$Result> thenStep);\n\n    AndThen<$SystemUnderTest, $Result> then(String expectationSpecification, CheckedConsumer<$Result> thenStep);\n\n    AndThen<$SystemUnderTest, $Result> then(CheckedRunnable thenStep);\n\n    AndThen<$SystemUnderTest, $Result> then(String expectationSpecification, CheckedRunnable thenStep);\n\n    AndThen<$SystemUnderTest, $Result> then(CheckedPredicate<$Result> thenStep);\n\n    AndThen<$SystemUnderTest, $Result> thenSutRepliesWithin(long timeLimit);\n\n    AndThen<$SystemUnderTest, $Result> thenSutRepliesWithin(Duration durationLimit);\n\n    void then(List<CheckedPredicate<$Result>> thenSteps);\n\n    void then(CheckedConsumer<$Result> thenStepAboutResult,\n            CheckedConsumer<$SystemUnderTest> thenStepAboutSystemUnderTest);\n\n    void then(CheckedPredicate<$Result> thenStepAboutResult,\n            CheckedPredicate<$SystemUnderTest> thenStepAboutSystemUnderTest);\n\n    AndThenStandardOutputCaptured<$SystemUnderTest, $Result> thenStandardOutput(CheckedConsumer<File> thenStep);\n\n    AndThenStandardOutputCaptured<$SystemUnderTest, $Result> thenStandardOutput(String expectationSpecification,\n            CheckedConsumer<File> thenStep);\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedBiConsumer.java\n@FunctionalInterface\npublic interface CheckedBiConsumer<T, U> {\n\n    void accept(T t, U u) throws Throwable;\n}\ntest-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface AndGivenArgument<$SystemUnderTest, $Argument> extends WhenApplyingOneArgument<$SystemUnderTest,\n        $Argument> {\n\n    <$Argument2> AndGivenTwoArguments<$SystemUnderTest, $Argument, $Argument2> andArgument(\n            CheckedSupplier<$Argument2> givenStep);\n\n    <$Argument2> AndGivenTwoArguments<$SystemUnderTest, $Argument, $Argument2> andArgument(\n            Class<$Argument2> mutableArgumentClass, CheckedConsumer<$Argument2> givenStep);\n\n    <$Argument2> AndGivenTwoArguments<$SystemUnderTest, $Argument, $Argument2> andArgument(String description,\n            CheckedSupplier<$Argument2> givenStep);\n\n    <$Argument2> AndGivenTwoArguments<$SystemUnderTest, $Argument, $Argument2> andArgument(String description,\n            $Argument2 argument);\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSupplier.java\npublic interface CheckedSupplier<R> {\n\n    R get() throws Throwable;\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedConsumer.java\n@FunctionalInterface\npublic interface CheckedConsumer<T> {\n\n    void accept(T t) throws Throwable;\n}\ntest-as-you-think-core/src/main/java/testasyouthink/preparation/Preparation.java\npublic class Preparation<$SystemUnderTest> {\n\n    private final Functions functions = Functions.INSTANCE;\n    private final SutPreparation sutPreparation = SutPreparation.INSTANCE;\n    private final ArgumentPreparation argumentPreparation = ArgumentPreparation.INSTANCE;\n    private final Queue<Consumer<$SystemUnderTest>> givenSteps;\n    private Supplier<$SystemUnderTest> givenSutStep;\n    private Queue<Supplier> argumentSuppliers;\n    private $SystemUnderTest systemUnderTest;\n    private boolean stdoutCaptured;\n\n    public Preparation() {\n        givenSteps = new ArrayDeque<>();\n        argumentSuppliers = new LinkedList<>();\n        stdoutCaptured = false;\n    }\n\n    public Preparation(Class<$SystemUnderTest> sutClass) {\n        this();\n        givenSutStep = sutPreparation.buildSutSupplier(sutClass);\n    }\n\n    public Preparation($SystemUnderTest systemUnderTest) {\n        this();\n        givenSutStep = sutPreparation.buildSutSupplier(systemUnderTest);\n    }\n\n    public Preparation(CheckedSupplier<$SystemUnderTest> givenSutStep) {\n        this();\n        this.givenSutStep = sutPreparation.buildSutSupplier(givenSutStep);\n    }\n\n    public void recordGivenStep(CheckedRunnable givenStep) {\n        givenSteps.add(functions.toConsumer(() -> {\n            try {\n                givenStep.run();\n            } catch (Throwable throwable) {\n                throw new PreparationError(\"Fails to prepare the test fixture!\", throwable);\n            }\n        }));\n    }\n\n    public void recordGivenStep(CheckedConsumer<$SystemUnderTest> givenStep) {\n        givenSteps.add(sutPreparation.buildSutSupplier(givenStep));\n    }\n\n    public <$Argument> void recordGivenStep(CheckedSupplier<$Argument> givenStep) {\n        argumentSuppliers.add(argumentPreparation.buidArgumentSupplier(givenStep));\n    }\n\n    public <$Argument> void recordGivenStep(Class<$Argument> mutableArgumentClass,\n            CheckedConsumer<$Argument> givenStep) {\n        argumentSuppliers.add(argumentPreparation.buildMutableArgumentSupplier(mutableArgumentClass, givenStep));\n    }\n\n    public Queue<Supplier> getArgumentSuppliers() {\n        return argumentSuppliers;\n    }\n\n    public void prepareFixtures() {\n        $SystemUnderTest sutToPrepareAtFirst = systemUnderTest();\n        while (!givenSteps.isEmpty()) {\n            givenSteps\n                    .poll()\n                    .accept(sutToPrepareAtFirst);\n        }\n    }\n\n    public void prepareFixturesSeparately() {\n        prepareFixtures();\n        argumentSuppliers.forEach(Supplier::get);\n    }\n\n    private $SystemUnderTest systemUnderTest() {\n        if (systemUnderTest == null && givenSutStep != null) {\n            systemUnderTest = givenSutStep.get();\n        }\n        return systemUnderTest;\n    }\n\n    public Supplier<$SystemUnderTest> supplySut() {\n        return this::systemUnderTest;\n    }\n\n    public void captureStdout() {\n        if (!stdoutCaptured) {\n            recordGivenStep(() -> {\n                Path stdoutPath = Files.createTempFile(\"actual_result\", \".txt\");\n                stdoutPath\n                        .toFile()\n                        .deleteOnExit();\n                StandardRedirection.STDOUT_PATHS.put(currentThread().getId(), stdoutPath);\n                StandardRedirection.STREAMS_TO_FILE.put(currentThread().getId(),\n                        new PrintStream(stdoutPath.toString()));\n            });\n\n            stdoutCaptured = true;\n        }\n    }\n\n    public Path getStdoutPath() {\n        return StandardRedirection.STDOUT_PATHS.get(currentThread().getId());\n    }\n\n    private static class StandardRedirection {\n\n        private static final Map<Long, Path> STDOUT_PATHS;\n        private static final Map<Long, PrintStream> STREAMS_TO_FILE;\n        private static final PrintStream SYSTEM_OUT;\n        private static final PrintStream SYSTEM_ERR;\n\n        static {\n            SYSTEM_OUT = System.out;\n            SYSTEM_ERR = System.err;\n            STDOUT_PATHS = new HashMap<>();\n            STREAMS_TO_FILE = new HashMap<>();\n\n            commuteStandardOutputs();\n        }\n\n        private static void commuteStandardOutputs() {\n            redirectStreamOnce(SYSTEM_OUT, System::setOut);\n            redirectStreamOnce(SYSTEM_ERR, System::setErr);\n        }\n\n        private static void redirectStreamOnce(final PrintStream printStream, Consumer<PrintStream> redirectTo) {\n            PrintStream allInOne = new PrintStream(new OutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    printStream.write(b);\n                    if (!STREAMS_TO_FILE.isEmpty()) {\n                        STREAMS_TO_FILE\n                                .get(currentThread().getId())\n                                .write(b);\n                    }\n                }\n            });\n            redirectTo.accept(allInOne);\n        }\n    }\n}\ntest-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface AndGivenTwoArguments<$SystemUnderTest, $Argument1, $Argument2> extends\n        WhenApplyingTwoArguments<$SystemUnderTest, $Argument1, $Argument2> {\n\n    <$Argument3> WhenApplyingThreeArguments<$SystemUnderTest, $Argument1, $Argument2, $Argument3> andArgument(\n            CheckedSupplier<$Argument3> givenStep);\n\n    <$Argument3> WhenApplyingThreeArguments<$SystemUnderTest, $Argument1, $Argument2, $Argument3> andArgument(\n            Class<$Argument3> mutableArgumentClass, CheckedConsumer<$Argument3> givenStep);\n\n    <$Argument3> WhenApplyingThreeArguments<$SystemUnderTest, $Argument1, $Argument2, $Argument3> andArgument(\n            String description, CheckedSupplier<$Argument3> givenStep);\n\n    <$Argument3> WhenApplyingThreeArguments<$SystemUnderTest, $Argument1, $Argument2, $Argument3> andArgument(\n            String description, $Argument3 argument);\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/Functions.java\npublic enum Functions {\n\n    INSTANCE;\n\n    public <T> Consumer<T> toConsumer(Runnable runnable) {\n        return toBeConsumed -> runnable.run();\n    }\n\n    public CheckedConsumer<Void> toCheckedConsumer(CheckedRunnable runnable) {\n        return toBeConsumed -> runnable.run();\n    }\n\n    public <T, R> CheckedFunction<T, R> toFunction(CheckedConsumer<T> checkedConsumer) {\n        return toBeConsumed -> {\n            checkedConsumer.accept(toBeConsumed);\n            return null;\n        };\n    }\n\n    public <R> CheckedFunction<Void, R> toCheckedFunction(CheckedSupplier<R> supplier) {\n        return Void -> supplier.get();\n    }\n\n    public <R> CheckedFunction<Void, R[]> toCheckedFunction(CheckedArraySupplier<R> supplier) {\n        return Void -> supplier.get();\n    }\n\n    public <T> CheckedFunction<T, Throwable> toFunctionWithThrowableAsResult(CheckedConsumer<T> checkedConsumer) {\n        return toBeConsumed -> {\n            Throwable result = null;\n            try {\n                checkedConsumer.accept(toBeConsumed);\n            } catch (Throwable thrown) {\n                result = thrown;\n            }\n            return result;\n        };\n    }\n\n    public CheckedFunction<Void, Throwable> toFunctionWithThrowableAsResult(CheckedRunnable whenStep) {\n        return Void -> {\n            try {\n                whenStep.run();\n            } catch (Throwable thrown) {\n                return thrown;\n            }\n            return null;\n        };\n    }\n\n    public <$Value> CheckedSupplier<$Value> toCheckedSupplier($Value value) {\n        return () -> value;\n    }\n\n    public <$Target, $Argument, $Result> CheckedFunction<$Target, $Result> toFunction(\n            CheckedBiFunction<$Target, $Argument, $Result> biFunction, Queue<Supplier> arguments) {\n        return target -> biFunction.apply(target, ($Argument) arguments\n                .remove()\n                .get());\n    }\n\n    public <$Target, $Argument1, $Argument2, $Result> CheckedFunction<$Target, $Result> toFunction(\n            CheckedTriFunction<$Target, $Argument1, $Argument2, $Result> triFunction, Queue<Supplier> arguments) {\n        return toFunction(toBiFunction(triFunction, arguments), arguments);\n    }\n\n    public <$Target, $Argument1, $Argument2, $Argument3, $Result> CheckedFunction<$Target, $Result> toFunction(\n            CheckedQuadriFunction<$Target, $Argument1, $Argument2, $Argument3, $Result> quadriFunction,\n            Queue<Supplier> arguments) {\n        return toFunction(toBiFunction(toTriFunction(quadriFunction, arguments), arguments), arguments);\n    }\n\n    public <$Target, $Argument> CheckedConsumer<$Target> toConsumer(CheckedBiConsumer<$Target, $Argument> biConsumer,\n            Queue<Supplier> arguments) {\n        return target -> biConsumer.accept(target, ($Argument) arguments\n                .remove()\n                .get());\n    }\n\n    public <$Target, $Argument1, $Argument2> CheckedConsumer<$Target> toConsumer(\n            CheckedTriConsumer<$Target, $Argument1, $Argument2> triConsumer, Queue<Supplier> arguments) {\n        return toConsumer(toBiConsumer(triConsumer, arguments), arguments);\n    }\n\n    public <$Target, $Argument1, $Argument2, $Argument3> CheckedConsumer<$Target> toConsumer(\n            CheckedQuadriConsumer<$Target, $Argument1, $Argument2, $Argument3> quadriConsumer,\n            Queue<Supplier> arguments) {\n        return toConsumer(toBiConsumer(toTriConsumer(quadriConsumer, arguments), arguments), arguments);\n    }\n\n    static class ConsumerUnitTransformation {\n\n        static <$Target, $Argument1, $Argument2> CheckedBiConsumer<$Target, $Argument1> toBiConsumer(\n                CheckedTriConsumer<$Target, $Argument1, $Argument2> triConsumer, Queue<Supplier> arguments) {\n            return (target, argument1) -> triConsumer.accept(target, argument1, ($Argument2) arguments\n                    .remove()\n                    .get());\n        }\n\n        static <$Target, $Argument1, $Argument2, $Argument3> CheckedTriConsumer<$Target, $Argument1, $Argument2>\n        toTriConsumer(\n                CheckedQuadriConsumer<$Target, $Argument1, $Argument2, $Argument3> quadriConsumer,\n                Queue<Supplier> arguments) {\n            return (target, argument1, argument2) -> quadriConsumer.accept(target, argument1, argument2,\n                    ($Argument3) arguments\n                            .remove()\n                            .get());\n        }\n    }\n\n    static class FunctionUnitTransformation {\n\n        static <$Target, $Argument1, $Argument2, $Result> CheckedBiFunction<$Target, $Argument1, $Result> toBiFunction(\n                CheckedTriFunction<$Target, $Argument1, $Argument2, $Result> triFunction, Queue<Supplier> arguments) {\n            return (target, argument1) -> triFunction.apply(target, argument1, ($Argument2) arguments\n                    .remove()\n                    .get());\n        }\n\n        static <$Target, $Argument1, $Argument2, $Argument3, $Result> CheckedTriFunction<$Target, $Argument1,\n                $Argument2, $Result> toTriFunction(\n                CheckedQuadriFunction<$Target, $Argument1, $Argument2, $Argument3, $Result> quadriFunction,\n                Queue<Supplier> arguments) {\n            return (target, argument1, argument2) -> quadriFunction.apply(target, argument1, argument2,\n                    ($Argument3) arguments\n                            .remove()\n                            .get());\n        }\n    }\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedBiFunction.java\n@FunctionalInterface\npublic interface CheckedBiFunction<T, U, R> {\n\n    R apply(T t, U u) throws Throwable;\n}\n", "answers": ["    public ThenWithoutResult<$SystemUnderTest> when(CheckedBiConsumer<$SystemUnderTest, $Argument> whenStep) {"], "length": 1226, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "1e92aed924b1d5384f31de520133e8b0d337033627ce5ee3"}
{"input": "import static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport com.dd.plist.NSArray;\nimport com.dd.plist.NSDictionary;\nimport com.dd.plist.NSNumber;\nimport com.dd.plist.NSObject;\nimport com.dd.plist.NSString;\nimport com.dd.plist.PropertyListFormatException;\nimport com.dd.plist.XMLPropertyListParser;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.iosdevicecontrol.util.FluentLogger;\nimport com.google.common.io.MoreFiles;\nimport com.google.common.io.RecursiveDeleteOption;\nimport com.google.iosdevicecontrol.command.Command;\nimport com.google.iosdevicecontrol.command.CommandFailureException;\nimport com.google.iosdevicecontrol.command.CommandProcess;\nimport com.google.iosdevicecontrol.command.CommandResult;\nimport com.google.iosdevicecontrol.IosAppBundleId;\nimport com.google.iosdevicecontrol.IosAppInfo;\nimport com.google.iosdevicecontrol.IosAppProcess;\nimport com.google.iosdevicecontrol.IosDevice;\nimport com.google.iosdevicecontrol.IosDeviceException;\nimport com.google.iosdevicecontrol.IosDeviceResource;\nimport com.google.iosdevicecontrol.IosDeviceSocket;\nimport com.google.iosdevicecontrol.IosModel;\nimport com.google.iosdevicecontrol.IosVersion;\nimport com.google.iosdevicecontrol.real.DevDiskImages.DiskImage;\nimport com.google.iosdevicecontrol.util.CheckedCallable;\nimport com.google.iosdevicecontrol.util.CheckedCallables;\nimport com.google.iosdevicecontrol.util.ForwardingSocket;\nimport com.google.iosdevicecontrol.util.PlistParser;\nimport com.google.iosdevicecontrol.util.RetryCallable;\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.ParseException;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.ImageInputStream;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.joda.time.Duration;\nimport org.xml.sax.SAXException;\n            })\n        .call();\n  }\n\n  /** Thrown if the developer image doesn't appear mounted when running an app. */\n  private class NoDeveloperImageMountedException extends IosDeviceException {\n    private NoDeveloperImageMountedException() {\n      super(RealDeviceImpl.this, \"Cannot run apps without mounting a developer image\");\n    }\n  }\n\n  @SuppressWarnings(\"Finally\") // b/64321948\n  @Override\n  public IosDeviceSocket openWebInspectorSocket() throws IosDeviceException {\n    int inspectorPort;\n    try (ServerSocket socket = new ServerSocket(0)) {\n      inspectorPort = socket.getLocalPort();\n    } catch (IOException e) {\n      throw new IosDeviceException(this, e);\n    }\n\n    CommandProcess inspectorProcess = idevice.webinspectorproxy(Integer.toString(inspectorPort));\n    Closeable closeProcess =\n        () -> {\n          try {\n            inspectorProcess.kill().await();\n          } catch (CommandFailureException e) {\n            throw new IOException(e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new IOException(e);\n          }\n        };\n\n    // Socket may not be open right away, so we retry.\n    Socket socket;\n    try {\n      socket =\n          RetryCallable.retry(() -> new Socket(\"localhost\", inspectorPort))\n              .withDelay(Duration.standardSeconds(1))\n              .withMaxAttempts(15)\n              .call();\n    } catch (IOException e) {\n      IosDeviceException deviceEx = new IosDeviceException(this, e);\n      try {\n        closeProcess.close();\n      } catch (Throwable suppressed) {\n        deviceEx.addSuppressed(suppressed);\n      } finally {\n        throw deviceEx;\n      }\n    }\n\n    // Wrap the socket with an augmented close method that also closes the process.\n    return IosDeviceSocket.wrap(\n        this,\n        new ForwardingSocket(socket) {\n          @Override\n          public synchronized void close() throws IOException {\n            try {\n              closeProcess.close();\n            } finally {\n              super.close();\n            }\n          }\n        });\n  }\n\n  @Override\n  public void restart() throws IosDeviceException {\n    await(idevice.diagnostics(\"restart\"));\n\n    restarting = true;\n    try {\n      // Device should take at least 30 seconds to reboot.\n      sleep(Duration.standardSeconds(30));\n      // Now check periodically for the device to become responsive again.\n      retryResponsiveAfterReboot.call();\n    } finally {\n      restarting = false;\n    }\n  }\n\n  private final RetryCallable<Void, IosDeviceException> retryResponsiveAfterReboot =\n      RetryCallable.retry(\n              () -> {\n                if (!isResponsive()) {\n                  throw new IosDeviceException(\n                      RealDeviceImpl.this, \"Device unresponsive after reboot\");\n                }\n              })\n          .withMaxAttempts(12)\n          .withDelay(Duration.standardSeconds(5));\n\n  @Override\n  public String toString() {\n    return MoreObjects.toStringHelper(IosDevice.class).add(\"udid\", udid).toString();\n  }\n\n  private NSDictionary callIdeviceInfo() throws IosDeviceException {\n    String infoText = await(idevice.info(\"-x\"));\n    byte[] infoBytes = infoText.getBytes(StandardCharsets.UTF_8);\n    try {\n      return (NSDictionary) XMLPropertyListParser.parse(infoBytes);\n    } catch (ParserConfigurationException\n        | ParseException\n        | PropertyListFormatException\n        | IOException\n        | SAXException e) {\n      throw new IosDeviceException(RealDeviceImpl.this, e);\n    }\n  }\n\n  /**\n   * Waits for a process to terminate and returns the result of the execution. Optionally specify\n   * expected process exit codes, which if not specified, is assumed to be only zero. If the exit\n   * code is not one of the expected values, this method throws an IosDeviceException.\n   */\n  private String await(CommandProcess process, Integer... expectedExitCodes)\n      throws IosDeviceException {", "context": "java/com/google/iosdevicecontrol/util/FluentLogger.java\npublic final class FluentLogger {\n  /** Returns a generic fluent logger for a class. */\n  public static FluentLogger forEnclosingClass() {\n    StackTraceElement caller = new Throwable().getStackTrace()[1];\n    Logger logger = Logger.getLogger(caller.getClassName());\n    logger.setUseParentHandlers(false);\n    logger.addHandler(new ConsoleHandler());\n    return new FluentLogger(logger, Level.OFF, Optional.empty());\n  }\n\n  private final Logger logger;\n  private final Level level;\n  private final Optional<Throwable> cause;\n\n  private FluentLogger(Logger logger, Level level, Optional<Throwable> cause) {\n    this.level = level;\n    this.logger = logger;\n    this.cause = cause;\n  }\n\n  /** Returns a fluent logger with the specified cause. */\n  public FluentLogger withCause(Throwable cause) {\n    return new FluentLogger(logger, level, Optional.of(cause));\n  }\n\n  /** Convenience method for at({@link Level#INFO}). */\n  public FluentLogger atInfo() {\n    return at(Level.INFO);\n  }\n\n  /** Convenience method for at({@link Level#SEVERE}). */\n  public FluentLogger atSevere() {\n    return at(Level.SEVERE);\n  }\n\n  /** Convenience method for at({@link Level#WARNING}). */\n  public FluentLogger atWarning() {\n    return at(Level.WARNING);\n  }\n\n  /** Convenience method for at({@link Level#FINE}). */\n  public FluentLogger atFine() {\n    return at(Level.FINE);\n  }\n\n  /** Returns a fluent logger with the specified logging level. */\n  public FluentLogger at(Level level) {\n    return new FluentLogger(logger, level, cause);\n  }\n\n  /** Print a log of the {@link FluentLogger#cause}. */\n  public void log() {\n    log(\"\");\n  }\n\n  /** Print a formatted log message. */\n  public void log(String message, Object... params) {\n    StackTraceElement caller = new Throwable().getStackTrace()[1];\n    String formatMsg = String.format(message, params);\n    if (cause.isPresent()) {\n      logger.logp(level, logger.getName(), caller.getMethodName(), formatMsg, cause.get());\n    } else {\n      logger.logp(level, logger.getName(), caller.getMethodName(), formatMsg);\n    }\n  }\n}\njava/com/google/iosdevicecontrol/command/Command.java\n@AutoValue\npublic abstract class Command {\n  /**\n   * The default command environment: equal to {@link System#getenv()}.\n   */\n  public static final ImmutableMap<String, String> SYSTEM_ENVIRONMENT =\n      ImmutableMap.copyOf(System.getenv());\n\n  /**\n   * The default command executor: runs commands on the native OS.\n   */\n  public static final CommandExecutor NATIVE_EXECUTOR = NativeProcess.EXECUTOR;\n\n  private static final Predicate<CommandResult> HAS_EXIT_CODE_ZERO =\n      new Predicate<CommandResult>() {\n        @Override\n        public boolean apply(CommandResult result) {\n          return result.exitCode() == 0;\n        }\n      };\n\n  private static final FluentLogger logger = FluentLogger.forEnclosingClass();\n\n  /**\n   * Returns a command with the specified executable and arguments.\n   */\n  public static Command command(String executable, String... args) {\n    return new AutoValue_Command(\n        executable,\n        ImmutableList.copyOf(args),\n        SYSTEM_ENVIRONMENT,\n        Optional.<Path>absent(),\n        InputSource.fromProcess(),\n        OutputSink.toProcessOut(),\n        OutputSink.toProcessErr(),\n        HAS_EXIT_CODE_ZERO,\n        NATIVE_EXECUTOR);\n  }\n\n  /**\n   * Returns a command with the specified executable path and arguments.\n   */\n  public static Command command(Path executable, String... args) {\n    return command(sanitizePath(executable), args);\n  }\n\n  /**\n   * Need to prefix paths that are just a filename with a ./, otherwise it will be treated as a\n   * executable on the PATH, and fail.\n   */\n  private static String sanitizePath(Path executable) {\n    return executable.equals(executable.getFileName())\n        ? executable.getFileSystem().getPath(\".\").resolve(executable).toString()\n        : executable.toString();\n  }\n\n  //\n  // Accessor methods.\n  //\n\n  /**\n   * Returns the executable.\n   */\n  public abstract String executable();\n\n  /**\n   * Returns the list of arguments to the executable.\n   */\n  public abstract ImmutableList<String> arguments();\n\n  /**\n   * Returns the map of environment variables under which the executable will run.\n   */\n  public abstract ImmutableMap<String, String> environment();\n\n  /**\n   * Returns the working directory where to run the command, or absent for the working directory of\n   * the current Java process.\n   */\n  public abstract Optional<Path> workingDirectory();\n\n  /**\n   * Returns the source of input that will be piped to this command's standard input.\n   */\n  public abstract InputSource stdinSource();\n\n  /**\n   * Returns the sink to which output from the command's standard output will be piped.\n   */\n  public abstract OutputSink stdoutSink();\n\n  /**\n   * Returns the sink to which output from the command's standard error will be piped.\n   */\n  public abstract OutputSink stderrSink();\n\n  /**\n   * Returns the predicate on a command's result that determines whether a command's result is\n   * successful.\n   */\n  public abstract Predicate<CommandResult> successCondition();\n\n  /**\n   * Returns the executor to run the command.\n   */\n  public abstract CommandExecutor executor();\n\n  //\n  // Fluent methods.\n  //\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified executable\n   * in place of the current executable.\n   */\n  public final Command withExecutable(Path executable) {\n    return withExecutable(sanitizePath(executable));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified executable\n   * in place of the current executable.\n   */\n  public final Command withExecutable(String executable) {\n    return new AutoValue_Command(\n        executable,\n        arguments(),\n        environment(),\n        workingDirectory(),\n        stdinSource(),\n        stdoutSink(),\n        stderrSink(),\n        successCondition(),\n        executor());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified arguments\n   * in place of the current arguments.\n   */\n  public final Command withArguments(List<String> arguments) {\n    return new AutoValue_Command(\n        executable(),\n        ImmutableList.copyOf(arguments),\n        environment(),\n        workingDirectory(),\n        stdinSource(),\n        stdoutSink(),\n        stderrSink(),\n        successCondition(),\n        executor());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified arguments\n   * in place of the current arguments.\n   */\n  public final Command withArguments(String first, String... rest) {\n    return withArguments(listFromVarArgs(first, rest));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified arguments\n   * appended to the current arguments.\n   */\n  public final Command withArgumentsAppended(List<String> arguments) {\n    return withArguments(\n        ImmutableList.<String>builder().addAll(arguments()).addAll(arguments).build());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified arguments\n   * appended to the current arguments.\n   */\n  public final Command withArgumentsAppended(String first, String... rest) {\n    return withArgumentsAppended(listFromVarArgs(first, rest));\n  }\n\n  private static List<String> listFromVarArgs(String first, String... rest) {\n    return ImmutableList.<String>builder().add(first).add(rest).build();\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified environment\n   * in place of the current environment.\n   */\n  public final Command withEnvironment(Map<String, String> environment) {\n    return new AutoValue_Command(\n        executable(),\n        arguments(),\n        ImmutableMap.copyOf(environment),\n        workingDirectory(),\n        stdinSource(),\n        stdoutSink(),\n        stderrSink(),\n        successCondition(),\n        executor());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified key-value\n   * entries in place of the current environment.\n   *\n   * @throws IllegalArgumentException - if an odd number of key value arguments are given\n   */\n  public final Command withEnvironment(String firstKey, String firstValue, String... rest) {\n    return withEnvironment(mapFromVarArgs(firstKey, firstValue, rest));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the current environment\n   * updated by the specified environment.\n   */\n  public final Command withEnvironmentUpdated(Map<String, String> environment) {\n    // This isn't as simple as ImmutableMap.builder().putAll(environment()).putAll(environment),\n    // because the ImmutableMap builder prohibits duplicate keys.\n    ImmutableMap.Builder<String, String> builder =\n        ImmutableMap.<String, String>builder().putAll(environment);\n    for (Entry<String, String> e : environment().entrySet()) {\n      if (!environment.containsKey(e.getKey())) {\n        builder.put(e);\n      }\n    }\n    return withEnvironment(builder.build());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the current environment\n   * updated by the specified key-value entries.\n   *\n   * @throws IllegalArgumentException - if an odd number of key/value arguments are given\n   */\n  public final Command withEnvironmentUpdated(String firstKey, String firstValue, String... rest) {\n    return withEnvironmentUpdated(mapFromVarArgs(firstKey, firstValue, rest));\n  }\n\n  private static Map<String, String> mapFromVarArgs(\n      String firstKey, String firstValue, String... rest) {\n    checkArgument(rest.length % 2 == 0, \"odd number of key/value arguments\");\n    ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n    builder.put(firstKey, firstValue);\n    for (int i = 0; i < rest.length; i += 2) {\n      builder.put(rest[i], rest[i + 1]);\n    }\n    return builder.build();\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified working\n   * directory. An absent value signifies the working directory of the current Java process.\n   */\n  public final Command withWorkingDirectory(Optional<Path> directory) {\n    return new AutoValue_Command(\n        executable(),\n        arguments(),\n        environment(),\n        directory,\n        stdinSource(),\n        stdoutSink(),\n        stderrSink(),\n        successCondition(),\n        executor());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified working\n   * directory on the default FileSystem.\n   */\n  public final Command withWorkingDirectory(String directory) {\n    return withWorkingDirectory(Paths.get(directory));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified working\n   * directory.\n   */\n  public final Command withWorkingDirectory(Path directory) {\n    return withWorkingDirectory(Optional.of(directory));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stdin\n   * source.\n   */\n  public final Command withStdinFrom(Path file) {\n    return withStdinFrom(InputSource.fromFile(file));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stdin\n   * source.\n   */\n  public final Command withStdinFromUtf8(String string) {\n    return withStdinFrom(string, StandardCharsets.UTF_8);\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stdin\n   * source.\n   */\n  public final Command withStdinFrom(String string, Charset charset) {\n    return withStdinFrom(CharSource.wrap(string).asByteSource(charset));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stdin\n   * source.\n   */\n  public final Command withStdinFrom(ByteSource byteSource) {\n    return withStdinFrom(InputSource.fromStream(byteSource));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but whose stdin source is the\n   * same as the JVM's (effectively {@link System#in}).\n   */\n  public final Command withStdinFromJvm() {\n    return withStdinFrom(InputSource.fromJvm());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stdin\n   * source.\n   */\n  public final Command withStdinFrom(InputSource stdinSource) {\n    return new AutoValue_Command(\n        executable(),\n        arguments(),\n        environment(),\n        workingDirectory(),\n        stdinSource,\n        stdoutSink(),\n        stderrSink(),\n        successCondition(),\n        executor());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stdout\n   * sink.\n   */\n  public final Command withStdoutTo(Path file) {\n    return withStdoutTo(OutputSink.toFile(file));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stdout\n   * sink.\n   */\n  public final Command withStdoutTo(ByteSink byteSink) {\n    return withStdoutTo(OutputSink.toStream(byteSink));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but whose stdout sink is the same\n   * as the JVM's (effectively {@link System#out}).\n   */\n  public final Command withStdoutToJvm() {\n    return withStdoutTo(OutputSink.toJvmOut());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stdout\n   * sink.\n   */\n  public final Command withStdoutTo(OutputSink outputSink) {\n    return new AutoValue_Command(\n        executable(),\n        arguments(),\n        environment(),\n        workingDirectory(),\n        stdinSource(),\n        outputSink,\n        stderrSink(),\n        successCondition(),\n        executor());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stderr\n   * sink.\n   */\n  public final Command withStderrTo(Path file) {\n    return withStderrTo(OutputSink.toFile(file));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stderr\n   * sink.\n   */\n  public final Command withStderrTo(ByteSink byteSink) {\n    return withStderrTo(OutputSink.toStream(byteSink));\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stderr\n   * sink.\n   */\n  public final Command withStderrToJvm() {\n    return withStderrTo(OutputSink.toJvmErr());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified stderr\n   * sink.\n   */\n  public final Command withStderrTo(OutputSink outputSink) {\n    return new AutoValue_Command(\n        executable(),\n        arguments(),\n        environment(),\n        workingDirectory(),\n        stdinSource(),\n        stdoutSink(),\n        outputSink,\n        successCondition(),\n        executor());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with a success condition that\n   * tests whether the result has one of the specified exit codes.\n   */\n  public final Command withSuccessExitCodes(int first, int... rest) {\n    ImmutableSet.Builder<Integer> builder = ImmutableSet.<Integer>builder().add(first);\n    for (int exitCode : rest) {\n      builder.add(exitCode);\n    }\n    final ImmutableSet<Integer> exitCodeSet = builder.build();\n    return withSuccessCondition(\n        new Predicate<CommandResult>() {\n          @Override\n          public boolean apply(CommandResult result) {\n            return exitCodeSet.contains(result.exitCode());\n          }\n        });\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified success\n   * condition.\n   */\n  public final Command withSuccessCondition(Predicate<CommandResult> condition) {\n    return new AutoValue_Command(\n        executable(),\n        arguments(),\n        environment(),\n        workingDirectory(),\n        stdinSource(),\n        stdoutSink(),\n        stderrSink(),\n        condition,\n        executor());\n  }\n\n  /**\n   * Returns a command that behaves equivalently to this command, but with the specified executor\n   * in place of the current executor.\n   */\n  public final Command withExecutor(CommandExecutor executor) {\n    return new AutoValue_Command(\n        executable(),\n        arguments(),\n        environment(),\n        workingDirectory(),\n        stdinSource(),\n        stdoutSink(),\n        stderrSink(),\n        successCondition(),\n        executor);\n  }\n\n  //\n  // Execution methods.\n  //\n\n  /**\n   * Starts the command running asynchronously.\n   *\n   * @throws CommandStartException - if there was an error starting the command\n   */\n  public final CommandProcess start() throws CommandStartException {\n    logger.atFine().log(\"Started command: %s\", this);\n    return executor().start(this);\n  }\n\n  /**\n   * Starts the command and blocks until it has completed.\n   *\n   * <p>Blocks until the command completes. It returns the command result if the result satisfies\n   * the command's success condition (by default a zero exit code), and throws {@link\n   * CommandFailureException} otherwise. If this thread is interrupted, this method kills the\n   * process and throws {@link InterruptedException}.\n   *\n   * @throws CommandStartException - if there was an error starting the command\n   * @throws CommandFailureException - if the result fails the command's success condition\n   * @throws InterruptedException - if the execution is interrupted\n   */\n  @CanIgnoreReturnValue\n  public final CommandResult execute()\n      throws CommandStartException, CommandFailureException, InterruptedException {\n    CommandProcess process = start();\n    try {\n      return process.await();\n    } catch (InterruptedException e) {\n      logger.atFine().log(\"Thread interrupted; killing command: %s\", this);\n      process.kill();\n      throw e;\n    }\n  }\n}\njava/com/google/iosdevicecontrol/IosAppBundleId.java\npublic final class IosAppBundleId {\n  // Implementation note: I didn't use @AutoValue, because I didn't want to add an additional\n  // property method to this class beyond toString. See: https://github.com/google/auto/issues/357\n\n  private static final Pattern VALID_UTI_PATTERN = Pattern.compile(\"^[\\\\w-\\\\.]+$\");\n\n  /**\n   * Returns the bundle identifier read from a \".ipa\" application archive file. This is equivalent\n   * to {@code IosAppInfo.readFromIpa(ipaPath).bundleId()}.\n   */\n  public static IosAppBundleId readFromIpa(Path ipaPath) throws IOException {\n    return IosAppInfo.readFromPath(ipaPath).bundleId();\n  }\n\n  private final String string;\n\n  /**\n   * Constructs a bundle ID from the given string. This constructor checks that the specified string\n   * is a valid Apple Uniform Type Identifier (UTI), meaning it contains only alphanumeric\n   * (A-Z,a-z,0-9), hyphen (-), and period (.) characters.\n   *\n   * @throws IllegalArgumentException if the string is not a valid Apple UTI.\n   */\n  public IosAppBundleId(String string) {\n    checkArgument(VALID_UTI_PATTERN.matcher(string).matches());\n    this.string = string;\n  }\n\n  @Override\n  public String toString() {\n    return string;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hashCode(string);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    return o instanceof IosAppBundleId && string.equals(((IosAppBundleId) o).string);\n  }\n}\njava/com/google/iosdevicecontrol/command/CommandResult.java\npublic final class CommandResult {\n  private final int exitCode;\n  private final CapturingOutputStream stdout;\n  private final CapturingOutputStream stderr;\n\n  CommandResult(int exitCode, CapturingOutputStream stdout, CapturingOutputStream stderr) {\n    this.exitCode = exitCode;\n    this.stdout = stdout;\n    this.stderr = stderr;\n  }\n\n  /** Returns the exit code of the command execution. */\n  public int exitCode() {\n    return exitCode;\n  }\n\n  /** Returns the standard output of the command execution as a new array of bytes. */\n  public byte[] stdoutBytes() {\n    return stdout.toByteArray();\n  }\n\n  /** Returns the standard error of the command execution as a new array of bytes. */\n  public byte[] stderrBytes() {\n    return stderr.toByteArray();\n  }\n\n  /** Returns the standard output of the command execution as a string. */\n  public String stdoutString(Charset cs) {\n    return stdout.toString(cs);\n  }\n\n  /** Returns the standard error of the command execution as a string. */\n  public String stderrString(Charset cs) {\n    return stderr.toString(cs);\n  }\n\n  /** Returns the standard output of the command execution as a UTF-8 string. */\n  public String stdoutStringUtf8() {\n    return stdoutString(UTF_8);\n  }\n\n  /** Returns the standard error of the command execution as a UTF-8 string. */\n  public String stderrStringUtf8() {\n    return stderrString(UTF_8);\n  }\n\n  @Override\n  public String toString() {\n    return MoreObjects.toStringHelper(this)\n        .add(\"exit code\", exitCode)\n        .add(\"stdout\", stdoutStringUtf8())\n        .add(\"stderr\", stderrStringUtf8())\n        .toString();\n  }\n}\njava/com/google/iosdevicecontrol/util/RetryCallable.java\npublic final class RetryCallable<V, X extends Exception> implements CheckedCallable<V, X> {\n  /** Default number of maximum attempts: 3. */\n  public static final int DEFAULT_MAX_ATTEMPTS = 3;\n\n  /**\n   * Creates a callable that retries the specified task up to the default number of attempts, with\n   * no delay between attempts and a noop exception handler.\n   */\n  public static <V, X extends Exception> RetryCallable<V, X> retry(\n      CheckedCallable<? extends V, ? extends X> task) {\n    return new RetryCallable<>(\n        task, DEFAULT_MAX_ATTEMPTS, Duration.ZERO, false, ExceptionHandler.NOOP);\n  }\n\n  /**\n   * Creates a callable that retries the specified task up to the default number of attempts, with\n   * no delay between attempts and a noop exception handler.\n   */\n  public static <X extends Exception> RetryCallable<Void, X> retry(VoidCallable<? extends X> task) {\n    return retry(CheckedCallables.fromVoidCallable(task));\n  }\n\n  private final CheckedCallable<? extends V, ? extends X> task;\n  private final int maxAttempts;\n  private final Duration delay;\n  private final boolean delayedFirstAttempt;\n  private final ExceptionHandler<? super X> exceptionHandler;\n\n  private RetryCallable(\n      CheckedCallable<? extends V, ? extends X> task,\n      int maxAttempts,\n      Duration delay,\n      boolean delayedFirstAttempt,\n      ExceptionHandler<? super X> exceptionHandler) {\n    this.task = checkNotNull(task);\n    checkArgument(maxAttempts > 0);\n    this.maxAttempts = maxAttempts;\n    this.delay = checkNotNull(delay);\n    this.delayedFirstAttempt = delayedFirstAttempt;\n    this.exceptionHandler = checkNotNull(exceptionHandler);\n  }\n\n  /**\n   * Returns a callable equivalent to this one but with the specified number of maximum attempts.\n   */\n  public RetryCallable<V, X> withMaxAttempts(int maxAttempts) {\n    return new RetryCallable<>(task, maxAttempts, delay, delayedFirstAttempt, exceptionHandler);\n  }\n\n  /** Returns a callable equivalent to this one but with the specified delay between attempts. */\n  public RetryCallable<V, X> withDelay(Duration delay) {\n    return new RetryCallable<>(task, maxAttempts, delay, delayedFirstAttempt, exceptionHandler);\n  }\n\n  /** Returns a callable equivalent to this one but with the delay before the first attempt. */\n  public RetryCallable<V, X> withDelayedFirstAttempt() {\n    return new RetryCallable<>(task, maxAttempts, delay, delayedFirstAttempt, exceptionHandler);\n  }\n\n  /** Returns a callable equivalent to this one but with the specified exception handler. */\n  public RetryCallable<V, X> withExceptionHandler(ExceptionHandler<? super X> exceptionHandler) {\n    return new RetryCallable<>(task, maxAttempts, delay, delayedFirstAttempt, exceptionHandler);\n  }\n\n  /**\n   * Repeatedly attempts a task up to the specified (or default) number of maximum attempts,\n   * handling each checked exception thrown by the task with the specified (or default) exception\n   * handler, and then waiting the specified (or default) delay between attempts.\n   *\n   * <p>If the maximum number of attempts has been reached, the first exception is thrown with all\n   * remaining exceptions added as suppressed exceptions to the original. If the exception handler\n   * throws a checked exception, it is added as a suppressed exception to the original, and the\n   * original exception is thrown immediately with no further retries attempted. If this thread is\n   * interrupted, an {@link InterruptedException} is added as suppressed to the original, and the\n   * original exception is thrown immediately with no further retries attempted. If the task or the\n   * exception handler throws an unchecked exception, this unchecked exception is propagated\n   * immediately with no retry.\n   */\n  @Override\n  public V call() throws X {\n    if (delayedFirstAttempt) {\n      Uninterruptibles.sleepUninterruptibly(delay.getMillis(), MILLISECONDS);\n    }\n\n    X cause = null;\n    for (int i = 0; i < maxAttempts; i++) {\n      try {\n        return task.call();\n      } catch (RuntimeException e) {\n        // Propagate unchecked exceptions immediately.\n        throw e;\n      } catch (Exception e) {\n        // If it's a checked exception, it's necessarily of type X.\n        @SuppressWarnings(\"unchecked\")\n        X failure = (X) e;\n        if (cause == null) {\n          cause = failure;\n        } else {\n          cause.addSuppressed(failure);\n        }\n\n        // Handle the failure.\n        try {\n          exceptionHandler.handle(failure);\n        } catch (RuntimeException e2) {\n          // Propagate unchecked exceptions immediately.\n          throw e2;\n        } catch (Exception e2) {\n          // A checked exception is marked suppressed and the call ends immediately.\n          if (!e2.equals(failure)) {\n            cause.addSuppressed(e2);\n          }\n          break;\n        }\n\n        // Sleep for the specified delay.\n        try {\n          Thread.sleep(delay.getMillis());\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          cause.addSuppressed(ie);\n          break;\n        }\n      }\n    }\n\n    throw Verify.verifyNotNull(cause);\n  }\n}\njava/com/google/iosdevicecontrol/util/ForwardingSocket.java\n@SuppressWarnings(\"UnsynchronizedOverridesSynchronized\")\npublic class ForwardingSocket extends Socket {\n  private final Socket delegate;\n\n  public ForwardingSocket(Socket delegate) {\n    this.delegate = checkNotNull(delegate);\n  }\n\n  @Override\n  public void connect(SocketAddress endpoint) throws IOException {\n    delegate.connect(endpoint);\n  }\n\n  @Override\n  public void connect(SocketAddress endpoint, int timeout) throws IOException {\n    delegate.connect(endpoint, timeout);\n  }\n\n  @Override\n  public void bind(SocketAddress bindpoint) throws IOException {\n    delegate.bind(bindpoint);\n  }\n\n  @Override\n  public InetAddress getInetAddress() {\n    return delegate.getInetAddress();\n  }\n\n  @Override\n  public InetAddress getLocalAddress() {\n    return delegate.getLocalAddress();\n  }\n\n  @Override\n  public int getPort() {\n    return delegate.getPort();\n  }\n\n  @Override\n  public int getLocalPort() {\n    return delegate.getLocalPort();\n  }\n\n  @Override\n  public SocketAddress getRemoteSocketAddress() {\n    return delegate.getRemoteSocketAddress();\n  }\n\n  @Override\n  public SocketAddress getLocalSocketAddress() {\n    return delegate.getLocalSocketAddress();\n  }\n\n  @Override\n  public SocketChannel getChannel() {\n    return delegate.getChannel();\n  }\n\n  @Override\n  public InputStream getInputStream() throws IOException {\n    return delegate.getInputStream();\n  }\n\n  @Override\n  public OutputStream getOutputStream() throws IOException {\n    return delegate.getOutputStream();\n  }\n\n  @Override\n  public void setTcpNoDelay(boolean on) throws SocketException {\n    delegate.setTcpNoDelay(on);\n  }\n\n  @Override\n  public boolean getTcpNoDelay() throws SocketException {\n    return delegate.getTcpNoDelay();\n  }\n\n  @Override\n  public void setSoLinger(boolean on, int linger) throws SocketException {\n    delegate.setSoLinger(on, linger);\n  }\n\n  @Override\n  public int getSoLinger() throws SocketException {\n    return delegate.getSoLinger();\n  }\n\n  @Override\n  public void sendUrgentData(int data) throws IOException {\n    delegate.sendUrgentData(data);\n  }\n\n  @Override\n  public void setOOBInline(boolean on) throws SocketException {\n    delegate.setOOBInline(on);\n  }\n\n  @Override\n  public boolean getOOBInline() throws SocketException {\n    return delegate.getOOBInline();\n  }\n\n  @Override\n  public void setSoTimeout(int timeout) throws SocketException {\n    delegate.setSoTimeout(timeout);\n  }\n\n  @Override\n  public int getSoTimeout() throws SocketException {\n    return delegate.getSoTimeout();\n  }\n\n  @Override\n  public void setSendBufferSize(int size) throws SocketException {\n    delegate.setSendBufferSize(size);\n  }\n\n  @Override\n  public int getSendBufferSize() throws SocketException {\n    return delegate.getSendBufferSize();\n  }\n\n  @Override\n  public void setReceiveBufferSize(int size) throws SocketException {\n    delegate.setReceiveBufferSize(size);\n  }\n\n  @Override\n  public int getReceiveBufferSize() throws SocketException {\n    return delegate.getReceiveBufferSize();\n  }\n\n  @Override\n  public void setKeepAlive(boolean on) throws SocketException {\n    delegate.setKeepAlive(on);\n  }\n\n  @Override\n  public boolean getKeepAlive() throws SocketException {\n    return delegate.getKeepAlive();\n  }\n\n  @Override\n  public void setTrafficClass(int tc) throws SocketException {\n    delegate.setTrafficClass(tc);\n  }\n\n  @Override\n  public int getTrafficClass() throws SocketException {\n    return delegate.getTrafficClass();\n  }\n\n  @Override\n  public void setReuseAddress(boolean on) throws SocketException {\n    delegate.setReuseAddress(on);\n  }\n\n  @Override\n  public boolean getReuseAddress() throws SocketException {\n    return delegate.getReuseAddress();\n  }\n\n  @Override\n  public void close() throws IOException {\n    delegate.close();\n  }\n\n  @Override\n  public void shutdownInput() throws IOException {\n    delegate.shutdownInput();\n  }\n\n  @Override\n  public void shutdownOutput() throws IOException {\n    delegate.shutdownOutput();\n  }\n\n  @Override\n  public boolean isConnected() {\n    return delegate.isConnected();\n  }\n\n  @Override\n  public boolean isBound() {\n    return delegate.isBound();\n  }\n\n  @Override\n  public boolean isClosed() {\n    return delegate.isClosed();\n  }\n\n  @Override\n  public boolean isInputShutdown() {\n    return delegate.isInputShutdown();\n  }\n\n  @Override\n  public boolean isOutputShutdown() {\n    return delegate.isOutputShutdown();\n  }\n\n  @Override\n  public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {\n    delegate.setPerformancePreferences(connectionTime, latency, bandwidth);\n  }\n\n  @Override\n  public String toString() {\n    return delegate.toString();\n  }\n}\njava/com/google/iosdevicecontrol/util/CheckedCallable.java\npublic interface CheckedCallable<V, X extends Exception> {\n  @CanIgnoreReturnValue\n  V call() throws X;\n}\njava/com/google/iosdevicecontrol/IosAppInfo.java\n@AutoValue\npublic abstract class IosAppInfo {\n  /** Returns the application info read from either an app folder or ipa archive */\n  public static IosAppInfo readFromPath(Path ipaOrAppPath) throws IOException {\n    NSObject plistDict;\n    if (Files.isDirectory(ipaOrAppPath)) {\n      plistDict = PlistParser.fromPath(ipaOrAppPath.resolve(\"Info.plist\"));\n    } else {\n      try (FileSystem ipaFs = FileSystems.newFileSystem(ipaOrAppPath, null)) {\n        Path appPath =\n            MoreFiles.listFiles(ipaFs.getPath(\"Payload\"))\n                .stream()\n                // Can't use Files.isDirectory, because no entry is a \"directory\" in a zip.\n                .filter(e -> e.toString().endsWith(\".app/\"))\n                .collect(MoreCollectors.onlyElement());\n        plistDict = PlistParser.fromPath(appPath.resolve(\"Info.plist\"));\n      }\n    }\n    return readFromPlistDictionary((NSDictionary) plistDict);\n  }\n\n  /** Returns the application info read from a plist dictionary. */\n  public static IosAppInfo readFromPlistDictionary(NSDictionary dict) {\n    return builder()\n        .bundleId(new IosAppBundleId(dict.get(\"CFBundleIdentifier\").toString()))\n        .build();\n  }\n\n  /** Returns a new builder. */\n  public static Builder builder() {\n    return new AutoValue_IosAppInfo.Builder();\n  }\n\n  /** A builder for {@code IosAppInfo}. */\n  @AutoValue.Builder\n  public abstract static class Builder {\n    public abstract Builder bundleId(IosAppBundleId bundleId);\n\n    public abstract IosAppInfo build();\n  }\n\n  /** The bundle identifier of the application. */\n  public abstract IosAppBundleId bundleId();\n}\njava/com/google/iosdevicecontrol/command/CommandProcess.java\npublic abstract class CommandProcess {\n  private final Command command;\n  private final RawProcess rawProcess;\n  private final CapturingOutputStream stdoutStream;\n  private final CapturingOutputStream stderrStream;\n  private final Optional<AsyncCopier> stdinPump;\n  private final Optional<AsyncCopier> stdoutPump;\n  private final Optional<AsyncCopier> stderrPump;\n\n  private volatile CommandResult result = null;\n\n  protected CommandProcess(Command command, RawProcess rawProcess) throws CommandStartException {\n    this.command = checkNotNull(command);\n    this.rawProcess = checkNotNull(rawProcess);\n    stdoutStream = new CapturingOutputStream();\n    stderrStream = new CapturingOutputStream();\n\n    Supplier<Level> ioLogLevel = new Supplier<Level>() {\n      @Override\n      public Level get() {\n        return CommandProcess.this.rawProcess.isAlive() ? Level.WARNING : Level.FINE;\n      }\n    };\n\n    try {\n      stdinPump =\n          maybeStartCopyFromSourceToPipe(command.stdinSource(), rawProcess.stdinPipe(), ioLogLevel);\n      stdoutPump =\n          maybeStartCopyFromPipeToSink(\n              rawProcess.stdoutPipe(),\n              command.stdoutSink(),\n              stdoutStream,\n              stderrStream,\n              ioLogLevel);\n      stderrPump =\n          maybeStartCopyFromPipeToSink(\n              rawProcess.stderrPipe(),\n              command.stderrSink(),\n              stdoutStream,\n              stderrStream,\n              ioLogLevel);\n    } catch (IOException e) {\n      throw new CommandStartException(command, e);\n    }\n  }\n\n  private static Optional<AsyncCopier> maybeStartCopyFromSourceToPipe(\n      InputSource inputSource, Optional<OutputStream> pipe, Supplier<Level> ioLogLevel)\n      throws IOException {\n    if (pipe.isPresent() && !inputSource.kind().equals(InputSource.Kind.PROCESS)) {\n      InputStream sourceStream = inputSource.byteSource().get().openStream();\n      return Optional.of(AsyncCopier.start(sourceStream, pipe.get(), ioLogLevel));\n    } else {\n      return Optional.absent();\n    }\n  }\n\n  private static Optional<AsyncCopier> maybeStartCopyFromPipeToSink(\n      Optional<InputStream> pipe,\n      OutputSink outputSink,\n      OutputStream stdoutStream,\n      OutputStream stderrStream,\n      Supplier<Level> ioLogLevel)\n      throws IOException {\n    if (pipe.isPresent()) {\n      OutputStream sinkStream;\n      switch (outputSink.kind()) {\n        case PROCESS_OUT:\n          sinkStream = stdoutStream;\n          break;\n        case PROCESS_ERR:\n          sinkStream = stderrStream;\n          break;\n        default:\n          sinkStream = outputSink.byteSink().get().openStream();\n      }\n      return Optional.of(AsyncCopier.start(pipe.get(), sinkStream, ioLogLevel));\n    } else {\n      return Optional.absent();\n    }\n  }\n\n  /** The command that started this process. */\n  public final Command command() {\n    return command;\n  }\n\n  /** Returns whether the process has not yet terminated. */\n  public final boolean isAlive() {\n    return rawProcess.isAlive();\n  }\n\n  /**\n   * Blocks until the command completes. It returns the command result if the result satisfies the\n   * command's success condition (by default a zero exit code), and throws {@link\n   * CommandFailureException} otherwise.\n   *\n   * <p>If this thread is interrupted, an {@link InterruptedException} is thrown, but the <i>process\n   * will continue running</i>. If you wish the process to be killed in this case, catch this\n   * exception and call {@link CommandProcess#kill} on the running process.\n   *\n   * @throws CommandFailureException - if the result fails the command's success condition\n   * @throws InterruptedException - if the execution is interrupted\n   */\n  @CanIgnoreReturnValue\n  public final CommandResult await() throws CommandFailureException, InterruptedException {\n    rawProcess.await(); // returns immediately if process already complete\n    return processFinished();\n  }\n\n  /**\n   * Blocks until the command completes or the timeout is reached. If the timeout is reached before\n   * the command finishes, {@link TimeoutException} is thrown. It returns the command result if\n   * the result satisfies the command's success condition (by default a zero exit code), and throws\n   * {@link CommandFailureException} otherwise.\n   *\n   * <p>If this thread is interrupted, an {@link InterruptedException} is thrown, but the <i>process\n   * will continue running</i>. If you wish the process to be killed in this case, catch this\n   * exception and call {@link CommandProcess#kill} on the running process.\n   *\n   * @throws CommandFailureException - if the result fails the command's success condition\n   * @throws InterruptedException - if the execution is interrupted\n   */\n  @CanIgnoreReturnValue\n  public final CommandResult await(long timeout, TimeUnit unit)\n      throws CommandFailureException, InterruptedException, TimeoutException {\n    if (rawProcess.await(timeout, unit)) {\n      return processFinished();\n    }\n    throw new TimeoutException(\n        String.format(\"%s did not complete after %d %s.\", command, timeout, unit));\n  }\n\n  /**\n   * A helper method for cleaning up once the process has finished. This method should only be\n   * called once the caller knows the process has terminated (e.g. by calling {link #await}).\n   *\n   * @throws CommandFailureException if the command fails.\n   * @throws InterruptedException if the raw process is interrupted.\n   */\n  private CommandResult processFinished()\n      throws CommandFailureException, InterruptedException {\n    // Double-checked locking to compute the result at most once.\n    if (result == null) {\n      synchronized (this) {\n        if (result == null) {\n          verify(!rawProcess.isAlive());\n          int exitCode = rawProcess.await();\n          // The process has ended, so there is no need to wait indefinitely for the stdin pump,\n          // which may in theory be blocked or simply unbounded; just force stop it now.\n          if (stdinPump.isPresent()) {\n            stdinPump.get().stop();\n          }\n          // However, wait indefinitely for the stdout and stderr pumps before returning. The\n          // default case of writing to a CapturingOutputStream will never block forever; if the\n          // user provides a custom output stream, the burden is on them that it doesn't either.\n          if (stdoutPump.isPresent()) {\n            stdoutPump.get().await();\n          }\n          if (stderrPump.isPresent()) {\n            stderrPump.get().await();\n          }\n          result = new CommandResult(exitCode, stdoutStream, stderrStream);\n        }\n      }\n    }\n\n    if (command.successCondition().apply(result)) {\n      return result;\n    } else {\n      throw new CommandFailureException(command, result);\n    }\n  }\n\n  /**\n   * Sends a signal to terminate the process and returns immediately. Killing a process that has\n   * already exited has no effect. To wait for the process to be killed, use {@code kill().await()}.\n   *\n   * <p>This method makes a best-effort attempt to read in any data already written to stdout or\n   * stderr before the process is terminated. Reading output from a process as you kill it is\n   * inherently racy, so if there's any output you expect to see it should be read explicitly via\n   * {@link #stdoutStream}/{@link #stderrStream} before calling this method.\n   *\n   * <p><b>Implementation detail:</b> manual benchmarking suggests {@link Process} will buffer up to\n   * 60KB internally, which this method should be able to retrieve.\n   */\n  @CanIgnoreReturnValue\n  public final CommandProcess kill() {\n    rawProcess.kill();\n    return this;\n  }\n\n  /** Returns a new {@link InputStream} connected to the standard output of the process. */\n  public final InputStream stdoutStream() {\n    return stdoutStream.openInputStream();\n  }\n\n  /** Returns a new {@link InputStream} connected to the standard error of the process. */\n  public final InputStream stderrStream() {\n    return stderrStream.openInputStream();\n  }\n\n  /** Returns a new {@link Reader} connected to the standard output of the process. */\n  public final Reader stdoutReader(Charset cs) {\n    return new InputStreamReader(stdoutStream(), cs);\n  }\n\n  /** Returns a new {@link Reader} connected to the standard error of the process. */\n  public final Reader stderrReader(Charset cs) {\n    return new InputStreamReader(stderrStream(), cs);\n  }\n\n  /**\n   * Returns a new {@link Reader} connected to the standard output of the process, assuming the\n   * output uses UTF-8 encoding.\n   */\n  public final Reader stdoutReaderUtf8() {\n    return stdoutReader(UTF_8);\n  }\n\n  /**\n   * Returns a new {@link Reader} connected to the standard error of the process, assuming the\n   * output uses UTF-8 encoding.\n   */\n  public final Reader stderrReaderUtf8() {\n    return stderrReader(UTF_8);\n  }\n\n  @Override\n  public final int hashCode() {\n    // All implementations must use reference equality.\n    return super.hashCode();\n  }\n\n  @Override\n  public final boolean equals(Object o) {\n    // All implementations must use reference equality.\n    return super.equals(o);\n  }\n\n  @Override\n  public final String toString() {\n    return MoreObjects.toStringHelper(this)\n        .add(\"command\", command)\n        .add(\"alive\", isAlive())\n        .toString();\n  }\n\n  /**\n   * A low-level process API used to implement {@link CommandProcess}. This is a bare-bones\n   * \"strategy\" object that executors use to create instances of the more user-friendly\n   * CommandProcess type. The alternative to the strategy object design is a complicated combination\n   * of constructor args and abstract hook methods on CommandProcess. Also, unlike hook methods, a\n   * strategy object allows us to safely invoke these methods in the CommandProcess constructor, a\n   * feature which CommandProcess uses to start a StdinPump, for example.\n   */\n  protected interface RawProcess {\n    /**\n     * Returns an output stream that writes to the standard input of the process; absent when the\n     * process has redirected its stdin and, therefore, isn't reading input over a pipe.\n     */\n    Optional<OutputStream> stdinPipe();\n\n    /**\n     * Returns an input stream that reads from the standard output of the process; absent when the\n     * process has redirected its stdout and, therefore, isn't writing output over a pipe.\n     */\n    Optional<InputStream> stdoutPipe();\n\n    /**\n     * Returns an input stream that reads from the standard error of the process; absent when the\n     * process has redirected its stderr and, therefore, isn't writing error over a pipe.\n     */\n    Optional<InputStream> stderrPipe();\n\n    /** Returns whether the process has not yet terminated. */\n    boolean isAlive();\n\n    /**\n     * Waits for the process to terminate and returns its exit code.\n     *\n     * @throws InterruptedException - if the execution is interrupted\n     */\n    @CanIgnoreReturnValue\n    int await() throws InterruptedException;\n\n    /**\n     * Waits up to timeout for the process to terminate, returning true if it did so.\n     *\n     * @throws InterruptedException - if the execution is interrupted\n     */\n    boolean await(long timeout, TimeUnit unit) throws InterruptedException;\n\n    /** Sends a signal to terminate the process and returns immediately. */\n    void kill();\n  }\n}\njava/com/google/iosdevicecontrol/IosDeviceSocket.java\npublic abstract class IosDeviceSocket extends IosDeviceResource {\n  /** Wraps an iOS device and a Java socket as an IosDeviceSocket. */\n  public static IosDeviceSocket wrap(IosDevice device, Socket socket) throws IosDeviceException {\n    return new SocketWrapper(device, socket);\n  }\n\n  protected IosDeviceSocket(IosDevice device) {\n    super(device);\n  }\n\n  /**\n   * Read bytes from the socket until the array is full or EOF is reached, returning the number of\n   * bytes read. The returned value is less than the length of the array only when EOF is reached.\n   */\n  public abstract int read(byte[] bytes) throws IosDeviceException;\n\n  /** Writes bytes to the socket. */\n  public abstract void write(byte[] bytes) throws IosDeviceException;\n\n  /** Wraps a device and a Java socket as an IosDeviceSocket. */\n  private static class SocketWrapper extends IosDeviceSocket {\n    private final InputStream socketIn;\n    private final OutputStream socketOut;\n    private final Closeable socketClose;\n\n    private SocketWrapper(IosDevice device, Socket socket) throws IosDeviceException {\n      super(device);\n      try {\n        socketIn = socket.getInputStream();\n        socketOut = socket.getOutputStream();\n      } catch (IOException | RuntimeException e) {\n        try {\n          socket.close();\n        } catch (IOException ce) {\n          e.addSuppressed(ce);\n        }\n        throw new IosDeviceException(device, e);\n      }\n      socketClose = socket::close;\n    }\n\n    @Override\n    public int read(byte[] bytes) throws IosDeviceException {\n      try {\n        return ByteStreams.read(socketIn, bytes, 0, bytes.length);\n      } catch (IOException e) {\n        throw new IosDeviceException(device(), e);\n      }\n    }\n\n    @Override\n    public void write(byte[] bytes) throws IosDeviceException {\n      try {\n        socketOut.write(bytes);\n      } catch (IOException e) {\n        throw new IosDeviceException(device(), e);\n      }\n    }\n\n    @Override\n    public void close() throws IosDeviceException {\n      try {\n        socketClose.close();\n      } catch (IOException e) {\n        throw new IosDeviceException(device(), e);\n      }\n    }\n  }\n}\njava/com/google/iosdevicecontrol/IosAppProcess.java\npublic interface IosAppProcess {\n  /**\n   * Kills the process and returns immediately. To kill and then wait for the process to terminate,\n   * use kill().await().\n   */\n  IosAppProcess kill();\n\n  /** Waits for the app to terminate and returns its output. */\n  String await() throws IosDeviceException, InterruptedException;\n\n  /** Waits for the app to terminate up to the specified timeout and returns its output. */\n  String await(Duration timeout) throws IosDeviceException, InterruptedException, TimeoutException;\n\n  /** Returns a new reader to the UTF-8 encoded streamed output. */\n  Reader outputReader();\n}\njava/com/google/iosdevicecontrol/util/CheckedCallables.java\npublic final class CheckedCallables {\n  /**\n   * Returns a a {@link CheckedCallable} that always returns <code>instance</code>.\n   */\n  public static <V, X extends Exception> CheckedCallable<V, X> returning(V instance) {\n    return new CheckedCallableReturning<>(instance);\n  }\n\n  private static class CheckedCallableReturning<V, X extends Exception>\n      implements CheckedCallable<V, X>, Serializable {\n    private final V instance;\n\n    private CheckedCallableReturning(V instance) {\n      this.instance = instance;\n    }\n\n    @Override\n    public V call() {\n      return instance;\n    }\n\n    @Override\n    public boolean equals(@Nullable Object obj) {\n      if (obj instanceof CheckedCallableReturning) {\n        CheckedCallableReturning<?, ?> that = (CheckedCallableReturning<?, ?>) obj;\n        return Objects.equals(instance, that.instance);\n      }\n      return false;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hashCode(instance);\n    }\n\n    @Override\n    public String toString() {\n      return \"CheckedCallables.returning(\" + instance + \")\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * Wraps a {@link Callable} as a {@link CheckedCallable}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static <V> CheckedCallable<V, Exception> fromCallable(Callable<? extends V> c) {\n    return c instanceof CheckedCallable\n        ? (CheckedCallable<V, Exception>) c\n        : new CheckedCallableFromCallable<V>(c);\n  }\n\n  private static class CheckedCallableFromCallable<V>\n      implements CheckedCallable<V, Exception>, Serializable {\n    private final Callable<? extends V> delegate;\n\n    private CheckedCallableFromCallable(Callable<? extends V> delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public V call() throws Exception {\n      return delegate.call();\n    }\n\n    @Override\n    public boolean equals(@Nullable Object obj) {\n      if (obj instanceof CheckedCallableFromCallable) {\n        CheckedCallableFromCallable<?> that = (CheckedCallableFromCallable<?>) obj;\n        return delegate.equals(that.delegate);\n      }\n      return false;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hashCode(delegate);\n    }\n\n    @Override\n    public String toString() {\n      return \"CheckedCallables.fromCallable(\" + delegate + \")\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * Wraps a {@link VoidCallable} as a {@link CheckedCallable}.\n   */\n  public static <X extends Exception> CheckedCallable<Void, X> fromVoidCallable(\n      VoidCallable<? extends X> c) {\n    return new CheckedCallableFromVoidCallable<X>(c);\n  }\n\n  private static class CheckedCallableFromVoidCallable<X extends Exception>\n      implements CheckedCallable<Void, X>, Serializable {\n    private final VoidCallable<? extends X> delegate;\n\n    private CheckedCallableFromVoidCallable(VoidCallable<? extends X> delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    public Void call() throws X {\n      delegate.call();\n      return null;\n    }\n\n    @Override\n    public boolean equals(@Nullable Object obj) {\n      if (obj instanceof CheckedCallableFromVoidCallable) {\n        CheckedCallableFromVoidCallable<?> that = (CheckedCallableFromVoidCallable<?>) obj;\n        return delegate.equals(that.delegate);\n      }\n      return false;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hashCode(delegate);\n    }\n\n    @Override\n    public String toString() {\n      return \"CheckedCallables.fromVoidCallable(\" + delegate + \")\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * Returns a {@link CheckedCallable} which caches the instance retrieved or exception thrown\n   * during the first call and returns that value or throws that exception on subsequent calls.\n   */\n  public static <V, X extends Exception> CheckedCallable<V, X> memoize(CheckedCallable<V, X> c) {\n    return c instanceof MemoizingCheckedCallable ? c : new MemoizingCheckedCallable<V, X>(c);\n  }\n\n  private static class MemoizingCheckedCallable<V, X extends Exception>\n      implements CheckedCallable<V, X>, Serializable {\n    private final CheckedCallable<V, X> delegate;\n\n    private transient volatile boolean initialized;\n    // The \"value\" and \"exception\" fields do not need to be volatile; their visibility piggy-backs\n    // on volatile read of \"initialized\".\n    private transient V value;\n    private transient Exception exception;\n\n    private MemoizingCheckedCallable(CheckedCallable<V, X> delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public V call() throws X {\n      // Double Checked Locking.\n      if (!initialized) {\n        synchronized (this) {\n          if (!initialized) {\n            try {\n              value = delegate.call();\n            } catch (Exception e) {\n              exception = e;\n            }\n            initialized = true;\n          }\n        }\n      }\n\n      if (exception == null) {\n        return value;\n      } else {\n        // The exception either be of generic type X or a RuntimeException, but a generic cast will\n        // succeed in either case due to type erasure.\n        throw (X) exception;\n      }\n    }\n\n    @Override\n    public String toString() {\n      return \"CheckedCallables.memoize(\" + delegate + \")\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  private CheckedCallables() {}\n}\njava/com/google/iosdevicecontrol/IosDeviceException.java\npublic class IosDeviceException extends Exception {\n  /** Remedies to some kinds of iOS device errors. */\n  public enum Remedy {\n    DISMISS_DIALOG,\n    REINSTALL_APP,\n    RESTART_DEVICE,\n  }\n\n  private final IosDevice device;\n  private final Optional<Remedy> remedy;\n\n  public IosDeviceException(IosDevice device, String message) {\n    this(device, device + \": \" + message, null, Optional.<Remedy>absent());\n  }\n\n  public IosDeviceException(IosDevice device, Throwable cause) {\n    this(device, device.toString(), checkNotNull(cause), Optional.<Remedy>absent());\n  }\n\n  public IosDeviceException(IosDevice device, Throwable cause, Remedy remedy) {\n    this(device, device.toString(), checkNotNull(cause), Optional.of(remedy));\n  }\n\n  private IosDeviceException(\n      IosDevice device, String message, @Nullable Throwable cause, Optional<Remedy> remedy) {\n    super(message, cause);\n    this.device = checkNotNull(device);\n    this.remedy = remedy;\n  }\n\n  /** Returns the device on which the error occurred. */\n  public final IosDevice device() {\n    return device;\n  }\n\n  /** Suggested remedy that <i>may</i> resolve the cause of the error. */\n  public final Optional<Remedy> remedy() {\n    return remedy;\n  }\n}\njava/com/google/iosdevicecontrol/real/DevDiskImages.java\n@AutoValue\nabstract static class DiskImage {\n  abstract Path imagePath();\n  abstract Path signaturePath();\n}\njava/com/google/iosdevicecontrol/IosVersion.java\n@AutoValue\npublic abstract class IosVersion {\n  public static Builder builder() {\n    return new AutoValue_IosVersion.Builder();\n  }\n\n  /** The build version, e.g. \"12H321\". */\n  public abstract String buildVersion();\n\n  /** The product version, e.g. \"8.4.1\". */\n  public abstract String productVersion();\n\n  /** The major version number, e.g. 8. */\n  public final int majorVersion() {\n    return Integer.parseInt(productVersion().substring(0, productVersion().indexOf('.')));\n  }\n\n  public abstract Builder toBuilder();\n\n  /**\n   * IosVersion builder.\n   */\n  @AutoValue.Builder\n  public abstract static class Builder {\n    public abstract Builder buildVersion(String buildVersion);\n\n    public abstract Builder productVersion(String productVersion);\n\n    public abstract IosVersion build();\n  }\n}\njava/com/google/iosdevicecontrol/IosDeviceResource.java\npublic abstract class IosDeviceResource implements AutoCloseable {\n  private final IosDevice device;\n\n  protected IosDeviceResource(IosDevice device) {\n    this.device = checkNotNull(device);\n  }\n\n  /** Returns the device to which the resource belongs. */\n  public final IosDevice device() {\n    return device;\n  }\n\n  @Override\n  public abstract void close() throws IosDeviceException;\n}\njava/com/google/iosdevicecontrol/IosDevice.java\npublic interface IosDevice {\n  /** Returns the udid of the device. */\n  String udid();\n\n  /** Returns whether the device is responsive to communication from the host. */\n  boolean isResponsive();\n\n  /**\n   * Returns the model of the device.\n   *\n   * @throws IosDeviceException - if there is an error communicating with the device\n   */\n  IosModel model() throws IosDeviceException;\n\n  /**\n   * Returns the version of the device.\n   *\n   * @throws IosDeviceException - if there is an error communicating with the device\n   */\n  IosVersion version() throws IosDeviceException;\n\n  /**\n   * Lists the application information of all installed applications on the device.\n   *\n   * @throws IosDeviceException - if there is an error communicating with the device\n   */\n  ImmutableSet<IosAppInfo> listApplications() throws IosDeviceException;\n\n  /**\n   * Returns whether an application with the specified bundle ID is installed.\n   *\n   * @throws IosDeviceException - if there is an error communicating with the device\n   */\n  boolean isApplicationInstalled(IosAppBundleId bundleId) throws IosDeviceException;\n\n  /**\n   * Installs the specified application from a .app folder or .ipa archive on the device. If an\n   * application with the same bundle ID is already installed, it will be overwritten.\n   *\n   * @throws IosDeviceException - if there is an error communicating with the device\n   */\n  void installApplication(Path ipaOrAppPath) throws IosDeviceException;\n\n  /**\n   * Uninstall the application with the specified bundle ID on the device. If an application with\n   * this bundle ID is not installed, this is a noop.\n   *\n   * @throws IosDeviceException - if there is an error communicating with the device\n   */\n  void uninstallApplication(IosAppBundleId bundleId) throws IosDeviceException;\n\n  /**\n   * Runs the specified iOS application with the specified args and returns immediately with a\n   * {@link IosAppProcess}, which is a future to the text output of the running application.\n   *\n   * @throws IosDeviceException - if there is an error communicating with the device\n   */\n  IosAppProcess runApplication(IosAppBundleId bundleId, String... args) throws IosDeviceException;\n\n  /**\n   * Starts capturing the system log for the device and writes it to the provided path. Returns an\n   * {@link IosDeviceResource}, which can be used in a try-with-resources block.\n   *\n   * @throws IosDeviceException - if there was an error communicating with the device\n   * @throws IllegalStateException - if system log capturing is already started\n   */\n  IosDeviceResource startSystemLogger(Path logPath) throws IosDeviceException;\n\n  /**\n   * Copies the crash logs to the specified directory and removes them from the device.\n   *\n   * @throws IosDeviceException - if there was an error communicating with the device\n   */\n  void pullCrashLogs(Path directory) throws IosDeviceException;\n\n  /**\n   * Clears the crash logs on the device.\n   *\n   * @throws IosDeviceException - if there was an error communicating with the device\n   */\n  void clearCrashLogs() throws IosDeviceException;\n\n  /**\n   * Opens a socket to communicate with the web inspector.\n   *\n   * @throws IosDeviceException - if there was an error communicating with the device\n   */\n  IosDeviceSocket openWebInspectorSocket() throws IosDeviceException;\n\n  /**\n   * Restarts the device and waits for it to be responsive.\n   *\n   * @throws IosDeviceException - if there is an error communicating with the device\n   */\n  void restart() throws IosDeviceException;\n\n  /**\n   * Takes a screenshot in PNG format and returns the bytes.\n   *\n   * @throws IosDeviceException - if there is an error communicating with the device\n   */\n  byte[] takeScreenshot() throws IosDeviceException;\n}\njava/com/google/iosdevicecontrol/command/CommandFailureException.java\npublic final class CommandFailureException extends CommandException {\n  private final CommandResult result;\n\n  CommandFailureException(Command command, CommandResult result) {\n    super(command, checkNotNull(result, command).toString());\n    Verify.verify(!command().successCondition().apply(result), result.toString());\n    this.result = result;\n  }\n\n  public CommandResult result() {\n    return result;\n  }\n}\njava/com/google/iosdevicecontrol/util/PlistParser.java\npublic class PlistParser {\n  /**\n   * Parses the content of a plist file as UTF-8 encoded XML.\n   *\n   * @throws PlistParseException - if there is an error parsing the content.\n   */\n  public static NSObject fromPath(Path plist) {\n    try {\n      return PropertyListParser.parse(Files.readAllBytes(plist));\n    } catch (ParserConfigurationException\n        | ParseException\n        | PropertyListFormatException\n        | IOException\n        | SAXException e) {\n      throw new PlistParseException(e);\n    }\n  }\n\n  /**\n   * Parses an XML string to a plist object.\n   *\n   * @throws PlistParseException - if there is an error parsing the string.\n   */\n  public static NSObject fromXml(String xml) {\n    try {\n      return XMLPropertyListParser.parse(xml.getBytes(UTF_8));\n    } catch (ParserConfigurationException\n        | ParseException\n        | PropertyListFormatException\n        | IOException\n        | SAXException e) {\n      throw new PlistParseException(e);\n    }\n  }\n\n  /**\n   * Parses a byte array to a plist object.\n   *\n   * @throws PlistParseException - if there is an error parsing the bytes.\n   */\n  public static NSObject fromBinary(byte[] bytes) {\n    try {\n      return BinaryPropertyListParser.parse(bytes);\n    } catch (UnsupportedEncodingException | PropertyListFormatException e) {\n      throw new PlistParseException(e);\n    }\n  }\n\n  /** Thrown if a parsing error occurs. */\n  public static class PlistParseException extends RuntimeException {\n    private PlistParseException(Exception cause) {\n      super(cause);\n    }\n  }\n\n  private PlistParser() {}\n}\njava/com/google/iosdevicecontrol/IosModel.java\n@AutoValue\npublic abstract class IosModel {\n  private static final Splitter PRODUCT_CLASS_SPLITTER = Splitter.on(' ').limit(2);\n\n  /** The class of device. */\n  public enum DeviceClass {\n    IPAD,\n    IPHONE,\n    IPOD;\n\n    private static final StringEnumMap<DeviceClass> STRING_TO_DEVICE_CLASS =\n        new StringEnumMap<>(DeviceClass.class);\n\n    /**\n     * Returns the device class for the specified string, e.g. returns <code>IPHONE</code> for the\n     * string \"iPhone\".\n     */\n    public static DeviceClass forString(String s) {\n      return STRING_TO_DEVICE_CLASS.get(s);\n    }\n\n    private final String string;\n\n    private DeviceClass() {\n      // e.g. \"IPHONE\" becomes \"iPhone\";\n      string = \"iP\" + name().substring(2).toLowerCase();\n    }\n\n    @Override\n    public String toString() {\n      return string;\n    }\n  }\n\n  /** CPU architecture of an iOS device. */\n  public enum Architecture {\n    ARM64,\n    ARMV7,\n    ARMV7F,\n    ARMV7K,\n    ARMV7S,\n    I386,\n    X86_64;\n\n    private static final StringEnumMap<Architecture> STRING_TO_ARCHITECTURE =\n        new StringEnumMap<>(Architecture.class);\n\n    /**\n     * Returns the architecture for the specified string, e.g. returns <code>ARMV7</code> for the\n     * string \"armv7\".\n     */\n    public static Architecture forString(String s) {\n      return STRING_TO_ARCHITECTURE.get(s);\n    }\n\n    private final String string;\n\n    private Architecture() {\n      string = name().toLowerCase();\n    }\n\n    @Override\n    public String toString() {\n      return string;\n    }\n  }\n\n  public static Builder builder() {\n    return new AutoValue_IosModel.Builder();\n  }\n\n  private final Supplier<DeviceClass> deviceClass =\n      Suppliers.memoize(\n          () ->\n              DeviceClass.forString(PRODUCT_CLASS_SPLITTER.split(productName()).iterator().next()));\n\n  /** Model identifier, e.g. \"iPhone5,1\". */\n  public abstract String identifier();\n\n  /** Product string of this model, e.g. \"iPhone 5\". */\n  public abstract String productName();\n\n  /** Architecture of the device, e.g. \"arm64\". */\n  public abstract Architecture architecture();\n\n  /** Device class of this model, e.g. \"iPad\". */\n  public final DeviceClass deviceClass() {\n    return deviceClass.get();\n  }\n\n  /** IosModel builder. */\n  @AutoValue.Builder\n  public abstract static class Builder {\n    public abstract Builder identifier(String identifier);\n\n    public abstract Builder productName(String productName);\n\n    public abstract Builder architecture(Architecture architecture);\n\n    /** Equivalent to <code>architecture(Architecture.fromString(archString))</code>. */\n    public final Builder architecture(String archString) {\n      return architecture(Architecture.forString(archString));\n    }\n\n    public abstract IosModel build();\n  }\n}\n", "answers": ["    CommandResult result = awaitResult(process);"], "length": 7530, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "264e0d85db3f543e14718f9a2e0f0185e816178daee60e35"}
{"input": "import android.content.Context;\nimport android.content.SharedPreferences;\nimport android.graphics.Color;\nimport android.graphics.Typeface;\nimport android.preference.PreferenceManager;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.TextView;\nimport java.lang.ref.SoftReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Set;\nimport ru.henridellal.emerald.activity.Apps;\nimport ru.henridellal.emerald.data.BaseData;\nimport ru.henridellal.emerald.data.CategoryManager;\nimport ru.henridellal.emerald.util.IconPackManager;\nimport ru.henridellal.emerald.preference.Keys;\nimport ru.henridellal.emerald.LauncherApp;\nimport ru.henridellal.emerald.listener.OnAppClickListener;\nimport ru.henridellal.emerald.listener.OnAppLongClickListener;\nimport ru.henridellal.emerald.listener.OnAppUnlockLongClickListener;\nimport ru.henridellal.emerald.R;\nimport ru.henridellal.emerald.ui.Themer;\n\t\t\t\tsections = new String[0];\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tString ch;\n\t\t\t\tint sectionIndex = 0;\n\t\t\t\tfor (int i = 0; i < toDisplay.size(); i++) {\n\t\t\t\t\tBaseData a = toDisplay.get(i);\n\t\t\t\t\tch = (a.getName().length() > 1) ? a.getName().substring(0,1).toUpperCase() : a.getName();\n\t\t\t\t\tif (!indexData.containsKey(ch)) {\n\t\t\t\t\t\tindexData.put(ch, sectionIndex);\n\t\t\t\t\t\tsectionIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSet<String> sectionsSet = indexData.keySet();\n\t\t\t\tArrayList<String> sectionsList = new ArrayList<String>(sectionsSet);\n\t\t\t\tCollections.sort(sectionsList);\n\t\t\t\tsections = new String[sectionsList.size()];\n\t\t\t\tsectionsList.toArray(sections);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic boolean isEnabled(int position) {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic View getView(int position, View convertView, ViewGroup parent) {\n\t\tView view;\n\t\tImageView img;\n\t\tTextView tv;\n\t\tBaseData a = toDisplay.get(position);\n\t\tboolean isEmptyView = (convertView == null);\n\t\tif (isEmptyView) {\n\t\t\tLayoutInflater inflater = (LayoutInflater)contextRef.get().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t\t\tview = inflater.inflate(inflatedLayoutId, parent, false);\n\t\t\timg = (ImageView) view.findViewById(R.id.icon);\n\t\t\ttv = (TextView) view.findViewById(R.id.text);\n\t\t\tswitch (appShortcut) {\n\t\t\t\tcase TEXT:\n\t\t\t\t\timg.setVisibility(View.GONE);\n\t\t\t\t\tsetTextViewParams(tv);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ICON:\n\t\t\t\t\tsetImageViewLayoutParams(img);\n\t\t\t\t\ttv.setVisibility(View.GONE);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsetImageViewLayoutParams(img);\n\t\t\t\t\tsetTextViewParams(tv);\n\t\t\t}\n\t\t\tview.setOnClickListener(onClickListener);\n\t\t\tview.setOnLongClickListener(onLongClickListener);\n\t\t} else {\n\t\t\tview = convertView;\n\t\t\timg = (ImageView) view.findViewById(R.id.icon);\n\t\t\ttv = (TextView) view.findViewById(R.id.text);\t\n\t\t}\n\t\t// app shortcut\n\t\tview.setTag(a);\n\t\tif (appShortcut != ICON) {\n\t\t\ttv.setText(a.getName());\n\t\t\ttv.setTextSize(textSize);\n\t\t}\n\t\tif (appShortcut >= ICON) {\n\t\t\tIconPackManager.setIcon(contextRef.get(), img, a);\n\t\t}\n\t\treturn view;\n\t}\n\n\tpublic void setTextViewParams(TextView tv) {\n\t\ttv.setTextColor(textColor);\n\t\ttv.setTypeface(Typeface.DEFAULT, fontStyle);\n\t}\n\n\tpublic void setImageViewLayoutParams(ImageView img) {\n\t\tif (null == imageViewLayoutParams) {\n\t\t\timageViewLayoutParams = img.getLayoutParams();\n\t\t\timageViewLayoutParams.width = iconSize;\n\t\t\timageViewLayoutParams.height = iconSize;\n\t\t}\n\t\timg.setLayoutParams(imageViewLayoutParams);\n\t}\n\t\t\n\tpublic int getPositionForSection(int sectionIndex) {\n\t\treturn indexData.get(sections[sectionIndex]);\n\t}\n\tpublic int getSectionForPosition(int position) {\n\t\treturn 0;\n\t}\n\tpublic Object[] getSections() {\n\t\treturn sections;\n\t}\n\t\t\n\t@Override\n\tpublic int getCount() {\n\t\treturn toDisplay.size();\n\t}\n\n\t@Override\n\tpublic Object getItem(int position) {\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic long getItemId(int position) {\n\t\treturn 0;\n\t}\n\n\tpublic void update(ArrayList<BaseData> curCatData) {\n\t\tcategoryData = curCatData;\n\t\ttoDisplay = new ArrayList<BaseData>(categoryData);\n\t\tif (!CategoryManager.HISTORY.equals(LauncherApp.getCategoryManager().getCurCategory()))\n\t\t\tCollections.sort(toDisplay, comparator);\n\t\tsetSections();\n\t\tnotifyDataSetChanged();\n\t}\n\t\n\tprivate void setTextColor() {", "context": "app/src/main/java/ru/henridellal/emerald/listener/OnAppUnlockLongClickListener.java\npublic class OnAppUnlockLongClickListener implements View.OnLongClickListener {\n\tprivate SoftReference<Context> contextRef;\n\tpublic OnAppUnlockLongClickListener(Context context) {\n\t\tcontextRef = new SoftReference<Context>(context);\n\t}\n\t\n\t@Override\n\tpublic boolean onLongClick(final View arg0) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(contextRef.get());\n\t\tbuilder.setTitle(contextRef.get().getResources().getString(R.string.type_password));\n\t\tfinal EditText inputBox = new EditText(contextRef.get());\n\t\tinputBox.setInputType(InputType.TYPE_CLASS_TEXT|InputType.TYPE_TEXT_VARIATION_PASSWORD);\n\t\tbuilder.setView(inputBox);\n\t\tbuilder.setPositiveButton(android.R.string.yes, \n\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tif (inputBox.getText().toString().equals(((Apps)contextRef.get()).options.getString(Keys.PASSWORD, \"\"))) {\n\t\t\t\t\t\tBaseData tag = (BaseData) arg0.getTag();\n\t\t\t\t\t\tif (tag instanceof AppData) {\n\t\t\t\t\t\t\t((Apps)contextRef.get()).itemContextMenu((AppData)tag);\n\t\t\t\t\t\t} else if (tag instanceof ShortcutData) {\n\t\t\t\t\t\t\t((Apps)contextRef.get()).itemContextMenu((ShortcutData)tag);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tToast.makeText(contextRef.get(), contextRef.get().getResources().getString(R.string.wrong_password), Toast.LENGTH_LONG).show();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\tbuilder.setNegativeButton(android.R.string.cancel,\n\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t});\n\n\t\tbuilder.setCancelable(true);\n\t\tbuilder.show();\n\t\treturn false;\n\t}\n}\napp/src/main/java/ru/henridellal/emerald/util/IconPackManager.java\npublic class IconPackManager {\n\tprivate Context context;\n\tprivate String iconPackName;\n\tprivate float factor = 1.0f;\n\tprivate ArrayList<Bitmap> iconBacks;\n\tprivate Bitmap iconMask, iconUpon;\n\tprivate boolean transformDrawable = true;\n\tprivate Map<String, String> iconsData;\n\tprivate Resources iconPackRes;\n\n\tpublic Resources getResources() {\n\t\treturn iconPackRes;\n\t}\n\n\tpublic IconPackManager(Context context, String iconPack) {\n\t\tthis.context = context;\n\t\tsetIconPack(iconPack);\n\t}\n\n\tpublic Map<String, String> getIcons() {\n\t\treturn iconsData;\n\t}\n\n\tpublic void setIconPack(String iconPackName) {\n\t\tif (getIconPacks().containsValue(iconPackName) || \"default\".equals(iconPackName)) {\n\t\t\tthis.iconPackName = iconPackName;\n\t\t} else {\n\t\t\tthis.iconPackName = \"default\";\n\t\t\tEditor editor = PreferenceManager.getDefaultSharedPreferences(context).edit();\n\t\t\teditor.putString(Keys.ICON_PACK, this.iconPackName).commit();\n\t\t}\n\t\tsetIcons();\n\t}\n\n\tprivate Bitmap loadBitmap(String drawableName) {\n\t\tint id = iconPackRes.getIdentifier(drawableName, \"drawable\", iconPackName);\n\t\tif (id > 0)\n\t\t\treturn ((BitmapDrawable)iconPackRes.getDrawable(id)).getBitmap();\n\t\telse\n\t\t\treturn null;\n\t}\n\n\t/* Returns Bitmap for default icon pack.\n\t * Includes code for retrieving Oreo+ adaptive icons.\n\t */\n\tpublic Bitmap getDefaultBitmap(Drawable d) {\n\t\tif (d instanceof BitmapDrawable) {\n\t\t\treturn ((BitmapDrawable) d).getBitmap();\n\t\t} else if ((Build.VERSION.SDK_INT >= 26)\n\t\t\t&& (d instanceof AdaptiveIconDrawable)) {\n\t\t\t\tAdaptiveIconDrawable icon = ((AdaptiveIconDrawable)d);\n\t\t\t\tint w = icon.getIntrinsicWidth();\n\t\t\t\tint h = icon.getIntrinsicHeight();\n\t\t\t\tBitmap result = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n\t\t\t\tCanvas canvas = new Canvas(result);\n\t\t\t\ticon.setBounds(0, 0, w, h);\n\t\t\t\ticon.draw(canvas);\n\t\t\t\treturn result;\n\t\t}\n\t\tfloat density = context.getResources().getDisplayMetrics().density;\n\t\tint defaultWidth = (int)(48* density);\n\t\tint defaultHeight = (int)(48* density);\n\t\treturn Bitmap.createBitmap(defaultWidth, defaultHeight, Bitmap.Config.ARGB_8888);\n\t}\n\n\t/* transforms an Drawable object to Bitmap\n\t * and adds effects from icon pack\n\t */\n\tpublic Bitmap transformDrawable(Drawable d) {\n\t\tBitmap b = getDefaultBitmap(d);\n\t\tif ((iconBacks == null && iconMask == null && iconUpon == null && factor == 1.f) || !transformDrawable)\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t\tint w, h;\n\t\tif (null != iconBacks && iconBacks.size() > 0) {\n\t\t\tw = iconBacks.get(0).getWidth();\n\t\t\th = iconBacks.get(0).getHeight();\n\t\t} else {\n\t\t\tw = b.getWidth();\n\t\t\th = b.getHeight();\n\t\t}\n\t\tBitmap result = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n\t\tCanvas canvas = new Canvas(result);\n\t\tif (null != iconBacks && iconBacks.size() > 0) {\n\t\t\tcanvas.drawBitmap(iconBacks.get((int)(Math.random()*iconBacks.size()-1)), 0, 0, null);\n\t\t}\n\t\tPaint p = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\tBitmap scaledBitmap = Bitmap.createScaledBitmap(b, (int)(w*factor), (int)(h*factor), false);\n\t\tcanvas.drawBitmap(scaledBitmap, w*(1-factor)/2, h*(1-factor)/2, p);\n\t\tif (iconMask != null) {\n\t\t\tp.setXfermode(new PorterDuffXfermode(Mode.DST_OUT));\n\t\t\tcanvas.drawBitmap(iconMask, 0.f, 0.f, p);\n\t\t\tp.setXfermode(null);\n\t\t}\n\t\tif (iconUpon != null) {\n\t\t\tcanvas.drawBitmap(iconUpon, 0, 0, null);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic Bitmap getBitmap(String component) {\n\t\tif (iconsData.containsKey(component)) {\n\t\t\tString drawableName = iconsData.get(component);\n\t\t\treturn loadBitmap(drawableName);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/* used by Options class to list all icon packs available*/\n\tpublic Map<String, String> getIconPacks() {\n\t\tMap<String, String> iconPacks = new HashMap<String, String>();\n\t\tPackageManager pm = context.getPackageManager();\n\t\tList<ResolveInfo> iconPacksInfo = pm.queryIntentActivities(new Intent(\"org.adw.launcher.THEMES\"), PackageManager.GET_META_DATA);\n\t\tString iconPackPackage = null;\n\t\tString iconPackName = null;\n\t\tfor (ResolveInfo info: iconPacksInfo) {\n\t\t\ticonPackPackage = info.activityInfo.packageName;\n\t\t\ttry {\n\t\t\t\tApplicationInfo ai = pm.getApplicationInfo(iconPackPackage, PackageManager.GET_META_DATA);\n\t\t\t\ticonPackName = pm.getApplicationLabel(ai).toString();\n\t\t\t} catch (PackageManager.NameNotFoundException e) {\n\t\t\t\tLog.e(Apps.APP_TAG, e.toString());\n\t\t\t}\n\t\t\ticonPacks.put(iconPackName, iconPackPackage);\n\t\t}\n\t\treturn iconPacks;\n\t}\n\n\t//sets icon from cache in ImageView\n\tpublic static void setIcon(Context c, ImageView img, BaseData a) {\n\t\tFile iconFile = Cache.getCustomIconFile(c, a);\n\t\tif (!iconFile.exists()) {\n\t\t\tif (a instanceof AppData) {\n\t\t\t\ticonFile = Cache.getIconFile(c, a);\n\t\t\t} else {\n\t\t\t\ticonFile = Cache.getShortcutIconFile(c, ((ShortcutData)a).getUri());\n\t\t\t}\n\t\t}\n\t\tif (iconFile.exists()){\n\t\t\ttry {\n\t\t\t\timg.setImageDrawable(Drawable.createFromStream(\n\t\t\t\t\tnew FileInputStream(iconFile), null));\n\t\t\t} catch (Exception e) {\n\t\t\t\timg.setImageResource(android.R.drawable.sym_def_app_icon);\n\t\t\t}\n\t\t} else {\n\t\t\timg.setImageResource(android.R.drawable.sym_def_app_icon);\n\t\t}\n\t}\n\n\t/* sets icons data */\n\tpublic void setIcons() {\n\t\ticonsData = new HashMap<String, String>();\n\t\ticonBacks = null;\n\t\ticonMask = null;\n\t\ticonUpon = null;\n\t\tfactor = 1.0f;\n\t\ticonPackRes = null;\n\t\tif (\"default\".equals(iconPackName)) {\n\t\t\treturn;\n\t\t}\n\t\ttransformDrawable = PreferenceManager.getDefaultSharedPreferences(context).getBoolean(Keys.TRANSFORM_DRAWABLE, true);\n\t\tString component = null;\n\t\tString drawable = null;\n\t\tPackageManager pm = context.getPackageManager();\n\t\ticonBacks = new ArrayList<Bitmap>();\n\t\ttry {\n\t\t\ticonPackRes = pm.getResourcesForApplication(iconPackName);\n\t\t} catch (PackageManager.NameNotFoundException nameNotFound) {\n\t\t\tLog.e(Apps.APP_TAG, nameNotFound.toString());\n\t\t}\n\t\ttry {\n\t\t\tint id = iconPackRes.getIdentifier(\"appfilter\", \"xml\", iconPackName);\n\t\t\tXmlPullParser parser = iconPackRes.getXml(id);\n\t\t\tint parserEvent = parser.getEventType();\n\t\t\t\n\t\t\twhile (parserEvent != XmlPullParser.END_DOCUMENT) {\n\t\t\t\tif (parserEvent == XmlPullParser.START_TAG) {\n\t\t\t\t\tfinal String parserName = parser.getName();\n\t\t\t\t\tif (\"item\".equals(parserName)) {\n\t\t\t\t\t\tfor (int i = 0; i < parser.getAttributeCount(); i++) {\n\t\t\t\t\t\t\tif (\"component\".equals(parser.getAttributeName(i))) {\n\t\t\t\t\t\t\t\tcomponent = parser.getAttributeValue(i);\n\t\t\t\t\t\t\t\tint c = component.indexOf(\"{\");\n\t\t\t\t\t\t\t\tcomponent = component.substring(c + 1, component.length() - 1);\n\t\t\t\t\t\t\t} else if (\"drawable\".equals(parser.getAttributeName(i))) {\n\t\t\t\t\t\t\t\tdrawable = parser.getAttributeValue(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ticonsData.put(component, drawable);\n\t\t\t\t\t} else if (\"iconback\".equals(parserName)) {\n\t\t\t\t\t\tfor (int i = 0; i < parser.getAttributeCount(); i++) {\n\t\t\t\t\t\t\ticonBacks.add(loadBitmap(parser.getAttributeValue(i)));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (\"iconmask\".equals(parserName) && parser.getAttributeCount() > 0 && \"iconmask\".equals(parser.getAttributeName(0))) {\n\t\t\t\t\t\ticonMask = loadBitmap(parser.getAttributeValue(0));\n\t\t\t\t\t} else if (\"iconupon\".equals(parserName) && parser.getAttributeCount() > 0 && \"iconupon\".equals(parser.getAttributeName(0))) {\n\t\t\t\t\t\ticonUpon = loadBitmap(parser.getAttributeValue(0));\n\t\t\t\t\t} else if (\"scale\".equals(parserName) && \"factor\".equals(parser.getAttributeName(0))) {\n\t\t\t\t\t\tfactor = Float.valueOf(parser.getAttributeValue(0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparserEvent = parser.next();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLog.e(Apps.APP_TAG, e.toString());\n\t\t}\n\t}\n}\napp/src/main/java/ru/henridellal/emerald/ui/Themer.java\npublic class Themer {\n\n\tpublic static int theme;\n\n\tpublic static final int DEFAULT_THEME = 0;\n\tpublic static final int LIGHT = 1;\n\tpublic static final int DARK = 2;\n\tpublic static final int WALLPAPER_LIGHT = 3;\n\tpublic static final int WALLPAPER_DARK = 4;\n\t\n\tpublic static void applyTheme(Activity activity, SharedPreferences options) {\n\t\ttheme = Integer.parseInt(options.getString(Keys.THEME, activity.getResources().getString(R.string.defaultThemeValue)));\n\t\tswitch (theme) {\n\t\t\tcase LIGHT:\n\t\t\t\tactivity.setTheme(R.style.AppTheme_Light);\n\t\t\t\tbreak;\n\t\t\tcase DARK:\n\t\t\t\tactivity.setTheme(R.style.AppTheme_Dark);\n\t\t\t\tbreak;\n\t\t\tcase WALLPAPER_LIGHT:\n\t\t\t\tactivity.setTheme(R.style.AppTheme_Light_Wallpaper);\n\t\t\t\tbreak;\n\t\t\tcase WALLPAPER_DARK:\n\t\t\t\tactivity.setTheme(R.style.AppTheme_Dark_Wallpaper);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tpublic static void setWindowDecorations(Activity activity, SharedPreferences options) {\n\t\tif (!options.getBoolean(Keys.FULLSCREEN, false)) {\n\t\t\tactivity.getWindow().setStatusBarColor(options.getInt(Keys.STATUS_BAR_BACKGROUND, 0x22000000));\n\t\t}\n\t\tactivity.getWindow().setNavigationBarColor(options.getInt(Keys.NAV_BAR_BACKGROUND, 0x22000000));\n\t}\n}\napp/src/main/java/ru/henridellal/emerald/listener/OnAppClickListener.java\npublic class OnAppClickListener implements View.OnClickListener {\n\tprivate SoftReference<Apps> appsRef;\n\tpublic OnAppClickListener(Apps apps) {\n\t\tappsRef = new SoftReference<Apps>(apps);\n\t}\n\t\n\t@Override\n\tpublic void onClick(View arg0) {\n\t\tif (arg0.getTag() instanceof BaseData) {\n\t\t\tappsRef.get().launch((BaseData)arg0.getTag());\n\t\t}\n\t}\n}\napp/src/main/java/ru/henridellal/emerald/LauncherApp.java\npublic class LauncherApp extends Application {\n\tprivate static LauncherApp singleton;\n\tpublic static LauncherApp getInstance() {\n\t\treturn singleton;\n\t}\n\t\n\tprivate static IconPackManager ipm;\n\tprivate static CategoryManager cm;\n\tpublic static IconPackManager getIconPackManager() {\n\t\treturn ipm;\n\t}\n\tpublic static CategoryManager getCategoryManager() {\n\t\treturn cm;\n\t}\n\n\t@Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\t\tString iconPack = PreferenceManager.getDefaultSharedPreferences(getApplicationContext())\n\t\t\t.getString(Keys.ICON_PACK, \"default\");\n\t\tipm = new IconPackManager(getApplicationContext(), iconPack);\n\t\tcm = new CategoryManager(getApplicationContext());\n\t}\n}\napp/src/main/java/ru/henridellal/emerald/preference/Keys.java\npublic final class Keys {\n\tpublic static final String SHOW_TUTORIAL = \"show_tutorial\";\n\tpublic static final String MESSAGE_SHOWN = \"message_shown\";\n\tpublic static final String KEEP_IN_MEMORY = \"keep_in_memory\";\n\tpublic static final String VOLUME_BUTTONS = \"volume_buttons\";\n\tpublic static final String FULLSCREEN = \"fullscreen\";\n\t\n\tpublic static final String BAR_BACKGROUND = \"bar_background\";\n\tpublic static final String DOCK_BACKGROUND = \"dock_background\";\n\tpublic static final String NAV_BAR_BACKGROUND = \"nav_bar_background\";\n\tpublic static final String STATUS_BAR_BACKGROUND = \"status_bar_background\";\n\tpublic static final String APPS_WINDOW_BACKGROUND = \"apps_background\";\n\t\n\tpublic static final String ICON_PACK = \"icon_pack\";\n\tpublic static final String ICON_PACK_CHANGED = \"icon_pack_changed\";\n\tpublic static final String TRANSFORM_DRAWABLE = \"transform_drawable\";\n\tpublic static final String APP_SHORTCUT = \"app_shortcut\";\n\tpublic static final String PREV_APP_SHORTCUT = \"prevApp_shortcut\";\n\tpublic static final String SHOW_KEYBOARD_ON_START = \"show_keyboard\";\n\tpublic static final String TILE = \"tile\";\n\tpublic static final String HIDE_MAIN_BAR = \"hide_main_bar\";\n\tpublic static final String BOTTOM_MAIN_BAR = \"bottom_main_bar\";\n\tpublic static final String STACK_FROM_BOTTOM = \"stack_from_bottom\";\n\tpublic static final String SCROLLBAR = \"scrollbar\";\n\tpublic static final String INVERT_FONT_COLOR = \"invert_font_color\";\n\t\n\tpublic static final String ICON_SIZE = \"icon_size\";\n\tpublic static final String TEXT_SIZE = \"text_size\";\n\tpublic static final String FONT_STYLE = \"font_style\";\n\tpublic static final String COLUMN_WIDTH = \"column_width\";\n\tpublic static final String VERTICAL_SPACING = \"vertical_spacing\";\n\t\n\tpublic static final String ICON_SIZE_LANDSCAPE = \"icon_size_land\";\n\tpublic static final String TEXT_SIZE_LANDSCAPE = \"text_size_land\";\n\tpublic static final String COLUMN_WIDTH_LANDSCAPE = \"column_width_land\";\n\tpublic static final String VERTICAL_SPACING_LANDSCAPE = \"vertical_spacing_land\";\n\t\n\tpublic static final String DOCK_IN_LANDSCAPE = \"show_dock_in_landscape\";\n\t\n\tpublic static final String HOME = \"home\";\n\tpublic static final String HOME_BUTTON = \"home_button\";\n\tpublic static final String CATEGORY = \"category\";\n\tpublic static final String ORIENTATION = \"orientation\";\n\tpublic static final String SEARCH_PROVIDER = \"search_provider\";\n\tpublic static final String THEME = \"theme\";\n\tpublic static final String HISTORY_SIZE = \"history_size\";\n\tpublic static final String HIDE_HISTORY = \"hide_history\";\n\tpublic static final String HIDE_UNCLASSIFIED = \"hide_unclassified\";\n\tpublic static final String HIDE_ALL = \"hide_all\";\n\tpublic static final String PASSWORD = \"password\";\n\t\n\tpublic static final String[] BACKUP = {SHOW_TUTORIAL,\n\t\tKEEP_IN_MEMORY, FULLSCREEN, BAR_BACKGROUND, DOCK_BACKGROUND,\n\t\tNAV_BAR_BACKGROUND, STATUS_BAR_BACKGROUND,\n\t\tAPPS_WINDOW_BACKGROUND, ICON_PACK, TRANSFORM_DRAWABLE,\n\t\tAPP_SHORTCUT, PREV_APP_SHORTCUT,\n\t\tSHOW_KEYBOARD_ON_START, TILE, BOTTOM_MAIN_BAR,\n\t\tHIDE_MAIN_BAR, STACK_FROM_BOTTOM, SCROLLBAR, INVERT_FONT_COLOR,\n\t\tICON_SIZE, TEXT_SIZE, FONT_STYLE, COLUMN_WIDTH,\n\t\tVERTICAL_SPACING, ICON_SIZE_LANDSCAPE, \n\t\tTEXT_SIZE_LANDSCAPE, COLUMN_WIDTH_LANDSCAPE,\n\t\tVERTICAL_SPACING_LANDSCAPE, DOCK_IN_LANDSCAPE,\n\t\tHOME, HOME_BUTTON, ORIENTATION, SEARCH_PROVIDER,\n\t\tTHEME, HISTORY_SIZE\n\t};\n\t\n\tpublic static final String[] restart = {MESSAGE_SHOWN, FULLSCREEN, BAR_BACKGROUND,\n\t\tNAV_BAR_BACKGROUND, STATUS_BAR_BACKGROUND, DOCK_BACKGROUND,\n\t\tAPPS_WINDOW_BACKGROUND, SHOW_KEYBOARD_ON_START, TILE, BOTTOM_MAIN_BAR, HIDE_MAIN_BAR,\n\t\tSTACK_FROM_BOTTOM, FONT_STYLE, SCROLLBAR, INVERT_FONT_COLOR, THEME, ORIENTATION,\n\t\tAPP_SHORTCUT, KEEP_IN_MEMORY, PASSWORD, ICON_PACK_CHANGED};\n\n}\napp/src/main/java/ru/henridellal/emerald/data/CategoryManager.java\npublic class CategoryManager {\n\tpublic static final String ALL = \"All\";\n\tpublic static final String UNCLASSIFIED = \"Unclassified\";\n\tpublic static final String HIDDEN = \"Hidden\";\n\tpublic static final String HISTORY = \"History\";\n\t\n\tpublic static final byte PREVIOUS = 0;\n\tpublic static final byte NEXT = 1;\n\t\n\tprivate SoftReference<Context> contextRef;\n\tprivate String home;\n\tprivate String curCategory;\n\tprivate ArrayList<String> names;\n\tprivate Map<String,Category> categories;\n\tprivate SharedPreferences options;\n\tprivate ArrayList<String> history;\n\tprivate static final int HISTORY_MAX = 10;\n\t\n\tpublic CategoryManager(Context context) {\n\t\tcontextRef = new SoftReference<Context>(context);\n\t\tthis.options = PreferenceManager.getDefaultSharedPreferences(context);\n\t\thistory = new ArrayList<String>();\n\t\tloadCategoriesList();\n\t\tcurCategory = options.getString(Keys.CATEGORY, ALL);\n\t\thome = options.getString(Keys.HOME, ALL);\n\t}\n\n\tpublic void loadCategoriesList() {\n\t\tcategories = DatabaseHelper.getCategories(contextRef.get());\n\t\tnames = new ArrayList<String>(categories.keySet());\n\t\tsortNames();\n\t}\n\n\tpublic String getHome() {\n\t\treturn home;\n\t}\n\n\tpublic void setHome(String catName) {\n\t\tif (haveCategory(catName)) {\n\t\t\thome = catName;\n\t\t\toptions.edit().putString(Keys.HOME, home).commit();\n\t\t}\n\t}\n\t/*Checks if Categories instance has a category named s*/\n\tpublic boolean haveCategory(String s) {\n\t\treturn names.contains(s);\n\t}\n\t/*Functions for spinner. Return names of categories\n\twhich are neighbouring to the current*/\n\tpublic String getCategory(byte direction) {\n\t\tif (!curCategory.equals(HIDDEN)) {\n\t\t\tint result = names.indexOf(curCategory);\n\t\t\tint startPosition = result;\n\t\t\tfor (int i = 0; i < names.size(); i++) {\n\t\t\t\tif (direction == PREVIOUS) {\n\t\t\t\t\tresult--;\n\t\t\t\t\tresult = (result > -1) ? result : names.size()-2;\n\t\t\t\t} else {\n\t\t\t\t\tresult++;\n\t\t\t\t\tresult = (result < names.size()-1) ? result : 0;\n\t\t\t\t}\n\t\t\t\tif (startPosition == result) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (!isHidden(names.get(result))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn names.get(result);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic Category getCategory(String categoryName) {\n\t\tif (categories.containsKey(categoryName)) {\n\t\t\treturn categories.get(categoryName);\n\t\t} else {\n\t\t\treturn categories.get(ALL);\n\t\t}\n\t}\n\n\tpublic boolean isHidden(String categoryName) {\n\t\tif (HISTORY.equals(categoryName)) {\n\t\t\treturn options.getBoolean(Keys.HIDE_HISTORY, false);\n\t\t} else if (UNCLASSIFIED.equals(categoryName)) {\n\t\t\treturn options.getBoolean(Keys.HIDE_UNCLASSIFIED, false);\n\t\t} else if (ALL.equals(categoryName)) {\n\t\t\treturn options.getBoolean(Keys.HIDE_ALL, false);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t/*Sets current category and saves its name in preferences*/\n\tpublic void setCurCategory(String category) {\n\t\tsetCurCategory(category, true);\n\t}\n\t\n\tpublic void setCurCategory(String category, boolean push) {\n\t\tif (push)\n\t\t\tpushCategory(curCategory);\n\t\tcurCategory = category;\n\t\toptions.edit().putString(Keys.CATEGORY, category).commit();\n\t}\n\n\t//sets previously chosen category as current\n\tpublic void prevCategory() {\n\t\tString c = popCategory();\n\t\tif (c != null) {\n\t\t\tsetCurCategory(c, false);\n\t\t}\n\t}\n\t\n\tprivate void pushCategory(String c) {\n\t\tif (history.size() > 0 && history.get(history.size()-1).equals(c))\n\t\t\treturn;\n\t\tif (history.size() >= HISTORY_MAX)\n\t\t\thistory.remove(0);\n\t\t//Log.v(\"TinyLaunch\", \"push \"+c);\n\t\thistory.add(c);\n\t}\n\n\t//returns (pops) previously chosen category from history\n\tprivate String popCategory() {\n\t\twhile (history.size() > 0) {\n\t\t\tString c = history.get(history.size()-1);\n\t\t\thistory.remove(history.size()-1);\n\t\t\tif (names.contains(c)) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\treturn home;\n\t}\n\n\t//return category names\n\tpublic ArrayList<String> getCategories() {\n\t\treturn names;\n\t}\n\n\t//sorts categories in specific order\n\t//All > custom categories > Unclassified > History > Hidden\n\tpublic void sortNames() {\n\t\tCollections.sort(names, new Comparator<String>(){\n\t\t\t//private Map<String, Integer> defaultRanks = new Map<String, Integer>();\n\t\t\t@Override\n\t\t\tpublic int compare(String lhs, String rhs) {\n\t\t\t\t//int lhsNumber, rhsNumber;\n\t\t\t\tif (lhs.equals(ALL)) {\n\t\t\t\t\tif (rhs.equals(ALL))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn -1;\n\t\t\t\t} else if (lhs.equals(HIDDEN)) {\n\t\t\t\t\tif (rhs.equals(HIDDEN)) \n\t\t\t\t\t\treturn 0;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn 1;\n\t\t\t\t} else if (lhs.equals(UNCLASSIFIED)) {\n\t\t\t\t\tif (rhs.equals(UNCLASSIFIED)) \n\t\t\t\t\t\treturn 0;\n\t\t\t\t\telse if (rhs.equals(HIDDEN) || rhs.equals(HISTORY))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn 1;\n\t\t\t\t} else if (lhs.equals(HISTORY)) {\n\t\t\t\t\tif (rhs.equals(HISTORY))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\telse if (rhs.equals(HIDDEN))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn 1;\n\t\t\t\t} else if (rhs.equals(ALL)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else if (rhs.equals(HIDDEN) || rhs.equals(UNCLASSIFIED) || rhs.equals(HISTORY)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn lhs.compareToIgnoreCase(rhs);\n\t\t\t}});\n\t}\n\t\n\tpublic ArrayList<String> getEditableCategories() {\n\t\tArrayList<String> customNames = new ArrayList<String>();\n\t\tfor (String s : names) {\n\t\t\tif (isEditable(s)) {\n\t\t\t\tcustomNames.add(s);\n\t\t\t}\n\t\t}\n\t\treturn customNames;\n\t}\n\t//can be renamed and deleted or not\n\tpublic static boolean isCustom(String c) {\n\t\treturn ! c.equals(ALL) && ! c.equals(UNCLASSIFIED) && ! c.equals(HIDDEN) && ! c.equals(HISTORY);\n\t}\n\t//can be filled with apps by the user\n\tpublic static boolean isEditable(String c) {\n\t\treturn ! c.equals(ALL) && ! c.equals(UNCLASSIFIED);\n\t}\n\t//checks if category has an app\n\tpublic boolean in(BaseData item, String cat) {\n\t\treturn categories.get(cat).getData().contains(item);\n\t}\n\n\tpublic String getCurCategory() {\n\t\treturn curCategory;\n\t}\n}\napp/src/main/java/ru/henridellal/emerald/listener/OnAppLongClickListener.java\npublic class OnAppLongClickListener implements View.OnLongClickListener {\n\tprivate SoftReference<Apps> appsRef;\n\tpublic OnAppLongClickListener(Apps apps) {\n\t\tappsRef = new SoftReference<Apps>(apps);\n\t}\n\t\n\t@Override\n\tpublic boolean onLongClick(View arg0) {\n\t\tif (arg0.getTag() instanceof AppData) {\n\t\t\tappsRef.get().itemContextMenu((AppData)arg0.getTag());\n\t\t} else if (arg0.getTag() instanceof ShortcutData) {\n\t\t\tappsRef.get().itemContextMenu((ShortcutData)arg0.getTag());\n\t\t}\n\t\treturn false;\n\t}\n}\napp/src/main/java/ru/henridellal/emerald/activity/Apps.java\npublic class Apps extends Activity\n{\n\tprivate GestureDetector gestureDetector;\n\tprivate CategoryManager categories;\n\tprivate ArrayList<BaseData> curCatData;\n\tprivate GridView grid;\n\tpublic SharedPreferences options;\n\tpublic static final String PREF_APPS = \"apps\";\n\tpublic static final String APP_TAG = \"ru.henridellal.emerald\";\n\tpublic static final String ACTION_OPEN_MENU = \"ru.henridellal.emerald.open_menu\";\n\tprivate CustomAdapter adapter;\n\tpublic static final int GRID = 0;\n\tpublic static final int LIST = 1;\n\tprivate boolean lock, searchIsOpened, homeButtonPressed, launcherUpdate;\n\n\tprivate void addMenuShortcut() {\n\t\tIntent menuIntent = new Intent(this, Apps.class);\n\t\tmenuIntent.setAction(ACTION_OPEN_MENU);\n\t\tIntent shortcutIntent = new Intent();\n\t\tshortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, menuIntent);\n\t\tshortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, getResources().getString(R.string.launcher_menu));\n\t\tshortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, Intent.ShortcutIconResource.fromContext(this, R.mipmap.icon));\n\t\tshortcutIntent.setAction(\"com.android.launcher.action.INSTALL_SHORTCUT\");\n\t\tsendBroadcast(shortcutIntent);\n\t}\n\n\tpublic void changePrefsOnRotate() {\n\t\tResources res = getResources();\n\t\tfloat density = res.getDisplayMetrics().density;\n\t\tint iconSize, textSize, verticalSpacing, columnWidth;\n\t\tboolean hideDockInLandscape = !(options.getBoolean(Keys.DOCK_IN_LANDSCAPE, true));\n\n\t\tif (res.getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {\n\t\t\t//Log.v(APP_TAG, \"loadFilteredApps : Portrait orientation\");\n\t\t\ticonSize = (int)(options.getInt(Keys.ICON_SIZE, res.getInteger(R.integer.icon_size_default)) * density);\n\t\t\ttextSize = (int)(options.getInt(Keys.TEXT_SIZE, res.getInteger(R.integer.text_size_default)) * density);\n\t    \tverticalSpacing = (int)(options.getInt(Keys.VERTICAL_SPACING, res.getInteger(R.integer.vertical_spacing_default)) * density);\n\n\t    \tif (options.getBoolean(Keys.TILE, true)) {\n\t    \t\tcolumnWidth = (int)(options.getInt(Keys.COLUMN_WIDTH, res.getInteger(R.integer.column_width_default)) * density);\n\t    \t\tgrid.setColumnWidth(columnWidth);\n\t\t\t} else {\n\t    \t\tgrid.setNumColumns(1);\n\t    \t}\n\t    \tif (hideDockInLandscape) {\n\t    \t\tDock.setAlwaysHide(false);\n\t    \t\tDock.unhide();\n\t    \t}\n\t\t} else {\n\t\t\t//Log.v(APP_TAG, \"loadFilteredApps : orientation\");\n\t\t\ticonSize = (int)(options.getInt(Keys.ICON_SIZE_LANDSCAPE, res.getInteger(R.integer.icon_size_land_default)) * density);\n\t\t\ttextSize = (int)(options.getInt(Keys.TEXT_SIZE_LANDSCAPE, res.getInteger(R.integer.text_size_land_default)) * density);\n\t\t\tverticalSpacing = (int)(options.getInt(Keys.VERTICAL_SPACING_LANDSCAPE, res.getInteger(R.integer.vertical_spacing_land_default)) * density);\n\t    \tif (options.getBoolean(Keys.TILE, true)) {\n\t\t\t\tcolumnWidth = (int)(options.getInt(Keys.COLUMN_WIDTH_LANDSCAPE, res.getInteger(R.integer.column_width_land_default)) * density);\n\t    \t} else {\n\t    \t\tgrid.setNumColumns(2);\n\t    \t\tcolumnWidth = -1;\n\t    \t}\n\t\t\tgrid.setColumnWidth(columnWidth);\n\t    \tif (hideDockInLandscape) {\n\t    \t\tDock.hide();\n\t    \t\tDock.setAlwaysHide(true);\n\t    \t}\n\t\t}\n\t\tadapter.setIconSize(iconSize);\n\t\tadapter.setTextSize(textSize);\n\t\tgrid.setVerticalSpacing(verticalSpacing);\n\t}\n\n\tpublic void loadFilteredApps() {\n\t\tCategory curCategory = categories.getCategory(categories.getCurCategory());\n\t\tcurCatData = DatabaseHelper.getEntries(this, curCategory.getName());\n\t\tadapter.update(curCatData);\n\t\tif (!options.getBoolean(Keys.HIDE_MAIN_BAR, false)) {\n\t\t\t((Button)findViewById(R.id.category_button)).setText(curCategory.getRepresentName(this));\n\t\t}\n\t\t/*if (null != mGetAppsThread)\n\t\t\tmGetAppsThread.quit();*/\n\t}\n\n\t//launches app and adds it to history\n\tpublic boolean launch(BaseData item) {\n\t\tIntent i = item.getLaunchIntent(this);\n\t\tif (i == null) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tstartActivity(i);\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\tToast.makeText(this, \"Activity is not found\", Toast.LENGTH_LONG).show();\n\t\t\tDatabaseHelper.removeApp(this, item.getComponent());\n\t\t\tloadFilteredApps();\n\t\t} finally {\n\t\t\tif (searchIsOpened) {\n\t\t\t\tcloseSearch();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t\n\tpublic static ProgressDialog progress;\n\tprotected boolean icons;\n\tprotected int appShortcut;\n\tpublic static Handler handler;\n\tpublic static AppsTaskHandler loadAppsHandler;\n\tpublic static GetAppsThread mGetAppsThread;\n\n\tpublic static class AppsTaskHandler extends Handler {\n\t\tApps activity;\n\t\tAppsTaskHandler(Apps activity) {\n\t\t\tthis.activity = activity;\n\t\t}\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\ttry {\n\t\t\t\tprogress.dismiss();\n\t\t\t}\n\t\t\tcatch (Exception ignored) {}\n\t\t\tactivity.loadFilteredApps();\n\t\t\tmGetAppsThread.quit();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void loadAppsFromSystem(final boolean iconPackChanged) {\n\t\tif (null != progress) {\n\t\t\ttry {\n\t\t\t\tif (null != mGetAppsThread)\n\t\t\t\t\tmGetAppsThread.quit();\n\t\t\t\tprogress.dismiss();\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\tprogress = new ProgressDialog(this);\n\t\tprogress.setCancelable(false);\n\t\tprogress.setMessage(\"Getting applications...\");\n\t\tprogress.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n\t\tprogress.setIndeterminate(true);\n\t\tprogress.show();\n\t\t//TODO access shared preferences the other way\n\t\tappShortcut = Integer.parseInt(options.getString(Keys.APP_SHORTCUT, \"3\"));\n\t\ticons = appShortcut >= CustomAdapter.ICON;\n\t\t// delete icons from cache if they aren't used\n\t\tif (!icons) {\n\t\t\tCache.deleteIcons(this);\n\t\t}\n\t\thandler = new Handler();\n\t\tloadAppsHandler = new AppsTaskHandler(this);\n\t\tRunnable appsTask;\n\t\tif (Build.VERSION.SDK_INT >= 21) {\n\t\t\tappsTask = new AppsTaskLollipop(this, icons, iconPackChanged);\n\t\t} else {\n\t\t\tappsTask = new AppsTask(this, icons, iconPackChanged);\n\t\t}\n\t\tmGetAppsThread = new GetAppsThread(\"GetAppsThread\");\n\t\tmGetAppsThread.start();\n\t\tmGetAppsThread.prepareHandler();\n\t\tmGetAppsThread.postTask(appsTask);\n\t\t\n\t}\n\tpublic static void writeIconToFile(File iconFile, Drawable d, String component) {\n\t\ttry {\n\t\t\tBitmap bmp;\n\t\t\tIconPackManager ipm = LauncherApp.getInstance().getIconPackManager();\n\t\t\t// get icon from icon pack\n\t\t\tif ((bmp = ipm.getBitmap(component)) == null) {\n\t\t\t\t// edit drawable to match icon pack\n\t\t\t\tbmp = ipm.transformDrawable(d);\n\t\t\t}\n\t\t\t// save icon in cache\n\t\t\tFileOutputStream out = new FileOutputStream(iconFile);\n\t\t\tbmp.compress(CompressFormat.PNG, 100, out);\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\ticonFile.delete();\n\t\t}\n\t}\n\n\tprivate void openCategoriesList() {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setCancelable(true);\n\t\tcategories.loadCategoriesList(); // TODO Remove after migration to 0.6.0\n\t\tfinal ArrayList<String> cats = new ArrayList<String>(categories.getCategories());\n\t\tcats.remove(CategoryManager.HIDDEN);\n\t\tArrayList<String> toRemove = new ArrayList<String>();\n\t\tfor (String category: cats) {\n\t\t\tif (categories.isHidden(category))\n\t\t\t\ttoRemove.add(category);\n\t\t}\n\t\tcats.removeAll(toRemove);\n\t\ttoRemove = null;\n\t\tfinal ArrayList<String> categoriesNames = new ArrayList<String>(cats.size());\n\t\tfor (String category: cats) {\n\t\t\tcategoriesNames.add(categories.getCategory(category).getRepresentName(this));\n\t\t}\n\t\tbuilder.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, categoriesNames), \n\t\t\tnew DialogInterface.OnClickListener(){\n\t\t\t@Override\n\t\t\tpublic void onClick(DialogInterface di, int catNum) {\n\t\t\t\tString newCat = cats.get(catNum);\n\t\t\t\tif (!newCat.equals(categories.getCurCategory())) {\n\t\t\t\t\tcategories.setCurCategory(newCat);\n\t\t\t\t\tloadFilteredApps();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (!isFinishing())\n\t\t\tbuilder.create().show();\n\t}\n\t//shows popup window for editing categories of app or shortcut\n\tprivate void itemEdit(final BaseData item) {\n\t\t//Log.v(APP_TAG, \"Open app edit window\");\n\t\t\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\n\t\tbuilder.setTitle(item.getName());\n\t\tbuilder.setCancelable(true);\n\n\t\tArrayList<String> editableCategories =  categories.getEditableCategories();\n\t\tfinal int nCategories = editableCategories.size();\n\t\tArrayList<String> editableCategoriesNames = new ArrayList<String>(nCategories);\n\t\tfinal int position = grid.getFirstVisiblePosition();\n\t\tfor (String category: editableCategories) {\n\t\t\teditableCategoriesNames.add(categories.getCategory(category).getRepresentName(this));\n\t\t}\n\t\tif (nCategories > 0) {\n\t\t\tfinal String[] editableCategoriesArray = new String[nCategories];\n\t\t\teditableCategories.toArray(editableCategoriesArray);\n\t\t\tfinal String[] editableCategoriesNamesArray = new String[nCategories];\n\t\t\teditableCategoriesNames.toArray(editableCategoriesNamesArray);\n\t\t\t\n\t\t\tfinal boolean[] checked = new boolean[nCategories];\t\t\t\n\n\t\t\tfor (int i = 0; i < nCategories ; i++) {\n\t\t\t\tchecked[i] = DatabaseHelper.hasItem(this, item, editableCategoriesArray[i]);\n\t\t\t}\n\n\t\t\tfinal boolean[] oldChecked = checked.clone();\n\n\t\t\tbuilder.setMultiChoiceItems(editableCategoriesNamesArray, checked, \n\t\t\t\tnew DialogInterface.OnMultiChoiceClickListener() {\t\t\t\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which, boolean isChecked) {\n\t\t\t\t}\n\t\t\t});\n\t\t\tbuilder.setPositiveButton(\"OK\", new OnClickListener(){\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface arg0, int arg1) {\n\t\t\t\t\tfor (int i = 0 ; i < nCategories ; i++) {\n\t\t\t\t\t\tif (checked[i] && ! oldChecked[i])\n\t\t\t\t\t\t\tDatabaseHelper.addToCategory(Apps.this, item, editableCategoriesArray[i]);\n\t\t\t\t\t\telse if (!checked[i] && oldChecked[i])\n\t\t\t\t\t\t\tDatabaseHelper.removeFromCategory(Apps.this, item, editableCategoriesArray[i]);\n\t\t\t\t\t}\n\t\t\t\t\tloadFilteredApps();\n\t\t\t\t\tgrid.setSelection(position);\n\t\t\t\t}});\n\t\t}\n\t\tif (!isFinishing())\n\t\t\tbuilder.create().show();\n\t}\n\tpublic void itemContextMenu(final AppData item) {\n\t\t//Log.v(APP_TAG, \"Open app edit window\");\n\t\t\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tResources res = getResources();\n\t\tbuilder.setTitle(item.getName());\n\t\tbuilder.setCancelable(true);\n\t\t\n\t\tString[] commands = new String[]{\n\t\t\tres.getString(R.string.aboutTitle),\n\t\t\t\tres.getString(R.string.findInMarket),\n\t\t\tres.getString(R.string.editAppCategories),\n\t\t\tres.getString(R.string.uninstall),\n\t\t\t(Dock.hasApp(item)) ? \n\t\t\t\tres.getString(R.string.remove_from_dock):\n\t\t\t\tres.getString(R.string.add_to_dock),\n\t\t\tres.getString(R.string.change_icon)\n\t\t};\n\t\tbuilder.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, commands),\n\t\tnew DialogInterface.OnClickListener(){\n\t\t\tpublic void onClick(DialogInterface di, int which) {\n\t\t\t\tUri uri;\n\t\t\t\tswitch(which) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\turi = Uri.parse(\"package:\"+ComponentName.unflattenFromString(\n\t\t\t\t\t\t\titem.getComponent()).getPackageName());\n\t\t\t\t\t\tstartActivity(new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS, uri));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\turi = Uri.parse(\"market://details?id=\"+ComponentName.unflattenFromString(\n\t\t\t\t\t\t\titem.getComponent()).getPackageName());\n\t\t\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, uri));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\titemEdit(item);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\turi = Uri.parse(\"package:\"+ComponentName.unflattenFromString(\n\t\t\t\t\t\t\titem.getComponent()).getPackageName());\n\t\t\t\t\t\tstartActivityForResult(new Intent(Intent.ACTION_DELETE, uri), 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tif (Dock.hasApp(item)) {\n\t\t\t\t\t\t\tDock.remove(item);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!Dock.isFull()) {\n\t\t\t\t\t\t\t\tDock.add(item);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tToast.makeText(Apps.this, getResources().getString(R.string.dock_is_full), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDock.update();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tIntent intent = new Intent(Apps.this, ChangeIconActivity.class);\n\t\t\t\t\t\tintent.putExtra(ChangeIconActivity.COMPONENT_NAME, item.getComponent());\n\t\t\t\t\t\tintent.putExtra(ChangeIconActivity.SHORTCUT_NAME, item.getName());\n\t\t\t\t\t\tstartActivity(intent);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (!isFinishing())\n\t\t\tbuilder.create().show();\n\t}\n\t\n\tpublic void itemContextMenu(final ShortcutData item) {\n\t\t//Log.v(APP_TAG, \"Open app edit window\");\n\t\t\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tResources res = getResources();\n\t\tbuilder.setTitle(item.getName());\n\t\tbuilder.setCancelable(true);\n\t\t\n\t\tString[] commands = new String[]{\n\t\t\t\tres.getString(R.string.editCategories),\n\t\t\t\tres.getString(R.string.uninstall),\n\t\t\t(Dock.hasApp(item)) ?\n\t\t\t\t\tres.getString(R.string.remove_from_dock):\n\t\t\t\t\tres.getString(R.string.add_to_dock)\n\t\t};\n\t\tbuilder.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, commands),\n\t\tnew DialogInterface.OnClickListener(){\n\t\t\tpublic void onClick(DialogInterface di, int which) {\n\t\t\t\tswitch(which) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\titemEdit(item);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tDatabaseHelper.removeShortcut(Apps.this, item.getUri());\n\t\t\t\t\t\tloadFilteredApps();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tif (Dock.hasApp(item)) {\n\t\t\t\t\t\t\tDock.remove(item);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!Dock.isFull()) {\n\t\t\t\t\t\t\t\tDock.add(item);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tToast.makeText(Apps.this, getResources().getString(R.string.dock_is_full), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDock.update();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (!isFinishing())\n\t\t\tbuilder.create().show();\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\t//Log.v(APP_TAG, \"Configuration changed\");\n\t\tsuper.onConfigurationChanged(newConfig);\n\t\tchangePrefsOnRotate();\n\t\tloadFilteredApps();\n\t}\n\t\n\tprivate void menu() {\n\t\t//Log.v(APP_TAG, \"Trying to open menu\");\n\t\tif (lock) {\n\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t//builder.setTitle(\"\");\n\t\t\tbuilder.setMessage(getResources().getString(R.string.type_password));\n\t\t\tfinal EditText inputBox = new EditText(this);\n\t\t\tinputBox.setInputType(InputType.TYPE_CLASS_TEXT|InputType.TYPE_TEXT_VARIATION_PASSWORD);\n\t\t\tbuilder.setView(inputBox);\n\t\t\tbuilder.setPositiveButton(android.R.string.yes, \n\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tif (inputBox.getText().toString().equals(options.getString(Keys.PASSWORD, \"\"))) {\n\t\t\t\t\t\topenOptionsMenu();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tToast.makeText(getApplicationContext(), getResources().getString(R.string.wrong_password), Toast.LENGTH_LONG).show();\n\t\t\t\t\t}\n\t\t\t} });\n\t\t\tbuilder.setCancelable(true);\n\t\t\tif (!isFinishing()) {\n\t\t\t\tbuilder.show();\n\t\t\t}\n\t\t} else {\n\t\t\topenOptionsMenu();\n\t\t}\n\t}\n\tprivate boolean isDefaultLauncher() {\n\t\tfinal Intent intent = new Intent(Intent.ACTION_MAIN);\n\t\tintent.addCategory(Intent.CATEGORY_HOME);\n\t\tfinal ResolveInfo resolveInfo =\n\t\t\t\tgetPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);\n        return resolveInfo != null &&\n\t\t\t\tgetPackageName().equals(resolveInfo.activityInfo.packageName);\n\t}\n\t\n\tprotected void onMenuButton(View v) {\n\t\tmenu();\n\t}\n\tpublic void searchInWeb(String text) {\n\t\tString site = options.getString(Keys.SEARCH_PROVIDER, \"https://duckduckgo.com/?q=\");\n\t\tString url = site + text;\n\t\tIntent intent = new Intent(Intent.ACTION_VIEW);\n\t\tintent.setData(Uri.parse(url));\n\t\ttry {\n\t\t\tstartActivity(intent);\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\tToast.makeText(this, \"Cannot handle \"+ url + \" request\", Toast.LENGTH_LONG).show();\n\t\t}\n\t}\n\tpublic void openSearch() {\n\t\t//Log.v(APP_TAG, \"Start searching\");\n\t\tcategories.setCurCategory(CategoryManager.ALL);\n\t\tloadFilteredApps();\n\t\ttoggleFullscreen(false);\n\t\tif (options.getBoolean(Keys.HIDE_MAIN_BAR, false)) {\n\t\t\tfindViewById(R.id.main_bar).setVisibility(View.VISIBLE);\n\t\t}\n\t\tfindViewById(R.id.tabs).setVisibility(View.GONE);\n\t\tInputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\t\tfinal EditText text = (EditText)findViewById(R.id.textField);\n\t\tif (imm != null) {\n\t\t\timm.showSoftInput(grid, InputMethodManager.SHOW_IMPLICIT);\n\t\t}\n\t\tfindViewById(R.id.searchBar).setVisibility(View.VISIBLE);\n\t\ttext.setVisibility(View.VISIBLE);\n\t\tfindViewById(R.id.webSearchButton).setVisibility(View.VISIBLE);\n\t\tif (Dock.isVisible()) {\n\t\t\tDock.hide();\n\t\t}\n\t\ttext.addTextChangedListener(new TextWatcher() {\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {}\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {}\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int count, int after) {\n\t\t\t\tadapter.filter(s);\n\t\t\t}\n\t\t});\n\t\ttext.setOnKeyListener(new View.OnKeyListener() {\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() != KeyEvent.ACTION_DOWN) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// allow arrow up/down to focus the grid of apps\n\t\t\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_UP || keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {\n\t\t\t\t\tgrid.requestFocus();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// On enter, search the internet\n\t\t\t\tif (keyCode == KeyEvent.KEYCODE_ENTER) {\n\t\t\t\t\tsearchInWeb(text.getText().toString());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\tView.OnClickListener onClick = new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsearchInWeb(text.getText().toString());\n\t\t\t}\n\t\t};\n\t\tfindViewById(R.id.webSearchButton).setOnClickListener(onClick);\n\t\tsearchIsOpened = true;\n\t\ttext.requestFocusFromTouch();\n\t}\n\tpublic void closeSearch() {\n\t\t//Log.v(APP_TAG, \"Quit search\");\n\t\tEditText text = (EditText)findViewById(R.id.textField);\n\t\ttext.setText(\"\");\n\t\tfindViewById(R.id.searchBar).setVisibility(View.GONE);\n\t\tfindViewById(R.id.webSearchButton).setVisibility(View.GONE);\n\t\ttext.setVisibility(View.GONE);\n\t\thideMainBarIfNeeded();\n\t\tif (!Dock.isEmpty()) {\n\t\t\tDock.unhide();\n\t\t}\n\t\tsearchIsOpened=false;\n\t\ttoggleFullscreen(true);\n\t}\n\tprivate void hideMainBarIfNeeded() {\n\t\tif (options.getBoolean(Keys.HIDE_MAIN_BAR, false)) {\n\t\t\tfindViewById(R.id.main_bar).setVisibility(View.GONE);\n\t\t} else {\n\t\t\tfindViewById(R.id.tabs).setVisibility(View.VISIBLE);\n\t\t}\n\t}\n\tpublic void onMyClick(View v) {\n\t\tswitch(v.getId()) {\n\t\t\tcase R.id.searchButton:\n\t\t\t\topenSearch();\n\t\t\t\tbreak;\n\t\t\tcase R.id.category_button:\n\t\t\t\topenCategoriesList();\n\t\t\t\tbreak;\n\t\t\tcase R.id.menuButton:\n\t\t\t\tmenu();\n\t\t\t\tbreak;\n\t\t\tcase R.id.quit_hidden_apps:\n\t\t\t\ttoggleHiddenCategory();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic boolean dispatchTouchEvent(MotionEvent event) {\n\t\tgestureDetector.onTouchEvent(event);\n\t\treturn super.dispatchTouchEvent(event);\n\t}\n\t\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event) {\n\t\tif (event.getAction() != KeyEvent.ACTION_DOWN) {\n\t\t\treturn super.onKeyDown(keyCode, event);\n\t\t}\n\t\tif (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BUTTON_SELECT) {\n\t\t\tmenu();\n\t\t\treturn true;\n\t\t} else if (keyCode == KeyEvent.KEYCODE_INFO || keyCode == KeyEvent.KEYCODE_BUTTON_Y) {\n\t\t\tBaseData item = getFocusedLaunchItem();\n\t\t\tif (item instanceof AppData) {\n\t\t\t\titemContextMenu((AppData) item);\n\t\t\t\treturn true;\n\t\t\t} else if (item instanceof ShortcutData) {\n\t\t\t\titemContextMenu((ShortcutData) item);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_ESCAPE\n\t\t\t|| keyCode == KeyEvent.KEYCODE_BUTTON_B) {\n\t\t\t//Log.v(APP_TAG, \"BACK pressed\");\n\t\t\tif (searchIsOpened) {\n\t\t\t\tcloseSearch();\n\t\t\t} else if (!isDefaultLauncher()) {\n\t\t\t\tfinish();\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif (categories.getCurCategory().equals(CategoryManager.HIDDEN)) {\n\t\t\t\t\tfindViewById(R.id.quit_hidden_apps).setVisibility(View.GONE);\n\t\t\t\t\thideMainBarIfNeeded();\n\t\t\t\t}\n\t\t\t\tcategories.prevCategory();\n\t\t\t}\n\t\t\tloadFilteredApps();\n\t\t\treturn true;\n\t\t} else if (event.isAltPressed()) {\n\t\t\tif (keyCode >= KeyEvent.KEYCODE_1 && keyCode <= KeyEvent.KEYCODE_9) {\n\t\t\t\tObject app = Dock.getApp(keyCode-KeyEvent.KEYCODE_1);\n\t\t\t\tif (app instanceof BaseData && launch((BaseData) app)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (keyCode == KeyEvent.KEYCODE_0 && !searchIsOpened) {\n\t\t\t\topenSearch();\n\t\t\t} else if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) {\n\t\t\t\tcategories.setCurCategory(categories.getCategory(CategoryManager.PREVIOUS));\n\t\t\t\tloadFilteredApps();\n\t\t\t} else if (keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {\n\t\t\t\tcategories.setCurCategory(categories.getCategory(CategoryManager.NEXT));\n\t\t\t\tloadFilteredApps();\n\t\t\t} else if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {\n\t\t\t\topenCategoriesList();\n\t\t\t} else if (keyCode == KeyEvent.KEYCODE_O && !lock) {\n\t\t\t\tstartActivity(new Intent(this, Options.class));\n\t\t\t} else if (keyCode == KeyEvent.KEYCODE_H && !lock) {\n\t\t\t\ttoggleHiddenCategory();\n\t\t\t} else if (keyCode == KeyEvent.KEYCODE_R && !lock) {\n\t\t\t\tif (null != mGetAppsThread)\n\t\t\t\t\tmGetAppsThread.quit();\n\t\t\t\tloadAppsFromSystem(true);\n\t\t\t}\n\t\t} else if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER || keyCode == KeyEvent.KEYCODE_ENTER\n\t\t\t\t||\tkeyCode == KeyEvent.KEYCODE_BUTTON_A || keyCode == KeyEvent.KEYCODE_BUTTON_1) {\n\t\t\tBaseData item = getFocusedLaunchItem();\n\t\t\tif (item != null && launch(item)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {\n\t\t\tif (options.getBoolean(Keys.VOLUME_BUTTONS, false)) {\n\t\t\t\tcategories.setCurCategory(categories.getCategory(CategoryManager.PREVIOUS));\n\t\t\t\tloadFilteredApps();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {\n\t\t\tif (options.getBoolean(Keys.VOLUME_BUTTONS, false)) {\n\t\t\t\tcategories.setCurCategory(categories.getCategory(CategoryManager.NEXT));\n\t\t\t\tloadFilteredApps();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (keyCode == KeyEvent.KEYCODE_BUTTON_L1 || keyCode == KeyEvent.KEYCODE_BUTTON_L2\n\t\t\t\t|| keyCode == KeyEvent.KEYCODE_BUTTON_THUMBL|| keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {\n\t\t\tcategories.setCurCategory(categories.getCategory(CategoryManager.PREVIOUS));\n\t\t\tloadFilteredApps();\n\t\t\treturn true;\n\t\t} else if (keyCode == KeyEvent.KEYCODE_BUTTON_R1 || keyCode == KeyEvent.KEYCODE_BUTTON_R2\n\t\t\t\t|| keyCode == KeyEvent.KEYCODE_BUTTON_THUMBR || keyCode == KeyEvent.KEYCODE_PAGE_UP) {\n\t\t\tcategories.setCurCategory(categories.getCategory(CategoryManager.NEXT));\n\t\t\tloadFilteredApps();\n\t\t\treturn true;\n\t\t} else if (event.isPrintingKey() && !searchIsOpened) {\n\t\t\topenSearch(); // search as you type\n\t\t\tEditText text = findViewById(R.id.textField);\n\t\t\treturn text.onKeyDown(keyCode, event);\n\t\t}\n\t\treturn super.onKeyDown(keyCode, event);\n\t}\n\t\n\t@Override\n\tpublic void onBackPressed() {}\n\t\n\t@Override\n\tprotected void onStop() {\n\t\tsuper.onStop();\n\t}\n\t\n\t@Override\n\tprotected void onPause() {\n\t\t//Log.v(APP_TAG, \"onPause\");\n\t\tsuper.onPause();\n\t\tif (searchIsOpened) {\n\t\t\tcloseSearch();\n\t\t}\n\t}\n\t@Override\n\tprotected void onDestroy() {\n\t\t//Log.v(APP_TAG, \"onDestroy\");\n\t\tgrid.setOnScrollListener(null);\n\t\tgrid.setOnTouchListener(null);\n\t\tgrid.setOnItemClickListener(null);\n\t\tsuper.onDestroy();\n\t}\n\t\n\t@Override\n\tpublic void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tloadFilteredApps();\n\t\t}\n\t}\n\t\n\t@Override\n\tprotected void onNewIntent(Intent i) {\n\t\t//Log.v(APP_TAG, \"onNewIntent\");\n\t\tString action = i.getAction();\n\t\tif (Intent.ACTION_MAIN.equals(action)) {\n\t\t\thandleHomeButtonPress();\n\t\t} else if (ACTION_OPEN_MENU.equals(action)) {\n\t\t\tmenu();\n\t\t}\n\t\t\n\t\tsuper.onNewIntent(i);\n\t}\n\n\tprivate BaseData getFocusedLaunchItem() {\n\t\tView view = getCurrentFocus();\n\t\tif (view instanceof GridView) {\n\t\t\tview = ((GridView) view).getSelectedView();\n\t\t}\n\t\tif (view != null) {\n\t\t\tObject viewTag = view.getTag();\n\t\t\tif (viewTag instanceof BaseData) {\n\t\t\t\treturn (AppData)viewTag;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void handleHomeButtonPress() {\n\t\ttry {\n\t\thomeButtonPressed = true;\n\t\tif (categories == null) {\n\t\t\tcategories = LauncherApp.getCategoryManager();\n\t\t}\n\t\tif (categories.getCurCategory().equals(CategoryManager.HIDDEN)) {\n\t\t\tfindViewById(R.id.quit_hidden_apps).setVisibility(View.GONE);\n\t\t\thideMainBarIfNeeded();\n\t\t\tcategories.setCurCategory(categories.getHome());\n\t\t} else if (categories.getCurCategory().equals(categories.getHome())) {\n\t\t\tString newCategory = options.getString(Keys.HOME_BUTTON, \"\");\n\t\t\tif (newCategory.length() > 0) {\n\t\t\t\tcategories.setCurCategory(newCategory);\n\t\t\t} else {\n\t\t\t\tcategories.setCurCategory(categories.getHome());\n\t\t\t}\n\t\t} else {\n\t\t\tcategories.setCurCategory(categories.getHome());\n\t\t}\n\t\tloadFilteredApps();\n\t\t} catch (Exception e) {\n\t\t\tToast.makeText(this, e.toString(), Toast.LENGTH_LONG).show();\n\t\t}\n\t}\n\n\tprivate void toggleFullscreen(boolean enableFullscreen) {\n\t\tif (options.getBoolean(Keys.FULLSCREEN, false)) {\n\t\t\tif (enableFullscreen) {\n\t\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t\t} else {\n\t\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void toggleHiddenCategory() {\n\t\tif (CategoryManager.HIDDEN.equals(categories.getCurCategory())) {\n\t\t\tcategories.setCurCategory(categories.getHome());\n\t\t\tfindViewById(R.id.quit_hidden_apps).setVisibility(View.GONE);\n\t\t\thideMainBarIfNeeded();\n\t\t} else {\n\t\t\tcategories.setCurCategory(CategoryManager.HIDDEN);\n\t\t\tfindViewById(R.id.searchBar).setVisibility(View.GONE);\n\t\t\tfindViewById(R.id.tabs).setVisibility(View.GONE);\n\t\t\tif (options.getBoolean(Keys.HIDE_MAIN_BAR, false)) {\n\t\t\t\tfindViewById(R.id.main_bar).setVisibility(View.VISIBLE);\n\t\t\t}\n\t\t\tfindViewById(R.id.quit_hidden_apps).setVisibility(View.VISIBLE);\n\t\t}\n\t\tif (searchIsOpened) {\n\t\t\tcloseSearch();\n\t\t}\n\t\tloadFilteredApps();\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\t//Log.v(APP_TAG, \"onCreate\");\n\t\toptions = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tif (options.getBoolean(Keys.FULLSCREEN, false)) {\n\t\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\t}\n\t\tcategories = LauncherApp.getCategoryManager();\n\t\tsuper.onCreate(savedInstanceState);\n\t\tif (Build.VERSION.SDK_INT >= 11) {\n\t\t\tThemer.applyTheme(this, options);\n\t\t\tif (options.getBoolean(Keys.KEEP_IN_MEMORY, false)) {\n\t\t\t\tPersistentNotification.setNotification(this);\n\t\t\t}\n\t\t}\n\t\tif (options.getBoolean(Keys.SHOW_TUTORIAL, true)) {\n\t\t\tstartActivity(new Intent(this, TutorialActivity.class));\n\t\t}\n\t\tif (!DatabaseHelper.hasMenuShortcut(this) && Build.VERSION.SDK_INT < 26) {\n\t\t\taddMenuShortcut();\n\t\t}\n\t\tsetRequestedOrientation(Integer.parseInt(options.getString(Keys.ORIENTATION, \"2\")));\n\t\tif (Build.VERSION.SDK_INT >= 21) {\n\t\t\tThemer.setWindowDecorations(this, options);\n\t\t}\n\t\ttoggleFullscreen(true);\n\t\tsetContentView(MainLayout.get(this, options));\n\t\tgrid = (GridView) findViewById(R.id.appsGrid);\n\t\tadapter = new CustomAdapter(this);\n\t\tgrid.setAdapter(adapter);\n\t\toptions.edit().putBoolean(Keys.MESSAGE_SHOWN, true).commit();\n\t\tif (options.getBoolean(Keys.ICON_PACK_CHANGED, false)) {\n\t\t\tloadAppsFromSystem(true);\n\t\t\toptions.edit().putBoolean(Keys.ICON_PACK_CHANGED, false).commit();\n\t\t}\n\t\tDock.init(this);\n\t\tchangePrefsOnRotate();\n\t\tgestureDetector = new GestureDetector(this, new SwipeListener(this));\n\t\tgrid.setOnTouchListener(new View.OnTouchListener() {\n\t\t\tpublic boolean onTouch(View view, MotionEvent event) {\n\t\t\t\treturn gestureDetector.onTouchEvent(event);\n\t\t\t}\n\t\t});\n\t\tgrid.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {\n\t\t\t\tview.callOnClick();\n\t\t\t}\n\t\t});\n\t}\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\t//Log.v(APP_TAG, \"Menu item is selected\");\n\t\tswitch(item.getItemId()) {\n\t\tcase R.id.full_scan:\n\t\t\tif (null != mGetAppsThread)\n\t\t\t\tmGetAppsThread.quit();\n\t\t\tloadAppsFromSystem(true);\n\t\t\treturn true;\n\t\tcase R.id.change_wallpaper:\n\t\t\tstartActivity(new Intent(Intent.ACTION_SET_WALLPAPER));\n\t\t\treturn true;\n\t\tcase R.id.options:\n\t\t\tstartActivity(new Intent(this, Options.class));\n\t\t\treturn true;\n\t\tcase R.id.access_hidden:\n\t\t\ttoggleHiddenCategory();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tgetMenuInflater().inflate(R.menu.main, menu);\n\t\treturn true;\n\t}\n\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t//Log.v(APP_TAG, \"onResume\");\n\t\t\n\t    lock = options.getString(Keys.PASSWORD, \"\").length() > 0;\n\t    /*if (!homeButtonPressed) {\n\t    \ttry {\n\t    \t\t//loadList(false);\n\t    \t} catch (Exception e) {\n\t    \t\tToast.makeText(Apps.this, e.toString(), Toast.LENGTH_LONG).show();\n\t    \t}\n\t    } else {\n\t    \thomeButtonPressed = false;\n\t    }*/\n\t    if (homeButtonPressed) {\n\t    \thomeButtonPressed = false;\n\t    }\n\t    \n\t\tif (DatabaseHelper.isDatabaseEmpty(this) && !launcherUpdate) {\n\t\t\tloadAppsFromSystem(true);\n\t\t} else {\n\t\t\tloadFilteredApps();\n\t\t}\n\t\t\n\t\tDock.initApps();\n\t\tlauncherUpdate = false;\n\t}\n\t@Override\n\tprotected void onPostResume() {\n\t\tsuper.onPostResume();\n\t\tif (options.getBoolean(Keys.SHOW_KEYBOARD_ON_START, false)) {\n\t\t\tgrid.postDelayed(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\topenSearch();\n\t\t\t\t}\n\t\t\t}, 100);\n\t\t}\n\t}\n}\napp/src/main/java/ru/henridellal/emerald/data/BaseData.java\npublic abstract class BaseData implements Comparable<BaseData> {\n\t//component is a package name\n\tprotected String component;\n\t\n\t//name is app name\n\tprotected String name;\n\n\tpublic String getId() {\n\t\treturn component;\n\t}\n\tpublic static final Comparator<BaseData> NameComparator = \n\t\tnew Comparator<BaseData>() {\n\n\t\tpublic int compare(BaseData a, BaseData b) {\n\t\t\treturn a.name.compareToIgnoreCase(b.name);\n\t\t}\n\t};\n\t\n\t@Override\n\tpublic boolean equals(Object a) {\n\t\tif (! (a instanceof BaseData))\n\t\t\treturn false;\n\t\tif (component == null) {\n\t\t\treturn a == null || ((BaseData)a).component == null;\n\t\t}\n\t\treturn component.equals( ((BaseData)a).component );\n\t}\n\t\n\tpublic BaseData() {}\n\tpublic BaseData(String component, String name) {\n\t\tthis.component = component;\n\t\tthis.name = name;\n\t}\n\n\tpublic String getComponent() {\n\t\treturn this.component;\n\t}\n\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\tpublic void read(BufferedReader reader, String firstLineOfData) {}\n\n\tpublic void write(BufferedWriter reader) throws IOException {\n\t\tthrow new IOException();\n\t}\n\n\tprotected String readLine(BufferedReader reader, String key) throws IOException {\n\t\tString line = reader.readLine();\n\t\tif (line == null || !line.startsWith(key))\n\t\t\tthrow new IOException();\n\t\treturn line;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(BaseData arg0) {\n\t\treturn arg0.name.compareToIgnoreCase(this.name);\n\t}\n\n\tabstract public Intent getLaunchIntent(Context context);\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tif (component == null)\n\t\t\treturn \"NULL null NULL\".hashCode();\n\t\telse\n\t\t\treturn (component).hashCode();\n\t}\n}\n", "answers": ["\t\tint theme = Themer.theme;"], "length": 4819, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "0dc4e35a91336fa30c6d08138f1b924fb6ee8f3390248266"}
{"input": "package com.itranswarp.wxapi.sample.controller;\nimport java.io.IOException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport com.itranswarp.wxapi.event.AbstractEvent;\nimport com.itranswarp.wxapi.message.Message;\nimport com.itranswarp.wxapi.message.Message.MessageBuilder;\nimport com.itranswarp.wxapi.sample.robot.Robot;\nimport com.itranswarp.wxapi.sample.robot.Robot.RobotResponse;\nimport com.itranswarp.wxapi.sample.robot.RobotException;\nimport com.itranswarp.wxapi.message.ReceivedImageMessage;\nimport com.itranswarp.wxapi.message.ReceivedLinkMessage;\nimport com.itranswarp.wxapi.message.ReceivedLocationMessage;\nimport com.itranswarp.wxapi.message.ReceivedShortVideoMessage;\nimport com.itranswarp.wxapi.message.ReceivedTextMessage;\nimport com.itranswarp.wxapi.message.ReceivedVideoMessage;\nimport com.itranswarp.wxapi.message.ReceivedVoiceMessage;\nimport com.itranswarp.wxapi.message.RepliedImageMessage;\nimport com.itranswarp.wxapi.message.RepliedTextMessage;\nimport com.itranswarp.wxapi.message.RepliedVideoMessage;\nimport com.itranswarp.wxapi.message.RepliedVoiceMessage;\nimport com.itranswarp.wxapi.util.XmlUtil;\n\n\n\n\n\n@Controller\npublic class MessageController extends AbstractController {\n\n\t@Autowired\n\tRobot robot;\n\n\t/**\n\t * Response echo message.\n\t * \n\t * @param echoStr\n\t *            Random string sent from weixin.\n\t * @param request\n\t *            The HttpServletRequest object.\n\t * @return The echo string.\n\t */\n\t@RequestMapping(value = \"/wxapi/message\", method = RequestMethod.GET)\n\t@ResponseBody\n\tString token(@RequestParam(value = \"echostr\") String echoStr, HttpServletRequest request) {\n\t\tclient.validateSignature(request);\n\t\treturn echoStr;\n\t}\n\n\tString talk(String userId, String text) throws Exception {\n\t\ttry {\n\t\t\tRobotResponse resp = robot.talk(userId, text);\n\t\t\tif (resp.code == RobotResponse.CODE_TEXT) {\n\t\t\t\treturn resp.text;\n\t\t\t}\n\t\t} catch (RobotException e) {\n\t\t\tlog.warn(\"RobotException: \" + e.getCode(), e);\n\t\t}\n\t\treturn \"亲，听不懂你在说什么 :(\";\n\t}\n\n\t/**\n\t * Receive XML messages sent from weixin.\n\t * \n\t * @param request\n\t * @param response\n\t * @return\n\t * @throws IOException\n\t */\n\t@RequestMapping(value = \"/wxapi/message\", method = RequestMethod.POST, consumes = \"text/xml\", produces = \"text/xml;charset=utf-8\")\n\t@ResponseBody\n\tString onMessageReceived(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tString xml = client.readXml(request);\n\t\tlog.info(\"weixin >>> \" + xml);", "context": "robot/src/main/java/com/itranswarp/wxapi/sample/robot/Robot.java\n@Component\npublic class Robot {\n\n\tstatic final String TULING_URL = \"http://www.tuling123.com/openapi/api\";\n\n\tstatic final Map<String, String> HEADERS = MapUtil.createMap(\"Content-Type\", \"application/json\", \"Authorization\",\n\t\t\t\"token\");\n\n\t@Value(\"${robot.app.key}\")\n\tString apiKey;\n\n\t@Value(\"${robot.app.secret}\")\n\tString apiSecret;\n\n\tpublic RobotResponse talk(String userId, String text) throws Exception {\n\t\treturn talk(userId, text, null);\n\t}\n\n\tpublic RobotResponse talk(String userId, String text, String location) throws Exception {\n\t\tSystem.out.println(\"Key: \" + apiKey + \", Secret: \" + apiSecret);\n\t\tMap<String, String> params = MapUtil.createMap(\"key\", apiKey, \"userid\", HashUtil.md5(userId), \"info\", text);\n\t\tif (location != null && !location.isEmpty()) {\n\t\t\tparams.put(\"loc\", location);\n\t\t}\n\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\t\tString jsonData = JsonUtil.toJson(params);\n\t\tString aesKey = HashUtil.md5(apiSecret + timestamp + apiKey);\n\t\tString encryptedData = aesEncrypt(aesKey, jsonData);\n\t\tMap<String, String> postData = MapUtil.createMap(\"key\", apiKey, \"timestamp\", timestamp, \"data\", encryptedData);\n\t\tString json = HttpUtil.httpPost(TULING_URL, JsonUtil.toJson(postData), HEADERS);\n\t\tRobotResponse resp = JsonUtil.fromJson(RobotResponse.class, json);\n\t\tif (resp.code >= 40000 && resp.code <= 49999) {\n\t\t\tthrow new RobotException(resp.code, resp.text);\n\t\t}\n\t\treturn resp;\n\t}\n\n\tString aesEncrypt(String aesKey, String data) throws GeneralSecurityException {\n\t\tKey key = new SecretKeySpec(getHash(aesKey), \"AES\");\n\t\tIvParameterSpec iv = new IvParameterSpec(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });\n\t\tCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\t\tcipher.init(Cipher.ENCRYPT_MODE, key, iv);\n\t\tbyte[] encryptData = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));\n\t\treturn Base64.getEncoder().encodeToString(encryptData);\n\t}\n\n\tbyte[] getHash(String s) throws GeneralSecurityException {\n\t\tbyte[] data = s.getBytes(StandardCharsets.UTF_8);\n\t\tMessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\tdigest.update(data);\n\t\treturn digest.digest();\n\t}\n\n\tpublic static class RobotResponse {\n\n\t\tpublic static int CODE_TEXT = 100000;\n\t\tpublic static int CODE_LINK = 200000;\n\t\tpublic static int CODE_NEWS = 302000;\n\t\tpublic static int CODE_COOK = 308000;\n\t\tpublic static int CODE_SONG = 313000;\n\t\tpublic static int CODE_POEM = 314000;\n\n\t\tpublic int code;\n\t\tpublic String text;\n\t\tpublic String url;\n\t\tpublic Item[] list;\n\t\tpublic Func function;\n\t}\n\n\tpublic static class Item {\n\t\tpublic String article;\n\t\tpublic String source;\n\t\tpublic String icon;\n\t\tpublic String info;\n\t\tpublic String detailurl;\n\t}\n\n\tpublic static class Func {\n\t\tpublic String song;\n\t\tpublic String singer;\n\t\tpublic String author;\n\t\tpublic String name;\n\t}\n\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/ReceivedTextMessage.java\npublic class ReceivedTextMessage extends AbstractReceivedMessage {\n\n\tpublic final String MsgType = Message.TYPE_TEXT;\n\n\tpublic final String Content;\n\n\tReceivedTextMessage(long CreateTime, String FromUserName, String ToUserName, long MsgId, String Content) {\n\t\tsuper(CreateTime, FromUserName, ToUserName, MsgId);\n\t\tthis.Content = Content;\n\t}\n\n}\nwxapi/src/main/java/com/itranswarp/wxapi/util/XmlUtil.java\npublic class XmlUtil {\n\n\tpublic static String toXml(Object o) {\n\t\tXmlMapper mapper = new XmlMapper();\n\t\ttry {\n\t\t\treturn mapper.writeValueAsString(o);\n\t\t} catch (JsonProcessingException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static String toXml(Object o, String rootName) {\n\t\tXmlMapper mapper = new XmlMapper();\n\t\ttry {\n\t\t\treturn mapper.writer().withRootName(rootName).writeValueAsString(o);\n\t\t} catch (JsonProcessingException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static <T> T fromXml(Class<T> clazz, String s) {\n\t\tXmlMapper mapper = new XmlMapper();\n\t\tmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\t\ttry {\n\t\t\treturn mapper.readValue(s, clazz);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/ReceivedVideoMessage.java\npublic class ReceivedVideoMessage extends AbstractReceivedMessage {\n\n\tpublic final String MsgType = Message.TYPE_VIDEO;\n\n\tpublic final String MediaId;\n\n\tpublic final String ThumbMediaId;\n\n\tReceivedVideoMessage(long CreateTime, String FromUserName, String ToUserName, long MsgId, String MediaId,\n\t\t\tString ThumbMediaId) {\n\t\tsuper(CreateTime, FromUserName, ToUserName, MsgId);\n\t\tthis.MediaId = MediaId;\n\t\tthis.ThumbMediaId = ThumbMediaId;\n\t}\n\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/ReceivedShortVideoMessage.java\npublic class ReceivedShortVideoMessage extends AbstractReceivedMessage {\n\n\tpublic final String MsgType = Message.TYPE_SHORT_VIDEO;\n\n\tpublic final String MediaId;\n\n\tpublic final String ThumbMediaId;\n\n\tReceivedShortVideoMessage(long CreateTime, String FromUserName, String ToUserName, long MsgId, String MediaId,\n\t\t\tString ThumbMediaId) {\n\t\tsuper(CreateTime, FromUserName, ToUserName, MsgId);\n\t\tthis.MediaId = MediaId;\n\t\tthis.ThumbMediaId = ThumbMediaId;\n\t}\n\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/RepliedImageMessage.java\npublic class RepliedImageMessage extends AbstractRepliedMessage {\n\n\tpublic final Image Image;\n\n\tpublic RepliedImageMessage(String FromUserName, String ToUserName, String MediaId) {\n\t\tsuper(Message.TYPE_IMAGE, FromUserName, ToUserName);\n\t\tthis.Image = new Image(MediaId);\n\t}\n\n\tpublic static class Image {\n\n\t\tpublic final String MediaId;\n\n\t\tpublic Image(String mediaId) {\n\t\t\tMediaId = mediaId;\n\t\t}\n\t}\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/ReceivedImageMessage.java\npublic class ReceivedImageMessage extends AbstractReceivedMessage {\n\n\tpublic final String MsgType = Message.TYPE_IMAGE;\n\n\tpublic final String PicUrl;\n\n\tpublic final String MediaId;\n\n\tReceivedImageMessage(long CreateTime, String FromUserName, String ToUserName, long MsgId, String PicUrl,\n\t\t\tString MediaId) {\n\t\tsuper(CreateTime, FromUserName, ToUserName, MsgId);\n\t\tthis.PicUrl = PicUrl;\n\t\tthis.MediaId = MediaId;\n\t}\n\n}\nrobot/src/main/java/com/itranswarp/wxapi/sample/robot/Robot.java\npublic static class RobotResponse {\n\n\tpublic static int CODE_TEXT = 100000;\n\tpublic static int CODE_LINK = 200000;\n\tpublic static int CODE_NEWS = 302000;\n\tpublic static int CODE_COOK = 308000;\n\tpublic static int CODE_SONG = 313000;\n\tpublic static int CODE_POEM = 314000;\n\n\tpublic int code;\n\tpublic String text;\n\tpublic String url;\n\tpublic Item[] list;\n\tpublic Func function;\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/RepliedTextMessage.java\npublic class RepliedTextMessage extends AbstractRepliedMessage {\n\n\tpublic final String Content;\n\n\tpublic RepliedTextMessage(String FromUserName, String ToUserName, String Content) {\n\t\tsuper(Message.TYPE_TEXT, FromUserName, ToUserName);\n\t\tthis.Content = Content;\n\t}\n\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/ReceivedLinkMessage.java\npublic class ReceivedLinkMessage extends AbstractReceivedMessage {\n\n\tpublic final String MsgType = Message.TYPE_LINK;\n\n\tpublic final String Url;\n\n\tpublic final String Title;\n\n\tpublic final String Description;\n\n\tReceivedLinkMessage(long CreateTime, String FromUserName, String ToUserName, long MsgId, String Url, String Title,\n\t\t\tString Description) {\n\t\tsuper(CreateTime, FromUserName, ToUserName, MsgId);\n\t\tthis.Url = Url;\n\t\tthis.Title = Title;\n\t\tthis.Description = Description;\n\t}\n\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/RepliedVoiceMessage.java\npublic class RepliedVoiceMessage extends AbstractRepliedMessage {\n\n\tpublic final Voice Voice;\n\n\tpublic RepliedVoiceMessage(String FromUserName, String ToUserName, String MediaId) {\n\t\tsuper(Message.TYPE_VOICE, FromUserName, ToUserName);\n\t\tthis.Voice = new Voice(MediaId);\n\t}\n\n\tpublic static class Voice {\n\n\t\tpublic final String MediaId;\n\n\t\tpublic Voice(String mediaId) {\n\t\t\tMediaId = mediaId;\n\t\t}\n\t}\n}\nwxapi/src/main/java/com/itranswarp/wxapi/event/AbstractEvent.java\npublic abstract class AbstractEvent {\n\n\tpublic static final String EVENT_SUBSCRIBE = \"subscribe\";\n\tpublic static final String EVENT_UNSUBSCRIBE = \"unsubscribe\";\n\tpublic static final String EVENT_SCAN = \"SCAN\";\n\n\tpublic final long CreateTime;\n\n\tpublic final String FromUserName;\n\n\tpublic final String ToUserName;\n\n\tpublic final String Event;\n\n\tAbstractEvent(long CreateTime, String FromUserName, String ToUserName, String Event) {\n\t\tthis.CreateTime = CreateTime;\n\t\tthis.FromUserName = FromUserName;\n\t\tthis.ToUserName = ToUserName;\n\t\tthis.Event = Event;\n\t}\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/Message.java\npublic static class MessageBuilder {\n\tfinal String FromUserName;\n\tfinal String ToUserName;\n\n\tMessageBuilder(String FromUserName, String ToUserName) {\n\t\tthis.FromUserName = FromUserName;\n\t\tthis.ToUserName = ToUserName;\n\t}\n\n\tpublic RepliedTextMessage toTextMessage(String Content) {\n\t\treturn new RepliedTextMessage(FromUserName, ToUserName, Content);\n\t}\n\n\tpublic RepliedImageMessage toImageMessage(String MediaId) {\n\t\treturn new RepliedImageMessage(FromUserName, ToUserName, MediaId);\n\t}\n\n\tpublic RepliedVoiceMessage toVoiceMessage(String MediaId) {\n\t\treturn new RepliedVoiceMessage(FromUserName, ToUserName, MediaId);\n\t}\n\n\tpublic RepliedVideoMessage toVideoMessage(String MediaId, String Title, String Description) {\n\t\treturn new RepliedVideoMessage(FromUserName, ToUserName, MediaId, Title, Description);\n\t}\n\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/ReceivedLocationMessage.java\npublic class ReceivedLocationMessage extends AbstractReceivedMessage {\n\n\tpublic final String MsgType = Message.TYPE_LOCATION;\n\n\tpublic final String Label;\n\n\tpublic final double Location_X;\n\n\tpublic final double Location_Y;\n\n\tpublic final long Scale;\n\n\tReceivedLocationMessage(long CreateTime, String FromUserName, String ToUserName, long MsgId, String Label,\n\t\t\tdouble Location_X, double Location_Y, long Scale) {\n\t\tsuper(CreateTime, FromUserName, ToUserName, MsgId);\n\t\tthis.Label = Label;\n\t\tthis.Location_X = Location_X;\n\t\tthis.Location_Y = Location_Y;\n\t\tthis.Scale = Scale;\n\t}\n\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/Message.java\npublic class Message {\n\n\tstatic final String TYPE_TEXT = \"text\";\n\n\tstatic final String TYPE_IMAGE = \"image\";\n\n\tstatic final String TYPE_VOICE = \"voice\";\n\n\tstatic final String TYPE_VIDEO = \"video\";\n\n\tstatic final String TYPE_SHORT_VIDEO = \"shortvideo\";\n\n\tstatic final String TYPE_LOCATION = \"location\";\n\n\tstatic final String TYPE_LINK = \"link\";\n\n\tstatic final String TYPE_EVENT = \"event\";\n\n\tstatic final String EVENT_SUBSCRIBE = \"subscribe\";\n\n\tpublic String ToUserName;\n\n\tpublic String FromUserName;\n\n\tpublic long CreateTime;\n\n\tpublic String MsgType;\n\n\tpublic long MsgId;\n\n\t// for text message:\n\tpublic String Content;\n\n\t// for image message:\n\tpublic String PicUrl;\n\n\t// for image / voice / video / short video message:\n\tpublic String MediaId;\n\n\t// for voice message:\n\tpublic String Format;\n\n\tpublic String Recognition;\n\n\t// for video / short video message:\n\tpublic String ThumbMediaId;\n\n\t// for location message:\n\tpublic String Label;\n\n\tpublic double Location_X;\n\n\tpublic double Location_Y;\n\n\tpublic long Scale;\n\n\t// for link message:\n\tpublic String Url;\n\n\tpublic String Title;\n\n\tpublic String Description;\n\n\t// for event:\n\tpublic String Event;\n\n\tpublic String EventKey;\n\n\tpublic String Ticket;\n\n\tpublic double Latitude;\n\n\tpublic double Longitude;\n\n\tpublic double Precision;\n\n\tpublic boolean isTextMessage() {\n\t\treturn TYPE_TEXT.equals(this.MsgType);\n\t}\n\n\tpublic boolean isImageMessage() {\n\t\treturn TYPE_IMAGE.equals(this.MsgType);\n\t}\n\n\tpublic boolean isVoiceMessage() {\n\t\treturn TYPE_VOICE.equals(this.MsgType);\n\t}\n\n\tpublic boolean isVideoMessage() {\n\t\treturn TYPE_VIDEO.equals(this.MsgType);\n\t}\n\n\tpublic boolean isShortVideoMessage() {\n\t\treturn TYPE_SHORT_VIDEO.equals(this.MsgType);\n\t}\n\n\tpublic boolean isLocationMessage() {\n\t\treturn TYPE_LOCATION.equals(this.MsgType);\n\t}\n\n\tpublic boolean isLinkMessage() {\n\t\treturn TYPE_LINK.equals(this.MsgType);\n\t}\n\n\tpublic boolean isEvent() {\n\t\treturn TYPE_EVENT.equals(this.MsgType);\n\t}\n\n\t/**\n\t * 把消息转换为相应的事件类型\n\t * \n\t * @return AbstractEvent的子类\n\t */\n\tpublic AbstractEvent asEvent() {\n\t\tif (isEvent()) {\n\t\t\tswitch (this.Event) {\n\t\t\tcase AbstractEvent.EVENT_SUBSCRIBE:\n\t\t\t\treturn new SubscribeEvent(CreateTime, FromUserName, ToUserName, Event, EventKey, Ticket);\n\t\t\tcase AbstractEvent.EVENT_UNSUBSCRIBE:\n\t\t\t\treturn new UnsubscribeEvent(CreateTime, FromUserName, ToUserName, Event, EventKey, Ticket);\n\t\t\tcase AbstractEvent.EVENT_SCAN:\n\t\t\t\treturn new ScanEvent(CreateTime, FromUserName, ToUserName, Event, EventKey, Ticket);\n\t\t\tdefault:\n\t\t\t\tthrow new WeixinMessageException(\"Cannot handle new type of event from \" + this);\n\t\t\t}\n\t\t}\n\t\tthrow new WeixinMessageException(\"Cannot cast to event from \" + this);\n\t}\n\n\t/**\n\t * 把消息转换为文本消息\n\t * \n\t * @return ReceivedTextMessage\n\t */\n\tpublic ReceivedTextMessage asTextMessage() {\n\t\tif (isTextMessage()) {\n\t\t\treturn new ReceivedTextMessage(CreateTime, FromUserName, ToUserName, MsgId, Content);\n\t\t}\n\t\tthrow new WeixinMessageException(\"Cannot cast to text message from \" + this);\n\t}\n\n\t/**\n\t * 把消息转换为图片消息\n\t * \n\t * @return ReceivedImageMessage\n\t */\n\tpublic ReceivedImageMessage asImageMessage() {\n\t\tif (isImageMessage()) {\n\t\t\treturn new ReceivedImageMessage(CreateTime, FromUserName, ToUserName, MsgId, PicUrl, MediaId);\n\t\t}\n\t\tthrow new WeixinMessageException(\"Cannot cast to image message from \" + this);\n\t}\n\n\t/**\n\t * 把消息转换为语音消息\n\t * \n\t * @return ReceivedVoiceMessage\n\t */\n\tpublic ReceivedVoiceMessage asVoiceMessage() {\n\t\tif (isVoiceMessage()) {\n\t\t\treturn new ReceivedVoiceMessage(CreateTime, FromUserName, ToUserName, MsgId, MediaId, Format, Recognition);\n\t\t}\n\t\tthrow new WeixinMessageException(\"Cannot cast to voice message from \" + this);\n\t}\n\n\t/**\n\t * 把消息转换为视频消息\n\t * \n\t * @return ReceivedVideoMessage\n\t */\n\tpublic ReceivedVideoMessage asVideoMessage() {\n\t\tif (isVideoMessage()) {\n\t\t\treturn new ReceivedVideoMessage(CreateTime, FromUserName, ToUserName, MsgId, MediaId, ThumbMediaId);\n\t\t}\n\t\tthrow new WeixinMessageException(\"Cannot cast to video message from \" + this);\n\t}\n\n\t/**\n\t * 把消息转换为小视频消息\n\t * \n\t * @return ReceivedShortVideoMessage\n\t */\n\tpublic ReceivedShortVideoMessage asShortVideoMessage() {\n\t\tif (isShortVideoMessage()) {\n\t\t\treturn new ReceivedShortVideoMessage(CreateTime, FromUserName, ToUserName, MsgId, MediaId, ThumbMediaId);\n\t\t}\n\t\tthrow new WeixinMessageException(\"Cannot cast to short video message from \" + this);\n\t}\n\n\t/**\n\t * 把消息转换为位置消息\n\t * \n\t * @return ReceivedLocationMessage\n\t */\n\tpublic ReceivedLocationMessage asLocationMessage() {\n\t\tif (isLocationMessage()) {\n\t\t\treturn new ReceivedLocationMessage(CreateTime, FromUserName, ToUserName, MsgId, Label, Location_X,\n\t\t\t\t\tLocation_Y, Scale);\n\t\t}\n\t\tthrow new WeixinMessageException(\"Cannot cast to location message from \" + this);\n\t}\n\n\t/**\n\t * 把消息转换为链接消息\n\t * \n\t * @return ReceivedLinkMessage\n\t */\n\tpublic ReceivedLinkMessage asLinkMessage() {\n\t\tif (isLinkMessage()) {\n\t\t\treturn new ReceivedLinkMessage(CreateTime, FromUserName, ToUserName, MsgId, Url, Title, Description);\n\t\t}\n\t\tthrow new WeixinMessageException(\"Cannot cast to link message from \" + this);\n\t}\n\n\t/**\n\t * 创建一个MessageBuilder对象\n\t * \n\t * @param FromUserName\n\t *            发送方\n\t * @param ToUserName\n\t *            接收方\n\t * @return MessageBuilder\n\t */\n\tpublic static MessageBuilder buildMessage(String FromUserName, String ToUserName) {\n\t\treturn new MessageBuilder(FromUserName, ToUserName);\n\t}\n\n\tpublic String toString() {\n\t\treturn \"<Message: MsgType=\" + this.MsgType + \", MsgId=\" + this.MsgId + \">\";\n\t}\n\n\tpublic static class MessageBuilder {\n\t\tfinal String FromUserName;\n\t\tfinal String ToUserName;\n\n\t\tMessageBuilder(String FromUserName, String ToUserName) {\n\t\t\tthis.FromUserName = FromUserName;\n\t\t\tthis.ToUserName = ToUserName;\n\t\t}\n\n\t\tpublic RepliedTextMessage toTextMessage(String Content) {\n\t\t\treturn new RepliedTextMessage(FromUserName, ToUserName, Content);\n\t\t}\n\n\t\tpublic RepliedImageMessage toImageMessage(String MediaId) {\n\t\t\treturn new RepliedImageMessage(FromUserName, ToUserName, MediaId);\n\t\t}\n\n\t\tpublic RepliedVoiceMessage toVoiceMessage(String MediaId) {\n\t\t\treturn new RepliedVoiceMessage(FromUserName, ToUserName, MediaId);\n\t\t}\n\n\t\tpublic RepliedVideoMessage toVideoMessage(String MediaId, String Title, String Description) {\n\t\t\treturn new RepliedVideoMessage(FromUserName, ToUserName, MediaId, Title, Description);\n\t\t}\n\n\t}\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/ReceivedVoiceMessage.java\npublic class ReceivedVoiceMessage extends AbstractReceivedMessage {\n\n\tpublic final String MsgType = Message.TYPE_VOICE;\n\n\tpublic final String MediaId;\n\n\tpublic final String Format;\n\n\tpublic final String Recognition;\n\n\tpublic ReceivedVoiceMessage(long CreateTime, String FromUserName, String ToUserName, long MsgId, String MediaId,\n\t\t\tString Format, String Recognition) {\n\t\tsuper(CreateTime, FromUserName, ToUserName, MsgId);\n\t\tthis.MediaId = MediaId;\n\t\tthis.Format = Format;\n\t\tthis.Recognition = Recognition;\n\t}\n\n}\nrobot/src/main/java/com/itranswarp/wxapi/sample/robot/RobotException.java\npublic class RobotException extends RuntimeException {\n\n\tprivate int code = 0;\n\n\tpublic int getCode() {\n\t\treturn code;\n\t}\n\n\tpublic RobotException() {\n\t\tsuper();\n\t}\n\n\tpublic RobotException(int code) {\n\t\tsuper();\n\t\tthis.code = code;\n\t}\n\n\tpublic RobotException(int code, String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t\tthis.code = code;\n\t}\n\n\tpublic RobotException(int code, String message) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t}\n\n\tpublic RobotException(int code, Throwable cause) {\n\t\tsuper(cause);\n\t\tthis.code = code;\n\t}\n\n\tpublic RobotException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic RobotException(String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic RobotException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n}\nwxapi/src/main/java/com/itranswarp/wxapi/message/RepliedVideoMessage.java\npublic class RepliedVideoMessage extends AbstractRepliedMessage {\n\n\tpublic final Video Video;\n\n\tpublic RepliedVideoMessage(String FromUserName, String ToUserName, String MediaId, String Title,\n\t\t\tString Description) {\n\t\tsuper(Message.TYPE_VIDEO, FromUserName, ToUserName);\n\t\tthis.Video = new Video(MediaId, Title, Description);\n\t}\n\n\tpublic static class Video {\n\n\t\tpublic final String MediaId;\n\t\tpublic final String Title;\n\t\tpublic final String Description;\n\n\t\tpublic Video(String MediaId, String Title, String Description) {\n\t\t\tthis.MediaId = MediaId;\n\t\t\tthis.Title = Title;\n\t\t\tthis.Description = Description;\n\t\t}\n\t}\n}\n", "answers": ["\t\tMessage msg = XmlUtil.fromXml(Message.class, xml);"], "length": 2116, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "2765e9a5cf94efddee7fc7b1f7ccf2e8ee97cf3bf122dbb0"}
{"input": "import os\nimport shutil\nimport MobSF.settings as SETTINGS\nimport json\nimport signal\nimport subprocess\nimport threading\nimport time\nimport traceback\nfrom DynamicAnalyzer.pyWebProxy.pywebproxy import Proxy\nfrom DynamicAnalyzer.views.android.android_avd import avd_load_wait\nfrom DynamicAnalyzer.views.android.android_avd import refresh_avd\nfrom DynamicAnalyzer.views.android.android_dyn_shared import connect\nfrom DynamicAnalyzer.views.android.android_dyn_shared import install_and_run\nfrom DynamicAnalyzer.views.android.android_dyn_shared import web_proxy\nfrom DynamicAnalyzer.views.android.android_dyn_shared import get_identifier\nfrom DynamicAnalyzer.views.android.android_virtualbox_vm import refresh_vm\nfrom mass_static_analysis import genMD5\nfrom MobSF.utils import getADB\nfrom StaticAnalyzer.views.android.manifest_analysis import get_manifest\nfrom StaticAnalyzer.views.android.manifest_analysis import manifest_data as get_manifest_data\nfrom StaticAnalyzer.views.shared_func import Unzip\nfrom Analysis_x_logcat.analysis import analysis_x_logcat\n    captureDispatchPointer(0,0,0,{screen_x_middle},300,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},300,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,0,{screen_x_middle},400,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},400,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,0,{screen_x_middle},500,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},500,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,0,{screen_x_middle},600,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},600,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,0,{screen_x_middle},700,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},700,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,0,{screen_x_middle},800,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},800,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,0,{screen_x_middle},900,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},900,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,0,{screen_x_middle},1000,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},1000,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,0,{screen_x_middle},1100,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},1100,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,0,{screen_x_middle},1200,1,1,-1,1,1,0,0)\n    captureDispatchPointer(0,0,1,{screen_x_middle},1200,1,1,-1,1,1,0,0)\n    UserWait(1000)\n    captureDispatchPress(4)\n    captureDispatchPress(4)\n    captureDispatchPress(4)\n    '''\n    drag_wait = 750\n    packagename = app_info['packagename']\n    mainactivity = app_info['mainactivity']\n    if mainactivity.startswith('.'):\n        mainactivity = packagename + mainactivity\n    screen_x_right = 750\n    screen_y_middle = 640\n    screen_x_left = 50\n    screen_x_middle = 400\n    \n    monkey_script_data = monkey_script_pattern.format(drag_wait=drag_wait, \n        packagename=packagename, mainactivity=mainactivity, \n        screen_x_right=screen_x_right, screen_y_middle=screen_y_middle, \n        screen_x_left=screen_x_left, screen_x_middle=screen_x_middle)\n    \n    monkey_script_file_name = os.path.join(os.path.join(UPLOAD_DIR, app_info['file_md5']), 'monkey_script.txt')\n    with open(monkey_script_file_name, 'w') as f:\n        f.write(monkey_script_data)\n    \n    subprocess.call([adb,\n                     \"-s\",\n                     get_identifier(),\n                     \"push\",\n                     monkey_script_file_name,\n                     \"/data/local/tmp\"])\n    subprocess.call([adb,\n                     \"-s\",\n                     get_identifier(),\n                     \"shell\",\n                     \"monkey\", \"-f\", \n                     \"/data/local/tmp/monkey_script.txt\", \"1\"])\n    print u'\\n[INFO] 跳过初始化界面'\n    return\n\ndef auto_app_test(adb, app_info):\n    print u'\\n[INFO] 开始自动化测试...'\n    \n    # monkey script 测试，用于进入初始化界面\n    monkey_script_test(adb, app_info)\n    \n    packagename = app_info['packagename']\n    # monkey 测试，输出太多，重定向输出\n    p = subprocess.Popen([adb, '-s', get_identifier(), 'shell', \n                'monkey', '-p', packagename, \n                '--ignore-crashes', '--ignore-timeouts', \n                '--monitor-native-crashes', \n                '-v', '-v', '-v', '1000'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    # 设置超时检查\n    start_time = time.time()\n    while True:\n        if p.poll() is not None:\n            #useless_out, useless_err = p.communicate()\n            break\n        if time.time() - start_time > 60:\n            p.terminate()\n            break\n        time.sleep(0.5)\n    \n    # TODO: 添加其他测试方法\n    return\n\ndef download_logs(adb, download_dir):\n    subprocess.call([adb,\n                     \"-s\",\n                     get_identifier(),\n                     \"pull\",\n                     \"/data/data/de.robv.android.xposed.installer/log/error.log\",\n                     download_dir + \"x_logcat_temp.txt\"])\n    print \"\\n[INFO] Downloading Droidmon API Monitor Logcat logs\"\n    # TODO: 下载其他有用文件\n    return\n\nIs_Downloading = True\ndef download_logs_thread(adb, download_dir):\n    if not os.path.isdir(download_dir):\n        os.makedirs(download_dir)\n    global Is_Downloading\n    while Is_Downloading:\n        download_logs(adb, download_dir)\n        log_path = os.path.join(download_dir, 'x_logcat.txt')\n        log_temp_path = os.path.join(download_dir, 'x_logcat_temp.txt')\n        if os.path.exists(log_path):\n            log_size = os.path.getsize(log_path)\n            log_temp_size = os.path.getsize(log_temp_path)\n            if log_size < log_temp_size:\n                shutil.copy(log_temp_path, log_path)\n        else:\n            shutil.copy(log_temp_path, log_path)\n        os.remove(log_temp_path)\n        time.sleep(10)\n    return\n\n# 运行该 apk 文件，获取运行时特征并存储在 '该文件路径' + '_info_/' 目录中，\n# 因此调用该函数时需要先检查以上目录是否存在，如果存在则认为已经运行过该 apk 文件。\ndef dynamic_main(file_path):\n", "context": "mass_static_analysis.py\ndef genMD5(app):\n\n    BLOCKSIZE = 65536\n    hasher = hashlib.md5()\n    with open(app, 'rb') as afile:\n        buf = afile.read(BLOCKSIZE)\n        while buf:\n            hasher.update(buf)\n            buf = afile.read(BLOCKSIZE)\n    return (hasher.hexdigest())\nDynamicAnalyzer/views/android/android_avd.py\ndef avd_load_wait(adb):\n    \"\"\"Wait for AVD Load\"\"\"\n    try:\n        emulator = get_identifier()\n\n        print \"[INFO] Wait for emulator to load\"\n        args = [adb,\n                \"-s\",\n                emulator,\n                \"wait-for-device\"]\n        subprocess.call(args)\n\n        print \"[INFO] Wait for dev.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"dev.bootcomplete\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"1\":\n                break\n            else:\n                time.sleep(1)\n\n        print \"[INFO] Wait for sys.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"sys.boot_completed\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"1\":\n                break\n            else:\n                time.sleep(1)\n\n        print \"[INFO] Wait for svc.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"init.svc.bootanim\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"stopped\":\n                break\n            else:\n                time.sleep(1)\n        time.sleep(5)\n        # Remount the partitions for RW\n        subprocess.call([adb, \"-s\", emulator, \"remount\"])\n        return True\n    except:\n        PrintException(\"[ERROR] emulator did not boot properly\")\n        return False\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef install_and_run(toolsdir, apk_path, package, launcher, is_activity):\n    \"\"\"Install APK and Run it\"\"\"\n    print \"\\n[INFO] Starting App for Dynamic Analysis\"\n    # try:\n    adb = getADB(toolsdir)\n    print \"\\n[INFO] Installing APK\"\n    install_result = subprocess.check_output([adb, \"-s\", get_identifier(),\n                     \"install\", \"-r\", apk_path])\n    print install_result\n    # 如果是未签名的错误，则对其进行签名并安装，\n    # 签名命令示例：jarsigner -verbose -keystore davidblus_android.keystore -storepass davidblus -signedjar app_signed.apk app.apk davidblus_android.keystore\n    if 'INSTALL_PARSE_FAILED_NO_CERTIFICATES' in install_result:\n        signed_apk_path = sign_apk(apk_path)\n        install_result = subprocess.check_output([adb, \"-s\", get_identifier(),\n                         \"install\", \"-r\", signed_apk_path])\n        print install_result\n    if 'Success' not in install_result:\n        raise Exception('Install Error')\n    if is_activity:\n        run_app = package + \"/\" + launcher\n        print \"\\n[INFO] Launching APK Main Activity\"\n        subprocess.call([adb, \"-s\", get_identifier(),\n                         \"shell\", \"am\", \"start\", \"-n\", run_app])\n    else:\n        print \"\\n[INFO] App Doesn't have a Main Activity\"\n        # Handle Service or Give Choice to Select in Future.\n    print \"[INFO] Testing Environment is Ready!\"\n    # except:\n    #     PrintException(\"[ERROR]  Starting App for Dynamic Analysis\")\nStaticAnalyzer/views/shared_func.py\ndef Unzip(APP_PATH, EXT_PATH):\n    print \"[INFO] Unzipping\"\n    try:\n        files = []\n        with zipfile.ZipFile(APP_PATH, \"r\") as z:\n            for fileinfo in z.infolist():\n                filename = fileinfo.filename\n                if not isinstance(filename, unicode):\n                    filename = unicode(filename, encoding=\"utf-8\", errors=\"replace\")\n                files.append(filename)\n                z.extract(fileinfo, EXT_PATH)\n        return files\n    except:\n        PrintException(\"[ERROR] Unzipping Error\")\n        if platform.system() == \"Windows\":\n            print \"\\n[INFO] Not yet Implemented.\"\n            return files\n        else:\n            print \"\\n[INFO] Using the Default OS Unzip Utility.\"\n            try:\n                subprocess.call(\n                    ['unzip', '-o', '-q', APP_PATH, '-d', EXT_PATH])\n                dat = subprocess.check_output(['unzip', '-qq', '-l', APP_PATH])\n                dat = dat.split('\\n')\n                x = ['Length   Date   Time   Name']\n                x = x + dat\n                return x\n            except:\n                PrintException(\"[ERROR] Unzipping Error\")\nStaticAnalyzer/views/android/manifest_analysis.py\ndef get_manifest(app_dir, tools_dir, typ, binary):\n    \"\"\"Get the manifest file.\"\"\"\n    dat = read_manifest(app_dir, tools_dir, typ, binary).replace(\"\\n\", \"\")\n    # changed by davidblus\n    new_AndroidManifest = os.path.join(app_dir, 'new_AndroidManifest.xml')\n    with open(new_AndroidManifest, 'w') as file:\n        file.write(dat)\n        \n    try:\n        manifest = minidom.parseString(dat)\n    except Exception as err:\n        try:\n            dat_windows = dat.decode('gb2312', 'ignore')\n            manifest = minidom.parseString(dat_windows)\n        except Exception as err:\n            try:\n                apktool = os.path.join(os.path.join(tools_dir, 'apktool2.2.4'), 'apktool')\n                apktool_dir = os.path.join(app_dir, 'apktool')\n                app_apk = os.path.join(app_dir, 'app.apk')\n                cmd_list = [apktool, \"d\", \"-o\", apktool_dir, \"-s\", app_apk]\n                print cmd_list\n                if platform.system() == 'Windows':\n                    temp = subprocess.call(cmd_list, shell=True)\n                else:\n                    temp = subprocess.call(cmd_list)\n                with open(os.path.join(apktool_dir, 'AndroidManifest.xml')) as fp:\n                    dat = fp.read()\n                manifest = minidom.parseString(dat)\n            except Exception as err:\n                print traceback.format_exc()\n                raise Exception('Parsing Manifest Error')\n            \n    return manifest\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef connect(toolsdir):\n    \"\"\"Connect to VM/Device\"\"\"\n    print \"\\n[INFO] Connecting to VM/Device\"\n    try:\n        adb = getADB(toolsdir)\n        subprocess.call([adb, \"kill-server\"])\n        subprocess.call([adb, \"start-server\"])\n        print \"\\n[INFO] ADB Started\"\n        wait(5)\n        print \"\\n[INFO] Connecting to VM/Device\"\n        result = subprocess.call([adb, \"connect\", get_identifier()])\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\" and result != 0:\n            subprocess.call([adb, \"tcpip\", str(settings.DEVICE_ADB_PORT)])\n            subprocess.call([adb, \"connect\", get_identifier()])\n        subprocess.call([adb, \"-s\", get_identifier(), \"wait-for-device\"])\n        print \"\\n[INFO] Mounting\"\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\",\n                             \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"])\n        else:\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\",\n                             \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"])\n            # This may not work for VMs other than the default MobSF VM\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\", \"mount\",\n                             \"-o\", \"rw,remount\", \"-t\", \"rfs\", \"/dev/block/sda6\", \"/system\"])\n    except:\n        print traceback.format_exc()\n        PrintException(\"[ERROR]  Connecting to VM/Device\")\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef web_proxy(apk_dir, ip_address, port):\n    \"\"\"Run MITM Proxy\"\"\"\n    print \"\\n[INFO] Starting Web Proxy\"\n    try:\n        Proxy(ip_address, port, apk_dir, \"on\")\n    except:\n        PrintException(\"[ERROR] Starting Web Proxy\")\nDynamicAnalyzer/views/android/android_virtualbox_vm.py\ndef refresh_vm(uuid, snapshot_uuid, vbox_exe):\n    \"\"\"Refresh VirtualBox based VMs\"\"\"\n    print \"\\n[INFO] Refreshing MobSF VM\"\n    try:\n        # Close VM\n        args = [vbox_exe, 'controlvm', uuid, 'poweroff']\n        subprocess.call(args)\n        # changed by davidblus\n        time.sleep(2)\n        print \"\\n[INFO] VM Closed\"\n        # Restore Snapshot\n        args = [vbox_exe, 'snapshot', uuid, 'restore', snapshot_uuid]\n        subprocess.call(args)\n        print \"\\n[INFO] VM Restore Snapshot\"\n        # Start Fresh VM\n        args = [vbox_exe, 'startvm', uuid]\n        subprocess.call(args)\n        print \"\\n[INFO] VM Starting\"\n    except:\n        PrintException(\"[ERROR] Refreshing MobSF VM\")\nDynamicAnalyzer/pyWebProxy/pywebproxy.py\ndef Proxy(IP, PORT, LOG, STAT):\n    global kill, log\n    if STAT == \"on\":\n        log = LOG\n        kill = False\n        print \"\\n[INFO] Started Web Proxy at \" + IP + \":\" + PORT\n        threading.Thread(target=startTornado, kwargs=dict(\n            IP=IP, PORT=PORT, log=log)).start()\n    else:\n        print \"\\n[INFO] Stopping any running instance of WebProxy\"\n        kill = True\nDynamicAnalyzer/views/android/android_avd.py\ndef refresh_avd(adb, avd_path, reference_name, dup_name, emulator):\n    \"\"\"Refresh AVD\"\"\"\n    print \"\\n[INFO] Refreshing MobSF Emulator\"\n    try:\n        # Stop existing emulator on the spesified port\n        stop_avd(adb)\n\n        # Windows has annoying lock system, it takes time for it to remove the locks after we stopped the emulator\n        if platform.system() == 'Windows':\n            time.sleep(3)\n\n        # Delete old emulator\n        delete_avd(avd_path, dup_name)\n\n        # Copy and replace the contents of the reference machine\n        duplicate_avd(avd_path, reference_name, dup_name)\n\n        # Start emulator\n        start_avd(emulator, dup_name, settings.AVD_ADB_PORT)\n    except:\n        PrintException(\"[ERROR] Refreshing MobSF VM\")\nAnalysis_x_logcat/analysis.py\ndef analysis_x_logcat(x_file_name, app_info):\n    package_name = app_info['packagename']\n    \n    # 新的 app_info 包含所有可能的manifest文件中提到的java代码所在的包名\n    app_info = set_java_package_names(app_info)\n    \n    # func_timeflow 表示以时间顺序记录的函数调用列表。 TODO: 供后续制定以时间序列调用api的规则，进而检测分析。\n    func_timeflow = load_x_file(x_file_name, package_name)\n    file_timeflow = x_file_name + '_timeflow_list.json'\n    save_file(file_timeflow, func_timeflow)\n    \n    # 把时间顺序记录的函数调用列表转换为二维特征数据\n    try:\n        timeflow_to_numpy(file_timeflow, FILE_S_JSON)\n    except Exception as e:\n        print u'把时间序列转换为二维特征数据时出异常：', traceback.format_exc()\n    \n    # hook_datas 表示数据处理过程中的中间结果。\n    hook_datas = make_hooks_datas(func_timeflow, package_name, app_info['java_package_names'])\n    #save_file(x_file_name + '_hook_result.json', hook_datas)\n    \n    # func_statistic 表示以api为关键字的函数调用列表。 TODO: 供后续制定以api调用详细信息的规则，进而检测分析。\n    func_statistic = count_function(hook_datas, package_name)\n    file_count_function = x_file_name + '_count_function.json'\n    save_file(file_count_function, func_statistic)\n    \n    # 根据 api调用->敏感行为 规则，查出其具有的敏感行为列表。\n    sensitives = transfer_func_to_sen(func_statistic)\n    sensitives = delete_empty_element(sensitives)\n    save_file(x_file_name + '_sensitives.json', sensitives)\n    \n    # 根据 api调用->漏洞 规则，查出其具有的漏洞列表。\n    vulnerabilities = transfer_func_to_vul(func_statistic, app_info)\n    vulnerabilities = remove_white(vulnerabilities)\n    vulnerabilities = delete_empty_element(vulnerabilities)\n    save_file(x_file_name + '_vulnerabilities.json', vulnerabilities)\n\n    # 由于临时文件比较大，当硬盘空间不足时，则删除临时文件。\n    # os.remove(x_file_name)\n    # os.remove(file_timeflow)\n    os.remove(file_count_function)\n    \n    result = {'sensitives': sensitives, 'vulnerabilities': vulnerabilities}\n    return result\nMobSF/utils.py\ndef getADB(TOOLSDIR):\n    \"\"\"Get ADB binary path\"\"\"\n    try:\n        if len(settings.ADB_BINARY) > 0 and isFileExists(settings.ADB_BINARY):\n            return settings.ADB_BINARY\n        else:\n            adb = 'adb'\n            if platform.system() == \"Darwin\":\n                adb_dir = os.path.join(TOOLSDIR, 'adb/mac/')\n                subprocess.call([\"chmod\", \"777\", adb_dir])\n                adb = os.path.join(TOOLSDIR, 'adb/mac/adb')\n            elif platform.system() == \"Linux\":\n                adb_dir = os.path.join(TOOLSDIR, 'adb/linux/')\n                subprocess.call([\"chmod\", \"777\", adb_dir])\n                adb = os.path.join(TOOLSDIR, 'adb/linux/adb')\n            elif platform.system() == \"Windows\":\n                adb = os.path.join(TOOLSDIR, 'adb/windows/adb.exe')\n            return adb\n    except:\n        PrintException(\"[ERROR] Getting ADB Location\")\n        return \"adb\"\nStaticAnalyzer/views/android/manifest_analysis.py\ndef manifest_data(mfxml):\n    \"\"\"Extract manifest data.\"\"\"\n    try:\n        print \"[INFO] Extracting Manifest Data\"\n        svc = []\n        act = []\n        brd = []\n        cnp = []\n        lib = []\n        perm = []\n        dvm_perm = {}\n        package = ''\n        minsdk = '1'\n        maxsdk = ''\n        targetsdk = ''\n        mainact = ''\n        androidversioncode = ''\n        androidversionname = ''\n        application_name = ''\n        permissions = mfxml.getElementsByTagName(\"uses-permission\")\n        manifest = mfxml.getElementsByTagName(\"manifest\")\n        activities = mfxml.getElementsByTagName(\"activity\")\n        services = mfxml.getElementsByTagName(\"service\")\n        providers = mfxml.getElementsByTagName(\"provider\")\n        receivers = mfxml.getElementsByTagName(\"receiver\")\n        libs = mfxml.getElementsByTagName(\"uses-library\")\n        sdk = mfxml.getElementsByTagName(\"uses-sdk\")\n        application = mfxml.getElementsByTagName(\"application\")\n        for node in application:\n            application_name = node.getAttribute(\"android:name\")\n        for node in sdk:\n            minsdk = node.getAttribute(\"android:minSdkVersion\")\n            maxsdk = node.getAttribute(\"android:maxSdkVersion\")\n            # Esteve 08.08.2016 - begin - If android:targetSdkVersion is not set, the default value is the one of the android:minSdkVersion\n            # targetsdk=node.getAttribute(\"android:targetSdkVersion\")\n            if node.getAttribute(\"android:targetSdkVersion\"):\n                targetsdk = node.getAttribute(\"android:targetSdkVersion\")\n            else:\n                targetsdk = node.getAttribute(\"android:minSdkVersion\")\n            # End\n        for node in manifest:\n            package = node.getAttribute(\"package\")\n            androidversioncode = node.getAttribute(\"android:versionCode\")\n            androidversionname = node.getAttribute(\"android:versionName\")\n        for activity in activities:\n            act_2 = activity.getAttribute(\"android:name\")\n            act.append(act_2)\n            if len(mainact) < 1:\n                # ^ Fix for Shitty Manifest with more than one MAIN\n                for sitem in activity.getElementsByTagName(\"category\"):\n                    val = sitem.getAttribute(\"android:name\")\n                    if val == \"android.intent.category.LAUNCHER\":\n                        mainact = activity.getAttribute(\"android:name\")\n        for activity in activities:\n            if not mainact:\n                for sitem in activity.getElementsByTagName(\"action\"):\n                    val = sitem.getAttribute(\"android:name\")\n                    if val == \"android.intent.action.MAIN\":\n                        mainact = activity.getAttribute(\"android:name\")\n\n        for service in services:\n            service_name = service.getAttribute(\"android:name\")\n            svc.append(service_name)\n\n        for provider in providers:\n            provider_name = provider.getAttribute(\"android:name\")\n            cnp.append(provider_name)\n\n        for receiver in receivers:\n            rec = receiver.getAttribute(\"android:name\")\n            brd.append(rec)\n\n        for _lib in libs:\n            libary = _lib.getAttribute(\"android:name\")\n            lib.append(libary)\n\n        for permission in permissions:\n            perm.append(permission.getAttribute(\"android:name\"))\n\n        for i in perm:\n            prm = i\n            pos = i.rfind(\".\")\n            if pos != -1:\n                prm = i[pos + 1:]\n            try:\n                dvm_perm[i] = DVM_PERMISSIONS[\"MANIFEST_PERMISSION\"][prm]\n            except KeyError:\n                dvm_perm[i] = [\n                    \"dangerous\",\n                    \"Unknown permission from android reference\",\n                    \"Unknown permission from android reference\"\n                ]\n\n        man_data_dic = {\n            'services': svc,\n            'activities': act,\n            'receivers': brd,\n            'providers': cnp,\n            'libraries': lib,\n            'perm': dvm_perm,\n            'packagename': package,\n            'mainactivity': mainact,\n            'min_sdk': minsdk,\n            'max_sdk': maxsdk,\n            'target_sdk': targetsdk,\n            'androver': androidversioncode,\n            'androvername': androidversionname,\n            'application_name': application_name\n        }\n\n        return man_data_dic\n    except:\n        PrintException(\"[ERROR] Extracting Manifest Data\")\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef get_identifier():\n    \"\"\"Get Device Type\"\"\"\n    try:\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n            return settings.DEVICE_IP + \":\" + str(settings.DEVICE_ADB_PORT)\n        elif settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_AVD\":\n            return 'emulator-' + str(settings.AVD_ADB_PORT)\n        else:\n            return settings.VM_IP + \":\" + str(settings.VM_ADB_PORT)\n    except:\n        PrintException(\n            \"[ERROR] Getting ADB Connection Identifier for Device/VM\")\n", "answers": ["    file_md5 = genMD5(file_path)"], "length": 1714, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "1341d46a7843a495a5668f7e4253fbaebba798bd9fcc93ee"}
{"input": "import asyncio\nimport copy\nimport json\nimport traceback\nimport discord\nfrom discord.ext import commands\nfrom discord.ext.commands import BadArgument\nfrom clembot.config.constants import MyEmojis\nfrom clembot.core import checks\nfrom clembot.core.bot import group, command\nfrom clembot.core.checks import AccessDenied\nfrom clembot.core.logs import Logger\nfrom clembot.exts.config import channel_checks\nfrom clembot.exts.config.channel_metadata import ChannelMetadata\nfrom clembot.exts.pkmn.gm_pokemon import Pokemon\nfrom clembot.exts.raid import raid_checks\nfrom clembot.exts.raid.raid import RaidRepository, RaidParty, RosterLocation, ChannelMessage\nfrom clembot.exts.raid.raid_cog import NoRaidForChannelError\nfrom clembot.utilities.utils import snowflake\nfrom clembot.utilities.utils.embeds import Embeds\nfrom clembot.utilities.utils.utilities import Utilities\n\n\n\n\nclass RaidPartyCog(commands.Cog):\n\n    def __init__(self, bot):\n        self.bot = bot\n        self._dbi = bot.dbi\n        self.utilities = Utilities()\n\n        self.bot.loop.create_task(self.load_raid_parties())\n\n\n    async def load_raid_parties(self):\n        Logger.info(\"load_raid_parties()\")\n\n        await Pokemon.load(self.bot)\n        for rcrd in await RaidRepository.find_raid_parties():\n            self.bot.loop.create_task(self.load_raid_party(rcrd))\n\n\n    async def load_raid_party(self, rcrd):\n        Logger.info(f\"load_raid_party({rcrd.get('raid_party_id', None)})\")\n        await RaidParty.from_db_dict(self.bot, rcrd)\n\n\n    @staticmethod\n    def get_raid_party_for_channel(ctx) -> RaidParty:\n        raid_party = RaidParty.by_channel.get(ctx.channel.id, None)\n        if raid_party is not None:\n            return raid_party\n        else:\n            raise NoRaidForChannelError(f\"Raid not found for channel {ctx.channel.mention}.\")\n\n\n    @command(pass_context=True, category='Bot Info', aliases=[\"raidparty\", \"rp\", \"raid-party\"])\n    @channel_checks.raid_report_enabled()\n    async def cmd_raidparty(self, ctx, *party_title):\n        \"\"\"\n        **!raid-party channel-name** - creates a raid party channel.\n\n        **Organizer commands:**\n        **!add pokemon-or-egg gym-or-location [eta]** - adds a location into the roster\n        **!update location# [pokemon-or-egg] [gym-or-location] [eta]** - updates the pokemon or location or eta for location #\n        **!remove location#** - to remove specified location from roster\n        **!move** - moves raid party to the next location in roster\n        **!reset** - to clean up the roster\n        **!raid-over** - to delete the channel (only channel-creator can do this)\n\n        **Participant commands:**\n        **!roster** - lists the roster\n        **!where** - to see the current location of raid party\n        **!next** - to see the next location of raid party\n\n        \"\"\"\n\n        city = await ctx.city()\n        timezone = await ctx.guild_profile(key='timezone')\n        raid_party_id = next(snowflake.create())\n\n        try:\n            raid_party_channel = await ctx.guild.create_text_channel('-'.join(party_title), overwrites=dict(ctx.channel.overwrites),\n                                                category=ctx.guild.get_channel(ctx.channel.category_id))\n\n            raid_party_message = await Embeds.message(ctx.channel, f\"Raid Party has been created, organize in {raid_party_channel.mention}\")\n\n        except discord.Forbidden:\n                raise commands.BotMissingPermissions(['Manage Channels'])\n\n        raid_party = RaidParty(raid_party_id=raid_party_id, bot=self.bot, guild_id=ctx.guild.id,\n                               response_message_id=raid_party_message.id, report_channel_id = ctx.channel.id,\n                               channel_id=raid_party_channel.id, author_id=ctx.message.author.id, city=city,\n                               timezone=timezone, roster_begins_at=0)\n        await raid_party.insert()\n\n\n\n    @command(pass_context=True, category='Bot Info', aliases=[\"raid-city\", \"rc\"])\n", "context": "clembot/utilities/utils/embeds.py\nclass Embeds:\n\n    def __init__(self):\n        return\n\n    @staticmethod\n    async def ask_for_input(ctx, prompt_embed, validate_response=None):\n        \"\"\"\n        returns cancel if configuration is cancelled.\n        \"\"\"\n        def check(msg):\n            return msg.author == ctx.message.author and msg.channel == ctx.channel\n\n        await ctx.send(embed=prompt_embed)\n\n        while True:\n            try:\n                response = await ctx.bot.wait_for('message', check=check, timeout=60)\n            except asyncio.TimeoutError:\n                await Embeds.error(ctx.channel, 'Too late!')\n                return \"cancel\"\n            except Exception as error:\n                break\n            response_content = response.content.strip()\n            if response_content == \"cancel\" or (validate_response and validate_response(response_content)):\n                return response_content\n            else:\n                await Embeds.error(ctx.channel, 'I could not interpret your response. Try again!')\n                continue\n        return \"cancel\"\n\n\n    @staticmethod\n    def google_location_preview_url(lat_long):\n        key = config_template.api_keys[\"google-api-key\"]\n        gmap_base_url = f\"https://maps.googleapis.com/maps/api/staticmap?center={lat_long}&markers=color:blue%7C{lat_long}&maptype=roadmap&size=250x125&zoom=15&key={key}\"\n\n        return gmap_base_url\n\n    @staticmethod\n    async def message(channel, description, title=None, footer=None, user=None, icon=MyEmojis.INFO):\n        try:\n            error_message = \"The output contains more than 2000 characters.\"\n\n            user_mention = f\"{icon} \"\n            if user:\n                user_mention = f\"{user_mention}**{user.display_name}** \"\n\n            if len(description) >= 2000:\n                discord.Embed(description=\"{0}\".format(error_message), colour=discord.Color.red())\n\n            message_embed = discord.Embed(description=f\"{user_mention}{description}\", colour=discord.Colour.green(), title=title)\n            if footer:\n                message_embed.set_footer(text=footer)\n            return await channel.send(embed=message_embed)\n        except Exception as error:\n            Logger.error(error)\n\n\n    @staticmethod\n    async def error(channel, description, user=None):\n\n        color = discord.Colour.red()\n        user_mention = \"\"\n        if user:\n            user_mention = f\"**{user.display_name}** \"\n        error_embed = discord.Embed(description=f\"{MyEmojis.ERROR} {user_mention}{description}\", colour=color)\n        return await channel.send(embed=error_embed)\n\n    @staticmethod\n    async def error_notification(ctx, header, error, disappear_in=30):\n        \"\"\"The message stays for 30 seconds and disappears!\"\"\"\n        try:\n            err_msg = await ctx.send(embed=Embeds.make_embed(msg_type='error', header=header, content=error.__str__()))\n            if disappear_in:\n                await asyncio.sleep(disappear_in)\n                await err_msg.delete()\n        except Exception as err:\n            Logger.error(err)\n\n\n    @staticmethod\n    def trim_to(text, length, delimiter=\",\"):\n        if len(text) == 0:\n            return \"None\"\n        if text and delimiter:\n            return text[:text.rfind(delimiter, 0, length)] + \" ** and more1.**\" if len(text) > length else text\n        return text\n\n    @staticmethod\n    def make_embed(msg_type='', header=None, header_icon=None, title=None, title_url=None, content=None, thumbnail='',\n                   image='', fields=None, footer=None, footer_icon=None, inline=True, guild=None, msg_color=None):\n        \"\"\"Returns a formatted discord embed object.\n\n        Define either a type or a colour.\n        Types are:\n        error, warning, info, success, help.\n        \"\"\"\n        embed_types = {\n            'error':{\n                'icon':'https://i.imgur.com/juhq2uJ.png',\n                'colour':'red'\n            },\n            'warning':{\n                'icon':'https://i.imgur.com/4JuaNt9.png',\n                'colour':'gold'\n            },\n            'info':{\n                'icon':'https://i.imgur.com/wzryVaS.png',\n                'colour':'blue'\n            },\n            'success':{\n                'icon':'https://i.imgur.com/ZTKc3mr.png',\n                'colour':'green'\n            },\n            'help':{\n                'icon':'https://i.imgur.com/kTTIZzR.png',\n                'colour':'blue'\n            }\n        }\n        if msg_type in embed_types.keys():\n            msg_color = embed_types[msg_type]['colour']\n            header_icon = embed_types[msg_type]['icon']\n        if guild and not msg_color:\n            msg_color = color(guild)\n        else:\n            if not isinstance(msg_color, discord.Colour):\n                msg_color = color(msg_color)\n\n        embed = discord.Embed(title=title or discord.Embed.Empty, url=title_url or discord.Embed.Empty,\n            description=content, colour=msg_color)\n\n        if header:\n            embed.set_author(name=header, icon_url=header_icon or discord.Embed.Empty, url=discord.Embed.Empty)\n\n        if thumbnail:\n            embed.set_thumbnail(url=thumbnail)\n        if image:\n            embed.set_image(url=image)\n        if fields:\n            for key, value in fields.items():\n                ilf = inline\n                if not isinstance(value, str):\n                    if not value:\n                        continue\n                    else:\n                        ilf = value[0]\n                        value = value[1]\n                if value:\n                    embed.add_field(name=f\"**{key}**\", value=Embeds.trim_to(value, 995), inline=ilf)\n        if footer:\n            footer = {'text':footer}\n            if footer_icon:\n                footer['icon_url'] = footer_icon\n            embed.set_footer(**footer)\n        return embed\nclembot/core/checks.py\nclass AccessDenied(CommandError):\nasync def _check_is_owner(ctx):\nasync def _check_is_trusted(ctx):\nasync def _check_is_guild_owner(ctx):\nasync def _check_is_guild_admin(ctx):\nasync def _check_is_moderator(ctx):\nasync def check_is_owner(ctx):\nasync def check_is_trusted(ctx):\nasync def check_is_guild_owner(ctx):\nasync def check_is_guild_admin(ctx):\nasync def check_is_moderator(ctx):\ndef go_thru_sometimes():\ndef is_bot_owner():\ndef is_trusted():\ndef is_guild_owner():\ndef is_guild_admin():\ndef is_guild_mod():\nclembot/exts/config/channel_metadata.py\nclass ChannelMetadata:\n\n    by_channel = dict()\n    _in_progress_config_channels = []\n\n    def __init__(self, bot, channel):\n        self.bot = bot\n        self.channel = channel\n\n    def __eq__(self, other):\n        return self.channel.id == other.channel.id\n\n    @classmethod\n    def begin_configuration(cls, channel_id):\n        cls._in_progress_config_channels.append(channel_id)\n\n\n    @classmethod\n    def end_configuration(cls, channel_id):\n        if cls.config_in_progress(channel_id):\n            cls._in_progress_config_channels.remove(channel_id)\n\n    @classmethod\n    def config_in_progress(cls, channel_id):\n        return channel_id in cls._in_progress_config_channels\n\n\n    @property\n    def _data(self):\n        report_channel_query = self.bot.dbi.table('channel_metadata').query()\n        _data = report_channel_query.where(channel_id=self.channel.id)\n        return _data\n\n    @classmethod\n    def cache(cls, channel_dict):\n        ChannelMetadata.by_channel[channel_dict.get('channel_id')] = channel_dict\n\n\n    @classmethod\n    def evict(cls, channel_id):\n        ChannelMetadata.by_channel.pop(channel_id, None)\n\n\n    @classmethod\n    async def find(cls, bot, channel_id, guild_id = None):\n\n        channel_metadata = ChannelMetadata.by_channel.get(channel_id)\n        if channel_metadata:\n            return channel_metadata\n\n        report_channel_query = bot.dbi.table('channel_metadata').query()\n        _data = report_channel_query.where(channel_id=channel_id)\n        db_record = await _data.get()\n\n        if db_record:\n            channel_metadata = ChannelMetadata.deserialize(dict(db_record[0]))\n            ChannelMetadata.cache(channel_metadata)\n            return channel_metadata\n\n        if guild_id:\n            await ChannelMetadata.insert(bot, {'channel_id': channel_id, 'guild_id': guild_id})\n        return ChannelMetadata.by_channel.get(channel_id)\n\n\n    @classmethod\n    async def city(cls, bot, channel_id):\n        channel_dict = await ChannelMetadata.find(bot, channel_id)\n        if channel_dict:\n            return channel_dict.get('city')\n        raise Exception(\"City has not been set for this channel.\")\n\n    @staticmethod\n    def serialize(data_dict):\n        return _.map_values(data_dict, lambda val: json.dumps(val) if isinstance(val, dict) else val)\n\n    @staticmethod\n    def deserialize(data_dict):\n        return { k :json.loads(v) if k == 'config' and v is not None else v for (k, v) in data_dict.items()}\n\n\n    @classmethod\n    async def update(cls, bot, channel_dict):\n        channel_metadata_table = bot.dbi.table('channel_metadata')\n        update_dict=ChannelMetadata.serialize(channel_dict)\n        channel_metadata_table_update = channel_metadata_table.update(**update_dict).where(channel_id=channel_dict.get('channel_id'))\n        await channel_metadata_table_update.commit()\n        ChannelMetadata.cache(channel_dict)\n\n    @classmethod\n    async def insert(cls, bot, channel_dict):\n        channel_metadata_table = bot.dbi.table('channel_metadata')\n        insert_dict = ChannelMetadata.serialize(channel_dict)\n        channel_metadata_table_insert = channel_metadata_table.insert(**insert_dict)\n        await channel_metadata_table_insert.commit()\n        ChannelMetadata.cache(channel_dict)\n\n    @staticmethod\n    def embed(ctx, channel_dict):\n        return (ChannelConfigEmbed.from_channel_metadata(ctx, channel_dict)).embed\n\n    @staticmethod\n    def success_embed(ctx, channel_dict):\n        embed = (ChannelConfigEmbed.from_channel_metadata(ctx, channel_dict, \"Configuration has been updated successfully.\", Icons.configure_success)).embed\n        return embed\n\n    @staticmethod\n    def failure_embed(ctx, channel_dict):\n        embed = (ChannelConfigEmbed.from_channel_metadata(ctx, channel_dict, \"No configuration changes done.\", Icons.configure_failure)).embed\n        return embed\n\n    @staticmethod\n    def profile_embed(ctx, channel_dict, title=None):\n        return (ChannelConfigEmbed.from_channel_profile(ctx, channel_dict, title)).embed\nclembot/exts/config/channel_checks.py\nasync def _is_wild_report_channel(ctx):\nasync def _is_raid_report_channel(ctx):\nasync def _is_nest_report_channel(ctx):\ndef raid_report_enabled():\ndef wild_report_enabled():\ndef nest_report_enabled():\nclembot/core/bot.py\ndef command(*args, **kwargs):\n    def decorator(func):\n        category = kwargs.get(\"category\")\n        examples = kwargs.get(\"examples\")\n        func.command_category = category\n        func.examples = examples\n        error_wrapped_func = wrap_error(func)\n        result = commands.command(*args, **kwargs)(error_wrapped_func)\n        return result\n    return decorator\nclembot/utilities/utils/snowflake.py\nCLEM_EPOCH = 1502123160\ndef to_timestamp(_id):\ndef create():\n    def __init__(self):\n    def next(self):\n    def dumps(self, number):\n    def loads(self, value):\n    def cuid(cls, id):\ndef main():\nclass Snowflake:\nclass Base36:\nclass CUIDGenerator:\nclembot/exts/raid/raid.py\nclass RosterLocation:\n\n    def __init__(self, raid_boss = Union[Pokemon, str], poi_location: POILocation=None, eta=None):\n        self.raid_boss = raid_boss\n        self.poi_location = poi_location\n        self.eta = eta\n\n    def to_dict(self):\n        state_dict = {\n            'raid_boss': self.raid_boss if isinstance(self.raid_boss, str) else self.raid_boss.id,\n            'poi' : self.poi_location.to_dict(),\n            'eta' : self.eta,\n        }\n        return state_dict\n\n    @classmethod\n    async def from_dict(cls, bot, state):\n        p_raid_boss, p_eta, p_poi = ([state.get(attr, None) for attr in ['raid_boss', 'eta', 'poi']])\n\n        raid_boss = \"egg\" if p_raid_boss == \"egg\" else Pokemon.to_pokemon(p_raid_boss)\n        poi_location = await POILocation.from_dict(bot, p_poi)\n\n        return cls(raid_boss=raid_boss, poi_location=poi_location, eta=p_eta)\n\n    @classmethod\n    async def from_command_text(cls, ctx, text, update_mode=False):\n        args = text.split()\n\n        if len(args) == 0:\n            raise BadArgument(\"No information found about egg/boss location and/or eta.\")\n\n        if args[0] == 'egg':\n            pkmn_or_egg = 'egg'\n            del args[0]\n        else:\n            try:\n                pkmn_or_egg = (await Pokemon.convert(ctx, args[0]))\n            except BadArgument as error:\n                if not update_mode:\n                    raise error\n                else:\n                    pkmn_or_egg = None\n            if pkmn_or_egg:\n                del args[0]\n\n        eta=None\n        if len(args) > 0:\n            index = -1\n            if args[-1].upper() == 'AM' or args[-1].upper() == 'PM':\n                eta = ''.join(args[-2:])\n                index = -2\n            else:\n                eta = args[-1]\n            if convert_into_time(eta, require_am_pm=False) is None:\n                eta = None\n            else:\n                del args[index:]\n\n        poi_location = None\n        if len(args) > 0:\n            poi_location = await POILocationConverter.convert(ctx, ' '.join(args))\n\n        return cls(raid_boss=pkmn_or_egg, poi_location=poi_location, eta=eta)\n\n    @property\n    def raid_for(self):\n        if isinstance(self.raid_boss, Pokemon):\n            return self.raid_boss.label\n        return self.raid_boss\n\n    @property\n    def raid_at(self):\n        if self.poi_location:\n            return self.poi_location.gym_embed_label\n\n    def raid_location_embed(self):\n        return (RosterLocationEmbed.from_roster_location(self)).embed\nclembot/exts/pkmn/gm_pokemon.py\nclass Pokemon:\n\n    _cache = dict()\n\n    def __init__(self, db_dict, pokedex_num, aliases=[], pokemon_form_id=None):\n        self.db_dict = db_dict\n        self.pokedex_num = pokedex_num\n        self.aliases = aliases\n        self.pokemon_form_id = pokemon_form_id\n\n    def __getitem__(self, item):\n        \"\"\"use [] operator to access members, simpler to create entity objects\"\"\"\n        return self.db_dict.get(item)\n\n\n    def __setitem__(self, key, value):\n        \"\"\"use [] operator to access members, simpler to create entity objects. Handles array kind of values.\"\"\"\n        self.db_dict[key] = value\n\n\n    def __repr__(self):\n        return self.label\n\n    @property\n    def id(self):\n        return self.aliases[0] if self.aliases else None\n\n    @property\n    def label(self):\n        return self.id.title()\n\n    # @property\n    # def label(self):\n    #     if self.pokeform_display_text:\n    #         return self.pokeform_display_text.capitalize()\n    #     return None\n\n\n    @property\n    def form(self):\n        form = _.get(self.db_dict, 'pokemonId')\n        if '_ALOLA' in form:\n            form = form.replace('_ALOLA','_ALOLA_FORM')\n        return form\n\n    @property\n    def base_attack(self):\n        return _.get(self.db_dict, 'stats.baseAttack')\n\n    @property\n    def base_defense(self):\n        return _.get(self.db_dict, 'stats.baseDefense')\n\n    @property\n    def base_stamina(self):\n        return _.get(self.db_dict, 'stats.baseStamina')\n\n    @property\n    def fast_moves(self):\n        return list(map(lambda move: move.replace(\"_FAST\", \"\"), _.get(self.db_dict, 'quickMoves')))\n\n    @property\n    def fast_moves_labels(self):\n        return list(map(lambda move: move.replace(\"_\",\" \").title() , self.fast_moves))\n\n    @property\n    def charge_moves(self):\n        return list(map(lambda move: move, _.get(self.db_dict, 'cinematicMoves')))\n\n    @property\n    def charge_moves_labels(self):\n        return list(map(lambda move: move.replace(\"_\",\" \").title() , self.charge_moves))\n\n\n    @property\n    def type1(self):\n        type1 = _.get(self.db_dict, 'type')\n        if type1:\n            return type1.replace(\"POKEMON_TYPE_\",\"\").upper()\n        return None\n\n    @property\n    def type2(self):\n        type2 = _.get(self.db_dict, 'type2')\n        if type2:\n            return type2.replace(\"POKEMON_TYPE_\", \"\").upper()\n        return None\n\n    @property\n    def types(self):\n        if self.type2:\n            return [self.type1, self.type2]\n        return [self.type1]\n\n    @property\n    def type1_icon(self):\n        if self.type1:\n            key = self.type1.lower()\n            return config_template.type_emoji[key]\n        return None\n\n    @property\n    def type2_icon(self):\n        if self.type2:\n            key = self.type2.lower()\n            return config_template.type_emoji[key]\n        return None\n\n    @property\n    def shiny(self):\n        return False\n\n    def _gender_type(self):\n        return 'X'\n\n    @property\n    def gender(self):\n        return 'MALE'\n\n\n    @property\n    def extended_label(self):\n        \"\"\"returns pokemon(pokedex) type1 type2\"\"\"\n        extended_label=f\"{self.label} ({self.pokedex_num}) {self.type1_icon}\"\n        if self.type2_icon:\n            extended_label=f\"{extended_label}{self.type2_icon}\"\n        return extended_label\n\n    @property\n    def preview_url(self):\n        url = \"https://raw.githubusercontent.com/TrainingB/Clembot/v2-rewrite/images/pkmn/\"\n        if self.form:\n            url += str(self.form)\n        if self.shiny:\n            url += '_SHINY'\n        if self._gender_type() == 'DIMORPH' and self.gender:\n            url += f'_{self.gender.upper()}'\n        url += '.png'\n        # url += '?cache=5'\n        return url\n\n    # async def color(self):\n    #     url = await self.sprite_url()\n    #     color = await formatters.url_color(url)\n    #     return color\n\n    @property\n    def raid_cp_range(self):\n        low_cp = self.calculate_cp(20, 10, 10, 10)\n        high_cp = self.calculate_cp(20, 15, 15, 15)\n        return [low_cp, high_cp]\n\n\n    def calculate_cp(self, level, attiv, defiv, staiv):\n        if None in [level, attiv, defiv, staiv]:\n            return None\n        else:\n            cpm = CPCalculator().cpM[level]\n            att = (self.base_attack + attiv)*cpm\n            defense = (self.base_defense + defiv)*cpm\n            sta = (self.base_stamina + staiv)*cpm\n            cp = math.floor((att*defense**0.5*sta**0.5)/10)\n            if cp < 10:\n                cp = 10\n            return cp\n\n    @classmethod\n    def cache(cls, form):\n        Pokemon._cache[form.aliases[0]] = form\n\n    @classmethod\n    def to_pokemon(cls, search_for):\n        if len(cls._cache) < 1:\n            raise Exception(\"Error : Pokemon forms are not loaded yet.\")\n\n        if search_for:\n            return cls._cache.get(search_for.upper(), None)\n\n        return None\n\n    @classmethod\n    async def load(cls, bot):\n\n        if len(Pokemon._cache) == 0:\n            table = bot.dbi.table('PB_POKEMON_FORM')\n            forms = await table.query().select().getjson()\n\n            for form in forms:\n                pForm = Pokemon(json.loads(form.get('data')), form.get('pokedex_id'), form.get('aliases'), form.get('pokemon_form_id'))\n                Pokemon.cache(pForm)\n        GMPokemonFormSpellHelper.set_dictionary(cls._cache.keys())\n\n    @classmethod\n    async def convert(cls, ctx, argument) :\n\n        await cls.load(ctx.bot)\n\n        pokemon_form = cls.to_pokemon(argument.upper())\n        if pokemon_form:\n            return pokemon_form\n        else:\n            possible_pokemon_form = await Pokemon.auto_correct(ctx, argument.upper())\n            if possible_pokemon_form:\n                pokemon_form = cls.to_pokemon(possible_pokemon_form)\n                return pokemon_form\n\n        raise BadArgument(f\"{argument} could not be resolved to a pokemon.\")\n\n    @staticmethod\n    async def auto_correct(ctx, pokemon_as_text):\n\n        not_acceptable_message = f\"**{pokemon_as_text}** isn't a Pokemon!\"\n\n        suggestion = GMPokemonFormSpellHelper.correction(pokemon_as_text)\n\n        if suggestion and suggestion != pokemon_as_text:\n\n            not_acceptable_message += f\" Did you mean **{suggestion}**?\"\n            replace_pokemon = await Utilities.ask_confirmation(ctx, ctx.message, not_acceptable_message, \"Alright!\", \"That's okay!\", \"Timed Out!\")\n            if replace_pokemon:\n                return suggestion\n\n        return None\n\n\n\n\n\n    @property\n    def weaknesses(self):\n        \"\"\"\n        Given a Pokemon name, return a list of its weaknesses as defined in the type chart\n        Calculate sum of its weaknesses and resistances.\n        -2 == immune , -1 == NVE, 0 == neutral, 1 == SE, 2 == double SE\n        \"\"\"\n        type_eff = {}\n        for p_type in self.types:\n            for atk_type in _TYPE_CHART[p_type]:\n                if atk_type not in type_eff:\n                    type_eff[atk_type] = 0\n                type_eff[atk_type] += _TYPE_CHART[p_type][atk_type]\n\n        # Summarize into a list of weaknesses,\n        # sorting double weaknesses to the front and marking them with 'x2'.\n        ret = []\n        for p_type, effectiveness in sorted(type_eff.items(), key=lambda x: x[1], reverse=True):\n            if effectiveness == 1:\n                ret.append(p_type.lower())\n            elif effectiveness == 2:\n                ret.append(p_type.lower() + \"x2\")\n\n        return ret\n\n\n    @property\n    def weaknesses_icon(self):\n        \"\"\"\n        Given a list of weaknesses, return a space-separated string of their type IDs as defined in the type_id_dict\n        \"\"\"\n        ret = \"\"\n        for weakness in self.weaknesses:\n            # Handle an \"x2\" postfix defining a double weakness\n            x2 = \"\"\n            if weakness[-2:] == \"x2\":\n                weakness = weakness[:-2]\n                x2 = \"x2\"\n\n            # Append to string\n            ret += config_template.type_emoji[weakness] + x2 + \" \"\n\n        return ret\nclembot/utilities/utils/utilities.py\nclass Utilities:\n\n    numbers = {\"0\": \":zero:\", \"1\": \":one:\", \"2\": \":two:\", \"3\": \":three:\", \"4\": \":four:\", \"5\": \":five:\", \"6\": \":six:\", \"7\": \":seven:\", \"8\": \":eight:\", \"9\": \":nine:\"}\n\n    @staticmethod\n    def trim_to(text, length, delimiter=\",\"):\n        if len(text) == 0:\n            return \"None\"\n        if text and delimiter:\n            return text[:text.rfind(delimiter, 0, length)] + \" ** and more.**\" if len(text) > length else text\n        return text\n\n    @staticmethod\n    def emojify_numbers(number):\n        number_emoji = \"\"\n\n        reverse = \"\".join(reversed(str(number)))\n\n        for digit in reverse[::-1]:\n\n            emoji = Utilities.numbers.get(digit)\n            if not emoji:\n                emoji = \":regional_indicator_\" + digit.lower() + \":\"\n\n            number_emoji = number_emoji + emoji\n\n        return number_emoji\n\n    @staticmethod\n    def _normalize(emoji):\n        initial_emoji = emoji\n        if isinstance(emoji, discord.Reaction):\n            emoji = emoji.emoji\n\n        if isinstance(emoji, discord.Emoji):\n            emoji = ':%s:%s' % (emoji.name, emoji.id)\n\n        elif isinstance(emoji, discord.PartialEmoji):\n            emoji = emoji._as_reaction()\n        elif isinstance(emoji, str):\n            pass\n\n        if emoji.count(':') == 1 and not emoji.startswith(':'):\n            emoji = f\":{emoji}\"\n\n        if emoji.__contains__(\">\") and emoji.__contains__(\"<\"):\n            emoji = emoji.replace('<','').replace('>','')\n        return emoji\n\n\n    @staticmethod\n    def _demojify(emoji):\n        # convert emoji to id\n        if isinstance(emoji, discord.Reaction):\n            emoji = emoji.emoji.id\n\n        if isinstance(emoji, discord.Emoji):\n            emoji = emoji.id\n        elif isinstance(emoji, discord.PartialEmoji):\n            emoji = emoji.id if emoji.id else emoji.name\n        elif isinstance(emoji, str):\n            pass\n\n        return emoji\n\n    @staticmethod\n    def _emojify(emoji):\n        if emoji.__contains__(\">\") and emoji.__contains__(\"<\"):\n            emoji = emoji.replace('<', '').replace('>', '')\n        return emoji\n\n    @staticmethod\n    def _uuid(cls, id):\n        try:\n            return '%x' % (hash(id) % 10 ** 8)\n        except Exception as error:\n            Logger.error(error)\n            return id\n\n    @staticmethod\n    async def _send_error_message(channel, description, user=None):\n\n        color = discord.Colour.red()\n        user_mention = \"\"\n        if user:\n            user_mention = f\"Beep Beep! **{user.display_name}** \"\n        error_embed = discord.Embed(description=f\"{user_mention}{description}\", colour=color)\n        return await channel.send(embed=error_embed)\n\n    @staticmethod\n    async def message(destination, description, user=None):\n\n        color = discord.Colour.green()\n        user_mention = \"\"\n        if user:\n            user_mention = f\"Beep Beep! **{user.display_name}** \"\n        error_embed = discord.Embed(description=f\"{user_mention}{description}\", colour=color)\n        return await destination.send(embed=error_embed)\n\n    @staticmethod\n    async def message_as_text(channel, description):\n        return await channel.send(description)\n\n    @staticmethod\n    async def error(channel, description, user=None):\n\n        color = discord.Colour.red()\n        user_mention = \"\"\n        if user:\n            user_mention = f\"Beep Beep! **{user.display_name}** \"\n        error_message = f\"{user_mention}{description}\"\n        error_embed = discord.Embed(description=f\"{error_message}\", colour=color)\n        Logger.error(error_message)\n        return await channel.send(embed=error_embed)\n\n    @staticmethod\n    async def _send_message(channel, description, title=None, footer=None, user=None):\n        try:\n\n            error_message = \"The output contains more than 2000 characters.\"\n\n            user_mention = \"\"\n            if user:\n                user_mention = f\"Beep Beep! **{user.display_name}** \"\n\n            if len(description) >= 2000:\n                discord.Embed(description=\"{0}\".format(error_message))\n\n            color = discord.Colour.green()\n            message_embed = discord.Embed(description=f\"{user_mention}{description}\", colour=color, title=title)\n            if footer:\n                message_embed.set_footer(text=footer)\n            return await channel.send(embed=message_embed)\n        except Exception as error:\n            Logger.error(error)\n\n    @staticmethod\n    async def _send_embed(channel, description=None, title=None, additional_fields={}, footer=None):\n\n        embed = discord.Embed(description=description, colour=discord.Colour.gold(), title=title)\n\n        for label, value in additional_fields.items():\n            if value:\n                embed.add_field(name=\"**{0}**\".format(label), value=value, inline=False)\n\n        if footer:\n            embed.set_footer(text=footer)\n\n        try:\n            return await channel.send(embed=embed)\n        except Exception as error:\n            return await channel.send(error)\n\n    @command(name=\"export\")\n    async def _export(self, ctx):\n\n        return await self._send_message(ctx.channel, \"Beep Beep! **{}**, This feature is under-development!\".format(ctx.message.author.display_name))\n\n        Logger.error(\"_export() called!\")\n\n        raid_dict = ctx.bot.guild_dict[ctx.guild.id]['raidchannel_dict'][ctx.channel.id]\n\n        channel_mentions = ctx.message.raw_channel_mentions\n\n        if len(channel_mentions) < 1:\n            await self._send_error_message(ctx.channel, \"Beep Beep! **{}**, Please provide the channel reference to export the details!\".format(ctx.message.author.display_name))\n\n    @command(name=\"clean_content\")\n    async def _clean_content(self, message):\n\n        message_content = {}\n        content_without_mentions = message.content\n\n        for mention in message.mentions:\n            mention_text = mention.mention.replace(\"!\", \"\")\n            content_without_mentions = content_without_mentions.replace(\"<@!\", \"<@\").replace(mention_text, '')\n\n        # remove extra spaces\n        message_content['content_without_mentions'] = re.sub(' +', ' ', content_without_mentions)\n\n        return message_content\n\n    @staticmethod\n    def get_help_embed(description, usage, available_value_title, available_values, mode=\"message\"):\n\n        if mode == \"message\":\n            color = discord.Colour.green()\n        else:\n            color = discord.Colour.red()\n\n        help_embed = discord.Embed( description=\"**{0}**\".format(description), colour=color)\n\n        help_embed.add_field(name=\"**Usage :**\", value = \"**{0}**\".format(usage))\n        help_embed.add_field(name=\"**{0} :**\".format(available_value_title), value=_(\"**{0}**\".format(\", \".join(available_values))), inline=False)\n\n        return help_embed\n\n    @staticmethod\n    async def _send_error_message_and_cleanup(channel, message, user):\n        log_message = await Embeds.error(channel, message, user=user)\n        await asyncio.sleep(8)\n        await log_message.delete()\n\n\n    @staticmethod\n    async def get_image_embed(channel, image_url):\n        embed = discord.Embed(colour=channel.guild.me.colour)\n        embed.set_thumbnail(url=image_url)\n        return await channel.send(embed=embed)\n\n    @staticmethod\n    async def ask(message, destination, user_list=None, *, react_list=['✅', '❎']):\n        if user_list and type(user_list) != __builtins__.list:\n            user_list = [user_list]\n\n\n        def check(reaction, user):\n            if user_list and type(user_list) is __builtins__.list:\n                return (user.id in user_list) and (reaction.message.id == message.id) and (reaction.emoji in react_list)\n            elif not user_list:\n                return (user.id != message.guild.me.id) and (reaction.message.id == message.id) and (reaction.emoji in react_list)\n\n\n        for r in react_list:\n            await asyncio.sleep(0.25)\n            await message.add_reaction(r)\n        try:\n            reaction, user = await Clembot.wait_for('reaction_add', check=check, timeout=60)\n            return reaction, user\n        except asyncio.TimeoutError:\n            await message.clear_reactions()\n            return\n\n\n    @staticmethod\n    @wrap_error\n    async def ask_confirmation(ctx, message, rusure_message, yes_message, no_message, timed_out_message):\n        author = message.author\n        channel = message.channel\n\n        reaction_list = ['✅', '❎']\n        # reaction_list = ['❔', '✅', '❎']\n\n        rusure = await ctx.channel.send(f\"Beep Beep! {rusure_message}\")\n        await rusure.add_reaction( \"✅\")  # checkmark\n        await rusure.add_reaction( \"❎\")  # cross\n\n        def check(react, user):\n            if user.id != author.id:\n                return False\n            return True\n\n        # res = await Clembot.wait_for_reaction(reaction_list, message=rusure, check=check, timeout=60)\n        try:\n            reaction, user = await ctx.bot.wait_for('reaction_add', check=check, timeout=10)\n        except asyncio.TimeoutError:\n            await rusure.delete()\n            confirmation = await channel.send(f\"Beep Beep! {timed_out_message}\")\n            await asyncio.sleep(1)\n            await confirmation.delete()\n            return False\n\n        if reaction.emoji == \"❎\":\n            await rusure.delete()\n            confirmation = await channel.send(f\"Beep Beep! {no_message}\")\n            await asyncio.sleep(1)\n            await confirmation.delete()\n            return False\n        elif reaction.emoji == \"✅\":\n            await rusure.delete()\n            confirmation = await channel.send(f\"Beep Beep! {yes_message}\")\n            await asyncio.sleep(1)\n            await confirmation.delete()\n            return True\n\n\n    @staticmethod\n    @wrap_error\n    async def ask_via_reactions(ctx, message, question_message, accepted_message, rejected_message, timed_out_message, reaction_dict, error_response):\n        author = message.author\n        channel = message.channel\n\n        rusure = await ctx.channel.send(f\"{question_message}\")\n\n        for r in reaction_dict.keys():\n            await rusure.add_reaction(r)\n\n        def check(react, user):\n            if user.id != author.id:\n                return False\n            return True\n\n        try:\n            reaction, user = await ctx.bot.wait_for('reaction_add', check=check, timeout=10)\n        except asyncio.TimeoutError:\n            await rusure.delete()\n            confirmation = await channel.send(f\"{timed_out_message}\")\n            await asyncio.sleep(1)\n            await confirmation.delete()\n            return error_response\n\n        if reaction.emoji not in reaction_dict.keys():\n            await rusure.delete()\n            confirmation = await channel.send(f\"{rejected_message}\")\n            await asyncio.sleep(1)\n            await confirmation.delete()\n            return error_response\n\n        elif reaction.emoji in reaction_dict.keys():\n            await rusure.delete()\n            confirmation = await channel.send(f\"{accepted_message}\")\n            await asyncio.sleep(1)\n            await confirmation.delete()\n            return reaction_dict.get(reaction.emoji, error_response)\n\n\n    @staticmethod\n    async def send_to_hastebin(destination, whatever):\n        whatever = whatever.encode('ascii', errors='replace').decode('utf-8')\n        print(whatever)\nclembot/exts/raid/raid_cog.py\nclass NoRaidForChannelError(ValueError):\n    pass\nclembot/exts/raid/raid.py\nclass RaidParty(RSVPEnabled):\n    \"\"\"\n    Also serves as raidparty_cache\n    \"\"\"\n    by_channel = dict()\n    by_id = dict()\n    embed_options = ['description', 'rsvp']\n\n    def __init__(self, raid_party_id=None, bot=None, guild_id=None, channel_id=None, author_id = None,\n                 response_message_id = None, report_channel_id=None, city=None, timezone=None, roster= [] , roster_begins_at = 0,\n                 trainer_dict=dict()):\n        super().__init__(bot=bot, trainer_dict=trainer_dict)\n        self.id = raid_party_id\n        self.bot = bot\n        self.guild_id = guild_id\n        self.channel_id = channel_id\n        self.author_id = author_id\n        self.response_message_id = response_message_id\n        self.report_channel_id = report_channel_id\n        self.raid_type = \"raidparty\"\n        self.city = city\n        self.timezone = timezone\n        self.snowflake = Snowflake()\n        self.roster = roster\n        self.roster_begins_at = roster_begins_at\n        self.trainer_dict = trainer_dict\n\n    @property\n    def empty(self):\n        if len(self.roster) == 0:\n            return True\n        return False\n\n    @property\n    def current_location(self):\n        if self.empty:\n            return None\n        return self.roster[self.physical_index(self.roster_begins_at)]\n\n    @property\n    def current_location_index(self):\n        return self.roster_begins_at\n\n\n    def is_started_by(self, member_id):\n        return self.author_id == member_id\n\n    def physical_index(self, i):\n        return i - self.roster_begins_at\n\n    def __getitem__(self, i: int) -> RosterLocation:\n        \"\"\"Get\"\"\"\n        if self.roster_begins_at <= i <= self.roster_begins_at + self.__len__():\n            return self.roster[self.physical_index(i)]\n        return None\n\n    def __setitem__(self, i: int, o: RosterLocation) -> None:\n        \"\"\"Update\"\"\"\n        if self.physical_index(i) > len(self.roster):\n            return\n        self.roster[self.physical_index(i)] = o\n\n    def __delitem__(self, i: int) -> None:\n        \"\"\"Remove\"\"\"\n        del self.roster[self.physical_index(i)]\n        print(f\"{self.__repr__()} (after REMOVE {i})\")\n\n    def __len__(self) -> int:\n        return len(self.roster)\n\n    def __contains__(self, __x: RosterLocation) -> bool:\n        return __x in self.roster\n\n\n    async def append(self, roster_location: RosterLocation):\n        self.roster.append(roster_location)\n        if self.roster_begins_at == 0:\n            self.roster_begins_at = 1\n        await self.update()\n\n    async def add_location(self, roster_location):\n        await self.append(roster_location)\n\n    def remove_location(self, location_number):\n        self.__delitem__(location_number)\n\n    async def move(self):\n        if self.empty:\n            raise ValueError(\"No next location available on the roster!\")\n        self.remove_location(self.roster_begins_at)\n        self.roster_begins_at += 1\n        await self.update()\n\n    async def reset(self):\n        self.roster = []\n        self.roster_begins_at = 0\n        await self.update()\n\n    async def embed(self):\n        return (RaidPartyEmbed.from_raid_party(self)).embed\n\n    @property\n    def guild(self) -> discord.Guild:\n        return self.bot.get_guild(self.guild_id)\n\n    @property\n    def channel(self):\n        return self.guild.get_channel(self.channel_id)\n\n\n    def to_dict(self):\n        \"\"\"Returns the raid_dict column value for the raid\"\"\"\n        state_dict = {\n            'raid_type' : self.raid_type,\n            'author_id': self.author_id,\n            'response_message_id' : self.response_message_id,\n            'report_channel_id' : self.report_channel_id,\n            'timezone': self.timezone,\n            'city' : self.city,\n            'roster_begins_at': self.roster_begins_at,\n            'roster': [rl.to_dict() for rl in self.roster],\n        }\n\n        if len(self.trainer_dict) > 0:\n            state_dict['trainer_dict'] = self.trainer_dict\n\n        return state_dict\n\n    def __setstate__(self, state):\n        return None\n\n\n    def get_state(self):\n        \"\"\"Returns the DB representation of the raid report\"\"\"\n        state = self.to_dict()\n        db_state = {\n            'raid_party_id': self.id,\n            'guild_id': self.guild_id,\n            'channel_id': self.channel_id,\n            'raid_party_dict': json.dumps(state)\n        }\n        return db_state\n\n\n    @classmethod\n    def cache(cls, raid_party):\n        cls.by_channel[raid_party.channel_id] = raid_party\n        cls.by_id[raid_party.id] = raid_party\n\n    @classmethod\n    def evict(cls, raid_party):\n        cls.by_channel.pop(raid_party.channel_id, None)\n        cls.by_id.pop(raid_party.id, None)\n\n    @classmethod\n    async def from_cache(cls, ctx, raid_id=None):\n        if raid_id:\n            raid = cls.by_id.get(raid_id, None)\n            if not raid:\n                RaidRepository.set_dbi(ctx.bot.dbi)\n                raid_from_db = await RaidRepository.find_raid_by_id(raid_id)\n                raid = await Raid.from_db_dict(ctx.bot, raid_from_db)\n                if not raid:\n                    return None\n                return raid\n        else:\n            raid = cls.by_channel.get(ctx.channel.id, None)\n            if not raid:\n                RaidRepository.set_dbi(ctx.bot.dbi)\n                raid_from_db = await RaidRepository.find_raid_for_channel(ctx.guild.id, ctx.channel.id)\n                raid = await Raid.from_db_dict(ctx.bot, raid_from_db)\n                if not raid:\n                    return None\n                return raid\n\n\n    @classmethod\n    async def from_db_dict(cls, bot, db_dict):\n        \"\"\"\n        :param bot:\n        :param db_dict:\n        :return: Raid object, also caches the object\n        \"\"\"\n        guild_id, channel_id, raid_party_id, raid_party_dict_text \\\n            = [db_dict.get(attr, None) for attr in ['guild_id', 'channel_id', 'raid_party_id', 'raid_party_dict']]\n\n        raid_party_dict = json.loads(raid_party_dict_text)\n\n        roster_dict, trainer_dict = [raid_party_dict.get(attr, {}) for attr in\n               ['roster', 'trainer_dict']]\n\n        roster_dict = json.loads(roster_dict) if isinstance(roster_dict, str) else roster_dict\n\n        roster = [await RosterLocation.from_dict(bot, rl) for rl in roster_dict]\n\n        p_raid_type, p_author_id, p_response_message_id, p_report_channel_id, p_timezone, p_city, p_roster_begins_at = [raid_party_dict.get(attr, None) for attr in\n                                                 ['raid_type', 'author_id', 'response_message_id', 'report_channel_id', 'timezone', 'city', 'roster_begins_at']]\n\n        raid_party = RaidParty(raid_party_id=raid_party_id, bot=bot, guild_id=guild_id, channel_id=channel_id,\n                    author_id=p_author_id, response_message_id=p_response_message_id, report_channel_id=p_report_channel_id, timezone=p_timezone, city=p_city,\n                    roster=roster, roster_begins_at=p_roster_begins_at, trainer_dict=trainer_dict)\n\n        RaidParty.cache(raid_party)\n        return raid_party\n\n    @property\n    def cuid(self):\n        return CUIDGenerator.cuid(self.id)\n\n\n    def __str__(self):\n        value = f\"{self.cuid}\"\n        return value\n\n\n\n\n    async def insert(self):\n        raid_table = self.bot.dbi.table('raid_party_report')\n        raid_table_insert = raid_table.insert(**self.get_state())\n        await raid_table_insert.commit()\n        RaidParty.cache(raid_party=self)\n\n\n    async def update(self):\n        raid_table = self.bot.dbi.table('raid_party_report')\n        raid_table_update = raid_table.update(raid_party_dict=json.dumps(self.to_dict())).where(raid_party_id=self.id)\n        await raid_table_update.commit()\n        RaidParty.cache(raid_party=self)\n        # await self.update_messages()\n        Logger.info(f\"[{self.cuid}] => raid_party update() finished!\")\n\n    async def delete(self):\n        \"\"\"Deletes the raid record from DB and evicts from cache.\"\"\"\n        raid_table = self.bot.dbi.table('raid_party_report')\n        raid_table_delete = raid_table.query().where(raid_party_id=self.id)\n        self.bot.loop.create_task(raid_table_delete.delete())\n        RaidParty.evict(raid_party=self)\n        Logger.info(f\"[{self.cuid}] => raid delete() finished!\")\n\n    async def add_rsvp(self, member_id: str, status, count=None):\n\n        member_id = str(member_id)\n        if not count:\n            count = 1\n\n        self.trainer_dict = self.trainer_dict or {}\n\n        self.trainer_dict.setdefault(member_id, {})\n        self.trainer_dict[member_id]['status'] = status\n        self.trainer_dict[member_id]['count'] = count\n\n        await self.update()\n\n\n    async def cancel_rsvp(self, member_id: str):\n        member_id = str(member_id)\n        member = self.trainer_dict.pop(member_id, None)\n        await self.update()\n        return member\n\n\n    def validate_count(self, count_value):\n\n        try:\n            count = int(count_value)\n        except Exception as error:\n            raise ValueError(\n                \"I can't understand how many are in your group, please use a number to specify the party size.\")\n\n        if 1 <= count <= 20:\n            return count\n        else:\n            raise ValueError(\"Group size is limited between 1-20.\")\n\n\n    USERS_PATTERN = '<@!?(\\d{17,19})>'\n\n    @staticmethod\n    def from_mention(text: str):\n        new_text = text.replace(\"<\",\"\").replace(\">\",\"\").replace(\"!\",\"\").replace(\"@\",\"\")\n        return new_text\n\n\n    async def handle_rsvp(self, message, status):\n        \"\"\"\n        '!x <@!415421645214449664> <@!159985870458322944> <@!289657500167438336> 5'\n        \"\"\"\n\n        arguments = message.content.split()[1:]\n        party_status = {}\n        mention_count_dict = {}\n\n        if len(arguments) == 0:\n            party_status[str(message.author.mention)] = 1\n        elif message.mentions:\n            # create a dictionary like a, 1, b, c, 2 => { a: 1, 1: 1, b: 1, c: 2}\n\n            words = iter(arguments)\n            word = next(words)\n\n            while word:\n                try:\n                    prev_word = word\n                    word = next(words)\n                    if word.isdigit():\n                        mention_count_dict[prev_word] = int(word)\n                    else:\n                        mention_count_dict[prev_word] = 1\n                except StopIteration:\n                    mention_count_dict[prev_word] = 1\n                    break\n\n            # only leave mention_id in keys, discard other elements of dictionary\n            party_status =  { key: mention_count_dict[key] for key in mention_count_dict.keys() if re.search(self.USERS_PATTERN, key) }\n\n        elif len(arguments) == 1:\n            party_status[str(message.author.mention)] = self.validate_count(arguments[0])\n\n\n        try:\n            Logger.info(party_status)\n            total_trainer_rsvp = 0\n            if status == 'x':\n                for mention, party_size in party_status.items():\n                    removed_user = await self.cancel_rsvp(member_id=Raid.from_mention(mention))\n                    if removed_user is None:\n                        embed_msg = f\"{mention} had no status to cancel.\"\n                        await Embeds.error(message.channel, embed_msg)\n                    else:\n                        embed_msg = f\"{mention}'s status has been cancelled.\"\n                        await Embeds.message(message.channel, embed_msg)\n                embed_msg = \"\"\n            else:\n                for user_id, party_size in party_status.items():\n                    await self.add_rsvp(member_id=Raid.from_mention(user_id), status=status, count=party_size)\n                    total_trainer_rsvp += party_size\n\n                with_trainers = \"\" if total_trainer_rsvp == 1 else \" with a total of {trainer_count} trainers\".format(trainer_count=total_trainer_rsvp)\n                is_or_are = \"is\" if len(party_status) == 1 else \"are\"\n                embed_msg = f\"{', '.join([mention for mention in party_status.keys()])} {is_or_are} {_.get(RSVPEnabled.STATUS_MESSAGE, f'{status}.message')}{with_trainers}\"\n\n            await self.send_rsvp_embed(message, description=embed_msg, options=self.embed_options)\n\n        except ValueError as value_error:\n            await Embeds.error(message.channel, f\"{value_error}\", user=message.author)\n\n        except Exception as error:\n            Logger.info(error)\n\n\n    async def send_rsvp_embed(self, message, description=None, options=['rsvp', 'i', 'c', 'h']):\n\n        return await message.channel.send(embed=await self.rsvp_embed_by_options(message, options=options,\n                                                                           description=description))\n\n    def size_by_status(self, status):\n        count = 0\n\n        for trainer in self.trainer_dict.values():\n            if trainer['status'] == status:\n                count += int(trainer['count'])\n\n        return count\n\n\n\n    async def handle_group_start(self):\n\n        users_starting = {}\n\n        for trainer_id in self.trainer_dict:\n            if self.trainer_dict[trainer_id]['status'] in [\"h\", \"hr\", \"ir\"]:\n                trainer = self.bot.get_user(int(trainer_id))\n                users_starting[trainer_id] = trainer.mention\n\n        if len(users_starting) > 0:\n            embed_message = f\"The group of trainers waiting at location {self.current_location_index} are starting. Trainers {', '.join(users_starting.values())}, please make sure you sync-up with other players.\"\n            await Embeds.message(self.channel, description=embed_message)\n        else:\n            embed_message = f\"How can you start when there is nobody waiting at the location?\"\n            await Embeds.error(self.channel, description=embed_message)\nclembot/core/logs.py\ndef init_loggers():\nclembot/config/constants.py\nclass MyEmojis:\n\n    DESPAWNED = '💨'\n    ON_MY_WAY = '🏎️'\n    TRASH = '🗑️'\n\n    REMOTE = f\"{parse_emoji(None, config_template.misc_emoji.get('remote_raid'))}\"\n    INVITE = f\"{parse_emoji(None, config_template.misc_emoji.get('add_friend'))}\"\n    HERE = f\"{parse_emoji(None, config_template.misc_emoji.get('here'))}\"\n    COMING = f\"{parse_emoji(None, config_template.misc_emoji.get('coming'))}\"\n    INTERESTED = f\"{parse_emoji(None, config_template.misc_emoji.get('interested'))}\"\n    INFO = f\"{parse_emoji(None, config_template.misc_emoji.get('info'))}\"\n    ERROR = f\"{parse_emoji(None, config_template.misc_emoji.get('error'))}\"\n    POKE_BATTLER = f\"{parse_emoji(None, config_template.misc_emoji.get('pb'))}\"\nclembot/core/bot.py\ndef group(*args, **kwargs):\n    def decorator(func):\n        category = kwargs.get(\"category\")\n        func.command_category = category\n        examples = kwargs.get(\"examples\")\n        func.examples = examples\n        error_wrapped_func = wrap_error(func)\n        result = commands.group(*args, **kwargs)(error_wrapped_func)\n        return result\n    return decorator\nclembot/exts/raid/raid.py\nclass ChannelMessage:\n    \"\"\"Represents a message identifier (channel_id, message_id)\"\"\"\n\n    @classmethod\n    def from_message(cls, message):\n        \"\"\"returns channel_id-message_id\"\"\"\n        return f\"{message.channel.id}-{message.id}\"\n\n    @classmethod\n    async def from_id(cls, bot, channel_id, message_id):\n\n        channel = bot.get_channel(channel_id)\n\n        if channel is None:\n            return None, None\n\n        try:\n            message = await channel.fetch_message(message_id)\n        except Exception as error:\n            Logger.error(f\"{channel_id} {message_id} {error}\")\n            return channel, None\n\n        return channel, message\n\n\n    @classmethod\n    async def from_text(cls, bot, arg):\n        \"\"\"returns Channel & Message from - separated IDs\"\"\"\n        channel_id, message_id = [int(a) for a in arg.split('-')]\n\n        channel = bot.get_channel(channel_id)\n        if not channel:\n            return None, None\n\n        try:\n            message = await channel.fetch_message(message_id)\n        except Exception as error:\n            Logger.info(f\"{channel_id} => {channel}\")\n            return channel, None\n\n        return channel, message\n\n    @classmethod\n    def split_parts(cls, arg):\n        \"\"\"returns Channel & Message from - separated IDs\"\"\"\n        channel_id, message_id = [int(a) for a in arg.split('-')]\n        return channel_id, message_id\nclembot/exts/raid/raid_checks.py\ndef _is_raid_channel(ctx):\ndef _is_raid_party_channel(ctx):\ndef _is_rsvp_enabled(ctx):\ndef raid_channel():\ndef raid_party_channel():\ndef rsvp_enabled():\nclembot/core/checks.py\nclass AccessDenied(CommandError):\n    pass\nclembot/exts/raid/raid.py\nclass RaidRepository:\n    _dbi = None\n\n    def __init__(self):\n        pass\n\n    @classmethod\n    def set_dbi(cls, dbi):\n        cls._dbi = dbi\n\n    @classmethod\n    async def find_raid_for_channel(cls, guild_id, channel_id):\n        raid_table = cls._dbi.table('raid_report')\n        raid_table_query = raid_table.query().select().where(guild_id=guild_id, channel_id=channel_id)\n        list_of_raids = await raid_table_query.getjson()\n        return list_of_raids[0]\n\n    @classmethod\n    async def find_raid_by_id(cls, raid_report_id):\n        raid_table = cls._dbi.table('raid_report')\n        raid_table_query = raid_table.query().select().where(raid_report_id=raid_report_id)\n        list_of_raids = await raid_table_query.getjson()\n        return list_of_raids[0]\n\n\n    @classmethod\n    async def find_raids(cls):\n        raid_table = cls._dbi.table('raid_report')\n        raid_table_query = raid_table.query().select()\n        list_of_raids = await raid_table_query.getjson()\n\n        list_of_raids = [raid for raid in list_of_raids if raid.get('guild_id', None) == (config_template.development_guild_id if config_template.development_guild_id is not None else raid.get('guild_id', None))]\n\n        return list_of_raids\n\n    @classmethod\n    async def find_raid_parties(cls):\n        raid_table = cls._dbi.table('raid_party_report')\n        raid_table_query = raid_table.query().select()\n        list_of_raids = await raid_table_query.getjson()\n        return list_of_raids\n\n    @classmethod\n    async def find_raids_reported_in_channel(cls, bot, channel_id):\n\n        query = raids_reported_in_channel_query\n        query_args = [str(channel_id)]\n        raid_list = await bot.dbi.execute_query_json(query, *query_args)\n        print(raid_list)\n\n        raid_id_list = [record.get('raid_id') for record in raid_list]\n        print(raid_id_list)\n\n\n        return raid_id_list\n", "answers": ["    @raid_checks.raid_party_channel()"], "length": 4185, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "b8d1b721ddc2769721908c5b5946467ad861ecb680ea5a67"}
{"input": "from datetime import datetime\nfrom django.test import TestCase\nfrom django.utils import timezone\nfrom freezegun import freeze_time\nfrom mock import patch\nfrom modules.utils import quote, phone_number_is_valid, remove_nondigit_characters, \\\n                                add_country_code_to_phone_number, prepare_phone_number, \\\n                                keywords_without_word, is_not_ascii\nfrom modules.date_helper import date_string_to_date, date_is_valid, \\\n                                date_to_date_string, date_string_dmy_to_date, \\\n                                date_string_mdy_to_date, date_string_ymd_to_date, \\\n                                try_parsing_partner_date, try_parsing_gen_date, \\\n                                datetime_string_mdy_to_datetime, datetime_string_ymd_to_datetime\nfrom modules.i18n import hindi_information, hindi_remind, hindi_born, \\\n                            subscribe_keywords, six_week_reminder_seven_days, \\\n                            six_week_reminder_one_day, ten_week_reminder_seven_days, \\\n                            ten_week_reminder_one_day, fourteen_week_reminder_seven_days, \\\n                            fourteen_week_reminder_one_day, nine_month_reminder_seven_days, \\\n                            nine_month_reminder_one_day, sixteen_month_reminder_seven_days, \\\n                            sixteen_month_reminder_one_day, five_year_reminder_seven_days, \\\n                            five_year_reminder_one_day, verify_pregnant_signup_birthdate, \\\n                            msg_subscribe, msg_unsubscribe, msg_already_sub, msg_failure, \\\n                            msg_failed_date\nfrom six import u\n\n\nFAKE_NOW = datetime(2017, 12, 1, 15, 10, 3)\n\nclass QuoteTests(TestCase):\n    def test_quote(self):\n        self.assertEqual(quote(\"text\"), \"`text`\")\n\n    def test_quote_with_a_float(self):\n        self.assertEqual(quote(2.0), \"`2.0`\")\n\n\nclass DateIsValidTests(TestCase):\n    def test_normal_date(self):\n        self.assertTrue(date_is_valid(\"25/11/2015\"))\n        self.assertTrue(date_is_valid(\"11/12/2012\"))\n        self.assertTrue(date_is_valid(\"09/02/2001\"))\n\n    def test_short_year_date(self):\n        self.assertTrue(date_is_valid(\"25/11/15\"))\n        self.assertTrue(date_is_valid(\"11/12/12\"))\n        self.assertTrue(date_is_valid(\"09/02/01\"))\n\n    def test_hypen_separated_date(self):\n        self.assertTrue(date_is_valid(\"25-11-2015\"))\n        self.assertTrue(date_is_valid(\"11-12-2012\"))\n        self.assertTrue(date_is_valid(\"09-02-2001\"))\n\n    def test_one_digit_date(self):\n        self.assertTrue(date_is_valid(\"05-05-2015\"))\n        self.assertTrue(date_is_valid(\"09-02-2001\"))\n        self.assertTrue(date_is_valid(\"05-5-2015\"))\n        self.assertTrue(date_is_valid(\"09-2-2001\"))\n        self.assertTrue(date_is_valid(\"5-05-2015\"))\n        self.assertTrue(date_is_valid(\"5-05-2015\"))\n        self.assertTrue(date_is_valid(\"9-2-2001\"))\n        self.assertTrue(date_is_valid(\"9-2-2001\"))\n        \n    def test_leap_year_dates(self):\n        self.assertTrue(date_is_valid(\"29/02/2012\"))\n        self.assertFalse(date_is_valid(\"29/02/2013\"))\n        self.assertTrue(date_is_valid(\"29/02/2016\"))\n        self.assertFalse(date_is_valid(\"29/02/2017\"))\n\n    def test_reject_bogus_dates(self):\n        self.assertFalse(date_is_valid(\"Bogus\"))\n        self.assertFalse(date_is_valid(\"00/00/00\"))\n        self.assertFalse(date_is_valid(\"31/02/2015\"))\n        self.assertFalse(date_is_valid(\"43/11/2015\"))\n\n    def test_reject_mm_dd_dates(self):\n        self.assertFalse(date_is_valid(\"11-25-2015\"))\n        self.assertFalse(date_is_valid(\"31/06/2017\"))\n        self.assertFalse(date_is_valid(\"29/02/2017\"))\n        self.assertFalse(date_is_valid(\"15/15/2015\"))\n    \n    def test_reject_too_far_in_future(self):\n        self.assertFalse(date_is_valid(\"25/11/2133\"))\n    \n    def test_reject_too_far_in_past(self):\n        self.assertFalse(date_is_valid(\"11/12/1991\"))\n\n\nclass DateStringToDateTests(TestCase):\n    def test_date_strings_get_converted_to_dates(self):\n", "context": "modules/i18n.py\ndef subscribe_keywords(language):\n    if language == \"English\":\n        return [\"remind\", \"join\", \"born\"]\n    elif language == \"Hindi\":\n        return [hindi_remind(), hindi_information(), hindi_born()]\n    else:\n        return []\nmodules/utils.py\ndef remove_nondigit_characters(phone_number):\n\treturn re.sub(\"[^0-9]\", \"\", phone_number)\nmodules/i18n.py\ndef hindi_remind():\n    return u'\\u0938\\u094d\\u092e\\u0930\\u0923'\nmodules/date_helper.py\ndef date_to_date_string(date):\n    return '{d}/{m}/{y}'.format(d = date.day,\n                                m = date.month,\n                                y = date.year)\nmodules/date_helper.py\ndef datetime_string_mdy_to_datetime(date_string):\n\treturn  datetime_from_date_string(date_string, \"%m/%d/%Y %I:%M:%S %p\").replace(tzinfo=timezone.get_default_timezone())\nmodules/date_helper.py\ndef date_string_dmy_to_date(date_string):\n\tfor fmt in [\"%d-%m-%Y\", \"%d/%m/%Y\"]:\n\t\ttry:\n\t\t\treturn  datetime_from_date_string(date_string, fmt).date()\n\t\texcept ValueError:\n\t\t\tpass\n\traise ValueError(\"No valid day-month-year date format\")\nmodules/date_helper.py\ndef date_string_to_date(date_string):\n    sep = \"-\" if \"-\" in date_string else \"/\"\n    if len(date_string.split(sep)) < 3:\n        raise ValueError()\n    year = \"%Y\" if len(date_string.split(sep)[2]) == 4 else \"%y\"\n    pattern = \"%d\" + sep + \"%m\" + sep + year\n    return datetime.strptime(date_string, pattern).date()\nmodules/utils.py\ndef phone_number_is_valid(phone_number):\n    \"\"\"Match any number starting with 91 or +91 that has another\n        9 to 15 digits\"\"\"\n    pattern = '^\\+?91?\\d{9,15}$'\n    prepared_phone_number = prepare_phone_number(phone_number)\n    return re.match(pattern, prepared_phone_number)\nmodules/date_helper.py\ndef date_string_ymd_to_date(date_string):\n\tfor fmt in [\"%Y-%m-%d\", \"%Y/%m/%d\"]:\n\t\ttry:\n\t\t\treturn datetime_from_date_string(date_string, fmt).date()\n\t\texcept ValueError:\n\t\t\tpass\n\traise ValueError(\"No valid year-month-day date format\")\nmodules/utils.py\ndef keywords_without_word(language, word):\n\tnew_keys = subscribe_keywords(language)\n\tif word in new_keys:\n\t\tnew_keys.remove(word)\n\treturn new_keys\nmodules/date_helper.py\ndef try_parsing_gen_date(date_string):\n\ttry:\n\t    return date_string_ymd_to_date(date_string)\n\texcept ValueError:\n\t\treturn date_string_mdy_to_date(date_string)\nmodules/i18n.py\ndef fourteen_week_reminder_one_day(language):\n    if language == \"English\":\n        return \"Your child is eligible to receive a free course of vaccines. {name} has their scheduled vaccination tomorrow.\"\n    elif language == \"Hindi\":\n        return u'1 \\u0926\\u093f\\u0928 \\u092e\\u0947\\u0902 {name} \\u0915\\u0940 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901 \\u090f\\u0935\\u0902 \\u0916\\u093c\\u0924\\u0930\\u0928\\u093e\\u0915 \\u092c\\u0940\\u092e\\u093e\\u0930\\u093f\\u0913\\u0902 \\u0938\\u0947 \\u092c\\u091a\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'\\u0aa1\\u0ac9\\u0a95\\u0acd\\u0a9f\\u0ab0\\u0ac9 \\u0a8f \\u0ae7 \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae\\u0abe\\u0a82  {name} \\u0aa8\\u0ac7 \\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aae\\u0abe\\u0a9f\\u0ac7 \\u0ab8\\u0ac2\\u0a9a\\u0ab5\\u0acd\\u0aaf\\u0ac1 \\u0a9b\\u0ac7.'\nmodules/i18n.py\ndef msg_unsubscribe(language):\n    if language == \"English\":\n        return \"You have been unsubscribed from CSH health reminders.\"\n    elif language == \"Hindi\":\n        return u'\\u0906\\u092a\\u0915\\u0940 \\u0938\\u0926\\u0938\\u094d\\u092f\\u0924\\u093e \\u0938\\u092e\\u093e\\u092a\\u094d\\u0924 \\u0915\\u0930 \\u0926\\u0940 \\u0917\\u092f\\u0940 \\u0939\\u0948.'\nmodules/i18n.py\ndef nine_month_reminder_one_day(language):\n    return six_week_reminder_one_day(language)\nmodules/i18n.py\ndef sixteen_month_reminder_one_day(language):\n    return ten_week_reminder_one_day(language)\nmodules/i18n.py\ndef ten_week_reminder_one_day(language):\n    if language == \"English\":\n        return \"{name} is due for their important vaccinations tomorrow. Please do so then.\"\n    elif language == \"Hindi\":\n        return u'\\u091c\\u093c\\u093f\\u092e\\u094d\\u092e\\u0947\\u0926\\u093e\\u0930 \\u092e\\u093e\\u0924\\u093e \\u0939\\u094b\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u0906\\u092a\\u0915\\u094b \\u092c\\u0927\\u093e\\u0908. 1 \\u0926\\u093f\\u0928 \\u092e\\u0947\\u0902 {name} \\u0915\\u0947 \\u091c\\u093c\\u0930\\u0942\\u0930\\u0940 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u0906\\u092a \\u0938\\u0947 \\u092e\\u0941\\u0932\\u093e\\u0915\\u093c\\u093e\\u0924 \\u0939\\u094b\\u0917\\u0940.'\n    elif language == \"Gujarati\":\n        return u'{name} \\u0aa8 \\u0ac1\\u0a82\\u0ae7 \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae \\u0ac1\\u0a82\\u0aae\\u0ab9\\u0aa4\\u0acd\\u0ab5\\u0aaa\\u0ac2\\u0aa3\\u0aa3\\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aa6\\u0aa8\\u0aaf\\u0aa4 \\u0a9b\\u0ac7. \\u0aa4\\u0acb \\u0a95\\u0ac3\\u0aaa \\u0a95\\u0ab0\\u0ac0\\u0ac1\\u0a82\\u0aa8\\u0ac7\\u0aaa\\u0a9b\\u0ac0 \\u0a8f \\u0a95\\u0ab0\\u0a9c\\u0acb.'\nmodules/date_helper.py\ndef date_string_mdy_to_date(date_string):\n\tfor fmt in [\"%m-%d-%Y\", \"%m/%d/%Y\"]:\n\t\ttry:\n\t\t\treturn  datetime_from_date_string(date_string, fmt).date()\n\t\texcept ValueError:\n\t\t\tpass\n\traise ValueError(\"No valid month-day-year date format\")\nmodules/i18n.py\ndef msg_already_sub(language):\n    if language == \"English\":\n        return \"You are already registered to receive CSH health reminders.\"\n    elif language == \"Hindi\":\n        return u'\\u0906\\u092a \\u092a\\u0939\\u0932\\u0947 \\u0938\\u0947 \\u0939\\u0940 \\u0938\\u0940.\\u090f\\u0938.\\u091a \\u0938\\u094d\\u0935\\u093e\\u0938\\u094d\\u0925\\u094d\\u092f \\u0938\\u094d\\u092e\\u0930\\u0923 \\u092a\\u094d\\u0930\\u093e\\u092a\\u094d\\u0924 \\u0915\\u0930\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u092a\\u0902\\u091c\\u0940\\u0915\\u0943\\u0924 \\u0939\\u0948\\u0902.'\nmodules/utils.py\ndef prepare_phone_number(phone_number):\n\tif phone_number == None:\n\t\treturn \"\"\n\tstripped_phone_number = remove_nondigit_characters(phone_number)\n\tif stripped_phone_number == \"0\" * len(stripped_phone_number):\n\t\treturn \"\"\n\telif len(stripped_phone_number) < 10:\n\t\treturn phone_number\n\treturn add_country_code_to_phone_number(stripped_phone_number)\nmodules/i18n.py\ndef six_week_reminder_one_day(language):\n    if language == \"English\":\n        return \"{name} is due for their important vaccinations tomorrow. Please do so then.\"\n    elif language == \"Hindi\":\n        return u'\\u0905\\u0917\\u0932\\u0947 1 \\u0926\\u093f\\u0928 \\u092e\\u0947\\u0902 {name} \\u0915\\u0940 \\u091c\\u093c\\u0930\\u0942\\u0930\\u0940 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0905\\u0935\\u0936\\u094d\\u092f \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'{name} \\u0aa8 \\u0ac1\\u0a82\\u0ae7 \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae \\u0ac1\\u0a82\\u0aae\\u0ab9\\u0aa4\\u0acd\\u0ab5\\u0aaa\\u0ac2\\u0aa3\\u0aa3\\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aa6\\u0aa8\\u0aaf\\u0aa4 \\u0a9b\\u0ac7. \\u0aa4\\u0acb \\u0a95\\u0ac3\\u0aaa \\u0a95\\u0ab0\\u0ac0\\u0ac1\\u0a82\\u0aa8\\u0ac7\\u0aaa\\u0a9b\\u0ac0 \\u0a8f \\u0a95\\u0ab0\\u0a9c\\u0acb.'\nmodules/i18n.py\ndef six_week_reminder_seven_days(language):\n    if language == \"English\":\n        return \"{name} has their scheduled vaccination in 7 days. Without this vaccination your child will be vulnerable to deadly diseases.\"\n    elif language == \"Hindi\":\n        return u'7 \\u0926\\u093f\\u0928\\u094b\\u0902 \\u092e\\u0947\\u0902 {name} \\u0915\\u093e \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901 \\u090f\\u0935\\u0902 \\u0916\\u093c\\u0924\\u0930\\u0928\\u093e\\u0915 \\u092c\\u0940\\u092e\\u093e\\u0930\\u093f\\u0913\\u0902 \\u0938\\u0947 \\u092c\\u091a\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'{name} \\u0aa8 \\u0ac1\\u0a82\\u0aed \\u0aa6\\u0abf\\u0ab5\\u0ab8 \\u0aae \\u0ac1\\u0aa8 \\u0ac1\\u0a82\\u0aed \\u0aa6\\u0abf\\u0ab5\\u0ab8 \\u0aae \\u0ac1\\u0a82\\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0ab8 \\u0aa6\\u0aa8\\u0aa6\\u0abf\\u0aa4 \\u0a9b\\u0ac7. \\u0a86 \\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0ab5\\u0a97\\u0ab0 \\u0aa4\\u0aae \\u0ab0\\u0ac1\\u0a82 \\u0aac \\u0ab3\\u0a95 \\u0a9c\\u0ac0\\u0ab5\\u0ab2\\u0ac7\\u0aa3 \\u0ab0\\u0acb\\u0a97\\u0acb \\u0aae \\u0a9f\\u0ac7\\u0ab8\\u0ac1\\u0a82\\u0ab5\\u0ac7\\u0abf\\u0aa8\\u0ab6\\u0ac0\\u0ab2 \\u0ab0\\u0ab9\\u0ac7\\u0ab6\\u0ac7.'\nmodules/i18n.py\ndef msg_subscribe(language):\n    if language == \"English\":\n        return \"{name} has been subscribed to CSH health reminders. Text END to \" + TEXTLOCAL_PHONENUMBER + \" to unsubscribe.\"\n    elif language == \"Hindi\":\n        return u'{name} \\u0938\\u0940 \\u090f\\u0938 \\u090f\\u091a \\u0939\\u0947\\u0932\\u094d\\u0925 \\u0905\\u0928\\u0941\\u0938\\u094d\\u092e\\u0930\\u0928 \\u0915\\u0947 \\u0938\\u0926\\u0938\\u094d\\u092f \\u0939\\u0948\\u0902. \\u0938\\u0926\\u0938\\u094d\\u092f\\u0924\\u093e \\u0930\\u0926\\u094d\\u0926 \\u0915\\u0930\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u0932\\u093f\\u0916\\u0947\\u0902 \"END\" \\u0914\\u0930 \\u092d\\u0947\\u0902\\u091c \\u0926\\u0947 ' + TEXTLOCAL_PHONENUMBER + u' \\u092a\\u0930.'\nmodules/i18n.py\ndef sixteen_month_reminder_seven_days(language):\n    return ten_week_reminder_seven_days(language)\nmodules/i18n.py\ndef ten_week_reminder_seven_days(language):\n    if language == \"English\":\n        return \"{name} is eligible for a free vaccination in 7 days. Without this vaccination your child will be vulnerable to deadly diseases.\"\n    elif language == \"Hindi\":\n        return u'7 \\u0926\\u093f\\u0928\\u094b\\u0902 \\u092e\\u0947\\u0902 {name} \\u0915\\u0940 \\u0928\\u093f\\u0903\\u0936\\u0941\\u0932\\u094d\\u0915 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901 \\u090f\\u0935\\u0902 \\u0916\\u093c\\u0924\\u0930\\u0928\\u093e\\u0915 \\u092c\\u0940\\u092e\\u093e\\u0930\\u093f\\u0913\\u0902 \\u0938\\u0947 \\u092c\\u091a\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'{name} \\u0aed \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae \\u0ac1\\u0a82\\u0aae\\u0aab\\u0aa4 \\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aae \\u0a9f\\u0ac7\\u0aaa \\u0aa4\\u0acd\\u0ab0 \\u0a9b\\u0ac7. \\u0a86 \\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0ab5\\u0a97\\u0ab0 \\u0aa4\\u0aae \\u0ab0\\u0ac2 \\u0aac \\u0ab3\\u0a95 \\u0a9c\\u0ac0\\u0ab5\\u0ab2\\u0ac7\\u0aa3 \\u0ab0\\u0acb\\u0a97\\u0acb \\u0aae \\u0a9f\\u0ac7\\u0ab8\\u0ac1\\u0a82\\u0ab5\\u0ac7\\u0abf\\u0aa8\\u0ab6\\u0ac0\\u0ab2 \\u0ab0\\u0ab9\\u0ac7\\u0ab6\\u0ac7.'\nmodules/utils.py\ndef quote(word):\n    return u\"`{}`\".format(word)\nmodules/i18n.py\ndef five_year_reminder_one_day(language):\n    return fourteen_week_reminder_one_day(language)\nmodules/i18n.py\ndef fourteen_week_reminder_seven_days(language):\n    if language == \"English\":\n        return \"Thank you for being a responsible mother. {name} is due for their important vaccinations in 7 days. Please do so then.\"\n    elif language == \"Hindi\":\n        return u'{name} \\u0915\\u0947 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 7 \\u0926\\u093f\\u0928\\u094b\\u0902 \\u092e\\u0947\\u0902 \\u0905\\u0935\\u0936\\u094d\\u092f \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'\\u0a8f\\u0a95 \\u0a9c\\u0ab5 \\u0aac\\u0abf \\u0ab0 \\u0aae \\u0aa4 \\u0ab9\\u0acb\\u0ab5 \\u0aac\\u0abf\\u0ab2 \\u0aa7\\u0aa8\\u0acd\\u0aaf\\u0ab5 \\u0abf. {name} \\u0aa8 \\u0ac1\\u0a82\\u0aed \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae \\u0ac1\\u0a82\\u0aae\\u0ab9\\u0aa4\\u0acd\\u0ab5\\u0aaa\\u0ac2\\u0aa3\\u0aa3\\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aa6\\u0aa8\\u0aaf\\u0aa4 \\u0a9b\\u0ac7. \\u0aa4\\u0acb \\u0a95\\u0ac3\\u0aaa \\u0a95\\u0ab0\\u0ac0\\u0ac1\\u0a82\\u0aa8\\u0ac7\\u0aaa\\u0a9b\\u0ac0 \\u0a8f \\u0a95\\u0ab0\\u0a9c\\u0acb.'\nmodules/i18n.py\ndef hindi_born():\n    return u'\\u091c\\u0928\\u094d\\u092e'\nmodules/i18n.py\ndef verify_pregnant_signup_birthdate(language):\n    if language == \"English\":\n        return \"You signed up for health reminders while pregnant. If your child has been born, text 'BORN Name DD-MM-YY' to \"+ TEXTLOCAL_PHONENUMBER + \" to register for  English. An example message is 'BORN Aarav 14-01-17' where 'Aarav' is your child's first name and '14-01-17' is your child's birthday.\"\n    elif language == \"Hindi\":\n        return u'\\u0905\\u092a\\u0928\\u0940 \\u0917\\u0930\\u094d\\u092d\\u093e\\u0935\\u0938\\u094d\\u0920\\u093e \\u0915\\u0947 \\u0926\\u094c\\u0930\\u093e\\u0928 \\u0906\\u092a\\u0928\\u0947 \\u0938\\u094d\\u0935\\u093e\\u0938\\u094d\\u0925\\u094d\\u092f \\u0938\\u094d\\u092e\\u0930\\u0923 \\u0915\\u0940 \\u0938\\u0926\\u0938\\u094d\\u092f\\u0924\\u093e \\u0932\\u0940 \\u0925\\u0940. \\u092f\\u0926\\u093f \\u0906\\u092a\\u0915\\u093e \\u092c\\u091a\\u094d\\u091a\\u093e \\u091c\\u0928\\u094d\\u092e \\u0932\\u0947 \\u091a\\u0942\\u0915\\u093e \\u0939\\u0948 \\u0924\\u094b \\u0932\\u093f\\u0916\\u0947 \\u201c \\u091c\\u0928\\u094d\\u092e \\u0928\\u093e\\u092e DD-MM-YY \\u201d \\u0914\\u0930 \\u092d\\u0947\\u0902\\u091c \\u0926\\u0947 \\u201c ' + TEXTLOCAL_PHONENUMBER + u' \\u201d \\u092a\\u0930 \\u0939\\u093f\\u0902\\u0926\\u0940 \\u092e\\u0947\\u0902 \\u092a\\u0902\\u091c\\u0940\\u0915\\u0930\\u0923 \\u0915\\u0947 \\u0932\\u093f\\u090f.'\nmodules/utils.py\ndef is_not_ascii(message):\n\treturn any(ord(char) >= 128 for char in message)\nmodules/i18n.py\ndef msg_failed_date(language):\n    if language == \"English\":\n        return \"Sorry, the date format was incorrect. An example message is 'Remind Sai 14-01-17' where 'Sai' is your child's first name and '14-01-17'' is their birthday.\"\n    elif language == \"Hindi\":\n        return u'\\u0915\\u094d\\u0937\\u092e\\u093e \\u0915\\u0940\\u091c\\u093f\\u092f\\u0947, \\u0924\\u093e\\u0930\\u0940\\u0916 \\u0915\\u093e \\u092a\\u094d\\u0930\\u093e\\u0930\\u0942\\u092a \\u0917\\u0932\\u0924 \\u0939\\u0948.'\nmodules/date_helper.py\ndef try_parsing_partner_date(date_string):\n\ttry:\n\t\treturn date_string_dmy_to_date(date_string)\n\texcept ValueError:\n\t\treturn date_string_ymd_to_date(date_string)\nmodules/i18n.py\ndef hindi_information():\n    return u'\\u0907\\u0924\\u094d\\u0924\\u093f\\u0932\\u093e'\nmodules/date_helper.py\ndef date_is_valid(date_string):\n    try:\n        date = date_string_to_date(date_string)\n        too_old = date.year < datetime.now().year - 18\n        too_young = date.year > datetime.now().year + 2\n        return (not too_old and not too_young)\n    except ValueError:\n        return False\nmodules/i18n.py\ndef five_year_reminder_seven_days(language):\n    return fourteen_week_reminder_seven_days(language)\nmodules/i18n.py\ndef msg_failure(language):\n    if language == \"English\":\n        return \"Sorry, we didn't understand that message. Text END to \" + TEXTLOCAL_PHONENUMBER + \" to unsubscribe.\"\n    elif language == \"Hindi\":\n        return u'\\u0915\\u094d\\u0937\\u092e\\u093e \\u0915\\u0930\\u0947\\u0902, \\u0939\\u092e\\u0928\\u0947 \\u0909\\u0938 \\u0938\\u0902\\u0926\\u0947\\u0936 \\u0915\\u094b \\u0928\\u0939\\u0940\\u0902 \\u0938\\u092e\\u091d\\u093e. \\u0938\\u0926\\u0938\\u094d\\u092f\\u0924\\u093e \\u0930\\u0926\\u094d\\u0926 \\u0915\\u0930\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u0932\\u093f\\u0916\\u0947\\u0902 \"END\" \\u0914\\u0930 \\u092d\\u0947\\u0902\\u091c \\u0926\\u0947 ' + TEXTLOCAL_PHONENUMBER + ' \\u092a\\u0930.'\nmodules/i18n.py\ndef nine_month_reminder_seven_days(language):\n    return six_week_reminder_seven_days(language)\nmodules/utils.py\ndef add_country_code_to_phone_number(phone_number):\n\tif not phone_number:\n\t\treturn phone_number\n\n\tbegins_with_nine_one = re.match(\"^91\", phone_number)\n\t\t\n\tif not begins_with_nine_one:\n\t\tphone_number = \"91\" + phone_number\n\n\treturn phone_number\nmodules/date_helper.py\ndef datetime_string_ymd_to_datetime(date_string):\n\t\ttry:\n\t\t\treturn datetime_from_date_string(date_string, \"%Y-%m-%d %H:%M:%S\").replace(tzinfo=timezone.get_default_timezone())\n\t\texcept ValueError:\n\t\t\tlogging.error(\"Invalid datetime entry for message: \" + quote(date_string))\n\t\t\treturn datetime.now().replace(tzinfo=timezone.get_default_timezone())\n", "answers": ["        self.assertEqual(date_string_to_date(\"25/11/2015\"), datetime(2015, 11, 25, 0, 0).date())"], "length": 1248, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "cacf528493436bc221cd5f738c9bc45b2b94bcfb38479ada"}
{"input": "import unittest\nimport uuid\nimport json\nimport tempfile\nimport os\nimport zmq.green as zmq\nimport gevent\nimport beeswarm.shared\nfrom datetime import datetime\nfrom beeswarm.server.db import database_setup\nfrom beeswarm.server.db.entities import Honeypot, Client\nfrom beeswarm.server.db.entities import Session\nfrom beeswarm.drones.honeypot.models.session import Session as HoneypotSession\nfrom beeswarm.shared.socket_enum import SocketNames\nfrom beeswarm.shared.message_enum import Messages\nfrom beeswarm.server.db.database_actor import DatabaseActor\nfrom beeswarm.drones.client.models.session import BaitSession\nfrom beeswarm.server.misc.config_actor import ConfigActor\nfrom beeswarm.shared.helpers import send_zmq_request_socket\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\n\n\n\n\nclass ClassifierTests(unittest.TestCase):\n    def setUp(self):\n        beeswarm.shared.zmq_context = zmq.Context()\n        fd, self.db_file = tempfile.mkstemp()\n        os.close(fd)\n        connection_string = 'sqlite:///{0}'.format(self.db_file)\n        os.remove(self.db_file)\n        database_setup.setup_db(connection_string)\n\n    def tearDown(self):\n        if os.path.isfile(self.db_file):\n            os.remove(self.db_file)\n\n    def test_matching_quick_succession(self):\n        \"\"\"\n        Tests that attack sessions coming in quick succession are classified correctly.\n        This test relates to issue #218\n        \"\"\"\n\n        honeypot_id = 1\n        honeypot = Honeypot(id=honeypot_id)\n\n        db_session = database_setup.get_session()\n        db_session.add(honeypot)\n        db_session.commit()\n\n        drone_data_socket = beeswarm.shared.zmq_context.socket(zmq.PUB)\n        drone_data_socket.bind(SocketNames.DRONE_DATA.value)\n\n        # startup session database\n        database_actor = DatabaseActor(999, delay_seconds=2)\n        database_actor.start()\n        gevent.sleep(1)\n\n        for x in xrange(0, 100):\n            honeypot_session = HoneypotSession(source_ip='192.168.100.22', source_port=52311, protocol='pop3', users={},\n                                               destination_port=110)\n            honeypot_session.add_auth_attempt('plaintext', True, username='james', password='bond')\n            honeypot_session.honeypot_id = honeypot_id\n            drone_data_socket.send('{0} {1} {2}'.format(Messages.SESSION_HONEYPOT.value, honeypot_id,\n                                                            json.dumps(honeypot_session.to_dict(), default=json_default,\n                                                            ensure_ascii=False)))\n\n        gevent.sleep(1)\n        database_actor_request_socket = beeswarm.shared.zmq_context.socket(zmq.REQ)\n        database_actor_request_socket.connect(SocketNames.DATABASE_REQUESTS.value)\n        sessions = send_zmq_request_socket(database_actor_request_socket, '{0}'.format(Messages.GET_SESSIONS_ALL.value))\n\n        for session in sessions:\n            self.assertEqual(session['classification'], 'Bruteforce')\n\n        self.assertEqual(len(sessions), 100)\n\n    def test_bait_classification_honeypot_first(self):\n        \"\"\"\n        Tests that bait sessions are paired correctly with their honeypot counter parts when honeypot message arrives\n        first.\n        \"\"\"\n\n        self.populate_bait(True)\n        # TODO: Use message request - not orm access!\n        db_session = database_setup.get_session()\n        sessions = db_session.query(Session).all()\n        for session in sessions:\n            self.assertEqual(session.classification_id, 'bait_session')\n\n        self.assertEqual(len(sessions), 1)\n\n    def test_bait_classification_client_first(self):\n        \"\"\"\n        Tests that bait sessions are paired correctly with their honeypot counter parts when client message arrives\n        first.\n        \"\"\"\n\n        self.populate_bait(False)\n        # TODO: Use message request - not orm access!\n        db_session = database_setup.get_session()\n        sessions = db_session.query(Session).all()\n        for session in sessions:\n            self.assertEqual(session.classification_id, 'bait_session')\n\n        self.assertEqual(len(sessions), 1)\n\n    def populate_bait(self, honeypot_first):\n        honeypot_id = 1\n        client_id = 2\n        honeypot = Honeypot(id=honeypot_id)\n        client = Client(id=client_id)\n\n        db_session = database_setup.get_session()\n        db_session.add(honeypot)\n        db_session.add(client)\n        db_session.commit()\n\n        drone_data_socket = beeswarm.shared.zmq_context.socket(zmq.PUB)\n        drone_data_socket.bind(SocketNames.DRONE_DATA.value)\n\n        fd, config_file = tempfile.mkstemp()\n        os.close(fd)\n        os.remove(config_file)\n        # persistence actor needs to communicate with on config REQ/REP socket\n", "context": "beeswarm/server/db/entities.py\nclass Honeypot(Drone):\n    __tablename__ = 'honeypot'\n    id = Column(String, ForeignKey('drone.id'), primary_key=True)\n    __mapper_args__ = {'polymorphic_identity': 'honeypot'}\n\n    sessions = relationship('Session', cascade='all, delete-orphan', backref='honeypot')\n    clients = relationship('Client', secondary=honeypot_client_mtm)\n    # current capabilities\n    capabilities = relationship('Capability', cascade='all, delete-orphan', backref='honeypot')\n    # fingerprint of the public key used to interact with attackers and clients\n    cert_digest = Column(String)\n\n    # The following certificate attribute are temporarily\n    # generation of certificate should be done on the server, hence no need for\n    # this information here\n    cert_common_name = Column(String)\n    cert_country = Column(String)\n    cert_state = Column(String)\n    cert_locality = Column(String)\n    cert_organization = Column(String)\n    cert_organization_unit = Column(String)\n\n    def add_capability(self, protocol, port, protocol_specific_data):\n        capability = Capability(protocol=protocol, port=port, protocol_specific_data=json.dumps(protocol_specific_data))\n        self.capabilities.append(capability)\nbeeswarm/server/db/database_actor.py\nclass DatabaseActor(gevent.Greenlet):\n\n    def __init__(self, max_sessions, clear_sessions=False, delay_seconds=30):\n        assert delay_seconds > 1\n        Greenlet.__init__(self)\n        db_session = database_setup.get_session()\n        self.enabled = True\n        # pending session will be converted to attacks if we cannot match with bait traffic\n        # with this period\n        self.delay_seconds = delay_seconds\n        # clear all pending sessions on startup, pending sessions on startup\n        pending_classification = db_session.query(Classification).filter(\n            Classification.type == 'pending').one()\n        pending_deleted = db_session.query(Session).filter(\n            Session.classification == pending_classification).delete()\n        db_session.commit()\n        logging.info(\n            'Cleaned {0} pending sessions on startup'.format(pending_deleted))\n        self.do_classify = False\n        self.do_maintenance = False\n        if clear_sessions or max_sessions == 0:\n            db_session = database_setup.get_session()\n            count = db_session.query(Session).delete()\n            logging.info('Deleting {0} sessions on startup.'.format(count))\n            db_session.commit()\n\n        self.max_session_count = max_sessions\n        if max_sessions:\n            logger.info(\n                'Database has been limited to contain {0} sessions.'.format(max_sessions))\n\n        context = beeswarm.shared.zmq_context\n\n        # prepare sockets\n        self.drone_data_socket = context.socket(zmq.SUB)\n        self.processedSessionsPublisher = context.socket(zmq.PUB)\n        self.databaseRequests = context.socket(zmq.REP)\n        self.config_actor_socket = context.socket(zmq.REQ)\n        self.drone_command_receiver = context.socket(zmq.PUSH)\n\n    def _run(self):\n        # connect and bind to all relevant sockets\n        # raw data from drones\n        self.drone_data_socket.connect(SocketNames.DRONE_DATA.value)\n        self.drone_data_socket.setsockopt(zmq.SUBSCRIBE, '')\n        # requests that this actor needs to respond to\n        self.databaseRequests.bind(SocketNames.DATABASE_REQUESTS.value)\n        # will publish session after they have been processed on this socket\n        self.processedSessionsPublisher.bind(\n            SocketNames.PROCESSED_SESSIONS.value)\n        # needed to be able to probe for options and get zmq keys\n        self.config_actor_socket.connect(SocketNames.CONFIG_COMMANDS.value)\n        # needed to send data directly to drones\n        self.drone_command_receiver.connect(SocketNames.DRONE_COMMANDS.value)\n\n        poller = zmq.Poller()\n        poller.register(self.drone_data_socket, zmq.POLLIN)\n        poller.register(self.databaseRequests, zmq.POLLIN)\n        gevent.spawn(self._start_recurring_classify_set)\n        gevent.spawn(self._start_recurring_maintenance_set)\n        while self.enabled:\n            socks = dict(poller.poll(100))\n            if self.do_classify:\n                self._classify_malicious_sessions()\n                self.do_classify = False\n            elif self.do_maintenance:\n                self._db_maintenance()\n                self.do_maintenance = False\n            elif self.databaseRequests in socks and socks[self.databaseRequests] == zmq.POLLIN:\n                data = self.databaseRequests.recv()\n                if ' ' in data:\n                    cmd, data = data.split(' ', 1)\n                else:\n                    cmd = data\n\n                if cmd == Messages.DRONE_CONFIG.value:\n                    self._handle_command_get_droneconfig(data)\n                elif cmd == Messages.BAIT_USER_ADD.value:\n                    self._handle_command_bait_user_add(data)\n                    self.databaseRequests.send(\n                        '{0} {1}'.format(Messages.OK.value, '{}'))\n                elif cmd == Messages.BAIT_USER_DELETE.value:\n                    self._handle_command_bait_user_delete(data)\n                    self.databaseRequests.send(\n                        '{0} {1}'.format(Messages.OK.value, '{}'))\n                elif cmd == Messages.DRONE_DELETE.value:\n                    self._handle_command_delete_drone(data)\n                    self.databaseRequests.send(\n                        '{0} {1}'.format(Messages.OK.value, '{}'))\n                elif cmd == Messages.DRONE_ADD.value:\n                    self._handle_command_add_drone()\n                elif cmd == Messages.GET_DB_STATS.value:\n                    result = self._handle_command_get_db_stats()\n                    self.databaseRequests.send('{0} {1}'.format(\n                        Messages.OK.value, json.dumps(result)))\n                elif cmd == Messages.GET_SESSIONS_ALL.value or cmd == Messages.GET_SESSIONS_ATTACKS.value \\\n                        or cmd == Messages.GET_SESSIONS_BAIT.value:\n                    # TODO: Accept to/from param to facilitate pagination\n                    result = self._handle_command_get_sessions(cmd)\n                    self.databaseRequests.send('{0} {1}'.format(\n                        Messages.OK.value, json.dumps(result)))\n                elif cmd == Messages.GET_SESSION_CREDENTIALS.value:\n                    result = self._handle_command_get_credentials(data)\n                    self.databaseRequests.send('{0} {1}'.format(\n                        Messages.OK.value, json.dumps(result)))\n                elif cmd == Messages.GET_SESSION_TRANSCRIPT.value:\n                    result = self._handle_command_get_transcript(data)\n                    self.databaseRequests.send('{0} {1}'.format(\n                        Messages.OK.value, json.dumps(result)))\n                elif cmd == Messages.GET_BAIT_USERS.value:\n                    result = self._handle_command_get_bait_users()\n                    self.databaseRequests.send('{0} {1}'.format(\n                        Messages.OK.value, json.dumps(result)))\n                elif cmd == Messages.CONFIG_DRONE.value:\n                    # .send on socket is handled internally since it can send errors back\n                    self._handle_command_config_drone(data)\n                elif cmd == Messages.GET_DRONE_LIST.value:\n                    result = self._handle_command_get_drone_list(data)\n                    self.databaseRequests.send('{0} {1}'.format(\n                        Messages.OK.value, json.dumps(result)))\n                elif cmd == Messages.PING_ALL_DRONES.value:\n                    self._handle_ping_all_drones()\n                    self.databaseRequests.send(\n                        '{0} {1}'.format(Messages.OK.value, ' '))\n                else:\n                    logger.error('Unknown message received: {0}'.format(data))\n                    assert False\n            elif self.drone_data_socket in socks and socks[self.drone_data_socket] == zmq.POLLIN:\n                split_data = self.drone_data_socket.recv().split(' ', 2)\n                if len(split_data) == 3:\n                    topic, drone_id, data = split_data\n                else:\n                    data = None\n                    topic, drone_id, = split_data\n                self._update_drone_last_activity(drone_id)\n                if topic == Messages.SESSION_HONEYPOT.value or topic == Messages.SESSION_CLIENT.value:\n                    self.persist_session(topic, data)\n                elif topic == Messages.CERT.value:\n                    self._handle_cert_message(topic, drone_id, data)\n                elif topic == Messages.KEY.value:\n                    pass\n                elif topic == Messages.IP.value:\n                    self._handle_message_ip(topic, drone_id, data)\n                elif topic == Messages.DRONE_WANT_CONFIG.value:\n                    config_dict = self._get_drone_config(drone_id)\n                    self.drone_command_receiver.send('{0} {1} {2}'.format(drone_id, Messages.CONFIG.value,\n                                                                          json.dumps(config_dict)))\n                elif topic == Messages.PING.value:\n                    self._update_drone_last_activity(drone_id)\n                    logger.debug('Received ping from {0}'.format(drone_id))\n                else:\n                    logger.debug(\n                        'This actor cannot process this message: {0}'.format(topic))\n\n    def stop(self):\n        self.enabled = False\n        self.drone_data_socket.close()\n        self.processedSessionsPublisher.close()\n        self.databaseRequests.close()\n        self.config_actor_socket.close()\n        self.drone_command_receiver.close()\n\n    def _update_drone_last_activity(self, drone_id):\n        db_session = database_setup.get_session()\n        drone = db_session.query(Drone).filter(Drone.id == drone_id).one_or_none()\n        if drone:\n            drone.last_activity = datetime.now()\n            db_session.add(drone)\n            db_session.commit()\n        else:\n            logger.warning(\n                'Trying to update last activity non-exting drone with id {0}'.format(drone_id))\n\n    def _start_recurring_maintenance_set(self):\n        while self.enabled:\n            sleep_time = 60 * 60\n            gevent.sleep(sleep_time)\n            self.do_maintenance = True\n\n    def _start_recurring_classify_set(self):\n        while self.enabled:\n            sleep_time = self.delay_seconds / 2\n            gevent.sleep(sleep_time)\n            self.do_classify = True\n\n    def _handle_message_ip(self, topic, drone_id, data):\n        ip_address = data\n        logging.debug('Drone {0} reported ip: {1}'.format(\n            drone_id, ip_address))\n        db_session = database_setup.get_session()\n        drone = db_session.query(Drone).filter(Drone.id == drone_id).one_or_none()\n        if drone:\n            if drone.ip_address != ip_address:\n                drone.ip_address = ip_address\n                db_session.add(drone)\n                db_session.commit()\n        else:\n            logger.warning(\n                'Trying to update IP on non-exting drone with id {0}'.format(drone_id))\n\n    def _handle_cert_message(self, topic, drone_id, data):\n        # for now we just store the fingerprint\n        # in the future it might be relevant to store the entire public key and private key\n        # for forensic purposes\n        cert = data.split(' ', 1)[1]\n        digest = generate_cert_digest(cert)\n        logging.debug(\n            'Storing public key digest: {0} for drone {1}.'.format(digest, drone_id))\n        db_session = database_setup.get_session()\n        drone = db_session.query(Drone).filter(Drone.id == drone_id).one_or_none()\n        if drone:\n            drone.cert_digest = digest\n            db_session.add(drone)\n            db_session.commit()\n        else:\n            logger.warning(\n                'Trying to update cert on non-exting drone with id {0}'.format(drone_id))\n\n    def persist_session(self, session_type, session_json):\n        db_session = database_setup.get_session()\n\n        if self.max_session_count == 0:\n            return\n        elif db_session.query(Session).count() == self.max_session_count:\n            session_to_delete = db_session.query(\n                Session, func.min(Session.timestamp)).first()[0]\n            db_session.delete(session_to_delete)\n        try:\n            data = json.loads(session_json)\n        except UnicodeDecodeError:\n            data = json.loads(unicode(session_json, \"ISO-8859-1\"))\n        logger.debug('Persisting {0} session: {1}'.format(session_type, data))\n\n        classification = db_session.query(Classification).filter(\n            Classification.type == 'pending').one()\n\n        assert data['honeypot_id'] is not None\n        _honeypot = db_session.query(Honeypot).filter(\n            Honeypot.id == data['honeypot_id']).one_or_none()\n        if not _honeypot:\n            logger.warning('Trying to persist session for non-existing honeypot drone with id {0}'.format(data['honeypot_id']))\n            return\n        if session_type == Messages.SESSION_HONEYPOT.value:\n            session = Session()\n            for entry in data['transcript']:\n                transcript_timestamp = isoformatToDatetime(entry['timestamp'])\n                transcript = Transcript(timestamp=transcript_timestamp, direction=entry['direction'],\n                                        data=entry['data'])\n                session.transcript.append(transcript)\n\n            for auth in data['login_attempts']:\n                authentication = self.extract_auth_entity(auth)\n                session.authentication.append(authentication)\n        elif session_type == Messages.SESSION_CLIENT.value:\n            ignore_failed_bait_sessions = self.send_config_request('{0} {1}'.format(Messages.GET_CONFIG_ITEM.value,\n                                                                                    'ignore_failed_bait_session'))\n            if not data['did_complete'] and ignore_failed_bait_sessions:\n                logger.debug('Ignore failed bait session.')\n                return\n            session = BaitSession()\n            client = db_session.query(Client).filter(\n                Client.id == data['client_id']).one_or_none()\n            if not client:\n                logger.warning('Trying to persist session for non-existing client drone with id {0}'.format(data['client_id']))\n                return\n            client.last_activity = datetime.now()\n            session.did_connect = data['did_connect']\n            session.did_login = data['did_login']\n            session.did_complete = data['did_complete']\n            session.client = client\n            for auth in data['login_attempts']:\n                authentication = self.extract_auth_entity(auth)\n                session.authentication.append(authentication)\n        else:\n            logger.warn('Unknown message type: {0}'.format(session_type))\n            return\n        session.id = data['id']\n        session.classification = classification\n        session.timestamp = isoformatToDatetime(data['timestamp'])\n        session.received = datetime.utcnow()\n        session.protocol = data['protocol']\n        session.destination_ip = data['destination_ip']\n        session.destination_port = data['destination_port']\n        session.source_ip = data['source_ip']\n        session.source_port = data['source_port']\n        session.honeypot = _honeypot\n        _dronename = db_session.query(Drone).filter(\n            Drone.id == _honeypot.id).first().name\n        db_session.add(session)\n        db_session.commit()\n        matching_session = self.get_matching_session(session, db_session)\n        if session_type == Messages.SESSION_HONEYPOT.value:\n            if matching_session:\n                matching_session.name = _dronename\n                self.merge_bait_and_session(\n                    session, matching_session, db_session)\n        elif session_type == Messages.SESSION_CLIENT.value:\n            if matching_session:\n                session.name = _dronename\n                self.merge_bait_and_session(\n                    matching_session, session, db_session)\n        else:\n            assert False\n\n    def extract_auth_entity(self, auth_data):\n        username = auth_data.get('username', '')\n        password = auth_data.get('password', '')\n        authentication = Authentication(id=auth_data['id'], username=username, password=password,\n                                        successful=auth_data['successful'],\n                                        timestamp=isoformatToDatetime(auth_data['timestamp']))\n        return authentication\n\n    def get_matching_session(self, session, db_session, timediff=5):\n        \"\"\"\n        Tries to match a session with it's counterpart. For bait session it will try to match it with honeypot sessions\n        and the other way around.\n\n        :param session: session object which will be used as base for query.\n        :param timediff: +/- allowed time difference between a session and a potential matching session.\n        \"\"\"\n        db_session = db_session\n        min_datetime = session.timestamp - timedelta(seconds=timediff)\n        max_datetime = session.timestamp + timedelta(seconds=timediff)\n        # default return value\n        match = None\n        classification = db_session.query(Classification).filter(\n            Classification.type == 'pending').one()\n        # get all sessions that match basic properties.\n        sessions = db_session.query(Session).options(joinedload(Session.authentication)) \\\n            .filter(Session.protocol == session.protocol) \\\n            .filter(Session.honeypot == session.honeypot) \\\n            .filter(Session.timestamp >= min_datetime) \\\n            .filter(Session.timestamp <= max_datetime) \\\n            .filter(Session.id != session.id) \\\n            .filter(Session.classification == classification)\n\n        # identify the correct session by comparing authentication.\n        # this could properly also be done using some fancy ORM/SQL construct.\n        for potential_match in sessions:\n            if potential_match.discriminator == session.discriminator:\n                continue\n            assert potential_match.id != session.id\n            for honey_auth in session.authentication:\n                for session_auth in potential_match.authentication:\n                    if session_auth.username == honey_auth.username and \\\n                            session_auth.password == honey_auth.password and \\\n                            session_auth.successful == honey_auth.successful:\n                        assert potential_match.id != session.id\n                        match = potential_match\n                        break\n\n        return match\n\n    def merge_bait_and_session(self, honeypot_session, bait_session, db_session):\n        logger.debug('Classifying bait session with id {0} as legit bait and deleting '\n                     'matching honeypot_session with id {1}'.format(bait_session.id, honeypot_session.id))\n        bait_session.classification = db_session.query(Classification).filter(\n            Classification.type == 'bait_session').one()\n        bait_session.transcript = honeypot_session.transcript\n        bait_session.session_data = honeypot_session.session_data\n        # the client ip own detection can be flawed, but we are sure the the honeypot tcp source ip\n        # is the same as the clients source ip.\n        bait_session.source_ip = honeypot_session.source_ip\n        db_session.add(bait_session)\n        db_session.delete(honeypot_session)\n        db_session.commit()\n        self.processedSessionsPublisher.send(\n            '{0} {1} {2}'.format(Messages.DELETED_DUE_TO_MERGE.value, honeypot_session.id,\n                                 bait_session.id))\n        self.processedSessionsPublisher.send('{0} {1}'.format(Messages.SESSION.value,\n                                                              json.dumps(bait_session.to_dict())))\n\n    def _classify_malicious_sessions(self):\n        \"\"\"\n        Will classify all unclassified sessions as malicious activity.\n\n        :param delay_seconds: no sessions newer than (now - delay_seconds) will be processed.\n        \"\"\"\n        min_datetime = datetime.utcnow() - timedelta(seconds=self.delay_seconds)\n\n        db_session = database_setup.get_session()\n\n        # find and process bait sessions that did not get classified during\n        # persistence.\n        bait_sessions = db_session.query(BaitSession).options(joinedload(BaitSession.authentication)) \\\n            .filter(BaitSession.classification_id == 'pending') \\\n            .filter(BaitSession.did_complete == True) \\\n            .filter(BaitSession.received < min_datetime).all()\n\n        for bait_session in bait_sessions:\n            logger.debug(\n                'Classifying bait session with id {0} as MITM'.format(bait_session.id))\n            bait_session.classification = db_session.query(\n                Classification).filter(Classification.type == 'mitm').one()\n            db_session.commit()\n\n        # find and process honeypot sessions that did not get classified during\n        # persistence.\n        sessions = db_session.query(Session, Drone.name).filter(Session.discriminator == None) \\\n            .filter(Session.timestamp <= min_datetime) \\\n            .filter(Session.classification_id == 'pending') \\\n            .all()\n\n        for entry in sessions:\n            # Check if the attack used credentials leaked by beeswarm drones\n            session = entry[0]\n            bait_match = None\n            for a in session.authentication:\n                bait_match = db_session.query(BaitSession) \\\n                    .filter(BaitSession.authentication.any(username=a.username, password=a.password)).first()\n                if bait_match:\n                    break\n\n            if bait_match:\n                logger.debug('Classifying session with id {0} as attack which involved the reuse '\n                             'of previously transmitted credentials.'.format(session.id))\n                session.classification = db_session.query(Classification).filter(\n                    Classification.type == 'credentials_reuse').one()\n            elif len(session.authentication) == 0:\n                logger.debug(\n                    'Classifying session with id {0} as probe.'.format(session.id))\n                session.classification = db_session.query(\n                    Classification).filter(Classification.type == 'probe').one()\n            else:\n                # we have never transmitted this username/password combo\n                logger.debug(\n                    'Classifying session with id {0} as bruteforce attempt.'.format(session.id))\n                session.classification = db_session.query(Classification).filter(\n                    Classification.type == 'bruteforce').one()\n            db_session.commit()\n            session.name = entry[1]\n            self.processedSessionsPublisher.send(\n                '{0} {1}'.format(Messages.SESSION.value, json.dumps(session.to_dict())))\n\n    def _handle_command_delete_drone(self, data):\n        drone_id = data\n        logger.debug('Deleting drone: {0}'.format(drone_id))\n        db_session = database_setup.get_session()\n        drone_to_delete = db_session.query(\n            Drone).filter(Drone.id == drone_id).first()\n        if drone_to_delete:\n            db_session.delete(drone_to_delete)\n            db_session.commit()\n            # tell the drone to kill itself\n            self.drone_command_receiver.send(\n                '{0} {1} '.format(drone_id, Messages.DRONE_DELETE.value))\n            self.send_config_request('{0} {1}'.format(\n                Messages.DELETE_ZMQ_KEYS.value, drone_id))\n            self._reconfigure_all_clients()\n\n    def _handle_command_add_drone(self):\n        db_session = database_setup.get_session()\n        drone = Drone()\n        db_session.add(drone)\n        db_session.commit()\n        logger.debug('New drone has been added with id: {0}'.format(drone.id))\n\n        drone_config = self._get_drone_config(drone.id)\n        self.databaseRequests.send('{0} {1}'.format(\n            Messages.OK.value, json.dumps(drone_config)))\n\n    def _reconfigure_all_clients(self):\n        db_session = database_setup.get_session()\n        db_session.query(DroneEdge).delete()\n        db_session.commit()\n        honeypots = db_session.query(Honeypot).all()\n        clients = db_session.query(Client).all()\n        # delete old architecture\n        credentials = db_session.query(BaitUser).all()\n        for honeypot in honeypots:\n            for capability in honeypot.capabilities:\n                for client in clients:\n                    # following three variables should be make somewhat user\n                    # configurable again\n                    client_timings = json.loads(client.bait_timings)\n                    if capability.protocol in client_timings:\n                        # the time range in which to activate the bait sessions\n                        activation_range = client_timings[\n                            capability.protocol]['active_range']\n                        # period to sleep before using activation_probability\n                        sleep_interval = client_timings[\n                            capability.protocol]['sleep_interval']\n                        # the probability that a bait session will be\n                        # activated, 1 is always activate\n                        activation_probability = client_timings[\n                            capability.protocol]['activation_probability']\n                    else:\n                        logger.warning('Bait timings for {0} not found on client drone {1}({2}), using defaults instead'\n                                       .format(capability.protocol, client.name, client.id))\n                        activation_range = '00:00 - 23:59'\n                        sleep_interval = '60'\n                        activation_probability = 1\n                    bait_credentials = random.choice(credentials)\n                    client.add_bait(capability, activation_range, sleep_interval,\n                                    activation_probability, bait_credentials.username, bait_credentials.password)\n        db_session.commit()\n\n        drones = db_session.query(Drone).all()\n        for drone in drones:\n            self._send_config_to_drone(drone.id)\n\n    def _handle_command_get_droneconfig(self, drone_id):\n        result = self._get_drone_config(drone_id)\n        if len(result) == 0:\n            self.databaseRequests.send('{0} {1}'.format(\n                Messages.FAIL.value, 'Drone could not be found'))\n        else:\n            self.databaseRequests.send('{0} {1}'.format(\n                Messages.OK.value, json.dumps(result)))\n\n    def _send_config_to_drone(self, drone_id):\n        config = self._get_drone_config(drone_id)\n        logger.debug('Sending config to {0}: {1}'.format(drone_id, config))\n        self.drone_command_receiver.send('{0} {1} {2}'.format(\n            drone_id, Messages.CONFIG.value, json.dumps(config)))\n\n    def _handle_ping_all_drones(self):\n        db_session = database_setup.get_session()\n        drones = db_session.query(Drone)\n\n        for drone in drones:\n            logger.debug('Sending ping to {0}'.format(drone.id))\n            self.drone_command_receiver.send(\n                '{0} {1} {2}'.format(drone.id, Messages.PING.value, ''))\n\n    def send_config_request(self, request):\n        return send_zmq_request_socket(self.config_actor_socket, request)\n\n    def _handle_command_drone_config_changed(self, drone_id):\n        self._send_config_to_drone(drone_id)\n        # TODO: Only Clients that communicate with this drone_id needs to get\n        # reconfigured.\n        self._reconfigure_all_clients()\n\n    def _handle_command_bait_user_delete(self, data):\n        bait_user_id = int(data)\n        db_session = database_setup.get_session()\n        bait_user = db_session.query(BaitUser).filter(\n            BaitUser.id == bait_user_id).first()\n        if bait_user:\n            db_session.delete(bait_user)\n            db_session.commit()\n            drone_edge = db_session.query(DroneEdge).filter(DroneEdge.username == bait_user.username,\n                                                            DroneEdge.password == bait_user.password).first()\n            # A drone is using the bait users, reconfigure all\n            # TODO: This is lazy, we should only reconfigure the drone(s) who are actually\n            # using the credentials\n            if drone_edge:\n                self._reconfigure_all_clients()\n        else:\n            logger.warning(\n                'Tried to delete non-existing bait user with id {0}.'.format(bait_user_id))\n\n    def _handle_command_bait_user_add(self, data):\n        username, password = data.split(' ')\n        db_session = database_setup.get_session()\n        existing_bait_user = db_session.query(BaitUser).filter(BaitUser.username == username,\n                                                               BaitUser.password == password).first()\n        if not existing_bait_user:\n            new_bait_user = BaitUser(username=username, password=password)\n            db_session.add(new_bait_user)\n            db_session.commit()\n\n    def _handle_command_get_bait_users(self):\n        db_session = database_setup.get_session()\n        bait_users = db_session.query(BaitUser)\n        return_rows = []\n        for bait_user in bait_users:\n            row = {'id': bait_user.id, 'username': bait_user.username,\n                   'password': bait_user.password}\n            return_rows.append(row)\n        return return_rows\n\n    def _get_drone_config(self, drone_id):\n        db_session = database_setup.get_session()\n        drone = db_session.query(Honeypot).filter(Drone.id == drone_id).first()\n        # lame! what is the correct way?\n        if not drone:\n            drone = db_session.query(Client).filter(\n                Drone.id == drone_id).first()\n        if not drone:\n            drone = db_session.query(Drone).filter(\n                Drone.id == drone_id).first()\n        if not drone:\n            # drone not found\n            return {}\n\n        host = self.send_config_request('{0} {1}'.format(\n            Messages.GET_CONFIG_ITEM.value, 'network,server_host'))\n        zmq_port = self.send_config_request('{0} {1}'.format(\n            Messages.GET_CONFIG_ITEM.value, 'network,zmq_port'))\n        zmq_command_port = self.send_config_request(\n            '{0} {1}'.format(Messages.GET_CONFIG_ITEM.value, 'network,zmq_command_port'))\n\n        server_zmq_url = 'tcp://{0}:{1}'.format(host, zmq_port)\n        server_zmq_command_url = 'tcp://{0}:{1}'.format(host, zmq_command_port)\n\n        zmq_keys = self.send_config_request(\n            '{0} {1}'.format(Messages.GET_ZMQ_KEYS.value, drone_id))\n        zmq_server_key = self.send_config_request(\n            '{0} {1}'.format(Messages.GET_ZMQ_KEYS.value, 'beeswarm_server'))\n        zmq_server_key = zmq_server_key['public_key']\n        # common section that goes for all types of drones\n        drone_config = {\n            'general': {\n                'mode': drone.discriminator,\n                'id': int(drone.id),\n                'fetch_ip': False,\n                'name': drone.name\n            },\n            'beeswarm_server': {\n                'zmq_url': server_zmq_url,\n                'zmq_command_url': server_zmq_command_url,\n                'zmq_server_public': zmq_server_key,\n                'zmq_own_public': zmq_keys['public_key'],\n                'zmq_own_private': zmq_keys['private_key'],\n            },\n            'timecheck': {\n                'enabled': True,\n                'poll': 5,\n                'ntp_pool': 'pool.ntp.org'\n            }\n        }\n\n        if drone.discriminator == 'honeypot':\n            drone_config['certificate_info'] = {\n                'common_name': drone.cert_common_name,\n                'country': drone.cert_country,\n                'state': drone.cert_state,\n                'locality': drone.cert_locality,\n                'organization': drone.cert_organization,\n                'organization_unit': drone.cert_organization_unit\n            }\n            drone_config['capabilities'] = {}\n            for capability in drone.capabilities:\n                users = {}\n                for bait in capability.baits:\n                    users[bait.username] = bait.password\n                drone_config['capabilities'][capability.protocol] = {'port': capability.port,\n                                                                     'enabled': True,\n                                                                     'protocol_specific_data': json.loads(\n                                                                         capability.protocol_specific_data),\n                                                                     'users': users}\n        elif drone.discriminator == 'client':\n            drone_config['baits'] = {}\n            for bait in drone.baits:\n                _bait = {'server': bait.capability.honeypot.ip_address,\n                         'port': bait.capability.port,\n                         'honeypot_id': bait.capability.honeypot_id,\n                         'username': bait.username,\n                         'password': bait.password,\n                         'active_range': bait.activation_range,\n                         'sleep_interval': bait.sleep_interval,\n                         'activation_probability': bait.activation_probability}\n                if bait.capability.honeypot_id not in drone_config['baits']:\n                    drone_config['baits'][bait.capability.honeypot_id] = {}\n                assert bait.capability.protocol not in drone_config[\n                    'baits'][bait.capability.honeypot_id]\n                drone_config['baits'][bait.capability.honeypot_id][\n                    bait.capability.protocol] = _bait\n            if drone.bait_timings:\n                drone_config['bait_timings'] = json.loads(drone.bait_timings)\n            else:\n                drone_config['bait_timings'] = {}\n\n        return drone_config\n\n    def _handle_command_get_db_stats(self):\n        db_session = database_setup.get_session()\n        database_stats = {\n            'count_honeypots': db_session.query(Honeypot).count(),\n            'count_clients': db_session.query(Client).count(),\n            'count_sessions': db_session.query(Session).count(),\n            'count_all_baits': db_session.query(BaitSession).count(),\n            'count_all_attacks': db_session.query(Session).filter(Session.classification_id != 'bait_session')\n            .filter(Session.classification_id != 'pending')\n            .filter(Session.classification_id is not None).count(),\n            'count_attack_type': {\n                'http': self._get_num_attacks('http', db_session),\n                'vnc': self._get_num_attacks('vnc', db_session),\n                'ssh': self._get_num_attacks('ssh', db_session),\n                'ftp': self._get_num_attacks('ftp', db_session),\n                'https': self._get_num_attacks('https', db_session),\n                'pop3': self._get_num_attacks('pop3', db_session),\n                'pop3s': self._get_num_attacks('pop3s', db_session),\n                'smtp': self._get_num_attacks('smtp', db_session),\n                'telnet': self._get_num_attacks('telnet', db_session),\n            },\n            'baits': {\n                'successful': db_session.query(BaitSession).filter(BaitSession.did_login).count(),\n                'failed': db_session.query(BaitSession).filter(not BaitSession.did_login).count(),\n\n            }\n        }\n        return database_stats\n\n    def _get_num_attacks(self, protocol, db_session):\n        return db_session.query(Session).filter(Session.classification_id != 'bait_session') \\\n            .filter(Session.classification_id is not None) \\\n            .filter(Session.protocol == protocol).count()\n\n    def _handle_command_get_sessions(self, _type):\n        db_session = database_setup.get_session()\n        # the database_setup will not get hit until we start iterating the\n        # query object\n        query_iterators = {\n            Messages.GET_SESSIONS_ALL.value: db_session.query(Session),\n            Messages.GET_SESSIONS_BAIT.value: db_session.query(BaitSession),\n            Messages.GET_SESSIONS_ATTACKS.value: db_session.query(Session).filter(\n                Session.classification_id != 'bait_session')\n        }\n\n        if _type not in query_iterators:\n            logger.warning(\n                'Query for sessions with unknown type: {0}'.format(_type))\n            return []\n\n        # select which iterator to use\n        entries = query_iterators[_type].order_by(desc(Session.timestamp))\n        rows = []\n\n        for session in entries:\n            rows.append(session.to_dict())\n\n        return rows\n\n    def _handle_command_get_credentials(self, session_id):\n        db_session = database_setup.get_session()\n\n        credentials = db_session.query(Authentication).filter(\n            Authentication.session_id == session_id)\n        return_rows = []\n        for credential in credentials:\n            return_rows.append(credential.to_dict())\n        return return_rows\n\n    def _handle_command_get_transcript(self, session_id):\n        db_session = database_setup.get_session()\n\n        transcripts = db_session.query(Transcript).filter(\n            Transcript.session_id == session_id)\n        return_rows = []\n        for transcript in transcripts:\n            row = {'time': transcript.timestamp.strftime('%Y-%m-%d %H:%M:%S'), 'direction': transcript.direction,\n                   'data': transcript.data}\n            return_rows.append(row)\n        return return_rows\n\n    def _handle_command_get_drone_list(self, drone_type):\n        db_session = database_setup.get_session()\n        if drone_type == 'all':\n            drones = db_session.query(Drone).all()\n        elif drone_type == 'unassigned':\n            drones = db_session.query(Drone).filter(\n                Drone.discriminator == None)\n        else:\n            drones = db_session.query(Drone).filter(\n                Drone.discriminator == drone_type)\n\n        drone_list = []\n        for drone in drones:\n            drone_list.append(drone.to_dict())\n        return drone_list\n\n    def _handle_command_config_drone(self, data):\n        drone_id, config = data.split(' ', 1)\n        config = json.loads(config)\n\n        db_session = database_setup.get_session()\n        drone = db_session.query(Drone).filter(Drone.id == drone_id).one_or_none()\n        if not drone:\n            self.databaseRequests.send('{0} {1}'.format(Messages.FAIL.value, 'Drone with id {0} could not '\n                                                                             'found'.format(drone_id)))\n        elif config['mode'] == 'honeypot':\n            # it is a honeypot\n            self._config_honeypot(drone, db_session, config)\n            self.databaseRequests.send('{0} {1}'.format(Messages.OK.value, {}))\n        elif config['mode'] == 'client':\n            # it is a client\n            self._config_client(drone, db_session, config)\n            self.databaseRequests.send('{0} {1}'.format(Messages.OK.value, {}))\n\n        else:\n            logger.error(\n                'Could not detect mode for drone config, drone id: {0}'.format(drone_id))\n            self.databaseRequests.send('{0} {1}'.format(Messages.FAIL.value, 'Malformed data in drone config data.'\n                                                                             'Drone id: {0}'.format(drone_id)))\n\n    def _config_honeypot(self, drone, db_session, config):\n        if drone.discriminator != 'honeypot':\n            # meh, better way do do this?\n            drone_id = drone.id\n            ip_address = drone.ip_address\n            db_session.delete(drone)\n            db_session.commit()\n            drone = Honeypot(id=drone_id)\n            drone.ip_address = ip_address\n            db_session.add(drone)\n            db_session.commit()\n\n        # common properties\n        drone.name = config['name']\n\n        # certificate information\n        drone.cert_common_name = config['certificate']['common_name']\n        drone.cert_country = config['certificate']['country']\n        drone.cert_state = config['certificate']['state']\n        drone.cert_locality = config['certificate']['locality']\n        drone.cert_organization = config['certificate']['organization']\n        drone.cert_organization_unit = config[\n            'certificate']['organization_unit']\n\n        # add capabilities\n        drone.capabilities = []\n        for protocol_name, protocol_config in config['capabilities'].items():\n            if 'protocol_specific_data' in protocol_config:\n                protocol_specific_data = protocol_config[\n                    'protocol_specific_data']\n            else:\n                protocol_specific_data = {}\n            drone.add_capability(protocol_name, protocol_config[\n                                 'port'], protocol_specific_data)\n\n        db_session.add(drone)\n        db_session.commit()\n        self._handle_command_drone_config_changed(drone.id)\n\n    def _config_client(self, drone, db_session, config):\n        if drone.discriminator != 'client':\n            # meh, better way do do this?\n            # TODO: this cascade delete sessions, find a way to maintain\n            # sessions for deleted drones.\n            ip_address = drone.ip_address\n            drone_id = drone.id\n            db_session.delete(drone)\n            db_session.commit()\n            drone = Client(id=drone_id)\n            drone.ip_address = ip_address\n            db_session.add(drone)\n            db_session.commit()\n        drone.bait_timings = json.dumps(config['bait_timings'])\n        drone.name = config['name']\n        db_session.add(drone)\n        db_session.commit()\n        self._handle_command_drone_config_changed(drone.id)\n\n    def _db_maintenance(self):\n        logger.debug('Doing database maintenance')\n        bait_session_retain_days = int(self.send_config_request('{0} {1}'.format(Messages.GET_CONFIG_ITEM.value,\n                                                                                 'bait_session_retain')))\n        bait_retain = datetime.utcnow() - timedelta(days=bait_session_retain_days)\n        malicious_session_retain_days = int(self.send_config_request('{0} {1}'.format(Messages.GET_CONFIG_ITEM.value,\n                                                                                      'malicious_session_retain')))\n        malicious_retain = datetime.utcnow() - timedelta(days=malicious_session_retain_days)\n\n        db_session = database_setup.get_session()\n\n        malicious_deleted_count = db_session.query(Session).filter(Session.classification_id != 'bait_session') \\\n            .filter(Session.timestamp < malicious_retain).delete()\n\n        bait_deleted_count = db_session.query(Session).filter(Session.classification_id == 'bait_session') \\\n            .filter(Session.timestamp < bait_retain).delete()\n        db_session.commit()\n\n        logger.info('Database maintenance finished. Deleted {0} bait_sessions and {1} malicious sessions)'\n                    .format(bait_deleted_count, malicious_deleted_count))\nbeeswarm/server/db/entities.py\nclass Client(Drone):\n    __tablename__ = 'client'\n    __mapper_args__ = {'polymorphic_identity': 'client'}\n\n    id = Column(String, ForeignKey('drone.id'), primary_key=True)\n    bait_sessions = relationship(\"BaitSession\", cascade=\"all, delete-orphan\", backref='client')\n\n    baits = relationship('DroneEdge', cascade='all, delete-orphan', backref='client')\n    bait_timings = Column(String)\n\n    def add_bait(self, capability, activation_range, sleep_interval, activation_probability, username, password):\n        bait = DroneEdge(capability=capability, activation_range=activation_range, sleep_interval=sleep_interval,\n                         activation_probability=activation_probability, username=username, password=password)\n        bait.client_id = self.id\n        self.baits.append(bait)\nbeeswarm/drones/client/models/session.py\nclass BaitSession(BaseSession):\n    client_id = ''\n\n    def __init__(self, protocol, destination_ip, destination_port, honeypot_id):\n        super(BaitSession, self).__init__(protocol, destination_ip=destination_ip,\n                                          destination_port=destination_port)\n\n        assert BaitSession.client_id\n\n        self.client_id = BaitSession.client_id\n        self.honeypot_id = honeypot_id\n\n        self.did_connect = False\n        self.did_login = False\n        self.alldone = False\n        self.did_complete = False\n        self.protocol_data = {}\n\n    def to_dict(self):\n        return vars(self)\n\n    def end_session(self):\n        super(BaitSession, self).end_session(Messages.SESSION_CLIENT.value)\nbeeswarm/drones/honeypot/models/session.py\nclass Session(BaseSession):\n    authenticator = None\n    default_timeout = 25\n    honeypot_id = None\n\n    def __init__(self, source_ip, source_port, protocol, users, destination_port=None, destination_ip=None):\n\n        super(Session, self).__init__(protocol, source_ip, source_port, destination_ip, destination_port)\n\n        self.connected = True\n        self.authenticated = False\n        self.honeypot_id = Session.honeypot_id\n        self.users = users\n\n        # for session specific volatile data (will not get logged)\n        self.vdata = {}\n        self.last_activity = datetime.utcnow()\n\n        self.send_log(Messages.SESSION_PART_HONEYPOT_SESSION_START.value, self.to_dict())\n\n    def activity(self):\n        self.last_activity = datetime.utcnow()\n\n    def is_connected(self):\n        return self.connected\n\n    def try_auth(self, _type, **kwargs):\n        authenticated = False\n        if _type == 'plaintext':\n            if kwargs.get('username') in self.users:\n                if self.users[kwargs.get('username')] == kwargs.get('password'):\n                    authenticated = True\n\n        elif _type == 'cram_md5':\n            def encode_cram_md5(challenge, user, password):\n                response = user + ' ' + hmac.HMAC(password, challenge).hexdigest()\n                return response\n\n            if kwargs.get('username') in self.users:\n                uname = kwargs.get('username')\n                digest = kwargs.get('digest')\n                s_pass = self.users[uname]\n                challenge = kwargs.get('challenge')\n                ideal_response = encode_cram_md5(challenge, uname, s_pass)\n                _, ideal_digest = ideal_response.split()\n                if ideal_digest == digest:\n                    authenticated = True\n        elif _type == 'des_challenge':\n            challenge = kwargs.get('challenge')\n            response = kwargs.get('response')\n            for valid_password in self.users.values():\n                aligned_password = (valid_password + '\\0' * 8)[:8]\n                des = RFBDes(aligned_password)\n                expected_response = des.encrypt(challenge)\n                if response == expected_response:\n                    authenticated = True\n                    kwargs['password'] = aligned_password\n                    break\n        else:\n            assert False\n\n        if authenticated:\n            self.authenticated = True\n            self.add_auth_attempt(_type, True, **kwargs)\n        else:\n            self.add_auth_attempt(_type, False, **kwargs)\n\n        if _type == 'des_challenge':\n            kwargs['challenge'] = kwargs.get('challenge').encode('hex')\n            kwargs['response'] = kwargs.get('response').encode('hex')\n\n        self.send_log(Messages.SESSION_PART_HONEYPOT_AUTH.value, self.login_attempts[-1])\n        logger.debug('{0} authentication attempt from {1}:{2}. Credentials: {3}'.format(self.protocol, self.source_ip,\n                                                                                        self.source_port,\n                                                                                        json.dumps(kwargs)))\n        return authenticated\n\n    def end_session(self):\n        super(Session, self).end_session(Messages.SESSION_HONEYPOT.value)\nbeeswarm/shared/helpers.py\ndef send_zmq_request_socket(socket, request):\n    socket.send(request)\n    result = socket.recv()\n    status, data = result.split(' ', 1)\n    if status != Messages.OK.value:\n        logger.error('Receiving actor on socket {0} failed to respond properly. The request was: {1}'.format(socket,\n                                                                                                             request))\n        assert False\n    else:\n        if data.startswith('{') or data.startswith('['):\n            return json.loads(result.split(' ', 1)[1])\n        else:\n            return data\nbeeswarm/server/db/database_setup.py\ndef setup_db(connection_string):\ndef clear_db():\ndef get_session():\nbeeswarm/server/db/entities.py\nclass Session(Base):\n    __tablename__ = 'session'\n    discriminator = Column('type', String(50))\n    __mapper_args__ = {'polymorphic_on': discriminator}\n\n    id = Column(String, primary_key=True)\n    received = Column(DateTime)\n    timestamp = Column(DateTime, index=True)\n    protocol = Column(String)\n    authentication = relationship('Authentication', cascade=\"all, delete-orphan\")\n    source_ip = Column(String)\n    source_port = Column(Integer)\n    session_data = relationship('SessionData', cascade=\"all, delete-orphan\", backref='Session')\n    transcript = relationship('Transcript', cascade=\"all, delete-orphan\", backref='Session')\n    destination_ip = Column(String)\n    destination_port = Column(Integer)\n    honeypot_id = Column(String, ForeignKey('honeypot.id'))\n    drone = relationship(Drone, primaryjoin=honeypot_id==Drone.id, foreign_keys=honeypot_id, backref='session')\n    classification_id = Column(String, ForeignKey('classification.type'), nullable=False, default='pending')\n    classification = relationship('Classification')\n\n    # for display purposes\n    def to_dict(self):\n\n        auth_attempts = []\n        for attempt in self.authentication:\n            auth_attempts.append(attempt.to_dict())\n        classification = self.classification_id.replace('_', ' ').capitalize()\n        result = {'time': self.timestamp.strftime('%Y-%m-%d %H:%M:%S'),\n                  'protocol': self.protocol,\n                  'ip_address': self.source_ip,\n                  'honeypot_id': self.honeypot_id,\n                  'classification': classification,\n                  'id': self.id,\n                  'drone_name': '',\n                  }\n                  # drone can be None when unit testing\n        if self.drone:\n            result['drone_name'] = self.drone.name\n\n        return result\nbeeswarm/shared/message_enum.py\nclass Messages(Enum):\n    STOP = 'STOP'\n    START = 'START'\n    CONFIG = 'CONFIG'\n    # dump of all configuration elements known to the sender\n    CONFIG_FULL = 'CONFIG_FULL'\n    # mapping between clients, honeypots, capabilities and bait users\n    CONFIG_ARCHITECTURE = 'CONFIG_ARCHITECTURE'\n    BROADCAST = 'BROADCAST'\n\n    OK = 'OK'\n    FAIL = 'FAIL'\n    # KEY DRONE_ID DRONE_PRIVATE_KEY\n    KEY = 'KEY'\n    # CERT DRONE_ID DRONE_CERT\n    CERT = 'CERT'\n\n    # All data on an entire session, this also indicates session end.\n    SESSION_HONEYPOT = 'SESSION_HONEYPOT'\n    # Network connect to a honeypot, data format is as in SESSION_HONEYPOT, but not all fields has data.\n    SESSION_PART_HONEYPOT_SESSION_START = 'SESSION_PART_HONEYPOT_SESSION_START'\n    # Authentication attempt, format is as in self.login_attempts list SESSION_HONEYPOT\n    SESSION_PART_HONEYPOT_AUTH = 'SESSION_PART_HONEYPOT_AUTH'\n    SESSION_CLIENT = 'SESSION_CLIENT'\n\n    SET_CONFIG_ITEM = 'SET'\n    GET_CONFIG_ITEM = 'GET'\n    GET_ZMQ_KEYS = 'GET_ZMQ_KEYS'\n    DELETE_ZMQ_KEYS = 'DELETE_ZMQ_KEYS'\n    PING = 'PING'\n    PONG = 'PING'\n    IP = 'IP'\n\n    DRONE_WANT_CONFIG = 'DRONE_WANT_CONFIG'\n    DRONE_CONFIG = 'DRONE_CONFIG'\n    # ID USERNAME PASSWORD\n    BAIT_USER_ADD = 'BAIT_USER_ADD'\n    BAIT_USER_DELETE = 'BAIT_USER_DELETE'\n    GET_BAIT_USERS = 'GET_BAIT_USERS'\n    DRONE_DELETE = 'DRONE_DELETE'\n    DRONE_ADD = 'DRONE_ADD'\n\n    # Session was deleted because it was matched with an existing session\n    # This happens when a bait session is matched with a honeypot session.\n    # ID_OF_DELETED_SESSION ID_OF_THE_MERGED_SESSION\n    DELETED_DUE_TO_MERGE = \"DELETED_DUE_TO_MERGE\"\n\n    # A classified session is transmitted\n    # Parameters is data in json.\n    SESSION = \"SESSION\"\n\n    # Database requests\n    GET_DB_STATS = 'GET_DB_STATS'\n    # TODO: Following three should have to/from params to facilitate pagination\n    GET_SESSIONS_ALL = 'GET_SESSIONS_ALL'\n    GET_SESSIONS_BAIT = 'GET_SESSIONS_BAIT'\n    GET_SESSIONS_ATTACKS = 'GET_SESSIONS_ATTACKS'\n\n    # Param: session id\n    GET_SESSION_TRANSCRIPT = 'GET_SESSION_TRANSCRIPT'\n    # Param: session id\n    GET_SESSION_CREDENTIALS = 'GET_SESSION_CREDENTIALS'\n    # Param dronetype\n    GET_DRONE_LIST = 'GET_DRONE_LIST'\n    # Param: clientId config\n    CONFIG_DRONE = 'CONFIG_DRONE'\n\n    # Param: clientId config\n    PING_ALL_DRONES = 'PING_ALL_DRONES'\nbeeswarm/server/misc/config_actor.py\nclass ConfigActor(Greenlet):\n    def __init__(self, config_file, work_dir):\n        Greenlet.__init__(self)\n        self.config_file = os.path.join(work_dir, config_file)\n        if not os.path.exists(self.config_file):\n            self.config = {}\n            self._save_config_file()\n        self.config = json.load(open(self.config_file, 'r'))\n        self.work_dir = work_dir\n\n        context = beeswarm.shared.zmq_context\n        self.config_commands = context.socket(zmq.REP)\n        self.enabled = True\n\n    def stop(self):\n        self.enabled = False\n\n        if self.config_commands:\n            self.config_commands.close()\n\n    def _run(self):\n        self.config_commands.bind(SocketNames.CONFIG_COMMANDS.value)\n\n        poller = zmq.Poller()\n        poller.register(self.config_commands, zmq.POLLIN)\n        while self.enabled:\n            socks = dict(poller.poll(500))\n            if self.config_commands in socks and socks[self.config_commands] == zmq.POLLIN:\n                self._handle_commands()\n\n    def _handle_commands(self):\n        msg = self.config_commands.recv()\n\n        if ' ' in msg:\n            cmd, data = msg.split(' ', 1)\n        else:\n            cmd = msg\n        logger.debug('Received command: {0}'.format(cmd))\n\n        if cmd == Messages.SET_CONFIG_ITEM.value:\n            self._handle_command_set(data)\n            self.config_commands.send('{0} {1}'.format(Messages.OK.value, '{}'))\n        elif cmd == Messages.GET_CONFIG_ITEM.value:\n            value = self._handle_command_get(data)\n            self.config_commands.send('{0} {1}'.format(Messages.OK.value, value))\n        elif cmd == Messages.GET_ZMQ_KEYS.value:\n            self._handle_command_getkeys(data)\n        elif cmd == Messages.DELETE_ZMQ_KEYS.value:\n            self._remove_zmq_keys(data)\n            self.config_commands.send('{0} {1}'.format(Messages.OK.value, '{}'))\n        else:\n            logger.error('Unknown command received: {0}'.format(cmd))\n            self.config_commands.send(Messages.FAIL.value)\n\n    def _handle_command_set(self, data):\n        new_config = json.loads(data)\n        self.config.update(new_config)\n        self._save_config_file()\n\n    def _handle_command_get(self, data):\n        # example: 'network,host' will lookup self.config['network']['host']\n        keys = data.split(',')\n        value = self._retrieve_nested_config(keys, self.config)\n        return value\n\n    def _retrieve_nested_config(self, keys, dict):\n        if keys[0] in dict:\n            if len(keys) == 1:\n                return dict[keys[0]]\n            else:\n                return self._retrieve_nested_config(keys[1:], dict[keys[0]])\n\n    def _handle_command_getkeys(self, name):\n        private_key, publickey = self._get_zmq_keys(name)\n        self.config_commands.send(Messages.OK.value + ' ' + json.dumps({'public_key': publickey,\n                                                                        'private_key': private_key}))\n\n    def _save_config_file(self):\n        with open(self.config_file, 'w+') as config_file:\n            config_file.write(json.dumps(self.config, indent=4))\n\n    def _get_zmq_keys(self, id):\n        cert_path = os.path.join(self.work_dir, 'certificates')\n        public_keys = os.path.join(cert_path, 'public_keys')\n        private_keys = os.path.join(cert_path, 'private_keys')\n        public_key_path = os.path.join(public_keys, '{0}.pub'.format(id))\n        private_key_path = os.path.join(private_keys, '{0}.pri'.format(id))\n\n        if not os.path.isfile(public_key_path) or not os.path.isfile(private_key_path):\n            logging.debug('Generating ZMQ keys for: {0}.'.format(id))\n            for _path in [cert_path, public_keys, private_keys]:\n                if not os.path.isdir(_path):\n                    os.mkdir(_path)\n\n            tmp_key_dir = tempfile.mkdtemp()\n            try:\n                public_key, private_key = create_certificates(tmp_key_dir, id)\n                # the final location for keys\n                shutil.move(public_key, public_key_path)\n                shutil.move(private_key, private_key_path)\n            finally:\n                shutil.rmtree(tmp_key_dir)\n\n        # return copy of keys\n        return open(private_key_path, \"r\").readlines(), open(public_key_path, \"r\").readlines()\n\n    def _remove_zmq_keys(self, id):\n        cert_path = os.path.join(self.work_dir, 'certificates')\n        public_keys = os.path.join(cert_path, 'public_keys')\n        private_keys = os.path.join(cert_path, 'private_keys')\n        public_key_path = os.path.join(public_keys, '{0}.pub'.format(id))\n        private_key_path = os.path.join(private_keys, '{0}.pri'.format(id))\n\n        for _file in [public_key_path, private_key_path]:\n            if os.path.isfile(_file):\n                os.remove(_file)\nbeeswarm/shared/socket_enum.py\nclass SocketNames(Enum):\n    #### Sockets used on server ####\n    # All data received from drones will be published on this socket\n    DRONE_DATA = 'inproc://droneData'\n    # After sessions has been classified they will get retransmitted on this socket.\n    # TODO: Does not actually happen yet\n    PROCESSED_SESSIONS = 'inproc://processedSessionPublisher'\n    # Request / Reply to config actor\n    CONFIG_COMMANDS = 'inproc://configCommands'\n    # Data sent on this socket will be retransmitted to the correct drone, the data must be prefixed with\n    # the id of the drone.\n    DRONE_COMMANDS = 'inproc://droneCommands'\n\n\n    # Requests to and from the databsae\n    DATABASE_REQUESTS = 'inproc://databaseRequests'\n\n    #### Sockets used on drones ####\n    # Drone commands received from the server will be retransmitted  on this socket.\n    SERVER_COMMANDS = 'inproc://serverCommands'\n    # All messages transmitted on this socket will get retransmitted to the server\n    SERVER_RELAY = 'inproc://serverRelay'\n", "answers": ["        config_actor = ConfigActor(config_file, '')"], "length": 4341, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "d9e850b26e46db1f85cfd5cfccaa9eeaf3ed3a7e82901888"}
{"input": "package com.socks.jiandan.adapter;\nimport android.content.Intent;\nimport android.graphics.Bitmap;\nimport android.graphics.Typeface;\nimport android.support.v7.widget.CardView;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ProgressBar;\nimport android.widget.TextView;\nimport com.afollestad.materialdialogs.MaterialDialog;\nimport com.nostra13.universalimageloader.core.listener.SimpleImageLoadingListener;\nimport com.socks.jiandan.JDApplication;\nimport com.socks.jiandan.R;\nimport com.socks.jiandan.base.BaseActivity;\nimport com.socks.jiandan.base.ConstantString;\nimport com.socks.jiandan.cache.PictureCache;\nimport com.socks.jiandan.callback.LoadFinishCallBack;\nimport com.socks.jiandan.callback.LoadResultCallBack;\nimport com.socks.jiandan.model.Picture;\nimport com.socks.jiandan.net.JDApi;\nimport com.socks.jiandan.ui.activity.CommentListActivity;\nimport com.socks.jiandan.utils.FileUtil;\nimport com.socks.jiandan.utils.GsonHelper;\nimport com.socks.jiandan.utils.IntentHelper;\nimport com.socks.jiandan.utils.NetWorkUtil;\nimport com.socks.jiandan.utils.ShareUtil;\nimport com.socks.jiandan.utils.String2TimeUtil;\nimport com.socks.jiandan.utils.TextUtil;\nimport com.socks.jiandan.utils.ToastHelper;\nimport com.socks.jiandan.view.ShowMaxImageView;\nimport com.socks.jiandan.view.imageloader.ImageLoadProxy;\nimport java.util.ArrayList;\nimport java.util.List;\nimport butterknife.Bind;\nimport butterknife.ButterKnife;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.android.schedulers.AndroidSchedulers;\nimport rx.schedulers.Schedulers;\nimport static com.socks.jiandan.R.color.secondary_text_default_material_light;\n\n\n\n\n\n\npublic class PictureAdapter extends RecyclerView.Adapter<PictureAdapter.PictureViewHolder> {\n\n    private int page;\n    private int lastPosition = -1;\n    private int mType;\n    private boolean isWifiConnected;\n\n    private ArrayList<Picture> mPictures;\n    private LoadFinishCallBack<Object> mLoadFinisCallBack;\n    private LoadResultCallBack mLoadResultCallBack;\n    private BaseActivity mActivity;\n    private LoadFinishCallBack mSaveFileCallBack;\n\n    public PictureAdapter(BaseActivity activity, LoadResultCallBack loadResultCallBack, LoadFinishCallBack<Object> loadFinisCallBack, int type) {\n        mActivity = activity;\n        mType = type;\n        mLoadFinisCallBack = loadFinisCallBack;\n        mLoadResultCallBack = loadResultCallBack;\n        mPictures = new ArrayList<>();\n        isWifiConnected = NetWorkUtil.isWifiConnected(mActivity);\n    }\n\n    private void setAnimation(View viewToAnimate, int position) {\n        if (position > lastPosition) {\n            Animation animation = AnimationUtils.loadAnimation(viewToAnimate.getContext(), R\n                    .anim.item_bottom_in);\n            viewToAnimate.startAnimation(animation);\n            lastPosition = position;\n        }\n    }\n\n    @Override\n    public void onViewDetachedFromWindow(PictureViewHolder holder) {\n        super.onViewDetachedFromWindow(holder);\n        holder.card.clearAnimation();\n    }\n\n    @Override\n    public PictureViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View v = LayoutInflater.from(parent.getContext())\n                .inflate(R.layout.item_pic, parent, false);\n        return new PictureViewHolder(v);\n    }\n\n    @Override\n    public void onBindViewHolder(final PictureViewHolder holder, final int position) {\n\n        final Picture picture = mPictures.get(position);\n        String picUrl = picture.getPics()[0];\n\n        if (picUrl.endsWith(\".gif\")) {\n            holder.img_gif.setVisibility(View.VISIBLE);\n            //非WIFI网络情况下，GIF图只加载缩略图，详情页才加载真实图片\n            if (!isWifiConnected) {\n                picUrl = picUrl.replace(\"mw600\", \"small\").replace(\"mw1200\", \"small\").replace\n                        (\"large\", \"small\");\n            }\n        } else {\n            holder.img_gif.setVisibility(View.GONE);\n        }\n\n        holder.progress.setProgress(0);\n        holder.progress.setVisibility(View.VISIBLE);\n\n        ImageLoadProxy.displayImageList(picUrl, holder.img, R.drawable.ic_loading_large, new\n                        SimpleImageLoadingListener() {\n                            @Override\n                            public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {\n                                super.onLoadingComplete(imageUri, view, loadedImage);\n                                holder.progress.setVisibility(View.GONE);\n                            }\n                        },\n                (imageUri, view, current, total) -> holder.progress.setProgress((int) (current * 100f / total)));\n\n        if (TextUtil.isNull(picture.getText_content().trim())) {\n            holder.tv_content.setVisibility(View.GONE);\n        } else {\n            holder.tv_content.setVisibility(View.VISIBLE);\n            holder.tv_content.setText(picture.getText_content().trim());\n        }\n\n        holder.img.setOnClickListener(v -> IntentHelper.toImageDetailActivity(mActivity, picture));\n\n        holder.tv_author.setText(picture.getComment_author());\n        holder.tv_time.setText(String2TimeUtil.dateString2GoodExperienceFormat(picture.getComment_date()));\n        holder.tv_like.setText(picture.getVote_positive());\n        holder.tv_comment_count.setText(picture.getComment_counts());\n\n        //用于恢复默认的文字\n        holder.tv_like.setTypeface(Typeface.DEFAULT);\n        holder.tv_like.setTextColor(mActivity.getResources().getColor(\n                secondary_text_default_material_light));\n        holder.tv_support_des.setTextColor(mActivity.getResources().getColor(\n                secondary_text_default_material_light));\n\n        holder.tv_unlike.setText(picture.getVote_negative());\n        holder.tv_unlike.setTypeface(Typeface.DEFAULT);\n        holder.tv_unlike.setTextColor(mActivity.getResources().getColor(\n                secondary_text_default_material_light));\n        holder.tv_un_support_des.setTextColor(mActivity.getResources().getColor(\n                secondary_text_default_material_light));\n\n        holder.img_share.setOnClickListener(v -> new MaterialDialog.Builder(mActivity)\n                .items(R.array.picture_dialog)\n                .backgroundColor(mActivity.getResources().getColor(JDApplication.COLOR_OF_DIALOG))\n                .contentColor(JDApplication.COLOR_OF_DIALOG_CONTENT)\n                .itemsCallback((dialog, view, which, text) -> {\n\n                    switch (which) {\n                        case 0:", "context": "app/src/main/java/com/socks/jiandan/utils/ShareUtil.java\npublic class ShareUtil {\n\n    public static void sharePicture(Activity activity, String url) {\n\n        String[] urlSplits = url.split(\"\\\\.\");\n\n        File cacheFile = ImageLoader.getInstance().getDiskCache().get(url);\n\n        //如果不存在，则使用缩略图进行分享\n        if (!cacheFile.exists()) {\n            String picUrl = url;\n            picUrl = picUrl.replace(\"mw600\", \"small\").replace(\"mw1200\", \"small\").replace\n                    (\"large\", \"small\");\n            cacheFile = ImageLoader.getInstance().getDiskCache().get(picUrl);\n        }\n\n        File newFile = new File(CacheUtil.getSharePicName\n                (cacheFile, urlSplits));\n\n        if (FileUtil.copyTo(cacheFile, newFile)) {\n            ShareUtil.sharePicture(activity, newFile.getAbsolutePath(),\n                    \"分享自煎蛋 \" + url);\n        } else {\n            ToastHelper.Short(ConstantString.LOAD_SHARE);\n        }\n    }\n\n\n    public static void shareText(Activity activity, String shareText) {\n\n        Intent intent = new Intent(Intent.ACTION_SEND);\n        intent.setType(\"text/plain\");\n        intent.putExtra(Intent.EXTRA_TEXT,\n                shareText);\n        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        activity.startActivity(Intent.createChooser(intent, activity.getResources().getString(R\n                .string.app_name)));\n    }\n\n    public static void sharePicture(Activity activity, String imgPath, String shareText) {\n\n        Intent intent = new Intent(Intent.ACTION_SEND);\n        File f = new File(imgPath);\n        if (f != null && f.exists() && f.isFile()) {\n            intent.setType(\"image/*\");\n            intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(f));\n        } else {\n            ToastHelper.Short(\"分享图片不存在哦\");\n            return;\n        }\n\n        //GIF图片指明出处url，其他图片指向项目地址\n        if (imgPath.endsWith(\".gif\")) {\n            intent.putExtra(Intent.EXTRA_TEXT, shareText);\n        }\n\n        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        activity.startActivity(Intent.createChooser(intent, activity.getResources().getString(R\n                .string.app_name)));\n    }\n\n\n}\napp/src/main/java/com/socks/jiandan/cache/PictureCache.java\npublic class PictureCache extends BaseCache {\n\n\tprivate static PictureCache instance;\n\tprivate static PictureCacheDao mPictureCacheDao;\n\n\tprivate PictureCache() {\n\t}\n\n\tpublic static PictureCache getInstance(Context context) {\n\n\t\tif (instance == null) {\n\n\t\t\tsynchronized (PictureCache.class) {\n\t\t\t\tif (instance == null) {\n\t\t\t\t\tinstance = new PictureCache();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmDaoSession = JDApplication.getDaoSession(context);\n\t\t\tmPictureCacheDao = mDaoSession.getPictureCacheDao();\n\t\t}\n\t\treturn instance;\n\t}\n\n\t/**\n\t * 清楚全部缓存\n\t */\n\tpublic void clearAllCache() {\n\t\tmPictureCacheDao.deleteAll();\n\t}\n\n\t/**\n\t * 根据页码获取缓存数据\n\t *\n\t * @param page\n\t * @return\n\t */\n\t@Override\n\tpublic ArrayList<Picture> getCacheByPage(int page) {\n\n\t\tQueryBuilder<com.socks.greendao.PictureCache> query = mPictureCacheDao.queryBuilder().where(PictureCacheDao\n\t\t\t\t.Properties.Page.eq(\"\" + page));\n\n\t\tif (query.list().size() > 0) {\n\t\t\treturn (ArrayList<Picture>) JSONParser.toObject(query.list().get(0).getResult(),\n\t\t\t\t\tnew TypeToken<ArrayList<Picture>>() {\n\t\t\t\t\t}.getType());\n\t\t} else {\n\t\t\treturn new ArrayList<>();\n\t\t}\n\n\t}\n\n\t/**\n\t * 添加Jokes缓存\n\t *\n\t * @param result\n\t * @param page\n\t */\n\t@Override\n\tpublic void addResultCache(String result, int page) {\n\t\tcom.socks.greendao.PictureCache pictureCache = new com.socks.greendao.PictureCache();\n\t\tpictureCache.setResult(result);\n\t\tpictureCache.setPage(page);\n\t\tpictureCache.setTime(System.currentTimeMillis());\n\n\t\tmPictureCacheDao.insert(pictureCache);\n\t}\n\n}\napp/src/main/java/com/socks/jiandan/utils/GsonHelper.java\npublic class GsonHelper<T> {\n\n    public static Gson mGson;\n\n    static {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            GsonBuilder gsonBuilder = new GsonBuilder()\n                    .excludeFieldsWithModifiers(\n                            Modifier.FINAL,\n                            Modifier.TRANSIENT,\n                            Modifier.STATIC);\n            mGson = gsonBuilder.create();\n        } else {\n            mGson = new Gson();\n        }\n    }\n\n\n    public static String toString(Object obj) {\n        return mGson.toJson(obj);\n    }\n\n    public T fromJson(String json, Class<T> classOfT) {\n        return mGson.fromJson(json, classOfT);\n    }\n\n    public T fromJson(String json, Type typeOfT) {\n        return mGson.fromJson(json, typeOfT);\n    }\n\n}\napp/src/main/java/com/socks/jiandan/model/Picture.java\npublic class Picture implements Serializable {\n\n    public static final String URL_BORING_PICTURE = \"http://jandan.net/?oxwlxojflwblxbsapi=jandan.get_pic_comments&page=\";\n    public static final String URL_SISTER = \"http://jandan.net/?oxwlxojflwblxbsapi=jandan.get_ooxx_comments&page=\";\n\n    public static final int BoringPicture = 1;\n    public static final int Sister = 2;\n\n    private String comment_ID;\n    private String comment_author;\n    private String comment_date;\n    private String text_content;\n    private String vote_positive;\n    private String vote_negative;\n    private String[] pics;\n    //评论数量，需要单独获取\n    private String comment_counts;\n\n    public Picture() {\n    }\n\n    public static String getRequestUrl(int type, int page) {\n\n        switch (type) {\n            case BoringPicture:\n                return URL_BORING_PICTURE + page;\n            case Sister:\n                return URL_SISTER + page;\n            default:\n                return \"\";\n        }\n    }\n\n    public String getComment_ID() {\n        return comment_ID;\n    }\n\n    public String getComment_author() {\n        return comment_author;\n    }\n\n    public String getComment_date() {\n        return comment_date;\n    }\n\n    public String getText_content() {\n        return text_content;\n    }\n\n    public String getVote_positive() {\n        return vote_positive;\n    }\n\n    public String getVote_negative() {\n        return vote_negative;\n    }\n\n    public String getComment_counts() {\n        return comment_counts;\n    }\n\n    public void setComment_counts(String comment_counts) {\n        this.comment_counts = comment_counts;\n    }\n\n    public String[] getPics() {\n        return pics;\n    }\n\n}\napp/src/main/java/com/socks/jiandan/ui/activity/CommentListActivity.java\npublic class CommentListActivity extends BaseActivity implements LoadResultCallBack {\n\n    @Bind(R.id.swipe_refresh)\n    SwipeRefreshLayout mSwipeRefreshLayout;\n    @Bind(R.id.recycler_view)\n    RecyclerView mRecyclerView;\n    @Bind(R.id.toolbar)\n    Toolbar mToolbar;\n    @Bind(R.id.loading)\n    RotateLoading loading;\n\n    private boolean isFromFreshNews;\n    private CommentAdapter mAdapter;\n\n    @Override\n    protected void initView(@Nullable Bundle savedInstanceState) {\n        setContentView(R.layout.activity_comment_list);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitleTextColor(Color.WHITE);\n        setSupportActionBar(mToolbar);\n        mToolbar.setTitle(\"评论\");\n        mToolbar.setNavigationIcon(R.drawable.ic_actionbar_back);\n\n        mRecyclerView.setHasFixedSize(false);\n        mRecyclerView.setLayoutManager(new LinearLayoutManager(this));\n\n        mSwipeRefreshLayout.setColorSchemeResources(android.R.color.holo_blue_bright,\n                android.R.color.holo_green_light,\n                android.R.color.holo_orange_light,\n                android.R.color.holo_red_light);\n\n        mSwipeRefreshLayout.setOnRefreshListener(() -> {\n            if (isFromFreshNews) {\n                mAdapter.loadData4FreshNews();\n            } else {\n                mAdapter.loadData();\n            }\n        });\n    }\n\n    @Override\n    protected void loadData() {\n        String thread_key = getIntent().getStringExtra(DATA_THREAD_KEY);\n        String thread_id = getIntent().getStringExtra(DATA_THREAD_ID);\n        isFromFreshNews = getIntent().getBooleanExtra(DATA_IS_FROM_FRESH_NEWS, false);\n\n        if (isFromFreshNews) {\n            mAdapter = new CommentAdapter(this, thread_id, true, this);\n            if (TextUtils.isEmpty(thread_id) || thread_id.equals(\"0\")) {\n                ToastHelper.Short(FORBID_COMMENTS);\n                finish();\n            }\n        } else {\n            mAdapter = new CommentAdapter(this, thread_key, false, this);\n            if (TextUtils.isEmpty(thread_key) || thread_key.equals(\"0\")) {\n                ToastHelper.Short(FORBID_COMMENTS);\n                finish();\n            }\n        }\n        mRecyclerView.setAdapter(mAdapter);\n        if (isFromFreshNews) {\n            mAdapter.loadData4FreshNews();\n        } else {\n            mAdapter.loadData();\n        }\n        loading.start();\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if (resultCode == RESULT_OK) {\n            if (isFromFreshNews) {\n                mAdapter.loadData4FreshNews();\n            } else {\n                mAdapter.loadData();\n            }\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.menu_comment_list, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                finish();\n                return true;\n            case R.id.action_edit:\n                Intent intent = new Intent(this, PushCommentActivity.class);\n                intent.putExtra(DATA_THREAD_ID, mAdapter.getThreadId());\n                startActivityForResult(intent, 0);\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onSuccess(int result, Object object) {\n        if (result == LoadResultCallBack.SUCCESS_NONE) {\n            ToastHelper.Short(NO_COMMENTS);\n        }\n        loading.stop();\n        mSwipeRefreshLayout.setRefreshing(false);\n    }\n\n    @Override\n    public void onError(int code) {\n        mSwipeRefreshLayout.setRefreshing(false);\n        loading.stop();\n        ToastHelper.Short(LOAD_FAILED);\n    }\n\n}\napp/src/main/java/com/socks/jiandan/JDApplication.java\npublic class JDApplication extends Application {\n\n    public static int COLOR_OF_DIALOG = R.color.primary;\n    public static int COLOR_OF_DIALOG_CONTENT = Color.WHITE;\n\n    private static Context mContext;\n    private static DaoMaster daoMaster;\n    private static DaoSession daoSession;\n\n    private RefWatcher refWatcher;\n\n    @Override\n    public void onCreate() {\n        StrictModeUtil.init();\n        super.onCreate();\n        mContext = this;\n\n        refWatcher = LeakCanary.install(this);\n        ImageLoadProxy.initImageLoader(this);\n        initHttpClient();\n        SPHelper.init(mContext);\n        KLog.init(BuildConfig.DEBUG);\n    }\n\n    private void initHttpClient() {\n\n        OkHttpClient.Builder builder = new OkHttpClient.Builder();\n        builder.connectTimeout(30, TimeUnit.SECONDS);\n        builder.readTimeout(30, TimeUnit.SECONDS);\n        builder.writeTimeout(30, TimeUnit.SECONDS);\n        builder.retryOnConnectionFailure(true);\n        OkHttpProxy.setInstance(builder.build());\n\n    }\n\n    public static Context getContext() {\n        return mContext;\n    }\n\n    public static RefWatcher getRefWatcher(Context context) {\n        JDApplication application = (JDApplication) context.getApplicationContext();\n        return application.refWatcher;\n    }\n\n\n    public static DaoMaster getDaoMaster(Context context) {\n        if (daoMaster == null) {\n            DaoMaster.OpenHelper helper = new DaoMaster.DevOpenHelper(context, BaseCache.DB_NAME, null);\n            daoMaster = new DaoMaster(helper.getWritableDatabase());\n        }\n        return daoMaster;\n    }\n\n    public static DaoSession getDaoSession(Context context) {\n        if (daoSession == null) {\n            if (daoMaster == null) {\n                daoMaster = getDaoMaster(context);\n            }\n            daoSession = daoMaster.newSession();\n        }\n        return daoSession;\n    }\n\n}\napp/src/main/java/com/socks/jiandan/callback/LoadFinishCallBack.java\npublic interface LoadFinishCallBack<T> {\n    \n    void loadFinish(T t);\n\n}\napp/src/main/java/com/socks/jiandan/view/ShowMaxImageView.java\npublic class ShowMaxImageView extends ImageView {\n\n\tprivate float mHeight = 0;\n\n\tpublic ShowMaxImageView(Context context) {\n\t\tsuper(context);\n\t}\n\n\tpublic ShowMaxImageView(Context context, AttributeSet attrs) {\n\t\tsuper(context, attrs);\n\t}\n\n\tpublic ShowMaxImageView(Context context, AttributeSet attrs, int defStyleAttr) {\n\t\tsuper(context, attrs, defStyleAttr);\n\t}\n\n\t@Override\n\tpublic void setImageBitmap(Bitmap bm) {\n\n\t\tif (bm != null) {\n\t\t\tgetHeight(bm);\n\t\t}\n\n\t\tsuper.setImageBitmap(bm);\n\t\trequestLayout();\n\t}\n\n\t@Override\n\tpublic void setImageDrawable(Drawable drawable) {\n\n\t\tif (drawable != null) {\n\t\t\tgetHeight(drawableToBitamp(drawable));\n\t\t}\n\n\t\tsuper.setImageDrawable(drawable);\n\t\trequestLayout();\n\t}\n\n\t@Override\n\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\n\t\tif (mHeight != 0) {\n\n\t\t\tint sizeWidth = MeasureSpec.getSize(widthMeasureSpec);\n\t\t\tint sizeHeight = MeasureSpec.getSize(heightMeasureSpec);\n\n\t\t\tint resultHeight = (int) Math.max(mHeight, sizeHeight);\n\n\t\t\tif (resultHeight >= ScreenSizeUtil.getScreenHeight((Activity) getContext())) {\n\t\t\t\tresultHeight = ScreenSizeUtil.getScreenHeight((Activity) getContext()) / 3;\n\t\t\t}\n\n\t\t\tsetMeasuredDimension(sizeWidth, resultHeight);\n\t\t} else {\n\t\t\tsuper.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\t\t}\n\n\t}\n\n\tprivate void getHeight(Bitmap bm) {\n\n\t\tfloat bitmapWidth = bm.getWidth();\n\t\tfloat bitmapHeight = bm.getHeight();\n\n\t\tif (bitmapWidth > 0 && bitmapHeight > 0) {\n\t\t\tfloat scaleWidth = getWidth() / bitmapWidth;\n\t\t\tmHeight = bitmapHeight * scaleWidth;\n\t\t}\n\n\t}\n\n\n\tprivate Bitmap drawableToBitamp(Drawable drawable) {\n\n\t\tif (drawable != null) {\n\t\t\tBitmapDrawable bd = (BitmapDrawable) drawable;\n\t\t\treturn bd.getBitmap();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n}\napp/src/main/java/com/socks/jiandan/utils/ToastHelper.java\npublic class ToastHelper {\r\n\r\n    public static void Short(@NonNull CharSequence sequence) {\r\n        Toast.makeText(JDApplication.getContext(), sequence, Toast.LENGTH_SHORT).show();\r\n    }\r\n\r\n    public static void Short(@StringRes int id) {\r\n        Toast.makeText(JDApplication.getContext(), id, Toast.LENGTH_SHORT).show();\r\n    }\r\n\r\n    public static void Long(@StringRes int id) {\r\n        Toast.makeText(JDApplication.getContext(), id, Toast.LENGTH_LONG).show();\r\n    }\r\n\r\n    public static void Long(@NonNull CharSequence sequence) {\r\n        Toast.makeText(JDApplication.getContext(), sequence, Toast.LENGTH_LONG).show();\r\n    }\r\n\r\n}\r\napp/src/main/java/com/socks/jiandan/base/BaseActivity.java\npublic abstract class BaseActivity extends AppCompatActivity implements ConstantString {\n\n    private CompositeSubscription mCompositeSubscription;\n    protected Context mContext;\n    protected boolean isTransitionAnimation = true;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mContext = this;\n        initView(savedInstanceState);\n        loadData();\n    }\n\n    protected abstract void initView(@Nullable Bundle savedInstanceState);\n\n    protected abstract void loadData();\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        JDApplication.getRefWatcher(this).watch(this);\n        if (mCompositeSubscription != null) {\n            mCompositeSubscription.unsubscribe();\n        }\n    }\n\n    @Override\n    public void finish() {\n        super.finish();\n        if (isTransitionAnimation) {\n            overridePendingTransition(R.anim.anim_none, R.anim.trans_center_2_right);\n        }\n    }\n\n    public CompositeSubscription getCompositeSubscription() {\n        if (this.mCompositeSubscription == null) {\n            this.mCompositeSubscription = new CompositeSubscription();\n        }\n\n        return this.mCompositeSubscription;\n    }\n\n\n    public void addSubscription(Subscription s) {\n        if (this.mCompositeSubscription == null) {\n            this.mCompositeSubscription = new CompositeSubscription();\n        }\n\n        this.mCompositeSubscription.add(s);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Fragment Method\n    ///////////////////////////////////////////////////////////////////////////\n\n    protected Fragment findFragmentByTag(String tag) {\n        FragmentManager manager = getSupportFragmentManager();\n        return manager.findFragmentByTag(tag);\n    }\n\n    protected void addFragment(@IdRes int containerId, Fragment fragment, String tag) {\n        FragmentManager manager = getSupportFragmentManager();\n        FragmentTransaction transaction = manager.beginTransaction();\n        transaction.add(containerId, fragment, tag);\n        transaction.commit();\n    }\n\n    protected void showFragment(Fragment fragment) {\n        FragmentManager manager = getSupportFragmentManager();\n        FragmentTransaction transaction = manager.beginTransaction();\n        transaction.show(fragment);\n        transaction.commit();\n    }\n\n    protected void hideFragment(Fragment fragment) {\n        FragmentManager manager = getSupportFragmentManager();\n        FragmentTransaction transaction = manager.beginTransaction();\n        transaction.hide(fragment);\n        transaction.commit();\n    }\n\n    protected void removeFragment(Fragment fragment) {\n        FragmentManager manager = getSupportFragmentManager();\n        FragmentTransaction transaction = manager.beginTransaction();\n        transaction.remove(fragment);\n        transaction.commit();\n    }\n\n    protected void hideFragmentByTag(String... tags) {\n\n        if (tags.length <= 0) {\n            return;\n        }\n\n        FragmentManager manager = getSupportFragmentManager();\n        FragmentTransaction transaction = manager.beginTransaction();\n        for (String tag : tags) {\n            if (TextUtils.isEmpty(tag)) {\n                continue;\n            }\n            Fragment fragment = manager.findFragmentByTag(tag);\n            if (fragment != null) {\n                transaction.hide(fragment);\n            }\n        }\n        transaction.commit();\n    }\n\n    public void replaceFragment(@IdRes int id_content, Fragment fragment) {\n        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();\n        transaction.replace(id_content, fragment);\n        transaction.commit();\n    }\n}\napp/src/main/java/com/socks/jiandan/utils/FileUtil.java\npublic class FileUtil {\n\n    /**\n     * 获取文件夹总大小\n     *\n     * @param file\n     * @return\n     */\n    public static double getDirSize(File file) {\n        //判断文件是否存在\n        if (file.exists()) {\n            //如果是目录则递归计算其内容的总大小\n            if (file.isDirectory()) {\n                File[] children = file.listFiles();\n                double size = 0;\n                for (File f : children) {\n                    size += getDirSize(f);\n                }\n                return size;\n            } else {//如果是文件则直接返回其大小,以“兆”为单位\n                return (double) file.length() / 1024 / 1024;\n            }\n        } else {\n            return 0.0;\n        }\n    }\n\n    public static void savePicture(String picUrl, LoadFinishCallBack<Bundle> loadFinishCallBack) {\n\n        boolean isSmallPic = false;\n        String[] urls = picUrl.split(\"\\\\.\");\n        File cacheFile = ImageLoader.getInstance().getDiskCache().get(picUrl);\n\n        //如果是GIF格式，优先保存GIF动态图，如果不存在，则保存缩略图\n        if (!cacheFile.exists()) {\n            String cacheUrl = picUrl.replace(\"mw600\", \"small\").replace(\"mw1200\", \"small\")\n                    .replace(\"large\", \"small\");\n            cacheFile = ImageLoader.getInstance().getDiskCache().get(cacheUrl);\n            isSmallPic = true;\n        }\n\n        File picDir = new File(CacheUtil.getSaveDirPath());\n\n        if (!picDir.exists()) {\n\n            if (picDir.mkdir()) {\n                final File newFile = new File(picDir, CacheUtil.getSavePicName(cacheFile, urls));\n                if (FileUtil.copyTo(cacheFile, newFile)) {\n                    Bundle bundle = new Bundle();\n                    bundle.putBoolean(BaseActivity.DATA_IS_SMALL_PIC, isSmallPic);\n                    bundle.putString(BaseActivity.DATA_FILE_PATH, newFile.getAbsolutePath());\n                    loadFinishCallBack.loadFinish(bundle);\n                } else {\n                    ToastHelper.Short(ConstantString.SAVE_FAILED);\n                }\n            }\n        }\n    }\n\n    /**\n     * 复制文件\n     *\n     * @param src 源文件\n     * @param dst 目标文件\n     * @return\n     */\n    public static boolean copyTo(File src, File dst) {\n\n        FileInputStream fi = null;\n        FileOutputStream fo = null;\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            fi = new FileInputStream(src);\n            fo = new FileOutputStream(dst);\n            in = fi.getChannel();//得到对应的文件通道\n            out = fo.getChannel();//得到对应的文件通道\n            in.transferTo(0, in.size(), out);//连接两个通道，并且从in通道读取，然后写入out通道\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        } finally {\n            try {\n\n                if (fi != null) {\n                    fi.close();\n                }\n\n                if (in != null) {\n                    in.close();\n                }\n\n                if (fo != null) {\n                    fo.close();\n                }\n\n                if (out != null) {\n                    out.close();\n                }\n\n            } catch (IOException e) {\n                e.printStackTrace();\n                return false;\n            }\n        }\n\n    }\n\n\n}\napp/src/main/java/com/socks/jiandan/utils/TextUtil.java\npublic class TextUtil {\n\n    public static final String REG_EMAIL = \"\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*\";\n\n\n    public static boolean isEmail(String email) {\n        Pattern p = Pattern.compile(REG_EMAIL);\n        Matcher m = p.matcher(email);\n        return m.matches();\n    }\n\n\n    /**\n     * 判断是否为null、空字符串或者是\"null\"\n     *\n     * @param str\n     * @return\n     */\n    public static boolean isNull(CharSequence... str) {\n\n        for (CharSequence cha : str) {\n            if (cha == null || cha.length() == 0 || cha.equals(\"null\")) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void copy(Activity activity, String copyText) {\n        ClipboardManager clip = (ClipboardManager)\n                activity.getSystemService(Context\n                        .CLIPBOARD_SERVICE);\n        clip.setPrimaryClip(ClipData.newPlainText\n                (null, copyText));\n        ToastHelper.Short(ConstantString.COPY_SUCCESS);\n    }\n\n    public static String getHtml(FreshNews freshNews, String content) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"<!DOCTYPE html>\");\n        sb.append(\"<html dir=\\\"ltr\\\" lang=\\\"zh\\\">\");\n        sb.append(\"<head>\");\n        sb.append(\"<meta name=\\\"viewport\\\" content=\\\"width=100%; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;\\\" />\");\n        sb.append(\"<link rel=\\\"stylesheet\\\" href='file:///android_asset/style.css' type=\\\"text/css\\\" media=\\\"screen\\\" />\");\n        sb.append(\"</head>\");\n        sb.append(\"<body style=\\\"padding:0px 8px 8px 8px;\\\">\");\n        sb.append(\"<div id=\\\"pagewrapper\\\">\");\n        sb.append(\"<div id=\\\"mainwrapper\\\" class=\\\"clearfix\\\">\");\n        sb.append(\"<div id=\\\"maincontent\\\">\");\n        sb.append(\"<div class=\\\"post\\\">\");\n        sb.append(\"<div class=\\\"posthit\\\">\");\n        sb.append(\"<div class=\\\"postinfo\\\">\");\n        sb.append(\"<h2 class=\\\"thetitle\\\">\");\n        sb.append(\"<a>\");\n        sb.append(freshNews.title);\n        sb.append(\"</a>\");\n        sb.append(\"</h2>\");\n        sb.append(freshNews.author.getName() + \" @ \" + String2TimeUtil\n                .dateString2GoodExperienceFormat(freshNews.date));\n        sb.append(\"</div>\");\n        sb.append(\"<div class=\\\"entry\\\">\");\n        sb.append(content);\n        sb.append(\"</div>\");\n        sb.append(\"</div>\");\n        sb.append(\"</div>\");\n        sb.append(\"</div>\");\n        sb.append(\"</div>\");\n        sb.append(\"</div>\");\n        sb.append(\"</body>\");\n        sb.append(\"</html>\");\n        return sb.toString();\n    }\n\n}\napp/src/main/java/com/socks/jiandan/callback/LoadResultCallBack.java\npublic interface LoadResultCallBack {\n\n    int SUCCESS_OK = 1001;\n    int SUCCESS_NONE = 1002;\n    int ERROR_NET = 1003;\n\n    void onSuccess(int result, Object object);\n\n    void onError(int code);\n}\napp/src/main/java/com/socks/jiandan/net/JDApi.java\npublic class JDApi {\n\n    public static Observable<ArrayList<Video>> getVideos(int page) {\n        return Observable.create(new Observable.OnSubscribe<ArrayList<Video>>() {\n            @Override\n            public void call(Subscriber<? super ArrayList<Video>> subscriber) {\n                try {\n                    subscriber.onNext(new VideoParser().parse(OkHttpProxy.get().url(Video.getUrlVideos(page)).execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(applySchedulers());\n    }\n\n\n    public static Observable<ArrayList<Joke>> getJokes(int page) {\n        return Observable.create(new Observable.OnSubscribe<ArrayList<Joke>>() {\n            @Override\n            public void call(Subscriber<? super ArrayList<Joke>> subscriber) {\n                try {\n                    subscriber.onNext(new JokeParser().parse(OkHttpProxy.get().url(Joke.getRequestUrl(page)).execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(applySchedulers());\n    }\n\n\n    public static Observable<ArrayList<CommentNumber>> getCommentNumber(String comments) {\n\n        return Observable.create(new Observable.OnSubscribe<ArrayList<CommentNumber>>() {\n            @Override\n            public void call(Subscriber<? super ArrayList<CommentNumber>> subscriber) {\n                String url = CommentNumber.getCommentCountsURL(comments);\n                try {\n                    subscriber.onNext(new CommentCountsParser().parse(OkHttpProxy.get().url(url).execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(applySchedulers());\n    }\n\n\n    public static Observable<ArrayList<Picture>> getPictures(int type, int page) {\n\n        return Observable.create(new Observable.OnSubscribe<ArrayList<Picture>>() {\n            @Override\n            public void call(Subscriber<? super ArrayList<Picture>> subscriber) {\n                String url = Picture.getRequestUrl(type, page);\n                try {\n                    subscriber.onNext(new PictureParser().parse(OkHttpProxy.get().url(url).execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(applySchedulers());\n    }\n\n\n    public static Observable<Boolean> pushComment4DuoShuo(Map<String, String> params) {\n\n        return Observable.create(new Observable.OnSubscribe<Boolean>() {\n            @Override\n            public void call(Subscriber<? super Boolean> subscriber) {\n                try {\n                    subscriber.onNext(new PushCommentParser().parse(OkHttpProxy.post().url(Commentator.URL_PUSH_COMMENT).setParams(params).execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(applySchedulers());\n    }\n\n\n    public static Observable<Boolean> pushComment4FreshNews(String url) {\n\n        return Observable.create(new Observable.OnSubscribe<Boolean>() {\n            @Override\n            public void call(Subscriber<? super Boolean> subscriber) {\n                try {\n                    subscriber.onNext(new Push4FreshCommentParser().parse(OkHttpProxy.get().url(url).execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(applySchedulers());\n    }\n\n\n    public static Observable<ArrayList<Comment4FreshNews>> getCommentator4FreshNews(final String thread_key, LoadFinishCallBack callBack) {\n\n        return Observable.create(new Observable.OnSubscribe<ArrayList<Comment4FreshNews>>() {\n\n            @Override\n            public void call(Subscriber<? super ArrayList<Comment4FreshNews>> subscriber) {\n                String url = Comment4FreshNews.getUrlComments(thread_key);\n                try {\n                    subscriber.onNext(new FreshNewsCommentParser(callBack).parse(OkHttpProxy.get()\n                            .url(url)\n                            .execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(applySchedulers());\n    }\n\n\n    public static Observable<ArrayList<Commentator>> getCommentator(final String thread_key, LoadFinishCallBack callBack) {\n\n        return Observable.create(new Observable.OnSubscribe<ArrayList<Commentator>>() {\n\n            @Override\n            public void call(Subscriber<? super ArrayList<Commentator>> subscriber) {\n                String url = Commentator.getUrlCommentList(thread_key);\n                try {\n                    subscriber.onNext(new CommentListParser(callBack).parse(OkHttpProxy.get()\n                            .url(url)\n                            .execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(applySchedulers());\n    }\n\n\n    public static Observable<ArrayList<FreshNews>> getFreshNews(final int page) {\n\n        return Observable.create(new Observable.OnSubscribe<ArrayList<FreshNews>>() {\n\n            @Override\n            public void call(Subscriber<? super ArrayList<FreshNews>> subscriber) {\n                String url = FreshNews.getUrlFreshNews(page);\n                try {\n                    subscriber.onNext(new FreshNewsParser().parse(OkHttpProxy.get()\n                            .url(url)\n                            .execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(JDApi.<ArrayList<FreshNews>>applySchedulers());\n    }\n\n\n    public static Observable<String> getFreshDetail(String id) {\n        return Observable.create(new Observable.OnSubscribe<String>() {\n            @Override\n            public void call(Subscriber<? super String> subscriber) {\n                String url = FreshNews.getUrlFreshNewsDetail(id);\n                try {\n                    subscriber.onNext(new FreshNewsDetailParser().parse(OkHttpProxy.get().url(url).execute()));\n                    subscriber.onCompleted();\n                } catch (IOException e) {\n                    subscriber.onError(e);\n                }\n            }\n        }).compose(applySchedulers());\n    }\n\n    public static <T> Observable.Transformer<T, T> applySchedulers() {\n        return observable -> observable.subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread());\n    }\n\n}\napp/src/main/java/com/socks/jiandan/base/ConstantString.java\npublic interface ConstantString {\n\n    String COMMENT_FAILED = \"神秘力量导致评论失败 ⊙︿⊙\";\n    String VOTE_FAILED = \"神秘力量导致投票失败 ⊙︿⊙\";\n    String LOAD_FAILED = \"神秘力量导致加载失败 ⊙︿⊙\";\n    String SAVE_FAILED = \"神秘力量导致保存失败 ⊙︿⊙\";\n    String LOAD_SHARE = \"神秘力量导致分享失败 ⊙︿⊙\";\n\n    String INPUT_TOO_SHORT = \"你的..太短..\";\n    String COPY_SUCCESS = \"复制成功\";\n    String SAVE_SUCCESS = \"保存成功\";\n    String SAVE_SMALL_SUCCESS = \"保存缩略图成功\";\n    String VOTE_XX = \"疼...轻点插\";\n    String VOTE_OO = \"顶的好舒服~\";\n    String VOTE_REPEAT = \"投过票了\";\n    String LOAD_NO_NETWORK = \"无网络，当前为缓存数据\";\n    String FORBID_COMMENTS = \"禁止评论\";\n    String NO_COMMENTS = \"暂无评论\";\n    String UN_CLICK = \"别点了，这玩意不能用\";\n\n    String DATA_FRESH_NEWS = \"FreshNews\";\n    String DATA_POSITION = \"position\";\n    String DATA_THREAD_ID = \"thread_id\";\n    String DATA_THREAD_KEY = \"thread_key\";\n    String DATA_IS_FROM_FRESH_NEWS = \"is_from_fresh_news\";\n\n    String DATA_IMAGE_URL = \"img_url\";\n    String DATA_IMAGE_ID = \"img_id\";\n    String DATA_IMAGE_AUTHOR = \"img_author\";\n    String DATA_IS_NEED_WEB_VIEW = \"is_need_webview\";\n\n    String DATA_IS_SMALL_PIC =  \"isSmallPic\";\n    String DATA_FILE_PATH =  \"file_path\";\n\n}\napp/src/main/java/com/socks/jiandan/utils/IntentHelper.java\npublic class IntentHelper {\n\n    public static void toSettingActivity(Context context) {\n        Intent intent = new Intent(\n                Settings.ACTION_WIRELESS_SETTINGS);\n        context.startActivity(intent);\n    }\n\n    public static void toFreshDetailActivity(Context context, ArrayList<FreshNews> mFreshNews, int position) {\n        Intent intent = new Intent(context, FreshNewsDetailActivity.class);\n        intent.putExtra(FreshNewsDetailActivity.DATA_FRESH_NEWS, mFreshNews);\n        intent.putExtra(FreshNewsDetailActivity.DATA_POSITION, position);\n        context.startActivity(intent);\n    }\n\n    public static void toCommentListActivity(Context context, String id) {\n        Intent intent = new Intent(context, CommentListActivity.class);\n        intent.putExtra(BaseActivity.DATA_THREAD_ID, id);\n        intent.putExtra(BaseActivity.DATA_IS_FROM_FRESH_NEWS, true);\n        context.startActivity(intent);\n    }\n\n    public static void toPushComment4Result(Activity context, String postId, String threadId, String parentName){\n        Intent intent = new Intent\n                (context, PushCommentActivity.class);\n        intent.putExtra(\"parent_id\", postId);\n        intent.putExtra(\"thread_id\", threadId);\n        intent.putExtra(\"parent_name\", parentName);\n        context.startActivityForResult(intent, 0);\n    }\n\n\n    public static void toImageDetailActivity(Context context, Picture picture){\n        Intent intent = new Intent(context, ImageDetailActivity.class);\n\n        intent.putExtra(BaseActivity.DATA_IMAGE_AUTHOR, picture.getComment_author());\n        intent.putExtra(BaseActivity.DATA_IMAGE_URL, picture.getPics());\n        intent.putExtra(BaseActivity.DATA_IMAGE_ID, picture.getComment_ID());\n        intent.putExtra(BaseActivity.DATA_THREAD_KEY, \"comment-\" + picture.getComment_ID());\n\n        if (picture.getPics()[0].endsWith(\".gif\")) {\n            intent.putExtra(BaseActivity.DATA_IS_NEED_WEB_VIEW, true);\n        }\n\n        context.startActivity(intent);\n    }\n}\n", "answers": ["                            ShareUtil.sharePicture(mActivity, picture"], "length": 2796, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "08e95c1f144ac0dd144b0a74d05d16910ae0ff82d33ba978"}
{"input": "import os\nimport numpy as np\nimport argparse as ap\nfrom time import time\nfrom tfce_mediation.cynumstats import resid_covars\nfrom tfce_mediation.tfce import CreateAdjSet\nfrom tfce_mediation.tm_io import read_tm_filetype, write_tm_filetype, savemgh_v2, savenifti_v2\nfrom tfce_mediation.pyfunc import save_ply, convert_voxel, vectorized_surface_smooth\nfrom tfce_mediation.tm_func import calculate_tfce, calculate_mediation_tfce, calc_mixed_tfce, apply_mfwer, create_full_mask, merge_adjacency_array, lowest_length, create_position_array, paint_surface, strip_basename, saveauto\n\tcorrectionoptions.add_argument(\"-ssr\",\"--setsurfacerange\", \n\t\thelp=\"Must be used with -mfwe option. Input a range to set the surfaces to create pFWE corrected images using a range. Family-wise error rate correction will only applied to the specified surfaces. e.g., -ssr 0 3\", \n\t\tnargs=2,\n\t\ttype=int,\n\t\tmetavar=('INT'))\n\n\treturn ap\n\ndef run(opts):\n\tcurrentTime=int(time())\n\tif opts.multisurfacefwecorrection:\n\t\t#############################\n\t\t###### FWER CORRECTION ######\n\t\t#############################\n\t\t_, image_array, masking_array, maskname, affine_array, vertex_array, face_array, surfname, adjacency_array, tmi_history, columnids = read_tm_filetype('%s' % opts.tmifile[0], verbose=False)\n\n\t\t# check file dimensions\n\t\tif not image_array[0].shape[1] % 3 == 0:\n\t\t\tprint('Print file format is not understood. Please make sure %s is statistics file.' % opts.tmifile[0])\n\t\t\tquit()\n\t\telse:\n\t\t\tnum_contrasts = int(image_array[0].shape[1] / 3)\n\n\t\t# get surface coordinates in data array\n\t\tposition_array = create_position_array(masking_array)\n\n\t\tif num_contrasts == 1:\n\t\t\t# get lists for positive and negative contrasts\n\t\t\tpos_range = [1]\n\t\t\tneg_range = [2]\n\t\telse:\n\t\t\t# get lists for positive and negative contrasts\n\t\t\tpos_range = list(range(num_contrasts, num_contrasts+num_contrasts))\n\t\t\tneg_range = list(range(num_contrasts*2, num_contrasts*2+num_contrasts))\n\n\t\t# check that randomisation has been run\n\t\tif not os.path.exists(\"%s/output_%s/perm_maxTFCE_surf0_tcon1.csv\" % (os.getcwd(),opts.tmifile[0])): # make this safer\n\t\t\tprint('Permutation folder not found. Please run --randomise first.')\n\t\t\tquit()\n\n\t\t#check permutation file lengths\n\t\tnum_surf = len(masking_array)\n\t\tsurface_range = list(range(num_surf))\n\t\tnum_perm = lowest_length(num_contrasts, surface_range, opts.tmifile[0])\n\n\t\tif opts.setsurfacerange:\n\t\t\tsurface_range = list(range(opts.setsurfacerange[0], opts.setsurfacerange[1]+1))\n\t\telif opts.setsurface:\n\t\t\tsurface_range = opts.setsurface\n\t\tif np.array(surface_range).max() > len(masking_array):\n\t\t\tprint(\"Error: range does note fit the surfaces contained in the tmi file. %s contains the following surfaces\" % opts.tmifile[0])\n\t\t\tfor i in range(len(surfname)):\n\t\t\t\tprint((\"Surface %d : %s, %s\" % (i,surfname[i], maskname[i])))\n\t\t\tquit()\n\t\tprint(\"Reading %d contrast(s) from %d of %d surface(s)\" % ((num_contrasts),len(surface_range), num_surf))\n\t\tprint(\"Reading %s permutations with an accuracy of p=0.05+/-%.4f\" % (num_perm,(2*(np.sqrt(0.05*0.95/num_perm)))))\n\n\t\t# calculate the P(FWER) images from all surfaces\n\t\tpositive_data, negative_data = apply_mfwer(image_array, num_contrasts, surface_range, num_perm, num_surf, opts.tmifile[0], position_array, pos_range, neg_range, weight='logmasksize')\n\n\t\t# write out files\n\t\tif opts.concatestats:\n\t\t\twrite_tm_filetype(opts.tmifile[0],\n\t\t\t\timage_array = positive_data,\n\t\t\t\tmasking_array = masking_array,\n\t\t\t\tmaskname = maskname,\n\t\t\t\taffine_array = affine_array,\n\t\t\t\tvertex_array = vertex_array,\n\t\t\t\tface_array = face_array,\n\t\t\t\tsurfname = surfname,\n\t\t\t\tadjacency_array = adjacency_array,\n\t\t\t\tcheckname = False,\n\t\t\t\ttmi_history = tmi_history)\n\t\t\t_, image_array, masking_array, maskname, affine_array, vertex_array, face_array, surfname, adjacency_array, tmi_history, columnids = read_tm_filetype(opts.tmifile[0], verbose=False)\n\t\t\twrite_tm_filetype(opts.tmifile[0],\n\t\t\t\timage_array = np.column_stack((image_array[0],negative_data)),\n\t\t\t\tmasking_array = masking_array,\n\t\t\t\tmaskname = maskname,\n\t\t\t\taffine_array = affine_array,\n\t\t\t\tvertex_array = vertex_array,\n\t\t\t\tface_array = face_array,\n\t\t\t\tsurfname = surfname,\n\t\t\t\tadjacency_array = adjacency_array,\n\t\t\t\tcheckname = False,\n\t\t\t\ttmi_history = tmi_history)\n\t\telse:\n\t\t\tfor i in range(len(opts.outtype)):\n\t\t\t\tif opts.outtype[i] == 'tmi':\n\t\t\t\t\tcontrast_names = []\n\n\t\t\t\t\tfor j in range(num_contrasts):\n\t\t\t\t\t\tcontrast_names.append((\"tstat_pFWER_con%d\" % (j+1)))\n\t\t\t\t\tfor k in range(num_contrasts):\n\t\t\t\t\t\tcontrast_names.append((\"negtstat_pFWER_con%d\" % (k+1)))\n\n\t\t\t\t\toutdata = np.column_stack((positive_data,negative_data))\n\n\t\t\t\t\tif opts.neglog:\n\t\t\t\t\t\tfor j in range(num_contrasts):\n\t\t\t\t\t\t\tcontrast_names.append((\"tstat_negLog_pFWER_con%d\" % (j+1)))\n\t\t\t\t\t\tfor k in range(num_contrasts):\n\t\t\t\t\t\t\tcontrast_names.append((\"negtstat_negLog_pFWER_con%d\" % (k+1)))\n\n\t\t\t\t\toutdata = np.column_stack((outdata,-np.log10(1-positive_data)))\n\t\t\t\t\toutdata = np.column_stack((outdata,-np.log10(1-negative_data)))\n\n\t\t\t\t\twrite_tm_filetype(\"pFWER_%s\" % opts.tmifile[0],\n\t\t\t\t\t\timage_array = outdata,\n\t\t\t\t\t\tmasking_array = masking_array,\n\t\t\t\t\t\tmaskname = maskname,\n\t\t\t\t\t\taffine_array = affine_array,\n\t\t\t\t\t\tvertex_array = vertex_array,\n\t\t\t\t\t\tface_array = face_array,\n\t\t\t\t\t\tsurfname = surfname,\n\t\t\t\t\t\tcheckname = False,\n\t\t\t\t\t\tcolumnids = np.array(contrast_names),\n\t\t\t\t\t\ttmi_history = tmi_history)\n\n\t\t\t\telse:\n\t\t\t\t\tif opts.outtype[i] == 'mgh':\n", "context": "tfce_mediation/tm_func.py\ndef calculate_tfce(merge_y, masking_array, pred_x, calcTFCE, vdensity, position_array, fullmask, perm_number = None, randomise = False, verbose = False, no_intercept = True, set_surf_count = None, print_interation = False):\n\tX = np.column_stack([np.ones(merge_y.shape[0]),pred_x])\n\tif randomise:\n\t\tnp.random.seed(perm_number+int(float(str(time())[-6:])*100))\n\t\tX = X[np.random.permutation(list(range(merge_y.shape[0])))]\n\tk = len(X.T)\n\tinvXX = np.linalg.inv(np.dot(X.T, X))\n\ttvals = tval_int(X, invXX, merge_y, merge_y.shape[0], k, merge_y.shape[1])\n\tif no_intercept:\n\t\ttvals = tvals[1:,:]\n\ttvals = tvals.astype(np.float32, order = \"C\")\n\ttfce_tvals = np.zeros_like(tvals).astype(np.float32, order = \"C\")\n\tneg_tfce_tvals = np.zeros_like(tvals).astype(np.float32, order = \"C\")\n\n\tfor tstat_counter in range(tvals.shape[0]):\n\t\ttval_temp = np.zeros_like((fullmask)).astype(np.float32, order = \"C\")\n\t\tif tvals.shape[0] == 1:\n\t\t\ttval_temp[fullmask==1] = tvals[0]\n\t\telse:\n\t\t\ttval_temp[fullmask==1] = tvals[tstat_counter]\n\t\ttval_temp = tval_temp.astype(np.float32, order = \"C\")\n\t\ttfce_temp = np.zeros_like(tval_temp).astype(np.float32, order = \"C\")\n\t\tneg_tfce_temp = np.zeros_like(tval_temp).astype(np.float32, order = \"C\")\n\t\tcalcTFCE.run(tval_temp, tfce_temp)\n\t\tcalcTFCE.run((tval_temp*-1), neg_tfce_temp)\n\t\ttval_temp = tval_temp[fullmask==1]\n\t\ttfce_temp = tfce_temp[fullmask==1]\n\t\tneg_tfce_temp = neg_tfce_temp[fullmask==1]\n#\t\tposition = 0\n\t\tfor surf_count in range(len(masking_array)):\n\t\t\tstart = position_array[surf_count]\n\t\t\tend = position_array[surf_count+1]\n\t\t\tif isinstance(vdensity, int): # check vdensity is a scalar\n\t\t\t\ttfce_tvals[tstat_counter,start:end] = (tfce_temp[start:end] * (tval_temp[start:end].max()/100) * vdensity)\n\t\t\t\tneg_tfce_tvals[tstat_counter,start:end] = (neg_tfce_temp[start:end] * ((tval_temp*-1)[start:end].max()/100) * vdensity)\n\t\t\telse:\n\t\t\t\ttfce_tvals[tstat_counter,start:end] = (tfce_temp[start:end] * (tval_temp[start:end].max()/100) * vdensity[start:end])\n\t\t\t\tneg_tfce_tvals[tstat_counter,start:end] = (neg_tfce_temp[start:end] * ((tval_temp*-1)[start:end].max()/100) * vdensity[start:end])\n\t\t\tif randomise:\n\t\t\t\tif set_surf_count is not None:\n\t\t\t\t\tos.system(\"echo %f >> perm_maxTFCE_surf%d_tcon%d.csv\" % (np.nanmax(tfce_tvals[tstat_counter,start:end]),int(set_surf_count[surf_count]),tstat_counter+1))\n\t\t\t\t\tos.system(\"echo %f >> perm_maxTFCE_surf%d_tcon%d.csv\" % (np.nanmax(neg_tfce_tvals[tstat_counter,start:end]),int(set_surf_count[surf_count]),tstat_counter+1))\n\t\t\t\telse:\n\t\t\t\t\tos.system(\"echo %f >> perm_maxTFCE_surf%d_tcon%d.csv\" % (np.nanmax(tfce_tvals[tstat_counter,start:end]),surf_count,tstat_counter+1))\n\t\t\t\t\tos.system(\"echo %f >> perm_maxTFCE_surf%d_tcon%d.csv\" % (np.nanmax(neg_tfce_tvals[tstat_counter,start:end]),surf_count,tstat_counter+1))\n\t\t\telse:\n\t\t\t\tif set_surf_count is not None:\n\t\t\t\t\tprint(\"Maximum (untransformed) postive tfce value for surface %s, tcon %d: %f\" % (int(set_surf_count[surf_count]),tstat_counter+1,np.nanmax(tfce_tvals[tstat_counter,start:end]))) \n\t\t\t\t\tprint(\"Maximum (untransformed) negative tfce value for surface %s, tcon %d: %f\" % (int(set_surf_count[surf_count]),tstat_counter+1,np.nanmax(neg_tfce_tvals[tstat_counter,start:end])))\n\t\t\t\telse:\n\t\t\t\t\tprint(\"Maximum (untransformed) postive tfce value for surface %s, tcon %d: %f\" % (surf_count,tstat_counter+1,np.nanmax(tfce_tvals[tstat_counter,start:end]))) \n\t\t\t\t\tprint(\"Maximum (untransformed) negative tfce value for surface %s, tcon %d: %f\" % (surf_count,tstat_counter+1,np.nanmax(neg_tfce_tvals[tstat_counter,start:end])))\n\t\tif verbose:\n\t\t\tprint(\"T-contrast: %d\" % tstat_counter)\n\t\t\tprint(\"Max tfce from all surfaces = %f\" % tfce_tvals[tstat_counter].max())\n\t\t\tprint(\"Max negative tfce from all surfaces = %f\" % neg_tfce_tvals[tstat_counter].max())\n\tif randomise:\n\t\tif print_interation:\n\t\t\tprint(\"Interation number: %d\" % perm_number)\n#\t\tos.system(\"echo %s >> perm_maxTFCE_allsurf.csv\" % ( ','.join([\"%0.2f\" % i for i in tfce_tvals.max(axis=1)] )) )\n#\t\tos.system(\"echo %s >> perm_maxTFCE_allsurf.csv\" % ( ','.join([\"%0.2f\" % i for i in neg_tfce_tvals.max(axis=1)] )) )\n\t\ttvals = None\n\t\ttfce_tvals = None\n\t\tneg_tfce_tvals = None\n\ttval_temp = None\n\ttfce_temp = None\n\tneg_tfce_temp = None\n\tdel calcTFCE\n\tif not randomise:\n\t\treturn (tvals.astype(np.float32, order = \"C\"), tfce_tvals.astype(np.float32, order = \"C\"), neg_tfce_tvals.astype(np.float32, order = \"C\"))\ntfce_mediation/tm_func.py\ndef paint_surface(lowthresh, highthres, color_scheme, data_array, save_colorbar = True):\n\tcolormaps = np.array(plt.colormaps(),dtype=np.str)\n\tif (str(color_scheme) == 'r_y') or (str(color_scheme) == 'red-yellow'):\n\t\tout_color_array = convert_redtoyellow(np.array((float(lowthresh),float(highthres))), data_array, save_colorbar = save_colorbar)\n\telif (str(color_scheme) == 'b_lb') or (str(color_scheme) == 'blue-lightblue'):\n\t\tout_color_array = convert_bluetolightblue(np.array((float(lowthresh),float(highthres))), data_array, save_colorbar = save_colorbar)\n\telif np.any(colormaps == str(color_scheme)):\n\t\tout_color_array = convert_mpl_colormaps(np.array((float(lowthresh),float(highthres))), data_array, str(color_scheme), save_colorbar = save_colorbar)\n\telse:\n\t\tprint(\"Error: colour scheme %s does not exist\" % str(color_scheme))\n\t\tquit()\n\treturn out_color_array\ntfce_mediation/tm_func.py\ndef apply_mfwer(image_array, num_contrasts, surface_range, num_perm, num_surf, tminame, position_array, pos_range, neg_range = None, method = 'scale', weight = None, mediation = False, medtype = None): \n\t# weight = None is essentially Tippet without considering mask size\n\n\tmaxvalue_array = np.zeros((num_perm,num_contrasts))\n\ttemp_max = np.zeros((num_perm, num_surf))\n\tpositive_data = np.zeros((image_array[0].shape[0],num_contrasts))\n\tif mediation == False:\n\t\tnegative_data = np.zeros((image_array[0].shape[0],num_contrasts))\n\n\tif weight == 'logmasksize':\n\t\tx = []\n\t\tfor i in range(len(position_array)-1):\n\t\t\tx.append((position_array[i+1] - position_array[i]))\n\t\tweights = (np.log(x)/np.log(x).sum())/np.mean(np.log(x)/np.log(x).sum()) # weights between mask size and max values probablity.\n\t\tw_temp_max = np.zeros((num_perm, num_surf))\n\n\tfor contrast in range(num_contrasts):\n\t\tfor surface in surface_range: # the standardization is done within each surface\n\t\t\tif mediation == False:\n\t\t\t\tlog_perm_results = np.log(np.genfromtxt('output_%s/perm_maxTFCE_surf%d_tcon%d.csv' % (tminame,surface,contrast+1))[:num_perm])\n\t\t\telse:\n\t\t\t\tlog_perm_results = np.log(np.genfromtxt('output_%s/perm_maxTFCE_surf%d_%s_zstat.csv' % (tminame,surface,str(medtype)))[:num_perm])\n\t\t\t# set log(0) back to zero (only happens with small masks and very large effect sizes)\n\t\t\tlog_perm_results[np.isinf(log_perm_results)] = 0\n\t\t\tstart = position_array[surface]\n\t\t\tend = position_array[surface+1]\n\n\t\t\t# log transform, standarization\n\t\t\tposvmask = np.log(image_array[0][start:end,pos_range[contrast]]) > 0\n\t\t\ttemp_lt = np.log(image_array[0][start:end,pos_range[contrast]][posvmask]) # log and z transform the images by the permutation values (the max tfce values are left skewed)\n\t\t\ttemp_lt -= log_perm_results.mean()\n\t\t\ttemp_lt /= log_perm_results.std()\n\t\t\ttemp_lt += 10\n\t\t\tpositive_data[start:end,contrast][posvmask] = temp_lt\n\t\t\tdel temp_lt, posvmask\n\n\t\t\tif mediation == False:\n\t\t\t\tposvmask = np.log(image_array[0][start:end,neg_range[contrast]]) > 0\n\t\t\t\ttemp_lt = np.log(image_array[0][start:end,neg_range[contrast]][posvmask]) # log and z transform the images by the permutation values (the max tfce values are left skewed)\n\t\t\t\ttemp_lt -= log_perm_results.mean()\n\t\t\t\ttemp_lt /= log_perm_results.std()\n\t\t\t\ttemp_lt += 10\n\t\t\t\tnegative_data[start:end,contrast][posvmask] = temp_lt\n\t\t\t\tdel temp_lt, posvmask\n\n\t\t\tlog_perm_results -= log_perm_results.mean() # standardize the max TFCE values \n\t\t\tlog_perm_results /= log_perm_results.std()\n\t\t\tif weight == 'logmasksize':\n\t\t\t\tw_log_perm_results = log_perm_results * weights[surface]\n\t\t\t\tw_log_perm_results += 10\n\t\t\t\tw_temp_max[:,surface] = w_log_perm_results\n\t\t\tlog_perm_results += 10\n\t\t\ttemp_max[:,surface] = log_perm_results\n\n\n\t\tif not weight == None:\n\t\t\tw_temp_max[np.isnan(w_temp_max)]=0\n\t\t\tmax_index = np.argmax(w_temp_max, axis=1)\n\t\t\tmax_value_list = np.zeros((len(max_index)),dtype=np.float32) # this should not be necessary\n\t\t\tfor i in range(len(temp_max)):\n\t\t\t\tmax_value_list[i]= temp_max[i,max_index[i]]\n\t\t\tmaxvalue_array[:,contrast] = np.sort(max_value_list)\n\t\t\tdel max_value_list\n\t\telse:\n\t\t\tmaxvalue_array[:,contrast] = np.sort(temp_max.max(axis=1))\n\tdel temp_max\n\t# two for loops just so my brain doesn't explode\n\tfor contrast in range(num_contrasts):\n\t\tsorted_perm_tfce_max=maxvalue_array[:,contrast]\n\t\tp_array=np.zeros_like(sorted_perm_tfce_max)\n\t\tcorrp_img = np.zeros((positive_data.shape[0]))\n\t\tfor j in range(num_perm):\n\t\t\tp_array[j] = np.true_divide(j,num_perm)\n\t\tcV=0\n\t\tfor k in positive_data[:,contrast]:\n\t\t\tcorrp_img[cV] = find_nearest(sorted_perm_tfce_max,k,p_array)\n\t\t\tcV+=1\n\t\tpositive_data[:,contrast] = np.copy(corrp_img)\n\t\tif mediation == False:\n\t\t\tcV=0\n\t\t\tcorrp_img = np.zeros((negative_data.shape[0]))\n\t\t\tfor k in negative_data[:,contrast]:\n\t\t\t\tcorrp_img[cV] = find_nearest(sorted_perm_tfce_max,k,p_array)\n\t\t\t\tcV+=1\n\t\t\tnegative_data[:,contrast] = np.copy(corrp_img)\n\tif mediation == False:\n\t\treturn positive_data, negative_data\n\telse:\n\t\treturn positive_data\ntfce_mediation/tm_io.py\ndef savenifti_v2(image_array, index, imagename, affine=None):\n\tif not ((imagename.endswith('nii')) or (imagename.endswith('nii.gz'))):\n\t\timagename += '.nii.gz'\n\toutdata = image_array.astype(np.float32, order = \"C\")\n\tif image_array.ndim == 2:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2],image_array.shape[1]))\n\telif image_array.ndim == 1:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2]))\n\telse:\n\t\tprint('error')\n\timgout[index]=outdata\n\tnib.save(nib.Nifti1Image(imgout.astype(np.float32, order = \"C\"),affine=affine),imagename)\ntfce_mediation/tm_func.py\ndef create_position_array(masking_array):\n\tpointer = 0\n\tposition_array = [0]\n\tfor i in range(len(masking_array)):\n\t\tpointer += len(masking_array[i][masking_array[i]==True])\n\t\tposition_array.append(pointer)\n\treturn position_array\ntfce_mediation/tm_func.py\ndef calculate_mediation_tfce(medtype, merge_y, masking_array, pred_x, depend_y, calcTFCE, vdensity, position_array, fullmask, perm_number = None, randomise = False, verbose = False, no_intercept = True, print_interation = False):\n\tif randomise:\n\t\tnp.random.seed(perm_number+int(float(str(time())[-6:])*100))\n\t\tindices_perm = np.random.permutation(list(range(merge_y.shape[0])))\n\t\tif (medtype == 'M') or (medtype == 'I'):\n\t\t\tif randomise:\n\t\t\t\tpred_x = pred_x[indices_perm]\n\t\telse:\n\t\t\tif randomise:\n\t\t\t\tpred_x = pred_x[indices_perm]\n\t\t\t\tdepend_y = depend_y[indices_perm]\n\tSobelZ = calc_sobelz(medtype, pred_x, depend_y, merge_y, merge_y.shape[0], merge_y.shape[1])\n\tSobelZ = SobelZ.astype(np.float32, order = \"C\")\n\ttfce_SobelZ = np.zeros_like(SobelZ).astype(np.float32, order = \"C\")\n\tzval_temp = np.zeros_like((fullmask)).astype(np.float32, order = \"C\")\n\tzval_temp[fullmask==1] = SobelZ\n\tzval_temp = zval_temp.astype(np.float32, order = \"C\")\n\ttfce_temp = np.zeros_like(zval_temp).astype(np.float32, order = \"C\")\n\tcalcTFCE.run(zval_temp, tfce_temp)\n\tzval_temp = zval_temp[fullmask==1]\n\ttfce_temp = tfce_temp[fullmask==1]\n\tfor surf_count in range(len(masking_array)):\n\t\tstart = position_array[surf_count]\n\t\tend = position_array[surf_count+1]\n\t\tif isinstance(vdensity, int): # check vdensity is a scalar\n\t\t\ttfce_SobelZ[start:end] = (tfce_temp[start:end] * (zval_temp[start:end].max()/100) * vdensity)\n\t\telse:\n\t\t\ttfce_SobelZ[start:end] = (tfce_temp[start:end] * (zval_temp[start:end].max()/100) * vdensity[start:end])\n\t\tif randomise:\n\t\t\tos.system(\"echo %f >> perm_maxTFCE_surf%d_%s_zstat.csv\" % (np.nanmax(tfce_SobelZ[start:end]), surf_count, medtype))\n\t\telse:\n\t\t\tprint(\"Max Sobel Z tfce value for surface %s:\\t %1.5f\" % (surf_count, np.nanmax(tfce_SobelZ[start:end]))) \n\tif verbose:\n\t\tprint(\"Max Zstat tfce from all surfaces = %f\" % tfce_SobelZ.max())\n\tif randomise:\n\t\tprint(\"Interation number: %d\" % perm_number)\n\t\tSobelZ = None\n\t\ttfce_SobelZ = None\n\tzval_temp = None\n\ttfce_temp = None\n\tdel calcTFCE\n\tif not randomise:\n\t\treturn (SobelZ.astype(np.float32, order = \"C\"), tfce_SobelZ.astype(np.float32, order = \"C\"))\ntfce_mediation/tm_func.py\ndef create_full_mask(masking_array):\n\t# make mega mask\n\tfullmask = []\n\tfor i in range(len(masking_array)):\n\t\tif masking_array[i].shape[2] == 1: # check if vertex or voxel image\n\t\t\tfullmask = np.hstack((fullmask, masking_array[i][:,0,0]))\n\t\telse:\n\t\t\tfullmask = np.hstack((fullmask, masking_array[i][masking_array[i]==True]))\n\treturn fullmask\ntfce_mediation/pyfunc.py\ndef save_ply(v, f, outname, color_array=None, output_binary=True):\n\t# check file extension\n\tif not outname.endswith('ply'):\n\t\tif output_binary:\n\t\t\toutname += '.ply'\n\t\telse:\n\t\t\toutname += '.ascii.ply'\n\toutname=check_outname(outname)\n\n\t# write header \n\theader = (\"ply\\n\")\n\tif output_binary:\n\t\theader += (\"format binary_%s_endian 1.0\\n\" % (sys.byteorder))\n\t\tif sys.byteorder == 'little':\n\t\t\toutput_fmt = '<'\n\t\telse:\n\t\t\toutput_fmt = '>'\n\telse:\n\t\theader += (\"format ascii 1.0\\n\")\n\theader += (\"comment made with TFCE_mediation\\n\")\n\theader += (\"element vertex %d\\n\" % len(v))\n\theader += (\"property float x\\n\")\n\theader += (\"property float y\\n\")\n\theader += (\"property float z\\n\")\n\tif color_array is not None:\n\t\theader += (\"property uchar red\\n\")\n\t\theader += (\"property uchar green\\n\")\n\t\theader += (\"property uchar blue\\n\")\n\theader += (\"element face %d\\n\" % len(f))\n\theader += (\"property list uchar int vertex_index\\n\")\n\theader += (\"end_header\\n\")\n\n\t# write to file\n\twith open(outname, \"a\") as o:\n\t\to.write(header)\n\t\tfor i in range(len(v)):\n\t\t\tif output_binary:\n\t\t\t\tif color_array is not None:\n\t\t\t\t\to.write(\n\t\t\t\t\t\tstruct.pack(output_fmt + 'fffBBB', v[i, 0], v[i, 1], v[i, 2], color_array[i, 0], color_array[i, 1], color_array[i, 2]))\n\t\t\t\telse:\n\t\t\t\t\to.write(struct.pack(output_fmt + 'fff', v[i, 0], v[i, 1], v[i, 2]))\n\t\t\telse:\n\t\t\t\tif color_array is not None:\n\t\t\t\t\to.write(\"%1.6f %1.6f %1.6f %d %d %d\\n\" % (v[i, 0], v[i, 1], v[i, 2], color_array[i, 0], color_array[i, 1], color_array[i, 2]))\n\t\t\t\telse:\n\t\t\t\t\to.write(\"%1.6f %1.6f %1.6f\\n\" % (v[i, 0], v[i, 1], v[i, 2]))\n\t\tfor j in range(len(f)):\n\t\t\tif output_binary:\n\t\t\t\to.write(struct.pack('<Biii', 3, f[j, 0], f[j, 1], f[j, 2]))\n\t\t\telse:\n\t\t\t\to.write(\"3 %d %d %d\\n\" % (f[j, 0], f[j, 1], f[j, 2]))\ntfce_mediation/tm_func.py\ndef calc_mixed_tfce(assigntfcesettings, merge_y, masking_array, position_array, vdensity, pred_x, calcTFCE, perm_number = None, randomise = False, medtype = None, depend_y = None):\n\tfor i in np.unique(assigntfcesettings):\n\t\tdata_mask = np.zeros(merge_y.shape[1], dtype=bool)\n\t\textract_range = np.argwhere(assigntfcesettings==i)\n\t\tfor surface in extract_range:\n\t\t\tstart = position_array[int(surface)]\n\t\t\tend = position_array[int(surface)+1]\n\t\t\tdata_mask[start:end] = True\n\t\tsubset_merge_y = merge_y[:,data_mask]\n\t\ttry:\n\t\t\ttemp_vdensity = vdensity[data_mask]\n\t\texcept:\n\t\t\ttemp_vdensity = 1\n\n\t\tif randomise:\n\t\t\t\n\t\t\tif i == 0:\n\t\t\t\tdisplay_iter = True\n\t\t\telse:\n\t\t\t\tdisplay_iter = False\n\n\t\t\tcalculate_tfce(subset_merge_y, \n\t\t\t\tnp.array(masking_array)[assigntfcesettings==i], \n\t\t\t\tpred_x, \n\t\t\t\tcalcTFCE[i], \n\t\t\t\ttemp_vdensity, \n\t\t\t\tcreate_position_array(np.array(masking_array)[assigntfcesettings==i]),\n\t\t\t\tcreate_full_mask(np.array(masking_array)[assigntfcesettings==i]),\n\t\t\t\tset_surf_count = extract_range,\n\t\t\t\tperm_number=perm_number, \n\t\t\t\trandomise = True,\n\t\t\t\tprint_interation = display_iter)\n\t\telse:\n\t\t\ttemp_tvals, temp_tfce_tvals, temp_neg_tfce_tvals = calculate_tfce(subset_merge_y, \n\t\t\t\tnp.array(masking_array)[assigntfcesettings==i], \n\t\t\t\tpred_x, \n\t\t\t\tcalcTFCE[i], \n\t\t\t\ttemp_vdensity, \n\t\t\t\tcreate_position_array(np.array(masking_array)[assigntfcesettings==i]),\n\t\t\t\tcreate_full_mask(np.array(masking_array)[assigntfcesettings==i]),\n\t\t\t\tset_surf_count = extract_range)\n\n\t\t\tif i == 0: # at first instance\n\t\t\t\ttvals = tfce_tvals = neg_tfce_tvals = np.zeros((temp_tvals.shape[0],merge_y.shape[1]))\n\t\t\ttvals[:,data_mask] = temp_tvals\n\t\t\ttfce_tvals[:,data_mask] = temp_tfce_tvals\n\t\t\tneg_tfce_tvals[:,data_mask] = temp_neg_tfce_tvals\n\t\t\ttemp_tvals = None\n\t\t\ttemp_tfce_tvals = None\n\t\t\ttemp_neg_tfce_tvals = None\n\tif not randomise:\n\t\treturn tvals, tfce_tvals, neg_tfce_tvals\ntfce_mediation/pyfunc.py\ndef vectorized_surface_smooth(v, f, adjacency, number_of_iter = 5, scalar = None, lambda_w = 0.5, mode = 'laplacian', weighted = True):\n\t\"\"\"\n\tApplies Laplacian (Gaussian) or Taubin (low-pass) smoothing with option to smooth single volume\n\t\n\tCitations\n\t----------\n\t\n\tHerrmann, Leonard R. (1976), \"Laplacian-isoparametric grid generation scheme\", Journal of the Engineering Mechanics Division, 102 (5): 749-756.\n\tTaubin, Gabriel. \"A signal processing approach to fair surface design.\" Proceedings of the 22nd annual conference on Computer graphics and interactive techniques. ACM, 1995.\n\t\n\t\n\tParameters\n\t----------\n\tv : array\n\t\tvertex array\n\tf : array\n\t\tface array\n\tadjacency : array\n\t\tadjacency array\n\n\t\n\tFlags\n\t----------\n\tnumber_of_iter : int\n\t\tnumber of smoothing iterations\n\tscalar : array\n\t\tapply the same smoothing to a image scalar\n\tlambda_w : float\n\t\tlamda weighting of degree of movement for each iteration\n\t\tThe weighting should never be above 1.0\n\tmode : string\n\t\tThe type of smoothing can either be laplacian (which cause surface shrinkage) or taubin (no shrinkage)\n\t\t\n\tReturns\n\t-------\n\tv_smooth : array\n\t\tsmoothed vertices array\n\tf : array\n\t\tf = face array (unchanged)\n\t\n\tOptional returns\n\t-------\n\tvalues : array\n\t\tsmoothed scalar array\n\t\n\t\"\"\"\n\tk = 0.1\n\tmu_w = -lambda_w/(1-k*lambda_w)\n\n\tlengths = np.array([len(a) for a in adjacency])\n\tmaxlen = max(lengths)\n\tpadded = [list(a) + [-1] * (maxlen - len(a)) for a in adjacency]\n\tadj = np.array(padded)\n\tw = np.ones(adj.shape, dtype=float)\n\tw[adj<0] = 0.\n\tval = (adj>=0).sum(-1).reshape(-1, 1)\n\tw /= val\n\tw = w.reshape(adj.shape[0], adj.shape[1],1)\n\n\tvorig = np.zeros_like(v)\n\tvorig[:] = v\n\tif scalar is not None:\n\t\tscalar[np.isnan(scalar)] = 0\n\t\tsorig = np.zeros_like(scalar)\n\t\tsorig[:] = scalar\n\n\tfor iter_num in range(number_of_iter):\n\t\tif weighted:\n\t\t\tvadj = v[adj]\n\t\t\tvadj = np.swapaxes(v[adj],1,2)\n\t\t\tweights = np.zeros((v.shape[0], maxlen))\n\t\t\tfor col in range(maxlen):\n\t\t\t\tweights[:,col] = np.power(np.linalg.norm(vadj[:,:,col] - v, axis=1),-1)\n\t\t\tweights[adj==-1] = 0\n\t\t\tvectors = np.einsum('abc,adc->acd', weights[:,None], vadj)\n\n\t\t\tif scalar is not None:\n\t\t\t\tscalar[np.isnan(scalar)] = 0\n\n\t\t\t\tsadj = scalar[adj]\n\t\t\t\tsadj[adj==-1] = 0\n\t\t\t\tif lambda_w < 1:\n\t\t\t\t\tscalar = (scalar*(1-lambda_w)) + lambda_w*(np.sum(np.multiply(weights, sadj),axis=1) / np.sum(weights, axis = 1))\n\t\t\t\telse:\n\t\t\t\t\tscalar = np.sum(np.multiply(weights, sadj),axis=1) / np.sum(weights, axis = 1)\n\t\t\t\tscalar[np.isnan(scalar)] = sorig[np.isnan(scalar)] # hacky scalar nan fix\n\t\t\tif iter_num % 2 == 0:\n\t\t\t\tv += lambda_w*(np.divide(np.sum(vectors, axis = 1), np.sum(weights[:,None], axis = 2)) - v)\n\t\t\telif mode == 'taubin':\n\t\t\t\tv += mu_w*(np.divide(np.sum(vectors, axis = 1), np.sum(weights[:,None], axis = 2)) - v)\n\t\t\telif mode == 'laplacian':\n\t\t\t\tv += lambda_w*(np.divide(np.sum(vectors, axis = 1), np.sum(weights[:,None], axis = 2)) - v)\n\t\t\telse:\n\t\t\t\tprint(\"Error: mode %s not understood\" % mode)\n\t\t\t\tquit()\n\t\t\tv[np.isnan(v)] = vorig[np.isnan(v)] # hacky vertex nan fix\n\t\telse:\n\t\t\tif scalar is not None:\n\t\t\t\tsadj = scalar[adj]\n\t\t\t\tsadj[adj==-1] = 0\n\n\t\t\t\tif lambda_w < 1:\n\t\t\t\t\tscalar = (scalar*(1-lambda_w)) + (lambda_w*np.divide(np.sum(sadj, axis = 1),lengths))\n\t\t\t\telse:\n\t\t\t\t\tscalar = np.divide(np.sum(sadj, axis = 1),lengths)\n\t\t\tif iter_num % 2 == 0:\n\t\t\t\tv += np.array(lambda_w*np.swapaxes(w,0,1)*(np.swapaxes(v[adj], 0, 1)-v)).sum(0)\n\t\t\telif mode == 'taubin':\n\t\t\t\tv += np.array(mu_w*np.swapaxes(w,0,1)*(np.swapaxes(v[adj], 0, 1)-v)).sum(0)\n\t\t\telif mode == 'laplacian':\n\t\t\t\tv += np.array(lambda_w*np.swapaxes(w,0,1)*(np.swapaxes(v[adj], 0, 1)-v)).sum(0)\n\t\t\telse:\n\t\t\t\tprint(\"Error: mode %s not understood\" % mode)\n\t\t\t\tquit()\n\n\tif scalar is not None:\n\t\treturn (v, f, scalar)\n\telse:\n\t\treturn (v, f)\ntfce_mediation/tm_io.py\ndef write_tm_filetype(outname, columnids = [], imgtype = [], checkname = True, output_binary = True, image_array = [], masking_array = [], maskname = [],  affine_array = [], vertex_array = [], face_array = [], surfname = [], adjacency_array = [], tmi_history = [], append_history = True): # NOTE: add ability to store subjectids and imgtypes\n\t# timestamp\n\tcurrentTime=int(strftime(\"%Y%m%d%H%M%S\",gmtime()))\n\t# counters\n\tnum_data = 0\n\tnum_mask = 0\n\tnum_object = 0\n\tnum_affine = 0\n\tnum_adjacency = 0\n\t# history counters\n\th_mask = 0\n\th_affine = 0\n\th_object = 0\n\th_adjacency = 0\n\n\tif not tmi_history == []:\n\t\tfor i in range(len(tmi_history)):\n\t\t\tline = tmi_history[i].split(' ')\n\t\t\tif line[1] == 'mode_add':\n\t\t\t\th_mask += int(line[4])\n\t\t\t\th_affine += int(line[5])\n\t\t\t\th_object += int(line[6])\n\t\t\t\th_adjacency += int(line[7])\n\t\t\telif line[1] == 'mode_sub':\n\t\t\t\th_mask -= int(line[4])\n\t\t\t\th_affine -= int(line[5])\n\t\t\t\th_object -= int(line[6])\n\t\t\t\th_adjacency -= int(line[7])\n\t\t\telif line[1] == 'mode_replace':\n\t\t\t\tpass\n\t\t\telif line[1] == 'mode_reorder':\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tprint((\"Error reading history. Mode %s is not understood. Count is reflect number of element in current file\" % line[1]))\n\n\tif not masking_array == []:\n\t\tmasking_array=np.array(masking_array)\n\t\tif (masking_array.dtype.kind=='O') or (masking_array.ndim==4):\n\t\t\tnum_mask=int(masking_array.shape[0])\n\t\telif masking_array.ndim==3:\n\t\t\tnum_mask = 1\n\t\telse:\n\t\t\tprint(\"Error mask dimension are not understood\")\n\tif not vertex_array==[]:\n\t\tvertex_array=np.array(vertex_array)\n\t\tif vertex_array.ndim==2:\n\t\t\tnum_object = 1\n\t\telif (vertex_array.dtype.kind == 'O') or (vertex_array.ndim==3):\n\t\t\tnum_object=int(vertex_array.shape[0])\n\t\telse:\n\t\t\tprint(\"Error surface object dimension are not understood.\")\n\tif not affine_array==[]:\n\t\taffine_array=np.array(affine_array)\n\t\tif affine_array.ndim==2:\n\t\t\tnum_affine = 1\n\t\telif (affine_array.dtype.kind == 'O') or (affine_array.ndim==3):\n\t\t\tnum_affine=int(affine_array.shape[0])\n\t\telse:\n\t\t\tprint(\"Error affine dimension are not understood.\")\n\tif not adjacency_array==[]:\n\t\tadjacency_array=np.array(adjacency_array)\n\t\tif (adjacency_array.dtype.kind == 'O') or (adjacency_array.ndim==2):\n\t\t\tnum_adjacency=int(adjacency_array.shape[0])\n\t\telif adjacency_array.ndim==1:\n\t\t\tnum_adjacency = 1\n\t\telse:\n\t\t\tprint(\"Error shape of adjacency objects are not understood.\")\n\n\t# write array shape\n\tif not image_array == []:\n\t\tnum_data = 1\n\t\tif image_array.ndim == 1:\n\t\t\tnvert=len(image_array)\n\t\t\tnsub = 1\n\t\telse:\n\t\t\tnvert=image_array.shape[0]\n\t\t\tnsub=image_array.shape[1]\n\tif not outname.endswith('tmi'):\n\t\tif output_binary:\n\t\t\tif not outname.endswith('tmi'):\n\t\t\t\toutname += '.tmi'\n\t\telse:\n\t\t\toutname += '.ascii.tmi'\n\tif checkname:\n\t\toutname=check_outname(outname)\n\twith open(outname, \"w\") as o:\n\t\to.write(\"tmi\\n\")\n\t\tif output_binary:\n\t\t\to.write(\"format binary_%s_endian %s\\n\" % ( sys.byteorder, tm_filetype_version() ) )\n\t\telse:\n\t\t\to.write(\"format ascii %s\\n\" % tm_filetype_version() )\n\t\to.write(\"comment made with TFCE_mediation\\n\")\n\t\tif not image_array==[]:\n\t\t\to.write(\"element data_array\\n\")\n\t\t\to.write(\"dtype float32\\n\")\n\t\t\to.write(\"nbytes %d\\n\" % image_array.astype('float32').nbytes)\n\t\t\to.write(\"datashape %d %d\\n\" % (nvert,nsub))\n\n\t\tif num_mask>0:\n\t\t\tfor i in range(num_mask):\n\t\t\t\to.write(\"element masking_array\\n\")\n\t\t\t\to.write(\"dtype uint8\\n\") # for binarized masks\n\t\t\t\to.write(\"nbytes %d\\n\" % masking_array[i].nbytes)\n\t\t\t\to.write(\"nmasked %d\\n\" % len(masking_array[i][masking_array[i]==True]))\n\t\t\t\to.write(\"maskshape %d %d %d\\n\" % (masking_array[i].shape[0],masking_array[i].shape[1],masking_array[i].shape[2]))\n\t\t\t\tif maskname is not []:\n\t\t\t\t\to.write(\"maskname %s\\n\" % maskname[i])\n\t\t\t\telse:\n\t\t\t\t\to.write(\"maskname unknown\\n\")\n\n\t\tif num_affine>0:\n\t\t\tfor i in range(num_affine):\n\t\t\t\to.write(\"element affine\\n\")\n\t\t\t\to.write(\"dtype float32\\n\")\n\t\t\t\to.write(\"nbytes %d\\n\" % affine_array[i].astype('float32').nbytes)\n\t\t\t\to.write(\"affineshape %d %d\\n\" % (affine_array[i].shape[0], affine_array[i].shape[1]) )\n\n\t\tif num_object>0:\n\t\t\tfor i in range(num_object):\n\t\t\t\tif surfname is not []:\n\t\t\t\t\to.write(\"surfname %s\\n\" % surfname[i])\n\t\t\t\telse:\n\t\t\t\t\to.write(\"surfname unknown\\n\")\n\n\t\t\t\to.write(\"element vertex\\n\")\n\t\t\t\to.write(\"dtype float32\\n\")\n\t\t\t\to.write(\"nbytes %d\\n\" % vertex_array[i].astype('float32').nbytes)\n\t\t\t\to.write(\"vertexshape %d %d\\n\" % (vertex_array[i].shape[0], vertex_array[i].shape[1]) )\n\n\t\t\t\to.write(\"element face\\n\")\n\t\t\t\to.write(\"dtype uint32\\n\")\n\t\t\t\to.write(\"nbytes %d\\n\" % face_array[i].astype('uint32').nbytes)\n\t\t\t\to.write(\"faceshape %d %d\\n\" % (face_array[i].shape[0], face_array[i].shape[1]))\n\n\t\tif num_adjacency>0:\n\t\t\tfor i in range(num_adjacency):\n\t\t\t\to.write(\"element adjacency_object\\n\")\n\t\t\t\to.write(\"dtype python_object\\n\")\n\t\t\t\to.write(\"nbytes %d\\n\" % len(pickle.dumps(adjacency_array[i], -1)) )\n\t\t\t\to.write(\"adjlength %d\\n\" % len(adjacency_array[i]) )\n\n\t\tif not np.array_equal(columnids, []):\n\t\t\t\to.write(\"element column_id\\n\")\n\t\t\t\to.write(\"dtype %s\\n\" % columnids.dtype)\n\t\t\t\to.write(\"nbytes %d\\n\" % columnids.nbytes)\n\t\t\t\to.write(\"listlength %d\\n\" % len(columnids))\n\n\t\t# create a recorded of what was added to the file. 'mode_add' denotes these items were added. tmi_history is expandable.\n\t\tif append_history:\n\t\t\ttmi_history.append(\"history mode_add %d %d %d %d %d %d\" % (currentTime, num_data, num_mask-h_mask, num_affine-h_affine, num_object-h_object, num_adjacency-h_adjacency) )\n\t\tfor i in range(len(tmi_history)):\n\t\t\to.write('%s\\n' % (tmi_history[i]) )\n\t\to.write(\"end_header\\n\")\n\t\to.close()\n\n\t\tif output_binary:\n\t\t\twith open(outname, \"ab\") as o:\n\t\t\t\timage_array = np.array(image_array.T, dtype='float32') # transpose to reduce file size\n\t\t\t\timage_array.tofile(o)\n\t\t\t\tif num_mask>0:\n\t\t\t\t\tfor j in range(num_mask):\n\t\t\t\t\t\tbinarymask = masking_array[j] * 1\n\t\t\t\t\t\tbinarymask = np.array(binarymask.T, dtype=np.uint8)\n\t\t\t\t\t\tbinarymask.tofile(o)\n\t\t\t\tif num_affine>0:\n\t\t\t\t\tfor j in range(num_affine):\n\t\t\t\t\t\toutaffine = np.array(affine_array[j].T, dtype='float32')\n\t\t\t\t\t\toutaffine.tofile(o)\n\t\t\t\tif num_object>0:\n\t\t\t\t\tfor j in range(num_object):\n\t\t\t\t\t\toutv = np.array(vertex_array[j].T, dtype='float32')\n\t\t\t\t\t\toutv.tofile(o)\n\t\t\t\t\t\toutf = np.array(face_array[j].T, dtype='uint32')\n\t\t\t\t\t\toutf.tofile(o)\n\t\t\t\tif not np.array_equal(columnids, []):\n\t\t\t\t\tcolumnids.tofile(o)\n\t\t\t\tif num_adjacency>0:\n\t\t\t\t\tfor j in range(num_adjacency):\n\t\t\t\t\t\tpickle.dump(adjacency_array[j],o, protocol=pickle.HIGHEST_PROTOCOL)\n\t\telse:\n\t\t\twith open(outname, \"a\") as o:\n\t\t\t\tif not image_array == []:\n\t\t\t\t\tnp.savetxt(o,image_array.astype(np.float32))\n\t\t\t\tif num_mask>0:\n\t\t\t\t\tfor j in range(num_mask):\n\t\t\t\t\t\tbinarymask = masking_array[j] * 1\n\t\t\t\t\t\tbinarymask = np.array(binarymask, dtype=np.uint8)\n\t\t\t\t\t\tx, y, z = np.ma.nonzero(binarymask)\n\t\t\t\t\t\tfor i in range(len(x)):\n\t\t\t\t\t\t\to.write(\"%d %d %d\\n\" % (int(x[i]), int(y[i]), int(z[i]) ) )\n\t\t\t\tif num_affine>0:\n\t\t\t\t\tfor j in range(num_affine):\n\t\t\t\t\t\toutaffine = np.array(affine_array[j])\n\t\t\t\t\t\tnp.savetxt(o,outaffine.astype(np.float32))\n\t\t\t\tif columnids is not []:\n\t\t\t\t\tcolumnids.tofile(o, sep='\\n', format=\"%s\")\n\t\t\t\tif num_object>0:\n\t\t\t\t\tfor k in range(num_object):\n\t\t\t\t\t\tfor i in range(len(vertex_array[k])):\n\t\t\t\t\t\t\to.write(\"%1.6f %1.6f %1.6f\\n\" % (vertex_array[k][i,0],\n\t\t\t\t\t\t\t\tvertex_array[k][i,1],\n\t\t\t\t\t\t\t\tvertex_array[k][i,2]))\n\t\t\t\t\t\tfor j in range(len(face_array[k])):\n\t\t\t\t\t\t\to.write(\"%d %d %d\\n\" % (int(face_array[k][j,0]),\n\t\t\t\t\t\t\t\tint(face_array[k][j,1]),\n\t\t\t\t\t\t\t\tint(face_array[k][j,2])))\n\t\to.close()\ntfce_mediation/tm_io.py\ndef read_tm_filetype(tm_file, verbose=True):\n\t# getfilesize\n\tfilesize = os.stat(tm_file).st_size\n\t# declare variables\n\telement = []\n\telement_dtype = []\n\telement_nbyte = []\n\telement_nmasked = []\n\tmasking_array = []\n\tdatashape = []\n\tmaskshape = []\n\tmaskname = []\n\tvertexshape = []\n\tfaceshape = []\n\tsurfname = []\n\taffineshape = []\n\tadjlength = []\n\tarray_read = []\n\tobject_read = []\n\to_imgarray = []\n\to_masking_array = []\n\to_vertex = []\n\to_face = []\n\to_affine = []\n\to_adjacency = []\n\to_columnids = []\n\tmaskcounter = 0\n\tvertexcounter = 0\n\tfacecounter = 0\n\taffinecounter = 0\n\tadjacencycounter = 0\n\ttmi_history = []\n\n\t# read first line\n\tobj = open(tm_file, 'rb')\n\treader = obj.readline().decode(\"UTF-8\").strip().split()\n\tfirstword=reader[0]\n\tif firstword != 'tmi':\n\t\tprint(\"Error: not a TFCE_mediation image.\")\n\t\texit()\n\treader = obj.readline().decode(\"UTF-8\").strip().split()\n\tfirstword=reader[0]\n\tif firstword != 'format':\n\t\tprint(\"Error: unknown reading file format\")\n\t\texit()\n\telse:\n\t\ttm_filetype = reader[1]\n\n\n\twhile firstword != 'end_header':\n\t\treader = obj.readline().decode(\"UTF-8\").strip().split()\n\t\tfirstword=reader[0]\n\t\tif firstword == 'element':\n\t\t\telement.append((reader[1]))\n\t\tif firstword == 'dtype':\n\t\t\telement_dtype.append((reader[1]))\n\t\tif firstword == 'nbytes':\n\t\t\telement_nbyte.append((reader[1]))\n\t\tif firstword == 'datashape':\n\t\t\tdatashape.append(np.array((reader[1], reader[2])).astype(np.int))\n\t\tif firstword == 'nmasked':\n\t\t\telement_nmasked.append(( int(reader[1]) ))\n\t\tif firstword == 'maskshape':\n\t\t\tmaskshape.append(np.array((reader[1], reader[2], reader[3])).astype(np.int))\n\t\tif firstword == 'maskname':\n\t\t\tmaskname.append((reader[1]))\n\t\tif firstword == 'affineshape':\n\t\t\taffineshape.append(np.array((reader[1], reader[2])).astype(np.int))\n\t\tif firstword == 'vertexshape':\n\t\t\tvertexshape.append(np.array((reader[1], reader[2])).astype(np.int))\n\t\tif firstword == 'surfname':\n\t\t\tsurfname.append((reader[1]))\n\t\tif firstword == 'faceshape':\n\t\t\tfaceshape.append(np.array((reader[1], reader[2])).astype(np.int))\n\t\tif firstword == 'adjlength':\n\t\t\tadjlength.append(np.array(reader[1]).astype(np.int))\n\t\tif firstword == 'history':\n\t\t\ttmi_history.append(str(' '.join(reader)))\n\t\tif firstword == 'listlength':\n\t\t\tlistlength=int(reader[1])\n\t# skip header\n\tposition = filesize\n\tfor i in range(len(element_nbyte)):\n\t\tposition-=int(element_nbyte[i])\n\t# readdata\n\tif tm_filetype == 'binary_little_endian':\n\t\tfor e in range(len(element)):\n\t\t\tobj.seek(position)\n\t\t\tif verbose:\n\t\t\t\tprint(position)\n\t\t\t\tprint(\"reading %s\" % str(element[e]))\n\t\t\tif not str(element[e]) == 'adjacency_object':\n\t\t\t\tarray_read = np.fromfile(obj, dtype=element_dtype[e])\n\t\t\telse:\n\t\t\t\tobject_read.append(pickle.load(obj))\n\t\t\tposition += int(element_nbyte[e])\n\t\t\t# reshape arrays\n\t\t\tif str(element[e]) == 'data_array':\n\t\t\t\to_imgarray.append(np.array(array_read[:datashape[0][0]*datashape[0][1]]).reshape(datashape[0][1],datashape[0][0]).T)\n\t\t\tif str(element[e]) == 'masking_array':\n\t\t\t\tmasktemp = np.array(array_read[:(maskshape[maskcounter][2]*maskshape[maskcounter][1]*maskshape[maskcounter][0])]).reshape(maskshape[maskcounter][2],maskshape[maskcounter][1],maskshape[maskcounter][0]).T\n\t\t\t\to_masking_array.append((np.array(masktemp, dtype=bool) ))\n\t\t\t\tmaskcounter += 1\n\t\t\tif str(element[e]) == 'affine':\n\t\t\t\to_affine.append(np.array(array_read[:affineshape[affinecounter][1]*affineshape[affinecounter][0]]).reshape(affineshape[affinecounter][1],affineshape[affinecounter][0]).T)\n\t\t\t\taffinecounter += 1\n\t\t\tif str(element[e]) == 'vertex':\n\t\t\t\to_vertex.append(np.array(array_read[:vertexshape[vertexcounter][1]*vertexshape[vertexcounter][0]]).reshape(vertexshape[vertexcounter][1],vertexshape[vertexcounter][0]).T)\n\t\t\t\tvertexcounter += 1\n\t\t\tif str(element[e]) == 'face':\n\t\t\t\to_face.append(np.array(array_read[:faceshape[facecounter][1]*faceshape[facecounter][0]]).reshape(faceshape[facecounter][1],faceshape[facecounter][0]).T)\n\t\t\t\tfacecounter += 1\n\t\t\tif str(element[e]) == 'column_id':\n\t\t\t\to_columnids.append(np.array(array_read[:listlength]))\n\t\t\tif str(element[e]) == 'adjacency_object':\n\t\t\t\to_adjacency.append(np.array(object_read[adjacencycounter][:adjlength[adjacencycounter]]))\n\t\t\t\tadjacencycounter += 1\n\t\t\tarray_read = []\n\telif tm_filetype == 'ascii':\n\t\tfor e in range(len(element)):\n\t\t\tif str(element[e]) == 'data_array':\n\t\t\t\timg_data = np.zeros((datashape[0][0], datashape[0][1]))\n\t\t\t\tfor i in range(int(datashape[0][0])):\n\t\t\t\t\timg_data[i] = np.array(obj.readline().strip().split(), dtype = 'float32')\n\t\t\t\to_imgarray.append((np.array(img_data, dtype = 'float32')))\n\t\t\tif str(element[e]) == 'masking_array':\n\t\t\t\t\tfor k in range(element_nmasked[maskcounter]):\n\t\t\t\t\t\tmasking_array.append((np.array(obj.readline().strip().split()).astype(np.int32)))\n\t\t\t\t\tmasking_array = np.array(masking_array)\n\t\t\t\t\toutmask = np.zeros((maskshape[maskcounter]), dtype=np.int)\n\t\t\t\t\toutmask[masking_array[:,0],masking_array[:,1],masking_array[:,2]] = 1\n\t\t\t\t\to_masking_array.append((np.array(outmask, dtype=bool)))\n\t\t\t\t\tmaskcounter += 1\n\t\t\t\t\tmasking_array=[]\n\t\t\tif str(element[e]) == 'affine':\n\t\t\t\ttemparray = []\n\t\t\t\tfor k in range(int(affineshape[affinecounter][0])):\n\t\t\t\t\ttemparray.append((np.array(obj.readline().strip().split()).astype('float32')))\n\t\t\t\to_affine.append((np.array(temparray, dtype='float32')))\n\t\t\t\taffinecounter += 1\n\t\t\tif str(element[e]) == 'vertex':\n\t\t\t\ttemparray = []\n\t\t\t\tfor k in range(int(vertexshape[vertexcounter][0])):\n\t\t\t\t\ttemparray.append((np.array(obj.readline().strip().split()).astype('float32')))\n\t\t\t\to_vertex.append((np.array(temparray, dtype='float32')))\n\t\t\t\tvertexcounter += 1\n\t\t\tif str(element[e]) == 'face':\n\t\t\t\ttemparray = []\n\t\t\t\tfor k in range(int(faceshape[facecounter][0])):\n\t\t\t\t\ttemparray.append((np.array(obj.readline().strip().split()).astype('int32')))\n\t\t\t\to_face.append(( np.array(temparray, dtype='int32') ))\n\t\t\t\tfacecounter += 1\n\t\t\tif str(element[e]) == 'column_id':\n\t\t\t\ttemparray = []\n\t\t\t\tfor k in range(listlength):\n\t\t\t\t\ttemparray.append(obj.readline().strip() )\n\t\t\t\to_columnids.append(( np.array(temparray, dtype=element_dtype[e]) ))\n\n\telse:\n\t\tprint(\"Error unknown filetype: %s\" % tm_filetype)\n\treturn(element, o_imgarray, o_masking_array, maskname, o_affine, o_vertex, o_face, surfname, o_adjacency, tmi_history, o_columnids)\ntfce_mediation/tm_io.py\ndef savemgh_v2(image_array, index, imagename, affine=None):\n\tif not imagename.endswith('mgh'):\n\t\timagename += '.mgh'\n\toutdata = image_array.astype(np.float32, order = \"C\")\n\tif image_array.ndim == 1:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2]))\n\t\timgout[index]=outdata\n\telif image_array.shape[1] > 1:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2],image_array.shape[1]))\n\t\timgout[index]=outdata\n\telse:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2]))\n\t\timgout[index]=outdata[:,0]\n\tnib.save(nib.freesurfer.mghformat.MGHImage(imgout.astype(np.float32, order = \"C\"),affine=affine),imagename)\ntfce_mediation/pyfunc.py\ndef convert_voxel(img_data, affine = None, threshold = None, data_mask = None, absthreshold = None):\n\t\"\"\"\n\tConverts a voxel image to a surface including outputs voxel values to paint vertex surface.\n\t\n\tParameters\n\t----------\n\timg_data : array\n\t\timage array\n\taffine : array\n\t\t affine [4x4] to convert vertices values to native space (Default = None)\n\tdata_mask : array\n\t\tuse a mask to create a surface backbone (Default = None)\n\tthreshold : float\n\t\tthreshold for output of voxels (Default = None)\n\tabsthreshold : float\n\t\tthreshold for output of abs(voxels) (Default = None)\n\t\t\n\tReturns\n\t-------\n\t\tv : array\n\t\t\tvertices\n\t\tf : array\n\t\t\tfaces\n\t\tvalues : array\n\t\t\tscalar values\n\t\n\t\"\"\"\n\ttry:\n\t\tfrom skimage import measure\n\texcept:\n\t\tprint(\"Error skimage is required\")\n\t\tquit()\n\n\tif threshold is not None:\n\t\tprint(\"Zeroing data less than threshold = %1.2f\" % threshold)\n\t\timg_data[img_data<threshold] = 0\n\tif absthreshold is not None:\n\t\tprint(\"Zeroing absolute values less than threshold = %1.2f\" % absthreshold)\n\t\timg_data[np.abs(img_data)<absthreshold] = 0\n\tif data_mask is not None:\n\t\tprint(\"Including mask\")\n\t\tdata_mask *= .1\n\t\tdata_mask[img_data!=0] = img_data[img_data!=0]\n\t\tdel img_data\n\t\timg_data = np.copy(data_mask)\n\ttry:\n\t\tv, f, _, values = measure.marching_cubes_lewiner(img_data)\n\t\tif affine is not None:\n\t\t\tprint(\"Applying affine transformation\")\n\t\t\tv = nib.affines.apply_affine(affine,v)\n\texcept:\n\t\tprint(\"No voxels above threshold\")\n\t\tv = f = values = []\n\treturn v, f, values\ntfce_mediation/tm_func.py\ndef saveauto(image_array, index, imagename, affine=None):\n\tif index.shape[2] > 1:\n\t\tsavenifti_v2(image_array, index, imagename, affine)\n\telse:\n\t\tsavemgh_v2(image_array, index, imagename, affine)\ntfce_mediation/tm_func.py\ndef lowest_length(num_contrasts, surface_range, tmifilename, medtype = None):\n\tlengths = []\n\tfor contrast in range(num_contrasts):\n\t\tfor surface in surface_range: # the standardization is done within each surface\n\t\t\tif medtype is not None:\n\t\t\t\tlengths.append(np.array(np.genfromtxt('output_%s/perm_maxTFCE_surf%d_%s_zstat.csv' % (tmifilename,surface,medtype)).shape[0]))\n\t\t\telse:\n\t\t\t\tlengths.append(np.array(np.genfromtxt('output_%s/perm_maxTFCE_surf%d_tcon%d.csv' % (tmifilename,surface,contrast+1)).shape[0]))\n\treturn np.array(lengths).min()\ntfce_mediation/tm_func.py\ndef strip_basename(basename):\n\tif basename.endswith('.mgh'):\n\t\tbasename = basename[:-4]\n\telif basename.endswith('.nii.gz'):\n\t\tbasename = basename[:-7]\n\telse:\n\t\tpass\n\tif basename.startswith('lh.all'):\n\t\tbasename = 'lh.%s' % basename[7:]\n\tif basename.startswith('rh.all'):\n\t\tbasename = 'rh.%s' % basename[7:]\n\treturn basename\ntfce_mediation/tm_func.py\ndef merge_adjacency_array(adjacent_range, adjacency_array):\n\tv_count = 0\n\tif len(adjacent_range) == 1:\n\t\tadjacency = np.copy(adjacency_array[0])\n\t\tfor i in range(len(adjacency)):\n\t\t\tadjacency[i] = np.array(list(adjacency[i])).tolist() # list fixes 'set' 'int' error\n\telse:\n\t\tfor e in adjacent_range:\n\t\t\tif v_count == 0:\n\t\t\t\tadjacency = np.copy(adjacency_array[0])\n\t\t\t\tfor i in range(len(adjacency)):\n\t\t\t\t\tadjacency[i] = np.array(list(adjacency[i])).tolist() # list fixes 'set' 'int' error\n\t\t\t\tv_count += len(adjacency_array[e])\n\t\t\telse:\n\t\t\t\ttemp_adjacency = np.copy(adjacency_array[e])\n\t\t\t\tfor i in range(len(adjacency_array[e])):\n\t\t\t\t\ttemp_adjacency[i] = np.add(list(temp_adjacency[i]), v_count).tolist() # list fixes 'set' 'int' error\n\t\t\t\tadjacency = np.hstack((adjacency, temp_adjacency))\n\t\t\t\tv_count += len(adjacency_array[e])\n\treturn adjacency\n", "answers": ["\t\t\t\t\t\tsavefunc = savemgh_v2"], "length": 4046, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "ca29a391edd0d83b0e2ca7866b46d8472fc032c11c2e0b59"}
{"input": "import android.accounts.AccountManager;\nimport android.content.Context;\nimport com.google.gson.Gson;\nimport org.ohmage.app.InstallSurveyDependencies;\nimport org.ohmage.app.InstallSurveyDependencies.InstallSurveyDependenciesFragment;\nimport org.ohmage.app.MainActivity;\nimport org.ohmage.app.MainActivityOhmletsTest;\nimport org.ohmage.app.MainActivityTest;\nimport org.ohmage.app.OhmageAuthenticator;\nimport org.ohmage.app.OhmageService;\nimport org.ohmage.app.OhmletActivity;\nimport org.ohmage.app.SurveyActivity;\nimport org.ohmage.app.SurveyActivity.SurveyPromptLoader;\nimport org.ohmage.auth.AuthHelper;\nimport org.ohmage.auth.AuthenticateFragment;\nimport org.ohmage.auth.Authenticator;\nimport org.ohmage.auth.AuthenticatorTest;\nimport org.ohmage.auth.CreateAccountFragment;\nimport org.ohmage.auth.SignInFragment;\nimport org.ohmage.auth.oauth.OAuthActivity;\nimport org.ohmage.auth.oauth.OAuthActivity.OAuthFragment;\nimport org.ohmage.dagger.ForApplication;\nimport org.ohmage.fragments.HomeFragment;\nimport org.ohmage.fragments.InstallDependenciesDialog;\nimport org.ohmage.fragments.OhmletsFragment;\nimport org.ohmage.fragments.OhmletsGridFragment;\nimport org.ohmage.fragments.OhmletsSearchFragment;\nimport org.ohmage.fragments.StreamsFragment;\nimport org.ohmage.fragments.SurveysFragment;\nimport org.ohmage.operators.ContentProviderSaver;\nimport org.ohmage.prompts.PromptFragment;\nimport org.ohmage.provider.ContentProviderReader;\nimport org.ohmage.provider.StreamContentProvider;\nimport org.ohmage.sync.OhmageSyncAdapter;\nimport org.ohmage.sync.ResponseSyncAdapter;\nimport org.ohmage.sync.StreamSyncAdapter;\nimport org.ohmage.sync.StreamSyncAdapterTest;\nimport org.ohmage.tasks.LogoutTaskFragment;\nimport javax.inject.Singleton;\nimport dagger.Module;\nimport dagger.Provides;\nimport static org.mockito.Mockito.mock;\n/*\n * Copyright (C) 2013 ohmage\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.ohmage.test.dagger;\n\n\n\n\n\n\n\n@Module(\n        injects = {\n                InjectedAndroidTestCase.class,\n                MainActivityTest.class,\n                AuthenticatorTest.class,\n                StreamSyncAdapterTest.class,\n                MainActivityOhmletsTest.class,\n\n                MainActivity.class,\n                AuthenticateFragment.class,\n                Authenticator.class,\n                CreateAccountFragment.class,\n                SignInFragment.class,\n                LogoutTaskFragment.class,\n                StreamContentProvider.class,\n                StreamSyncAdapter.class,\n                OhmageAuthenticator.class,\n                OhmletsSearchFragment.class,\n                OhmletsGridFragment.OhmletAdapter.class,\n                OhmletsFragment.class,\n                OhmageSyncAdapter.class,", "context": "ohmage/src/main/java/org/ohmage/app/SurveyActivity.java\npublic static class SurveyPromptLoader extends AsyncTaskLoader<ArrayList<Prompt>> {\n    @Inject Gson gson;\n\n    Uri mUri;\n    String[] mProjection;\n    String mSelection;\n    String[] mSelectionArgs;\n\n    Cursor mCursor;\n\n    private ArrayList<Prompt> mPrompts;\n\n    /* Runs on a worker thread */\n    @Override\n    public ArrayList<Prompt> loadInBackground() {\n        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,\n                mSelectionArgs, null);\n        if (cursor != null && cursor.moveToFirst()) {\n            mPrompts = gson.fromJson(cursor.getString(0), new TypeToken<ArrayList<Prompt>>() {\n            }.getType());\n            cursor.close();\n        }\n        return mPrompts;\n    }\n\n    /* Runs on the UI thread */\n    @Override\n    public void deliverResult(ArrayList<Prompt> result) {\n        if (isReset()) {\n            // An async query came in while the loader is stopped\n            mPrompts = null;\n            return;\n        }\n        mPrompts = result;\n        if (isStarted()) {\n            super.deliverResult(result);\n        }\n    }\n\n    /**\n     * Creates a Loader for prompt items\n     */\n    public SurveyPromptLoader(Context context, String surveyId, long surveyVersion) {\n        super(context);\n        ((SurveyActivity) context).inject(this);\n\n        mUri = OhmageContract.Surveys.CONTENT_URI;\n        mProjection = new String[]{\n                OhmageContract.Surveys.SURVEY_ITEMS\n        };\n        mSelection = OhmageContract.Surveys.SURVEY_ID + \"=? AND \" +\n                     OhmageContract.Surveys.SURVEY_VERSION + \"=?\";\n        mSelectionArgs = new String[]{\n                surveyId, String.valueOf(surveyVersion)\n        };\n    }\n\n    public SurveyPromptLoader(Context context, Uri surveyUri) {\n        super(context);\n        ((SurveyActivity) context).inject(this);\n\n        mUri = surveyUri;\n        mProjection = new String[]{\n                OhmageContract.Surveys.SURVEY_ITEMS\n        };\n    }\n\n    /**\n     * Starts an asynchronous load of the contacts list data. When the result is ready the callbacks\n     * will be called on the UI thread. If a previous load has been completed and is still valid\n     * the result may be passed to the callbacks immediately.\n     * <p/>\n     * Must be called from the UI thread\n     */\n    @Override\n    protected void onStartLoading() {\n        if (mPrompts != null) {\n            deliverResult(mPrompts);\n        }\n        if (takeContentChanged() || mCursor == null) {\n            forceLoad();\n        }\n    }\n\n    /**\n     * Must be called from the UI thread\n     */\n    @Override\n    protected void onStopLoading() {\n        // Attempt to cancel the current load task if possible.\n        cancelLoad();\n    }\n\n    @Override\n    protected void onReset() {\n        super.onReset();\n\n        // Ensure the loader is stopped\n        onStopLoading();\n\n        mPrompts = null;\n    }\n\n    @Override\n    public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {\n        super.dump(prefix, fd, writer, args);\n        writer.print(prefix);\n        writer.print(\"mPrompts=\");\n        writer.println(mPrompts);\n    }\n}\nohmage/src/main/java/org/ohmage/provider/StreamContentProvider.java\npublic class StreamContentProvider extends ContentProvider implements OnAccountsUpdateListener {\n\n    @Inject AccountManager am;\n\n    private AsyncBulkInsertHandler mAsyncQueryHandler;\n\n    private String mAccount;\n\n    // enum of the URIs we can match using sUriMatcher\n    private interface MatcherTypes {\n        int STREAMS = 0;\n\n        int STREAMS_ID = 1;\n\n        int COUNTS = 2;\n    }\n\n    private OhmageDbHelper dbHelper;\n\n    private static UriMatcher sUriMatcher;\n\n    {\n        sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n        sUriMatcher.addURI(StreamContract.CONTENT_AUTHORITY, \"streams\", MatcherTypes.STREAMS);\n        sUriMatcher\n                .addURI(StreamContract.CONTENT_AUTHORITY, \"streams/*/*\", MatcherTypes.STREAMS_ID);\n        sUriMatcher.addURI(StreamContract.CONTENT_AUTHORITY, \"counts\", MatcherTypes.COUNTS);\n    }\n\n    @Override\n    public int delete(Uri uri, String selection, String[] selectionArgs) {\n        int count = 0;\n\n        switch (sUriMatcher.match(uri)) {\n\n            case MatcherTypes.STREAMS:\n                count = dbHelper.getWritableDatabase().delete(Tables.StreamData, selection,\n                        selectionArgs);\n                break;\n            case MatcherTypes.COUNTS:\n\n            default:\n                throw new UnsupportedOperationException(\"insert(): Unknown URI: \" + uri);\n        }\n\n        notifyInsert(uri, count);\n        return count;\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        switch (sUriMatcher.match(uri)) {\n\n            case MatcherTypes.STREAMS:\n                return StreamContract.Streams.CONTENT_TYPE;\n            case MatcherTypes.COUNTS:\n                return StreamContract.StreamCounts.CONTENT_TYPE;\n            default:\n                throw new UnsupportedOperationException(\"getType(): Unknown URI: \" + uri);\n        }\n    }\n\n    public static int counter = 0;\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        long id = -1;\n\n        ContentResolver cr = getContext().getContentResolver();\n\n        switch (sUriMatcher.match(uri)) {\n            case MatcherTypes.STREAMS:\n\n                if (mAccount == null) {\n                    return null;\n                }\n\n                // Set the correct username\n                values.put(StreamContract.Streams.USERNAME, mAccount);\n\n                SQLiteDatabase db = dbHelper.getWritableDatabase();\n                db.insert(Tables.StreamData, BaseColumns._ID, values);\n\n                break;\n            default:\n                throw new UnsupportedOperationException(\"insert(): Unknown URI: \" + uri);\n        }\n        if (id != -1)\n            return ContentUris.withAppendedId(StreamContract.Streams.CONTENT_URI, id);\n        return null;\n    }\n\n    @Override\n    public boolean onCreate() {\n        dbHelper = new OhmageDbHelper(getContext());\n\n        ((Ohmage) getContext().getApplicationContext()).getApplicationGraph().inject(this);\n\n        am.addOnAccountsUpdatedListener(this, null, true);\n\n        mAsyncQueryHandler = new AsyncBulkInsertHandler(getContext().getContentResolver(),\n                StreamContract.Streams.CONTENT_URI);\n        return true;\n    }\n\n    @Override\n    public void onAccountsUpdated(Account[] accounts) {\n        for (Account account : accounts) {\n            if (AuthUtil.ACCOUNT_TYPE.equals(account.type)) {\n                mAccount = account.name;\n                return;\n            }\n        }\n        mAccount = null;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,\n            String sortOrder) {\n        Cursor cursor;\n        switch (sUriMatcher.match(uri)) {\n            case MatcherTypes.COUNTS:\n                SQLiteQueryBuilder streams = new SQLiteQueryBuilder();\n                streams.setTables(Tables.StreamData);\n                cursor = streams.query(dbHelper.getReadableDatabase(), projection, selection,\n                        selectionArgs, StreamContract.Streams.STREAM_ID + \", \"\n                                       + StreamContract.Streams.STREAM_VERSION, null, sortOrder);\n                break;\n            case MatcherTypes.STREAMS:\n                cursor = dbHelper.getReadableDatabase()\n                        .query(Tables.StreamData, projection, selection,\n                                selectionArgs, null, null, sortOrder);\n                break;\n            default:\n                throw new UnsupportedOperationException(\"query(): Unknown URI: \" + uri);\n        }\n\n        cursor.setNotificationUri(getContext().getContentResolver(), uri);\n        return cursor;\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {\n        throw new UnsupportedOperationException(\"Update not allowed\");\n    }\n\n    @Override\n    public synchronized int bulkInsert(Uri uri, ContentValues[] values) {\n        int count = 0;\n\n        // We can't insert any points if no account exists.\n        String account = mAccount;\n        if (TextUtils.isEmpty(account)) {\n            return 0;\n        }\n\n        SQLiteDatabase db = dbHelper.getWritableDatabase();\n\n        try {\n            db.beginTransaction();\n\n            String table;\n            switch (sUriMatcher.match(uri)) {\n                case MatcherTypes.STREAMS:\n                    table = Tables.StreamData;\n                    break;\n                default:\n                    throw new UnsupportedOperationException(\"bulkInsert(): Unknown URI: \" + uri);\n            }\n\n            for (ContentValues v : values) {\n                v.put(StreamContract.Streams.USERNAME, mAccount);\n                if (db.insert(table, BaseColumns._ID, v) != -1)\n                    count++;\n            }\n\n            db.setTransactionSuccessful();\n        } finally {\n            db.endTransaction();\n        }\n\n        notifyInsert(uri, count);\n\n        return count;\n    }\n\n    private void notifyInsert(Uri uri, Integer count) {\n        if (count > 0) {\n            ContentResolver cr = getContext().getContentResolver();\n\n            switch (sUriMatcher.match(uri)) {\n                case MatcherTypes.STREAMS:\n                    cr.notifyChange(StreamContract.Streams.CONTENT_URI, null, false);\n                    break;\n            }\n        }\n    }\n}\nohmage/src/main/java/org/ohmage/auth/AuthenticateFragment.java\npublic class AuthenticateFragment extends TransitionFragment implements View.OnClickListener {\n\n    /**\n     * Keeps track of the state of if the progress spinner is shown\n     */\n    private boolean mShowProgress;\n\n    /**\n     * The view which shows the progress spinner\n     */\n    private View mAuthLoadingView;\n\n    /**\n     * The view which shows the authentication buttons\n     */\n    private View mAuthButtonsView;\n\n    private Callbacks mCallbacks;\n\n    public AuthenticateFragment() {\n        setDefaultAnimation(R.anim.abc_fade_in, R.anim.abc_fade_out);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.fragment_authenticate, container, false);\n\n        SignInButton signInButton = (SignInButton) view.findViewById(R.id.sign_in_google_button);\n        signInButton.setOnClickListener(this);\n        signInButton.setSize(SignInButton.SIZE_WIDE);\n\n        Button createAccount = (Button) view.findViewById(R.id.create_account_button);\n        createAccount.setOnClickListener(this);\n        Button signInEmail = (Button) view.findViewById(R.id.sign_in_email_button);\n        signInEmail.setOnClickListener(this);\n\n        mAuthLoadingView = view.findViewById(R.id.authenticate_loading);\n        mAuthButtonsView = view.findViewById(R.id.authenticate_buttons);\n\n        // Set the visibility of the views\n        mAuthLoadingView.setVisibility(mShowProgress ? View.VISIBLE : View.INVISIBLE);\n        mAuthButtonsView.setVisibility(mShowProgress ? View.INVISIBLE : View.VISIBLE);\n\n        return view;\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putBoolean(\"showProgress\", mShowProgress);\n    }\n\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        mCallbacks = (Callbacks) activity;\n    }\n\n    @Override public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setRetainInstance(true);\n    }\n\n    @Override\n    public void onDetach() {\n        super.onDetach();\n        mCallbacks = null;\n    }\n\n    /**\n     * Shows the progress UI and hides the authentication buttons.\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)\n    public void showProgress(boolean show) {\n        mShowProgress = show;\n\n        // On Honeycomb MR2 we have the ViewPropertyAnimator APIs, which allow\n        // for very easy animations. If available, use these APIs to fade-in\n        // the progress spinner.\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {\n            int shortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);\n\n            mAuthLoadingView.setVisibility(View.VISIBLE);\n            mAuthLoadingView.animate()\n                    .setDuration(shortAnimTime)\n                    .alpha(show ? 1 : 0)\n                    .setListener(new AnimatorListenerAdapter() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            mAuthLoadingView.setVisibility(\n                                    mShowProgress ? View.VISIBLE : View.INVISIBLE);\n                        }\n                    });\n\n            mAuthButtonsView.setVisibility(View.VISIBLE);\n            mAuthButtonsView.animate()\n                    .setDuration(shortAnimTime)\n                    .alpha(show ? 0 : 1)\n                    .setListener(new AnimatorListenerAdapter() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            mAuthButtonsView.setVisibility(\n                                    mShowProgress ? View.INVISIBLE : View.VISIBLE);\n                        }\n                    });\n        } else {\n            // The ViewPropertyAnimator APIs are not available, so simply showProgress\n            // and hide the relevant UI components.\n            mAuthLoadingView.setVisibility(show ? View.VISIBLE : View.INVISIBLE);\n            mAuthButtonsView.setVisibility(show ? View.INVISIBLE : View.VISIBLE);\n        }\n    }\n\n    @Override\n    public void onClick(View view) {\n        switch (view.getId()) {\n            case R.id.sign_in_google_button:\n                mCallbacks.onGoogleSignInClick();\n                break;\n            case R.id.create_account_button:\n                mCallbacks.onCreateAccountClick();\n                break;\n            case R.id.sign_in_email_button:\n                mCallbacks.onEmailSignInClick();\n                break;\n        }\n    }\n\n    public static interface Callbacks {\n        void onGoogleSignInClick();\n\n        void onCreateAccountClick();\n\n        void onEmailSignInClick();\n    }\n}\nohmage/src/main/java/org/ohmage/app/SurveyActivity.java\npublic class SurveyActivity extends InjectedActionBarActivity\n        implements LoaderCallbacks<ArrayList<Prompt>>, ConnectionCallbacks,\n        OnConnectionFailedListener {\n    private static final String TAG = SurveyActivity.class.getSimpleName();\n\n    @Inject Gson gson;\n\n    /**\n     * The pager widget, which handles animation and allows swiping horizontally to access previous\n     * and next wizard steps.\n     */\n    private VerticalViewPager mPager;\n\n    /**\n     * The pager adapter, which provides the pages to the view pager widget.\n     */\n    private PromptFragmentAdapter mPagerAdapter;\n\n    private CirclePageIndicator indicator;\n\n    /**\n     * Location client to get accurate location\n     */\n    private LocationClient mLocationClient;\n\n    private static final LocationRequest REQUEST = LocationRequest.create()\n            .setInterval(5000)         // 5 seconds\n            .setFastestInterval(16)    // 16ms = 60fps\n            .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\n\n    private SurveyStateFragment mState;\n\n    public static final int MSG_SHOW_INSTALL_DEPENDENCIES = 0;\n\n    private Handler handler = new Handler() {\n\n        @Override\n        public void handleMessage(Message msg) {\n            if(msg.what == MSG_SHOW_INSTALL_DEPENDENCIES) {\n                FragmentManager fm = getSupportFragmentManager();\n                InstallDependenciesDialog fragment =\n                        (InstallDependenciesDialog) fm.findFragmentByTag(\"install\");\n                if (fragment == null) {\n                    fragment = InstallDependenciesDialog.getInstance((ApkSet) msg.obj, true);\n                }\n                fragment.show(fm, \"install\");\n            }\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_survey);\n\n        // Instantiate a ViewPager and a PagerAdapter.\n        mPager = (VerticalViewPager) findViewById(R.id.pager);\n        mPager.setPageMargin(getResources().getDimensionPixelSize(R.dimen.gutter));\n\n        //Bind the title indicator to the adapter\n        indicator = (CirclePageIndicator) findViewById(R.id.titles);\n\n        if (savedInstanceState == null) {\n            mState = new SurveyStateFragment();\n            getSupportFragmentManager().beginTransaction().add(mState, \"state\").commit();\n        } else {\n            mState = (SurveyStateFragment) getSupportFragmentManager().findFragmentByTag(\"state\");\n        }\n\n        if (mState.prompts != null) {\n            setPromptFragmentAdapter();\n        } else {\n            getSupportLoaderManager().initLoader(0, null, this);\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        setUpLocationClientIfNeeded();\n        mLocationClient.connect();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        if (mLocationClient != null) {\n            mLocationClient.disconnect();\n        }\n    }\n\n    private void setUpLocationClientIfNeeded() {\n        if (mLocationClient == null) {\n            mLocationClient = new LocationClient(\n                    getApplicationContext(),\n                    this,  // ConnectionCallbacks\n                    this); // OnConnectionFailedListener\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        // If nothing has been answered just go back\n        if (mPagerAdapter == null || mPagerAdapter.getAnsweredCount() == 0) {\n            discardSurvey();\n            return;\n        }\n\n        // Otherwise show a dialog so they don't lose their responses\n        FragmentManager fm = getSupportFragmentManager();\n        CancelResponseDialogFragment fragment =\n                (CancelResponseDialogFragment) fm.findFragmentByTag(\"cancel\");\n        if (fragment == null) {\n            fragment = new CancelResponseDialogFragment();\n        }\n        fragment.show(fm, \"cancel\");\n    }\n\n    private void discardSurvey() {\n        if(mPagerAdapter != null)\n            mPagerAdapter.clearExtras();\n        super.onBackPressed();\n    }\n\n    @Override public SurveyPromptLoader onCreateLoader(int id, Bundle args) {\n        return new SurveyPromptLoader(this, getIntent().getData());\n    }\n\n    @Override public void onLoadFinished(Loader<ArrayList<Prompt>> loader, ArrayList<Prompt> data) {\n        if(data == null) {\n            Toast.makeText(this, R.string.survey_not_found, Toast.LENGTH_SHORT).show();\n            finish();\n            return;\n        }\n\n        if (mPagerAdapter == null) {\n            setPrompts(data);\n\n            // Check for remote activity prompts and make sure they all exist\n            if(data != null) {\n                ApkSet appItems = ApkSet.fromPromptsIgnoreSkippable(data);\n                appItems.clearInstalled(this);\n\n                if (!appItems.isEmpty()) {\n                    Message msg = handler.obtainMessage(MSG_SHOW_INSTALL_DEPENDENCIES);\n                    msg.obj = appItems;\n                    msg.sendToTarget();\n                }\n            }\n        }\n    }\n\n    @Override public void onLoaderReset(Loader<ArrayList<Prompt>> loader) {\n\n    }\n\n    public void setPromptFragmentAdapter() {\n        mPagerAdapter = new PromptFragmentAdapter(getSupportFragmentManager(), mState.prompts);\n        mPager.setAdapter(mPagerAdapter);\n        indicator.setViewPager(mPager);\n    }\n\n    public void setPrompts(ArrayList<Prompt> data) {\n        mState.prompts = new Prompts(data);\n        setPromptFragmentAdapter();\n    }\n\n    public void submit() {\n        // Tell reminders that the survey was taken\n        TriggerFramework.notifySurveyTaken(this, Surveys.getId(getIntent().getData()));\n\n        ContentValues values = new ContentValues();\n        values.put(Responses.SURVEY_ID, Surveys.getId(getIntent().getData()));\n        values.put(Responses.SURVEY_VERSION, Surveys.getVersion(getIntent().getData()));\n        values.put(Responses.RESPONSE_METADATA,\n                new StreamPointBuilder().now().withId()\n                        .withLocation(mLocationClient.getLastLocation())\n                        .getMetadata()\n        );\n        mPagerAdapter.buildResponse(values);\n        getContentResolver().insert(Responses.CONTENT_URI, values);\n        finish();\n    }\n\n    @Override public void onConnected(Bundle bundle) {\n        mLocationClient.requestLocationUpdates(REQUEST, new LocationListener() {\n            @Override public void onLocationChanged(Location location) {\n            }\n        });\n    }\n\n    @Override public void onDisconnected() {\n\n    }\n\n    @Override public void onConnectionFailed(ConnectionResult connectionResult) {\n\n    }\n\n    public PromptFragmentAdapter getPagerAdapter() {\n        return mPagerAdapter;\n    }\n\n    public class PromptFragmentAdapter extends FragmentStatePagerAdapter {\n        private final Prompts prompts;\n\n        private final FragmentManager mFragmentManager;\n\n        /**\n         * Keeps track of what fragments have been created\n         */\n        private BitSet mFragments = new BitSet();\n\n        /**\n         * Keeps track of any prompts which have just changed due to an answer being updated.\n         */\n        int mLastUpdate = 0;\n\n        public PromptFragmentAdapter(FragmentManager fm, Prompts prompts) {\n            super(fm);\n            mFragmentManager = fm;\n            this.prompts = prompts;\n        }\n\n        @Override\n        public SurveyItemFragment getItem(final int position) {\n            Prompt prompt = prompts.getPromptAt(position);\n            SurveyItemFragment fragment = null;\n            if (prompt == null) {\n                fragment = new SubmitResponseFragment();\n            } else {\n                fragment = prompt.getFragment();\n                fragment.showButtons(position == getCount() - 1 ? View.VISIBLE : View.GONE);\n            }\n\n            if (fragment != null) {\n                mFragments.set(position);\n            }\n\n            return fragment;\n        }\n\n        @Override\n        public void destroyItem(ViewGroup container, int position, Object object) {\n            mFragments.clear(position);\n            super.destroyItem(container, position, object);\n        }\n\n        @Override\n        public int getCount() {\n            return prompts.getAnsweredCount() + 1;\n        }\n\n        @Override\n        public float getPageWidth(int position) {\n            if (position == prompts.size()) {\n                return 1.0f;\n            }\n            return 0.1f;\n        }\n\n        @Override public Parcelable saveState() {\n            Parcelable parent = super.saveState();\n            Bundle state = new Bundle();\n            state.putParcelable(\"parent\", parent);\n            return state;\n        }\n\n        @Override\n        public void restoreState(Parcelable state, ClassLoader loader) {\n            Bundle bundle = (Bundle) state;\n            state = bundle.getBundle(\"parent\");\n\n            // Hijack the fragment state from our parent\n            if (state != null) {\n                bundle = (Bundle) state;\n                mFragments.clear();\n                Iterable<String> keys = bundle.keySet();\n                for (String key : keys) {\n                    if (key.startsWith(\"f\")) {\n                        int index = Integer.parseInt(key.substring(1));\n                        Fragment f = mFragmentManager.getFragment(bundle, key);\n                        if (f != null) {\n                            mFragments.set(index, true);\n                        } else {\n                            Log.w(TAG, \"Bad fragment at key \" + key);\n                        }\n                    }\n                }\n            }\n            super.restoreState(state, loader);\n        }\n\n        public void buildResponse(ContentValues values) {\n            Log.d(TAG, gson.toJson(prompts.answers));\n            values.put(Responses.RESPONSE_DATA, gson.toJson(prompts.answers));\n            values.put(Responses.RESPONSE_EXTRAS, gson.toJson(prompts.extras));\n        }\n\n        public void updateAnswer(PromptFragment promptFragment) {\n            promptFragment.showButtons(View.GONE);\n            Prompt prompt = promptFragment.getPrompt();\n            boolean alreadyAnswered = prompts.isAnswered(prompt);\n\n            mLastUpdate = prompts.updateAnswer(prompt);\n            notifyDataSetChanged();\n\n            if (!alreadyAnswered) {\n                moveToLastPrompt();\n            }\n        }\n\n        /**\n         * Moves to the last prompt, waits until it has been added to the view\n         */\n        private void moveToLastPrompt() {\n            final int position = getCount() - 1;\n            mPager.post(new Runnable() {\n                @Override public void run() {\n                    mPager.bringPositionUpOnScreen(position);\n                }\n            });\n        }\n\n        @Override\n        public int getItemPosition(Object object) {\n            if (object instanceof PromptFragment) {\n                if (prompts.positionOf(((PromptFragment) object).getPrompt()) >= mLastUpdate) {\n                    return PagerAdapter.POSITION_NONE;\n                }\n                return POSITION_UNCHANGED;\n            }\n            return PagerAdapter.POSITION_NONE;\n        }\n\n        public int getPosition(SurveyItemFragment fragment) {\n            if (fragment instanceof PromptFragment) {\n                return prompts.positionOf(((PromptFragment) fragment).getPrompt());\n            } else if (fragment instanceof SubmitResponseFragment) {\n                return prompts.size();\n            }\n            return -1;\n        }\n\n        public SurveyItemFragment getPromptFragmentAt(int position) {\n            if (mFragments.get(position)) {\n                return getItem(position);\n            }\n            return null;\n        }\n\n        public int getAnsweredCount() {\n            return prompts.getAnsweredCount();\n        }\n\n        public void clearExtras() {\n            prompts.clearExtras();\n        }\n    }\n\n    public static class SubmitResponseFragment extends SurveyItemFragment {\n\n        boolean submitted = false;\n\n        @Override\n        public View onCreateView(LayoutInflater inflater, final ViewGroup container,\n                Bundle savedInstanceState) {\n            View view = inflater.inflate(R.layout.prompt_submit, container, false);\n            final Button submit = (Button) view.findViewById(R.id.submit);\n            submit.setOnClickListener(new OnClickListener() {\n                @Override public void onClick(View v) {\n                    submit.setEnabled(false);\n                    if (!submitted) {\n                        submitted = true;\n                        ((SurveyActivity) getActivity()).submit();\n                    }\n                }\n            });\n            return view;\n        }\n    }\n\n    /**\n     * Static library support version of the framework's {@link android.content.CursorLoader}.\n     * Used to write apps that run on platforms prior to Android 3.0.  When running\n     * on Android 3.0 or above, this implementation is still used; it does not try\n     * to switch to the framework's implementation.  See the framework SDK\n     * documentation for a class overview.\n     */\n    public static class SurveyPromptLoader extends AsyncTaskLoader<ArrayList<Prompt>> {\n        @Inject Gson gson;\n\n        Uri mUri;\n        String[] mProjection;\n        String mSelection;\n        String[] mSelectionArgs;\n\n        Cursor mCursor;\n\n        private ArrayList<Prompt> mPrompts;\n\n        /* Runs on a worker thread */\n        @Override\n        public ArrayList<Prompt> loadInBackground() {\n            Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,\n                    mSelectionArgs, null);\n            if (cursor != null && cursor.moveToFirst()) {\n                mPrompts = gson.fromJson(cursor.getString(0), new TypeToken<ArrayList<Prompt>>() {\n                }.getType());\n                cursor.close();\n            }\n            return mPrompts;\n        }\n\n        /* Runs on the UI thread */\n        @Override\n        public void deliverResult(ArrayList<Prompt> result) {\n            if (isReset()) {\n                // An async query came in while the loader is stopped\n                mPrompts = null;\n                return;\n            }\n            mPrompts = result;\n            if (isStarted()) {\n                super.deliverResult(result);\n            }\n        }\n\n        /**\n         * Creates a Loader for prompt items\n         */\n        public SurveyPromptLoader(Context context, String surveyId, long surveyVersion) {\n            super(context);\n            ((SurveyActivity) context).inject(this);\n\n            mUri = OhmageContract.Surveys.CONTENT_URI;\n            mProjection = new String[]{\n                    OhmageContract.Surveys.SURVEY_ITEMS\n            };\n            mSelection = OhmageContract.Surveys.SURVEY_ID + \"=? AND \" +\n                         OhmageContract.Surveys.SURVEY_VERSION + \"=?\";\n            mSelectionArgs = new String[]{\n                    surveyId, String.valueOf(surveyVersion)\n            };\n        }\n\n        public SurveyPromptLoader(Context context, Uri surveyUri) {\n            super(context);\n            ((SurveyActivity) context).inject(this);\n\n            mUri = surveyUri;\n            mProjection = new String[]{\n                    OhmageContract.Surveys.SURVEY_ITEMS\n            };\n        }\n\n        /**\n         * Starts an asynchronous load of the contacts list data. When the result is ready the callbacks\n         * will be called on the UI thread. If a previous load has been completed and is still valid\n         * the result may be passed to the callbacks immediately.\n         * <p/>\n         * Must be called from the UI thread\n         */\n        @Override\n        protected void onStartLoading() {\n            if (mPrompts != null) {\n                deliverResult(mPrompts);\n            }\n            if (takeContentChanged() || mCursor == null) {\n                forceLoad();\n            }\n        }\n\n        /**\n         * Must be called from the UI thread\n         */\n        @Override\n        protected void onStopLoading() {\n            // Attempt to cancel the current load task if possible.\n            cancelLoad();\n        }\n\n        @Override\n        protected void onReset() {\n            super.onReset();\n\n            // Ensure the loader is stopped\n            onStopLoading();\n\n            mPrompts = null;\n        }\n\n        @Override\n        public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {\n            super.dump(prefix, fd, writer, args);\n            writer.print(prefix);\n            writer.print(\"mPrompts=\");\n            writer.println(mPrompts);\n        }\n    }\n\n    public static class SurveyStateFragment extends Fragment {\n        public Prompts prompts;\n\n        @Override public void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setRetainInstance(true);\n        }\n    }\n\n    /**\n     * This class keeps track of all the prompts and how the user answered them. It provides the\n     * functions {@link #answer(AnswerablePrompt)}, {@link #ignore(Prompt)}, and\n     * {@link #skip(Prompt)} based on the users actions. {@link #getPromptAt(int)} will return the\n     * next prompt ignoring all prompts which weren't displayed.\n     */\n    public static class Prompts {\n        final ArrayList<Prompt> prompts;\n\n        // Answers\n        final public HashMap<String, Object> answers;\n        final public HashMap<String, String> extras;\n\n        // List of the skipped prompts\n        final ArrayList<String> mSkipped;\n\n        // List of not displayed prompts\n        final ArrayList<String> mNotDisplayed;\n\n        public Prompts(ArrayList<Prompt> data) {\n            this.prompts = data;\n\n            answers = new HashMap<String, Object>();\n            extras = new HashMap<String, String>();\n            mSkipped = new ArrayList<String>();\n            mNotDisplayed = new ArrayList<String>();\n        }\n\n        /**\n         * Returns the prompt at the given position ignoring prompts which are not displayed\n         *\n         * @param position\n         * @return\n         */\n        public Prompt getPromptAt(int position) throws IllegalStateException {\n            Prompt prompt = null;\n            Map<String, Object> prev = null;\n            int index = promptIndex(position);\n\n            while (prompt == null && index < prompts.size()) {\n                prompt = prompts.get(index);\n                if (prompt.getCondition() != null) {\n                    if (prev == null) {\n                        prev = getPreviousResponses(index);\n                    }\n                    Condition condition = new Condition(prompt.getCondition());\n\n                    if (!condition.evaluate(prev)) {\n                        ignore(prompt);\n                        updatePrevious(prompt, prev);\n                        prompt = null;\n                        index++;\n                    }\n                }\n            }\n            return prompt;\n        }\n\n        /**\n         * Returns the index into {@link #prompts} given the position of shown prompts\n         *\n         * @param position\n         * @return\n         */\n        private int promptIndex(int position) {\n            return position + positionOffset(position);\n        }\n\n        private int positionOffset(int index) {\n            int count = 0;\n            for (int i = 0; i <= index && i < prompts.size(); i++) {\n                if (isIgnored(prompts.get(i))) {\n                    count++;\n                    index++;\n                }\n            }\n            return count;\n        }\n\n        /**\n         * Count the number of prompts that have been ignored before the given position\n         *\n         * @param index\n         * @return\n         */\n        private int ignoredPromptsBefore(int index) {\n            int count = 0;\n            for (int i = 0; i < index && i < prompts.size(); i++) {\n                if (isIgnored(prompts.get(i))) {\n                    count++;\n                }\n            }\n            return count;\n        }\n\n        /**\n         * Gets the map of all answers before the current answer to be used to evaluate the\n         * the condition for the prompt at the given position\n         *\n         * @return a map of all previous responses\n         */\n        private Map<String, Object> getPreviousResponses(int index) {\n            AbstractMap prev = new HashMap<String, Object>();\n            for (int i = 0; i < index; i++) {\n                updatePrevious(prompts.get(i), prev);\n            }\n            return prev;\n        }\n\n        /**\n         * Convenience method to update the previous responses map for the given prompt\n         *\n         * @param prompt\n         * @param prev\n         */\n        private void updatePrevious(Prompt prompt, Map<String, Object> prev) {\n            if (answers.keySet().contains(prompt.getId())) {\n                prev.put(prompt.getId(), answers.get(prompt.getId()));\n            } else if (mSkipped.contains(prompt.getId())) {\n                prev.put(prompt.getId(), NoResponse.SKIPPED);\n            } else if (mNotDisplayed.contains(prompt.getId())) {\n                prev.put(prompt.getId(), NoResponse.NOT_DISPLAYED);\n            }\n        }\n\n        /**\n         * Calculates the number of prompts that were actively answered or skipped.\n         *\n         * @return\n         */\n        public int getAnsweredCount() {\n            return answers.size() + mSkipped.size();\n        }\n\n        /**\n         * Will add an answer given the state of the prompt item\n         *\n         * @param prompt\n         * @return the index of the first position which changed due to conditions\n         */\n        public int updateAnswer(Prompt prompt) {\n            if (prompt instanceof AnswerablePrompt) {\n                if (((AnswerablePrompt) prompt).hasValidResponse()) {\n                    answer((AnswerablePrompt) prompt);\n                } else if (prompt.isSkippable()) {\n                    skip(prompt);\n                } else {\n                    // If this prompt is no longer valid remove all answers after it\n                    int invalidPrompt = prompts.indexOf(prompt);\n                    removeAnswersAfter(invalidPrompt);\n                    return invalidPrompt - ignoredPromptsBefore(invalidPrompt) + 1;\n                }\n            } else {\n                answer(prompt);\n            }\n\n            return resetFutureAnswers(prompt);\n        }\n\n        private void answer(Prompt prompt) {\n            remove(prompt);\n            answers.put(prompt.getId(), null);\n        }\n\n        private void answer(AnswerablePrompt prompt) {\n            remove(prompt);\n            answers.put(prompt.getId(), prompt.getAnswer());\n            extras.put(prompt.getId(), prompt.getAnswerExtras());\n        }\n\n        private void ignore(Prompt prompt) {\n            remove(prompt);\n            mNotDisplayed.add(prompt.getId());\n        }\n\n        private void skip(Prompt prompt) {\n            remove(prompt);\n            mSkipped.add(prompt.getId());\n        }\n\n        private void remove(Prompt prompt) {\n            mNotDisplayed.remove(prompt.getId());\n            mSkipped.remove(prompt.getId());\n            answers.remove(prompt.getId());\n            extras.remove(prompt.getId());\n        }\n\n        /**\n         * Calculates if a prompt was answered\n         *\n         * @param prompt\n         * @return true if it was answered or skipped\n         */\n        public boolean isAnswered(Prompt prompt) {\n            return answers.containsKey(prompt.getId()) || mSkipped.contains(prompt.getId());\n        }\n\n        /**\n         * Calculates if a prompt was ignored due to conditions\n         *\n         * @param prompt\n         * @return true if it was ignored\n         */\n        public boolean isIgnored(Prompt prompt) {\n            return mNotDisplayed.contains(prompt.getId());\n        }\n\n        public int ignoredPromptsSize() {\n            return mNotDisplayed.size();\n        }\n\n        public int size() {\n            return prompts.size() - mNotDisplayed.size();\n        }\n\n        public int positionOf(Prompt prompt) {\n            int idx = prompts.indexOf(prompt);\n            return idx - ignoredPromptsBefore(idx);\n        }\n\n        private void removeAnswersAfter(int index) {\n            for (int i = index; i < prompts.size(); i++) {\n                Prompt prompt = prompts.get(i);\n                String promptId = prompt.getId();\n                if (mSkipped.contains(promptId)) {\n                    mSkipped.remove(promptId);\n                } else if (answers.keySet().contains(promptId)) {\n                    answers.remove(promptId);\n                    if(extras.keySet().contains(promptId)) {\n                        extras.remove(promptId);\n                    }\n                } else if (mNotDisplayed.contains(promptId)) {\n                    mNotDisplayed.remove(promptId);\n                }\n            }\n        }\n\n        public void clearExtras() {\n            for (int i = 0; i < prompts.size(); i++) {\n                String fileName = extras.get(prompts.get(i).getId());\n                if (fileName != null) {\n                    new File(fileName).delete();\n                }\n            }\n        }\n\n        /**\n         * Since the answer changed for this response we should re-calculate all of the next responses\n         *\n         * @param prompt\n         */\n        private int resetFutureAnswers(Prompt prompt) throws IllegalStateException {\n            int pivot = prompts.indexOf(prompt);\n            Map<String, Object> prev = null;\n\n            int lastUpdate = size();\n\n            // Calculate the first prompt which no longer passes the condition test\n            int after = prompts.size();\n            for (int i = pivot + 1;\n                 i < getAnsweredCount() + ignoredPromptsSize() + 1 && i < prompts.size(); i++) {\n                prompt = prompts.get(i);\n                if (prev == null) {\n                    prev = getPreviousResponses(i);\n                }\n                if (prompt.getCondition() != null) {\n                    Condition condition = new Condition(prompt.getCondition());\n                    // The first prompt which is not the same as it used to be and is shown\n                    boolean show = condition.evaluate(prev);\n                    if (show == isIgnored(prompt)) {\n                        lastUpdate = Math.min(lastUpdate, i);\n                        if (!show) {\n                            ignore(prompt);\n                        } else {\n                            after = i;\n                            break;\n                        }\n                    }\n                }\n\n                updatePrevious(prompt, prev);\n            }\n\n            // Remove all responses after the last valid one\n            removeAnswersAfter(after);\n\n            return lastUpdate - ignoredPromptsBefore(lastUpdate + 1);\n        }\n    }\n\n    public static class CancelResponseDialogFragment extends DialogFragment {\n\n        @Override public Dialog onCreateDialog(Bundle savedInstanceState) {\n            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n            builder.setTitle(getString(R.string.discard_survey_title))\n                    .setMessage(getString(R.string.discard_survey_message))\n                    .setPositiveButton(R.string.discard, new DialogInterface.OnClickListener() {\n                        @Override public void onClick(DialogInterface dialog, int which) {\n                            ((SurveyActivity) getActivity()).discardSurvey();\n                        }\n                    })\n                    .setNegativeButton(R.string.cancel, null);\n            return builder.create();\n        }\n    }\n}\nohmage/src/main/java/org/ohmage/app/MainActivity.java\npublic class MainActivity extends InjectedActionBarActivity\n        implements AdapterView.OnItemClickListener,\n        OnAccountsUpdateListener {\n\n    private static final String TAG = MainActivity.class.getSimpleName();\n\n    /**\n     * If this action is set, the streams fragment will be shown\n     */\n    public static final String EXTRA_VIEW_STREAMS = \"extra_view_streams\";\n\n    /**\n     * If this action is set, the surveys fragment will be shown\n     */\n    public static final String EXTRA_VIEW_SURVEYS = \"extra_view_surveys\";\n\n    @Inject AccountManager accountManager;\n\n    /**\n     * The sliding drawer\n     */\n    private DrawerLayout mDrawerLayout;\n\n    /**\n     * A list of navigation items which are shown in the sliding drawer\n     */\n    private String[] mNavigationItems;\n\n    /**\n     * The list which holds the navigation items\n     */\n    private ListView mDrawerList;\n\n    /**\n     * The drawer toggle button on the actionbar\n     */\n    private ActionBarDrawerToggle mDrawerToggle;\n\n    /**\n     * An array which holds the icons for the navigation items\n     */\n    private TypedArray mNavigationIcons;\n\n    /**\n     * Set when the user wants to logout\n     */\n    private boolean mLoggingOut;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.activity_main);\n\n        mNavigationItems = getResources().getStringArray(R.array.navigation_items);\n        mNavigationIcons = getResources().obtainTypedArray(R.array.navigation_icons);\n\n        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);\n        mDrawerList = (ListView) findViewById(R.id.left_drawer);\n\n        // Set the adapter for the list view\n        ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,\n                R.layout.simple_list_item_activated_1, mNavigationItems) {\n\n            @Override\n            public View getView(int position, View convertView, ViewGroup parent) {\n                // Set the left drawable of the text view to be the icon for that item\n                TextView view = (TextView) super.getView(position, convertView, parent);\n                Drawable d = getResources()\n                        .getDrawable(mNavigationIcons.getResourceId(position, -1));\n\n                if (d != null && view != null) {\n                    int bounds = getResources()\n                            .getDimensionPixelSize(R.dimen.navigation_icon_bounds);\n                    d.setBounds(0, 0, bounds, bounds);\n                    view.setCompoundDrawables(d, null, null, null);\n                }\n                return view;\n            }\n        };\n\n        mDrawerList.setAdapter(adapter);\n\n        // Set the list's click listener\n        mDrawerList.setOnItemClickListener(this);\n        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);\n        mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START);\n\n        mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout,\n                R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close);\n\n        // Set the drawer toggle as the DrawerListener\n        mDrawerLayout.setDrawerListener(mDrawerToggle);\n\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        getSupportActionBar().setHomeButtonEnabled(true);\n\n        if (savedInstanceState == null) {\n            if (getIntent().getBooleanExtra(EXTRA_VIEW_STREAMS, false)) {\n                setFragment(getString(R.string.streams));\n            } else {\n                if (!handleNewIntent(getIntent())) {\n                    setFragment(0);\n                }\n            }\n        }\n    }\n\n    @Override protected void onNewIntent(Intent intent) {\n        super.onNewIntent(intent);\n        handleNewIntent(intent);\n    }\n\n    private boolean handleNewIntent(Intent intent) {\n        boolean handled = false;\n        boolean showStreams = intent.getBooleanExtra(EXTRA_VIEW_STREAMS, false);\n        boolean showSurveys = intent.getBooleanExtra(EXTRA_VIEW_SURVEYS, false);\n\n        Uri data = intent.getData();\n        if (data != null && \"/stream/authorized\".equals(data.getPath())) {\n\n            String packageName = data.getQueryParameter(\"packageName\");\n            String error = data.getQueryParameter(\"error\");\n            if (error != null) {\n                StreamNotAuthorizedError e =\n                        StreamNotAuthorizedError.newInstance(packageName, error);\n                e.show(getSupportFragmentManager(), \"stream_error\");\n                Log.d(TAG, \"There was an error authorizing \" + packageName + \": \" + error);\n            } else {\n                Log.d(TAG, \"Successfully authorized: \" + packageName);\n            }\n\n            showStreams = true;\n        }\n\n        if (showStreams || showSurveys) {\n            String page = showSurveys ? getString(R.string.home) : getString(R.string.streams);\n            for (int i = 0; i < mNavigationItems.length; i++) {\n                if(page.equals(mNavigationItems[i])) {\n                    setFragment(i);\n                    handled = true;\n                    break;\n                }\n            }\n        }\n        return handled;\n    }\n\n    public void onPostCreate(Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n        mDrawerToggle.syncState();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        // Watch to make sure the account still exists.\n        accountManager.addOnAccountsUpdatedListener(this, null, true);\n    }\n\n    @Override protected void onPause() {\n        super.onPause();\n\n        accountManager.removeOnAccountsUpdatedListener(this);\n    }\n\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        mDrawerToggle.onConfigurationChanged(newConfig);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main, menu);\n        return true;\n    }\n\n    @Override\n    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n        if (getString(R.string.reminders).equals(mNavigationItems[position])) {\n            Intent intent = new Intent(this, TriggerListActivity.class);\n            startActivity(intent);\n        } else {\n            setFragment(position);\n        }\n    }\n\n    private void setFragment(int position) {\n        // Set the fragment by the name\n        setFragment(mNavigationItems[position]);\n\n        // Highlight the selected item, update the title, and close the drawer\n        mDrawerList.setItemChecked(position, true);\n        if (position == 0) {\n            setTitle(R.string.app_name);\n        } else {\n            setTitle(mNavigationItems[position]);\n        }\n        mDrawerLayout.closeDrawer(mDrawerList);\n    }\n\n    public void setFragment(String id) {\n        // Find the correct fragment to show\n        Fragment fragment = new HomeFragment();\n        if (getString(R.string.ohmlets).equals(id)) {\n            fragment = new OhmletsFragment();\n        } else if (getString(R.string.surveys).equals(id)) {\n            fragment = new SurveysFragment();\n        } else if (getString(R.string.streams).equals(id)) {\n            fragment = new StreamsFragment();\n        }\n\n        // Insert the fragment by replacing any existing fragment\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        fragmentManager.beginTransaction().replace(R.id.content_frame, fragment).commit();\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (mDrawerToggle.onOptionsItemSelected(item)) {\n            return true;\n        }\n\n        switch (item.getItemId()) {\n            case R.id.action_settings:\n                //TODO: show settings\n                return true;\n\n            case R.id.action_sign_out:\n                mLoggingOut = true;\n                FragmentManager fm = getSupportFragmentManager();\n                LogoutTaskFragment logoutTaskFragment =\n                        (LogoutTaskFragment) fm.findFragmentByTag(\"logout\");\n\n                // If the Fragment is non-null, then it is currently being\n                // retained across a configuration change.\n                if (logoutTaskFragment == null) {\n                    logoutTaskFragment = new LogoutTaskFragment();\n                    fm.beginTransaction().add(logoutTaskFragment, \"logout\").commit();\n                }\n\n                return true;\n        }\n\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onBackPressed() {\n\n        // This is a workaround for this bug\n        // https://code.google.com/p/android/issues/detail?id=40323\n\n        // If the fragment exists and has some back-stack entry\n        Fragment fragment = getSupportFragmentManager().findFragmentById(R.id.content_frame);\n        if (fragment != null && fragment.getChildFragmentManager().getBackStackEntryCount() > 0) {\n            // Get the fragment fragment manager - and pop the back stack\n            fragment.getChildFragmentManager().popBackStack();\n        } else {\n            // otherwise let super handle the back press\n            super.onBackPressed();\n        }\n    }\n\n    @Override public void onAccountsUpdated(Account[] accounts) {\n        for (Account account : accounts) {\n            if (AuthUtil.ACCOUNT_TYPE.equals(account.type)) {\n                return;\n            }\n        }\n\n        // No ohmage accounts so start the authenticator activity\n        Intent intent = new Intent(this, AuthenticatorActivity.class);\n        if (mLoggingOut)\n            intent.putExtra(AuthenticatorActivity.EXTRA_CLEAR_DEFAULT_ACCOUNT, true);\n        startActivity(intent);\n        finish();\n    }\n\n    public static class StreamNotAuthorizedError extends DialogFragment {\n\n        public static StreamNotAuthorizedError newInstance(String packageName, String error) {\n            StreamNotAuthorizedError fragment = new StreamNotAuthorizedError();\n            Bundle args = new Bundle();\n            args.putString(\"error\", error);\n            args.putString(\"packageName\", packageName);\n            fragment.setArguments(args);\n            return fragment;\n        }\n\n        @Override public Dialog onCreateDialog(Bundle savedInstanceState) {\n            String packageName = getArguments().getString(\"packageName\");\n            String error = getArguments().getString(\"error\");\n            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n            builder.setTitle(R.string.title_stream_not_authorized)\n                    .setMessage(\n                            getString(R.string.message_stream_not_authorized, packageName, error));\n            builder.setPositiveButton(android.R.string.ok, null);\n            return builder.create();\n        }\n    }\n}\nohmage/src/main/java/org/ohmage/app/OhmageService.java\npublic interface OhmageService {\n\n    @GET(\"/auth_token\") AccessToken getAccessToken(@Query(\"refresh_token\") String refreshToken)\n            throws AuthenticationException;\n\n    @GET(\"/auth_token\")\n    AccessToken getAccessToken(@Query(\"email\") String email, @Query(\"password\") String password)\n            throws AuthenticationException;\n\n    @GET(\"/auth_token\")\n    void getAccessToken(@Query(\"email\") String email, @Query(\"password\") String password,\n            CancelableCallback<AccessToken> callback);\n\n    //This path is checked in the OkClient to prevent redirects\n    @GET(\"/oauth/authorize?response_type=code\")\n    Observable<String> OAuthAuthorize(@Query(\"client_id\") String clientId, @Query(\"scope\") String scope,\n            @Query(\"state\") String state);\n\n    //This path is checked in the OkClient to prevent redirects\n    @POST(\"/oauth/authorization_with_token\")\n    Observable<String> OAuthAuthorized(@Query(\"granted\") boolean granted, @Query(\"code\") String code);\n\n    @GET(\"/oauth/clients/{client_id}\")\n    Observable<OAuthClient> OAuthClientInfo(@Path(\"client_id\") String clientId);\n\n    @POST(\"/people\") void createUser(@Query(\"provider\") AuthUtil.GrantType grantType,\n            @Query(\"access_token\") String accessToken, @Body User user,\n            CancelableCallback<User> callback);\n\n    @POST(\"/people\") void createUser(@Query(\"password\") String password, @Body User user,\n            CancelableCallback<User> callback);\n\n    @POST(\"/people\") void createUser(@Query(\"password\") String password, @Body User user,\n            @Query(\"user_invitation_id\") String inviteCode, CancelableCallback<User> callback);\n\n    @GET(\"/people/{userId}/current/\")\n    Observable<User> getCurrentStateForUser(@Path(\"userId\") String userId)\n            throws AuthenticationException;\n\n    @GET(\"/ohmlets\")\n    void searchOhmlets(@Query(\"query\") String query, Callback<Ohmlets> ohmletsCallback);\n\n    @GET(\"/ohmlets\") void getOhmlets(Callback<Ohmlets> ohmletsCallback);\n\n    @GET(\"/ohmlets/{ohmletId}\") Observable<Ohmlet> getOhmlet(@Path(\"ohmletId\") String id);\n\n    @POST(\"/ohmlets/{ohmletId}/people\")\n    Response updateMemberForOhmlet(@Path(\"ohmletId\") String ohmletId, @Body Member member)\n            throws AuthenticationException;\n\n    @POST(\"/ohmlets/{ohmletId}/people\")\n    Response updateMemberForOhmlet(@Path(\"ohmletId\") String ohmletId, @Body Member member,\n            @Query(\"ohmlet_invitation_id\") String inviteCode) throws AuthenticationException;\n\n    @DELETE(\"/ohmlets/{ohmletId}/people/{userId}\")\n    Response removeUserFromOhmlet(@Path(\"ohmletId\") String ohmletId, @Path(\"userId\") String userId)\n            throws AuthenticationException;\n\n    @GET(\"/surveys\") void getSurveys(Callback<Surveys> surveysCallback);\n\n    @GET(\"/surveys\")\n    Observable<List<Survey>> getDefaultSurveys();\n\n    @GET(\"/surveys/{surveyId}/{surveyVersion}\")\n    Observable<Survey> getSurvey(@Path(\"surveyId\") String surveyId,\n            @Path(\"surveyVersion\") String surveyVersion);\n\n    @POST(\"/surveys/{surveyId}/{surveyVersion}/data\")\n    Observable<Response> uploadResponse(@Path(\"surveyId\") String surveyId,\n            @Path(\"surveyVersion\") long surveyVersion, @Body ResponseTypedOutput data)\n            throws AuthenticationException;\n\n    @GET(\"/streams/{streamId}\")\n    Observable<Collection<Integer>> getStreamVersions(@Path(\"streamId\") String streamId);\n\n    @GET(\"/streams/{streamId}/{streamVersion}\")\n    Observable<Stream> getStream(@Path(\"streamId\") String streamId,\n            @Path(\"streamVersion\") long streamVersion);\n\n    @POST(\"/streams/{streamId}/{streamVersion}/data\")\n    Response uploadStreamData(@Path(\"streamId\") String streamId,\n            @Path(\"streamVersion\") long streamVersion, @Body StreamWriterOutput data)\n            throws AuthenticationException;\n\n    // *** START OMH-DSU *** //\n    @Headers(AuthUtil.OMH_AUTH_HEADER)\n    @GET(\"/google-signin\") AccessToken getAccessTokenWithCode(@Query(\"code\") String code,\n            @Query(\"client_id\") String clientId) throws AuthenticationException;\n\n    @Headers(AuthUtil.OMH_AUTH_HEADER)\n    @GET(\"/google-signin\") void getAccessTokenWithCode(@Query(\"code\") String code,\n            @Query(\"client_id\") String clientId, CancelableCallback<AccessToken> callback);\n\n    @Headers(AuthUtil.OMH_AUTH_HEADER)\n    @FormUrlEncoded\n    @POST(\"/oauth/token\") AccessToken refreshAccessToken(@Field(\"refresh_token\") String refreshToken, @Field(\"grant_type\") String type)\n            throws AuthenticationException;\n\n    @POST(\"/dataPoints\")\n    Observable<Response> uploadDataPoint(@Body DataPointTypedOutput data)\n            throws AuthenticationException;\n\n    // *** END OMH-DSU *** //\n    public abstract static class CancelableCallback<T> implements Callback<T> {\n\n        private boolean mCancelled;\n\n        public void cancel() {\n            mCancelled = true;\n        }\n\n        public boolean isCancelled() {\n            return mCancelled;\n        }\n    }\n}\nohmage/src/main/java/org/ohmage/fragments/HomeFragment.java\npublic class HomeFragment extends GridFragment implements LoaderCallbacks<Cursor>,\n        OnRefreshListener, SyncStatusObserver {\n\n    @Inject AccountManager am;\n\n    private static final String TAG = HomeFragment.class.getSimpleName();\n    private PullToRefreshLayout mPullToRefreshLayout;\n\n    private Object syncObserverHandle;\n    private Handler mHandler = new Handler();\n    private Runnable mRefreshCompleteRunnable = new Runnable() {\n        @Override public void run() {\n            if(getView() != null) {\n                setEmptyText(\"No Surveys\");\n                mPullToRefreshLayout.setRefreshComplete();\n            }\n        }\n    };\n\n    @Override public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n    }\n\n    @Override public void onResume() {\n        super.onResume();\n\n        syncObserverHandle = ContentResolver.addStatusChangeListener(\n                ContentResolver.SYNC_OBSERVER_TYPE_PENDING |\n                ContentResolver.SYNC_OBSERVER_TYPE_ACTIVE, this\n        );\n\n        checkSyncStatus();\n    }\n\n    @Override public void onPause() {\n        super.onPause();\n        if(syncObserverHandle != null) {\n            ContentResolver.removeStatusChangeListener(syncObserverHandle);\n            syncObserverHandle = null;\n        }\n    }\n\n    @Override public void onDestroy() {\n        super.onDestroy();\n        mHandler.removeCallbacks(mRefreshCompleteRunnable);\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n\n        setEmptyText(\"No surveys\");\n\n        setGridShown(false);\n\n        getLoaderManager().initLoader(0, null, this);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.refreshable_grid_layout, container, false);\n\n        // Now find the PullToRefreshLayout to setup\n        mPullToRefreshLayout = (PullToRefreshLayout) view.findViewById(R.id.ptr_layout);\n\n        // Now setup the PullToRefreshLayout\n        ActionBarPullToRefresh.from(getActivity())\n                // Mark All Children as pullable\n                .allChildrenArePullable()\n                        // Set the OnRefreshListener\n                .listener(this)\n                .theseChildrenArePullable(R.id.grid, R.id.internalEmpty)\n                .useViewDelegate(TextView.class, new ViewDelegate() {\n                    @Override public boolean isReadyForPull(View view, float v, float v2) {\n                        return true;\n                    }\n                })\n                .useViewDelegate(GridView.class, new AbsListViewDelegate())\n                        // Finally commit the setup to our PullToRefreshLayout\n                .setup(mPullToRefreshLayout);\n\n        return view;\n    }\n\n    @Override\n    public SurveyAdapter getListAdapter() {\n        return (SurveyAdapter) super.getListAdapter();\n    }\n\n    @Override\n    public void onGridItemClick(GridView g, View v, int position, long id) {\n        Cursor cursor = getListAdapter().getItem(position).getData();\n        if (cursor != null) {\n            startActivity(new Intent(Intent.ACTION_VIEW, OhmageContract.Surveys\n                    .getUriForSurveyIdVersion(cursor.getString(0), cursor.getString(1))));\n        }\n    }\n\n    @Override public Loader<Cursor> onCreateLoader(int id, Bundle args) {\n        return new CursorLoader(getActivity(), OhmageContract.Surveys.CONTENT_URI, new String[]{\n                Surveys.SURVEY_ID, Surveys.SURVEY_VERSION, Surveys.SURVEY_NAME,\n                Surveys.SURVEY_DESCRIPTION, Surveys.SURVEY_PENDING_TIME,\n                Surveys.SURVEY_PENDING_TIMEZONE}, null, null,\n                Surveys.SURVEY_PENDING_TIME + \" desc\"\n        );\n    }\n\n    @Override public void onLoadFinished(Loader<Cursor> loader, Cursor data) {\n\n        ArrayList<Item> items = new ArrayList<Item>();\n        boolean pivot = true;\n        data.moveToPosition(-1);\n        while (data.moveToNext()) {\n            if (items.isEmpty() && data.getLong(4) != Reminders.NOT_PENDING) {\n                pivot = false;\n                items.add(new Item(\"Pending\"));\n            } else if (!items.isEmpty() && data.getLong(4) == Reminders.NOT_PENDING && !pivot) {\n                pivot = true;\n                items.add(new Item(\"Surveys\"));\n            }\n            items.add(new Item(data, 0));\n        }\n\n        SurveyAdapter adapter = getListAdapter();\n        if (adapter == null) {\n            adapter = new SurveyAdapter(getActivity(), items);\n            setListAdapter(adapter);\n        } else {\n            adapter.setData(items);\n        }\n\n        setGridShown(true);\n    }\n\n    @Override public void onLoaderReset(Loader<Cursor> loader) {\n        getListAdapter().setData(null);\n    }\n\n    @Override public void onRefreshStarted(View view) {\n        Account[] accounts = am.getAccountsByType(AuthUtil.ACCOUNT_TYPE);\n        for (Account account : accounts) {\n            Bundle bundle = new Bundle();\n            bundle.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true);\n            ContentResolver.requestSync(account, OhmageContract.CONTENT_AUTHORITY, bundle);\n        }\n    }\n\n    @Override public void onStatusChanged(int which) {\n        checkSyncStatus();\n    }\n\n    public void checkSyncStatus() {\n        Account[] accounts = am.getAccountsByType(AuthUtil.ACCOUNT_TYPE);\n        if(accounts.length == 0) {\n            return;\n        }\n\n        mHandler.removeCallbacks(mRefreshCompleteRunnable);\n        if(ContentResolver.isSyncActive(accounts[0], OhmageContract.CONTENT_AUTHORITY) ||\n           ContentResolver.isSyncPending(accounts[0], OhmageContract.CONTENT_AUTHORITY)) {\n            getActivity().runOnUiThread(new Runnable() {\n                @Override public void run() {\n                    if(getListAdapter() == null || getListAdapter().isEmpty()) {\n                        mPullToRefreshLayout.setRefreshing(true);\n                        setEmptyText(\"Please wait for Surveys to Synchronize...\");\n                    }\n                }\n            });\n        } else {\n            mHandler.postDelayed(mRefreshCompleteRunnable, 500);\n        }\n    }\n\n    private static class Item {\n        private int dataPosition = -1;\n\n        /**\n         * The index of the id field for the cursor\n         */\n        private final int idIdex;\n\n        private final Cursor data;\n        private final String header;\n\n        public Item(String header) {\n            this(header, null, -1);\n            if (header == null) {\n                throw new IllegalArgumentException(\"the header string can't be null\");\n            }\n        }\n\n        public Item(Cursor data, int idIdx) {\n            this(null, data, idIdx);\n            if (data == null) {\n                throw new IllegalArgumentException(\"the cursor data shouldn't be null\");\n            }\n        }\n\n        private Item(String header, Cursor data, int idIdx) {\n            this.header = header;\n            this.data = data;\n            if (data != null) {\n                this.dataPosition = data.getPosition();\n            } else {\n                this.dataPosition = -1;\n            }\n            this.idIdex = idIdx;\n        }\n\n        public boolean isHeader() {\n            return data == null;\n        }\n\n        public Cursor getData() {\n            data.moveToPosition(dataPosition);\n            return data;\n        }\n\n        public long getItemId() {\n            return data == null ? header.hashCode() : getData().getString(0).hashCode();\n        }\n    }\n\n    public static class SurveyAdapter extends BaseAdapter {\n        private static final int HEADER = 0;\n        private static final int DATA = 1;\n\n        private final LayoutInflater mInflater;\n        private final Context mContext;\n        private ArrayList<Item> mData;\n\n        private final DateTimeFormatter mTimeFormatter;\n\n        public SurveyAdapter(Context context, ArrayList<Item> data) {\n            super();\n            mContext = context;\n            mData = data;\n            mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n            mTimeFormatter = DateTimeFormat.shortTime().withZone(DateTimeZone.getDefault());\n        }\n\n        public boolean areAllItemsEnabled() {\n            return false;\n        }\n\n        public boolean isEnabled(int position) {\n            return !getItem(position).isHeader();\n        }\n\n        public int getItemViewType(int position) {\n            return getItem(position).isHeader() ? HEADER : DATA;\n        }\n\n        public int getViewTypeCount() {\n            return 2;\n        }\n\n        @Override public int getCount() {\n            return mData.size();\n        }\n\n        @Override public Item getItem(int position) {\n            return mData.get(position);\n        }\n\n        @Override public long getItemId(int position) {\n            return getItem(position).getItemId();\n        }\n\n        @Override public View getView(int position, View convertView, ViewGroup parent) {\n            Item item = getItem(position);\n            if (convertView == null) {\n                if (item.isHeader()) {\n                    convertView = new TextView(mContext);\n                } else {\n                    convertView = mInflater.inflate(R.layout.list_item_local_survey, parent, false);\n                }\n            }\n\n            if (item.isHeader()) {\n                ((TextView) convertView).setText(item.header);\n            } else {\n                TextView name = ViewHolder.get(convertView, R.id.name);\n                TextView description = ViewHolder.get(convertView, R.id.description);\n                TextView pending = ViewHolder.get(convertView, R.id.pendingTime);\n\n                Cursor data = item.getData();\n\n                name.setText(data.getString(2));\n                description.setText(data.getString(3));\n                long pendingTime = data.getLong(4);\n                String zone = data.getString(5);\n                pending.setText(\n                        mTimeFormatter.withZone(DateTimeZone.forID(zone)).print(pendingTime));\n                pending.setVisibility(\n                        pendingTime == Reminders.NOT_PENDING ? View.GONE : View.VISIBLE);\n            }\n\n            return convertView;\n        }\n\n        public void setData(ArrayList<Item> data) {\n            if (data == null) {\n                mData.clear();\n            } else {\n                mData = data;\n            }\n            notifyDataSetChanged();\n        }\n    }\n}\nohmage/src/main/java/org/ohmage/auth/AuthHelper.java\npublic class AuthHelper {\n\n    private final Context mContext;\n\n    public AuthHelper(Context context) {\n        mContext = context;\n    }\n\n    public String googleAuthGetToken(String googleAccount) throws UserRecoverableAuthException,\n            IOException, GoogleAuthException {\n        String code = GoogleAuthUtil.getToken(mContext, googleAccount, AuthUtil.Google.CODE_SCOPE, null);\n        // clear it immediately to avoid stale code from being cached\n        GoogleAuthUtil.clearToken(mContext, code);\n        return \"fromApp_\" + code;\n    }\n}\nohmage/src/androidTest/java/org/ohmage/app/MainActivityOhmletsTest.java\n@LargeTest\npublic class MainActivityOhmletsTest extends InjectedActivityInstrumentationTestCase<MainActivity> {\n\n    @Inject AccountManager fakeAccountManager;\n    @Inject OhmageService fakeOhmageService;\n\n    Account fakeAccount = new Account(\"username\", AuthUtil.ACCOUNT_TYPE);\n\n    public MainActivityOhmletsTest() {\n        super(MainActivity.class);\n    }\n\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        when(fakeAccountManager.getAccountsByType(AuthUtil.ACCOUNT_TYPE))\n                .thenReturn(new Account[]{fakeAccount});\n        MainActivity activity = getActivity();\n\n        // Open the ohmlets page\n        activity.setFragment(activity.getString(R.string.ohmlets));\n    }\n\n    public void testClickingSearchIcon_initialState_showsSearchTextBox() {\n        onView(withId(R.id.search_button)).perform(click());\n        onView(withId(R.id.search_src_text))\n                .check(matches(isDisplayed()))\n                .check(matches(hasFocus()));\n    }\n\n    public void testTypingText_inSearchBox_sendsTheCorrectQueryToTheNetwork()\n            throws InterruptedException {\n        onView(withId(R.id.search_button)).perform(click());\n        String query = \"a\";\n\n        onView(withId(R.id.search_src_text)).perform(typeText(query)).perform();\n        // Wait for a few milliseconds so the request will actually happen\n        Thread.sleep(250);\n\n        verify(fakeOhmageService).searchOhmlets(eq(query), any(Callback.class));\n    }\n\n    public void testReceivingList_withItems_showsItemsInList() {\n        onView(withId(R.id.search_button)).perform(click());\n        String query = \"a\";\n        final Ohmlets ohmlets = new Ohmlets();\n        addFakeOhmlet(ohmlets);\n        doAnswer(new Answer<Object>() {\n            @Override\n            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n                Callback<Ohmlets> cb = (Callback<Ohmlets>) invocationOnMock.getArguments()[1];\n                cb.success(ohmlets, null);\n                return null;\n            }\n        }).when(fakeOhmageService).searchOhmlets(eq(query), any(Callback.class));\n\n        onView(withId(R.id.search_src_text)).perform(typeText(query));\n    }\n//\n//    public void testTypingText_noPreviousQuery_showsSpinnerWhileRequestIsBeingMade() {\n//\n//    }\n//\n//    public void testTypingText_noDataForPreviousQuery_showsSpinnerWhileRequestIsBeingMade() {\n//\n//    }\n//\n//    public void testQuicklyTypingText_searchBoxIsSelected_onlySendsOneNetworkRequestAtTheEnd() {\n//\n//    }\n//\n//    public void testTypingText_afterPreviousQueryMadeWithReturnedData_continuesToShowOldData() {\n//\n//    }\n//\n//    public void testTypingText_afterPreviousQueryMadeWithReturnedData_showsNewItemsAfterTheRequestIsComplete() {\n//\n//    }\n\n    private void addFakeOhmlet(Ohmlets ohmlets) {\n        Ohmlet p = new Ohmlet();\n        p.ohmletId = ohmlets.size() + 1 + \"\";\n        p.name = \"Blah Ohmlet\";\n        p.description = \"This is a fake ohmlet to collect blah data\";\n        ohmlets.add(p);\n    }\n}\nohmage/src/main/java/org/ohmage/operators/ContentProviderSaver.java\npublic class ContentProviderSaver implements Action1<Savable> {\n    private static final String TAG = ContentProviderSaver.class.getSimpleName();\n\n    private final boolean mIsSyncAdapter;\n\n    @Inject Gson gson;\n\n    public ContentProviderSaver() {\n        this(false);\n    }\n\n    public ContentProviderSaver(boolean isSyncAdapter) {\n        Ohmage.app().getApplicationGraph().inject(this);\n        mIsSyncAdapter = isSyncAdapter;\n    }\n\n    @Override public void call(Savable savable) {\n        Uri uri = savable.getUrl();\n        if (mIsSyncAdapter)\n            uri = OhmageSyncAdapter.appendSyncAdapterParam(uri);\n        Ohmage.app().getContentResolver().insert(uri, savable.toContentValues(this));\n        savable.onSaved();\n    }\n\n    public Gson gson() {\n        return gson;\n    }\n\n    public static interface Savable {\n        ContentValues toContentValues(ContentProviderSaver saver);\n\n        Uri getUrl();\n\n        void onSaved();\n    }\n\n    public static class ContentProviderSaverSubscriber extends Subscriber<Savable> {\n\n        private final boolean mIsSyncAdapter;\n\n        public ContentProviderSaverSubscriber(boolean isSyncAdapter) {\n            mIsSyncAdapter = isSyncAdapter;\n        }\n\n        @Override public void onCompleted() {\n\n        }\n\n        @Override public void onError(Throwable e) {\n            e.printStackTrace();\n        }\n\n        @Override public void onNext(Savable args) {\n            new ContentProviderSaver(mIsSyncAdapter).call(args);\n        }\n    }\n}\nohmage/src/main/java/org/ohmage/auth/Authenticator.java\npublic class Authenticator extends AbstractAccountAuthenticator {\n\n    @Inject AccountManager am;\n    @Inject OhmageService ohmageService;\n    @Inject AuthHelper authHelper;\n\n    /**\n     * This is the google email of an account that can be used for authentication\n     */\n    public static final String USER_DATA_GOOGLE_ACCOUNT = \"user_data_google_account\";\n\n    /**\n     * This is set when the password for the account is the users actual password rather than\n     * a refreshToken. This happens if the user has not verified their account yet.\n     */\n    public static final String USE_PASSWORD = \"use_password\";\n\n    /**\n     * The user id for the account as provided by the server.\n     */\n    public static final String USER_ID = \"user_id\";\n\n    // Authentication Service context\n    private final Context mContext;\n\n    public Authenticator(Context context) {\n        super(context);\n        mContext = context;\n        Ohmage.app().getApplicationGraph().inject(this);\n    }\n\n    @Override\n    public Bundle addAccount(AccountAuthenticatorResponse response,\n            String accountType, String authTokenType, String[] requiredFeatures,\n            Bundle options) {\n        // TODO: decide if we should allow more than one account, and if not, make it clear to the\n        // user that they need to logout and login with a new account\n\n        final Intent intent = new Intent(mContext, AuthenticatorActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_TYPE, accountType);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);\n        final Bundle bundle = new Bundle();\n        bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n        return bundle;\n    }\n\n    @Override\n    public Bundle confirmCredentials(AccountAuthenticatorResponse response,\n            Account account, Bundle options) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Bundle editProperties(AccountAuthenticatorResponse response,\n            String accountType) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Bundle getAuthToken(AccountAuthenticatorResponse response, Account account,\n            String authTokenType, Bundle loginOptions)\n            throws NetworkErrorException {\n\n\n        // Extract the email and refresh_token from the Account Manager, and ask\n        // the server for a new refresh_token.\n        String authToken = am.peekAuthToken(account, authTokenType);\n\n        // Lets give another try to authenticate the user\n        AccessToken token = null;\n        UserRecoverableAuthException userRecoverableAuthException = null;\n        Log.e(Authenticator.class.getSimpleName(), \"Get Auth token \" + authToken + \" Refresh \" + am.getPassword(account));\n        if (TextUtils.isEmpty(authToken)) {\n            final String refreshToken = am.getPassword(account);\n\n            if (refreshToken != null) {\n\n                try {\n                    // If the account credentials have not gone to the server yet we saved the\n                    // password for the user\n                    if (Boolean.parseBoolean(am.getUserData(account, USE_PASSWORD))) {\n                        token = ohmageService.getAccessToken(account.name, refreshToken);\n                        if (token != null) {\n                            am.setUserData(account, Authenticator.USE_PASSWORD,\n                                    String.valueOf(false));\n                            am.setUserData(account, Authenticator.USER_ID, token.getUserId());\n                        }\n                    } else {\n                        // refresh token\n                        if(Ohmage.USE_DSU_DATAPOINTS_API) {\n                            token = ohmageService.refreshAccessToken(refreshToken, \"refresh_token\");\n                        }else {\n                            token = ohmageService.getAccessToken(refreshToken);\n                        }\n                    }\n                } catch (AuthenticationException e) {\n                    // This will happen if the refresh token was already used, or it was\n                    // invalidated or something\n\n                    // We can try getting the token from google\n                    String googleAccount = am.getUserData(account, USER_DATA_GOOGLE_ACCOUNT);\n                    if (googleAccount != null) {\n                        try {\n                            token = getTokenFromGoogle(googleAccount);\n                        } catch (UserRecoverableAuthException e1) {\n                            userRecoverableAuthException = e1;\n                        }\n                    }\n                } catch (RetrofitError e) {\n                    if (e.getResponse() != null && e.getResponse().getStatus() == 409) {\n                        // The user hasn't activated their account by clicking the link\n                        final Bundle bundle = new Bundle();\n                        bundle.putString(AccountManager.KEY_AUTH_FAILED_MESSAGE,\n                                Ohmage.app().getString(R.string.account_not_activated));\n                        bundle.putParcelable(AccountManager.KEY_INTENT, new Intent(mContext,\n                                AccountNotActivatedDialog.class));\n                        return bundle;\n                    } else {\n                        throw new NetworkErrorException();\n                    }\n                } catch(Exception e){\n                    Log.e(Authenticator.class.getSimpleName(), \"\", e);\n                }\n            }\n        }\n\n        // If we get an authToken - we return it\n        if (token != null) {\n            am.setPassword(account, token.getRefreshToken());\n            authToken = token.getAccessToken();\n        }\n\n        if (!TextUtils.isEmpty(authToken)) {\n            final Bundle result = new Bundle();\n            result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n            result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n            result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n            return result;\n        }\n\n        // If we get here, then we couldn't access the user's password - so we\n        // need to re-prompt them for their credentials. We do that by creating\n        // an intent to display our AuthenticatorActivity.\n        final Intent intent = new Intent(mContext, AuthenticatorActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);\n        intent.putExtra(AuthenticatorActivity.EXTRA_FROM_AUTHENTICATOR, true);\n        intent.putExtra(AuthenticatorActivity.EXTRA_HANDLE_USER_RECOVERABLE_ERROR,\n                userRecoverableAuthException);\n        final Bundle bundle = new Bundle();\n        bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n        return bundle;\n    }\n\n    private AccessToken getTokenFromGoogle(String googleAccount)\n            throws NetworkErrorException, UserRecoverableAuthException {\n        // We can check for a google account to automatically update the refresh token\n\n        try {\n            String googleToken = authHelper.googleAuthGetToken(googleAccount);\n            return ohmageService.getAccessTokenWithCode(googleToken, AuthUtil.OMH_CLIENT_ID);\n\n        } catch (UserRecoverableAuthException userAuthEx) {\n            throw userAuthEx;\n        } catch (GoogleAuthException authEx) {\n            // We can't really deal with this.. hopefully it doesn't happen\n        } catch (RetrofitError e) {\n            if (e.isNetworkError()) {\n                throw new NetworkErrorException();\n            }\n            //TODO: what should we catch for retrofit exceptions?\n        } catch (IOException transientEx) {\n            throw new NetworkErrorException();\n        } catch (AuthenticationException e) {\n            //TODO: what should we do if the token is invalid?\n        }\n        return null;\n    }\n\n    @Override\n    public String getAuthTokenLabel(String authTokenType) {\n        if (authTokenType.equals(AuthUtil.AUTHTOKEN_TYPE)) {\n            return mContext.getString(R.string.app_name);\n        }\n        return null;\n    }\n\n    @Override\n    public Bundle hasFeatures(AccountAuthenticatorResponse response,\n            Account account, String[] features) {\n        final Bundle result = new Bundle();\n        result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);\n        return result;\n    }\n\n    @Override\n    public Bundle updateCredentials(AccountAuthenticatorResponse response,\n            Account account, String authTokenType, Bundle loginOptions) {\n        throw new UnsupportedOperationException();\n    }\n}\nohmage/src/main/java/org/ohmage/auth/CreateAccountFragment.java\npublic class CreateAccountFragment extends TransitionFragment {\n\n    private static final String TAG = CreateAccountFragment.class.getSimpleName();\n\n    @Inject OhmageService ohmageService;\n\n    // UI references.\n    private EditText mFullnameView;\n    private EditText mEmailView;\n    private EditText mPasswordView;\n\n    private User mUser = new User();\n\n    /**\n     * Stores the password for the user if it is an ohmage account\n     */\n    private String mPassword;\n\n    /**\n     * The grant type should be set to determine which views will be shown to the user.\n     */\n    private AuthUtil.GrantType mGrantType;\n\n    /**\n     * Callbacks for the activity to handle create button pressed\n     */\n    private Callbacks mCallbacks;\n\n    public CreateAccountFragment() {\n        setDefaultAnimation(R.anim.slide_in_top, R.anim.slide_out_top);\n    }\n\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        mCallbacks = (Callbacks) activity;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setRetainInstance(true);\n    }\n\n    @Override\n    public void onDetach() {\n        super.onDetach();\n        mCallbacks = null;\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.fragment_create_account, container, false);\n\n        // Set up the login form.\n        mFullnameView = (EditText) view.findViewById(R.id.fullname);\n        mEmailView = (EditText) view.findViewById(R.id.email);\n        mPasswordView = (EditText) view.findViewById(R.id.password);\n        mPasswordView.setOnEditorActionListener(new TextView.OnEditorActionListener() {\n            @Override\n            public boolean onEditorAction(TextView textView, int id, KeyEvent keyEvent) {\n                if (id == R.id.create_account || id == EditorInfo.IME_NULL) {\n                    attemptAccountCreate();\n                    return true;\n                }\n                return false;\n            }\n        });\n\n        mEmailView.setText(mUser.email);\n        mFullnameView.setText(mUser.fullName);\n\n        view.findViewById(R.id.create_account_button)\n                .setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        attemptAccountCreate();\n                    }\n                });\n\n        setViewState(view);\n\n        return view;\n    }\n\n    /**\n     * Sets the visibility state of the prompts based on the grant type\n     *\n     * @param view\n     */\n    private void setViewState(View view) {\n        if (view != null) {\n            view.findViewById(R.id.ohmage_account_prompts).setVisibility(\n                    (showOhmageAccountPrompts()) ? View.VISIBLE : View.GONE);\n            ((TextView) view.findViewById(R.id.header_text)).setText((showOhmageAccountPrompts())\n                    ? R.string.create_ohmage_account_title\n                    : R.string.common_signin_button_text_long);\n        }\n    }\n\n    /**\n     * Called when the user clicks the create button. This will callback to the activity if\n     * the values supplied by the user are valid.\n     */\n    public void attemptAccountCreate() {\n\n        mEmailView.setError(null);\n\n        String fullName = mFullnameView.getText().toString();\n        mPassword = mPasswordView.getText().toString();\n        String email = mEmailView.getText().toString();\n\n        boolean cancel = false;\n        View focusView = null;\n\n        // Check for a valid email.\n        if (showOhmageAccountPrompts() && TextUtils.isEmpty(email)) {\n            mEmailView.setError(getString(R.string.error_field_required));\n            focusView = mEmailView;\n            cancel = true;\n        } else if (showOhmageAccountPrompts() && !isValidEmail(email)) {\n            mEmailView.setError(getString(R.string.error_invalid_email_address));\n            focusView = mEmailView;\n            cancel = true;\n        } else if (showOhmageAccountPrompts() && TextUtils.isEmpty(mPassword)) {\n            mPasswordView.setError(getString(R.string.error_field_required));\n            focusView = mPasswordView;\n            cancel = true;\n        }\n\n        if (cancel) {\n            // There was an error; don't attempt login and focus the first\n            // form field with an error.\n            focusView.requestFocus();\n        } else {\n            mUser.fullName = TextUtils.isEmpty(fullName) ? null : fullName;\n            mUser.email = TextUtils.isEmpty(email) ? null : email;\n\n            // First notify the activity that the account is being created\n            if (mCallbacks != null) {\n                mCallbacks.onCreateAccount();\n            }\n\n            // Either ask for the token or start to create the account\n            if (!showOhmageAccountPrompts()) {\n                mCallbacks.fetchToken(new UseToken() {\n                    @Override\n                    public void useToken(String token) {\n                        createAccount(token);\n                    }\n                });\n            } else {\n                createAccount(mPassword);\n            }\n        }\n    }\n\n    /**\n     * Just a simple check for now to see if there is an at sign and a period\n     *\n     * @param email\n     * @return true if the email is valid enough..\n     */\n    private boolean isValidEmail(String email) {\n        return Patterns.EMAIL_ADDRESS.matcher(email).matches();\n    }\n\n    /**\n     * Make the network call to create a user account\n     *\n     * @param token\n     */\n    private void createAccount(final String token) {\n        if (mGrantType == AuthUtil.GrantType.CLIENT_CREDENTIALS) {\n            CancelableCallback<User> callback = new CancelableCallback<User>() {\n                @Override public void success(User user, Response response) {\n                    ((AuthenticatorActivity) getActivity()).createAccount(user, token);\n                }\n\n                @Override public void failure(RetrofitError error) {\n                    ((AuthenticatorActivity) getActivity()).onRetrofitError(error);\n                }\n            };\n\n            String emailVerificationCode = getActivity().getIntent().getStringExtra(\n                    AuthenticatorActivity.EXTRA_USER_INVITATION_CODE);\n            if (emailVerificationCode != null)\n                ohmageService.createUser(token, mUser, emailVerificationCode, callback);\n            else\n                ohmageService.createUser(token, mUser, callback);\n        } else {\n            ohmageService.createUser(mGrantType, token, mUser,\n                    new OhmageService.CancelableCallback<User>() {\n                        @Override public void success(final User user, Response response) {\n                            mCallbacks.fetchToken(new UseToken() {\n                                @Override\n                                public void useToken(String token) {\n                                    ohmageService.getAccessTokenWithCode(token, AuthUtil.OMH_CLIENT_ID,\n                                            new OhmageService.CancelableCallback<AccessToken>() {\n                                                @Override\n                                                public void success(AccessToken accessToken,\n                                                        Response response) {\n                                                    ((AuthenticatorActivity) getActivity())\n                                                            .createAccount(user.email,\n                                                                    accessToken);\n                                                }\n\n                                                @Override public void failure(RetrofitError error) {\n                                                    ((AuthenticatorActivity) getActivity())\n                                                            .onRetrofitError(error);\n                                                }\n                                            });\n                                }\n                            });\n                        }\n\n                        @Override public void failure(RetrofitError error) {\n                            ((AuthenticatorActivity) getActivity()).onRetrofitError(error);\n                        }\n                    });\n        }\n    }\n\n    /**\n     * Set the default full name value\n     *\n     * @param fullName\n     */\n    public void setFullName(String fullName) {\n        if (!TextUtils.isEmpty(fullName))\n            mUser.fullName = fullName;\n    }\n\n    /**\n     * Check if we should show the ohmage account specific prompts\n     *\n     * @return true if we are creating an ohmage account\n     */\n    private boolean showOhmageAccountPrompts() {\n        return mGrantType == AuthUtil.GrantType.CLIENT_CREDENTIALS;\n    }\n\n    /**\n     * Set the grant type for this fragment\n     *\n     * @param grantType\n     */\n    public void setGrantType(AuthUtil.GrantType grantType) {\n        mGrantType = grantType;\n        setViewState(getView());\n    }\n\n    public void setEmail(String email) {\n        if (!TextUtils.isEmpty(email))\n            mUser.email = email;\n    }\n\n    public static interface Callbacks {\n        /**\n         * Called when the user clicks the create account button if we are performing an action\n         * which requires the calling activity to fetch the token. The parent activity must\n         * call {@link #createAccount(String)} with the token.\n         */\n        void fetchToken(UseToken useToken);\n\n        /**\n         * Called when the account is actually being created\n         */\n        void onCreateAccount();\n    }\n\n    public static interface UseToken {\n        /**\n         * A callback that the activity can use to send a token to this fragment\n         *\n         * @param token\n         */\n        void useToken(String token);\n    }\n}\nohmage/src/main/java/org/ohmage/sync/OhmageSyncAdapter.java\npublic class OhmageSyncAdapter extends AbstractThreadedSyncAdapter {\n\n    public static final String IS_SYNCADAPTER = \"is_syncadapter\";\n\n    private static final int NOTIFICATION_STREAM_APPS_ID = 0;\n    private static final int NOTIFICATION_REMOTE_APPS_ID = 1;\n\n    @Inject AccountManager am;\n\n    @Inject OhmageService ohmageService;\n\n    @Inject Gson gson;\n\n    private static final String TAG = OhmageSyncAdapter.class.getSimpleName();\n    private SyncResult mSyncResult;\n\n    /**\n     * Set up the sync adapter\n     */\n    public OhmageSyncAdapter(Context context, boolean autoInitialize) {\n        super(context, autoInitialize);\n        Ohmage.app().getApplicationGraph().inject(this);\n    }\n\n    /**\n     * Set up the sync adapter. This form of the\n     * constructor maintains compatibility with Android 3.0\n     * and later platform versions\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB)\n    public OhmageSyncAdapter(\n            Context context,\n            boolean autoInitialize,\n            boolean allowParallelSyncs) {\n        super(context, autoInitialize, allowParallelSyncs);\n        Ohmage.app().getApplicationGraph().inject(this);\n    }\n\n    @Override\n    public void onPerformSync(Account account, Bundle extras, String authority,\n            final ContentProviderClient provider, final SyncResult syncResult) {\n\n        mSyncResult = syncResult;\n\n        // Check for authtoken\n        String token = null;\n        try {\n            token = am.blockingGetAuthToken(account, AuthUtil.AUTHTOKEN_TYPE, true);\n        } catch (OperationCanceledException e) {\n            syncResult.stats.numSkippedEntries++;\n        } catch (IOException e) {\n            syncResult.stats.numIoExceptions++;\n        } catch (AuthenticatorException e) {\n            syncResult.stats.numAuthExceptions++;\n        }\n\n        // If the token wasn't found or there was a problem, we can stop now\n        if (token == null || syncResult.stats.numSkippedEntries > 0 ||\n            syncResult.stats.numIoExceptions > 0 || syncResult.stats.numAuthExceptions > 0) {\n            return;\n        }\n\n        String userId = am.getUserData(account, Authenticator.USER_ID);\n\n        try {\n            if (!Ohmage.USE_DSU_DATAPOINTS_API || userId != null) {\n                synchronizeOhmlets(userId, provider);\n                // TODO: download streams and surveys that are not part of ohmlets\n\n                // Don't continue if there were already errors\n                if (mSyncResult.stats.numIoExceptions > 0 ||\n                    mSyncResult.stats.numAuthExceptions > 0) {\n                    return;\n                }\n                synchronizeData(userId, provider);\n            } else {\n                downloadSurveys(provider);\n            }\n        } catch (AuthenticationException e) {\n            Log.e(TAG, \"Error authenticating user\", e);\n            syncResult.stats.numAuthExceptions++;\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Error synchronizing account\", e);\n            syncResult.stats.numIoExceptions++;\n        } catch (InterruptedException e) {\n            Log.e(TAG, \"Error synchronizing account\", e);\n            syncResult.stats.numIoExceptions++;\n        }\n    }\n\n    private void synchronizeOhmlets(final String userId, ContentProviderClient provider)\n            throws AuthenticationException, RemoteException, InterruptedException {\n        Log.d(TAG, \"state of ohmlets sync\");\n\n        final CountDownLatch upload;\n\n        // First, sync ohmlet join state. As described by the people field.\n        Cursor cursor = null;\n        try {\n            cursor = provider.query(OhmageContract.Ohmlets.CONTENT_URI,\n                    new String[]{\n                            OhmageContract.Ohmlets.OHMLET_ID,\n                            OhmageContract.Ohmlets.OHMLET_MEMBERS},\n                    Ohmlets.OHMLET_DIRTY + \"=1\", null, null\n            );\n\n            upload = new CountDownLatch(cursor.getCount());\n\n            while (cursor.moveToNext()) {\n                Member.List members = gson.fromJson(cursor.getString(1), Member.List.class);\n                Member m = members.getMember(userId);\n                if (m == null) {\n                    m = members.getMember(\"me\");\n                    if (m != null) {\n                        m.memberId = userId;\n                    }\n                }\n                final Member localMember = m;\n                ohmageService.getOhmlet(cursor.getString(0)).first(\n                        new Func1<Ohmlet, Boolean>() {\n                            @Override public Boolean call(Ohmlet ohmlet) {\n                                Member remoteMember = ohmlet.people.getMember(userId);\n                                try {\n                                    if (localMember != null) {\n                                        if (remoteMember == null ||\n                                            localMember.role != remoteMember.role) {\n                                            // Check for join verification code to send\n                                            if (localMember.code != null) {\n                                                String code = localMember.code;\n                                                localMember.code = null;\n                                                ohmageService.updateMemberForOhmlet(ohmlet.ohmletId,\n                                                        localMember, code);\n                                            } else {\n                                                ohmageService.updateMemberForOhmlet(ohmlet.ohmletId,\n                                                        localMember);\n                                            }\n                                        }\n                                    }\n                                    if (localMember == null && remoteMember != null) {\n                                        ohmageService.removeUserFromOhmlet(ohmlet.ohmletId, userId);\n                                    }\n                                } catch (AuthenticationException e) {\n                                    Log.e(TAG, \"Error authenticating user\", e);\n                                    mSyncResult.stats.numAuthExceptions++;\n                                } catch (RetrofitError e) {\n                                    Log.e(TAG, \"Error synchronizing ohmlet member state\", e);\n                                    mSyncResult.stats.numIoExceptions++;\n                                }\n                                return true;\n                            }\n                        }\n                ).finallyDo(new Action0() {\n                    @Override public void call() {\n                        upload.countDown();\n                    }\n                }).subscribe();\n            }\n            cursor.close();\n\n            // Wait for the upload sync operation to finish before downloading the user state\n            upload.await();\n\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n\n    private void downloadSurveys(ContentProviderClient provider)\n            throws AuthenticationException, RemoteException, InterruptedException {\n\n        final CountDownLatch download = new CountDownLatch(1);\n\n        Observable<List<Survey>> surveyList = ohmageService.getDefaultSurveys();\n\n        Observable<Survey> surveys = surveyList.flatMap(new Func1<List<Survey>, Observable<Survey>>() {\n            @Override public Observable<Survey> call(List<Survey> surveys) {\n                return Observable.from(surveys);\n            }\n        });\n\n        surveyList.subscribe(new SyncSubscriber<List<Survey>>(mSyncResult,\n                new ContentProviderStateSyncSubscriber(Surveys.CONTENT_URI, true)));\n\n        surveys.subscribe(\n                new SyncSubscriber<Survey>(mSyncResult, new ContentProviderSaverSubscriber(true)));\n\n        Observable.merge(surveyList, surveys).last()\n                .finallyDo(new Action0() {\n                    @Override public void call() {\n                        download.countDown();\n                    }\n                }).subscribe();\n\n        // Wait for any async download operations to finish\n        download.await();\n    }\n\n    private void synchronizeData(String userId, ContentProviderClient provider)\n            throws AuthenticationException, RemoteException, InterruptedException {\n\n        final CountDownLatch download = new CountDownLatch(1);\n\n        Observable<Ohmlet> current = ohmageService.getCurrentStateForUser(userId).flatMap(\n                new Func1<User, Observable<Ohmlet>>() {\n                    @Override\n                    public Observable<Ohmlet> call(User user) {\n                        return Observable.from(user.ohmlets);\n                    }\n                }\n        ).cache();\n\n        // Synchronize the current ohmlets to the db (this removes other ohmlets)\n        current.toList().subscribe(new SyncSubscriber<List<Ohmlet>>(mSyncResult,\n                new ContentProviderStateSyncSubscriber(Ohmlets.CONTENT_URI, true)));\n\n        Observable<Ohmlet> refreshedOhmlets = current.flatMap(new RefreshOhmlet());\n        refreshedOhmlets.subscribe(\n                new SyncSubscriber<Ohmlet>(mSyncResult, new ContentProviderSaverSubscriber(true)));\n\n\n        Observable<Survey> surveys = current.flatMap(new SurveysFromOhmlet());\n        surveys.toList().subscribe(new SyncSubscriber<List<Survey>>(mSyncResult,\n                new ContentProviderStateSyncSubscriber(Surveys.CONTENT_URI, true)));\n\n\n        Observable<Survey> refreshedSurveys =\n                surveys.filter(new FilterUpToDateSurveys(provider))\n                        .flatMap(new RefreshSurvey());\n        refreshedSurveys.subscribe(\n                new SyncSubscriber<Survey>(mSyncResult, new ContentProviderSaverSubscriber(true)));\n        refreshedSurveys.subscribe(new SyncSubscriber<Survey>(mSyncResult,\n                new Subscriber<Survey>() {\n                    public ApkSet surveys = new ApkSet();\n\n                    @Override public void onCompleted() {\n                        showInstallSurveyApkNotification(surveys);\n                    }\n\n                    @Override public void onError(Throwable e) {\n                        showInstallSurveyApkNotification(surveys);\n                    }\n\n                    @Override public void onNext(Survey survey) {\n                        for (Prompt prompt : survey.surveyItems) {\n                            if (prompt instanceof RemotePrompt &&\n                                ((RemotePrompt) prompt).getApp() != null &&\n                                !((RemotePrompt) prompt).getApp()\n                                        .isInstalled(getContext())) {\n                                surveys.add(((RemotePrompt) prompt).getApp());\n                                return;\n                            }\n                        }\n                    }\n                }\n        ));\n\n        Observable<Stream> streams = current.flatMap(new StreamsFromOhmlet());\n        streams.toList().subscribe(new SyncSubscriber<List<Stream>>(mSyncResult,\n                new ContentProviderStateSyncSubscriber(Streams.CONTENT_URI, true)));\n\n\n        Observable<Stream> refreshedStreams =\n                streams.filter(new FilterUpToDateStreams(provider)).flatMap(\n                        new RefreshStream());\n        refreshedStreams.subscribe(\n                new SyncSubscriber<Stream>(mSyncResult, new ContentProviderSaverSubscriber(true)));\n        refreshedStreams.subscribe(\n                new SyncSubscriber<Stream>(mSyncResult, new Subscriber<Stream>() {\n                    public ApkSet streams = new ApkSet();\n\n                    @Override public void onCompleted() {\n                        showInstallStreamApkNotification(streams);\n                    }\n\n                    @Override public void onError(Throwable e) {\n                        showInstallStreamApkNotification(streams);\n                    }\n\n                    @Override public void onNext(Stream stream) {\n                        if (!stream.app.isInstalled(getContext())) {\n                            stream.app.android.appName = stream.name;\n                            streams.add(stream.app);\n                        }\n                    }\n                })\n        );\n\n        Observable.merge(current, refreshedStreams, refreshedSurveys, refreshedOhmlets).last()\n                .finallyDo(new Action0() {\n                    @Override public void call() {\n                        download.countDown();\n                    }\n                }).subscribe();\n\n        // Wait for any async download operations to finish\n        download.await();\n    }\n\n    public void showInstallStreamApkNotification(ApkSet streams) {\n        if (streams == null || streams.isEmpty()) {\n            return;\n        }\n\n        Intent resultIntent = new Intent(getContext(), MainActivity.class);\n        resultIntent.putExtra(MainActivity.EXTRA_VIEW_STREAMS, true);\n        Builder builder = new Builder(getContext());\n\n        if (streams.size() > 1 && VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {\n            builder.setSmallIcon(R.drawable.stat_notify_update_collapse).setContentText(getContext()\n                    .getString(R.string.install_multiple_apps_for_stream_message, streams.size()));\n        } else {\n            builder.setSmallIcon(R.drawable.stat_notify_update).setContentText(getContext()\n                    .getString(R.string.install_app_for_stream_message,\n                            streams.iterator().next().getAppName()));\n        }\n\n        builder.setContentTitle(getContext().getString(R.string.install_apps_for_stream_title));\n        showInstallApkNotification(NOTIFICATION_STREAM_APPS_ID, builder, resultIntent);\n    }\n\n    public void showInstallSurveyApkNotification(ApkSet surveys) {\n        if (surveys == null || surveys.isEmpty()) {\n            return;\n        }\n\n        Intent resultIntent = new Intent(getContext(), InstallSurveyDependencies.class);\n        Builder builder = new Builder(getContext());\n\n        if (surveys.size() > 1 && VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {\n            builder.setSmallIcon(R.drawable.stat_notify_update_collapse).setContentText(getContext()\n                    .getString(R.string.install_multiple_apps_for_surveys_message, surveys.size()));\n        } else {\n            builder.setSmallIcon(R.drawable.stat_notify_update).setContentText(getContext()\n                    .getString(R.string.install_apps_for_survey_message,\n                            surveys.iterator().next().getAppName()));\n        }\n\n        builder.setContentTitle(getContext().getString(R.string.install_apps_for_survey_title));\n        showInstallApkNotification(NOTIFICATION_REMOTE_APPS_ID, builder, resultIntent);\n    }\n\n    private void showInstallApkNotification(int id, Builder builder, Intent intent) {\n        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        PendingIntent resultPendingIntent = PendingIntent.getActivity(getContext(), 0, intent,\n                PendingIntent.FLAG_UPDATE_CURRENT);\n        builder.setContentIntent(resultPendingIntent)\n                .setAutoCancel(true)\n                .setDefaults(Notification.DEFAULT_ALL);\n\n        NotificationManager mNotificationManager =\n                (NotificationManager) getContext().getSystemService(Context.NOTIFICATION_SERVICE);\n        mNotificationManager.notify(id, builder.build());\n    }\n\n    public static class SurveysFromOhmlet implements Func1<Ohmlet, Observable<Survey>> {\n        @Override public Observable<Survey> call(Ohmlet ohmlet) {\n            return Observable.from(ohmlet.surveys);\n        }\n    }\n\n    public static class StreamsFromOhmlet implements Func1<Ohmlet, Observable<Stream>> {\n        @Override public Observable<Stream> call(Ohmlet ohmlet) {\n            return Observable.from(ohmlet.streams);\n        }\n    }\n\n    public class RefreshStream implements Func1<Stream, Observable<Stream>> {\n        @Override public Observable<Stream> call(Stream stream) {\n            return ohmageService.getStream(stream.schemaId, stream.schemaVersion);\n        }\n    }\n\n    public class RefreshSurvey implements Func1<Survey, Observable<Survey>> {\n        @Override public Observable<Survey> call(Survey survey) {\n            return ohmageService.getSurvey(survey.schemaId.toString(), survey.schemaId.getVersion());\n        }\n    }\n\n    public class RefreshOhmlet implements Func1<Ohmlet, Observable<Ohmlet>> {\n        @Override public Observable<Ohmlet> call(Ohmlet ohmlet) {\n            return ohmageService.getOhmlet(ohmlet.ohmletId);\n        }\n    }\n\n    public static class FilterUpToDateSurveys implements Func1<Survey, Boolean> {\n\n        private final ContentProviderClient provider;\n\n        public FilterUpToDateSurveys(ContentProviderClient provider) {\n            this.provider = provider;\n        }\n\n        @Override public Boolean call(Survey survey) {\n            Cursor c = null;\n            try {\n                c = provider.query(\n                        Surveys.getUriForSurveyIdVersion(survey.schemaId),\n                        new String[]{Surveys.SURVEY_ID, Surveys.SURVEY_VERSION}, null, null, null);\n                if (c.moveToFirst()) {\n                    return !c.getString(0).equals(survey.schemaId) ||\n                           !c.getString(1).equals(survey.schemaId.getVersion());\n                }\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            } finally {\n                if(c != null) {\n                    c.close();\n                }\n            }\n            return true;\n        }\n    }\n\n    public static class FilterUpToDateStreams implements Func1<Stream, Boolean> {\n\n        private final ContentProviderClient provider;\n\n        public FilterUpToDateStreams(ContentProviderClient provider) {\n            this.provider = provider;\n        }\n\n        @Override public Boolean call(Stream stream) {\n            Cursor c = null;\n            try {\n                c = provider.query(\n                        Streams.getUriForStreamIdVersion(stream.schemaId, stream.schemaVersion),\n                        new String[]{Streams.STREAM_ID, Streams.STREAM_VERSION}, null, null, null);\n                if (c.moveToFirst()) {\n                    return !c.getString(0).equals(stream.schemaId) ||\n                           c.getInt(1) != stream.schemaVersion;\n                }\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            } finally {\n                if(c != null) {\n                    c.close();\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Same as the safe subscriber except it will log errors and continue running\n     *\n     * @param <T>\n     */\n    public static class SyncSubscriber<T> extends SafeSubscriber<T> {\n\n        private final SyncResult mSyncResult;\n\n        public SyncSubscriber(SyncResult syncResult, Subscriber<? super T> actual) {\n            super(actual);\n            mSyncResult = syncResult;\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            synchronized (mSyncResult) {\n                mSyncResult.stats.numIoExceptions++;\n            }\n        }\n    }\n\n\n    public static Uri appendSyncAdapterParam(Uri uri) {\n        return uri.buildUpon().appendQueryParameter(IS_SYNCADAPTER, \"true\").build();\n    }\n}\nohmage/src/main/java/org/ohmage/app/OhmletActivity.java\npublic class OhmletActivity extends InjectedActionBarActivity {\n\n    private static final String TAG = OhmletActivity.class.getSimpleName();\n    private View mLoadingView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_single_fragment);\n\n        mLoadingView = findViewById(R.id.loading);\n\n        String action = getIntent().getAction();\n        Bundle extras = new Bundle();\n        Uri data = getIntent().getData();\n        if (data.getScheme().equals(\"https\") || data.getScheme().equals(\"http\")) {\n            if (data.getPathSegments().size() > 3) {\n                if (data.getPathSegments().get(3).equals(\"invitation\")) {\n                    action = OhmletFragment.ACTION_JOIN;\n                }\n            }\n            extras.putString(OhmletFragment.EXTRA_OHMLET_INVITATION_ID,\n                    data.getQueryParameter(\"ohmlet_invitation_id\"));\n            extras.putString(AuthenticatorActivity.EXTRA_USER_INVITATION_CODE,\n                    data.getQueryParameter(\"user_invitation_id\"));\n            extras.putString(AuthenticatorActivity.EXTRA_EMAIL, data.getQueryParameter(\"email\"));\n            data = Ohmlets.getUriForOhmletId(data.getPathSegments().get(2));\n        }\n\n        if (savedInstanceState == null) {\n            getSupportFragmentManager().beginTransaction().add(R.id.container,\n                    OhmletFragment.getInstance(action, data, extras)).commit();\n        }\n    }\n\n    public void showLoadingView(boolean show) {\n        mLoadingView.setVisibility(show ? View.VISIBLE : View.GONE);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.ohmlet, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    /**\n     * A placeholder fragment containing a simple view.\n     */\n    public static class OhmletFragment extends InjectedFragment\n            implements Observer<Ohmlet>, OnClickListener, LoaderCallbacks<Cursor> {\n\n        public static final String EXTRA_OHMLET_INVITATION_ID = \"extra_ohmlet_invitation_id\";\n\n        /**\n         * Join an ohmlet\n         */\n        public static final String ACTION_JOIN = \"org.ohmage.action.JOIN\";\n\n        public static Fragment getInstance(String action, Uri uri, Bundle extras) {\n            OhmletFragment fragment = new OhmletFragment();\n            extras.putString(\"action\", action);\n            extras.putParcelable(\"uri\", uri);\n            fragment.setArguments(extras);\n            return fragment;\n        }\n\n        @Inject OhmageService ohmageService;\n\n        @Inject AccountManager am;\n\n        private TextView mDescription;\n\n        private Ohmlet mOhmlet;\n\n        private Subscription ohmletSupscription;\n\n        private Button mJoinButton;\n\n        private String userId;\n\n        private Uri uri;\n\n        private String ohmletId;\n\n        private String action;\n\n        private String invitationCode;\n\n        private JoinOhmletDialog mJoinDialog;\n\n        @Override public void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n\n            action = getArguments().getString(\"action\");\n            uri = getArguments().getParcelable(\"uri\");\n            invitationCode = getArguments().getString(EXTRA_OHMLET_INVITATION_ID);\n            ohmletId = uri.getLastPathSegment();\n        }\n\n        @Override public void onActivityCreated(Bundle savedInstanceState) {\n            super.onActivityCreated(savedInstanceState);\n\n            Account[] accounts = am.getAccountsByType(AuthUtil.ACCOUNT_TYPE);\n            if (accounts.length == 0) {\n                if (ACTION_JOIN.equals(action)) {\n                    Intent intent = new Intent(getActivity(), AuthenticatorActivity.class);\n                    Bundle extras = new Bundle(getArguments());\n                    extras.remove(\"uri\");\n                    extras.remove(\"action\");\n                    intent.putExtras(extras);\n                    intent.putExtra(AuthenticatorActivity.EXTRA_JOIN_OHMLET_ID, ohmletId);\n                    startActivity(intent);\n                }\n                getActivity().finish();\n                return;\n            }\n\n            userId = am.getUserData(accounts[0], Authenticator.USER_ID);\n\n            if (savedInstanceState == null) {\n                if (ACTION_JOIN.equals(action)) {\n                    mJoinDialog = (JoinOhmletDialog) getChildFragmentManager().findFragmentByTag(\"join_dialog\");\n                }\n            }\n\n            getLoaderManager().initLoader(0, null, this);\n        }\n\n        @Override public void onDestroy() {\n            super.onDestroy();\n            if (ohmletSupscription != null)\n                ohmletSupscription.unsubscribe();\n        }\n\n        @Override public void onCompleted() {\n            updateView();\n        }\n\n        @Override public void onError(Throwable e) {\n            //TODO: handle error correctly\n            Toast.makeText(getActivity(), \"error\", Toast.LENGTH_SHORT).show();\n            e.printStackTrace();\n        }\n\n        @Override public void onNext(Ohmlet ohmlet) {\n            setOhmlet(ohmlet);\n        }\n\n        @Override\n        public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                Bundle savedInstanceState) {\n            View rootView = inflater.inflate(R.layout.fragment_ohmlet, container, false);\n            assert rootView != null;\n\n            mDescription = (TextView) rootView.findViewById(R.id.description);\n            mDescription.setVisibility(View.GONE);\n            mJoinButton = (Button) rootView.findViewById(R.id.join);\n            mJoinButton.setVisibility(View.GONE);\n            mJoinButton.setOnClickListener(this);\n\n            if (mOhmlet != null)\n                updateView();\n\n            return rootView;\n        }\n\n        public void setOhmlet(Ohmlet ohmlet) {\n            mOhmlet = ohmlet;\n        }\n\n        public Ohmlet getOhmlet() {\n            return mOhmlet;\n        }\n\n        public String getUserId() {\n            return userId;\n        }\n\n        public String getInvitationCode() {\n            return invitationCode;\n        }\n\n        private void updateView() {\n            ((OhmletActivity) getActivity()).showLoadingView(false);\n            getActivity().setTitle(mOhmlet.name);\n\n            if (getView() != null) {\n                mDescription.setVisibility(View.VISIBLE);\n                mDescription.setText(mOhmlet.description);\n                mJoinButton.setVisibility(mOhmlet.isMember(userId) ? View.GONE : View.VISIBLE);\n            }\n        }\n\n        @Override public void onClick(View v) {\n            JoinOhmletDialog.getInstance().show(getChildFragmentManager(), \"join_dialog\");\n        }\n\n        @Override public Loader<Cursor> onCreateLoader(int i, Bundle bundle) {\n            return new CursorLoader(getActivity(), Ohmlets.getUriForOhmletId(ohmletId),\n                    Ohmlets.DEFAULT_PROJECTION, null, null, null);\n        }\n\n        @Override public void onLoadFinished(Loader<Cursor> cursorLoader, Cursor cursor) {\n            if (cursor.moveToFirst()) {\n                Ohmlet ohmlet = new Ohmlet();\n                new ContentProviderReader().read(ohmlet, cursor);\n                setOhmlet(ohmlet);\n                updateView();\n            } else {\n                // It is not in the db so go to the network\n                Observable<Ohmlet> ohmletObservable =\n                        ohmageService.getOhmlet(ohmletId).single().cache();\n\n                ohmletSupscription = AndroidObservable.fromFragment(this, ohmletObservable)\n                        .subscribe(this);\n            }\n        }\n\n        @Override public void onLoaderReset(Loader<Cursor> cursorLoader) {\n\n        }\n    }\n\n    public static class JoinOhmletDialog extends InjectedDialogFragment\n            implements DialogInterface.OnClickListener {\n\n        public static JoinOhmletDialog getInstance() {\n            return new JoinOhmletDialog();\n        }\n\n        @Override public Dialog onCreateDialog(Bundle savedInstanceState) {\n            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n            builder.setTitle(\"Join ohmlet?\")\n                    .setMessage(\"Are you sure you want to join this ohmlet?\")\n                    .setPositiveButton(R.string.join, this)\n                    .setNegativeButton(R.string.cancel, null);\n            return builder.create();\n        }\n\n        @Override public void onClick(DialogInterface dialog, int which) {\n\n            OhmletFragment parent = ((OhmletFragment) getParentFragment());\n\n            String userId = parent.getUserId();\n            Ohmlet ohmlet = parent.getOhmlet();\n            String id = TextUtils.isEmpty(userId) ? \"me\" : userId;\n\n            if (!ohmlet.isMember(id)) {\n                Member m = new Member();\n                m.memberId = id;\n                m.role = Role.MEMBER;\n                m.code = parent.getInvitationCode();\n                ohmlet.people.add(m);\n                ohmlet.dirty = true;\n\n                // Save the state of the ohmlet\n                Observable.from(ohmlet).subscribeOn(Schedulers.io()).doOnNext(\n                        new ContentProviderSaver()).doOnError(new Action1<Throwable>() {\n                    @Override public void call(Throwable throwable) {\n                        throwable.printStackTrace();\n                    }\n                }).subscribe();\n            }\n        }\n    }\n}\nohmage/src/androidTest/java/org/ohmage/auth/AuthenticatorTest.java\npublic class AuthenticatorTest extends InjectedAndroidTestCase {\n\n    @Inject AuthHelper fakeAuthHelper;\n    @Inject AccountManager fakeAccountManager;\n    @Inject OhmageService fakeOhmageService;\n\n    private Authenticator mAuthenticator;\n    private Context fakeContext;\n    private Account fakeAccount;\n    private static final String fakeGoogleEmail = \"fake@gmail.com\";\n    private static final String accessToken = \"token\";\n    private static final String refreshToken = \"refresh\";\n    private AccessToken token;\n    private static final String stubGoogleToken = \"google_token\";\n    private static final IOException ioe = new IOException();\n    private static final RetrofitError networkError = RetrofitError.networkError(\"\", ioe);\n    private static final RetrofitError serverError = RetrofitError.networkError(\"\", ioe);\n\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        fakeAccount = new Account(\"name\", AuthUtil.AUTHTOKEN_TYPE);\n        token = new AccessToken(accessToken, refreshToken, fakeAccount.name);\n\n        fakeContext = mock(Context.class);\n\n        mAuthenticator = new Authenticator(fakeContext);\n    }\n\n    public void testGetAuthToken_whenCached_returnsToken() throws Exception {\n        setAuthTokenCached(true);\n\n        Bundle bundle = mAuthenticator.getAuthToken(null, fakeAccount,\n                AuthUtil.AUTHTOKEN_TYPE, null);\n\n        verify(fakeAccountManager).peekAuthToken(fakeAccount, AuthUtil.AUTHTOKEN_TYPE);\n        verifyNoMoreInteractions(fakeAccountManager);\n        verifyTokenInBundle(bundle);\n    }\n\n    public void testGetAuthToken_whenNotCached_usesRefreshToken() throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenSuccess(refreshToken);\n\n        mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n\n        // Get the refresh password\n        verify(fakeAccountManager).getPassword(fakeAccount);\n        // Use the refresh password to get new tokens\n        verify(fakeOhmageService).getAccessToken(refreshToken);\n    }\n\n    public void testGetAuthToken_whenNotCached_savesNewRefreshToken() throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenSuccess(refreshToken);\n\n        mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n\n        // Saves the refresh token\n        verify(fakeAccountManager).setPassword(fakeAccount, refreshToken);\n    }\n\n    public void testGetAuthToken_whenUsingRefreshToken_returnsToken() throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenSuccess(refreshToken);\n\n        Bundle bundle = mAuthenticator.getAuthToken(null, fakeAccount,\n                AuthUtil.AUTHTOKEN_TYPE, null);\n        verifyTokenInBundle(bundle);\n    }\n\n    public void testGetAuthToken_noConnectionErrorUsingRefreshToken_throwsNetworkErrorException()\n            throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenFailure(refreshToken, networkError);\n\n        try {\n            mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n            fail(\"No Exception Thrown\");\n        } catch (Exception e) {\n            assertTrue(e instanceof NetworkErrorException);\n        }\n    }\n\n    public void testGetAuthToken_serverErrorUsingRefreshToken_throwsNetworkErrorException()\n            throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenFailure(refreshToken, serverError);\n\n        try {\n            mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n            fail(\"No Exception Thrown\");\n        } catch (Exception e) {\n            assertTrue(e instanceof NetworkErrorException);\n        }\n    }\n\n    public void testGetAuthToken_authErrorUsingRefreshToken_notifiesUser() throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenFailure(refreshToken, new AuthenticationException(\"\"));\n\n        Bundle data = mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n\n        verifyNotifyUserBundle(data);\n    }\n\n    public void testGetAuthToken_authErrorUsingRefreshTokenAndGoogleAccount_triesToGetGoogleAuth()\n            throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        when(fakeOhmageService.getAccessToken(refreshToken))\n                .thenThrow(new AuthenticationException(\"\")).thenReturn(token);\n        setHasGoogleAccount(true);\n        setGetGoogleAuthTokenResult(null);\n\n        mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n\n        verify(fakeAccountManager).getUserData(fakeAccount, Authenticator.USER_DATA_GOOGLE_ACCOUNT);\n        verify(fakeAuthHelper).googleAuthGetToken(fakeGoogleEmail);\n    }\n\n    public void testGetAuthToken_userRecoverableErrorWhenAuthtokenFromGoogle_sendsErrorViaIntent()\n            throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenFailure(refreshToken, new AuthenticationException(\"\"));\n        setHasGoogleAccount(true);\n        UserRecoverableAuthException fakeException = new UserRecoverableAuthException(\"msg\",\n                new Intent());\n        setGetGoogleAuthTokenResult(fakeException);\n\n\n        Bundle data = mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n\n        Intent intent = data.getParcelable(AccountManager.KEY_INTENT);\n        assertNotNull(intent);\n        assertEquals(intent.getComponent().getClassName(), AuthenticatorActivity.class.getName());\n        assertEquals(fakeException, intent\n                .getSerializableExtra(AuthenticatorActivity.EXTRA_HANDLE_USER_RECOVERABLE_ERROR));\n    }\n\n    public void testGetAuthToken_whenAuthWithGoogle_returnsToken() throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenFailure(refreshToken, new AuthenticationException(\"\"));\n        setHasGoogleAccount(true);\n        setGetGoogleAuthTokenResult(null);\n        setAccessTokenSuccess(AuthUtil.GrantType.GOOGLE_OAUTH2, stubGoogleToken);\n\n        Bundle data = mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n\n        verifyTokenInBundle(data);\n    }\n\n    public void testGetAuthToken_noConnectionErrorWhenAuthWithGoogle_throwsNetworkErrorException()\n            throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenFailure(refreshToken, new AuthenticationException(\"\"));\n        setHasGoogleAccount(true);\n        setGetGoogleAuthTokenResult(null);\n        setAccessTokenFailure(AuthUtil.GrantType.GOOGLE_OAUTH2, stubGoogleToken, networkError);\n\n        try {\n            mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n            fail(\"No Exception Thrown\");\n        } catch (Exception e) {\n            assertTrue(e instanceof NetworkErrorException);\n        }\n    }\n\n    public void testGetAuthToken_serverErrorWhenAuthWithGoogleToken_throwsNetworkException()\n            throws Exception {\n        setAuthTokenCached(false);\n        setAccountRefreshToken();\n        setAccessTokenFailure(refreshToken, new AuthenticationException(\"\"));\n        setHasGoogleAccount(true);\n        setGetGoogleAuthTokenResult(null);\n        setAccessTokenFailure(AuthUtil.GrantType.GOOGLE_OAUTH2, stubGoogleToken, serverError);\n\n        try {\n            mAuthenticator.getAuthToken(null, fakeAccount, AuthUtil.AUTHTOKEN_TYPE, null);\n            fail(\"No Exception Thrown\");\n        } catch (Exception e) {\n            assertTrue(e instanceof NetworkErrorException);\n        }\n    }\n\n    private void setAuthTokenCached(boolean cached) {\n        when(fakeAccountManager.peekAuthToken(fakeAccount, AuthUtil.AUTHTOKEN_TYPE))\n                .thenReturn(cached ? accessToken : null);\n    }\n\n    private void setAccountRefreshToken() {\n        when(fakeAccountManager.getPassword(fakeAccount)).thenReturn(refreshToken);\n    }\n\n    private void setAccessTokenSuccess(String refreshToken) throws Exception {\n        setAccessTokenResult(refreshToken, null);\n    }\n\n    private void setAccessTokenFailure(String refreshToken, Throwable error) throws Exception {\n        setAccessTokenResult(refreshToken, error);\n    }\n\n    private void setAccessTokenResult(String refreshToken, Throwable error) throws Exception {\n        OngoingStubbing<AccessToken> when = when(fakeOhmageService.getAccessToken(refreshToken));\n        if (error == null)\n            when.thenReturn(token);\n        else\n            when.thenThrow(error);\n    }\n\n    private void setAccessTokenSuccess(GrantType type, String token) throws Exception {\n        setAccessTokenResult(type, token, null);\n    }\n\n    private void setAccessTokenFailure(GrantType type, String token, Throwable error)\n            throws Exception {\n        setAccessTokenResult(type, token, error);\n    }\n\n    private void setAccessTokenResult(GrantType type, String t, Throwable error) throws Exception {\n        OngoingStubbing<AccessToken> when = when(fakeOhmageService.getAccessToken(type, t));\n        if (error == null)\n            when.thenReturn(token);\n        else\n            when.thenThrow(error);\n    }\n\n    private void setHasGoogleAccount(boolean hasAccount) {\n        when(fakeAccountManager.getUserData(fakeAccount, Authenticator.USER_DATA_GOOGLE_ACCOUNT))\n                .thenReturn(fakeGoogleEmail);\n    }\n\n    private void setGetGoogleAuthTokenResult(Exception e) throws Exception {\n        OngoingStubbing<String> stub = when(fakeAuthHelper.googleAuthGetToken(fakeGoogleEmail));\n        if (e == null) {\n            stub.thenReturn(stubGoogleToken);\n        } else {\n            stub.thenThrow(e);\n        }\n    }\n\n    private void verifyTokenInBundle(Bundle bundle) {\n        assertEquals(accessToken, bundle.getString(AccountManager.KEY_AUTHTOKEN));\n    }\n\n    private void verifyNotifyUserBundle(Bundle bundle) {\n        Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n        assertNotNull(intent);\n        assertEquals(intent.getComponent().getClassName(), AuthenticatorActivity.class.getName());\n        assertTrue(intent.getBooleanExtra(AuthenticatorActivity.EXTRA_FROM_AUTHENTICATOR, false));\n    }\n}\nohmage/src/main/java/org/ohmage/sync/ResponseSyncAdapter.java\npublic class ResponseSyncAdapter extends AbstractThreadedSyncAdapter {\n\n    public static final String IS_SYNCADAPTER = \"is_syncadapter\";\n\n    @Inject AccountManager am;\n\n    @Inject OhmageService ohmageService;\n\n    @Inject Gson gson;\n\n    private static final String TAG = ResponseSyncAdapter.class.getSimpleName();\n\n    /**\n     * Set up the sync adapter\n     */\n    public ResponseSyncAdapter(Context context, boolean autoInitialize) {\n        super(context, autoInitialize);\n        Ohmage.app().getApplicationGraph().inject(this);\n    }\n\n    /**\n     * Set up the sync adapter. This form of the\n     * constructor maintains compatibility with Android 3.0\n     * and later platform versions\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB)\n    public ResponseSyncAdapter(\n            Context context,\n            boolean autoInitialize,\n            boolean allowParallelSyncs) {\n        super(context, autoInitialize, allowParallelSyncs);\n        Ohmage.app().getApplicationGraph().inject(this);\n    }\n\n    @Override\n    public void onPerformSync(Account account, Bundle extras, String authority,\n            final ContentProviderClient provider, final SyncResult syncResult) {\n        // Check for authtoken\n        String token = null;\n        try {\n            token = am.blockingGetAuthToken(account, AuthUtil.AUTHTOKEN_TYPE, true);\n        } catch (OperationCanceledException e) {\n            syncResult.stats.numSkippedEntries++;\n        } catch (IOException e) {\n            syncResult.stats.numIoExceptions++;\n        } catch (AuthenticatorException e) {\n            syncResult.stats.numAuthExceptions++;\n        }\n\n        // If the token wasn't found or there was a problem, we can stop now\n        if (token == null || syncResult.stats.numSkippedEntries > 0 ||\n            syncResult.stats.numIoExceptions > 0 || syncResult.stats.numAuthExceptions > 0)\n            return;\n\n        // Upload responses\n        Observable<Long> toDelete = null;\n        Observable<ResponseFiles> filesToDelete = null;\n\n        Cursor cursor = null;\n\n        try {\n            cursor = provider.query(Responses.CONTENT_URI,\n                    new String[]{BaseColumns._ID, Responses.SURVEY_ID, Responses.SURVEY_VERSION,\n                            Responses.RESPONSE_DATA, Responses.RESPONSE_METADATA,\n                            Responses.RESPONSE_EXTRAS}, null, null, null);\n\n            while (cursor.moveToNext()) {\n                final ResponseFiles files = gson.fromJson(cursor.getString(5), ResponseFiles.class);\n                try {\n                    // Make the call to upload responses\n                    Observable<Response> uploadResponse = null;\n\n                    if(Ohmage.USE_DSU_DATAPOINTS_API) {\n                        uploadResponse = uploadDatapoint(cursor, files);\n                    } else {\n                        uploadOhmagePoint(cursor, files);\n                    }\n\n                    // Map the data for the upload response to the local id in the db\n                    final long localResponseId = cursor.getLong(0);\n                    Observable<Long> responseId = uploadResponse.map(new Func1<Response, Long>() {\n                        @Override public Long call(Response response) {\n                            return localResponseId;\n                        }\n                    });\n\n                    if(toDelete == null) {\n                        toDelete = responseId;\n                    } else {\n                        toDelete = Observable.mergeDelayError(responseId, toDelete);\n                    }\n\n                    // Map the data for the upload response to the files in the db\n                    Observable<ResponseFiles> responseFiles = uploadResponse.map(new Func1<Response, ResponseFiles>() {\n                        @Override public ResponseFiles call(Response response) {\n                            return files;\n                        }\n                    });\n\n                    if(filesToDelete == null) {\n                        filesToDelete = responseFiles;\n                    } else {\n                        filesToDelete = Observable.mergeDelayError(responseFiles, filesToDelete);\n                    }\n                } catch (AuthenticationException e) {\n                    Log.e(TAG, \"Auth\", e);\n                    syncResult.stats.numAuthExceptions++;\n                }\n            }\n            cursor.close();\n\n\n\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Remote\", e);\n            syncResult.stats.numIoExceptions++;\n        } finally {\n            if (cursor != null)\n                cursor.close();\n        }\n\n        if(toDelete != null) {\n            toDelete.flatMap(new Func1<Long, Observable<ContentProviderOperation>>() {\n                @Override public Observable<ContentProviderOperation> call(Long aLong) {\n                    return Observable.from(ContentProviderOperation.newDelete(appendSyncAdapterParam(\n                            ContentUris.withAppendedId(Responses.CONTENT_URI, aLong))).build());\n                }\n            }).subscribe(new Subscriber<ContentProviderOperation>() {\n                ArrayList<ContentProviderOperation> toDelete =\n                        new ArrayList<ContentProviderOperation>();\n\n                @Override public void onCompleted() {\n                    try {\n                        getContext().getContentResolver()\n                                .applyBatch(ResponseContract.CONTENT_AUTHORITY, toDelete);\n                    } catch (RemoteException e) {\n                        syncResult.stats.numIoExceptions++;\n                    } catch (OperationApplicationException e) {\n                        syncResult.stats.numIoExceptions++;\n                    }\n                    unsubscribe();\n                }\n\n                @Override public void onError(Throwable e) {\n                    // Delete the successful ones\n                    onCompleted();\n                }\n\n                @Override public void onNext(ContentProviderOperation args) {\n                    toDelete.add(args);\n                }\n            });\n        }\n\n        if(filesToDelete != null) {\n            filesToDelete.doOnNext(new Action1<ResponseFiles>() {\n                @Override public void call(ResponseFiles responseFiles) {\n                    for (String s : responseFiles.getIds()) {\n                        responseFiles.getFile(s).delete();\n                    }\n                }\n            }).subscribe(new Subscriber<ResponseFiles>() {\n                @Override public void onCompleted() {\n                    unsubscribe();\n                }\n\n                @Override public void onError(Throwable e) {\n\n                }\n\n                @Override public void onNext(ResponseFiles responseFiles) {\n\n                }\n            });\n        }\n    }\n\n    public static Uri appendSyncAdapterParam(Uri uri) {\n        return uri.buildUpon().appendQueryParameter(IS_SYNCADAPTER, \"true\").build();\n    }\n\n    private Observable<Response> uploadOhmagePoint(Cursor cursor, ResponseFiles files) throws AuthenticationException {\n        // Make the call to upload responses\n        return ohmageService.uploadResponse(cursor.getString(1), cursor.getLong(2),\n                new ResponseTypedOutput(cursor.getString(3),\n                        cursor.getString(4), files)).cache();\n\n    }\n\n    private Observable<Response> uploadDatapoint(Cursor cursor, ResponseFiles files) throws AuthenticationException {\n        OmhDataPointHeader header = new OmhDataPointHeader();\n        header.schemaId = new SchemaId(cursor.getString(1), cursor.getString(2));\n\n\n        JsonObject metadata =  new JsonParser().parse(cursor.getString(4)).getAsJsonObject();\n        header.creationDateTime = metadata.get(\"timestamp\").getAsString();\n        header.id = metadata.get(\"id\").getAsString();\n        Log.e(TAG, cursor.getString(3) + gson.toJson(header) + files.getIds().toString());\n        DataPointTypedOutput point = new DataPointTypedOutput(cursor.getString(3), gson.toJson(header), files);\n\n        // Make the call to upload responses\n        return ohmageService.uploadDataPoint(point).cache();\n    }\n}\n", "answers": ["                OhmletActivity.class,"], "length": 10623, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "5fe71bf0c2671adff4ef7a94a7ccbc1e3ac7392e1edfd213"}
{"input": "import abc\nimport binascii\nimport calendar\nimport copy\nimport hashlib\nimport os\nimport re\nimport six\nfrom datetime import datetime\nfrom cryptography.hazmat.primitives import constant_time\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom .fields import DSAPriv, DSAPub, DSASignature\nfrom .fields import ECDSAPub, ECDSAPriv, ECDSASignature\nfrom .fields import ECDHPub, ECDHPriv, ECDHCipherText\nfrom .fields import ElGCipherText, ElGPriv, ElGPub\nfrom .fields import OpaquePubKey\nfrom .fields import OpaquePrivKey\nfrom .fields import RSACipherText, RSAPriv, RSAPub, RSASignature\nfrom .fields import String2Key\nfrom .fields import SubPackets\nfrom .fields import UserAttributeSubPackets\nfrom .types import Packet\nfrom .types import Primary\nfrom .types import Private\nfrom .types import Public\nfrom .types import Sub\nfrom .types import VersionedPacket\nfrom ..constants import CompressionAlgorithm\nfrom ..constants import HashAlgorithm\nfrom ..constants import PubKeyAlgorithm\nfrom ..constants import SignatureType\nfrom ..constants import SymmetricKeyAlgorithm\nfrom ..constants import TrustFlags\nfrom ..constants import TrustLevel\nfrom ..decorators import sdproperty\nfrom ..errors import PGPDecryptionError\nfrom ..symenc import _decrypt\nfrom ..symenc import _encrypt\nfrom ..types import Fingerprint\n\n        checksum = self.bytes_to_int(m[:2])\n        del m[:2]\n\n        if not sum(symkey) % 65536 == checksum:  # pragma: no cover\n            raise PGPDecryptionError(\"{:s} decryption failed\".format(self.pkalg.name))\n\n        return (symalg, symkey)\n\n    def encrypt_sk(self, pk, symalg, symkey):\n        m = bytearray(self.int_to_bytes(symalg) + symkey)\n        m += self.int_to_bytes(sum(bytearray(symkey)) % 65536, 2)\n\n        if self.pkalg == PubKeyAlgorithm.RSAEncryptOrSign:\n            encrypter = pk.keymaterial.__pubkey__().encrypt\n            encargs = (bytes(m), padding.PKCS1v15(),)\n\n        elif self.pkalg == PubKeyAlgorithm.ECDH:\n            encrypter = pk\n            encargs = (bytes(m),)\n\n        else:\n            raise NotImplementedError(self.pkalg)\n\n        self.ct = self.ct.encrypt(encrypter, *encargs)\n        self.update_hlen()\n\n    def parse(self, packet):\n        super(PKESessionKeyV3, self).parse(packet)\n        self.encrypter = packet[:8]\n        del packet[:8]\n\n        self.pkalg = packet[0]\n        del packet[0]\n\n        if self.ct is not None:\n            self.ct.parse(packet)\n\n        else:  # pragma: no cover\n            del packet[:(self.header.length - 18)]\n\n\nclass Signature(VersionedPacket):\n    __typeid__ = 0x02\n    __ver__ = 0\n\n\nclass SignatureV4(Signature):\n    \"\"\"\n    5.2.3.  Version 4 Signature Packet Format\n\n    The body of a version 4 Signature packet contains:\n\n     - One-octet version number (4).\n\n     - One-octet signature type.\n\n     - One-octet public-key algorithm.\n\n     - One-octet hash algorithm.\n\n     - Two-octet scalar octet count for following hashed subpacket data.\n       Note that this is the length in octets of all of the hashed\n       subpackets; a pointer incremented by this number will skip over\n       the hashed subpackets.\n\n     - Hashed subpacket data set (zero or more subpackets).\n\n     - Two-octet scalar octet count for the following unhashed subpacket\n       data.  Note that this is the length in octets of all of the\n       unhashed subpackets; a pointer incremented by this number will\n       skip over the unhashed subpackets.\n\n     - Unhashed subpacket data set (zero or more subpackets).\n\n     - Two-octet field holding the left 16 bits of the signed hash\n       value.\n\n     - One or more multiprecision integers comprising the signature.\n       This portion is algorithm specific, as described above.\n\n    The concatenation of the data being signed and the signature data\n    from the version number through the hashed subpacket data (inclusive)\n    is hashed.  The resulting hash value is what is signed.  The left 16\n    bits of the hash are included in the Signature packet to provide a\n    quick test to reject some invalid signatures.\n\n    There are two fields consisting of Signature subpackets.  The first\n    field is hashed with the rest of the signature data, while the second\n    is unhashed.  The second set of subpackets is not cryptographically\n    protected by the signature and should include only advisory\n    information.\n\n    The algorithms for converting the hash function result to a signature\n    are described in a section below.\n    \"\"\"\n    __ver__ = 4\n\n    @sdproperty\n    def sigtype(self):\n        return self._sigtype\n\n    @sigtype.register(int)\n    @sigtype.register(SignatureType)\n    def sigtype_int(self, val):\n        self._sigtype = SignatureType(val)\n\n    @sdproperty\n    def pubalg(self):\n        return self._pubalg\n\n    @pubalg.register(int)\n    @pubalg.register(PubKeyAlgorithm)\n    def pubalg_int(self, val):\n        self._pubalg = PubKeyAlgorithm(val)\n\n        sigs = {PubKeyAlgorithm.RSAEncryptOrSign: RSASignature,\n                PubKeyAlgorithm.RSAEncrypt: RSASignature,\n                PubKeyAlgorithm.RSASign: RSASignature,\n                PubKeyAlgorithm.DSA: DSASignature,\n", "context": "src/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDSASignature(DSASignature):\n    def from_signer(self, sig):\n        seq, _ = decoder.decode(sig)\n        self.r = MPI(seq[0])\n        self.s = MPI(seq[1])\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ElGPriv(PrivKey, ElGPub):\n    __privfields__ = ('x', )\n\n    def __privkey__(self):\n        raise NotImplementedError()\n\n    def _generate(self, key_size):\n        raise NotImplementedError(PubKeyAlgorithm.ElGamal)\n\n    def parse(self, packet):\n        super(ElGPriv, self).parse(packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.x = MPI(packet)\n\n        else:\n            self.encbytes = packet\n\n        if self.s2k.usage in [0, 255]:\n            self.chksum = packet[:2]\n            del packet[:2]\n\n    def decrypt_keyblob(self, passphrase):\n        kb = super(ElGPriv, self).decrypt_keyblob(passphrase)\n        del passphrase\n\n        self.x = MPI(kb)\n\n        if self.s2k.usage in [254, 255]:\n            self.chksum = kb\n            del kb\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass UserAttributeSubPackets(SubPackets):\n    \"\"\"\n    This is nearly the same as just the unhashed subpackets from above,\n    except that there isn't a length specifier. So, parse will only parse one packet,\n    appending that one packet to self.__unhashed_sp.\n    \"\"\"\n    _spmodule = userattribute\n\n    def __bytearray__(self):\n        _bytes = bytearray()\n        for uhsp in self._unhashed_sp.values():\n            _bytes += uhsp.__bytearray__()\n        return _bytes\n\n    def __len__(self):  # pragma: no cover\n        return sum(len(sp) for sp in self._unhashed_sp.values())\n\n    def parse(self, packet):\n        # parse just one packet and add it to the unhashed subpacket ordereddict\n        # I actually have yet to come across a User Attribute packet with more than one subpacket\n        # which makes sense, given that there is only one defined subpacket\n        sp = UserAttribute(packet)\n        self[sp.__class__.__name__] = sp\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDHPriv(ECDSAPriv, ECDHPub):\n    def __bytearray__(self):\n        _b = ECDHPub.__bytearray__(self)\n        _b += self.s2k.__bytearray__()\n        if not self.s2k:\n            _b += self.s.to_mpibytes()\n\n            if self.s2k.usage == 0:\n                _b += self.chksum\n\n        else:\n            _b += self.encbytes\n\n        return _b\n\n    def __len__(self):\n        # because of the inheritance used for this, ECDSAPub.__len__ is called instead of ECDHPub.__len__\n        # the only real difference is self.kdf, so we can just add that\n        return super(ECDHPriv, self).__len__() + len(self.kdf)\n\n    def _generate(self, oid):\n        ECDSAPriv._generate(self, oid)\n        self.kdf.halg = self.oid.kdf_halg\n        self.kdf.encalg = self.oid.kek_alg\n\n    def publen(self):\n        return ECDHPub.__len__(self)\n\n    def parse(self, packet):\n        ECDHPub.parse(self, packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.s = MPI(packet)\n\n            if self.s2k.usage == 0:\n                self.chksum = packet[:2]\n                del packet[:2]\n\n        else:\n            ##TODO: this needs to be bounded to the length of the encrypted key material\n            self.encbytes = packet\nsrc/leap/mx/vendor/pgpy/constants.py\nclass CompressionAlgorithm(IntEnum):\n    #: No compression\n    Uncompressed = 0x00\n    #: ZIP DEFLATE\n    ZIP = 0x01\n    #: ZIP DEFLATE with zlib headers\n    ZLIB = 0x02\n    #: Bzip2\n    BZ2 = 0x03\n\n    def compress(self, data):\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.compress(data)[2:-4]\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.compress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.compress(data)\n\n        raise NotImplementedError(self)\n\n    def decompress(self, data):\n        if six.PY2:\n            data = bytes(data)\n\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.decompress(data, -15)\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.decompress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.decompress(data)\n\n        raise NotImplementedError(self)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass SignatureType(IntEnum):\n    BinaryDocument = 0x00\n    CanonicalDocument = 0x01\n    Standalone = 0x02\n    Generic_Cert = 0x10\n    Persona_Cert = 0x11\n    Casual_Cert = 0x12\n    Positive_Cert = 0x13\n    Subkey_Binding = 0x18\n    PrimaryKey_Binding = 0x19\n    DirectlyOnKey = 0x1F\n    KeyRevocation = 0x20\n    SubkeyRevocation = 0x28\n    CertRevocation = 0x30\n    Timestamp = 0x40\n    ThirdParty_Confirmation = 0x50\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDHCipherText(CipherText):\n    __mpis__ = ('vX', 'vY')\n\n    @classmethod\n    def encrypt(cls, pk, *args):\n        \"\"\"\n        For convenience, the synopsis of the encoding method is given below;\n        however, this section, [NIST-SP800-56A], and [RFC3394] are the\n        normative sources of the definition.\n\n            Obtain the authenticated recipient public key R\n            Generate an ephemeral key pair {v, V=vG}\n            Compute the shared point S = vR;\n            m = symm_alg_ID || session key || checksum || pkcs5_padding;\n            curve_OID_len = (byte)len(curve_OID);\n            Param = curve_OID_len || curve_OID || public_key_alg_ID || 03\n            || 01 || KDF_hash_ID || KEK_alg_ID for AESKeyWrap || \"Anonymous\n            Sender    \" || recipient_fingerprint;\n            Z_len = the key size for the KEK_alg_ID used with AESKeyWrap\n            Compute Z = KDF( S, Z_len, Param );\n            Compute C = AESKeyWrap( Z, m ) as per [RFC3394]\n            VB = convert point V to the octet string\n            Output (MPI(VB) || len(C) || C).\n\n        The decryption is the inverse of the method given.  Note that the\n        recipient obtains the shared secret by calculating\n        \"\"\"\n        # *args should be:\n        # - m\n        #\n        _m, = args\n\n        # m may need to be PKCS5-padded\n        padder = PKCS7(64).padder()\n        m = padder.update(_m) + padder.finalize()\n\n        km = pk.keymaterial\n\n        ct = cls()\n\n        # generate ephemeral key pair, then store it in ct\n        v = ec.generate_private_key(km.oid.curve(), default_backend())\n        ct.vX = MPI(v.public_key().public_numbers().x)\n        ct.vY = MPI(v.public_key().public_numbers().y)\n\n        # compute the shared point S\n        s = v.exchange(ec.ECDH(), km.__pubkey__())\n\n        # derive the wrapping key\n        z = km.kdf.derive_key(s, km.oid, PubKeyAlgorithm.ECDH, pk.fingerprint)\n\n        # compute C\n        ct.c = aes_key_wrap(z, m, default_backend())\n\n        return ct\n\n    def decrypt(self, pk, *args):\n        km = pk.keymaterial\n        # assemble the public component of ephemeral key v\n        v = ec.EllipticCurvePublicNumbers(self.vX, self.vY, km.oid.curve()).public_key(default_backend())\n\n        # compute s using the inverse of how it was derived during encryption\n        s = km.__privkey__().exchange(ec.ECDH(), v)\n\n        # derive the wrapping key\n        z = km.kdf.derive_key(s, km.oid, PubKeyAlgorithm.ECDH, pk.fingerprint)\n\n        # unwrap and unpad m\n        _m = aes_key_unwrap(z, self.c, default_backend())\n\n        padder = PKCS7(64).unpadder()\n        return padder.update(_m) + padder.finalize()\n\n    def __init__(self):\n        super(ECDHCipherText, self).__init__()\n        self.c = bytearray(0)\n\n    def __bytearray__(self):\n        _bytes = bytearray()\n        _xy = b'\\x04' + self.vX.to_mpibytes()[2:] + self.vY.to_mpibytes()[2:]\n        _bytes += MPI(self.bytes_to_int(_xy, 'big')).to_mpibytes()\n        _bytes.append(len(self.c))\n        _bytes += self.c\n\n        return _bytes\n\n    def parse(self, packet):\n        # self.v = MPI(packet)\n        xy = bytearray(MPI(packet).to_mpibytes()[2:])\n        del xy[:1]\n        xylen = len(xy)\n        x, y = xy[:xylen // 2], xy[xylen // 2:]\n        self.vX = MPI(self.bytes_to_int(x))\n        self.vY = MPI(self.bytes_to_int(y))\n\n        clen = packet[0]\n        del packet[0]\n\n        self.c += packet[:clen]\n        del packet[:clen]\nsrc/leap/mx/vendor/pgpy/constants.py\nclass TrustLevel(IntEnum):\n    Unknown = 0\n    Expired = 1\n    Undefined = 2\n    Never = 3\n    Marginal = 4\n    Fully = 5\n    Ultimate = 6\nsrc/leap/mx/vendor/pgpy/constants.py\nclass TrustFlags(FlagEnum):\n    Revoked = 0x20\n    SubRevoked = 0x40\n    Disabled = 0x80\n    PendingCheck = 0x100\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass DSASignature(Signature):\n    __mpis__ = ('r', 's')\n\n    def __sig__(self):\n        # return the signature data into an ASN.1 sequence of integers in DER format\n        seq = Sequence()\n        for i in self:\n            seq.setComponentByPosition(len(seq), Integer(i))\n\n        return encoder.encode(seq)\n\n    def from_signer(self, sig):\n        ##TODO: just use pyasn1 for this\n        def _der_intf(_asn):\n            if _asn[0] != 0x02:  # pragma: no cover\n                raise ValueError(\"Expected: Integer (0x02). Got: 0x{:02X}\".format(_asn[0]))\n            del _asn[0]\n\n            if _asn[0] & 0x80:  # pragma: no cover\n                llen = _asn[0] & 0x7F\n                del _asn[0]\n\n                flen = self.bytes_to_int(_asn[:llen])\n                del _asn[:llen]\n\n            else:\n                flen = _asn[0] & 0x7F\n                del _asn[0]\n\n            i = self.bytes_to_int(_asn[:flen])\n            del _asn[:flen]\n            return i\n\n        if isinstance(sig, bytes):\n            sig = bytearray(sig)\n\n        # this is a very limited asn1 decoder - it is only intended to decode a DER encoded sequence of integers\n        if not sig[0] == 0x30:\n            raise NotImplementedError(\"Expected: Sequence (0x30). Got: 0x{:02X}\".format(sig[0]))\n        del sig[0]\n\n        # skip the sequence length field\n        if sig[0] & 0x80:  # pragma: no cover\n            llen = sig[0] & 0x7F\n            del sig[:llen + 1]\n\n        else:\n            del sig[0]\n\n        self.r = MPI(_der_intf(sig))\n        self.s = MPI(_der_intf(sig))\n\n    def parse(self, packet):\n        self.r = MPI(packet)\n        self.s = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass DSAPub(PubKey):\n    __pubfields__ = ('p', 'q', 'g', 'y')\n\n    def __pubkey__(self):\n        params = dsa.DSAParameterNumbers(self.p, self.q, self.g)\n        return dsa.DSAPublicNumbers(self.y, params).public_key(default_backend())\n\n    def verify(self, subj, sigbytes, hash_alg):\n        verifier = self.__pubkey__().verifier(sigbytes, hash_alg)\n        verifier.update(subj)\n\n        try:\n            verifier.verify()\n\n        except InvalidSignature:\n            return False\n\n        return True\n\n    def parse(self, packet):\n        self.p = MPI(packet)\n        self.q = MPI(packet)\n        self.g = MPI(packet)\n        self.y = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDHPub(PubKey):\n    __pubfields__ = ('x', 'y')\n\n    def __init__(self):\n        super(ECDHPub, self).__init__()\n        self.oid = None\n        self.kdf = ECKDF()\n\n    def __len__(self):\n        return sum([len(getattr(self, i)) - 2 for i in self.__pubfields__] +\n                   [3,\n                    len(self.kdf),\n                    len(encoder.encode(self.oid.value)) - 1])\n\n    def __pubkey__(self):\n        return ec.EllipticCurvePublicNumbers(self.x, self.y, self.oid.curve()).public_key(default_backend())\n\n    def __bytearray__(self):\n        _b = bytearray()\n        _b += encoder.encode(self.oid.value)[1:]\n        # 0x04 || x || y\n        # where x and y are the same length\n        _xy = b'\\x04' + self.x.to_mpibytes()[2:] + self.y.to_mpibytes()[2:]\n        _b += MPI(self.bytes_to_int(_xy, 'big')).to_mpibytes()\n        _b += self.kdf.__bytearray__()\n\n        return _b\n\n    def __copy__(self):\n        pkt = super(ECDHPub, self).__copy__()\n        pkt.oid = self.oid\n        pkt.kdf = copy.copy(self.kdf)\n        return pkt\n\n    def parse(self, packet):\n        \"\"\"\n        Algorithm-Specific Fields for ECDH keys:\n\n          o  a variable-length field containing a curve OID, formatted\n             as follows:\n\n             -  a one-octet size of the following field; values 0 and\n                0xFF are reserved for future extensions\n\n             -  the octets representing a curve OID, defined in\n                Section 11\n\n             -  MPI of an EC point representing a public key\n\n          o  a variable-length field containing KDF parameters,\n             formatted as follows:\n\n             -  a one-octet size of the following fields; values 0 and\n                0xff are reserved for future extensions\n\n             -  a one-octet value 01, reserved for future extensions\n\n             -  a one-octet hash function ID used with a KDF\n\n             -  a one-octet algorithm ID for the symmetric algorithm\n                used to wrap the symmetric key used for the message\n                encryption; see Section 8 for details\n        \"\"\"\n        oidlen = packet[0]\n        del packet[0]\n        _oid = bytearray(b'\\x06')\n        _oid.append(oidlen)\n        _oid += bytearray(packet[:oidlen])\n        # try:\n        oid, _  = decoder.decode(bytes(_oid))\n\n        # except:\n        #     raise PGPError(\"Bad OID octet stream: b'{:s}'\".format(''.join(['\\\\x{:02X}'.format(c) for c in _oid])))\n        self.oid = EllipticCurveOID(oid)\n        del packet[:oidlen]\n\n        # flen = (self.oid.bit_length // 8)\n        xy = bytearray(MPI(packet).to_mpibytes()[2:])\n        # xy = bytearray(MPI(packet).to_bytes(flen, 'big'))\n        # the first byte is just \\x04\n        del xy[:1]\n        # now xy needs to be separated into x, y\n        xylen = len(xy)\n        x, y = xy[:xylen // 2], xy[xylen // 2:]\n        self.x = MPI(self.bytes_to_int(x))\n        self.y = MPI(self.bytes_to_int(y))\n\n        self.kdf.parse(packet)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ElGPub(PubKey):\n    __pubfields__ = ('p', 'g', 'y')\n\n    def __pubkey__(self):\n        raise NotImplementedError()\n\n    def parse(self, packet):\n        self.p = MPI(packet)\n        self.g = MPI(packet)\n        self.y = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Sub(Key):\n    pass\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass RSAPub(PubKey):\n    __pubfields__ = ('n', 'e')\n\n    def __pubkey__(self):\n        return rsa.RSAPublicNumbers(self.e, self.n).public_key(default_backend())\n\n    def verify(self, subj, sigbytes, hash_alg):\n        # zero-pad sigbytes if necessary\n        sigbytes = (b'\\x00' * (self.n.byte_length() - len(sigbytes))) + sigbytes\n        verifier = self.__pubkey__().verifier(sigbytes, padding.PKCS1v15(), hash_alg)\n        verifier.update(subj)\n\n        try:\n            verifier.verify()\n\n        except InvalidSignature:\n            return False\n\n        return True\n\n    def parse(self, packet):\n        self.n = MPI(packet)\n        self.e = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass RSACipherText(CipherText):\n    __mpis__ = ('me_mod_n', )\n\n    @classmethod\n    def encrypt(cls, encfn, *args):\n        ct = cls()\n        ct.me_mod_n = MPI(cls.bytes_to_int(encfn(*args)))\n        return ct\n\n    def decrypt(self, decfn, *args):\n        return decfn(*args)\n\n    def parse(self, packet):\n        self.me_mod_n = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Packet(Dispatchable):\n    __typeid__ = -1\n    __headercls__ = Header\n\n    def __init__(self):\n        super(Packet, self).__init__()\n        self.header = self.__headercls__()\n        if isinstance(self.__typeid__, six.integer_types):\n            self.header.tag = self.__typeid__\n\n    @abc.abstractmethod\n    def __bytearray__(self):\n        return self.header.__bytearray__()\n\n    def __len__(self):\n        return len(self.header) + self.header.length\n\n    def __repr__(self):\n        return \"<{cls:s} [tag 0x{tag:02d}] at 0x{id:x}>\".format(cls=self.__class__.__name__, tag=self.header.tag, id=id(self))\n\n    def update_hlen(self):\n        self.header.length = len(self.__bytearray__()) - len(self.header)\n\n    @abc.abstractmethod\n    def parse(self, packet):\n        if self.header.tag == 0:\n            self.header.parse(packet)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass PubKeyAlgorithm(IntEnum):\n    Invalid = 0x00\n    #: Signifies that a key is an RSA key.\n    RSAEncryptOrSign = 0x01\n    RSAEncrypt = 0x02  # deprecated\n    RSASign = 0x03     # deprecated\n    #: Signifies that a key is an ElGamal key.\n    ElGamal = 0x10\n    #: Signifies that a key is a DSA key.\n    DSA = 0x11\n    #: Signifies that a key is an ECDH key.\n    ECDH = 0x12\n    #: Signifies that a key is an ECDSA key.\n    ECDSA = 0x13\n    FormerlyElGamalEncryptOrSign = 0x14  # deprecated - do not generate\n    # DiffieHellman = 0x15  # X9.42\n\n    @property\n    def can_gen(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign,\n                        PubKeyAlgorithm.DSA,\n                        PubKeyAlgorithm.ECDSA,\n                        PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_encrypt(self):  # pragma: no cover\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.ElGamal, PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_sign(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.DSA, PubKeyAlgorithm.ECDSA}\n\n    @property\n    def deprecated(self):\n        return self in {PubKeyAlgorithm.RSAEncrypt,\n                        PubKeyAlgorithm.RSASign,\n                        PubKeyAlgorithm.FormerlyElGamalEncryptOrSign}\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDSAPub(PubKey):\n    __pubfields__ = ('x', 'y')\n\n    def __init__(self):\n        super(ECDSAPub, self).__init__()\n        self.oid = None\n\n    def __len__(self):\n        return sum([len(getattr(self, i)) - 2 for i in self.__pubfields__] +\n                   [3, len(encoder.encode(self.oid.value)) - 1])\n\n    def __pubkey__(self):\n        return ec.EllipticCurvePublicNumbers(self.x, self.y, self.oid.curve()).public_key(default_backend())\n\n    def __bytearray__(self):\n        _b = bytearray()\n        _b += encoder.encode(self.oid.value)[1:]\n        # 0x04 || x || y\n        # where x and y are the same length\n        _xy = b'\\x04' + self.x.to_mpibytes()[2:] + self.y.to_mpibytes()[2:]\n        _b += MPI(self.bytes_to_int(_xy, 'big')).to_mpibytes()\n\n        return _b\n\n    def __copy__(self):\n        pkt = super(ECDSAPub, self).__copy__()\n        pkt.oid = self.oid\n        return pkt\n\n    def verify(self, subj, sigbytes, hash_alg):\n        verifier = self.__pubkey__().verifier(sigbytes, ec.ECDSA(hash_alg))\n        verifier.update(subj)\n\n        try:\n            verifier.verify()\n\n        except InvalidSignature:\n            return False\n\n        return True\n\n    def parse(self, packet):\n        oidlen = packet[0]\n        del packet[0]\n        _oid = bytearray(b'\\x06')\n        _oid.append(oidlen)\n        _oid += bytearray(packet[:oidlen])\n        # try:\n        oid, _  = decoder.decode(bytes(_oid))\n\n        # except:\n        #     raise PGPError(\"Bad OID octet stream: b'{:s}'\".format(''.join(['\\\\x{:02X}'.format(c) for c in _oid])))\n        self.oid = EllipticCurveOID(oid)\n        del packet[:oidlen]\n\n        # flen = (self.oid.bit_length // 8)\n        xy = bytearray(MPI(packet).to_mpibytes()[2:])\n        # xy = bytearray(MPI(packet).to_bytes(flen, 'big'))\n        # the first byte is just \\x04\n        del xy[:1]\n        # now xy needs to be separated into x, y\n        xylen = len(xy)\n        x, y = xy[:xylen // 2], xy[xylen // 2:]\n        self.x = MPI(self.bytes_to_int(x))\n        self.y = MPI(self.bytes_to_int(y))\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass RSAPriv(PrivKey, RSAPub):\n    __privfields__ = ('d', 'p', 'q', 'u')\n\n    def __privkey__(self):\n        return rsa.RSAPrivateNumbers(self.p, self.q, self.d,\n                                     rsa.rsa_crt_dmp1(self.d, self.p),\n                                     rsa.rsa_crt_dmq1(self.d, self.q),\n                                     rsa.rsa_crt_iqmp(self.p, self.q),\n                                     rsa.RSAPublicNumbers(self.e, self.n)).private_key(default_backend())\n\n    def _generate(self, key_size):\n        if any(c != 0 for c in self):  # pragma: no cover\n            raise PGPError(\"key is already populated\")\n\n        # generate some big numbers!\n        pk = rsa.generate_private_key(65537, key_size, default_backend())\n        pkn = pk.private_numbers()\n\n        self.n = MPI(pkn.public_numbers.n)\n        self.e = MPI(pkn.public_numbers.e)\n        self.d = MPI(pkn.d)\n        self.p = MPI(pkn.p)\n        self.q = MPI(pkn.q)\n        # from the RFC:\n        # \"- MPI of u, the multiplicative inverse of p, mod q.\"\n        # or, simply, p^-1 mod p\n        # rsa.rsa_crt_iqmp(p, q) normally computes q^-1 mod p,\n        # so if we swap the values around we get the answer we want\n        self.u = MPI(rsa.rsa_crt_iqmp(pkn.q, pkn.p))\n\n        del pkn\n        del pk\n\n        self._compute_chksum()\n\n    def parse(self, packet):\n        super(RSAPriv, self).parse(packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.d = MPI(packet)\n            self.p = MPI(packet)\n            self.q = MPI(packet)\n            self.u = MPI(packet)\n\n            if self.s2k.usage == 0:\n                self.chksum = packet[:2]\n                del packet[:2]\n\n        else:\n            ##TODO: this needs to be bounded to the length of the encrypted key material\n            self.encbytes = packet\n\n    def decrypt_keyblob(self, passphrase):\n        kb = super(RSAPriv, self).decrypt_keyblob(passphrase)\n        del passphrase\n\n        self.d = MPI(kb)\n        self.p = MPI(kb)\n        self.q = MPI(kb)\n        self.u = MPI(kb)\n\n        if self.s2k.usage in [254, 255]:\n            self.chksum = kb\n            del kb\n\n    def sign(self, sigdata, hash_alg):\n        signer = self.__privkey__().signer(padding.PKCS1v15(), hash_alg)\n        signer.update(sigdata)\n        return signer.finalize()\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ECDSAPriv(PrivKey, ECDSAPub):\n    __privfields__ = ('s', )\n\n    def __privkey__(self):\n        ecp = ec.EllipticCurvePublicNumbers(self.x, self.y, self.oid.curve())\n        return ec.EllipticCurvePrivateNumbers(self.s, ecp).private_key(default_backend())\n\n    def _generate(self, oid):\n        if any(c != 0 for c in self):  # pragma: no cover\n            raise PGPError(\"Key is already populated!\")\n\n        self.oid = EllipticCurveOID(oid)\n\n        if not self.oid.can_gen:\n            raise ValueError(\"Curve not currently supported: {}\".format(oid.name))\n\n        pk = ec.generate_private_key(self.oid.curve(), default_backend())\n        pubn = pk.public_key().public_numbers()\n        self.x = MPI(pubn.x)\n        self.y = MPI(pubn.y)\n        self.s = MPI(pk.private_numbers().private_value)\n\n    def parse(self, packet):\n        super(ECDSAPriv, self).parse(packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.s = MPI(packet)\n\n            if self.s2k.usage == 0:\n                self.chksum = packet[:2]\n                del packet[:2]\n\n        else:\n            ##TODO: this needs to be bounded to the length of the encrypted key material\n            self.encbytes = packet\n\n    def decrypt_keyblob(self, passphrase):\n        kb = super(ECDSAPriv, self).decrypt_keyblob(passphrase)\n        del passphrase\n\n        self.s = MPI(kb)\n\n    def sign(self, sigdata, hash_alg):\n        signer = self.__privkey__().signer(ec.ECDSA(hash_alg))\n        signer.update(sigdata)\n        return signer.finalize()\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass String2Key(Field):\n    \"\"\"\n    3.7.  String-to-Key (S2K) Specifiers\n\n    String-to-key (S2K) specifiers are used to convert passphrase strings\n    into symmetric-key encryption/decryption keys.  They are used in two\n    places, currently: to encrypt the secret part of private keys in the\n    private keyring, and to convert passphrases to encryption keys for\n    symmetrically encrypted messages.\n\n    3.7.1.  String-to-Key (S2K) Specifier Types\n\n    There are three types of S2K specifiers currently supported, and\n    some reserved values:\n\n       ID          S2K Type\n       --          --------\n       0           Simple S2K\n       1           Salted S2K\n       2           Reserved value\n       3           Iterated and Salted S2K\n       100 to 110  Private/Experimental S2K\n\n    These are described in Sections 3.7.1.1 - 3.7.1.3.\n\n    3.7.1.1.  Simple S2K\n\n    This directly hashes the string to produce the key data.  See below\n    for how this hashing is done.\n\n       Octet 0:        0x00\n       Octet 1:        hash algorithm\n\n    Simple S2K hashes the passphrase to produce the session key.  The\n    manner in which this is done depends on the size of the session key\n    (which will depend on the cipher used) and the size of the hash\n    algorithm's output.  If the hash size is greater than the session key\n    size, the high-order (leftmost) octets of the hash are used as the\n    key.\n\n    If the hash size is less than the key size, multiple instances of the\n    hash context are created -- enough to produce the required key data.\n    These instances are preloaded with 0, 1, 2, ... octets of zeros (that\n    is to say, the first instance has no preloading, the second gets\n    preloaded with 1 octet of zero, the third is preloaded with two\n    octets of zeros, and so forth).\n\n    As the data is hashed, it is given independently to each hash\n    context.  Since the contexts have been initialized differently, they\n    will each produce different hash output.  Once the passphrase is\n    hashed, the output data from the multiple hashes is concatenated,\n    first hash leftmost, to produce the key data, with any excess octets\n    on the right discarded.\n\n    3.7.1.2.  Salted S2K\n\n    This includes a \"salt\" value in the S2K specifier -- some arbitrary\n    data -- that gets hashed along with the passphrase string, to help\n    prevent dictionary attacks.\n\n       Octet 0:        0x01\n       Octet 1:        hash algorithm\n       Octets 2-9:     8-octet salt value\n\n    Salted S2K is exactly like Simple S2K, except that the input to the\n    hash function(s) consists of the 8 octets of salt from the S2K\n    specifier, followed by the passphrase.\n\n    3.7.1.3.  Iterated and Salted S2K\n\n    This includes both a salt and an octet count.  The salt is combined\n    with the passphrase and the resulting value is hashed repeatedly.\n    This further increases the amount of work an attacker must do to try\n    dictionary attacks.\n\n       Octet  0:        0x03\n       Octet  1:        hash algorithm\n       Octets 2-9:      8-octet salt value\n       Octet  10:       count, a one-octet, coded value\n\n    The count is coded into a one-octet number using the following\n    formula:\n\n       #define EXPBIAS 6\n           count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);\n\n    The above formula is in C, where \"Int32\" is a type for a 32-bit\n    integer, and the variable \"c\" is the coded count, Octet 10.\n\n    Iterated-Salted S2K hashes the passphrase and salt data multiple\n    times.  The total number of octets to be hashed is specified in the\n    encoded count in the S2K specifier.  Note that the resulting count\n    value is an octet count of how many octets will be hashed, not an\n    iteration count.\n\n    Initially, one or more hash contexts are set up as with the other S2K\n    algorithms, depending on how many octets of key data are needed.\n    Then the salt, followed by the passphrase data, is repeatedly hashed\n    until the number of octets specified by the octet count has been\n    hashed.  The one exception is that if the octet count is less than\n    the size of the salt plus passphrase, the full salt plus passphrase\n    will be hashed even though that is greater than the octet count.\n    After the hashing is done, the data is unloaded from the hash\n    context(s) as with the other S2K algorithms.\n    \"\"\"\n    @sdproperty\n    def encalg(self):\n        return self._encalg\n\n    @encalg.register(int)\n    @encalg.register(SymmetricKeyAlgorithm)\n    def encalg_int(self, val):\n        self._encalg = SymmetricKeyAlgorithm(val)\n\n    @sdproperty\n    def specifier(self):\n        return self._specifier\n\n    @specifier.register(int)\n    @specifier.register(String2KeyType)\n    def specifier_int(self, val):\n        self._specifier = String2KeyType(val)\n\n    @sdproperty\n    def halg(self):\n        return self._halg\n\n    @halg.register(int)\n    @halg.register(HashAlgorithm)\n    def halg_int(self, val):\n        self._halg = HashAlgorithm(val)\n\n    @sdproperty\n    def count(self):\n        return (16 + (self._count & 15)) << ((self._count >> 4) + 6)\n\n    @count.register(int)\n    def count_int(self, val):\n        if val < 0 or val > 255:  # pragma: no cover\n            raise ValueError(\"count must be between 0 and 256\")\n        self._count = val\n\n    def __init__(self):\n        super(String2Key, self).__init__()\n        self.usage = 0\n        self.encalg = 0\n        self.specifier = 0\n        self.iv = None\n\n        # specifier-specific fields\n        # simple, salted, iterated\n        self.halg = 0\n\n        # salted, iterated\n        self.salt = bytearray()\n\n        # iterated\n        self.count = 0\n\n    def __bytearray__(self):\n        _bytes = bytearray()\n        _bytes.append(self.usage)\n        if bool(self):\n            _bytes.append(self.encalg)\n            _bytes.append(self.specifier)\n            if self.specifier >= String2KeyType.Simple:\n                _bytes.append(self.halg)\n            if self.specifier >= String2KeyType.Salted:\n                _bytes += self.salt\n            if self.specifier == String2KeyType.Iterated:\n                _bytes.append(self._count)\n            if self.iv is not None:\n                _bytes += self.iv\n        return _bytes\n\n    def __len__(self):\n        return len(self.__bytearray__())\n\n    def __bool__(self):\n        return self.usage in [254, 255]\n\n    def __nonzero__(self):\n        return self.__bool__()\n\n    def __copy__(self):\n        s2k = String2Key()\n        s2k.usage = self.usage\n        s2k.encalg = self.encalg\n        s2k.specifier = self.specifier\n        s2k.iv = self.iv\n        s2k.halg = self.halg\n        s2k.salt = copy.copy(self.salt)\n        s2k.count = self._count\n        return s2k\n\n    def parse(self, packet, iv=True):\n        self.usage = packet[0]\n        del packet[0]\n\n        if bool(self):\n            self.encalg = packet[0]\n            del packet[0]\n\n            self.specifier = packet[0]\n            del packet[0]\n\n            if self.specifier >= String2KeyType.Simple:\n                # this will always be true\n                self.halg = packet[0]\n                del packet[0]\n\n            if self.specifier >= String2KeyType.Salted:\n                self.salt = packet[:8]\n                del packet[:8]\n\n            if self.specifier == String2KeyType.Iterated:\n                self.count = packet[0]\n                del packet[0]\n\n            if iv:\n                self.iv = packet[:(self.encalg.block_size // 8)]\n                del packet[:(self.encalg.block_size // 8)]\n\n    def derive_key(self, passphrase):\n        ##TODO: raise an exception if self.usage is not 254 or 255\n        keylen = self.encalg.key_size\n        hashlen = self.halg.digest_size * 8\n\n        ctx = int(math.ceil((keylen / hashlen)))\n\n        # Simple S2K - always done\n        hsalt = b''\n        hpass = passphrase.encode('latin-1')\n\n        # salted, iterated S2K\n        if self.specifier >= String2KeyType.Salted:\n            hsalt = bytes(self.salt)\n\n        count = len(hsalt + hpass)\n        if self.specifier == String2KeyType.Iterated and self.count > len(hsalt + hpass):\n            count = self.count\n\n        hcount = (count // len(hsalt + hpass))\n        hleft = count - (hcount * len(hsalt + hpass))\n\n        hashdata = ((hsalt + hpass) * hcount) + (hsalt + hpass)[:hleft]\n\n        h = []\n        for i in range(0, ctx):\n            _h = self.halg.hasher\n            _h.update(b'\\x00' * i)\n            _h.update(hashdata)\n            h.append(_h)\n\n        # GC some stuff\n        del hsalt\n        del hpass\n        del hashdata\n\n        # and return the key!\n        return b''.join(hc.digest() for hc in h)[:(keylen // 8)]\nsrc/leap/mx/vendor/pgpy/symenc.py\ndef _encrypt(pt, key, alg, iv=None):\n    if iv is None:\n        iv = b'\\x00' * (alg.block_size // 8)\n\n    if alg.is_insecure:\n        raise PGPInsecureCipher(\"{:s} is not secure. Do not use it for encryption!\".format(alg.name))\n\n    if not callable(alg.cipher):\n        raise PGPEncryptionError(\"Cipher {:s} not supported\".format(alg.name))\n\n    try:\n        encryptor = Cipher(alg.cipher(key), modes.CFB(iv), default_backend()).encryptor()\n\n    except UnsupportedAlgorithm as ex:  # pragma: no cover\n        six.raise_from(PGPEncryptionError, ex)\n\n    else:\n        return bytearray(encryptor.update(pt) + encryptor.finalize())\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Private(Key):\n    pass\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Public(Key):\n    pass\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass ElGCipherText(CipherText):\n    __mpis__ = ('gk_mod_p', 'myk_mod_p')\n\n    @classmethod\n    def encrypt(cls, encfn, *args):\n        raise NotImplementedError()\n\n    def decrypt(self, decfn, *args):\n        raise NotImplementedError()\n\n    def parse(self, packet):\n        self.gk_mod_p = MPI(packet)\n        self.myk_mod_p = MPI(packet)\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass Primary(Key):\n    pass\nsrc/leap/mx/vendor/pgpy/constants.py\nclass HashAlgorithm(IntEnum):\n    Invalid = 0x00\n    MD5 = 0x01\n    SHA1 = 0x02\n    RIPEMD160 = 0x03\n    _reserved_1 = 0x04\n    _reserved_2 = 0x05\n    _reserved_3 = 0x06\n    _reserved_4 = 0x07\n    SHA256 = 0x08\n    SHA384 = 0x09\n    SHA512 = 0x0A\n    SHA224 = 0x0B\n\n    def __init__(self, *args):\n        super(self.__class__, self).__init__()\n        self._tuned_count = 0\n\n    @property\n    def hasher(self):\n        return hashlib.new(self.name)\n\n    @property\n    def digest_size(self):\n        return self.hasher.digest_size\n\n    @property\n    def tuned_count(self):\n        if self._tuned_count == 0:\n            self.tune_count()\n\n        return self._tuned_count\n\n    def tune_count(self):\n        start = end = 0\n        htd = _hashtunedata[:]\n\n        while start == end:\n            # potentially do this multiple times in case the resolution of time.time is low enough that\n            # hashing 100 KiB isn't enough time to produce a measurable difference\n            # (e.g. if the timer for time.time doesn't have enough precision)\n            htd = htd + htd\n            h = self.hasher\n\n            start = time.time()\n            h.update(htd)\n            end = time.time()\n\n        # now calculate how many bytes need to be hashed to reach our expected time period\n        # GnuPG tunes for about 100ms, so we'll do that as well\n        _TIME = 0.100\n        ct = int(len(htd) * (_TIME / (end - start)))\n        c1 = ((ct >> (ct.bit_length() - 5)) - 16)\n        c2 = (ct.bit_length() - 11)\n        c = ((c2 << 4) + c1)\n\n        # constrain self._tuned_count to be between 0 and 255\n        self._tuned_count = max(min(c, 255), 0)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass OpaquePubKey(PubKey):  # pragma: no cover\n    def __init__(self):\n        super(OpaquePubKey, self).__init__()\n        self.data = bytearray()\n\n    def __iter__(self):\n        yield self.data\n\n    def __pubkey__(self):\n        return NotImplemented\n\n    def __bytearray__(self):\n        return self.data\n\n    def parse(self, packet):\n        ##TODO: this needs to be length-bounded to the end of the packet\n        self.data = packet\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass DSAPriv(PrivKey, DSAPub):\n    __privfields__ = ('x',)\n\n    def __privkey__(self):\n        params = dsa.DSAParameterNumbers(self.p, self.q, self.g)\n        pn = dsa.DSAPublicNumbers(self.y, params)\n        return dsa.DSAPrivateNumbers(self.x, pn).private_key(default_backend())\n\n    def _generate(self, key_size):\n        if any(c != 0 for c in self):  # pragma: no cover\n            raise PGPError(\"key is already populated\")\n\n        # generate some big numbers!\n        pk = dsa.generate_private_key(key_size, default_backend())\n        pkn = pk.private_numbers()\n\n        self.p = MPI(pkn.public_numbers.parameter_numbers.p)\n        self.q = MPI(pkn.public_numbers.parameter_numbers.q)\n        self.g = MPI(pkn.public_numbers.parameter_numbers.g)\n        self.y = MPI(pkn.public_numbers.y)\n        self.x = MPI(pkn.x)\n\n        del pkn\n        del pk\n\n        self._compute_chksum()\n\n    def parse(self, packet):\n        super(DSAPriv, self).parse(packet)\n        self.s2k.parse(packet)\n\n        if not self.s2k:\n            self.x = MPI(packet)\n\n        else:\n            self.encbytes = packet\n\n        if self.s2k.usage in [0, 255]:\n            self.chksum = packet[:2]\n            del packet[:2]\n\n    def decrypt_keyblob(self, passphrase):\n        kb = super(DSAPriv, self).decrypt_keyblob(passphrase)\n        del passphrase\n\n        self.x = MPI(kb)\n\n        if self.s2k.usage in [254, 255]:\n            self.chksum = kb\n            del kb\n\n    def sign(self, sigdata, hash_alg):\n        signer = self.__privkey__().signer(hash_alg)\n        signer.update(sigdata)\n        return signer.finalize()\nsrc/leap/mx/vendor/pgpy/packet/types.py\nclass VersionedPacket(Packet):\n    __headercls__ = VersionedHeader\n\n    def __init__(self):\n        super(VersionedPacket, self).__init__()\n        if isinstance(self.__ver__, six.integer_types):\n            self.header.version = self.__ver__\n\n    def __repr__(self):\n        return \"<{cls:s} [tag 0x{tag:02d}][v{ver:d}] at 0x{id:x}>\".format(cls=self.__class__.__name__, tag=self.header.tag,\n                                                                          ver=self.header.version, id=id(self))\nsrc/leap/mx/vendor/pgpy/errors.py\nclass PGPDecryptionError(Exception):\n    \"\"\"Raised when decryption fails\"\"\"\n    pass\nsrc/leap/mx/vendor/pgpy/decorators.py\ndef sdproperty(fget):\n    def defset(obj, val):  # pragma: no cover\n        raise TypeError(str(val.__class__))\n\n    class SDProperty(property):\n        def register(self, cls=None, fset=None):\n            return self.fset.register(cls, fset)\n\n        def setter(self, fset):\n            self.register(object, fset)\n            return type(self)(self.fget, self.fset, self.fdel, self.__doc__)\n\n    return SDProperty(fget, sdmethod(defset))\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass RSASignature(Signature):\n    __mpis__ = ('md_mod_n', )\n\n    def __sig__(self):\n        return self.md_mod_n.to_mpibytes()[2:]\n\n    def parse(self, packet):\n        self.md_mod_n = MPI(packet)\n\n    def from_signer(self, sig):\n        self.md_mod_n = MPI(self.bytes_to_int(sig))\nsrc/leap/mx/vendor/pgpy/constants.py\nclass SymmetricKeyAlgorithm(IntEnum):\n    \"\"\"Supported symmetric key algorithms.\"\"\"\n    Plaintext = 0x00\n    #: .. warning::\n    #:     IDEA is insecure. PGPy only allows it to be used for decryption, not encryption!\n    IDEA = 0x01\n    #: Triple-DES with 168-bit key derived from 192\n    TripleDES = 0x02\n    #: CAST5 (or CAST-128) with 128-bit key\n    CAST5 = 0x03\n    #: Blowfish with 128-bit key and 16 rounds\n    Blowfish = 0x04\n    #: AES with 128-bit key\n    AES128 = 0x07\n    #: AES with 192-bit key\n    AES192 = 0x08\n    #: AES with 256-bit key\n    AES256 = 0x09\n    # Twofish with 256-bit key - not currently supported\n    Twofish256 = 0x0A\n    #: Camellia with 128-bit key\n    Camellia128 = 0x0B\n    #: Camellia with 192-bit key\n    Camellia192 = 0x0C\n    #: Camellia with 256-bit key\n    Camellia256 = 0x0D\n\n    @property\n    def cipher(self):\n        bs = {SymmetricKeyAlgorithm.IDEA: algorithms.IDEA,\n              SymmetricKeyAlgorithm.TripleDES: algorithms.TripleDES,\n              SymmetricKeyAlgorithm.CAST5: algorithms.CAST5,\n              SymmetricKeyAlgorithm.Blowfish: algorithms.Blowfish,\n              SymmetricKeyAlgorithm.AES128: algorithms.AES,\n              SymmetricKeyAlgorithm.AES192: algorithms.AES,\n              SymmetricKeyAlgorithm.AES256: algorithms.AES,\n              SymmetricKeyAlgorithm.Twofish256: namedtuple('Twofish256', ['block_size'])(block_size=128),\n              SymmetricKeyAlgorithm.Camellia128: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia192: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia256: algorithms.Camellia}\n\n        if self in bs:\n            return bs[self]\n\n        raise NotImplementedError(repr(self))\n\n    @property\n    def is_insecure(self):\n        insecure_ciphers = {SymmetricKeyAlgorithm.IDEA}\n        return self in insecure_ciphers\n\n    @property\n    def block_size(self):\n        return self.cipher.block_size\n\n    @property\n    def key_size(self):\n        ks = {SymmetricKeyAlgorithm.IDEA: 128,\n              SymmetricKeyAlgorithm.TripleDES: 192,\n              SymmetricKeyAlgorithm.CAST5: 128,\n              SymmetricKeyAlgorithm.Blowfish: 128,\n              SymmetricKeyAlgorithm.AES128: 128,\n              SymmetricKeyAlgorithm.AES192: 192,\n              SymmetricKeyAlgorithm.AES256: 256,\n              SymmetricKeyAlgorithm.Twofish256: 256,\n              SymmetricKeyAlgorithm.Camellia128: 128,\n              SymmetricKeyAlgorithm.Camellia192: 192,\n              SymmetricKeyAlgorithm.Camellia256: 256}\n\n        if self in ks:\n            return ks[self]\n\n        raise NotImplementedError(repr(self))\n\n    def gen_iv(self):\n        return os.urandom(self.block_size // 8)\n\n    def gen_key(self):\n        return os.urandom(self.key_size // 8)\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass OpaquePrivKey(PrivKey, OpaquePubKey):  # pragma: no cover\n    def __privkey__(self):\n        return NotImplemented\n\n    def _generate(self, key_size):\n        # return NotImplemented\n        raise NotImplementedError()\n\n    def decrypt_keyblob(self, passphrase):\n        return NotImplemented\nsrc/leap/mx/vendor/pgpy/types.py\nclass Fingerprint(str):\n    \"\"\"\n    A subclass of ``str``. Can be compared using == and != to ``str``, ``unicode``, and other :py:obj:`Fingerprint` instances.\n\n    Primarily used as a key for internal dictionaries, so it ignores spaces when comparing and hashing\n    \"\"\"\n    @property\n    def keyid(self):\n        return str(self).replace(' ', '')[-16:]\n\n    @property\n    def shortid(self):\n        return str(self).replace(' ', '')[-8:]\n\n    def __new__(cls, content):\n        if isinstance(content, Fingerprint):\n            return content\n\n        # validate input before continuing: this should be a string of 40 hex digits\n        content = content.upper().replace(' ', '')\n        if not bool(re.match(r'^[A-F0-9]{40}$', content)):\n            raise ValueError(\"Expected: String of 40 hex digits\")\n\n        # store in the format: \"AAAA BBBB CCCC DDDD EEEE  FFFF 0000 1111 2222 3333\"\n        #                                               ^^ note 2 spaces here\n        spaces = [ ' ' if i != 4 else '  ' for i in range(10) ]\n        chunks = [ ''.join(g) for g in six.moves.zip_longest(*[iter(content)] * 4) ]\n        content = ''.join(j for i in six.moves.zip_longest(chunks, spaces, fillvalue='') for j in i).strip()\n\n        return str.__new__(cls, content)\n\n    def __eq__(self, other):\n        if isinstance(other, Fingerprint):\n            return str(self) == str(other)\n\n        if isinstance(other, (six.text_type, bytes, bytearray)):\n            if isinstance(other, (bytes, bytearray)):  # pragma: no cover\n                other = other.decode('latin-1')\n\n            other = str(other).replace(' ', '')\n            return any([self.replace(' ', '') == other,\n                        self.keyid == other,\n                        self.shortid == other])\n\n        return False  # pragma: no cover\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __hash__(self):\n        return hash(str(self.replace(' ', '')))\n\n    def __bytes__(self):\n        return binascii.unhexlify(six.b(self.replace(' ', '')))\nsrc/leap/mx/vendor/pgpy/packet/fields.py\nclass SubPackets(collections.MutableMapping, Field):\n    _spmodule = signature\n\n    def __init__(self):\n        super(SubPackets, self).__init__()\n        self._hashed_sp = collections.OrderedDict()\n        self._unhashed_sp = collections.OrderedDict()\n\n    def __bytearray__(self):\n        _bytes = bytearray()\n        _bytes += self.__hashbytearray__()\n        _bytes += self.__unhashbytearray__()\n        return _bytes\n\n    def __hashbytearray__(self):\n        _bytes = bytearray()\n        _bytes += self.int_to_bytes(sum(len(sp) for sp in self._hashed_sp.values()), 2)\n        for hsp in self._hashed_sp.values():\n            _bytes += hsp.__bytearray__()\n        return _bytes\n\n    def __unhashbytearray__(self):\n        _bytes = bytearray()\n        _bytes += self.int_to_bytes(sum(len(sp) for sp in self._unhashed_sp.values()), 2)\n        for uhsp in self._unhashed_sp.values():\n            _bytes += uhsp.__bytearray__()\n        return _bytes\n\n    def __len__(self):  # pragma: no cover\n        return sum(sp.header.length for sp in itertools.chain(self._hashed_sp.values(), self._unhashed_sp.values())) + 4\n\n    def __iter__(self):\n        for sp in itertools.chain(self._hashed_sp.values(), self._unhashed_sp.values()):\n            yield sp\n\n    def __setitem__(self, key, val):\n        # the key provided should always be the classname for the subpacket\n        # but, there can be multiple subpackets of the same type\n        # so, it should be stored in the format: [h_]<key>_<seqid>\n        # where:\n        #  - <key> is the classname of val\n        #  - <seqid> is a sequence id, starting at 0, for a given classname\n\n        i = 0\n        if isinstance(key, tuple):  # pragma: no cover\n            key, i = key\n\n        d = self._unhashed_sp\n        if key.startswith('h_'):\n            d, key = self._hashed_sp, key[2:]\n\n        while (key, i) in d:\n            i += 1\n\n        d[(key, i)] = val\n\n    def __getitem__(self, key):\n        if isinstance(key, tuple):  # pragma: no cover\n            return self._hashed_sp.get(key, self._unhashed_sp.get(key))\n\n        if key.startswith('h_'):\n            return [v for k, v in self._hashed_sp.items() if key[2:] == k[0]]\n\n        else:\n            return [v for k, v in itertools.chain(self._hashed_sp.items(), self._unhashed_sp.items()) if key == k[0]]\n\n    def __delitem__(self, key):\n        ##TODO: this\n        raise NotImplementedError\n\n    def __contains__(self, key):\n        return key in set(k for k, _ in itertools.chain(self._hashed_sp, self._unhashed_sp))\n\n    def __copy__(self):\n        sp = SubPackets()\n        sp._hashed_sp = self._hashed_sp.copy()\n        sp._unhashed_sp = self._unhashed_sp.copy()\n\n        return sp\n\n    def addnew(self, spname, hashed=False, **kwargs):\n        nsp = getattr(self._spmodule, spname)()\n        for p, v in kwargs.items():\n            if hasattr(nsp, p):\n                setattr(nsp, p, v)\n        nsp.update_hlen()\n        if hashed:\n            self['h_' + spname] = nsp\n\n        else:\n            self[spname] = nsp\n\n    def update_hlen(self):\n        for sp in self:\n            sp.update_hlen()\n\n    def parse(self, packet):\n        hl = self.bytes_to_int(packet[:2])\n        del packet[:2]\n\n        # we do it this way because we can't ensure that subpacket headers are sized appropriately\n        # for their contents, but we can at least output that correctly\n        # so instead of tracking how many bytes we can now output, we track how many bytes have we parsed so far\n        plen = len(packet)\n        while plen - len(packet) < hl:\n            sp = SignatureSP(packet)\n            self['h_' + sp.__class__.__name__] = sp\n\n        uhl = self.bytes_to_int(packet[:2])\n        del packet[:2]\n\n        plen = len(packet)\n        while plen - len(packet) < uhl:\n            sp = SignatureSP(packet)\n            self[sp.__class__.__name__] = sp\nsrc/leap/mx/vendor/pgpy/symenc.py\ndef _decrypt(ct, key, alg, iv=None):\n    if iv is None:\n        \"\"\"\n        Instead of using an IV, OpenPGP prefixes a string of length\n        equal to the block size of the cipher plus two to the data before it\n        is encrypted. The first block-size octets (for example, 8 octets for\n        a 64-bit block length) are random, and the following two octets are\n        copies of the last two octets of the IV.\n        \"\"\"\n        iv = b'\\x00' * (alg.block_size // 8)\n\n    try:\n        decryptor = Cipher(alg.cipher(key), modes.CFB(iv), default_backend()).decryptor()\n\n    except UnsupportedAlgorithm as ex:  # pragma: no cover\n        six.raise_from(PGPDecryptionError, ex)\n\n    else:\n        return bytearray(decryptor.update(ct) + decryptor.finalize())\n", "answers": ["                PubKeyAlgorithm.ECDSA: ECDSASignature, }"], "length": 5424, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "477d6416677bcff0b880215deeb6d3f5f41a361f9bd341ae"}
{"input": "import math\nimport decimal\nimport operator\nfrom copy import copy\nfrom ..datatypes import AnyURI\nfrom ..exceptions import ElementPathKeyError, ElementPathTypeError\nfrom ..helpers import collapse_white_spaces\nfrom ..datatypes import AbstractDateTime, Duration, DayTimeDuration, \\\n    YearMonthDuration, NumericProxy, ArithmeticProxy\nfrom ..xpath_context import XPathSchemaContext\nfrom ..namespaces import XMLNS_NAMESPACE, XSD_NAMESPACE\nfrom ..schema_proxy import AbstractSchemaProxy\nfrom ..xpath_nodes import XPathNode, TypedElement, AttributeNode, TypedAttribute, \\\n    is_xpath_node, is_schema_node, is_document_node, is_element_node\nfrom .xpath1_parser import XPath1Parser\n        self.value = '{%s}%s' % (self[0].value, self[1].value)\n    return self\n\n\n@method('{')\ndef evaluate_namespace_uri(self, context=None):\n    if self[1].label.endswith('function'):\n        return self[1].evaluate(context)\n    return [x for x in self.select(context)]\n\n\n@method('{')\ndef select_namespace_uri(self, context=None):\n    if self[1].label.endswith('function'):\n        yield self[1].evaluate(context)\n        return\n    elif context is None:\n        raise self.missing_context()\n\n    if isinstance(context, XPathSchemaContext):\n        yield from self.select_xsd_nodes(context, self.value)\n\n    elif self.xsd_types is None:\n        for item in context.iter_children_or_self():\n            if context.match_name(self.value):\n                yield item\n    else:\n        # XSD typed selection\n        for item in context.iter_children_or_self():\n            if context.match_name(self.value):\n                if isinstance(item, (TypedAttribute, TypedElement)):\n                    yield item\n                else:\n                    context.item = self.get_typed_node(item)\n                    yield context.item\n\n\n###\n# Variables\n@method('$', bp=90)\ndef nud_variable_reference(self):\n    self.parser.expected_name('(name)')\n    self[:] = self.parser.expression(rbp=90),\n    if ':' in self[0].value:\n        raise self[0].wrong_syntax(\"variable reference requires a simple reference name\")\n    return self\n\n\n@method('$')\ndef evaluate_variable_reference(self, context=None):\n    if context is None:\n        raise self.missing_context()\n\n    try:\n        return context.variables[self[0].value]\n    except KeyError as err:\n        raise self.missing_name('unknown variable %r' % str(err)) from None\n\n\n###\n# Nullary operators (use only the context)\n@method(nullary('*'))\ndef select_wildcard(self, context=None):\n    if self:\n        # Product operator\n        item = self.evaluate(context)\n        if item is not None:\n            if context is not None:\n                context.item = item\n            yield item\n    elif context is None:\n        raise self.missing_context()\n\n    # Wildcard literal\n    elif isinstance(context, XPathSchemaContext):\n        for item in context.iter_children_or_self():\n            if item is not None:\n                self.add_xsd_type(item)\n                yield item\n\n    elif self.xsd_types is None:\n        for item in context.iter_children_or_self():\n            if item is None:\n                pass  # '*' wildcard doesn't match document nodes\n            elif context.axis == 'attribute':\n                if isinstance(item, (AttributeNode, TypedAttribute)):\n                    yield item\n            elif is_element_node(item):\n                yield item\n\n    else:\n        # XSD typed selection\n        for item in context.iter_children_or_self():\n            if context.item is not None and context.is_principal_node_kind():\n                if isinstance(item, (TypedAttribute, TypedElement)):\n                    yield item\n                else:\n                    context.item = self.get_typed_node(item)\n                    yield context.item\n\n\n@method(nullary('.'))\ndef select_self_shortcut(self, context=None):\n    if context is None:\n        raise self.missing_context()\n\n    elif isinstance(context, XPathSchemaContext):\n        for item in context.iter_self():\n            if is_schema_node(item):\n                self.add_xsd_type(item)\n            elif item is context.root:\n                # item is the schema\n                for xsd_element in item:\n                    self.add_xsd_type(xsd_element)\n            yield item\n\n    elif self.xsd_types is None:\n        for item in context.iter_self():\n            if item is not None:\n                yield item\n", "context": "elementpath/xpath_nodes.py\nclass TypedAttribute(XPathNode):\n    \"\"\"\n    A class for processing typed attribute nodes.\n\n    :param attribute: the origin AttributeNode instance.\n    :param xsd_type: the reference XSD type.\n    :param value: the types value.\n    \"\"\"\n    def __init__(self, attribute: AttributeNode, xsd_type: Any, value: Any) -> None:\n        self.attribute = attribute\n        self.xsd_type = xsd_type\n        self.value = value\n        self.parent = attribute.parent\n\n    @property\n    def kind(self) -> str:\n        return 'attribute'\n\n    @property\n    def name(self) -> str:\n        return self.attribute.name\n\n    def as_item(self) -> Tuple[str, Any]:\n        return self.attribute.name, self.value\n\n    def __repr__(self) -> str:\n        return '%s(name=%r)' % (self.__class__.__name__, self.attribute.name)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.attribute == other.attribute and \\\n            self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.attribute, self.value))\nelementpath/xpath_nodes.py\ndef is_document_node(obj: Any) -> bool:\n    return hasattr(obj, 'getroot') and hasattr(obj, 'parse') and hasattr(obj, 'iter')\nelementpath/helpers.py\ndef collapse_white_spaces(s: str) -> str:\n    return WHITESPACES_PATTERN.sub(' ', s).strip(' ')\nelementpath/xpath_nodes.py\ndef is_schema_node(obj: Any) -> bool:\n    return hasattr(obj, 'local_name') and hasattr(obj, 'type') and hasattr(obj, 'name')\nelementpath/xpath_nodes.py\nclass AttributeNode(XPathNode):\n    \"\"\"\n    A class for processing XPath attribute nodes.\n\n    :param name: the attribute name.\n    :param value: a string value or an XSD attribute when XPath is applied on a schema.\n    :param parent: the parent element.\n    \"\"\"\n    name: str\n\n    def __init__(self, name: str, value: Union[str, XsdAttributeProtocol],\n                 parent: Optional[ElementNode] = None) -> None:\n        self.name = name\n        self.value: Union[str, XsdAttributeProtocol] = value\n        self.parent = parent\n\n    @property\n    def kind(self) -> str:\n        return 'attribute'\n\n    def as_item(self) -> Tuple[str, Union[str, XsdAttributeProtocol]]:\n        return self.name, self.value\n\n    def __repr__(self) -> str:\n        if self.parent is not None:\n            return '%s(name=%r, value=%r, parent=%r)' % (\n                self.__class__.__name__, self.name, self.value, self.parent\n            )\n        return '%s(name=%r, value=%r)' % (self.__class__.__name__, self.name, self.value)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.name == other.name and \\\n            self.value == other.value and \\\n            self.parent is other.parent\n\n    def __hash__(self) -> int:\n        return hash((self.name, self.value, self.parent))\nelementpath/schema_proxy.py\nclass AbstractSchemaProxy(metaclass=ABCMeta):\n    \"\"\"\n    Abstract base class for defining schema proxies.\n\n    :param schema: a schema instance that implements the `AbstractEtreeElement` interface.\n    :param base_element: the schema element used as base item for static analysis.\n    \"\"\"\n    def __init__(self, schema: XMLSchemaProtocol,\n                 base_element: Optional[ElementProtocol] = None) -> None:\n        if not is_etree_element(schema):\n            raise ElementPathTypeError(\n                \"argument {!r} is not a compatible schema instance\".format(schema)\n            )\n        if base_element is not None and not is_etree_element(base_element):\n            raise ElementPathTypeError(\n                \"argument 'base_element' is not a compatible element instance\"\n            )\n\n        self._schema = schema\n        self._base_element: Optional[ElementProtocol] = base_element\n\n    def bind_parser(self, parser: XPathParserType) -> None:\n        \"\"\"\n        Binds a parser instance with schema proxy adding the schema's atomic types constructors.\n        This method can be redefined in a concrete proxy to optimize schema bindings.\n\n        :param parser: a parser instance.\n        \"\"\"\n        if parser.schema is not self:\n            parser.schema = self\n\n        parser.symbol_table = dict(parser.__class__.symbol_table)\n        for xsd_type in self.iter_atomic_types():\n            if xsd_type.name is not None:\n                parser.schema_constructor(xsd_type.name)\n        parser.tokenizer = parser.create_tokenizer(parser.symbol_table)\n\n    def get_context(self) -> XPathSchemaContext:\n        \"\"\"\n        Get a context instance for static analysis phase.\n\n        :returns: an `XPathSchemaContext` instance.\n        \"\"\"\n        return XPathSchemaContext(root=self._schema, item=self._base_element)\n\n    def find(self, path: str, namespaces: Optional[Dict[str, str]] = None) \\\n            -> Optional[XsdElementProtocol]:\n        \"\"\"\n        Find a schema element or attribute using an XPath expression.\n\n        :param path: an XPath expression that selects an element or an attribute node.\n        :param namespaces: an optional mapping from namespace prefix to namespace URI.\n        :return: The first matching schema component, or ``None`` if there is no match.\n        \"\"\"\n        return cast(Optional[XsdElementProtocol], self._schema.find(path, namespaces))\n\n    @property\n    def xsd_version(self) -> str:\n        \"\"\"The XSD version, returns '1.0' or '1.1'.\"\"\"\n        return self._schema.xsd_version\n\n    def get_type(self, qname: str) -> Optional[XsdTypeProtocol]:\n        \"\"\"\n        Get the XSD global type from the schema's scope. A concrete implementation must\n        return an object that supports the protocols `XsdTypeProtocol`, or `None` if\n        the global type is not found.\n\n        :param qname: the fully qualified name of the type to retrieve.\n        :returns: an object that represents an XSD type or `None`.\n        \"\"\"\n        return self._schema.maps.types.get(qname)\n\n    def get_attribute(self, qname: str) -> Optional[XsdAttributeProtocol]:\n        \"\"\"\n        Get the XSD global attribute from the schema's scope. A concrete implementation must\n        return an object that supports the protocol `XsdAttributeProtocol`, or `None` if\n        the global attribute is not found.\n\n        :param qname: the fully qualified name of the attribute to retrieve.\n        :returns: an object that represents an XSD attribute or `None`.\n        \"\"\"\n        return self._schema.maps.attributes.get(qname)\n\n    def get_element(self, qname: str) -> Optional[XsdElementProtocol]:\n        \"\"\"\n        Get the XSD global element from the schema's scope. A concrete implementation must\n        return an object that supports the protocol `XsdElementProtocol` interface, or\n        `None` if the global element is not found.\n\n        :param qname: the fully qualified name of the element to retrieve.\n        :returns: an object that represents an XSD element or `None`.\n        \"\"\"\n        return self._schema.maps.elements.get(qname)\n\n    def get_substitution_group(self, qname: str) -> Optional[List[XsdElementProtocol]]:\n        \"\"\"\n        Get a substitution group. A concrete implementation must returns a list containing\n        substitution elements or `None` if the substitution group is not found. Moreover each item\n        of the returned list must be an object that implements the `AbstractXsdElement` interface.\n\n        :param qname: the fully qualified name of the substitution group to retrieve.\n        :returns: a list containing substitution elements or `None`.\n        \"\"\"\n        return self._schema.maps.substitution_groups.get(qname)\n\n    @abstractmethod\n    def is_instance(self, obj: Any, type_qname: str) -> bool:\n        \"\"\"\n        Returns `True` if *obj* is an instance of the XSD global type, `False` if not.\n\n        :param obj: the instance to be tested.\n        :param type_qname: the fully qualified name of the type used to test the instance.\n        \"\"\"\n\n    @abstractmethod\n    def cast_as(self, obj: Any, type_qname: str) -> AtomicValueType:\n        \"\"\"\n        Converts *obj* to the Python type associated with an XSD global type. A concrete\n        implementation must raises a `ValueError` or `TypeError` in case of a decoding\n        error or a `KeyError` if the type is not bound to the schema's scope.\n\n        :param obj: the instance to be casted.\n        :param type_qname: the fully qualified name of the type used to convert the instance.\n        \"\"\"\n\n    @abstractmethod\n    def iter_atomic_types(self) -> Iterator[XsdTypeProtocol]:\n        \"\"\"\n        Returns an iterator for not builtin atomic types defined in the schema's scope. A concrete\n        implementation must yields objects that implement the protocol `XsdTypeProtocol`.\n        \"\"\"\n\n    @abstractmethod\n    def get_primitive_type(self, xsd_type: XsdTypeProtocol) -> XsdTypeProtocol:\n        \"\"\"\n        Returns the type at base of the definition of an XSD type. For an atomic type\n        is effectively the primitive type. For a list is the primitive type of the item.\n        For a union is the base union type. For a complex type is xs:anyType.\n\n        :param xsd_type: an XSD type instance.\n        :return: an XSD type instance.\n        \"\"\"\nelementpath/xpath1/xpath1_parser.py\nclass XPath1Parser(Parser[XPathToken]):\n    \"\"\"\n    XPath 1.0 expression parser class. Provide a *namespaces* dictionary argument for\n    mapping namespace prefixes to URI inside expressions. If *strict* is set to `False`\n    the parser enables also the parsing of QNames, like the ElementPath library.\n\n    :param namespaces: a dictionary with mapping from namespace prefixes into URIs.\n    :param strict: a strict mode is `False` the parser enables parsing of QNames \\\n    in extended format, like the Python's ElementPath library. Default is `True`.\n    \"\"\"\n    version = '1.0'\n    \"\"\"The XPath version string.\"\"\"\n\n    token_base_class = XPathToken\n    literals_pattern = re.compile(\n        r\"\"\"'(?:[^']|'')*'|\"(?:[^\"]|\"\")*\"|(?:\\d+|\\.\\d+)(?:\\.\\d*)?(?:[Ee][+-]?\\d+)?\"\"\"\n    )\n    name_pattern = re.compile(r'[^\\d\\W][\\w.\\-\\xb7\\u0300-\\u036F\\u203F\\u2040]*')\n\n    SYMBOLS: ClassVar[FrozenSet[str]] = Parser.SYMBOLS | {\n        # Axes\n        'descendant-or-self', 'following-sibling', 'preceding-sibling',\n        'ancestor-or-self', 'descendant', 'attribute', 'following',\n        'namespace', 'preceding', 'ancestor', 'parent', 'child', 'self',\n\n        # Operators\n        'and', 'mod', 'div', 'or', '..', '//', '!=', '<=', '>=', '(', ')', '[', ']',\n        ':', '.', '@', ',', '/', '|', '*', '-', '=', '+', '<', '>', '$', '::',\n\n        # Node test functions\n        'node', 'text', 'comment', 'processing-instruction',\n\n        # Node set functions\n        'last', 'position', 'count', 'id', 'name', 'local-name', 'namespace-uri',\n\n        # String functions\n        'string', 'concat', 'starts-with', 'contains',\n        'substring-before', 'substring-after', 'substring',\n        'string-length', 'normalize-space', 'translate',\n\n        # Boolean functions\n        'boolean', 'not', 'true', 'false', 'lang',\n\n        # Number functions\n        'number', 'sum', 'floor', 'ceiling', 'round',\n\n        # Symbols for ElementPath extensions\n        '{', '}'\n    }\n\n    DEFAULT_NAMESPACES: ClassVar[Dict[str, str]] = {'xml': XML_NAMESPACE}\n    \"\"\"\n    The default prefix-to-namespace associations of the XPath class. These namespaces\n    are updated in the instance with the ones passed with the *namespaces* argument.\n    \"\"\"\n\n    # Labels and symbols admitted after a path step\n    PATH_STEP_LABELS: ClassVar[Tuple[str, ...]] = ('axis', 'kind test')\n    PATH_STEP_SYMBOLS: ClassVar[Set[str]] = {\n        '(integer)', '(string)', '(float)', '(decimal)', '(name)', '*', '@', '..', '.', '{'\n    }\n\n    # Class attributes for compatibility with XPath 2.0+\n    schema: Optional[AbstractSchemaProxy] = None\n    variable_types: Optional[Dict[str, str]] = None\n    base_uri: Optional[str] = None\n    function_namespace = XPATH_FUNCTIONS_NAMESPACE\n    function_signatures: Dict[Tuple[QName, int], str] = {}\n\n    RESERVED_FUNCTION_NAMES = {\n        'comment', 'element', 'node', 'processing-instruction', 'text'\n    }\n\n    def __init__(self, namespaces: Optional[NamespacesType] = None, strict: bool = True,\n                 *args: Any, **kwargs: Any) -> None:\n        super(XPath1Parser, self).__init__()\n        self.namespaces: Dict[str, str] = self.DEFAULT_NAMESPACES.copy()\n        if namespaces is not None:\n            self.namespaces.update(namespaces)\n        self.strict: bool = strict\n\n    @property\n    def compatibility_mode(self) -> bool:\n        \"\"\"XPath 1.0 compatibility mode.\"\"\"\n        return True\n\n    @property\n    def default_namespace(self) -> Optional[str]:\n        \"\"\"\n        The default namespace. For XPath 1.0 this value is always `None` because the default\n        namespace is ignored (see https://www.w3.org/TR/1999/REC-xpath-19991116/#node-tests).\n        \"\"\"\n        return None\n\n    @property\n    def other_namespaces(self) -> Dict[str, str]:\n        \"\"\"The subset of namespaces not provided by default.\"\"\"\n        return {k: v for k, v in self.namespaces.items() if k not in self.DEFAULT_NAMESPACES}\n\n    @property\n    def xsd_version(self) -> str:\n        return '1.0'  # Use XSD 1.0 datatypes for default\n\n    def xsd_qname(self, local_name: str) -> str:\n        \"\"\"Returns a prefixed QName string for XSD namespace.\"\"\"\n        if self.namespaces.get('xs') == XSD_NAMESPACE:\n            return 'xs:%s' % local_name\n\n        for pfx, uri in self.namespaces.items():\n            if uri == XSD_NAMESPACE:\n                return '%s:%s' % (pfx, local_name) if pfx else local_name\n\n        raise xpath_error('XPST0081', 'Missing XSD namespace registration')\n\n    @staticmethod\n    def unescape(string_literal: str) -> str:\n        if string_literal.startswith(\"'\"):\n            return string_literal[1:-1].replace(\"''\", \"'\")\n        else:\n            return string_literal[1:-1].replace('\"\"', '\"')\n\n    @classmethod\n    def axis(cls, symbol: str, reverse_axis: bool = False, bp: int = 80) -> Type[XPathAxis]:\n        \"\"\"Register a token for a symbol that represents an XPath *axis*.\"\"\"\n        token_class = cls.register(symbol, label='axis', bases=(XPathAxis,),\n                                   reverse_axis=reverse_axis, lbp=bp, rbp=bp)\n        return cast(Type[XPathAxis], token_class)\n\n    @classmethod\n    def function(cls, symbol: str,\n                 nargs: NargsType = None,\n                 sequence_types: Tuple[str, ...] = (),\n                 label: str = 'function',\n                 bp: int = 90) -> Type[XPathFunction]:\n        \"\"\"\n        Registers a token class for a symbol that represents an XPath function.\n        \"\"\"\n        if 'function' not in label:\n            pass  # kind test or sequence type\n        elif symbol in cls.RESERVED_FUNCTION_NAMES:\n            raise ElementPathValueError(f'{symbol!r} is a reserved function name')\n        elif sequence_types:\n            # Register function signature(s)\n            if label == 'math function':\n                qname = QName(XPATH_MATH_FUNCTIONS_NAMESPACE, 'math:%s' % symbol)\n            else:\n                qname = QName(XPATH_FUNCTIONS_NAMESPACE, 'fn:%s' % symbol)\n\n            if nargs is None:\n                pass  # pragma: no cover\n            elif isinstance(nargs, int):\n                assert len(sequence_types) == nargs + 1\n                cls.function_signatures[(qname, nargs)] = 'function({}) as {}'.format(\n                    ', '.join(sequence_types[:-1]), sequence_types[-1]\n                )\n            elif nargs[1] is None:\n                assert len(sequence_types) == nargs[0] + 1\n                cls.function_signatures[(qname, nargs[0])] = 'function({}, ...) as {}'.format(\n                    ', '.join(sequence_types[:-1]), sequence_types[-1]\n                )\n            else:\n                assert len(sequence_types) == nargs[1] + 1\n                for arity in range(nargs[0], nargs[1] + 1):\n                    cls.function_signatures[(qname, arity)] = 'function({}) as {}'.format(\n                        ', '.join(sequence_types[:arity]), sequence_types[-1]\n                    )\n\n        token_class = cls.register(symbol, nargs=nargs, sequence_types=sequence_types,\n                                   label=label, bases=(XPathFunction,), lbp=bp, rbp=bp)\n        return cast(Type[XPathFunction], token_class)\n\n    def parse(self, source: str) -> XPathToken:\n        root_token = super(XPath1Parser, self).parse(source)\n        try:\n            root_token.evaluate()  # Static context evaluation\n        except MissingContextError:\n            pass\n        return root_token\n\n    def expected_name(self, *symbols: str, message: Optional[str] = None) -> None:\n        \"\"\"\n        Checks the next symbol with a list of symbols. Replaces the next token\n        with a '(name)' token if check fails and the symbol can be also a name.\n        Otherwise raises a syntax error.\n\n        :param symbols: a sequence of symbols.\n        :param message: optional error message.\n        \"\"\"\n        if self.next_token.symbol in symbols:\n            return\n        elif self.next_token.label in ('operator', 'symbol', 'let expression') and \\\n                self.name_pattern.match(self.next_token.symbol) is not None:\n            token_class = self.symbol_table['(name)']\n            self.next_token = token_class(self, self.next_token.symbol)\n        else:\n            raise self.next_token.wrong_syntax(message)\n\n    ###\n    # Type checking (used in XPath 2.0)\n    def is_instance(self, obj: Any, type_qname: str) -> bool:\n        \"\"\"Checks an instance against an XSD type.\"\"\"\n        if get_namespace(type_qname) == XSD_NAMESPACE:\n            if type_qname == XSD_ERROR:\n                return obj is None or obj == []\n            elif type_qname == XSD_UNTYPED_ATOMIC:\n                return isinstance(obj, UntypedAtomic)\n            elif type_qname == XSD_ANY_ATOMIC_TYPE:\n                return isinstance(obj, AnyAtomicType)\n            elif type_qname == XSD_ANY_SIMPLE_TYPE:\n                return isinstance(obj, AnyAtomicType) or \\\n                    isinstance(obj, list) and \\\n                    all(isinstance(x, AnyAtomicType) for x in obj)\n\n            try:\n                if self.xsd_version == '1.1':\n                    return isinstance(obj, xsd11_atomic_types[type_qname])\n                return isinstance(obj, xsd10_atomic_types[type_qname])\n            except KeyError:\n                pass\n\n        if self.schema is not None:\n            try:\n                return self.schema.is_instance(obj, type_qname)\n            except KeyError:\n                pass\n\n        raise ElementPathKeyError(\"unknown type %r\" % type_qname)\n\n    def is_sequence_type(self, value: str) -> bool:\n        \"\"\"Checks if a string is a sequence type specification.\"\"\"\n        try:\n            value = normalize_sequence_type(value)\n        except TypeError:\n            return False\n\n        if not value:\n            return False\n        elif value == 'empty-sequence()' or value == 'none':\n            return True\n        elif value[-1] in OCCURRENCE_INDICATORS:\n            value = value[:-1]\n\n        if value in COMMON_SEQUENCE_TYPES:\n            return True\n\n        elif value.startswith('element(') and value.endswith(')'):\n            if ',' not in value:\n                return EQNAME_PATTERN.match(value[8:-1]) is not None\n\n            try:\n                arg1, arg2 = value[8:-1].split(', ')\n            except ValueError:\n                return False\n            else:\n                return (arg1 == '*' or EQNAME_PATTERN.match(arg1) is not None) \\\n                    and EQNAME_PATTERN.match(arg2) is not None\n\n        elif value.startswith('document-node(') and value.endswith(')'):\n            if not value.startswith('document-node(element('):\n                return False\n            return self.is_sequence_type(value[14:-1])\n\n        elif value.startswith('function('):\n            if self.version >= '3.0':\n                if value == 'function(*)':\n                    return True\n                elif ' as ' in value:\n                    pass\n                elif not value.endswith(')'):\n                    return False\n                else:\n                    return self.is_sequence_type(value[9:-1])\n\n            try:\n                value, return_type = value.rsplit(' as ', 1)\n            except ValueError:\n                return False\n            else:\n                if not self.is_sequence_type(return_type):\n                    return False\n                elif value == 'function()':\n                    return True\n\n                value = value[9:-1]\n                if value.endswith(', ...'):\n                    value = value[:-5]\n\n                if 'function(' not in value:\n                    return all(self.is_sequence_type(x) for x in value.split(', '))\n\n                # Cover only if function() spec is the last argument\n                k = value.index('function(')\n                if not self.is_sequence_type(value[k:]):\n                    return False\n                return all(self.is_sequence_type(x) for x in value[:k].split(', ') if x)\n\n        elif QName.pattern.match(value) is None:\n            return False\n\n        try:\n            type_qname = get_expanded_name(value, self.namespaces)\n            self.is_instance(None, type_qname)\n        except (KeyError, ValueError):\n            return False\n        else:\n            return True\n\n    def get_atomic_value(self, type_or_name: Union[str, XsdTypeProtocol]) -> AtomicValueType:\n        \"\"\"Gets an atomic value for an XSD type instance or name. Used for schema contexts.\"\"\"\n        expanded_name: Optional[str]\n\n        if isinstance(type_or_name, str):\n            expanded_name = get_expanded_name(type_or_name, self.namespaces)\n            xsd_type = None\n        else:\n            xsd_type = type_or_name\n            expanded_name = xsd_type.name\n\n        if expanded_name:\n            uri, local_name = split_expanded_name(expanded_name)\n            if uri == XSD_NAMESPACE:\n                try:\n                    return ATOMIC_VALUES[local_name]\n                except KeyError:\n                    pass\n\n        if xsd_type is None and self.schema is not None:\n            xsd_type = self.schema.get_type(expanded_name or '')\n\n        if xsd_type is None:\n            return UntypedAtomic('1')\n        elif xsd_type.is_simple() or xsd_type.has_simple_content():\n            if self.schema is None:\n                return UntypedAtomic('1')\n            try:\n                primitive_type = self.schema.get_primitive_type(xsd_type)\n                return ATOMIC_VALUES[cast(str, primitive_type.local_name)]\n            except (KeyError, AttributeError):\n                return UntypedAtomic('1')\n        else:\n            # returns an xs:untypedAtomic value also for element-only types\n            # (that should be None) because it is for static evaluation.\n            return UntypedAtomic('1')\n\n    def match_sequence_type(self, value: Any,\n                            sequence_type: str,\n                            occurrence: Optional[str] = None) -> bool:\n        \"\"\"\n        Checks a value instance against a sequence type.\n\n        :param value: the instance to check.\n        :param sequence_type: a string containing the sequence type spec.\n        :param occurrence: an optional occurrence spec, can be '?', '+' or '*'.\n        \"\"\"\n        if sequence_type[-1] in OCCURRENCE_INDICATORS:\n            return self.match_sequence_type(value, sequence_type[:-1], sequence_type[-1])\n        elif value is None or isinstance(value, list) and value == []:\n            return sequence_type in ('empty-sequence()', 'none') or occurrence in ('?', '*')\n        elif sequence_type in ('empty-sequence()', 'none'):\n            return False\n        elif isinstance(value, list):\n            if len(value) == 1:\n                return self.match_sequence_type(value[0], sequence_type)\n            elif occurrence is None or occurrence == '?':\n                return False\n            else:\n                return all(self.match_sequence_type(x, sequence_type) for x in value)\n        elif sequence_type == 'item()':\n            return is_xpath_node(value) or isinstance(value, (AnyAtomicType, list, XPathFunction))\n        elif sequence_type == 'numeric':\n            return isinstance(value, NumericProxy)\n        elif sequence_type.startswith('function('):\n            if not isinstance(value, XPathFunction):\n                return False\n            return value.match_function_test(sequence_type)\n\n        value_kind = node_kind(value)\n        if value_kind is None:\n            try:\n                type_expanded_name = get_expanded_name(sequence_type, self.namespaces)\n                return self.is_instance(value, type_expanded_name)\n            except (KeyError, ValueError):\n                return False\n        elif sequence_type == 'node()':\n            return True\n        elif not sequence_type.startswith(value_kind) or not sequence_type.endswith(')'):\n            return False\n        elif sequence_type == f'{value_kind}()':\n            return True\n        elif value_kind == 'document-node':\n            return self.match_sequence_type(value.getroot(), sequence_type[14:-1])\n        elif value_kind not in ('element', 'attribute'):\n            return False\n\n        _, params = sequence_type[:-1].split('(')\n        if ',' not in sequence_type:\n            name = params\n        else:\n            name, type_name = params.split(',')\n            if type_name.endswith('?'):\n                type_name = type_name[:-1]\n            elif node_nilled(value):\n                return False\n\n            if type_name == 'xs:untyped':\n                if isinstance(value, (TypedAttribute, TypedElement)):\n                    return False\n            else:\n                try:\n                    type_expanded_name = get_expanded_name(type_name, self.namespaces)\n                    if not self.is_instance(value, type_expanded_name):\n                        return False\n                except (KeyError, ValueError):\n                    return False\n\n        if name == '*':\n            return True\n\n        try:\n            return node_name(value) == get_expanded_name(name, self.namespaces)\n        except (KeyError, ValueError):\n            return False\n\n    def check_variables(self, values: MutableMapping[str, Any]) -> None:\n        \"\"\"Checks the sequence types of the XPath dynamic context's variables.\"\"\"\n        for varname, value in values.items():\n            if not self.match_sequence_type(\n                    value, 'item()', occurrence='*' if isinstance(value, list) else None):\n                message = \"Unmatched sequence type for variable {!r}\".format(varname)\n                raise xpath_error('XPDY0050', message)\nelementpath/datatypes/datetime.py\nclass DayTimeDuration(Duration):\n\n    name = 'dayTimeDuration'\n\n    def __init__(self, seconds: Union[Decimal, int] = 0) -> None:\n        super(DayTimeDuration, self).__init__(0, seconds)\n\n    @classmethod\n    def fromtimedelta(cls, td: datetime.timedelta) -> 'DayTimeDuration':\n        return cls(seconds=Decimal(\n            '{}.{:06}'.format(td.days * 86400 + td.seconds, td.microseconds)\n        ))\n\n    def get_timedelta(self) -> datetime.timedelta:\n        return datetime.timedelta(\n            seconds=int(self.seconds), microseconds=int(self.seconds % 1 * 1000000)\n        )\n\n    def __repr__(self) -> str:\n        return '%s(seconds=%s)' % (self.__class__.__name__, normalized_seconds(self.seconds))\n\n    def __add__(self, other: object) -> Union['DayTimeDuration', Time, OrderedDateTime]:\n        if isinstance(other, (Time, Date10)):\n            return other + self\n        elif isinstance(other, self.__class__):\n            return DayTimeDuration(self.seconds + other.seconds)\n        raise TypeError(\"cannot add %r to %r\" % (type(other), type(self)))\n\n    def __sub__(self, other: object) -> 'DayTimeDuration':\n        if not isinstance(other, self.__class__):\n            raise TypeError(\"cannot subtract %r from %r\" % (type(other), type(self)))\n        return DayTimeDuration(seconds=self.seconds - other.seconds)\n\n    def __mul__(self, other: object) -> 'DayTimeDuration':\n        if isinstance(other, (float, int, Decimal)):\n            if math.isnan(other):\n                raise ValueError(\"cannot multiply a %r by NaN\" % type(self))\n\n            if isinstance(other, (int, Decimal)):\n                seconds = self.seconds * other\n            else:\n                seconds = self.seconds * Decimal.from_float(other)\n\n            return DayTimeDuration(seconds)\n        else:\n            raise TypeError(\"cannot multiply a %r by %r\" % (type(self), type(other)))\n\n    def __truediv__(self, other: object) -> Union[Decimal, 'DayTimeDuration']:\n        if isinstance(other, self.__class__):\n            return self.seconds / other.seconds\n        elif isinstance(other, (float, int, Decimal)):\n            if math.isnan(other):\n                raise ValueError(\"cannot divide a %r by NaN\" % type(self))\n\n            if isinstance(other, (int, Decimal)):\n                seconds = self.seconds / other\n            else:\n                seconds = self.seconds / Decimal.from_float(other)\n\n            return DayTimeDuration(seconds)\n        else:\n            raise TypeError(\"cannot divide a %r by %r\" % (type(self), type(other)))\nelementpath/namespaces.py\nXSD_NAMESPACE = \"http://www.w3.org/2001/XMLSchema\"\nelementpath/datatypes/uri.py\nclass AnyURI(AnyAtomicType):\n    \"\"\"\n    Class for xs:anyURI data.\n\n    :param value: a string or an untyped atomic instance.\n    \"\"\"\n    value: str\n    name = 'anyURI'\n\n    def __init__(self, value: Union[str, bytes, UntypedAtomic, 'AnyURI']) -> None:\n        if isinstance(value, str):\n            self.value = collapse_white_spaces(value)\n        elif isinstance(value, bytes):\n            self.value = collapse_white_spaces(value.decode('utf-8'))\n        elif isinstance(value, self.__class__):\n            self.value = value.value\n        elif isinstance(value, UntypedAtomic):\n            self.value = collapse_white_spaces(value.value)\n        else:\n            raise TypeError('the argument has an invalid type %r' % type(value))\n\n        self.validate(self.value)\n\n    def __repr__(self) -> str:\n        return '%s(%r)' % (self.__class__.__name__, self.value)\n\n    def __str__(self) -> str:\n        return self.value\n\n    def __bool__(self) -> bool:\n        return bool(self.value)  # For effective boolean value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n    def __contains__(self, item: str) -> bool:\n        return item in self.value\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value == other.value\n        elif isinstance(other, (bool, float, Decimal, Integer)):\n            raise TypeError(\"cannot compare {} with xs:{}\".format(type(other), self.name))\n        return self.value == other\n\n    def __ne__(self, other: object) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value != other.value\n        elif isinstance(other, (bool, float, Decimal, Integer)):\n            raise TypeError(\"cannot compare {} with xs:{}\".format(type(other), self.name))\n        return self.value != other\n\n    def __lt__(self, other: Union[str, 'AnyURI', UntypedAtomic]) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value < other.value\n        return self.value < other\n\n    def __le__(self, other: Union[str, 'AnyURI', UntypedAtomic]) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value <= other.value\n        return self.value <= other\n\n    def __gt__(self, other: Union[str, 'AnyURI', UntypedAtomic]) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value > other.value\n        return self.value > other\n\n    def __ge__(self, other: Union[str, 'AnyURI', UntypedAtomic]) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value >= other.value\n        return self.value >= other\n\n    @classmethod\n    def validate(cls, value: object) -> None:\n        if isinstance(value, cls):\n            return\n        elif isinstance(value, bytes):\n            value = value.decode()\n        elif not isinstance(value, str):\n            raise cls.invalid_type(value)\n\n        try:\n            url_parts = urlparse(value)\n            _ = url_parts.port  # check invalid port!\n        except ValueError as err:\n            msg = 'invalid value {!r} for xs:{} ({})'\n            raise ValueError(msg.format(value, cls.name, str(err))) from None\n        else:\n            if url_parts.path.startswith(':'):\n                raise cls.invalid_value(value)\n            elif value.count('#') > 1:\n                msg = 'invalid value {!r} for xs:{} (too many # characters)'\n                raise ValueError(msg.format(value, cls.name))\n            elif WRONG_ESCAPE_PATTERN.search(value) is not None:\n                msg = 'invalid value {!r} for xs:{} (wrong escaping)'\n                raise ValueError(msg.format(value, cls.name))\nelementpath/xpath_nodes.py\nclass TypedElement(XPathNode):\n    \"\"\"\n    A class for processing typed element nodes.\n\n    :param elem: the linked element. Can be an Element, or an XSD element \\\n    when XPath is applied on a schema.\n    :param xsd_type: the reference XSD type.\n    :param value: the decoded value. Can be `None` for empty or element-only elements.\"\n    \"\"\"\n    def __init__(self, elem: ElementProtocol, xsd_type: Any, value: Any) -> None:\n        self.elem = elem\n        self.xsd_type = xsd_type\n        self.value = value\n\n    @property\n    def kind(self) -> str:\n        return 'element'\n\n    @property\n    def name(self) -> str:\n        return self.elem.tag\n\n    @property\n    def tag(self) -> str:\n        return self.elem.tag\n\n    def __repr__(self) -> str:\n        return '%s(tag=%r)' % (self.__class__.__name__, self.elem.tag)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.elem is other.elem and \\\n            self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.elem, self.value))\nelementpath/datatypes/datetime.py\nclass YearMonthDuration(Duration):\n\n    name = 'yearMonthDuration'\n\n    def __init__(self, months: int = 0) -> None:\n        super(YearMonthDuration, self).__init__(months, 0)\n\n    def __repr__(self) -> str:\n        return '%s(months=%r)' % (self.__class__.__name__, self.months)\n\n    def __str__(self) -> str:\n        m = abs(self.months)\n        years, months = m // 12, m % 12\n\n        if not years:\n            return '-P%dM' % months if self.months < 0 else 'P%dM' % months\n        elif not months:\n            return '-P%dY' % years if self.months < 0 else 'P%dY' % years\n        elif self.months < 0:\n            return '-P%dY%dM' % (years, months)\n        else:\n            return 'P%dY%dM' % (years, months)\n\n    def __add__(self, other: object) \\\n            -> Union['YearMonthDuration', 'DayTimeDuration', 'OrderedDateTime']:\n        if isinstance(other, self.__class__):\n            return YearMonthDuration(months=self.months + other.months)\n        elif isinstance(other, (DateTime10, Date10)):\n            return other + self\n        raise TypeError(\"cannot add %r to %r\" % (type(other), type(self)))\n\n    def __sub__(self, other: object) -> 'YearMonthDuration':\n        if not isinstance(other, self.__class__):\n            raise TypeError(\"cannot subtract %r from %r\" % (type(other), type(self)))\n        return YearMonthDuration(months=self.months - other.months)\n\n    def __mul__(self, other: object) -> 'YearMonthDuration':\n        if not isinstance(other, (float, int, Decimal)):\n            raise TypeError(\"cannot multiply a %r by %r\" % (type(self), type(other)))\n        return YearMonthDuration(months=int(round_number(self.months * other)))\n\n    def __truediv__(self, other: object) -> Union[float, 'YearMonthDuration']:\n        if isinstance(other, self.__class__):\n            return self.months / other.months\n        elif isinstance(other, (float, int, Decimal)):\n            return YearMonthDuration(months=int(round_number(self.months / other)))\n        else:\n            raise TypeError(\"cannot divide a %r by %r\" % (type(self), type(other)))\nelementpath/xpath_nodes.py\ndef is_element_node(obj: Any) -> bool:\n    return isinstance(obj, TypedElement) or \\\n        hasattr(obj, 'tag') and not callable(obj.tag) and \\\n        hasattr(obj, 'attrib') and hasattr(obj, 'text')\nelementpath/datatypes/proxies.py\nclass NumericProxy(metaclass=NumericTypeMeta):\n    \"\"\"Proxy for xs:numeric related types. Builds xs:float instances.\"\"\"\n\n    def __new__(cls, *args: FloatArgType, **kwargs: FloatArgType) -> float:  # type: ignore[misc]\n        return float(*args, **kwargs)\nelementpath/xpath_nodes.py\ndef is_xpath_node(obj: Any) -> bool:\n    return isinstance(obj, XPathNode) or \\\n        hasattr(obj, 'tag') and hasattr(obj, 'attrib') and hasattr(obj, 'text') or \\\n        hasattr(obj, 'local_name') and hasattr(obj, 'type') and hasattr(obj, 'name') or \\\n        hasattr(obj, 'getroot') and hasattr(obj, 'parse') and hasattr(obj, 'iter')\nelementpath/xpath_nodes.py\nclass XPathNode:\n\n    name: Any = None\n    value: Any = None\n    parent: Optional[ElementNode] = None\n\n    @property\n    def kind(self) -> str:\n        raise NotImplementedError()\nelementpath/datatypes/datetime.py\nclass AbstractDateTime(metaclass=AtomicTypeMeta):\n    \"\"\"\n    A class for representing XSD date/time objects. It uses and internal datetime.datetime\n    attribute and an integer attribute for processing BCE years or for years after 9999 CE.\n    \"\"\"\n    xsd_version = '1.0'\n    pattern = re.compile(r'^$')\n    _utc_timezone = Timezone(datetime.timedelta(0))\n    _year = None\n\n    def __init__(self, year: int = 2000, month: int = 1, day: int = 1, hour: int = 0,\n                 minute: int = 0, second: int = 0, microsecond: int = 0,\n                 tzinfo: Optional[datetime.tzinfo] = None) -> None:\n\n        if hour == 24 and minute == second == microsecond == 0:\n            delta = datetime.timedelta(days=1)\n            hour = 0\n        else:\n            delta = datetime.timedelta(0)\n\n        if 1 <= year <= 9999:\n            self._dt = datetime.datetime(year, month, day, hour, minute,\n                                         second, microsecond, tzinfo)\n        elif year == 0:\n            raise ValueError('0 is an illegal value for year')\n        elif not isinstance(year, int):\n            raise TypeError(\"invalid type %r for year\" % type(year))\n        elif abs(year) > 2 ** 31:\n            raise OverflowError(\"year overflow\")\n        else:\n            self._year = year\n            if isleap(year + bool(self.xsd_version != '1.0')):\n                self._dt = datetime.datetime(4, month, day, hour, minute,\n                                             second, microsecond, tzinfo)\n            else:\n                self._dt = datetime.datetime(6, month, day, hour, minute,\n                                             second, microsecond, tzinfo)\n\n        if delta:\n            self._dt += delta\n\n    def __repr__(self) -> str:\n        fields = self.pattern.groupindex.keys()\n        arg_string = ', '.join(\n            str(getattr(self, k))\n            for k in ['year', 'month', 'day', 'hour', 'minute'] if k in fields\n        )\n        if 'second' in fields:\n            if self.microsecond:\n                arg_string += ', %d.%06d' % (self.second, self.microsecond)\n            else:\n                arg_string += ', %d' % self.second\n\n        if self.tzinfo is not None:\n            arg_string += ', tzinfo=%r' % self.tzinfo\n        return '%s(%s)' % (self.__class__.__name__, arg_string)\n\n    @abstractmethod\n    def __str__(self) -> str:\n        raise NotImplementedError()\n\n    @property\n    def year(self) -> int:\n        return self._year or self._dt.year\n\n    @property\n    def bce(self) -> bool:\n        return self._year is not None and self._year < 0\n\n    @property\n    def iso_year(self) -> str:\n        \"\"\"The ISO string representation of the year field.\"\"\"\n        year = self.year\n        if -9999 <= year < -1:\n            return '{:05}'.format(year if self.xsd_version == '1.0' else year + 1)\n        elif year == -1:\n            return '-0001' if self.xsd_version == '1.0' else '0000'\n        elif 0 <= year <= 9999:\n            return '{:04}'.format(year)\n        else:\n            return str(year)\n\n    @property\n    def month(self) -> int:\n        return self._dt.month\n\n    @property\n    def day(self) -> int:\n        return self._dt.day\n\n    @property\n    def hour(self) -> int:\n        return self._dt.hour\n\n    @property\n    def minute(self) -> int:\n        return self._dt.minute\n\n    @property\n    def second(self) -> int:\n        return self._dt.second\n\n    @property\n    def microsecond(self) -> int:\n        return self._dt.microsecond\n\n    @property\n    def tzinfo(self) -> Optional[Timezone]:\n        return cast(Timezone, self._dt.tzinfo)\n\n    @tzinfo.setter\n    def tzinfo(self, tz: Timezone) -> None:\n        self._dt = self._dt.replace(tzinfo=tz)\n\n    def tzname(self) -> Optional[str]:\n        return self._dt.tzname()\n\n    def astimezone(self, tz: Optional[datetime.tzinfo] = None) -> datetime.datetime:\n        return self._dt.astimezone(tz)\n\n    def isocalendar(self) -> Tuple[int, int, int]:\n        return self._dt.isocalendar()\n\n    @classmethod\n    def fromstring(cls, datetime_string: str, tzinfo: Optional[Timezone] = None) \\\n            -> 'AbstractDateTime':\n        \"\"\"\n        Creates an XSD date/time instance from a string formatted value.\n\n        :param datetime_string: a string containing an XSD formatted date/time specification.\n        :param tzinfo: optional implicit timezone information, must be a `Timezone` instance.\n        :return: an AbstractDateTime concrete subclass instance.\n        \"\"\"\n        if not isinstance(datetime_string, str):\n            msg = '1st argument has an invalid type {!r}'\n            raise TypeError(msg.format(type(datetime_string)))\n        elif tzinfo and not isinstance(tzinfo, Timezone):\n            msg = '2nd argument has an invalid type {!r}'\n            raise TypeError(msg.format(type(tzinfo)))\n\n        match = cls.pattern.match(datetime_string.strip())\n        if match is None:\n            msg = 'Invalid datetime string {!r} for {!r}'\n            raise ValueError(msg.format(datetime_string, cls))\n\n        match_dict = match.groupdict()\n        kwargs: Dict[str, int] = {\n            k: int(v) for k, v in match_dict.items() if k != 'tzinfo' and v is not None\n        }\n\n        if match_dict['tzinfo'] is not None:\n            tzinfo = Timezone.fromstring(match_dict['tzinfo'])\n\n        if 'microsecond' in kwargs:\n            microseconds = match_dict['microsecond']\n            if len(microseconds) != 6:\n                microseconds += '0' * (6 - len(microseconds))\n                kwargs['microsecond'] = int(microseconds[:6])\n\n        if 'year' in kwargs:\n            year_digits = match_dict['year'].lstrip('-')\n            if year_digits.startswith('0') and len(year_digits) > 4:\n                msg = \"Invalid datetime string {!r} for {!r} (when year \" \\\n                      \"exceeds 4 digits leading zeroes are not allowed)\"\n                raise ValueError(msg.format(datetime_string, cls))\n\n            if cls.xsd_version == '1.0':\n                if kwargs['year'] == 0:\n                    raise ValueError(\"year '0000' is an illegal value for XSD 1.0\")\n            elif kwargs['year'] <= 0:\n                kwargs['year'] -= 1\n\n        return cls(tzinfo=tzinfo, **kwargs)\n\n    @classmethod\n    def fromdatetime(cls, dt: Union[datetime.datetime, datetime.date, datetime.time],\n                     year: Optional[int] = None) -> 'AbstractDateTime':\n        \"\"\"\n        Creates an XSD date/time instance from a datetime.datetime/date/time instance.\n\n        :param dt: the datetime, date or time instance that stores the XSD Date/Time value.\n        :param year: if an year is provided the created instance refers to it and the \\\n        possibly present *dt.year* part is ignored.\n        :return: an AbstractDateTime concrete subclass instance.\n        \"\"\"\n        if not isinstance(dt, (datetime.datetime, datetime.date, datetime.time)):\n            raise TypeError('1st argument has an invalid type %r' % type(dt))\n        elif year is not None and not isinstance(year, int):\n            raise TypeError('2nd argument has an invalid type %r' % type(year))\n\n        kwargs = {k: getattr(dt, k) for k in cls.pattern.groupindex.keys() if hasattr(dt, k)}\n        if year is not None:\n            kwargs['year'] = year\n        return cls(**kwargs)\n\n    # Python can't compares offset-naive and offset-aware datetimes\n    def _get_operands(self, other: object) -> Tuple[datetime.datetime, datetime.datetime]:\n        if isinstance(other, (self.__class__, datetime.datetime)) or \\\n                isinstance(self, other.__class__):\n            dt: datetime.datetime = getattr(other, '_dt', cast(datetime.datetime, other))\n\n            if self._dt.tzinfo is dt.tzinfo:\n                return self._dt, dt\n            elif self.tzinfo is None:\n                return self._dt.replace(tzinfo=self._utc_timezone), dt\n            elif dt.tzinfo is None:\n                return self._dt, dt.replace(tzinfo=self._utc_timezone)\n            else:\n                return self._dt, dt\n        else:\n            raise TypeError(\"wrong type %r for operand %r\" % (type(other), other))\n\n    def __hash__(self) -> int:\n        return hash((self._dt, self._year))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, (AbstractDateTime, datetime.datetime)):\n            return False\n        try:\n            return operator.eq(*self._get_operands(other)) and self.year == other.year\n        except TypeError:\n            return False\n\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, (AbstractDateTime, datetime.datetime)):\n            return True\n        try:\n            return operator.ne(*self._get_operands(other)) or self.year != other.year\n        except TypeError:\n            return True\nelementpath/exceptions.py\nclass ElementPathTypeError(ElementPathError, TypeError):\n    pass\nelementpath/datatypes/datetime.py\nclass Duration(AnyAtomicType):\n    \"\"\"\n    Base class for the XSD duration types.\n\n    :param months: an integer value that represents years and months.\n    :param seconds: a decimal or an integer instance that represents \\\n    days, hours, minutes, seconds and fractions of seconds.\n    \"\"\"\n    name = 'duration'\n    pattern = re.compile(\n        r'^(-)?P(?=[0-9]|T)(?:([0-9]+)Y)?(?:([0-9]+)M)?(?:([0-9]+)D)?'\n        r'(?:T(?=[0-9])(?:([0-9]+)H)?(?:([0-9]+)M)?(?:([0-9]+(?:\\.[0-9]+)?)S)?)?$'\n    )\n\n    def __init__(self, months: int = 0, seconds: Union[Decimal, int] = 0) -> None:\n        if seconds < 0 < months or months < 0 < seconds:\n            raise ValueError('signs differ: (months=%d, seconds=%d)' % (months, seconds))\n        elif abs(months) > 2 ** 31:\n            raise OverflowError(\"months duration overflow\")\n        elif abs(seconds) > 2 ** 63:  # type: ignore[operator]\n            raise OverflowError(\"seconds duration overflow\")\n\n        self.months = months\n        self.seconds = Decimal(seconds).quantize(Decimal('1.000000'))\n\n    def __repr__(self) -> str:\n        return '{}(months={!r}, seconds={})'.format(\n            self.__class__.__name__, self.months, normalized_seconds(self.seconds)\n        )\n\n    def __str__(self) -> str:\n        m = abs(self.months)\n        years, months = m // 12, m % 12\n        s = self.seconds.copy_abs()\n        days = int(s // 86400)\n        hours = int(s // 3600 % 24)\n        minutes = int(s // 60 % 60)\n        seconds = s % 60\n\n        value = '-P' if self.sign else 'P'\n        if years or months or days:\n            if years:\n                value += '%dY' % years\n            if months:\n                value += '%dM' % months\n            if days:\n                value += '%dD' % days\n\n        if hours or minutes or seconds:\n            value += 'T'\n            if hours:\n                value += '%dH' % hours\n            if minutes:\n                value += '%dM' % minutes\n            if seconds:\n                value += '%sS' % normalized_seconds(seconds)\n\n        elif value[-1] == 'P':\n            value += 'T0S'\n        return value\n\n    @classmethod\n    def fromstring(cls, text: str) -> 'Duration':\n        \"\"\"\n        Creates a Duration instance from a formatted XSD duration string.\n\n        :param text: an ISO 8601 representation without week fragment and an optional decimal part \\\n        only for seconds fragment.\n        \"\"\"\n        if not isinstance(text, str):\n            msg = 'argument has an invalid type {!r}'\n            raise TypeError(msg.format(type(text)))\n\n        match = cls.pattern.match(text.strip())\n        if match is None:\n            raise ValueError('%r is not an xs:duration value' % text)\n\n        sign, y, mo, d, h, mi, s = match.groups()\n        seconds = Decimal(s or 0)\n        minutes = int(mi or 0) + int(seconds // 60)\n        seconds = seconds % 60\n        hours = int(h or 0) + minutes // 60\n        minutes = minutes % 60\n        days = int(d or 0) + hours // 24\n        hours = hours % 24\n        months = int(mo or 0) + 12 * int(y or 0)\n\n        if sign is None:\n            seconds = seconds + (days * 24 + hours) * 3600 + minutes * 60\n        else:\n            months = -months\n            seconds = -seconds - (days * 24 + hours) * 3600 - minutes * 60\n\n        if cls is DayTimeDuration:\n            if months:\n                raise ValueError('months must be 0 for %r' % cls.__name__)\n            return cls(seconds=seconds)\n        elif cls is YearMonthDuration:\n            if seconds:\n                raise ValueError('seconds must be 0 for %r' % cls.__name__)\n            return cls(months=months)\n        return cls(months=months, seconds=seconds)\n\n    @property\n    def sign(self) -> str:\n        return '-' if self.months < 0 or self.seconds < 0 else ''\n\n    def _compare_durations(self, other: object, op: Callable[[Any, Any], Any]) -> bool:\n        \"\"\"\n        Ordering is defined through comparison of four datetime.datetime values.\n\n        Ref: https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#duration\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise TypeError(\"wrong type %r for operand %r\" % (type(other), other))\n\n        m1, s1 = self.months, int(self.seconds)\n        m2, s2 = other.months, int(other.seconds)\n        ms1, ms2 = int((self.seconds - s1) * 1000000), int((other.seconds - s2) * 1000000)\n        return all([\n            op(datetime.timedelta(months2days(1696, 9, m1), s1, ms1),\n               datetime.timedelta(months2days(1696, 9, m2), s2, ms2)),\n            op(datetime.timedelta(months2days(1697, 2, m1), s1, ms1),\n               datetime.timedelta(months2days(1697, 2, m2), s2, ms2)),\n            op(datetime.timedelta(months2days(1903, 3, m1), s1, ms1),\n               datetime.timedelta(months2days(1903, 3, m2), s2, ms2)),\n            op(datetime.timedelta(months2days(1903, 7, m1), s1, ms1),\n               datetime.timedelta(months2days(1903, 7, m2), s2, ms2)),\n        ])\n\n    def __hash__(self) -> int:\n        return hash((self.months, self.seconds))\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, self.__class__):\n            return self.months == other.months and self.seconds == other.seconds\n        elif isinstance(other, UntypedAtomic):\n            return self.__eq__(self.fromstring(other.value))\n        else:\n            return other == (self.months, self.seconds)\n\n    def __ne__(self, other: object) -> bool:\n        if isinstance(other, self.__class__):\n            return self.months != other.months or self.seconds != other.seconds\n        elif isinstance(other, UntypedAtomic):\n            return self.__ne__(self.fromstring(other.value))\n        else:\n            return other != (self.months, self.seconds)\n\n    def __lt__(self, other: object) -> bool:\n        return self._compare_durations(other, operator.lt)\n\n    def __le__(self, other: object) -> bool:\n        return self == other or self._compare_durations(other, operator.le)\n\n    def __gt__(self, other: object) -> bool:\n        return self._compare_durations(other, operator.gt)\n\n    def __ge__(self, other: object) -> bool:\n        return self == other or self._compare_durations(other, operator.ge)\nelementpath/exceptions.py\nclass ElementPathKeyError(ElementPathError, KeyError):\n    pass\nelementpath/xpath_context.py\nclass XPathSchemaContext(XPathContext):\n    \"\"\"\n    The XPath dynamic context base class for schema bounded parsers. Use this class\n    as dynamic context for schema instances in order to perform a schema-based type\n    checking during the static analysis phase. Don't use this as dynamic context on\n    XML instances.\n    \"\"\"\n    iter_children_or_self: Callable[..., Iterator[Union[XsdElementProtocol, XMLSchemaProtocol]]]\n    root: XMLSchemaProtocol\nelementpath/datatypes/proxies.py\nclass ArithmeticProxy(metaclass=ArithmeticTypeMeta):\n    \"\"\"Proxy for arithmetic related types. Builds xs:float instances.\"\"\"\n\n    def __new__(cls, *args: FloatArgType, **kwargs: FloatArgType) -> float:  # type: ignore[misc]\n        return float(*args, **kwargs)\nelementpath/namespaces.py\nXMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\"  # Used in DOM for xmlns declarations\n", "answers": ["            elif is_document_node(context.root):"], "length": 5575, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "485d22985ce1c295b92e7ae9de982863b45748d37ff42a5b"}
{"input": "import functools\nimport random\n  from gevent.lock import RLock # pylint: disable=E0611\n  from gevent.coros import RLock\nfrom .base import (\n  LoadBalancerSink,\n  NoMembersError\n)\nfrom ..asynchronous import AsyncResult\nfrom ..constants import (\n  ChannelState,\n  Int,\n  MessageProperties,\n  SinkProperties,\n  SinkRole\n)\nfrom ..sink import (\n  FailingMessageSink,\n  SinkProvider,\n)\nfrom ..varz import (\n  Counter,\n  Gauge,\n  Source,\n  VarzBase\n)\n\"\"\"Heap Load Balancer.\n\nBased on the heap balancer from finagle, see (https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/loadbalancer/HeapBalancer.scala)\n\nThe heap load balancer maintains all nodes in a min-heap.  The heap is adjusted\nas the load on a node increases or decreases.  Nodes start at Zero (min int) and\nincrease load as they are used.  Load decreases when they are released back into\nthe pool.\n\nDowned nodes are tracked by setting a node's load to > 0.  A linked list of downed\nnodes is kept to resurrect downed nodes if they become active again.\n\"\"\"\n\n\ntry:\nexcept ImportError:\n\n\nclass Heap(object):\n  \"\"\"A utility class to perform heap functions\"\"\"\n  @staticmethod\n  def Swap(heap, i, j):\n    \"\"\"Swap two elements in the heap.\n\n    Args:\n      heap - The heap array.\n      i, j - The indexes int the array to swap.\n    \"\"\"\n    if i == 0 or j == 0:\n      raise Exception(\"heap swapping of element 0 should never happen.\")\n\n    heap[i], heap[j] = heap[j], heap[i]\n    heap[i].index = i\n    heap[j].index = j\n\n  @staticmethod\n  def FixUp(heap, i):\n    \"\"\"Traverse up the heap, ensuring the invariant is maintained.\n\n    Args:\n      heap - The heap array.\n      i - The index to start at.\n    \"\"\"\n    while True:\n      if i != 1 and heap[i] < heap[i//2]:\n        Heap.Swap(heap, i, i//2)\n        i //= 2 # FixUp(heap, i/2)\n      else:\n        break\n\n  @staticmethod\n  def FixDown(heap, i, j):\n    \"\"\"Traverse down the heap, ensuring the invariant is maintained.\n\n    Args:\n      heap - The heap array.\n      i, j - The node index to traverse from -> to.\n    \"\"\"\n    while True:\n      if j < i * 2: break\n\n      m = 2 * i if (j == i * 2 or heap[2*i] < heap[2*i+1]) else 2*i+1\n      if heap[m] < heap[i]:\n        Heap.Swap(heap, i, m)\n        i = m  # FixDown(heap, m, j)\n      else:\n        break\n\n\ndef synchronized(fn):\n  \"\"\"Runs the wrapped method under a lock.\n  The self parameter to the wrapped function is expected to have a __heap_lock\n  attribute.\n  \"\"\"\n  @functools.wraps(fn)\n  def wrapper(self, *args, **kwargs):\n    with self._heap_lock:\n      return fn(self, *args, **kwargs)\n  return wrapper\n\n\nclass HeapBalancerSink(LoadBalancerSink):\n  \"\"\"A sink that implements a heap load balancer.\"\"\"\n  Penalty = Int.MaxValue\n  Idle = Int.MinValue + 1\n\n  class HeapVarz(VarzBase):\n    \"\"\"\n    size - The number of nodes in the pool\n    no_members - The number of times the balancer served a failing requests\n                 because there were no members in the pool.\n    \"\"\"\n    _VARZ_BASE_NAME = 'scales.loadbalancer.Heap'\n    _VARZ = {\n      'size': Gauge,\n", "context": "scales/asynchronous.py\nclass AsyncResult(g_AsyncResult):\n  @staticmethod\n  def WhenAll(ars):\n    \"\"\"Returns an AsyncResult representing the state of all AsyncResults passed.\n\n    Args:\n      ars - An enumerable of AsyncResults.\n    Returns:\n      An AsyncResult representing the completion of all ars passed in.  When all\n      complete, the AsyncResult will be set to an array of the results of each\n      AsyncResult, in the order they were enumerated in.\n      If any AsyncResult fails, the return result will fail.\n    \"\"\"\n\n    ret = AsyncResult()\n    num_ars = len(ars)\n    total = [num_ars]\n    results = [None] * num_ars\n    def complete(_n, _ar):\n      if _ar.exception:\n        ret.set_exception(_ar.exception)\n      elif not ret.ready():\n        total[0] -= 1\n        results[_n] = _ar.value\n        if total[0] == 0:\n          ret.set(results)\n\n    for n, ar in enumerate(ars):\n      ar.rawlink(functools.partial(complete, n))\n    return ret\n\n  @staticmethod\n  def WhenAny(ars):\n    \"\"\"Returns an AsyncResult representing the state of any AsyncResult passed in.\n    The return value represents the state of the first AsyncResult to complete, or,\n    if all fail, the last to fail.\n\n    Args:\n      ars - An enumerable of AsyncResults.\n    Returns:\n      An AsyncResult representing the state of the first AsyncResult to complete.\n      The AsyncResult's value will be set to the value of the first result to\n      complete, or, if all fail, the exception thrown by the last to fail.\n    \"\"\"\n    ready_ars = [ar for ar in ars if ar.ready()]\n    if ready_ars:\n      return ready_ars[0]\n\n    ret = AsyncResult()\n    total = [len(ars)]\n    def complete(_ar):\n      total[0] -= 1\n      if total[0] == 0 and _ar.exception:\n        ret.set_exception(_ar.exception)\n      elif not ret.ready() and _ar.successful():\n        ret.set(_ar.value)\n\n    for ar in ars:\n      ar.rawlink(complete)\n    return ret\n\n  @staticmethod\n  def FromValue(val):\n    if val is None:\n      return AsyncResult.Complete()\n    else:\n      ar = AsyncResult()\n      ar.set(val)\n      return ar\n\n  @staticmethod\n  def Complete():\n    \"\"\"Return an AsyncResult that has completed.\"\"\"\n    return _COMPLETE\n\n  @staticmethod\n  def CompleteIn(n):\n    \"\"\"Returns an AsyncResult that completes in <n> seconds\n\n    Args:\n      n - The number of seconds to wait before completing.\n    \"\"\"\n    ar = AsyncResult()\n    def helper():\n      ar.set()\n    g = Greenlet(helper)\n    g.start_later(float(n))\n    return ar\n\n  def _SafeLinkHelper(self, fn):\n    try:\n      self.set(fn())\n    except:\n      self.set_exception(sys.exc_info()[1])\n\n  def SafeLink(self, fn):\n    \"\"\"Propagate the result of calling fn() on a new greenlet to ar\n\n    Args:\n      ar - An AsyncResult.\n      fn - The function to execute.\n    \"\"\"\n    gevent.spawn(self._SafeLinkHelper, fn)\n\n  def ContinueWith(self, fn, on_hub=True):\n    cw_ar = AsyncResult()\n    def continue_with_callback(_ar):\n      def run():\n        try:\n          val = fn(_ar)\n          cw_ar.set(val)\n        except:\n          cw_ar.set_exception(sys.exc_info()[1])\n      if on_hub:\n        run()\n      else:\n        gevent.spawn(run)\n    self.rawlink(continue_with_callback)\n    return cw_ar\n\n  def Map(self, fn):\n    def mapper(_):\n      if self.exception:\n        return self\n      else:\n        return fn(self.value)\n    return self.ContinueWith(mapper).Unwrap()\n\n  def _UnwrapHelper(self, target):\n    if self.ready():\n      # We're ready, propagate the result\n      if self.exception:\n        target.set_exception(self.exception)\n      else:\n        if isinstance(self.value, AsyncResult):\n          self.value._UnwrapHelper(target)\n        else:\n          target.set(self.value)\n    else:\n      self.rawlink(\n        functools.partial(AsyncResult._UnwrapHelper, target=target))\n\n  def Unwrap(self):\n    unwrapped_ar = AsyncResult()\n    self._UnwrapHelper(unwrapped_ar)\n    return unwrapped_ar\n\n  @staticmethod\n  def TryGet(val):\n    if isinstance(val, AsyncResult):\n      return val.get()\n    else:\n      return val\n\n  @staticmethod\n  def Run(fn):\n    ar = AsyncResult()\n    ar.SafeLink(fn)\n    return ar\n\n  @staticmethod\n  def RunInline(fn):\n    ar = AsyncResult()\n    ar._SafeLinkHelper(fn)\n    return ar\nscales/constants.py\nclass Int(object):\r\n  MaxValue = 2147483647\r\n  MinValue = -2147483648\r\nscales/constants.py\nclass SinkProperties(object):\r\n  Endpoint = 'endpoint'\r\n  ServiceInterface = 'service_iface'\r\n  Label = 'label'\r\nscales/loadbalancer/base.py\nclass NoMembersError(Exception): pass\nscales/sink.py\nclass FailingMessageSink(ClientMessageSink):\n  \"\"\"A sink that always returns a failure message.\"\"\"\n\n  def __init__(self, ex):\n    self._ex = ex\n    super(FailingMessageSink, self).__init__()\n\n  def AsyncProcessRequest(self, sink_stack, msg, stream, headers):\n    msg = MethodReturnMessage(error=self._ex())\n    sink_stack.AsyncProcessResponseMessage(msg)\n\n  def AsyncProcessResponse(self, sink_stack, context, stream, msg):\n    raise NotImplementedError(\"This should never be called\")\n\n  @property\n  def state(self):\n    return ChannelState.Open\n\n  @property\n  def endpoint(self):\n    return None\nscales/constants.py\nclass ChannelState(object):\r\n  Idle = 1\r\n  Open = 2\r\n  Busy = 3\r\n  Closed = 4\r\nscales/sink.py\ndef SinkProvider(sink_cls, role=None, **defaults):\n  \"\"\"Factory for creating simple sink providers.\n\n  Args:\n    sink_cls - The type of sink to provide.\n  Returns:\n    A SinkProvider that provides sinks of type 'sink_cls'.\n  \"\"\"\n  field_names = ' '.join(defaults.keys())\n  params_cls = namedtuple('Params', field_names)\n\n  def CreateSink(self, properties):\n    return self.SINK_CLASS(self.next_provider, self.sink_properties, properties)\n\n  def sink_class(self):\n    return self.SINK_CLASS\n\n  provider = type(\n    sink_cls.__name__ + 'Provider',\n    (SinkProviderBase, ),\n    {\n      'SINK_CLASS': sink_cls,\n      'PARAMS_CLASS': params_cls,\n      'Role': role,\n      'CreateSink': CreateSink,\n      'sink_class': property(sink_class),\n      '_defaults': defaults\n    }\n  )\n  return provider\nscales/varz.py\nclass VarzType(object):\nclass Source(object):\nclass VarzMetric(object):\nclass Gauge(VarzMetric): VARZ_TYPE = VarzType.Gauge\nclass Rate(VarzMetric): VARZ_TYPE = VarzType.Rate\nclass AverageRate(VarzMetric): VARZ_TYPE = VarzType.AverageRate\nclass Counter(Rate): VARZ_TYPE = VarzType.Counter\nclass VarzTimerBase(VarzMetric):\nclass AverageTimer(VarzTimerBase): VARZ_TYPE = VarzType.AverageTimer\nclass AggregateTimer(VarzTimerBase): VARZ_TYPE = VarzType.AggregateTimer\nclass VarzMeta(type):\nclass _VarzBase(object):\nclass _SampleSet(object):\nclass VarzReceiver(object):\nclass VarzAggregator(object):\n  class _Agg(object):\nclass VarzSocketWrapper(object):\n  class Varz(VarzBase):\nclass MonoClock(object):\nclass Ema(object):\n  def __init__(self, method=None, service=None, endpoint=None, client_id=None):\n  def to_tuple(self):\n  def to_dict(self):\n  def __cmp__(self, other):\n  def __hash__(self):\n  def _Adapt(fn):\n    def __Adapt(metric, source, amount=1):\n  def __init__(self, metric, source):\n  def __call__(self, *args):\n  def ForSource(self, source):\n  def Measure(self, source=None):\n  def __new__(mcs, name, bases, dct):\ndef VerifySource(source):\n  def __init__(self, source):\n  def __getattr__(self, item):\n  def __init__(self, max_size, data=None, p=.1):\n  def Sample(self, value):\n  def RegisterMetric(metric, varz_type):\n  def IncrementVarz(source, metric, amount=1):\n  def SetVarz(source, metric, value):\n  def RecordPercentileSample(cls, source, metric, value):\ndef DefaultKeySelector(k):\n    def __init__(self):\n  def CalculatePercentile(values, pct):\n  def _Downsample(lst, target_size):\n  def Aggregate(varz, metrics, key_selector=None):\n  def __init__(self, socket, varz_tag):\n  def host(self):\n  def port(self):\n  def isOpen(self):\n  def read(self, sz):\n  def recv_into(self, buf, sz):\n  def flush(self):\n  def write(self, buff):\n  def open(self):\n  def close(self):\n  def readAll(self, sz):\n  def __init__(self):\n  def Sample(self):\n  def __init__(self, window):\n  def Update(self, ts, sample):\n  VARZ_TYPE = None\nclass Gauge(VarzMetric): VARZ_TYPE = VarzType.Gauge\nclass Rate(VarzMetric): VARZ_TYPE = VarzType.Rate\nclass AverageRate(VarzMetric): VARZ_TYPE = VarzType.AverageRate\nclass Counter(Rate): VARZ_TYPE = VarzType.Counter\nclass AverageTimer(VarzTimerBase): VARZ_TYPE = VarzType.AverageTimer\nclass AggregateTimer(VarzTimerBase): VARZ_TYPE = VarzType.AggregateTimer\n  _VARZ = {}\n  _VARZ_BASE_NAME = None\n  VARZ_METRICS = {}\n  VARZ_DATA = defaultdict(lambda: defaultdict(int))\n  VARZ_PERCENTILES = [.5, .90, .99, .999, .9999]\n  _MAX_PERCENTILE_SIZE = 1000\n  MAX_AGG_AGE = 5 * 60\n    _VARZ_BASE_NAME = 'scales.socket'\n    _VARZ = {\n      'bytes_recv': Rate,\n      'bytes_sent': Rate,\n      'num_connections': Counter,\n      'tests_failed': Counter,\n      'connects': Rate,\n      'open_latency': AverageTimer\n    }\nscales/constants.py\nclass SinkRole(object):\r\n  Transport = 'transport'\r\n  Pool = 'pool'\r\n  LoadBalancer = 'loadbalancer'\r\n  Formatter = 'formatter'\r\nscales/loadbalancer/base.py\nclass LoadBalancerSink(ClientMessageSink):\n  \"\"\"Base class for all load balancer sinks.\"\"\"\n  Role = SinkRole.LoadBalancer\n\n  def __init__(self, next_provider, sink_properties, global_properties):\n    self._properties = global_properties\n    service_name = global_properties[SinkProperties.Label]\n    server_set_provider = sink_properties.server_set_provider\n    log_name = self.__class__.__name__.replace('ChannelSink', '')\n    self._log = ROOT_LOG.getChild('%s.[%s]' % (log_name, service_name))\n    self.__init_done = Event()\n    self.__open_ar = None\n    self.__open_greenlet = None\n    self._server_set_provider = server_set_provider\n    self._endpoint_name = server_set_provider.endpoint_name\n    self._next_sink_provider = next_provider\n    self._state = ChannelState.Idle\n    self._servers = {}\n    super(LoadBalancerSink, self).__init__()\n\n  @property\n  def state(self):\n    return self._state\n\n  def Open(self):\n    if self.__open_ar:\n      return self.__open_ar\n\n    self.__open_ar = AsyncResult()\n    self.__open_greenlet = gevent.spawn(self._OpenImpl)\n    return self.__open_ar\n\n  def _OpenImpl(self):\n    while self._state != ChannelState.Closed:\n      try:\n        self._server_set_provider.Initialize(\n            self.__OnServerSetJoin,\n            self.__OnServerSetLeave)\n        server_set = self._server_set_provider.GetServers()\n      except gevent.GreenletExit:\n        return\n      except:\n        self._log.exception(\"Unable to initialize serverset, retrying in 5 seconds.\")\n        gevent.sleep(5)\n        continue\n\n      random.shuffle(server_set)\n      self._servers = {}\n      [self.__AddServer(m) for m in server_set]\n      self.__init_done.set()\n      self._OpenInitialChannels()\n      self._open_greenlet = None\n      self._state = ChannelState.Open\n      return True\n\n  @abstractmethod\n  def _OpenInitialChannels(self):\n    \"\"\"To be overriden by subclasses.  Called after the ServerSet is initialized\n    and the initial set of servers has been loaded.\n    \"\"\"\n    pass\n\n  def _OnOpenComplete(self):\n    \"\"\"To be called by subclasses when they've completed (successfully or not)\n    opening their sinks.\n    \"\"\"\n    self.__open_ar.set(True)\n\n  def WaitForOpenComplete(self, timeout=None):\n    self.__open_ar.wait(timeout)\n\n  def Close(self):\n    self._server_set_provider.Close()\n    self._state = ChannelState.Closed\n    self.__init_done.clear()\n    if self.__open_greenlet:\n      self.__open_greenlet.kill(block=False)\n      self.__open_greenlet = None\n    self.__open_ar = None\n\n  @abstractmethod\n  def _AsyncProcessRequestImpl(self, sink_stack, msg, stream, headers):\n    pass\n\n  def AsyncProcessRequest(self, sink_stack, msg, stream, headers):\n    if not self.__open_ar.ready():\n      def _on_open_done(_):\n        timeout_event = msg.properties.get(Deadline.EVENT_KEY, None)\n        # Either there is no timeout, or the timeout hasn't expired yet.\n        if not timeout_event or not timeout_event.Get():\n          self._AsyncProcessRequestImpl(sink_stack, msg, stream, headers)\n      self.__open_ar.rawlink(_on_open_done)\n    else:\n      self._AsyncProcessRequestImpl(sink_stack, msg, stream, headers)\n\n  def __GetEndpoint(self, instance):\n    if self._endpoint_name:\n      aeps = instance.additional_endpoints\n      ep = aeps.get(self._endpoint_name, None)\n      if not ep:\n        raise ValueError(\n            \"Endpoint name %s not found in endpoints\", self._endpoint_name)\n      return ep\n    else:\n      return instance.service_endpoint\n\n  def _OnServersChanged(self, endpoint, channel_factory, added):\n    \"\"\"Overridable by child classes.  Invoked when servers in the server set are\n    added or removed.\n\n    Args:\n      instance - The server set member being added or removed.\n      added - True if the instance is being added, False if it's being removed.\n    \"\"\"\n    pass\n\n  def __AddServer(self, instance):\n    \"\"\"Adds a servers to the set of servers available to the load balancer.\n    Note: The new sink is not opened at this time.\n\n    Args:\n      instance - A Member object to be added to the pool.\n    \"\"\"\n    ep = self.__GetEndpoint(instance)\n    if not ep in self._servers:\n      new_props = self._properties.copy()\n      new_props.update({ SinkProperties.Endpoint: ep })\n      channel_factory = functools.partial(self._next_sink_provider.CreateSink, new_props)\n      self._servers[ep] = channel_factory\n      self._log.info(\"Instance %s joined (%d members)\" % (\n        ep, len(self._servers)))\n      self._OnServersChanged(ep, channel_factory, True)\n\n  def __RemoveServer(self, instance):\n    \"\"\"Removes a server from the load balancer.\n\n    Args:\n      instance - A Member object to be removed from the pool.\n    \"\"\"\n    ep = self.__GetEndpoint(instance)\n    channel_factory = self._servers.pop(ep, None)\n    self._OnServersChanged(ep, channel_factory, False)\n\n  def __OnServerSetJoin(self, instance):\n    \"\"\"Invoked when an instance joins the server set.\n\n    Args:\n      instance - Instance added to the cluster.\n    \"\"\"\n    # callbacks from the ServerSet are delivered serially, so we can guarantee\n    # that once this unblocks, we'll still get the notifications delivered in\n    # the order that they arrived.  Ex: OnJoin(a) -> OnLeave(a)\n    self.__init_done.wait()\n    # OnJoin notifications are delivered at startup, however we already\n    # pre-populate our copy of the ServerSet, so it's fine to ignore duplicates.\n    if self.__GetEndpoint(instance) in self._servers:\n      return\n\n    self.__AddServer(instance)\n\n  def __OnServerSetLeave(self, instance):\n    \"\"\"Invoked when an instance leaves the server set.\n\n    Args:\n      instance - Instance leaving the cluster.\n    \"\"\"\n    self.__init_done.wait()\n    self.__RemoveServer(instance)\n\n    self._log.info(\"Instance %s left (%d members)\" % (\n        self.__GetEndpoint(instance), len(self._servers)))\nscales/constants.py\nclass MessageProperties(object):\r\n  Endpoint = '__Endpoint'\r\n", "answers": ["      'no_members': Counter"], "length": 1853, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "83dfff0a545002c34c8768ae85f608da63dc855662ffd1ac"}
{"input": "from drogulus.net.netstring import (NetstringProtocol, NetstringConnector,\n                                    LENGTH)\nfrom drogulus.dht.messages import OK, to_dict, from_dict\nfrom drogulus.dht.contact import PeerNode\nfrom drogulus.dht.crypto import get_seal\nfrom drogulus.dht.node import Node\nfrom drogulus.version import get_version\nfrom ..keys import PUBLIC_KEY, PRIVATE_KEY, BAD_PUBLIC_KEY\nfrom hashlib import sha512\nfrom unittest import mock\nimport unittest\nimport uuid\nimport json\nimport asyncio\n        \"\"\"\n        transport = mock.MagicMock()\n        transport.close = mock.MagicMock()\n        connector = mock.MagicMock()\n        node = mock.MagicMock()\n        p = NetstringProtocol(connector, node)\n        p.connection_made(transport)\n        p.data_received('11:hello world@'.encode('utf-8'))\n        self.assertEqual(1, transport.close.call_count)\n\n    def test_data_received_bad_length(self):\n        \"\"\"\n        If the netstring does not start with an integer defining the length\n        of the message then ensure the problem is handled correctly.\n        \"\"\"\n        transport = mock.MagicMock()\n        transport.close = mock.MagicMock()\n        connector = mock.MagicMock()\n        node = mock.MagicMock()\n        p = NetstringProtocol(connector, node)\n        p.connection_made(transport)\n        p.data_received('foo:hello world,'.encode('utf-8'))\n        self.assertEqual(1, transport.close.call_count)\n\n    def test_data_received_length_too_long(self):\n        \"\"\"\n        If the netstring is expected to be too long then ensure the problem is\n        handled correctly.\n        \"\"\"\n        transport = mock.MagicMock()\n        transport.close = mock.MagicMock()\n        connector = mock.MagicMock()\n        node = mock.MagicMock()\n        p = NetstringProtocol(connector, node)\n        p.connection_made(transport)\n        p.data_received('999999999999999999:hello world,'.encode('utf-8'))\n        self.assertEqual(1, transport.close.call_count)\n\n    def test_data_received_in_bad_state(self):\n        \"\"\"\n        Ensure the correct RuntimeError is called if the state of the FSM is\n        invalid.\n        \"\"\"\n        transport = mock.MagicMock()\n        transport.close = mock.MagicMock()\n        connector = mock.MagicMock()\n        node = mock.MagicMock()\n        p = NetstringProtocol(connector, node)\n        p.connection_made(transport)\n        p._reader_state = 4\n        with self.assertRaises(RuntimeError):\n            p.data_received('11:hello world@'.encode('utf-8'))\n\n    def test_send_string(self):\n        \"\"\"\n        Ensure the raw string form of the message is correctly turned into a\n        valid netstring.\n        \"\"\"\n        transport = mock.MagicMock()\n        transport.write = mock.MagicMock()\n        connector = mock.MagicMock()\n        node = mock.MagicMock()\n        p = NetstringProtocol(connector, node)\n        p.connection_made(transport)\n        p.send_string('foo bar baz')\n        transport.write.assert_called_once_with(b'11:foo bar baz,')\n\n    def test_send_utf8_string_with_correct_length(self):\n        \"\"\"\n        Ensure the raw string containing weird unicode chars is correctly\n        turned into a valid netstring with the correct length.\n        \"\"\"\n        transport = mock.MagicMock()\n        transport.write = mock.MagicMock()\n        connector = mock.MagicMock()\n        node = mock.MagicMock()\n        p = NetstringProtocol(connector, node)\n        p.connection_made(transport)\n        p.send_string('zɐq ɹɐq ooɟ')\n        length = len('zɐq ɹɐq ooɟ'.encode('utf-8'))\n        expected = '%d:zɐq ɹɐq ooɟ,' % length\n        transport.write.assert_called_once_with(expected.encode('utf-8'))\n\n\nclass TestNetstringConnector(unittest.TestCase):\n    \"\"\"\n    Checks the NetstringConnector class works as expected.\n    \"\"\"\n\n    def setUp(self):\n        \"\"\"\n        Set up a new throw-away event loop.\n        \"\"\"\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        self.event_loop = asyncio.get_event_loop()\n        self.version = get_version()\n\n    def tearDown(self):\n        \"\"\"\n        Clean up the event loop.\n        \"\"\"\n        self.event_loop.close()\n\n    def test_init(self):\n        \"\"\"\n        Check the class instantiates as expected.\n        \"\"\"\n        nc = NetstringConnector(self.event_loop)\n        self.assertEqual(nc._connections, {})\n        self.assertEqual(nc.event_loop, self.event_loop)\n\n    def test_send_message_with_protocol(self):\n        \"\"\"\n        Ensures that the message is translated into a dictionary and passed\n        into the protocol object in the expected way.\n        \"\"\"\n        nc = NetstringConnector(self.event_loop)\n        protocol = mock.MagicMock()\n        protocol.send_string = mock.MagicMock()\n", "context": "drogulus/dht/messages.py\ndef to_dict(message):\n    \"\"\"\n    Returns a dict representation of the message object.\n    \"\"\"\n    name = message.__class__.__name__.lower()\n    data = message._asdict()\n    data['message'] = name\n    return dict(data)\ndrogulus/dht/messages.py\nOK = _make_message_class('OK', [], d)\ntests/keys.py\nPRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIICYAIBAAKBgQC8jS8lvazStqe5l2rWbUgRb+vgxqbB7mAuBd0zSlfEHQdLzhk5\nWo7JrVVJ4pKK/+uuVEr7KAnnuPH2GJBQOTJGw3Z2ZgkaifMGhKIk+xBHxPDC/BCZ\nJrMyKylJSz7LGwmJHYfJUGTNq9xwZfigcmthA4Vh9g7WWzmOFNdGrbufAQIDAQAB\nAoGAAkUc3TJ0YzEJweU9xwkXxgX37APYPBt3kvZFHHn3pofG77WyfgtGDs2EalhM\n9VlxZ+7h3DY2MFD8sL7I82vYY4Mb3OUVU1C/aWXEO4vk8LdXKn4rlV8xuFVKQn8p\nDIdMIW9h7j7EbLjdbG9tlGz++b3KQ00JD5Xk+MkoN4IpXfECRQDVpKedjsdAjVCS\nWtXSBu9L+QzLndj1d4gCgcO8tOrrdQ7WhwiXvI6FHgkfU5px0UBg9LEeMPTRNpWj\nf/W1MmdHQSlLbQI9AOHvA7mMXLk8QHoKLPi1ZgJo96SpX1bFNBqkUuXGYici4A1T\nud+V0/wbnRHzZ9DHfDFKjoLlfybHK2UxZQJEPksNSIaKGItb0+DCecPl4EwU7AXx\nbdlVgg2eKhbCbLcsBWdIHR4wnCXe2RCCdu9hiyOtxTTXHW2CAjNcTGIO9RrN1J0C\nPQC2JsIlBQH4oZgGDFAnj/AXP1Nw4NCpn0IbvKHM+H1HujlS5U608RHAbu7aexgW\n3c3F26s74xT5SZg19HUCRGgX01UT/sukk4ALuFCfwuR0hodIbhuJ6eWh/n0VEXJ4\nZt47JXvqWbVjC6vtSgBM5LiRAxcfee7Bi94OtZik4vI132d4\n-----END RSA PRIVATE KEY-----\"\"\"\ndrogulus/dht/crypto.py\ndef get_seal(item, private_key):\n    \"\"\"\n    Given an item dict that represents an outgoing message, create and return\n    a string representation of a \"seal\" - a cryptographic signature to prove\n    the provenance of the message.\n    \"\"\"\n    root_hash = _get_hash(item).hexdigest()\n    key = rsa.PrivateKey.load_pkcs1(private_key.encode('ascii'))\n    return binascii.hexlify(rsa.sign(root_hash.encode('ascii'),\n                                     key, 'SHA-512')).decode('ascii')\ntests/keys.py\nBAD_PUBLIC_KEY = \"\"\"-----BEGIN RSA PUBLIC KEY-----\nMIGJAoGBAIja/W02x6zDhExKZqrCZjedyC4J0dhDN2Y4fpDY0kSCp/ar83EsJLIX\nV1I1XFOFmGo1EBx6eWIrMuc2Nc4vY6I/16TZfvT2P6nh8OVWW88Ra0hIh2ggIDFt\ntId24hw7MP0rcNVQjAkC/TAuhO5kUQE4j9VFy2NpctKxvE6rcTONAgMBAAE=\n-----END RSA PUBLIC KEY-----\"\"\"\ntests/keys.py\nPUBLIC_KEY = \"\"\"-----BEGIN RSA PUBLIC KEY-----\nMIGJAoGBALyNLyW9rNK2p7mXatZtSBFv6+DGpsHuYC4F3TNKV8QdB0vOGTlajsmt\nVUnikor/665USvsoCee48fYYkFA5MkbDdnZmCRqJ8waEoiT7EEfE8ML8EJkmszIr\nKUlLPssbCYkdh8lQZM2r3HBl+KBya2EDhWH2DtZbOY4U10atu58BAgMBAAE=\n-----END RSA PUBLIC KEY-----\"\"\"\ndrogulus/dht/contact.py\nclass PeerNode(object):\n    \"\"\"\n    Represents another node on the network.\n    \"\"\"\n\n    def __init__(self, public_key, version, uri, last_seen=0.0):\n        \"\"\"\n        Initialise the peer node with a unique id within the network (derived\n        from its public key), the drogulus version the contact is running, a\n        URI that identifies where to contact the peer node and a timestamp\n        indicating when the last connection was made with the contact\n        (defaults to 0).\n        \"\"\"\n        self.network_id = make_network_id(public_key)\n        self.public_key = public_key\n        self.version = version\n        self.uri = uri\n        self.last_seen = last_seen\n        # failed_RPCs keeps track of the number of failed RPCs to this peer.\n        # If this number reaches a threshold then it is evicted from a\n        # bucket and replaced with another node that is more reliable.\n        self.failed_RPCs = 0\n\n    def dump(self):\n        \"\"\"\n        Returns a dictionary representation of the peer node that can be\n        serialised into JSON. Useful for backing up the routing table.\n        \"\"\"\n        return {\n            'public_key': self.public_key,\n            'version': self.version,\n            'uri': self.uri,\n        }\n\n    def __eq__(self, other):\n        \"\"\"\n        Override equals to work with a string representation of the contact's\n        id.\n        \"\"\"\n        if isinstance(other, PeerNode):\n            return self.network_id == other.network_id\n        elif isinstance(other, str):\n            return self.network_id == other\n        else:\n            return False\n\n    def __ne__(self, other):\n        \"\"\"\n        Override != to work with a string representation of the contact's id.\n        \"\"\"\n        return not self == other\n\n    def __repr__(self):\n        \"\"\"\n        Returns a tuple containing information about this contact.\n        \"\"\"\n        return str((self.network_id, self.public_key, self.version, self.uri,\n                    self.last_seen, self.failed_RPCs))\n\n    def __str__(self):\n        \"\"\"\n        Override the string representation of the object to be something\n        useful.\n        \"\"\"\n        return str({\n            'network_id': self.network_id,\n            'public_key': self.public_key,\n            'version': self.version,\n            'uri': self.uri,\n            'last_seen': self.last_seen,\n            'failed_rpc': self.failed_RPCs\n        })\n\n    def __hash__(self):\n        \"\"\"\n        Create a Python hash so instances of this class can be used as keys in\n        Python dics and members of Python sets.\n        \"\"\"\n        return hash(self.network_id)\ndrogulus/dht/node.py\nclass Node(object):\n    \"\"\"\n    This class represents a single local node in the DHT encapsulating its\n    presence in the network.\n\n    All interactions with the DHT network are performed via this class (or a\n    subclass).\n    \"\"\"\n\n    def __init__(self, public_key, private_key, event_loop, connector,\n                 reply_port):\n        \"\"\"\n        Initialises the node with the credentials, event loop and object\n        via which the node opens connections to peers. The reply_port\n        argument tells other nodes on the network the port to use to contact\n        this node. Such a port may not be the port used by the local machine\n        but could be, for example, the port assigned by the UPnP setup of the\n        local router.\n        \"\"\"\n        self.public_key = public_key\n        self.private_key = private_key\n        self.event_loop = event_loop\n        self.connector = connector\n        self.reply_port = reply_port\n        # The node's ID within the distributed hash table.\n        self.network_id = sha512(public_key.encode('ascii')).hexdigest()\n        # Reference to the event loop.\n        self.event_loop = event_loop\n        # The routing table stores information about other nodes on the DHT.\n        self.routing_table = RoutingTable(self.network_id)\n        # The local key/value store containing data held by this node.\n        self.data_store = DictDataStore()\n        # A dictionary of IDs for messages pending a response and associated\n        # Future instances to be fired when a response is completed.\n        self.pending = {}\n        # The version of Drogulus that this node implements.\n        self.version = get_version()\n        log.info('Initialised node with id: {}'.format(self.network_id))\n\n    def join(self, data_dump):\n        \"\"\"\n        Causes the Node to join the DHT network. This should be called before\n        any other DHT operations. The seed_nodes argument must be a list of\n        already known contacts describing existing nodes on the network.\n        \"\"\"\n        if not data_dump.get('contacts', []):\n            raise ValueError('Cannot join network: no contacts supplied')\n        self.routing_table.restore(data_dump)\n        # Ensure the refresh of k-buckets is set up properly.\n        self.event_loop.call_later(REFRESH_INTERVAL, self.refresh)\n        # Looking up the node's ID on the network will populate the routing\n        # table with fresh nodes as well as tell us who our nearest neighbours\n        # are.\n        return Lookup(FindNode, self.network_id, self, self.event_loop)\n\n    def message_received(self, message, protocol, address, port):\n        \"\"\"\n        Handles incoming messages.\n\n        The protocol, address and port arguments are used to create the\n        remote contact's URI used to identify them on the network.\n        \"\"\"\n        # Check the \"seal\" of the sender to make sure it's legit.\n        if not check_seal(message):\n            raise BadMessage()\n        # Update the routing table.\n        uri = '{protocol}://{address}:{port}'.format(protocol=protocol,\n                                                     address=address,\n                                                     port=port)\n        other_node = PeerNode(message.sender, message.version, uri,\n                              time.time())\n        log.info('Message received from {}'.format(other_node))\n        log.info(message)\n        self.routing_table.add_contact(other_node)\n        # Sort on message type and pass to handler method. Explicit > implicit.\n        try:\n            if isinstance(message, OK):\n                return self.handle_ok(message)\n            elif isinstance(message, Store):\n                return self.handle_store(message, other_node)\n            elif isinstance(message, FindNode):\n                return self.handle_find_node(message, other_node)\n            elif isinstance(message, FindValue):\n                return self.handle_find_value(message, other_node)\n            elif isinstance(message, Value):\n                return self.handle_value(message, other_node)\n            elif isinstance(message, Nodes):\n                return self.handle_nodes(message)\n        except Exception as ex:\n            log.error('Problem handling message from {}'.format(other_node))\n            log.error(message)\n            log.error(ex)\n\n    def send_message(self, contact, message, fire_and_forget=False):\n        \"\"\"\n        Sends a message to the specified contact, adds the resulting future to\n        the pending dictionary and ensures it times-out after the correct\n        period. A callback is added to ensure that the task is removed from\n        pending when it resolves (no matter the result). A timeout function\n        is scheduled after RESPONSE_TIMEOUT seconds to clean up the pending\n        task if the remote peer doesn't respond in a timely fashion.\n        \"\"\"\n        # A Future that represents the delivery of the message.\n        delivery = self.connector.send(contact, message, self)\n        # A Future that resolves with the response to the outgoing message.\n        response_received = asyncio.Future()\n        self.pending[message.uuid] = response_received\n\n        def on_delivery(task, node=self, response_received=response_received,\n                        message=message):\n            \"\"\"\n            Called when the delivery of the message either succeeds or fails.\n            If the delivery failed then punish the remote peer and resolve\n            response_received appropriately. Otherwise make sure the\n            appropriate timeout or fire-and-forget handling is put in place\n            on the response_received Future.\n            \"\"\"\n            if task.exception():\n                node.routing_table.remove_contact(contact.network_id)\n                if not response_received.done():\n                    response_received.set_exception(task.exception())\n            else:\n                if fire_and_forget:\n                    node.event_loop.call_soon(response_received.set_result,\n                                              'sent')\n                else:\n                    error = TimedOut('Response took too long.')\n                    node.event_loop.call_later(RESPONSE_TIMEOUT,\n                                               node.trigger_task,\n                                               message, error)\n\n        delivery.add_done_callback(on_delivery)\n\n        def on_response(future, uuid=message.uuid):\n            \"\"\"\n            Ensure the resolved response_received is removed from the pending\n            dictionary.\n            \"\"\"\n            if uuid in self.pending:\n                del self.pending[uuid]\n\n        response_received.add_done_callback(on_response)\n        return message.uuid, response_received\n\n    def trigger_task(self, message, error=False):\n        \"\"\"\n        Given a message, will attempt to retrieve the related pending task\n        and trigger it with the message.\n        \"\"\"\n        if message.uuid in self.pending:\n            task = self.pending[message.uuid]\n            if not task.done():\n                if error:\n                    task.set_exception(error)\n                else:\n                    task.set_result(message)\n            # Remove the resolved task from the pending dictionary.\n            del self.pending[message.uuid]\n\n    def handle_ok(self, message):\n        \"\"\"\n        Handles an incoming ok message.\n        \"\"\"\n        self.trigger_task(message)\n\n    def handle_store(self, message, contact):\n        \"\"\"\n        Handles an incoming Store message. Checks the provenance and timeliness\n        of the message before storing locally. If there is a problem, removes\n        the untrustworthy peer from the routing table. Otherwise, at\n        REPLICATE_INTERVAL minutes in the future, the local node will attempt\n        to replicate the Store message elsewhere in the DHT if such time is\n        <= the message's expiry time.\n\n        Sends an OK message if successful.\n        \"\"\"\n        # Check provenance\n        if verify_item(to_dict(message)):\n            # Ensure the key is correct.\n            k = construct_key(message.public_key, message.name)\n            if k != message.key:\n                # This may indicate a different / unknown / unsupported\n                # version of the drogulus created the original message.\n                raise BadMessage('Key mismatch')\n            # Ensure the value isn't expired.\n            now = time.time()\n            if message.expires > 0 and (message.expires < now):\n                # There's a non-zero expiry and it's less than the current\n                # time, so return an error.\n                raise ExpiredMessage(\n                    'Expired at {} (current time: {})'.format(message.expires,\n                                                              now))\n            # Ensure the node doesn't already have a more up-to-date version\n            # of the value.\n            current = self.data_store.get(message.key, False)\n            if current and (message.timestamp < current.timestamp):\n                # The node already has a later version of the value so\n                # return an error.\n                raise OutOfDateMessage(\n                    'Most recent timestamp: {}'.format(current.timestamp))\n            # Good to go, so store value.\n            self.data_store[message.key] = message\n            # At some future time attempt to replicate the Store message\n            # around the network IF it is within the message's expiry time.\n            self.event_loop.call_later(REPLICATE_INTERVAL, self.republish,\n                                       message.key)\n            # Reply with an OK so the other end updates its routing table.\n            return self.make_ok(message)\n        else:\n            # Remove from the routing table.\n            log.error('Problem with Store command from {}'.format(contact))\n            self.routing_table.blacklist(contact)\n            raise UnverifiableProvenance('Blacklisted')\n\n    def handle_find_node(self, message, contact):\n        \"\"\"\n        Handles an incoming FindNode message. Finds the details of up to K\n        other nodes closer to the target key that *this* node knows about.\n        Responds with a \"Nodes\" message containing the list of matching\n        nodes.\n        \"\"\"\n        target_key = message.key\n        # List containing tuples of information about the matching contacts.\n        other_nodes = [[n.public_key, n.version, n.uri] for n in\n                       self.routing_table.find_close_nodes(target_key)]\n        return self.make_nodes(message, other_nodes)\n\n    def handle_find_value(self, message, contact):\n        \"\"\"\n        Handles an incoming FindValue message. If the local node contains the\n        value associated with the requested key replies with an appropriate\n        \"Value\" message. Otherwise, responds with details of up to K other\n        nodes closer to the target key that the local node knows about. In\n        this case a \"Nodes\" message containing the list of matching nodes is\n        sent to the remote peer.\n        \"\"\"\n        match = self.data_store.get(message.key, False)\n        if match:\n            # Update the last access time for the matching value.\n            self.data_store.touch(message.key)\n            return self.make_value(message, match.key, match.value,\n                                   match.timestamp, match.expires,\n                                   match.created_with, match.public_key,\n                                   match.name, match.signature)\n        else:\n            return self.handle_find_node(message, contact)\n\n    def handle_value(self, message, contact):\n        \"\"\"\n        Handles an incoming Value message containing a value retrieved from\n        another node on the DHT. Ensures the message is valid and resolves the\n        referenced future to signal the arrival of the value.\n\n        If the value is invalid then the reponse is logged, the remote peer\n        is blacklisted and the referenced future is resolved with an\n        UnverifiableProvenance exception.\n        \"\"\"\n        if verify_item(to_dict(message)):\n            self.trigger_task(message)\n        else:\n            log.error(\n                'Problem with incoming Value message from {}'.format(contact))\n            log.error(message)\n            self.routing_table.remove_contact(contact.network_id, True)\n            log.error('Remote peer removed from routing table.')\n            self.trigger_task(message,\n                              error=UnverifiableProvenance('Blacklisted'))\n\n    def handle_nodes(self, message):\n        \"\"\"\n        Handles an incoming Nodes message containing information about other\n        nodes on the network that are close to a requested key.\n        \"\"\"\n        self.trigger_task(message)\n\n    def make_ok(self, message):\n        \"\"\"\n        Returns an OK acknowledgement appropriate given the incoming message.\n        \"\"\"\n        ok = {\n            'uuid': message.uuid,\n            'recipient': message.sender,\n            'sender': self.public_key,\n            'reply_port': self.reply_port,\n            'version': self.version\n        }\n        seal = get_seal(ok, self.private_key)\n        ok['seal'] = seal\n        ok['message'] = 'ok'\n        return from_dict(ok)\n\n    def make_value(self, message, key, value, timestamp, expires,\n                   created_with, public_key, name, signature):\n        \"\"\"\n        Returns a valid Value message in response to the referenced message.\n        \"\"\"\n        msg_dict = {\n            'uuid': message.uuid,\n            'recipient': message.sender,\n            'sender': self.public_key,\n            'reply_port': self.reply_port,\n            'version': self.version,\n            'key': key,\n            'value': value,\n            'timestamp': timestamp,\n            'expires': expires,\n            'created_with': created_with,\n            'public_key': public_key,\n            'name': name,\n            'signature': signature,\n        }\n        seal = get_seal(msg_dict, self.private_key)\n        msg_dict['seal'] = seal\n        msg_dict['message'] = 'value'\n        return from_dict(msg_dict)\n\n    def make_nodes(self, message, nodes):\n        \"\"\"\n        Returns a valid Nodes message in response to the referenced incoming\n        message.\n        \"\"\"\n        msg_dict = {\n            'uuid': message.uuid,\n            'recipient': message.sender,\n            'sender': self.public_key,\n            'reply_port': self.reply_port,\n            'version': self.version,\n            'nodes': nodes,\n        }\n        seal = get_seal(msg_dict, self.private_key)\n        msg_dict['seal'] = seal\n        msg_dict['message'] = 'nodes'\n        return from_dict(msg_dict)\n\n    def send_store(self, contact, key, value, timestamp, expires,\n                   created_with, public_key, name, signature):\n        \"\"\"\n        Sends a Store message to the given contact. The value contained within\n        the message is stored against a key derived from the public_key and\n        name. Furthermore, the message is cryptographically signed using the\n        value, timestamp, expires, name and meta values.\n        \"\"\"\n        msg_dict = {\n            'uuid': str(uuid4()),\n            'recipient': contact.public_key,\n            'sender': self.public_key,\n            'reply_port': self.reply_port,\n            'version': self.version,\n            'key': key,\n            'value': value,\n            'timestamp': timestamp,\n            'expires': expires,\n            'created_with': created_with,\n            'public_key': public_key,\n            'name': name,\n            'signature': signature,\n        }\n        seal = get_seal(msg_dict, self.private_key)\n        msg_dict['seal'] = seal\n        msg_dict['message'] = 'store'\n        message = from_dict(msg_dict)\n        return self.send_message(contact, message)\n\n    def send_find(self, contact, target, message_type):\n        \"\"\"\n        Sends a Find[Node|Value] message to the given contact with the\n        intention of obtaining information at the given target key. The type of\n        find message is specified by message_type.\n\n        This method is called by an instance of the Lookup class.\n        \"\"\"\n        msg_dict = {\n            'uuid': str(uuid4()),\n            'recipient': contact.public_key,\n            'sender': self.public_key,\n            'reply_port': self.reply_port,\n            'version': self.version,\n            'key': target,\n        }\n        seal = get_seal(msg_dict, self.private_key)\n        msg_dict['seal'] = seal\n        if message_type is FindNode:\n            msg_dict['message'] = 'findnode'\n        else:\n            msg_dict['message'] = 'findvalue'\n        message = from_dict(msg_dict)\n        return self.send_message(contact, message)\n\n    def _store_to_nodes(self, nearest_nodes, duplicate, key, value, timestamp,\n                        expires, created_with, public_key, name, signature):\n        \"\"\"\n        Given a list of nearest nodes will return a list of send_store based\n        tasks for the item based upon the args to be stored in the DHT at\n        those locations. The list will contain up to \"duplicate\" number of\n        pending tasks.\n        \"\"\"\n        # Guards to ensure meaningful duplication.\n        if duplicate < 1:\n            raise ValueError('Duplication count may not be less than 1')\n        if len(nearest_nodes) < 1:\n            raise ValueError('Empty list of nearest nodes.')\n\n        list_of_tasks = []\n        for contact in nearest_nodes[:duplicate]:\n            uuid, task = self.send_store(contact, key, value, timestamp,\n                                         expires, created_with, public_key,\n                                         name, signature)\n            list_of_tasks.append(task)\n        return list_of_tasks\n\n    def replicate(self, duplicate, key, value, timestamp, expires,\n                  created_with, public_key, name, signature):\n        \"\"\"\n        Will replicate item to \"duplicate\" number of nodes in the distributed\n        hash table. Returns a task that will fire with a list of send_store\n        tasks when \"duplicate\" number of closest nodes have been identified.\n\n        Obviously, the list can be consumed by asycnio.wait or asyncio.gather\n        to fire when the store commands have completed.\n        \"\"\"\n        if duplicate < 1:\n            # Guard to ensure meaningful duplication count. This may save\n            # time.\n            raise ValueError('Duplication count may not be less than 1')\n\n        result = asyncio.Future()\n        compound_key = construct_key(public_key, name)\n        lookup = Lookup(FindNode, compound_key, self, self.event_loop)\n        if lookup.done():\n            # If we get here it's because lookup couldn't start due to an\n            # empty routing table.\n            result.set_exception(lookup.exception())\n            return result\n\n        def on_result(r, duplicate=duplicate, result=result, key=key,\n                      value=value, timestamp=timestamp, expires=expires,\n                      created_with=created_with, public_key=public_key,\n                      name=name, signature=signature):\n            \"\"\"\n            To be called when the lookup completes.\n\n            If successful, send a store message to \"duplicate\" number of\n            contacts in the list of the close nodes have been found have by\n            the lookup and resolve the \"result\" Future with the resulting\n            list of pending tasks.\n\n            If there was an error simply pass the exception on via the\n            Future representing the result.\n            \"\"\"\n            try:\n                contacts = r.result()\n                tasks = self._store_to_nodes(contacts, duplicate, key, value,\n                                             timestamp, expires, created_with,\n                                             public_key, name, signature)\n                result.set_result(tasks)\n            except Exception as ex:\n                result.set_exception(ex)\n\n        lookup.add_done_callback(on_result)\n        return result\n\n    def retrieve(self, key):\n        \"\"\"\n        Given a key, will try to retrieve associated value from the distributed\n        hash table. Returns a Future that will resolve when the operation is\n        complete or failed.\n\n        As the original Kademlia explains:\n\n        \"For caching purposes, once a lookup succeeds, the requesting node\n        stores the <key, value> pair at the closest node it observed to the\n        key that did not return the value.\"\n\n        This method adds a callback to the NodeLookup to achieve this end.\n        \"\"\"\n        lookup = Lookup(FindValue, key, self, self.event_loop)\n        if lookup.done():\n            # If we get here it's because lookup couldn't start due to an\n            # empty routing table.\n            return lookup\n\n        def cache_result(lookup):\n            \"\"\"\n            Called once the lookup resolves in order to store the item at the\n            node closest to the key that did not return the value. If the\n            lookup encountered an exception then no further action is taken.\n            \"\"\"\n            if lookup.exception():\n                return\n            caching_contact = None\n            for candidate in lookup.shortlist:\n                if candidate in lookup.contacted:\n                    caching_contact = candidate\n                    break\n            if caching_contact:\n                log.info(\"Caching to {}\".format(caching_contact))\n                result = lookup.result()\n                self.send_store(caching_contact, lookup.target, result.value,\n                                result.timestamp, result.expires,\n                                result.created_with, result.public_key,\n                                result.name, result.signature)\n\n        lookup.add_done_callback(cache_result)\n        return lookup\n\n    def refresh(self):\n        \"\"\"\n        A periodically called method that will check and refresh the k-buckets\n        in the node's routing table.\n        \"\"\"\n        refresh_ids = self.routing_table.get_refresh_list()\n        log.info('Refreshing buckets with ids: {}'.format(refresh_ids))\n        for network_id in refresh_ids:\n            Lookup(FindNode, network_id, self, self.event_loop)\n        # schedule the next refresh.\n        self.event_loop.call_later(REFRESH_INTERVAL, self.refresh)\n\n    def republish(self, item_key):\n        \"\"\"\n        Periodically called to check and republish a locally stored item to\n        the wider network.\n\n        From the original Kademlia paper:\n\n        \"To ensure the persistence of key-value pairs, nodes must periodically\n        republish keys. Otherwise, two phenomena may cause lookups for valid\n        keys to fail. First, some of the k nodes that initially get a key-value\n        pair when it is published may leave the network. Second, new nodes may\n        join the network with IDs closer to some published key than the nodes\n        on which the key-value pair was originally published. In both cases,\n        the nodes with a key-value pair must republish it so as once again to\n        ensure it is available on the k nodes closest to the key.\n\n        To compensate for nodes leaving the network, Kademlia republishes each\n        key-value pair once an hour. A naive implementation of this strategy\n        would require many messages - each of up to k nodes storing a key-value\n        pair would perform a node lookup followed by k - 1 STORE RPCs every\n        hour. Fortunately, the republish process can be heavily optimized.\n        First, when a node receives a STORE RPC for a given key-value pair, it\n        assumes the RPC was also issued to the other k - 1 closest nodes, and\n        thus the recipient will not republish the key-value pair in the next\n        hour. This ensures that as long as republication intervals are not\n        exactly synchronized, only one node will republish a given key-value\n        pair every hour.\"\n\n        In this implementation, messages are only republished if the following\n        requirements are met:\n\n        * The item still exists in the local data store (it may have been\n        deleted in the time between the time of the call and the time the call\n        was scheduled).\n        * The item has not expired.\n        * The item has not been updated for REPLICATE_INTERVAL seconds.\n\n        Furthermore, the item is deleted from the local data store (after\n        republication) if the item has not been requested during the proceeding\n        REPLICATE_INTERVAL seconds. This ensures items are not over-cached but\n        remain stored at peer nodes whose network ids are closest to the\n        item's key.\n        \"\"\"\n        log.info('Republish check for key: {}'.format(item_key))\n        if item_key in self.data_store:\n            item = self.data_store[item_key]\n            now = time.time()\n            if item.expires > 0.0 and item.expires < now:\n                # The item has expired. If the item's expiry is 0 (or less)\n                # then the item should never expire.\n                del self.data_store[item_key]\n                log.info('{} expired. Deleted from local data store.'\n                         .format(item_key))\n            else:\n                updated = self.data_store.updated(item_key)\n                accessed = self.data_store.accessed(item_key)\n                update_delta = now - updated\n                access_delta = now - accessed\n                replicated = False\n                if update_delta > REPLICATE_INTERVAL:\n                    # The item needs republishing because it hasn't been\n                    # updated within the specified time interval.\n                    log.info('Republishing item {}.'.format(item_key))\n                    self.replicate(K, item.key, item.value, item.timestamp,\n                                   item.expires, item.created_with,\n                                   item.public_key, item.name, item.signature)\n                    replicated = True\n                # Re-schedule the republication check.\n                handler = self.event_loop.call_later(REPLICATE_INTERVAL,\n                                                     self.republish, item_key)\n                if access_delta > REPLICATE_INTERVAL:\n                    # The item has not been accessed for a while so, if\n                    # required, replicate the item and then remove it from the\n                    # local data store. Remember to cancel the scheduled\n                    # republication check.\n                    log.info('Removing {} due to lack of activity.'\n                             .format(item_key))\n                    if not replicated:\n                        self.replicate(K, item.key, item.value,\n                                       item.timestamp, item.expires,\n                                       item.created_with, item.public_key,\n                                       item.name, item.signature)\n                    del self.data_store[item_key]\n                    handler.cancel()\n        else:\n            log.info('{} is no longer in local data store. Cancelled.'\n                     .format(item_key))\ndrogulus/net/netstring.py\nLENGTH, DATA, COMMA = range(3)\nNUMBER = re.compile('(\\d*)(:?)')\n    MAX_LENGTH = 1024 * 1024 * 12  # 12mb-ish\nclass NetstringParseError(ValueError):\nclass NetstringProtocol(asyncio.Protocol):\nclass NetstringConnector(Connector):\n    def __init__(self, connector, node):\n    def string_received(self, data):\n    def connection_made(self, transport):\n    def handle_data(self):\n    def handle_comma(self):\n    def handle_length(self):\n    def data_received(self, data):\n    def send_string(self, data):\n    def __init__(self, event_loop):\n    def _send_message_with_protocol(self, message, protocol):\n    def send(self, contact, message, sender):\n        def on_connect(task, contact=contact, message=message, nc=self,\n                       delivered=delivered):\n    def receive(self, raw, sender, handler, protocol):\ndrogulus/dht/messages.py\ndef from_dict(data):\n    \"\"\"\n    Returns an instance of the correct message class given the data dict.\n    Encapsulates a variety of cleaning and checking of the raw data from\n    the (potentially dangerous) external network.\n    \"\"\"\n    message = data['message']\n    # Explicit is better than implicit (Zen of Python).\n    if message == 'ok':\n        return make_message(OK, data)\n    elif message == 'store':\n        return make_message(Store, data)\n    elif message == 'findnode':\n        return make_message(FindNode, data)\n    elif message == 'nodes':\n        return make_message(Nodes, data)\n    elif message == 'findvalue':\n        return make_message(FindValue, data)\n    elif message == 'value':\n        return make_message(Value, data)\n    else:\n        # Unknown request.\n        raise ValueError('{} is not a valid message type.'.format(message))\n", "answers": ["        msg = OK('uuid', 'recipient', 'sender', 9999, 'version', 'seal')"], "length": 3673, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "55de8b6b4fc8329418880d20919787526f8a140bfc8248d1"}
{"input": "package net.ttddyy.dsproxy.asserts.api;\nimport net.ttddyy.dsproxy.asserts.BatchExecutionEntry;\nimport net.ttddyy.dsproxy.asserts.CallableBatchExecution;\nimport net.ttddyy.dsproxy.asserts.CallableBatchExecutionEntry;\nimport net.ttddyy.dsproxy.asserts.CallableExecution;\nimport net.ttddyy.dsproxy.asserts.PreparedBatchExecution;\nimport net.ttddyy.dsproxy.asserts.PreparedBatchExecutionEntry;\nimport net.ttddyy.dsproxy.asserts.PreparedExecution;\nimport net.ttddyy.dsproxy.asserts.ProxyTestDataSource;\nimport net.ttddyy.dsproxy.asserts.QueryExecution;\nimport net.ttddyy.dsproxy.asserts.StatementBatchExecution;\nimport net.ttddyy.dsproxy.asserts.StatementExecution;\nimport javax.sql.DataSource;\nimport java.sql.JDBCType;\nimport java.sql.Types;\nimport java.util.List;\nimport java.util.Map;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\n\n\n\n/**\n * API compilation check with assertEquals.\n *\n * @author Tadaya Tsuyukubo\n */\npublic class SimpleAssertionApiCheck {\n\n    private DataSource actualDataSource;\n\n    public void dataSource() {\n        // tag::datasource[]\n        ProxyTestDataSource ds = new ProxyTestDataSource(actualDataSource);\n\n        // ... perform application logic with database ...\n\n        // execution count\n        assertEquals(3, ds.getQueryExecutions().size());\n        assertEquals(3, ds.getStatements().size());\n        assertEquals(3, ds.getBatchStatements().size());\n        assertEquals(3, ds.getPrepareds().size());\n        assertEquals(3, ds.getBatchPrepareds().size());\n        assertEquals(3, ds.getCallables().size());\n        assertEquals(3, ds.getBatchCallables().size());\n        // end::datasource[]\n    }\n\n    public void queryExecution() {\n        // tag::query[]\n        ProxyTestDataSource ds = new ProxyTestDataSource(actualDataSource);\n\n        // ... perform application logic with database ...\n\n        // each execution\n        QueryExecution qe = ds.getQueryExecutions().get(0);\n        assertTrue(qe.isSuccess());\n        assertTrue(qe.isBatch());\n        assertTrue(\"is statement\", qe instanceof StatementExecution);", "context": "src/main/java/net/ttddyy/dsproxy/asserts/PreparedBatchExecution.java\npublic class PreparedBatchExecution extends BaseQueryExecution implements QueryHolder, BatchParameterHolder, BatchExecution {\n\n    private String query;\n    private List<BatchExecutionEntry> batchExecutionEntries = new ArrayList<>();\n\n    @Override\n    public boolean isBatch() {\n        return true;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    @Override\n    public List<BatchExecutionEntry> getBatchExecutionEntries() {\n        return this.batchExecutionEntries;\n    }\n\n    public boolean addBatchExecutionEntry(PreparedBatchExecutionEntry entry) {\n        return this.batchExecutionEntries.add(entry);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public List<PreparedBatchExecutionEntry> getPrepareds() {\n\n        return (List<PreparedBatchExecutionEntry>) (List<?>) this.batchExecutionEntries;\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/BatchExecutionEntry.java\npublic interface BatchExecutionEntry {\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/CallableBatchExecutionEntry.java\npublic class CallableBatchExecutionEntry implements BatchExecutionEntry, ParameterByIndexHolder, ParameterByNameHolder, OutParameterHolder {\n\n    private SortedSet<ParameterKeyValue> parameters = new TreeSet<>();\n\n    @Override\n    public SortedSet<ParameterKeyValue> getAllParameters() {\n        return this.parameters;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_PARAM);\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetNullParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_NULL);\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getOutParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.REGISTER_OUT);\n    }\n\n    @Override\n    public Map<String, Object> getSetParamsByName() {\n        return toKeyNameMap(filterByKeyType(getSetParams(), ParameterKey.ParameterKeyType.BY_NAME));\n    }\n\n    @Override\n    public Map<Integer, Object> getSetParamsByIndex() {\n        return toKeyIndexMap(\n                filterByKeyType(getSetParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public Map<String, Integer> getSetNullParamsByName() {\n        return toKeyNameMap(\n                filterByKeyType(getSetNullParams(), ParameterKey.ParameterKeyType.BY_NAME));\n    }\n\n    @Override\n    public Map<Integer, Integer> getSetNullParamsByIndex() {\n        return toKeyIndexMap(\n                filterByKeyType(getSetNullParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n\n    }\n\n    @Override\n    public Map<String, Object> getOutParamsByName() {\n        return toKeyNameMap(filterByKeyType(getOutParams(), ParameterKey.ParameterKeyType.BY_NAME));\n    }\n\n    @Override\n    public Map<Integer, Object> getOutParamsByIndex() {\n        return toKeyIndexMap(\n                filterByKeyType(getOutParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public List<String> getParamNames() {\n        List<String> names = new ArrayList<>();\n        names.addAll(getSetParamsByName().keySet());\n        names.addAll(getSetNullParamsByName().keySet());\n        return names;\n    }\n\n    @Override\n    public List<Integer> getParamIndexes() {\n        List<Integer> indexes = new ArrayList<>();\n        indexes.addAll(getSetParamsByIndex().keySet());\n        indexes.addAll(getSetNullParamsByIndex().keySet());\n        return indexes;\n    }\n\n    @Override\n    public List<String> getOutParamNames() {\n        return new ArrayList<>(getOutParamsByName().keySet());\n    }\n\n    @Override\n    public List<Integer> getOutParamIndexes() {\n        return new ArrayList<>(getOutParamsByIndex().keySet());\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/PreparedExecution.java\npublic class PreparedExecution extends BaseQueryExecution implements QueryHolder, ParameterByIndexHolder {\n\n    private String query;\n    private SortedSet<ParameterKeyValue> parameters = new TreeSet<>();\n\n    @Override\n    public boolean isBatch() {\n        return false;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getAllParameters() {\n        return this.parameters;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_PARAM);\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetNullParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_NULL);\n    }\n\n    @Override\n    public Map<Integer, Object> getSetParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public Map<Integer, Integer> getSetNullParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetNullParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public List<Integer> getParamIndexes() {\n        List<Integer> indexes = new ArrayList<>();\n        indexes.addAll(getSetParamsByIndex().keySet());\n        indexes.addAll(getSetNullParamsByIndex().keySet());\n        return indexes;\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/StatementBatchExecution.java\npublic class StatementBatchExecution extends BaseQueryExecution implements QueriesHolder, BatchExecution {\n\n    private List<String> queries = new ArrayList<>();\n\n    @Override\n    public boolean isBatch() {\n        return true;\n    }\n\n    @Override\n    public List<String> getQueries() {\n        return this.queries;\n    }\n\n    public void setQueries(List<String> queries) {\n        this.queries = queries;\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/StatementExecution.java\npublic class StatementExecution extends BaseQueryExecution implements QueryHolder {\n\n    private String query;\n\n    @Override\n    public boolean isBatch() {\n        return false;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/QueryExecution.java\npublic interface QueryExecution {\n\n    boolean isSuccess();\n\n    boolean isBatch();\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/PreparedBatchExecutionEntry.java\npublic class PreparedBatchExecutionEntry implements BatchExecutionEntry, ParameterByIndexHolder {\n\n    private SortedSet<ParameterKeyValue> parameters = new TreeSet<>();\n\n    @Override\n    public SortedSet<ParameterKeyValue> getAllParameters() {\n        return this.parameters;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_PARAM);\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetNullParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_NULL);\n    }\n\n\n    @Override\n    public Map<Integer, Object> getSetParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public Map<Integer, Integer> getSetNullParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetNullParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public List<Integer> getParamIndexes() {\n        List<Integer> indexes = new ArrayList<>();\n        indexes.addAll(getSetParamsByIndex().keySet());\n        indexes.addAll(getSetNullParamsByIndex().keySet());\n        return indexes;\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/ProxyTestDataSource.java\npublic class ProxyTestDataSource extends ProxyDataSource {\n\n    private QueryExecutionFactoryListener queryExecutionFactoryListener = new QueryExecutionFactoryListener();\n\n\n    public ProxyTestDataSource() {\n        initialize();\n    }\n\n    public ProxyTestDataSource(DataSource dataSource) {\n        super(dataSource);\n        initialize();\n    }\n\n    private void initialize() {\n        this.getProxyConfig().getQueryListener().addListener(this.queryExecutionFactoryListener);\n    }\n\n    public void reset() {\n        this.queryExecutionFactoryListener.reset();\n    }\n\n    public List<StatementExecution> getStatements() {\n        return getQueryExecutionsFilteredBy(StatementExecution.class);\n    }\n\n    public StatementExecution getFirstStatement() {\n        return getFirstQueryExecution(StatementExecution.class);\n    }\n\n    public StatementExecution getLastStatement() {\n        return getLastQueryExecution(StatementExecution.class);\n    }\n\n    public List<StatementBatchExecution> getBatchStatements() {\n        return getQueryExecutionsFilteredBy(StatementBatchExecution.class);\n    }\n\n    public StatementBatchExecution getFirstBatchStatement() {\n        return getFirstQueryExecution(StatementBatchExecution.class);\n    }\n\n    public StatementBatchExecution getLastBatchStatement() {\n        return getLastQueryExecution(StatementBatchExecution.class);\n    }\n\n    public List<PreparedExecution> getPrepareds() {\n        return getQueryExecutionsFilteredBy(PreparedExecution.class);\n    }\n\n    public PreparedExecution getFirstPrepared() {\n        return getFirstQueryExecution(PreparedExecution.class);\n    }\n\n    public PreparedExecution getLastPrepared() {\n        return getLastQueryExecution(PreparedExecution.class);\n    }\n\n    public List<PreparedBatchExecution> getBatchPrepareds() {\n        return getQueryExecutionsFilteredBy(PreparedBatchExecution.class);\n    }\n\n    public PreparedBatchExecution getFirstBatchPrepared() {\n        return getFirstQueryExecution(PreparedBatchExecution.class);\n    }\n\n    public PreparedBatchExecution getLastBatchPrepared() {\n        return getLastQueryExecution(PreparedBatchExecution.class);\n    }\n\n    public List<CallableExecution> getCallables() {\n        return getQueryExecutionsFilteredBy(CallableExecution.class);\n    }\n\n    public CallableExecution getFirstCallable() {\n        return getFirstQueryExecution(CallableExecution.class);\n    }\n\n    public CallableExecution getLastCallable() {\n        return getLastQueryExecution(CallableExecution.class);\n    }\n\n    public List<CallableBatchExecution> getBatchCallables() {\n        return getQueryExecutionsFilteredBy(CallableBatchExecution.class);\n    }\n\n    public CallableBatchExecution getFirstBatchCallable() {\n        return getFirstQueryExecution(CallableBatchExecution.class);\n    }\n\n    public CallableBatchExecution getLastBatchCallable() {\n        return getLastQueryExecution(CallableBatchExecution.class);\n    }\n\n\n    @SuppressWarnings(\"unchecked\")\n    private <T extends QueryExecution> List<T> getQueryExecutionsFilteredBy(Class<T> classToFilter) {\n        List<T> result = new ArrayList<>();\n        for (QueryExecution queryExecution : getQueryExecutions()) {\n            if (classToFilter.isAssignableFrom(queryExecution.getClass())) {\n                result.add((T) queryExecution);\n            }\n        }\n        return result;\n    }\n\n    private <T extends QueryExecution> T getFirstQueryExecution(Class<T> classToFilter) {\n        List<T> filtered = getQueryExecutionsFilteredBy(classToFilter);\n        if (filtered.isEmpty()) {\n            return null;\n        }\n        return filtered.get(0);\n    }\n\n    private <T extends QueryExecution> T getLastQueryExecution(Class<T> classToFilter) {\n        List<T> filtered = getQueryExecutionsFilteredBy(classToFilter);\n        if (filtered.isEmpty()) {\n            return null;\n        }\n        return filtered.get(filtered.size() - 1);\n    }\n\n    public List<QueryExecution> getQueryExecutions() {\n        return this.queryExecutionFactoryListener.getQueryExecutions();\n    }\n\n    public QueryExecutionFactoryListener getQueryExecutionFactoryListener() {\n        return this.queryExecutionFactoryListener;\n    }\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/CallableBatchExecution.java\npublic class CallableBatchExecution extends BaseQueryExecution implements BatchParameterHolder, QueryHolder, BatchExecution {\n\n    private String query;\n\n    private List<BatchExecutionEntry> batchExecutionEntries = new ArrayList<>();\n\n    @Override\n    public boolean isBatch() {\n        return true;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    @Override\n    public List<BatchExecutionEntry> getBatchExecutionEntries() {\n        return this.batchExecutionEntries;\n    }\n\n    public boolean addBatchExecutionEntry(CallableBatchExecutionEntry entry) {\n        return this.batchExecutionEntries.add(entry);\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/CallableExecution.java\npublic class CallableExecution extends BaseQueryExecution implements QueryHolder, ParameterByIndexHolder, ParameterByNameHolder, OutParameterHolder {\n\n    private String query;\n    private SortedSet<ParameterKeyValue> parameters = new TreeSet<>();\n\n\n    @Override\n    public boolean isBatch() {\n        return false;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getAllParameters() {\n        return this.parameters;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_PARAM);\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetNullParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_NULL);\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getOutParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.REGISTER_OUT);\n    }\n\n    @Override\n    public Map<String, Object> getSetParamsByName() {\n        return toKeyNameMap(filterByKeyType(getSetParams(), ParameterKey.ParameterKeyType.BY_NAME));\n    }\n\n    @Override\n    public Map<Integer, Object> getSetParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public Map<String, Integer> getSetNullParamsByName() {\n        return toKeyNameMap(filterByKeyType(getSetNullParams(), ParameterKey.ParameterKeyType.BY_NAME));\n    }\n\n    @Override\n    public Map<Integer, Integer> getSetNullParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetNullParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public Map<String, Object> getOutParamsByName() {\n        return toKeyNameMap(filterByKeyType(getOutParams(), ParameterKey.ParameterKeyType.BY_NAME));\n    }\n\n    @Override\n    public Map<Integer, Object> getOutParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getOutParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public List<String> getParamNames() {\n        List<String> names = new ArrayList<>();\n        names.addAll(getSetParamsByName().keySet());\n        names.addAll(getSetNullParamsByName().keySet());\n        return names;\n    }\n\n    @Override\n    public List<Integer> getParamIndexes() {\n        List<Integer> indexes = new ArrayList<>();\n        indexes.addAll(getSetParamsByIndex().keySet());\n        indexes.addAll(getSetNullParamsByIndex().keySet());\n        return indexes;\n    }\n\n    @Override\n    public List<String> getOutParamNames() {\n        return new ArrayList<>(getOutParamsByName().keySet());\n    }\n\n    @Override\n    public List<Integer> getOutParamIndexes() {\n        return new ArrayList<>(getOutParamsByIndex().keySet());\n    }\n\n}\n", "answers": ["        assertTrue(\"is batch statement\", qe instanceof StatementBatchExecution);"], "length": 1159, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "bfc6597058f482395c67717d1a0b4fdd39f7659c0d73f851"}
{"input": "package net.ttddyy.dsproxy.asserts.hamcrest;\nimport net.ttddyy.dsproxy.asserts.CallableBatchExecution;\nimport net.ttddyy.dsproxy.asserts.CallableExecution;\nimport net.ttddyy.dsproxy.asserts.PreparedBatchExecution;\nimport net.ttddyy.dsproxy.asserts.PreparedExecution;\nimport net.ttddyy.dsproxy.asserts.ProxyTestDataSource;\nimport net.ttddyy.dsproxy.asserts.QueryExecution;\nimport net.ttddyy.dsproxy.asserts.QueryHolder;\nimport net.ttddyy.dsproxy.asserts.StatementBatchExecution;\nimport net.ttddyy.dsproxy.asserts.StatementExecution;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.batchCallableCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.batchPreparedCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.batchStatementCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.callableCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.callableOrBatchCallableCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.deleteCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.executionCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.executions;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.insertCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.otherCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.preparedCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.preparedOrBatchPreparedCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.selectCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.statementCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.statementOrBatchStatementCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.totalQueryCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.ProxyTestDataSourceAssertions.updateCount;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.QueryExecutionAssertions.failure;\nimport static net.ttddyy.dsproxy.asserts.hamcrest.QueryExecutionAssertions.success;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.Assert.fail;\nimport static org.mockito.BDDMockito.given;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.withSettings;\n\n\n\n\n\n/**\n * @author Tadaya Tsuyukubo\n * @since 1.0\n */\npublic class ProxyTestDataSourceAssertionsTest {\n\n\n    @Test\n    public void testExecutionSuccess() {\n        StatementExecution se = new StatementExecution();\n        se.setSuccess(true);\n\n        ProxyTestDataSource ds = new ProxyTestDataSource();\n        ds.getQueryExecutions().add(se);\n\n        Assert.assertThat(ds, executions(0, success()));\n        Assert.assertThat(ds, executions(0, is(success())));\n    }\n\n    @Test\n    public void testExecutionFail() {\n        StatementExecution se = new StatementExecution();\n        se.setSuccess(false);\n\n        ProxyTestDataSource ds = new ProxyTestDataSource();\n        ds.getQueryExecutions().add(se);\n", "context": "src/main/java/net/ttddyy/dsproxy/asserts/ProxyTestDataSource.java\npublic class ProxyTestDataSource extends ProxyDataSource {\n\n    private QueryExecutionFactoryListener queryExecutionFactoryListener = new QueryExecutionFactoryListener();\n\n\n    public ProxyTestDataSource() {\n        initialize();\n    }\n\n    public ProxyTestDataSource(DataSource dataSource) {\n        super(dataSource);\n        initialize();\n    }\n\n    private void initialize() {\n        this.getProxyConfig().getQueryListener().addListener(this.queryExecutionFactoryListener);\n    }\n\n    public void reset() {\n        this.queryExecutionFactoryListener.reset();\n    }\n\n    public List<StatementExecution> getStatements() {\n        return getQueryExecutionsFilteredBy(StatementExecution.class);\n    }\n\n    public StatementExecution getFirstStatement() {\n        return getFirstQueryExecution(StatementExecution.class);\n    }\n\n    public StatementExecution getLastStatement() {\n        return getLastQueryExecution(StatementExecution.class);\n    }\n\n    public List<StatementBatchExecution> getBatchStatements() {\n        return getQueryExecutionsFilteredBy(StatementBatchExecution.class);\n    }\n\n    public StatementBatchExecution getFirstBatchStatement() {\n        return getFirstQueryExecution(StatementBatchExecution.class);\n    }\n\n    public StatementBatchExecution getLastBatchStatement() {\n        return getLastQueryExecution(StatementBatchExecution.class);\n    }\n\n    public List<PreparedExecution> getPrepareds() {\n        return getQueryExecutionsFilteredBy(PreparedExecution.class);\n    }\n\n    public PreparedExecution getFirstPrepared() {\n        return getFirstQueryExecution(PreparedExecution.class);\n    }\n\n    public PreparedExecution getLastPrepared() {\n        return getLastQueryExecution(PreparedExecution.class);\n    }\n\n    public List<PreparedBatchExecution> getBatchPrepareds() {\n        return getQueryExecutionsFilteredBy(PreparedBatchExecution.class);\n    }\n\n    public PreparedBatchExecution getFirstBatchPrepared() {\n        return getFirstQueryExecution(PreparedBatchExecution.class);\n    }\n\n    public PreparedBatchExecution getLastBatchPrepared() {\n        return getLastQueryExecution(PreparedBatchExecution.class);\n    }\n\n    public List<CallableExecution> getCallables() {\n        return getQueryExecutionsFilteredBy(CallableExecution.class);\n    }\n\n    public CallableExecution getFirstCallable() {\n        return getFirstQueryExecution(CallableExecution.class);\n    }\n\n    public CallableExecution getLastCallable() {\n        return getLastQueryExecution(CallableExecution.class);\n    }\n\n    public List<CallableBatchExecution> getBatchCallables() {\n        return getQueryExecutionsFilteredBy(CallableBatchExecution.class);\n    }\n\n    public CallableBatchExecution getFirstBatchCallable() {\n        return getFirstQueryExecution(CallableBatchExecution.class);\n    }\n\n    public CallableBatchExecution getLastBatchCallable() {\n        return getLastQueryExecution(CallableBatchExecution.class);\n    }\n\n\n    @SuppressWarnings(\"unchecked\")\n    private <T extends QueryExecution> List<T> getQueryExecutionsFilteredBy(Class<T> classToFilter) {\n        List<T> result = new ArrayList<>();\n        for (QueryExecution queryExecution : getQueryExecutions()) {\n            if (classToFilter.isAssignableFrom(queryExecution.getClass())) {\n                result.add((T) queryExecution);\n            }\n        }\n        return result;\n    }\n\n    private <T extends QueryExecution> T getFirstQueryExecution(Class<T> classToFilter) {\n        List<T> filtered = getQueryExecutionsFilteredBy(classToFilter);\n        if (filtered.isEmpty()) {\n            return null;\n        }\n        return filtered.get(0);\n    }\n\n    private <T extends QueryExecution> T getLastQueryExecution(Class<T> classToFilter) {\n        List<T> filtered = getQueryExecutionsFilteredBy(classToFilter);\n        if (filtered.isEmpty()) {\n            return null;\n        }\n        return filtered.get(filtered.size() - 1);\n    }\n\n    public List<QueryExecution> getQueryExecutions() {\n        return this.queryExecutionFactoryListener.getQueryExecutions();\n    }\n\n    public QueryExecutionFactoryListener getQueryExecutionFactoryListener() {\n        return this.queryExecutionFactoryListener;\n    }\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> executionCount(int count) {\n    String msg = \"queryExecutions size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getQueryExecutions().size();\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/QueryExecutionAssertions.java\npublic static Matcher<QueryExecution> success() {\n    return new TypeSafeMatcher<QueryExecution>() {\n        @Override\n        protected boolean matchesSafely(QueryExecution item) {\n            return item.isSuccess();\n        }\n\n        @Override\n        public void describeTo(Description description) {\n            description.appendText(\"success\");\n        }\n\n        @Override\n        protected void describeMismatchSafely(QueryExecution item, Description mismatchDescription) {\n            mismatchDescription.appendText(\"was failure\");\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/QueryExecution.java\npublic interface QueryExecution {\n\n    boolean isSuccess();\n\n    boolean isBatch();\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/CallableBatchExecution.java\npublic class CallableBatchExecution extends BaseQueryExecution implements BatchParameterHolder, QueryHolder, BatchExecution {\n\n    private String query;\n\n    private List<BatchExecutionEntry> batchExecutionEntries = new ArrayList<>();\n\n    @Override\n    public boolean isBatch() {\n        return true;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    @Override\n    public List<BatchExecutionEntry> getBatchExecutionEntries() {\n        return this.batchExecutionEntries;\n    }\n\n    public boolean addBatchExecutionEntry(CallableBatchExecutionEntry entry) {\n        return this.batchExecutionEntries.add(entry);\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> insertCount(int count) {\n    return new QueryTypeCountMatcher(QueryType.INSERT, count);\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/CallableExecution.java\npublic class CallableExecution extends BaseQueryExecution implements QueryHolder, ParameterByIndexHolder, ParameterByNameHolder, OutParameterHolder {\n\n    private String query;\n    private SortedSet<ParameterKeyValue> parameters = new TreeSet<>();\n\n\n    @Override\n    public boolean isBatch() {\n        return false;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getAllParameters() {\n        return this.parameters;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_PARAM);\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetNullParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_NULL);\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getOutParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.REGISTER_OUT);\n    }\n\n    @Override\n    public Map<String, Object> getSetParamsByName() {\n        return toKeyNameMap(filterByKeyType(getSetParams(), ParameterKey.ParameterKeyType.BY_NAME));\n    }\n\n    @Override\n    public Map<Integer, Object> getSetParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public Map<String, Integer> getSetNullParamsByName() {\n        return toKeyNameMap(filterByKeyType(getSetNullParams(), ParameterKey.ParameterKeyType.BY_NAME));\n    }\n\n    @Override\n    public Map<Integer, Integer> getSetNullParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetNullParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public Map<String, Object> getOutParamsByName() {\n        return toKeyNameMap(filterByKeyType(getOutParams(), ParameterKey.ParameterKeyType.BY_NAME));\n    }\n\n    @Override\n    public Map<Integer, Object> getOutParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getOutParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public List<String> getParamNames() {\n        List<String> names = new ArrayList<>();\n        names.addAll(getSetParamsByName().keySet());\n        names.addAll(getSetNullParamsByName().keySet());\n        return names;\n    }\n\n    @Override\n    public List<Integer> getParamIndexes() {\n        List<Integer> indexes = new ArrayList<>();\n        indexes.addAll(getSetParamsByIndex().keySet());\n        indexes.addAll(getSetNullParamsByIndex().keySet());\n        return indexes;\n    }\n\n    @Override\n    public List<String> getOutParamNames() {\n        return new ArrayList<>(getOutParamsByName().keySet());\n    }\n\n    @Override\n    public List<Integer> getOutParamIndexes() {\n        return new ArrayList<>(getOutParamsByIndex().keySet());\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> totalQueryCount(final int count) {\n    return new TypeSafeMatcher<ProxyTestDataSource>() {\n        @Override\n        protected boolean matchesSafely(ProxyTestDataSource item) {\n            int actualSize = countQueries(item);\n            return count == actualSize;\n        }\n\n        @Override\n        public void describeTo(Description description) {\n            // expected clause\n            description.appendText(count + \" query executions\");\n        }\n\n        @Override\n        protected void describeMismatchSafely(ProxyTestDataSource item,\n                Description mismatchDescription) {\n            // but was clause\n            int actualSize = countQueries(item);\n            mismatchDescription.appendText(\"was \" + actualSize + \" query executions\");\n        }\n\n        private int countQueries(ProxyTestDataSource ds) {\n            int count = 0;\n            for (QueryExecution queryExecution : ds.getQueryExecutions()) {\n                if (queryExecution instanceof QueryHolder) {\n                    count++;\n                } else if (queryExecution instanceof QueriesHolder) {\n                    count += ((QueriesHolder) queryExecution).getQueries().size();\n                }\n            }\n            return count;\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> selectCount(int count) {\n    return new QueryTypeCountMatcher(QueryType.SELECT, count);\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> preparedCount(int count) {\n    String msg = \"PreparedExecution size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getPrepareds().size();\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/PreparedExecution.java\npublic class PreparedExecution extends BaseQueryExecution implements QueryHolder, ParameterByIndexHolder {\n\n    private String query;\n    private SortedSet<ParameterKeyValue> parameters = new TreeSet<>();\n\n    @Override\n    public boolean isBatch() {\n        return false;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getAllParameters() {\n        return this.parameters;\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_PARAM);\n    }\n\n    @Override\n    public SortedSet<ParameterKeyValue> getSetNullParams() {\n        return filterBy(this.parameters, ParameterKeyValue.OperationType.SET_NULL);\n    }\n\n    @Override\n    public Map<Integer, Object> getSetParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public Map<Integer, Integer> getSetNullParamsByIndex() {\n        return toKeyIndexMap(filterByKeyType(getSetNullParams(), ParameterKey.ParameterKeyType.BY_INDEX));\n    }\n\n    @Override\n    public List<Integer> getParamIndexes() {\n        List<Integer> indexes = new ArrayList<>();\n        indexes.addAll(getSetParamsByIndex().keySet());\n        indexes.addAll(getSetNullParamsByIndex().keySet());\n        return indexes;\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> preparedOrBatchPreparedCount(int count) {\n    String msg = \"PreparedExecution or PreparedBatchExecution size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getPrepareds().size() + actual.getBatchPrepareds().size();\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> updateCount(int count) {\n    return new QueryTypeCountMatcher(QueryType.UPDATE, count);\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> executions(final int index,\n        Matcher<? super QueryExecution> queryExecutionMatcher) {\n    return new CompositeMatcher<ProxyTestDataSource, QueryExecution>(queryExecutionMatcher) {\n\n        @Override\n        protected boolean validateByThisMatcher(ProxyTestDataSource item, Description expected,\n                Description actual) {\n            List<QueryExecution> queryExecutions = item.getQueryExecutions();\n            int size = queryExecutions.size();\n            if (size - 1 < index) {\n                expected.appendText(\"queryExecutions[\" + index + \"] exists\");\n                actual.appendText(\"queryExecutions[] size was \" + size);\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public QueryExecution getValue(ProxyTestDataSource actual) {\n            return actual.getQueryExecutions().get(index);\n        }\n\n        @Override\n        public String getSubMatcherFailureDescriptionPrefix() {\n            return \"queryExecutions[\" + index + \"] \";\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> statementOrBatchStatementCount(int count) {\n    String msg = \"StatementExecution or StatementBatchExecution size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getStatements().size() + actual.getBatchStatements().size();\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> batchStatementCount(int count) {\n    String msg = \"StatementBatchExecution size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getBatchStatements().size();\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> batchCallableCount(int count) {\n    String msg = \"CallableBatchExecution size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getBatchCallables().size();\n        }\n    };\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> callableOrBatchCallableCount(int count) {\n    String msg = \"CallableExecution or CallableBatchExecution size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getCallables().size() + actual.getBatchCallables().size();\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/QueryExecutionAssertions.java\npublic static Matcher<QueryExecution> failure() {\n    return new TypeSafeMatcher<QueryExecution>() {\n        @Override\n        protected boolean matchesSafely(QueryExecution item) {\n            return !item.isSuccess();\n        }\n\n        @Override\n        public void describeTo(Description description) {\n            description.appendText(\"failure\");\n        }\n\n        @Override\n        protected void describeMismatchSafely(QueryExecution item, Description mismatchDescription) {\n            mismatchDescription.appendText(\"was success\");\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> deleteCount(int count) {\n    return new QueryTypeCountMatcher(QueryType.DELETE, count);\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/PreparedBatchExecution.java\npublic class PreparedBatchExecution extends BaseQueryExecution implements QueryHolder, BatchParameterHolder, BatchExecution {\n\n    private String query;\n    private List<BatchExecutionEntry> batchExecutionEntries = new ArrayList<>();\n\n    @Override\n    public boolean isBatch() {\n        return true;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    @Override\n    public List<BatchExecutionEntry> getBatchExecutionEntries() {\n        return this.batchExecutionEntries;\n    }\n\n    public boolean addBatchExecutionEntry(PreparedBatchExecutionEntry entry) {\n        return this.batchExecutionEntries.add(entry);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public List<PreparedBatchExecutionEntry> getPrepareds() {\n\n        return (List<PreparedBatchExecutionEntry>) (List<?>) this.batchExecutionEntries;\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> callableCount(int count) {\n    String msg = \"CallableExecution size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getCallables().size();\n        }\n    };\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> statementCount(int count) {\n    String msg = \"StatementExecution size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getStatements().size();\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/StatementExecution.java\npublic class StatementExecution extends BaseQueryExecution implements QueryHolder {\n\n    private String query;\n\n    @Override\n    public boolean isBatch() {\n        return false;\n    }\n\n    @Override\n    public String getQuery() {\n        return this.query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/StatementBatchExecution.java\npublic class StatementBatchExecution extends BaseQueryExecution implements QueriesHolder, BatchExecution {\n\n    private List<String> queries = new ArrayList<>();\n\n    @Override\n    public boolean isBatch() {\n        return true;\n    }\n\n    @Override\n    public List<String> getQueries() {\n        return this.queries;\n    }\n\n    public void setQueries(List<String> queries) {\n        this.queries = queries;\n    }\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/QueryHolder.java\npublic interface QueryHolder {\n\n    String getQuery();\n\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> batchPreparedCount(int count) {\n    String msg = \"PreparedBatchExecution size\";\n    return new FeatureMatcher<ProxyTestDataSource, Integer>(equalTo(count), msg, msg) {\n        @Override\n        protected Integer featureValueOf(ProxyTestDataSource actual) {\n            return actual.getBatchPrepareds().size();\n        }\n    };\n}\nsrc/main/java/net/ttddyy/dsproxy/asserts/hamcrest/ProxyTestDataSourceAssertions.java\npublic static Matcher<ProxyTestDataSource> otherCount(int count) {\n    return new QueryTypeCountMatcher(QueryType.OTHER, count);\n}\n", "answers": ["        Assert.assertThat(ds, executions(0, failure()));"], "length": 1584, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "7dbb5a61c0e857a45b3b3794820f886ae1754e99f66669c8"}
{"input": "import struct\nimport imp\nimport os\nimport time\nfrom twisted.internet import reactor, task, protocol\nfrom twisted.internet.error import CannotListenError\nfrom twisted.internet.defer import inlineCallbacks, returnValue\nfrom twisted.enterprise import adbapi\nfrom twistar.registry import Registry\nfrom floranet.models.config import Config\nfrom floranet.models.device import Device\nfrom floranet.models.application import Application\nfrom floranet.imanager import interfaceManager\nfrom floranet.lora.wan import LoraWAN, GatewayMessage, Txpk\nfrom floranet.lora.mac import (MACMessage, MACDataDownlinkMessage, JoinAcceptMessage,\n      MACCommand, LinkCheckAns, LinkADRReq)\nfrom floranet.lora.bands import AU915, US915, EU868\nfrom floranet.lora.crypto import aesEncrypt\nfrom floranet.web.webserver import WebServer\nfrom floranet.util import txsleep, euiString, devaddrString, intPackBytes, intUnpackBytes\nfrom floranet.log import log\n            returnValue(None)\n        \n        # Find the set difference between the two lists, return lowest free address\n        diff = self.otarange.difference(devaddrs)\n        returnValue(diff.pop())\n\n    @inlineCallbacks\n    def _getActiveDevice(self, devaddr):\n        \"\"\"Searches active devices for the given devaddr.\n        \n        Args:\n            devaddr (int): A 32 bit end device network address (DevAddr).\n        \n        Returns:\n            A device object if successful, None otherwise.\n        \"\"\"\n        # Search active device for devaddr\n        device = yield Device.find(where=['devaddr = ?', devaddr], limit=1)\n        returnValue(device)\n        \n    def _checkDuplicateMessage(self, message):\n        \"\"\"Checks for duplicate gateway messages.\n        \n        We check for duplicate messages that may have been sent from\n        different gateways that heard the same LoRa PHY payload. The\n        period to check is defined by the config parameter duplicateperod.\n        Filtering uses the arrival time and MIC as cache entries -\n        duplicate frames will have the same MIC.\n\n        Args:\n            message (MACMessage): LoRa MAC message object\n        \n        Returns:\n            True if a duplicate is found, otherwise False.\n        \"\"\"\n        # Search the cache for matching MIC entries within\n        # self.config.duplicateperiod. Each entry in the\n        # cache list is a tuple (mic, timestamp)\n        if self.config.duplicateperiod == 0:\n            return False\n        mark = time.time()\n        duplicate = next((True for e in self.message_cache if\n                      e[0] == message.mic and \n                      e[1] + self.config.duplicateperiod > mark\n                      ), False)\n        if not duplicate:\n            self.message_cache.append((message.mic, mark))\n        return duplicate\n    \n    def _cleanMessageCache(self):\n        \"\"\"Removes stale entries from the message cache.\n        \n        This method is periodically called to limit the growth of\n        the message_cache list.\n        \"\"\"\n        mark = time.time()\n        self.message_cache = [x for x in self.message_cache if not\n                              (x[1] + self.config.duplicateperiod) < mark]\n\n    def _manageMACCommandQueue(self):\n        \"\"\"Removes expired MAC Commands from the queue.\n        \n        This method is periodically called to limit the queue size.\n        \"\"\"\n        mark = time.time()\n        self.commands = [x for x in self.commands if not\n                              (x[0] + self.config.macqueuelimit) < mark]\n        \n    @inlineCallbacks\n    def _processADRRequests(self):\n        \"\"\"Updates devices with target data rate, and sends ADR requests.\n        \n        This method is called every adrcycletime seconds as a looping task.\n        \n        \"\"\"        \n        # If we are running, return\n        if self.adrprocessing is True:\n            returnValue(None)\n        \n        self.adrprocessing = True\n        \n        devices = yield Device.all()\n        sendtime = time.time()\n        \n        for device in devices:\n            # Check this device is enabled\n            if not device.enabled:\n                continue\n            \n            # Check ADR is enabled\n            if not device.adr:\n                continue\n            \n            # Set the target data rate \n            target = device.getADRDatarate(self.band, self.config.adrmargin)\n            \n            # If no target, or the current data rate is the target, continue\n            if target is None:\n                continue\n            \n            # Set the device adr_datr\n            yield device.update(adr_datr=target)\n            \n            # Only send a request if we need to change\n            if device.tx_datr == device.adr_datr:\n                continue\n            \n            # If we are queueing commands, create the command and add to the queue.\n            # Replace any existing requests.\n            if self.config.macqueueing:\n                log.info(\"Queuing ADR MAC Command\")\n                command = self._createLinkADRRequest(device)\n                self._dequeueMACCommand(device.deveui, command)\n                self._queueMACCommand(device.deveui, command)\n                continue\n\n            # Check we have reached the next scheduled ADR message time\n            scheduled = sendtime + self.config.adrmessagetime\n            current = time.time()\n            if current < scheduled:\n", "context": "floranet/lora/mac.py\nclass MACDataDownlinkMessage(MACDataMessage):\n    \"\"\"A LoRa MAC Data Uplink Message.\n    \n    LoRa uplink data messages carry a PHY payload\n    consiting of a single octet header (mhdr),\n    a MAC payload (macpayload) and a 4-octet message\n    integrity code (mic).\n    \n    Attributes:\n        confirmed (bool): True if Confirmed Data Down\n        devaddr (int): Device address (DevAddr)\n        key (int): Encryption key (NwkSkey or AppSKey)\n        \n    \"\"\"\n    def __init__(self, devaddr, key, fcnt, adrenable, fopts,\n                 fport, frmpayload, acknowledge=False):\n        \"\"\"MACDataDownlinkMessage initialisation method.\n        \n        \"\"\"\n        self.devaddr = devaddr\n        self.key = key\n        self.mhdr = MACHeader(UN_DATA_DOWN, LORAWAN_R1)\n        ack = 1 if acknowledge is True else 0\n        adr = 1 if adrenable is True else 0\n        foptslen = len(fopts)\n        fhdr = FrameHeader(devaddr, adr, 0, ack, foptslen, fcnt,\n                           fopts, fpending=0, fdir='down')\n        self.payload = MACPayload(fhdr, fport, frmpayload)\n        self.mic = None\n        \n    def encode(self):\n        \"\"\"Create a binary representation of MACMessage object.\n        \n        Returns:\n            String of packed data.\n        \n        \"\"\"\n        # Calculate the MIC.\n        # The MIC is calculated as cmac = aes128_cmac(NwkSKey, B0 | msg)\n        # MIC = cmac[0:3]\n        # msg is defined as: MHDR | FHDR | FPort | FRMPayload\n        # B0 is defined as:\n        # 1 byte 0x49 | 4 bytes 0x00 | 1 byte dir=0 for uplink, 1 for downlink\n        # 4 bytes devaddr | 4 bytes fcntup or fcntdown\n        # 1 byte 0x00 | 1 bytes len\n        msg = self.mhdr.encode() + self.payload.encode()\n        B0 = struct.pack('<BLBLLBB', int('0x49', 16), 0, 1,\n                         self.devaddr, self.payload.fhdr.fcnt, 0, len(msg))\n        data = B0 + msg\n        # Create the MIC over the entire message\n        self.mic = aesEncrypt(intPackBytes(self.key, 16), data,\n                              mode='CMAC')[0:4]\n        msg += self.mic\n        return msg\n\n    def encrypt(self, key):\n        super(MACDataDownlinkMessage, self).encrypt(key, dir=1)\nfloranet/util.py\ndef devaddrString(devaddr):\n    \"\"\"Convert a 32 bit Lora DevAddr to string hex representation.\n    \n    Args:\n        devaddr (int): a 6 byte Lora DevAddr.\n    \n    Returns:\n        The hex string representation.\n    \"\"\"\n    return intHexString(devaddr, 4)\nfloranet/models/config.py\nclass Config(Model):\n    \"\"\"NetServer Configuration model\n    \n    Model representing the netserver configuration.\n    \n    Attributes:\n        name(str): Server name\n        listen (str): Interfaces to listen on\n        port (int): LoRaWAN port\n        webport (int): Web server port\n        apitoken (str): REST API authentication token\n        freqband (str): Frequency band\n        netid (int): Network ID\n        duplicateperiod (int): Period (seconds) used to check for duplicate messages\n        fcrelaxed (bool): Relaxed frame count mode\n        otaastart (int): OTAA range start address\n        otaaend (int): OTAA range end address\n        macqueuing (bool): Queue downlink MAC commands \n        macqueuelimit (int): Time (seconds) that MAC Commands can remain in the queue\n        adrenable (bool): Adapative data rate enable\n        adrmargin (int): SNR margin added to the calculation of adaptive data rate steps\n        adrcycletime (int): Period (seconds) for ADR control cycle\n        adrmessagetime (int): Minimum inter-ADR message time (seconds)\n    \"\"\"\n    \n    TABLENAME = 'config'\n    \n    @classmethod\n    @inlineCallbacks\n    def loadFactoryDefaults(self):\n        \"\"\"Populate NetServer configuration defaults.\"\"\"\n        \n        # Server configuration\n        c = Config()\n        c.defaults()\n        \n        yield c.save()\n        returnValue(c)\n\n    def check(self):\n        \"\"\"Validate the system configuration object.\n            \n        Returns:\n            valid (bool), message(dict): (True, empty) on success,\n            (False, error message dict) otherwise.\n        \"\"\"\n        messages = {}\n\n        if self.name == '':\n            messages['listen'] = 'Invalid name'\n            \n        if self.listen != '' and not (validIPv4Address(self.listen) or\n                validIPv6Address(self.listen)):\n            messages['listen'] = 'Invalid IP address'\n            \n        if self.port < 1 or self.port > 65535:\n            messages['port'] = 'Invalid server port'\n\n        if self.webport < 1 or self.webport > 65535:\n            messages['webport'] = 'Invalid web port'\n\n        if self.webport < 1 or self.webport > 65535:\n            messages['webport'] = 'Invalid web port'\n            \n        if self.freqband not in LoraBand.BANDS:\n            messages['freqband'] = 'Invalid frequency band'\n            \n        if self.netid < 1 or self.netid > int('0xFFFFFF', 16):\n            messages['netid'] = 'Invalid network ID'\n\n        if self.duplicateperiod < 1 or self.duplicateperiod > 60:\n            messages['netid'] = 'Invalid duplicate period'\n        \n        if self.otaastart < 1 or self.otaastart > int('0xFFFFFFFF', 16):\n            messages['otaastart'] = 'Invalid OTAA start address'\n        elif self.otaaend < 1 or self.otaaend > int('0xFFFFFFFF', 16) \\\n             or self.otaaend <= self.otaastart:\n            messages['otaastart'] = 'Invalid OTAA end address'\n        \n        if self.macqueuelimit < 60 or self.macqueuelimit > 86400:\n            messages['macqueuelimit'] = 'Invalid MAC queueing limit'\n\n        if self.adrmargin < 0.0:\n            messages['adrmargin'] = 'Invalid ADR SNR margin'\n        \n        if self.adrcycletime < 60:\n            messages['adrcycletime'] = 'Invalid ADR cycle time'\n            \n        if self.adrmessagetime < 1:\n            messages['adrmessagetime'] = 'Invalid ADR message time'\n \n        valid = not any(messages)\n        return valid, messages\n            \n    def defaults(self):\n        \"\"\"Populate server configuration defaults\n        \n        \"\"\"\n        self.name = 'floranet'\n        self.listen = '0.0.0.0'\n        self.port = 1700\n        self.webport = 8000\n        self.apitoken = 'IMxHj@wfNkym@*+V85Rs^G<QXMD~p[eaX3S=_D8f7{z0q{GN'\n        self.freqband = 'US915'\n        self.netid = int('0x010203', 16)\n        self.duplicateperiod = 10\n        self.fcrelaxed = True        \n        self.otaastart = int('0x06000001', 16)\n        self.otaaend = int('0x060FFFFF', 16)\n        self.macqueueing = True\n        self.macqueuelimit = 120\n        self.adrenable = True\n        self.adrmargin = 0.0\n        self.adrcycletime = 9000\n        self.adrmessagetime = 10\n    \n    def valid(self):\n        pass\nfloranet/models/application.py\nclass Application(Model):\n    \"\"\"LoRa application class\n    \n    Model representing a LoRa application.\n    \n    Attributes:\n        name (str): a user friendly name for the application\n        domain (str): optional customer domain string\n        appeui (int): global application ID (IEEE EUI64)\n        appnonce (int): A unique ID provided by the network server\n        appkey (int): AES-128 application secret key\n        fport (int): Port field used for this application\n    \"\"\"\n    \n    TABLENAME = 'applications'\n    BELONGSTO = [{'name': 'appinterface', 'class_name': 'AppInterface'}]\n    HASMANY = [{'name': 'properties', 'class_name': 'AppProperty'}]\n        \n    @inlineCallbacks\n    def valid(self):\n        \"\"\"Validate an application object.\n            \n        Returns:\n            valid (bool), message(dict): (True, empty) on success,\n            (False, error message dict) otherwise.\n        \"\"\"\n        messages = {}\n\n        # Check for unique appkeys\n        duplicate = yield Application.exists(where=['appkey = ? AND appeui != ?',\n                                                    self.appkey, self.appeui])\n        if duplicate:\n            messages['appkey'] = \"Duplicate application key exists: appkey \" \\\n                \"must be unique.\"\n        \n        # Check the app interface exists\n        if self.appinterface_id:\n            exists = yield AppInterface.exists(where=['id = ?', self.appinterface_id])\n            if not exists:\n                messages['appinterface_id'] = \"Application interface {} does not \" \\\n                \"exist.\".format(self.appinterface_id)\n\n        valid = not any(messages)\n        returnValue((valid, messages))\nfloranet/lora/crypto.py\ndef aesEncrypt(key, data, mode=None):\n    \"\"\"AES encryption function\n    \n    Args:\n        key (str): packed 128 bit key\n        data (str): packed plain text data\n        mode (str): Optional mode specification (CMAC)\n        \n    Returns:\n        Packed encrypted data string\n    \"\"\"\n    if mode == 'CMAC':\n        # Create AES cipher using key argument, and encrypt data\n        cipher = python_AES.new(key, python_AES.MODE_CMAC)\n    elif mode == None:\n        cipher = python_AES.new(key)\n    return cipher.encrypt(data)\nfloranet/lora/wan.py\nclass Txpk(object):\n    \"\"\"A Gateway Txpk (downstream) JSON object.\n    \n    The root JSON object shall contain zero or more txpk\n    objects. See Gateway to Server Interface Definition\n    Section 6.2.4.\n    \n    Attributes:\n        imme (bool): If true, the gateway is commanded to\n                     transmit the frame immediately \n        tmst (int): If \"imme\" is not true and \"tmst\" is present,\n                    the gateway is commanded to transmit the frame\n                    when its internal timestamp counter equals the\n                    value of \"tmst\".\n        time (str): UTC time. The precision is one microsecond. The\n                    format is ISO 8601 compact format. If \"imme\" is\n                    false or not present and \"tmst\" is not present,\n                    the gateway is commanded to transmit the frame at\n                    this time.\n        freq (float): The centre frequency on when the frame is to\n                    be transmitted in units of MHz.\n        rfch (int): The antenna on which the gateway is commanded\n                    to transmit the frame.\n        powe (int): The output power which what the gateway is\n                    commanded to transmit the frame.\n        modu (str): Modulation technique - \"LORA\" or \"FSK\".\n        datr (str): Datarate identifier. For Lora, comprised of\n                    \"SFnBWm where n is the spreading factor and\n                    m is the frame's bandwidth in kHz.\n        codr (str): ECC code rate as \"k/n\" where k is carried\n                    bits and n is total bits received.\n        ipol (bool): If true, commands gateway to invert the\n                    polarity of the transmitted bits. LoRa Server sets\n                    value to true when \"modu\" equals \"LORA\", otherwise\n                    the value is omitted.\n        size (int): Number of octets in the received frame.\n        data (str): Frame payload encoded in Base64. Padding characters\n                    shall not be not added\n        ncrc (bool): If not false, disable physical layer CRC generation\n                    by the transmitter.\n    \"\"\"\n    \n    def __init__(self, imme=None, tmst=None, time=None, freq=None,\n                 rfch=None, powe=None, modu=None, datr=None, codr=None,\n                 ipol=None, size=None, data=None, ncrc=None):\n        \"\"\"Txpk initialisation method.\n        \n        \"\"\"\n        self.imme = imme\n        self.tmst = tmst \n        self.time = time\n        self.freq = freq\n        self.rfch = rfch\n        self.powe = powe\n        self.modu = modu\n        self.datr = datr\n        self.codr = codr\n        self.ipol = ipol  \n        self.size = size\n        self.data = data\n        self.ncrc = ncrc\n        self.keys = ['imme', 'tmst', 'time', 'freq', 'rfch',\n                    'powe', 'modu', 'datr', 'codr', 'ipol',\n                    'size', 'data', 'ncrc']\n        # Base64 encode data, no padding\n        if self.data is not None:\n            self.size = len(self.data)\n            self.data = base64.b64encode(self.data)\n            # Remove padding\n            if self.data[-2:] == '==':\n                self.data = self.data[:-2]\n            elif self.data[-1:] == '=':\n                self.data = self.data[:-1]\n        else:\n            self.size = 0\n    \n    def encode(self):\n        \"\"\"Create a JSON string from Txpk object\n        \n        \"\"\"\n        # Create dict from attributes. Maintain added order\n        jd = {'txpk': OrderedDict()}\n        for key in self.keys:\n            val = getattr(self, key)\n            if val is not None:\n                jd['txpk'][key] = val\n        return json.dumps(jd, separators=(',', ':'))\nfloranet/models/device.py\nclass Device(Model):\n    \"\"\"LoRa device class model.\n        \n    Attributes:\n        name (str): Device name\n        devclass (str): Device class\n        devaddr (int): 32 bit end device address (DevAddr)\n        deveui (int): Global end-device ID (IEEE EUI64)\n        otaa (bool): Over the air activated flag\n        appeui (int): Application unique identifer (AppEUI)\n        nwkskey (int): 128 bit network session key (NwkSKey)\n        appskey (int): 128 bit application session key (AppSKey)\n        tx_chan (int): Transmit channel number\n        tx_datr (str): Transmit data rate\n        adr (bool): Device ADR control\n        adr_datr (str): Target ADR data rate\n        gw_addr (str): The gateway IP address\n        fcntup (int): Uplink frame  counter received from the device\n        fcntdown (int): Downlink frame counter sent to to the device\n        fcnterror (bool): Frame count error flag\n        snr_average (float): Calculated ADR average SNR\n        snr (list): SNR readings array\n        devnonce (list): Devnonce values from join requests\n        created (str): Timestamp when the device object is created\n        updated (str): Timestamp when the device object is updated\n    \"\"\"\n    \n    TABLENAME = 'devices'\n    \n    @inlineCallbacks\n    def valid(self, server):\n        \"\"\"Validate a device object.\n        \n        Args:\n            server (NetServer): Network server object\n            \n        Returns:\n            valid (bool), message(dict): (True, empty) on success,\n            (False, error message dict) otherwise.\n        \"\"\"\n        messages = {}\n        \n        # Check we have a valid class\n        if not self.devclass in {'a', 'c'}:\n            messages['class'] = \"Invalid device class\"\n        \n        # For ABP device, check for unique devaddr and keys, and devaddr\n        # validity\n        if not self.otaa:\n            check = {'devaddr': self.devaddr, 'nwkskey': self.nwkskey,\n                     'appskey': self.appskey}\n            for attr,v in check.items():\n                exists = yield Device.exists(where=[attr + ' = ? AND deveui != ?',\n                                                    v, self.deveui])\n                if exists:\n                    messages[attr] = \"Device {} {} \".format(attr, v) + \\\n                                     \"currently exists. Must be unique.\"\n\n            # Check devaddr is correctly defined within the network range\n            if not 'devaddr' in messages:\n                if not server.checkDevaddr(self.devaddr):\n                    messages['devaddr'] = \"Device devaddr \" + \\\n                            \"{} \".format(devaddrString(self.devaddr)) + \\\n                            \"is not within the configured network address range\"\n\n            # Check devaddr is not within the OTAA range\n            if not 'devaddr' in messages:\n                if self.devaddr >= server.config.otaastart and \\\n                 self.devaddr <= server.config.otaaend:\n                    messages['devaddr'] = \"Device devaddr \" \\\n                            \"{} \".format(devaddrString(self.devaddr)) + \\\n                             \"is within configured OTAA address range\"\n\n        valid = not any(messages)\n        returnValue((valid, messages))\n    \n    def isClassA(self):\n        \"\"\"Check if device is class A\"\"\"\n        return self.devclass == 'a'\n    \n    def isClassB(self):\n        \"\"\"Check if device is class B\"\"\"\n        return self.devclass == 'b'\n\n    def isClassC(self):\n        \"\"\"Check if device is class C\"\"\"\n        return self.devclass == 'c'\n    \n    def checkDevNonce(self, message):\n        \"\"\"Check the devnonce is not being repeated\n        \n        Args:\n            message (JoinRequestMessage): Join request message\n            \n        Returns True if message is valid, otherwise False\n        \"\"\"\n        if self.devnonce is None:\n            self.devnonce = []\n        \n        # If the  devnonce has been seen previously, return False\n        if message.devnonce in self.devnonce:\n            return False\n        # If we have exceeded the history length, pop the oldest devnonce\n        if len(self.devnonce) >= 20:\n            self.devnonce.pop(0)\n        self.devnonce.append(message.devnonce)\n        return True\n            \n    def checkFrameCount(self, fcntup, maxfcntgap, relaxed):\n        \"\"\"Sync fcntup counter with received value\n        \n        The value received must have incremented compared to current\n        counter value and must be less than the gap value specified\n        by MAX_FCNT_GAP after considering rollovers. Otherwise,\n        too many frames have been lost.\n        \n        Args:\n            fcntup (int): Received fcntup value\n            maxfcntgap (int): MAX_FCNT_GAP, band specific\n            relaxed (bool): frame count relaxed flag\n            \n        Returns:\n            True if fcntup is within the limit, otherwise False.\n        \n        \"\"\"\n        # Relxed mode. If fcntup <=1 then set fcntdown to zero\n        # and the device fcntup to match.\n        if relaxed and fcntup <= 1:\n            self.fcntdown = 0\n            self.fcntup = fcntup\n            self.fcnterror = False\n        elif fcntup > (self.fcntup + maxfcntgap):\n            self.fcnterror = True\n        elif fcntup < self.fcntup and (65535 - self.fcntup + fcntup) > maxfcntgap:\n            self.fcnterror = True\n        else:\n            self.fcntup = fcntup\n            self.fcnterror = False\n        \n        return not self.fcnterror\n\n    def updateSNR(self, lsnr):\n        \"\"\"Update Device SNR measures\n        \n        Updates the most recent received device SNR measure.\n        We keep 11 samples for each device, and use the\n        snr_pointer attribute to maintain the current sample\n        index.\n        \n        Args:\n            lsnr (float): Latest link SNR measure.\n        \n        \"\"\"\n        # Check we have a SNR measure\n        if lsnr is None:\n            return\n        \n        # Check if this is the first SNR reading\n        if self.snr is None:\n            self.snr = []\n            \n        # Update the current SNR reading\n        if len(self.snr) == 11:\n            self.snr.pop(0)\n        self.snr.append(lsnr)\n        \n        # Update the average SNR, ensure we have at least 6 readings\n        if len(self.snr) >= 6:\n            self.snr_average = sum(self.snr[-6:])/6.0\n\n    def getADRDatarate(self, band, margin):\n        \"\"\"Determine the optimal datarate that will achieve the\n        objective margin in the given band.\n        \n        We assume each increase in datarate step (e.g. DR0 to DR1) requires\n        an additional 3dB in SNR.\n        \n        Args:\n            band (Band): Band in use\n            margin (float): Target margin in dB\n        \n        Returns:\n            Optimal datarate as a string on success, otherwise None.\n        \"\"\"\n        if not hasattr(self, 'snr_average') or self.snr_average is None:\n            return None\n        \n        # Target thresholds that the average must exceed. Note range(0,4)\n        # refers to the first four (upstream) indices of the band.datarate\n        # list. These are DR0, DR1, DR2, DR3\n        thresholds = [float(i) * 3.0 + margin for i in range(0,4)]\n\n        # If we have an average SNR less than the lowest threshold,\n        # return the lowest DR\n        if self.snr_average < thresholds[0]:\n            return band.datarate[0]\n        \n        # Find the index of lowest threshold that the SNR average just exceeds\n        i = [n for n,v in enumerate(thresholds) if self.snr_average >= v][-1]\n        return band.datarate[i]\nfloranet/lora/wan.py\nclass LoraWAN(protocol.DatagramProtocol):\n    \"\"\"LoRaWAN Gateway to Server Interface.\n    \n    Attributes:\n        server (NetServer): The Lora Network Server\n        port (Port): Twsited TCP port\n        gateways (list): List of configured Gateways \n    \n    \"\"\"\n        \n    def __init__(self, server):\n        \"\"\"Initialize a LoRaWAN gateway network interface.\n        \n        Args:\n            server: FloraNetServer object.        \n        \"\"\"\n        self.server = server\n        self.port = None\n        self.gateways = []\n    \n    @inlineCallbacks  \n    def start(self):\n        \"\"\"Start the gateway network interface\"\"\"\n        self.gateways = yield Gateway.all()\n        self.port = reactor.listenUDP(self.server.config.port, self,\n                          interface=self.server.config.listen)\n        returnValue(True)\n    \n    @inlineCallbacks\n    def restart(self):\n        \"\"\"Restart the gateway network interface\"\"\"\n        yield self.port.stopListening()\n        self.port = reactor.listenUDP(self.server.config.port, self,\n                          interface=self.server.config.listen)\n        \n    def addGateway(self, gateway):\n        \"\"\"Add a gateway to the active list\n        \n        Args:\n            gateway (Gateway): The gateway to add\n        \n        \"\"\"\n        self.gateways.append(gateway)\n        log.info(\"Added gateway {host} to the active list\", host=gateway.host)\n\n    def updateGateway(self, host, gateway):\n        \"\"\"Update a gateway\n        \n        Args:\n            host (str): The host id to update\n            gateway (Gateway): The updated gateway        \n        \"\"\"\n        index = next((i for i,g in enumerate(self.gateways)\n                      if g.host == host), None)\n        if index is not None:\n            for a in {'host', 'name', 'enabled', 'power'}:\n                setattr(self.gateways[index], a, getattr(gateway, a))\n            log.info(\"Updated gateway {host}\", host=gateway.host)\n\n    def deleteGateway(self, gateway):\n        \"\"\"Delete a gateway from the active list\n        \n        Args:\n            gateway (Gateway): The gateway to delete\n        \n        \"\"\"\n        index = next((i for i,g in enumerate(self.gateways)\n                      if g.host == gateway.host), None)\n        if index is not None:\n            del(self.gateways[index])\n            log.info(\"Removed gateway {host} from the active list\", host=gateway.host)\n\n    def gateway(self, host):\n        \"\"\"Get the enabled gateway for host address\n        \n        Args:\n            host (str): The host address\n        \n        Returns:\n            Gateway object if found abd enabled, None otherwise.\n        \"\"\"\n        gateway = next((g for g in self.gateways if g.host == host), None)\n        return gateway\n    \n    def datagramReceived(self, data, (host, port)):\n        \"\"\"Handle an inbound LoraWAN datagram.\n        \n        Called from the Twisted reactor on receipt of an inbound\n        UDP datagram. This method verified the gateway and\n        dispatches the inbound GWMP types PULL_DATA and PUSH_DATA.\n        \n        Args:\n            data (str): UDP packet data.\n            (host, port) (tuple): Gateway IP address and port.\n        \n        \"\"\"\n        log.debug(\"Received {data} from {host}:{port}\", data=repr(data),\n                 host=host, port=port)\n        gateway = self.gateway(host)\n        if gateway is None:\n            log.error(\"Gateway message from unknown gateway {host}\", host=host)\n            return\n        if not gateway.enabled:\n            log.error(\"Gateway message from disabled gateway {host}\", host=host)\n            return\n        try:\n            message = GatewayMessage.decode(data, (host, port))\n        except (UnsupportedMethod, DecodeError) as e:\n            if isinstance(e, UnsupportedMethod):\n                log.error(\"Gateway message unsupported method error \"\n                        \"{errstr}\", errstr=str(e))\n            elif isinstance(e, DecodeError):\n                log.error(\"Gateway message decode error \"\n                        \"{errstr}\", errstr=str(e))\n            return\n        gateway.eui = message.gatewayEUI\n        if message.id == PULL_DATA:\n            log.debug(\"Received PULL_DATA from %s:%d\" % (host, port))\n            gateway.port = port\n            self._acknowledgePullData(message)\n        elif message.id == PUSH_DATA:\n            log.debug(\"Received PUSH_DATA from %s:%d\" % (host, port))\n            self._acknowledgePushData(message)\n            self.server.processPushDataMessage(message, gateway)\n        elif message.id == TX_ACK:\n            # TODO: Version 2 only\n            pass\n    \n    def sendPullResponse(self, request, txpk):\n        \"\"\"\"Send a PULL_RESP message to a gateway.\n        \n        The PULL_RESP message transports its payload, a JSON object,\n        from the LoRa network server to the LoRa gateway. The length\n        of a PULL_RESP message shall not exceed 1000 octets.\n        \n        Args:\n            request (GatewayMessage): The decoded Pull Request\n            txpk (Txpk): The txpk to be transported\n        \"\"\"\n        # Create a new PULL_RESP message. We must send to the\n        # gateway's PULL_DATA port.\n        host = request.remote[0]\n        gateway = self.gateway(host)\n        if gateway is None:\n            log.error(\"Pull Reponse - no known gateway for {host}\",\n                      host=host)\n            return\n        if gateway.port == None:\n            log.error(\"Pull Reponse - no known port for gateway {host}\",\n                      host=host)\n            return\n        remote = (host, gateway.port)\n        m = GatewayMessage(version=request.version, token=request.token,\n                    identifier=PULL_RESP, gatewayEUI=gateway.eui,\n                    remote=remote, ptype='txpk', txpk=txpk)\n        log.debug(\"Sending PULL_RESP message to %s:%d\" % remote)\n        self._sendMessage(m)\n    \n    def _acknowledgePullData(self, request):\n        \"\"\"Acknowledge a PULL_DATA message from a gateway.\n        \n        The PULL_ACK message is used by the network server to\n        acknowledge receipt of a PULL_DATA message.\n        \n        Args:\n            request (GatewayMessage): The decoded PULL_DATA message.\n        \"\"\"\n        # Create a new PULL_ACK message\n        m = GatewayMessage(version=request.version, token=request.token,\n                    identifier=PULL_ACK, gatewayEUI=request.gatewayEUI,\n                    remote=request.remote)\n        log.debug(\"Sending PULL_ACK message to %s:%d\" % m.remote)\n        self._sendMessage(m)\n    \n    def _acknowledgePushData(self, request):\n        \"\"\"Acknowledge a PUSH_DATA message from a gateway.\n        \n        The PUSH_ACK message is used by the network server to\n        acknowledge receipt of a PUSH_DATA message.\n        \n        Args:\n            request (GatewayMessage): The decoded PUSH_DATA message.\n        \"\"\"\n        # Create a new PUSH_ACK message\n        m = GatewayMessage(version=request.version, token=request.token,\n                    identifier=PUSH_ACK, gatewayEUI=request.gatewayEUI,\n                    remote=request.remote)\n        log.debug(\"Sending PUSH_ACK message to %s:%d\" % m.remote)\n        self._sendMessage(m)\n        \n    def _sendMessage(self, message):\n        \"\"\"Encode and send a GWMP message\n        \n        Args:\n            message (GatewayMessage): Outbound gateway message\n        \"\"\"\n        # Encode and send\n        packet = message.encode()\n        (host, port) = message.remote\n        log.debug(\"Sending {packet} to {host}:{port}\", packet=repr(packet),\n                 host=host, port=port)\n        self.transport.write(packet, message.remote)\nfloranet/web/webserver.py\nclass WebServer(object):\n    \"\"\"Webserver class.\n        \n    Attributes:\n        app (Flask): Flask app instance\n        site (Site): Twisted web site\n        port (Port): Twisted UDP port\n        api (RestApi): Rest API instance\n        login (LoginManager): Flask login manager\n    \"\"\"\n    def __init__(self, server):\n        \"\"\"Initialize the web server.\n        \n        Args:\n            server: NetServer object      \n        \"\"\"\n        self.server = server\n        self.port = None\n        \n        # Create Flask app and configure\n        self.app = Flask(__name__)\n        self.app.config['ERROR_404_HELP'] = False\n\n        # Create REST API instance\n        self.restapi = RestApi(self.app, self.server)\n\n        # Create LoginManager instance and configure\n        self.login = LoginManager()\n        self.login.init_app(self.app)\n        self.login.request_loader(self.load_user)\n        \n    def start(self):\n        \"\"\"Start the Web Server \"\"\"\n        self.site = Site(WSGIResource(reactor, reactor.getThreadPool(), self.app))\n        self.port = reactor.listenTCP(self.server.config.webport, self.site)\n\n    @inlineCallbacks\n    def restart(self):\n        \"\"\"Restart the web server\"\"\"\n        yield self.port.stopListening()\n        self.port = reactor.listenTCP(self.server.config.webport, self.site)\n        \n    def load_user(self, request):\n        \"\"\"Flask login request_loader callback.\n        \n        The expected behavior is to return a User instance if\n        the provided credentials are valid, and return None\n        otherwise.\n        \n        Args:\n            request (request): Flask request object\n            \n        Returns:\n            User object on success, otherwise None\n        \"\"\"\n        # Get the token as Authorisation header or JSON parameter\n        token = request.headers.get('Authorization')\n        if token is None:\n            data = request.get_json()\n            if data is None:\n                return None\n            token = data['token'] if 'token' in data else None\n\n        # Verify the token\n        if token is not None:\n            if token.encode('utf8') == self.server.config.apitoken:\n                return User('api', None)\n\n        return None\nfloranet/log.py\nclass Log(Logger):\n    def __init__(self):\n    def start(self, console, logfile, debug):\nfloranet/util.py\ndef euiString(eui):\n    \"\"\"Convert a Lora EUI to string hex representation.\n    \n    Args:\n        eui (int): an 8 byte Lora EUI.\n    \n    Returns:\n        The hex string representation.\n    \"\"\"\n    return intHexString(eui, 8)\nfloranet/lora/bands.py\nclass AU915(US915):\n    \"\"\"Australian 915-928 ISM Band\n    \n    Subclass of US915 band. Same parameters apply, with the exception\n    of upstream channels, which are upshifted to start at 915.2 MHz\n    (channels 0 to 63) and 915.9 (channels 64 to 71).\n    \n    \"\"\"\n    def __init__(self):\n        super(AU915, self).__init__()\n        self.upstream = []\n        for i in range(0, 64):\n            self.upstream.append((9152 + 2.0 * i)/10)\n        for i in range(0, 8):\n            self.upstream.append((9159 + 16.0 * i)/10)\nfloranet/lora/bands.py\nclass US915(LoraBand):\n    \"\"\"US 902-928 ISM Band\n    \n    upstream (list): 72 upstream (from device) channels:\n                    64 channels (0 to 63) utilizing LoRa 125 kHz BW\n                    starting at 902.3 MHz and incrementing\n                    linearly by 200 kHz to 914.9 MHz.\n                    8 channels (64 to 71) utilizing LoRa 500 kHz BW\n                    starting at 903.0 MHz and incrementing linearly\n                    by 1.6 MHz to 914.2 MHz. Units of MHz\n    downstream (list): 8 channels numbered 0 to 7 utilizing\n                    LoRa 500 kHz BW starting at 923.3 MHz and incrementing\n                    linearly by 600 kHz to 927.5 MHz. Units of MHz\n    datarate (dict): Data rate configuration as per Table 18 of the\n                    LoRa specification\n    datarate_rev (dict): Reverse lookup for datarate.\n    maxpayload (dict): Maximim payload size, indexed by datarate as per\n                    Table 20 of the LoRa specification\n    rx1dr (dict): Dictionary of lists to lookup the RX1 window data rate by\n                    transmit data rate and Rx1DROffset parameters. Lookup by\n                    rx1dr[txdatarate][rx1droffset]\n    rx1droffset (int): RX1 default DR offset\n    receive_delay (dict): First and second window window receive delays\n    join_accept_delay (dict): First and second window join accept delay\n    max_fcnt_gap  (int): Maximum tolerable frame count gap.\n    maxmac (dict): List of maximum MACpayload sizes (in bytes) for each\n                    datarate.\n    maxapp (dict): List of maximum application sizes (in bytes) for each\n                    datarate.\n                    \n                    \n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize a US915 band object.\"\"\"\n\n        # Upstream channels in MHz\n        self.upstream = []\n        for i in range(0, 64):\n            self.upstream.append((9033 + 2.0 * i)/10)\n        for i in range(0, 8):\n            self.upstream.append((9030 + 16.0 * (i - 64))/10)\n        # Downstream channels in MHz\n        self.downstream = []\n        for i in range(0, 8):\n            self.downstream.append((9233 + 6.0 * i)/10)\n        self.datarate = {\n            0:  'SF10BW125',\n            1:  'SF9BW125',\n            2:  'SF8BW125',\n            3:  'SF7BW125',\n            4:  'SF8BW500',\n            8:  'SF12BW500',\n            9:  'SF11BW500',\n            10: 'SF10BW500',\n            11: 'SF9BW500',\n            12: 'SF8BW500',\n            13: 'SF7BW500'\n        }\n        self.datarate_rev = {v:k for k, v in self.datarate.items()}\n        self.txpower = {0: 30, 1: 28, 2: 26, 3: 24, 4: 22, 5: 20,\n                        6: 18, 7: 16, 8: 14, 9: 12, 10: 10 }\n        self.rx1dr = {\n                    0: [10,  9,   8,   8],\n                    1: [11,  10,  9,   8],\n                    2: [12,  11,  10,  9],\n                    3: [13,  12,  11,  10],\n                    4: [13,  13,  12,  11],\n                    8: [8,   8,   8,   8],\n                    9: [9,   8,   8,   8],\n                   10: [10,  9,   8,   8],\n                   11: [11,  10,  9,   8],\n                   12: [11,  11,  10,  9], \n                   13: [13,  12,  11,  9]  }\n        self.rx1droffset = 0\n        self.receive_delay = {1: 1, 2: 2}\n        self.join_accept_delay = {1: 5, 2: 6}\n        self.max_fcnt_gap = 16384\n        self.maxpayloadlen = {\n            0: 19,\n            1: 61,\n            2: 137,\n            3: 250,\n            4: 250,\n            8: 61,\n            9: 137,\n            10: 250,\n            11: 250,\n            12: 250,\n            13: 250 }\n        self.maxappdatalen = {\n            0: 11,\n            1: 53,\n            2: 129,\n            3: 242,\n            4: 242,\n            8: 53,\n            9: 129,\n            10: 242,\n            11: 242,\n            12: 242,\n            13: 242 }\nfloranet/lora/bands.py\nclass EU868(LoraBand):\n    \"\"\" EUROPEAN 863-870 ISM Band \n        based on LoRoWAN_Regional_Parameters_v1_0\n    \"\"\"\n    def __init__(self):\n        super(EU868, self).__init__()\n        self.upstream = [ 868.10 , 868.30 , 868.50 , 867.1 , 867.3 , 867.5 , 867.7 , 867.9 , 868.8 ]\n        self.downstream = self.upstream\n        self.datarate = {\n            0: 'SF12BW125',\n            1: 'SF11BW125',\n            2: 'SF10BW125',\n            3: 'SF9BW125',\n            4: 'SF8BW125',\n            5: 'SF7BW125',\n            6: 'SF7BW250'\n            #7: FSK ?\n        }\n        self.datarate_rev = {v:k for k, v in self.datarate.items()}\n        self.txpower = { 0:20 , 1:14 , 2:11 , 3:8 , 4:5 , 5:2 }\n        self.rx1dr = {\n            0: [ 0 , 0 , 0 , 0 , 0 , 0 ],\n            1: [ 1 , 0 , 0 , 0 , 0 , 0 ],\n            2: [ 2 , 1 , 0 , 0 , 0 , 0 ],\n            3: [ 3 , 2 , 1 , 0 , 0 , 0 ],\n            4: [ 4 , 3 , 2 , 1 , 0 , 0 ],\n            5: [ 5 , 4 , 3 , 2 , 1 , 0 ],\n            6: [ 6 , 5 , 4 , 3 , 2 , 1 ],\n            7: [ 7 , 6 , 5 , 4 , 3 , 2 ],\n        }\n        self.rx1droffset = 0\n        self.receive_delay = {1: 1, 2: 2}\n        self.join_accept_delay = {1: 5, 2: 6}\n        self.max_fcnt_gap = 16384\n        self.maxpayloadlen = {\n            0: 59,\n            1: 59,\n            2: 59,\n            3:123,\n            4:250,\n            5:250,\n            6:250,\n            7:250,\n        }\n        self.maxappdatalen = {\n            0: 51,\n            1: 51,\n            2: 51,\n            3:115,\n            4:242,\n            5:242,\n            6:242,\n            7:242\n        }\n\n    def _rx2receive(self):\n        \"\"\"Get second receive window parameters\n        RX2 (second receive window) settings uses a fixed data\n        rate and frequency. Default parameters are 869.525Mhz / DR0\n        Returns:\n            A dict of RX2 frequency, datarate string, datarate index\n        \"\"\"\n        rxindex = 0\n        return {'freq': 869.525, 'datr': self.datarate[rxindex],\n                'index': rxindex}\nfloranet/lora/mac.py\nclass MACMessage(object):\n    \"\"\"A LoRa MAC message.\n    \n    \"\"\"        \n    @classmethod\n    def decode(cls, data):\n        \"\"\"Decode the message type.\n        \n        Args:\n            data (str): UDP packet data.\n        \n        Returns:\n            MACJoinMessage or MACDataMessage on success, None otherwise.\n            \n        \"\"\"\n        # Message (PHYPayload) must be at least 1 byte\n        if len(data) < 1:\n            raise DecodeError()\n        # Decode the MAC Header\n        mhdr = MACHeader.decode(data[0])\n        # Decode the Message\n        if mhdr.mtype == JOIN_REQUEST:\n            return JoinRequestMessage.decode(mhdr, data)\n        elif mhdr.mtype == UN_DATA_UP or mhdr.mtype == CO_DATA_UP:\n            return MACDataUplinkMessage.decode(mhdr, data)\n        else:\n            return None\n\n    def isJoinRequest(self):\n        \"\"\"Check if message is a Join Request.\n        \n        Returns:\n            True on match, otherwise False.\n        \n        \"\"\"\n        return self.mhdr.mtype == JOIN_REQUEST\n    \n    def isMACCommand(self):\n        \"\"\"Check if message is a MAC Command.\n        \n        Returns:\n            True on match, otherwise False.\n        \n        \"\"\"\n        return self.payload.fport == 0\n\n    def hasMACCommands(self):\n        \"\"\"Check if the message has piggybacked MAC commands.\n        \n        Returns:\n            True on match, otherwise False.\n        \"\"\"\n        return hasattr(self, 'commands') and len(self.commands) > 0\n    \n    def isUnconfirmedDataUp(self):\n        \"\"\"Check if message is Unconfirmed Data Up.\n        \n        Returns:\n            True on match, otherwise False.\n        \n        \"\"\"\n        return self.mhdr.mtype == UN_DATA_UP\n    \n    def isConfirmedDataUp(self):\n        \"\"\"Check if message is Confirmed Data Up.\n        \n        Returns:\n            True on match, otherwise False.\n        \n        \"\"\"\n        return self.mhdr.mtype == CO_DATA_UP\nfloranet/lora/mac.py\nclass LinkADRReq(MACCommand):\n    \"\"\"With the LinkADRReq command, the network server requests an\n    end-device to perform a rate adaptation.\n    \n    Attributes:\n        length (int): Frame length\n        cid (int): Command identifier\n        datarate (int): a 4-bit integer representing the device target data\n                      rate, region specific\n        txpower (int): a 4-bit integer that defines device transmit power,\n                      region specific\n        chmask (int): a 16-bit unsigned integer that encodes the channels\n                      usable for uplink access - bit 0 is the LSB.\n        chmaskcntl (int): a 3-bit integer that controls the interpretation\n                      of the ChMask bit mask.\n        nbrep (int): a 4-bit integer defining the number of repetitions\n                      for each uplink message.\n    \"\"\"\n    length = 5\n    \n    def __init__(self, datarate, txpower, chmask, chmaskcntl, nbrep):\n        self.cid = LINKADRREQ\n        self.datarate = datarate\n        self.txpower = txpower\n        self.chmask = chmask\n        self.chmaskcntl = chmaskcntl\n        self.nbrep = nbrep\n    \n    def encode(self):\n        \"\"\"Create a binary representation of LinkADRReq object.\n        \n        Returns:\n            String of packed data.\n        \n        \"\"\"\n        datarate_txpower = 0 | (self.datarate << 4) | self.txpower\n        redundancy = 0 | (self.chmaskcntl << 4) | self.nbrep\n        data = struct.pack('<BBHB', self.cid, datarate_txpower, self.chmask, redundancy)\n        return data\nfloranet/util.py\ndef intUnpackBytes(data, endian='big'):\n    \"\"\"Convert an packed binary string representation to an integer.\n    \n    Args:\n        data (str): packed binary data\n        endian (str): endian type: 'big' or 'little'\n    \n    Returns:\n        An integer.\n    \"\"\"\n    if isinstance(data, str):\n        data = bytearray(data)\n    if endian == 'big':\n        data = reversed(data)\n    num = 0\n    for offset, byte in enumerate(data):\n        num += byte << (offset * 8)\n    return num\nfloranet/util.py\ndef txsleep(secs):\n    \"\"\"Simulate a reactor sleep\n    \n    Args:\n        secs (float): time to sleep\n    \"\"\"\n    d = Deferred()\n    reactor.callLater(secs, d.callback, None)\n    return d\nfloranet/lora/mac.py\nclass MACCommand(object):\n    \"\"\"A MAC Command.\n    \n    LoRa MAC commands consist of a command identifier (CID) of\n    1 octect followed by a possibly empty command-specific sequence\n    of octets.\n    \n    \"\"\"\n    @classmethod\n    def decode(cls, data):\n        \"\"\"Create a MACCommand object from binary representation.\n        \n        Args:\n            data (str): FRMpayload, or fopts.\n        \n        Returns:\n            MACCommand object on success, otherwise None.\n            \n        \"\"\"\n        if len(data) == 0:\n            return None\n        cid = struct.unpack('B', data[0])[0]\n        if cid == LINKCHECKREQ:\n            return LinkCheckReq.decode(data)\n        elif cid == LINKADRANS:\n            return LinkADRAns.decode(data)\n        # TODO\n        #elif cid == DUTYCYCLEANS:\n        #    return DutyCycleReq.decode(data)\n        #elif cid == RXPARAMSETUPANS:\n        #    return RxParamSetupReq.decode(data)\n        #elif cid == DEVSTATUSANS:\n        #    return DevStatusReq.decode(data)\n        #elif cid == NEWCHANNELANS:\n        #    return NewChannelReq.decode(data)\n        #elif cid == RXTIMINGSETUPANS:\n        #    return RxTimingSetupReq.decode(data)\n        else:\n            return None\n    \n        \n    def isLinkCheckReq(self):\n        \"\"\"Check if the message is a LinkCheckReq MAC Command.\n        \n        Returns:\n            True on match, otherwise False.\n        \n        \"\"\"\n        return self.cid == LINKCHECKREQ\n    \n    def isLinkADRAns(self):\n        \"\"\"Check if the message is a LinkADRAns MAC Command.\n        \n        Returns:\n            True on match, otherwise False.\n        \n        \"\"\"\n        return self.cid == LINKADRANS\nfloranet/util.py\ndef intPackBytes(n, length, endian='big'):\n    \"\"\"Convert an integer to a packed binary string representation.\n    \n    Args:\n        n (int): Integer to convert\n        length (int): converted string length\n        endian (str): endian type: 'big' or 'little'\n    \n    Returns:\n        A packed binary string.\n    \"\"\"\n    if length == 0:\n        return ''\n    h = '%x' % n\n    s = ('0'*(len(h) % 2) + h).zfill(length*2).decode('hex')\n    if endian == 'big':\n        return s\n    else:\n        return s[::-1]\nfloranet/lora/wan.py\nclass GatewayMessage(object):\n    \"\"\"A Gateway Message.\n    \n    Messages sent between the LoRa gateway and the LoRa network\n    server. The gateway message protocol operates over UDP and\n    occupies the data area of a UDP packet. See Gateway to Server\n    Interface Definition.\n    \n    Attributes:\n        version (int): Protocol version - 0x01 or 0x02\n        token (str): Arbitrary tracking value set by the gateway.\n        id (int): Identifier - see GWMP Identifiers above.\n        gatewayEUI (str): Gateway device identifier.\n        payload (str): GWMP payload.\n        remote (tuple): Gateway IP address and port.\n        ptype (str): JSON protocol top-level object type.\n\n    \"\"\"\n\n    def __init__(self, version=1, token=0, identifier=None,\n                 gatewayEUI=None, txpk=None, remote=None,\n                 ptype=None):\n        \"\"\"GatewayMessage initialisation method.\n        \n        Args:\n            version (int): GWMP version.\n            token (str): Message token.\n            id: GWMP identifier.\n            gatewayEUI: gateway device identifier.\n            payload: GWMP payload.\n            ptype (str): payload type\n            remote: (host, port)\n            \n        Raises:\n            TypeError: If payload argument is set to None.\n        \n        \"\"\"\n        self.version = version\n        self.token = token\n        self.id = identifier\n        self.gatewayEUI = gatewayEUI\n        self.payload = ''\n        self.ptype = ptype\n        self.remote = remote\n        \n        self.rxpk = None\n        self.txpk = txpk\n        self.stat = None\n    \n    @classmethod\n    def decode(cls, data, remote):\n        \"\"\"Create a Message object from binary representation.\n        \n        Args:\n            data (str): UDP packet data.\n            remote (tuple): Gateway address and port.\n        \n        Returns:\n            GatewayMessage object on success.\n            \n        \"\"\"\n        # Check length\n        if len(data) < 4:\n            raise DecodeError(\"Message too short.\")\n        # Decode header\n        (version, token, identifer) = struct.unpack('<BHB', data[:4])\n        m = GatewayMessage(version=version, token=token, identifier=identifer)\n        m.remote = remote\n        # Test versions (1 or 2) and supported message types\n        if ( m.version not in (1, 2) or \n             m.version == 1 and m.id not in (PUSH_DATA, PULL_DATA) or \n             m.version == 2 and m.id not in (PUSH_DATA, PULL_DATA, TX_ACK)\n             ):\n                raise UnsupportedMethod()\n\n        # Decode gateway EUI and payload\n        if m.id == PUSH_DATA:\n            if len(data) < 12:\n                raise DecodeError(\"PUSH_DATA message too short.\")\n            m.gatewayEUI = struct.unpack('<Q', data[4:12])[0]\n            m.payload = data[12:]\n        elif m.id == PULL_DATA:\n            if len(data) < 12:\n                raise DecodeError(\"PULL_DATA message too short.\")\n            m.gatewayEUI = struct.unpack('<Q', data[4:12])[0]\n        elif m.id == TX_ACK:\n            m.payload = data[4:]\n            \n        # Decode PUSH_DATA payload\n        if m.id == PUSH_DATA:\n            try:\n                jdata = json.loads(m.payload)\n            except ValueError:\n                raise DecodeError(\"JSON payload decode error\")\n            m.ptype = jdata.keys()[0]\n            # Rxpk payload - one or more.\n            if  m.ptype == 'rxpk':\n                m.rxpk = []\n                for r in jdata['rxpk']:\n                    rx = Rxpk.decode(r)\n                    if rx is not None:\n                        m.rxpk.append(rx)\n                if not m.rxpk:\n                    raise DecodeError(\"Rxpk payload decode error\")\n            # Stat payload\n            elif m.ptype == 'stat':\n                m.stat = Stat.decode(jdata)\n                if m.stat is None:\n                    raise DecodeError(\"Stat payload decode error\")\n            # Unknown payload type\n            else:\n                raise DecodeError(\"Unknown payload type\")\n        return m\n\n    def encode(self):\n        \"\"\"Create a binary representation of message from Message object.\n        \n        Returns:\n            String of packed data.\n        \n        \"\"\"\n        data = ''\n        if self.id == PUSH_ACK:\n            data = struct.pack('<BHB', self.version, self.token, self.id)\n        elif self.id == PULL_ACK:\n            data = struct.pack('<BHBQ', self.version, self.token, self.id,\n                               self.gatewayEUI)\n        elif self.id == PULL_RESP:\n            if self.version == 1:\n                self.token = 0\n            self.payload = self.txpk.encode()\n            data = struct.pack('<BHB', self.version, self.token, self.id) + \\\n                    self.payload\n        return data\nfloranet/lora/mac.py\nclass LinkCheckAns(MACCommand):\n    \"\"\"Used by the network server to respond to a LinkCheckReq command\n    \n    Attributes:\n        length (int): Frame length \n        cid (int): Command identifier\n        margin (int): an 8-bit unsigned integer in the range of 0..254\n                      indicating the link margin in dB of the last\n                      successfully received LinkCheckReq command.\n        gwcnt (int): the number of gateways that successfully received\n                     the last LinkCheckReq command\n        \n    \"\"\"\n    length = 3\n    \n    def __init__(self, margin=0, gwcnt=1):\n        self.cid = LINKCHECKANS\n        self.margin = margin\n        self.gwcnt = gwcnt\n    \n    def encode(self):\n        \"\"\"Create a binary representation of LinkCheckReq object.\n        \n        Returns:\n            String of packed data.\n        \n        \"\"\"\n        data = struct.pack('BBB', self.cid, self.margin, self.gwcnt)\n        return data\nfloranet/imanager.py\nclass InterfaceManager(object):\n    def __init__(self):\n    def start(self, netserver):\n    def getInterface(self, appinterface_id):\n    def getAllInterfaces(self):\n    def checkInterface(self, appinterface_id):\n    def createInterface(self, interface):\n    def updateInterface(self, interface):\n    def deleteInterface(self, interface):\nfloranet/lora/mac.py\nclass JoinAcceptMessage(MACMessage):\n    \"\"\"A LoRa Join Accept message.\n    \n    The join accept message contains an\n    application nonce of 3 octets (appnonce),\n    3 octet a network identifier (netid), a 4\n    octet device address (devaddr), a 1 octet\n    delay between tx and rx (rxdelay) and\n    an optional list of channel frequencies\n    (cflist).\n    \n    Attributes:\n        mhdr (MACHeader): MAC header\n        appkey (int): Application key\n        appnonce (int): Application nonce\n        netid (int): Network identifer\n        devaddr (int): Device address\n        dlsettings (int): DLsettings field\n        rxdelay (int): Delay between tx and rx\n        cflist (list): List of channel frequencies\n        mic (int): Message integrity code\n    \"\"\"\n        \n    def __init__(self, appkey, appnonce, netid, devaddr, dlsettings,\n                 rxdelay, cflist=[]):\n        \"\"\"JoinAcceptMessage initialisation method.\n        \n        \"\"\"\n        self.mhdr = MACHeader(JOIN_ACCEPT, LORAWAN_R1)\n        self.appkey = appkey\n        self.appnonce = appnonce\n        self.netid = netid\n        self.devaddr = devaddr\n        self.dlsettings = dlsettings\n        self.rxdelay = rxdelay\n        self.cflist = cflist\n        self.mic = None\n\n    def encode(self):\n        \"\"\"Create a binary representation of JoinAcceptMessage object.\n        \n        Returns:\n            Packed JoinAccept message.\n        \"\"\"\n        # Encoding Join-accept:\n        # MAC Header\n        # 3 bytes appnonce\n        # 3 bytes netid \n        # 4 bytes devaddr\n        # 1 byte dlsettings\n        # 1 byte rxdelay\n        # Optional cflist\n        \n        # Create the message\n        header = self.mhdr.encode()\n        msg =  intPackBytes(self.appnonce, 3, endian='little') + \\\n               intPackBytes(self.netid, 3, endian='little') + \\\n               struct.pack('<L', self.devaddr) + \\\n               struct.pack('B', self.dlsettings) + \\\n               struct.pack('B', self.rxdelay)\n        # CFList is not used in a Join Accept message for US/AU bands\n        if self.cflist:\n            pass\n        # Create the MIC over the entire message\n        self.mic = aesEncrypt(intPackBytes(self.appkey, 16), header + msg,\n                              mode='CMAC')[0:4]\n        msg += self.mic\n        # Add the header and encrypt the message using AES-128 decrypt\n        data = header + aesDecrypt(intPackBytes(self.appkey, 16), msg)\n        return data\n", "answers": ["                yield txsleep(scheduled - current)            "], "length": 5972, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "41a833d80e8c897fe06ccca471cb7707316924fb7962c77d"}
{"input": "import csv\nimport itertools\nimport multiprocessing as mp\nimport os\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport time\nimport tqdm\nimport yaml\nfrom abc import abstractmethod\nfrom queue import Empty\nfrom typing import TYPE_CHECKING, Dict, List, Optional, Tuple\nfrom montreal_forced_aligner.abc import FileExporterMixin, TopLevelMfaWorker\nfrom montreal_forced_aligner.corpus.acoustic_corpus import AcousticCorpusPronunciationMixin\nfrom montreal_forced_aligner.exceptions import KaldiProcessingError, PlatformError\nfrom montreal_forced_aligner.helper import parse_old_features, score_wer\nfrom montreal_forced_aligner.models import AcousticModel, LanguageModel\nfrom montreal_forced_aligner.transcription.multiprocessing import (\n    CarpaLmRescoreArguments,\n    CarpaLmRescoreFunction,\n    CreateHclgArguments,\n    CreateHclgFunction,\n    DecodeArguments,\n    DecodeFunction,\n    FinalFmllrArguments,\n    FinalFmllrFunction,\n    FmllrRescoreArguments,\n    FmllrRescoreFunction,\n    InitialFmllrArguments,\n    InitialFmllrFunction,\n    LatGenFmllrArguments,\n    LatGenFmllrFunction,\n    LmRescoreArguments,\n    LmRescoreFunction,\n    ScoreArguments,\n    ScoreFunction,\n)\nfrom montreal_forced_aligner.utils import (\n    KaldiProcessWorker,\n    Stopped,\n    log_kaldi_errors,\n    thirdparty_binary,\n)\n    from argparse import Namespace\n    from montreal_forced_aligner.abc import MetaDict\n            Arguments for function\n        \"\"\"\n        self.logger.info(\"Regenerating lattices with fMLLR transforms...\")\n        with tqdm.tqdm(total=self.num_utterances) as pbar, open(\n            os.path.join(self.working_log_directory, \"lat_gen_fmllr_log_like.csv\"),\n            \"w\",\n            encoding=\"utf8\",\n        ) as log_file:\n            log_file.write(\"utterance,log_likelihood,num_frames\\n\")\n            if self.use_mp:\n                manager = mp.Manager()\n                error_dict = manager.dict()\n                return_queue = manager.Queue()\n                stopped = Stopped()\n                procs = []\n                for i, args in enumerate(self.lat_gen_fmllr_arguments()):\n                    function = LatGenFmllrFunction(args)\n                    p = KaldiProcessWorker(i, return_queue, function, error_dict, stopped)\n                    procs.append(p)\n                    p.start()\n                while True:\n                    try:\n                        utterance, log_likelihood, num_frames = return_queue.get(timeout=1)\n                        log_file.write(f\"{utterance},{log_likelihood},{num_frames}\\n\")\n                        if stopped.stop_check():\n                            continue\n                    except Empty:\n                        for proc in procs:\n                            if not proc.finished.stop_check():\n                                break\n                        else:\n                            break\n                        continue\n                    pbar.update(1)\n                for p in procs:\n                    p.join()\n                if error_dict:\n                    for v in error_dict.values():\n                        raise v\n            else:\n                for args in self.lat_gen_fmllr_arguments():\n                    function = LatGenFmllrFunction(args)\n                    for utterance, log_likelihood, num_frames in function.run():\n                        log_file.write(f\"{utterance},{log_likelihood},{num_frames}\\n\")\n                        pbar.update(1)\n\n    def calc_final_fmllr(self):\n        \"\"\"\n        Calculate final fMLLR transforms\n\n        See Also\n        -------\n        :class:`~montreal_forced_aligner.transcription.multiprocessing.FinalFmllrFunction`\n            Multiprocessing function\n        :meth:`.Transcriber.final_fmllr_arguments`\n            Arguments for function\n        \"\"\"\n        self.logger.info(\"Calculating final fMLLR transforms...\")\n        sum_errors = 0\n        with tqdm.tqdm(total=self.num_utterances) as pbar:\n            if self.use_mp:\n                manager = mp.Manager()\n                error_dict = manager.dict()\n                return_queue = manager.Queue()\n                stopped = Stopped()\n                procs = []\n                for i, args in enumerate(self.final_fmllr_arguments()):\n                    function = FinalFmllrFunction(args)\n                    p = KaldiProcessWorker(i, return_queue, function, error_dict, stopped)\n                    procs.append(p)\n                    p.start()\n                while True:\n                    try:\n                        done, no_gpost, other_errors = return_queue.get(timeout=1)\n                        sum_errors += no_gpost + other_errors\n                        if stopped.stop_check():\n                            continue\n                    except Empty:\n                        for proc in procs:\n                            if not proc.finished.stop_check():\n                                break\n                        else:\n                            break\n                        continue\n                    pbar.update(done + no_gpost + other_errors)\n                for p in procs:\n                    p.join()\n                if error_dict:\n                    for v in error_dict.values():\n                        raise v\n            else:\n                for args in self.final_fmllr_arguments():\n                    function = FinalFmllrFunction(args)\n                    for done, no_gpost, other_errors in function.run():\n                        sum_errors += no_gpost + other_errors\n                        pbar.update(done + no_gpost + other_errors)\n            if sum_errors:\n                self.logger.warning(f\"{sum_errors} utterances had errors on calculating fMLLR.\")\n\n    def fmllr_rescore(self):\n        \"\"\"\n        Rescore lattices with final fMLLR transforms\n\n        See Also\n        -------\n        :class:`~montreal_forced_aligner.transcription.multiprocessing.FmllrRescoreFunction`\n            Multiprocessing function\n        :meth:`.Transcriber.fmllr_rescore_arguments`\n            Arguments for function\n        \"\"\"\n        self.logger.info(\"Rescoring fMLLR lattices with final transform...\")\n        sum_errors = 0\n        with tqdm.tqdm(total=self.num_utterances) as pbar:\n            if self.use_mp:\n                manager = mp.Manager()\n                error_dict = manager.dict()\n                return_queue = manager.Queue()\n                stopped = Stopped()\n                procs = []\n                for i, args in enumerate(self.fmllr_rescore_arguments()):\n", "context": "montreal_forced_aligner/transcription/multiprocessing.py\nclass ScoreArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.transcription.multiprocessing.ScoreFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    score_options: MetaDict\n    lat_paths: Dict[str, str]\n    rescored_lat_paths: Dict[str, str]\n    carpa_rescored_lat_paths: Dict[str, str]\n    words_paths: Dict[str, str]\n    tra_paths: Dict[str, str]\nmontreal_forced_aligner/exceptions.py\nclass PlatformError(MFAError):\n    \"\"\"\n    Exception class for platform compatibility issues\n\n    Parameters\n    ----------\n    functionality_name: str\n        Functionality not available on the current platform\n    \"\"\"\n\n    def __init__(self, functionality_name):\n        super().__init__(\"\")\n        self.message_lines = [\n            f\"Functionality for {self.printer.emphasized_text(functionality_name)} is not available on {self.printer.error_text(sys.platform)}.\"\n        ]\n        if sys.platform == \"win32\":\n            self.message_lines.append(\"\")\n            self.message_lines.append(\n                f\" If you'd like to use {self.printer.emphasized_text(functionality_name)} on Windows, please follow the MFA installation \"\n                f\"instructions for the Windows Subsystem for Linux (WSL).\"\n            )\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass FmllrRescoreFunction(KaldiFunction):\n    \"\"\"\n    Multiprocessing function to rescore lattices following fMLLR estimation\n\n    See Also\n    --------\n    :func:`~montreal_forced_aligner.transcription.Transcriber.transcribe_fmllr`\n        Main function that calls this function in parallel\n    :meth:`.Transcriber.fmllr_rescore_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`gmm-rescore-lattice`\n        Relevant Kaldi binary\n    :kaldi_src:`lattice-determinize-pruned`\n        Relevant Kaldi binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.transcription.multiprocessing.FmllrRescoreArguments`\n        Arguments for the function\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG.*Done (?P<done>\\d+) lattices, determinization finished earlier than specified by the beam (or output was empty) on (?P<errors>\\d+) of these.\"\n    )\n\n    def __init__(self, args: FmllrRescoreArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.feature_strings = args.feature_strings\n        self.model_path = args.model_path\n        self.fmllr_options = args.fmllr_options\n        self.tmp_lat_paths = args.tmp_lat_paths\n        self.final_lat_paths = args.final_lat_paths\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        with open(self.log_path, \"w\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                feature_string = self.feature_strings[dict_name]\n                tmp_lat_path = self.tmp_lat_paths[dict_name]\n                final_lat_path = self.final_lat_paths[dict_name]\n                rescore_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"gmm-rescore-lattice\"),\n                        self.model_path,\n                        f\"ark:{tmp_lat_path}\",\n                        feature_string,\n                        \"ark:-\",\n                    ],\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                determinize_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-determinize-pruned\"),\n                        f\"--acoustic-scale={self.fmllr_options['acoustic_scale']}\",\n                        f\"--beam={self.fmllr_options['lattice_beam']}\",\n                        \"ark:-\",\n                        f\"ark:{final_lat_path}\",\n                    ],\n                    stdin=rescore_proc.stdout,\n                    stderr=subprocess.PIPE,\n                    encoding=\"utf8\",\n                    env=os.environ,\n                )\n                for line in determinize_proc.stderr:\n                    log_file.write(line)\n                    m = self.progress_pattern.match(line.strip())\n                    if m:\n                        yield int(m.group(\"done\")), int(m.group(\"errors\"))\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass DecodeArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.transcription.multiprocessing.DecodeFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    feature_strings: Dict[str, str]\n    decode_options: MetaDict\n    model_path: str\n    lat_paths: Dict[str, str]\n    word_symbol_paths: Dict[str, str]\n    hclg_paths: Dict[str, str]\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass DecodeFunction(KaldiFunction):\n    \"\"\"\n    Multiprocessing function for performing decoding\n\n    See Also\n    --------\n    :meth:`.Transcriber.transcribe`\n        Main function that calls this function in parallel\n    :meth:`.Transcriber.decode_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`gmm-latgen-faster`\n        Relevant Kaldi binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.transcription.multiprocessing.DecodeArguments`\n        Arguments for the function\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG.*Log-like per frame for utterance (?P<utterance>.*) is (?P<loglike>[-\\d.]+) over (?P<num_frames>\\d+) frames.\"\n    )\n\n    def __init__(self, args: DecodeArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.feature_strings = args.feature_strings\n        self.lat_paths = args.lat_paths\n        self.word_symbol_paths = args.word_symbol_paths\n        self.hclg_paths = args.hclg_paths\n        self.decode_options = args.decode_options\n        self.model_path = args.model_path\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        with open(self.log_path, \"w\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                feature_string = self.feature_strings[dict_name]\n                lat_path = self.lat_paths[dict_name]\n                word_symbol_path = self.word_symbol_paths[dict_name]\n                hclg_path = self.hclg_paths[dict_name]\n                if os.path.exists(lat_path):\n                    continue\n                if (\n                    self.decode_options[\"uses_speaker_adaptation\"]\n                    and self.decode_options[\"first_beam\"] is not None\n                ):\n                    beam = self.decode_options[\"first_beam\"]\n                else:\n                    beam = self.decode_options[\"beam\"]\n                if (\n                    self.decode_options[\"uses_speaker_adaptation\"]\n                    and self.decode_options[\"first_max_active\"] is not None\n                ):\n                    max_active = self.decode_options[\"first_max_active\"]\n                else:\n                    max_active = self.decode_options[\"max_active\"]\n                decode_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"gmm-latgen-faster\"),\n                        f\"--max-active={max_active}\",\n                        f\"--beam={beam}\",\n                        f\"--lattice-beam={self.decode_options['lattice_beam']}\",\n                        \"--allow-partial=true\",\n                        f\"--word-symbol-table={word_symbol_path}\",\n                        f\"--acoustic-scale={self.decode_options['acoustic_scale']}\",\n                        self.model_path,\n                        hclg_path,\n                        feature_string,\n                        f\"ark:{lat_path}\",\n                    ],\n                    stderr=subprocess.PIPE,\n                    env=os.environ,\n                    encoding=\"utf8\",\n                )\n                for line in decode_proc.stderr:\n                    log_file.write(line)\n                    m = self.progress_pattern.match(line.strip())\n                    if m:\n                        yield m.group(\"utterance\"), m.group(\"loglike\"), m.group(\"num_frames\")\nmontreal_forced_aligner/helper.py\ndef parse_old_features(config: MetaDict) -> MetaDict:\n    \"\"\"\n    Backwards compatibility function to parse old feature configuration blocks\n\n    Parameters\n    ----------\n    config: dict[str, Any]\n        Configuration parameters\n\n    Returns\n    -------\n    dict[str, Any]\n        Up to date versions of feature blocks\n    \"\"\"\n    feature_key_remapping = {\n        \"type\": \"feature_type\",\n        \"deltas\": \"uses_deltas\",\n    }\n    skip_keys = [\"lda\", \"fmllr\"]\n    if \"features\" in config:\n        for key in skip_keys:\n            if key in config[\"features\"]:\n                del config[\"features\"][key]\n        for key, new_key in feature_key_remapping.items():\n            if key in config[\"features\"]:\n\n                config[\"features\"][new_key] = config[\"features\"][key]\n                del config[\"features\"][key]\n    else:\n        for key in skip_keys:\n            if key in config:\n                del config[key]\n        for key, new_key in feature_key_remapping.items():\n            if key in config:\n                config[new_key] = config[key]\n                del config[key]\n    return config\nmontreal_forced_aligner/utils.py\ndef log_kaldi_errors(error_logs: List[str], logger: logging.Logger) -> None:\n    \"\"\"\n    Save details of Kaldi processing errors to a logger\n\n    Parameters\n    ----------\n    error_logs: list[str]\n        Kaldi log files with errors\n    logger: :class:`~logging.Logger`\n        Logger to output to\n    \"\"\"\n    logger.debug(f\"There were {len(error_logs)} kaldi processing files that had errors:\")\n    for path in error_logs:\n        logger.debug(\"\")\n        logger.debug(path)\n        with open(path, \"r\", encoding=\"utf8\") as f:\n            for line in f:\n                logger.debug(\"\\t\" + line.strip())\nmontreal_forced_aligner/utils.py\nclass Stopped(object):\n    \"\"\"\n    Multiprocessing class for detecting whether processes should stop processing and exit ASAP\n\n    Attributes\n    ----------\n    val: :func:`~multiprocessing.Value`\n        0 if not stopped, 1 if stopped\n    lock: :class:`~multiprocessing.Lock`\n        Lock for process safety\n    _source: multiprocessing.Value\n        1 if it was a Ctrl+C event that stopped it, 0 otherwise\n    \"\"\"\n\n    def __init__(self, initval: Union[bool, int] = False):\n        self.val = mp.Value(\"i\", initval)\n        self.lock = mp.Lock()\n        self._source = mp.Value(\"i\", 0)\n\n    def stop(self) -> None:\n        \"\"\"Signal that work should stop asap\"\"\"\n        with self.lock:\n            self.val.value = True\n\n    def stop_check(self) -> int:\n        \"\"\"Check whether a process should stop\"\"\"\n        with self.lock:\n            return self.val.value\n\n    def set_sigint_source(self) -> None:\n        \"\"\"Set the source as a ctrl+c\"\"\"\n        with self.lock:\n            self._source.value = True\n\n    def source(self) -> int:\n        \"\"\"Get the source value\"\"\"\n        with self.lock:\n            return self._source.value\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass CreateHclgFunction(KaldiFunction):\n    \"\"\"\n    Create HCLG.fst file\n\n    See Also\n    --------\n    :meth:`.Transcriber.create_hclgs`\n        Main function that calls this function in parallel\n    :meth:`.Transcriber.create_hclgs_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`add-self-loops`\n        Relevant Kaldi binary\n    :openfst_src:`fstconvert`\n        Relevant OpenFst binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.transcription.multiprocessing.CreateHclgArguments`\n        Arguments for the function\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG.*Log-like per frame for utterance (?P<utterance>.*) is (?P<loglike>[-\\d.]+) over (?P<num_frames>\\d+) frames.\"\n    )\n\n    def __init__(self, args: CreateHclgArguments):\n        self.log_path = args.log_path\n        self.working_directory = args.working_directory\n        self.path_template = args.path_template\n        self.words_path = args.words_path\n        self.carpa_path = args.carpa_path\n        self.small_arpa_path = args.small_arpa_path\n        self.medium_arpa_path = args.medium_arpa_path\n        self.big_arpa_path = args.big_arpa_path\n        self.model_path = args.model_path\n        self.disambig_L_path = args.disambig_L_path\n        self.disambig_int_path = args.disambig_int_path\n        self.hclg_options = args.hclg_options\n        self.words_mapping = args.words_mapping\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        hclg_path = self.path_template.format(file_name=\"HCLG\")\n        small_g_path = self.path_template.format(file_name=\"G.small\")\n        medium_g_path = self.path_template.format(file_name=\"G.med\")\n        lg_path = self.path_template.format(file_name=\"LG\")\n        hclga_path = self.path_template.format(file_name=\"HCLGa\")\n        if os.path.exists(hclg_path):\n            return\n        with open(self.log_path, \"w\") as log_file:\n            context_width = self.hclg_options[\"context_width\"]\n            central_pos = self.hclg_options[\"central_pos\"]\n\n            clg_path = self.path_template.format(file_name=f\"CLG_{context_width}_{central_pos}\")\n            ilabels_temp = self.path_template.format(\n                file_name=f\"ilabels_{context_width}_{central_pos}\"\n            ).replace(\".fst\", \"\")\n            out_disambig = self.path_template.format(\n                file_name=f\"disambig_ilabels_{context_width}_{central_pos}\"\n            ).replace(\".fst\", \".int\")\n\n            log_file.write(\"Generating decoding graph...\\n\")\n            if not os.path.exists(small_g_path):\n                log_file.write(\"Generating small_G.fst...\")\n                compose_g(self.small_arpa_path, self.words_path, small_g_path, log_file)\n            if not os.path.exists(medium_g_path):\n                log_file.write(\"Generating med_G.fst...\")\n                compose_g(self.medium_arpa_path, self.words_path, medium_g_path, log_file)\n            if not os.path.exists(self.carpa_path):\n                log_file.write(\"Generating G.carpa...\")\n                temp_carpa_path = self.carpa_path + \".temp\"\n                compose_g_carpa(\n                    self.big_arpa_path,\n                    temp_carpa_path,\n                    self.words_mapping,\n                    self.carpa_path,\n                    log_file,\n                )\n            if not os.path.exists(lg_path):\n                log_file.write(\"Generating LG.fst...\")\n                compose_lg(self.disambig_L_path, small_g_path, lg_path, log_file)\n            if not os.path.exists(clg_path):\n                log_file.write(\"Generating CLG.fst...\")\n                compose_clg(\n                    self.disambig_int_path,\n                    out_disambig,\n                    context_width,\n                    central_pos,\n                    ilabels_temp,\n                    lg_path,\n                    clg_path,\n                    log_file,\n                )\n            if not os.path.exists(hclga_path):\n                log_file.write(\"Generating HCLGa.fst...\")\n                compose_hclg(\n                    self.working_directory,\n                    ilabels_temp,\n                    self.hclg_options[\"transition_scale\"],\n                    clg_path,\n                    hclga_path,\n                    log_file,\n                )\n            log_file.write(\"Generating HCLG.fst...\")\n            self_loop_proc = subprocess.Popen(\n                [\n                    thirdparty_binary(\"add-self-loops\"),\n                    f\"--self-loop-scale={self.hclg_options['self_loop_scale']}\",\n                    \"--reorder=true\",\n                    self.model_path,\n                    hclga_path,\n                ],\n                stderr=log_file,\n                stdout=subprocess.PIPE,\n                env=os.environ,\n            )\n            convert_proc = subprocess.Popen(\n                [\n                    thirdparty_binary(\"fstconvert\"),\n                    \"--v=100\",\n                    \"--fst_type=const\",\n                    \"-\",\n                    hclg_path,\n                ],\n                stdin=self_loop_proc.stdout,\n                stderr=log_file,\n                env=os.environ,\n            )\n            convert_proc.communicate()\n            if os.path.exists(hclg_path):\n                yield True, hclg_path\n            else:\n                yield False, hclg_path\nmontreal_forced_aligner/utils.py\nclass KaldiProcessWorker(mp.Process):\n    \"\"\"\n    Multiprocessing function work\n\n    Parameters\n    ----------\n    job_name: int\n        Integer number of job\n    job_q: :class:`~multiprocessing.Queue`\n        Job queue to pull arguments from\n    function: KaldiFunction\n        Multiprocessing function to call on arguments from job_q\n    return_dict: dict\n        Dictionary for collecting errors\n    stopped: :class:`~montreal_forced_aligner.utils.Stopped`\n        Stop check\n    return_info: dict[int, Any], optional\n        Optional dictionary to fill if the function should return information to main thread\n    \"\"\"\n\n    def __init__(\n        self,\n        job_name: int,\n        return_q: mp.Queue,\n        function: KaldiFunction,\n        error_dict: dict,\n        stopped: Stopped,\n    ):\n        mp.Process.__init__(self)\n        self.job_name = job_name\n        self.function = function\n        self.return_q = return_q\n        self.error_dict = error_dict\n        self.stopped = stopped\n        self.finished = Stopped()\n\n    def run(self) -> None:\n        \"\"\"\n        Run through the arguments in the queue apply the function to them\n        \"\"\"\n        try:\n            for result in self.function.run():\n                self.return_q.put(result)\n        except Exception:\n            self.stopped.stop()\n            self.error_dict[self.job_name] = Exception(traceback.format_exception(*sys.exc_info()))\n        finally:\n            self.finished.stop()\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass ScoreFunction(KaldiFunction):\n    \"\"\"\n    Multiprocessing function for scoring lattices\n\n    See Also\n    --------\n    :meth:`~montreal_forced_aligner.transcription.Transcriber.score_transcriptions`\n        Main function that calls this function in parallel\n    :meth:`.Transcriber.score_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`lattice-scale`\n        Relevant Kaldi binary\n    :kaldi_src:`lattice-add-penalty`\n        Relevant Kaldi binary\n    :kaldi_src:`lattice-best-path`\n        Relevant Kaldi binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.transcription.multiprocessing.ScoreArguments`\n        Arguments for the function\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG .* For utterance (?P<utterance>.*), best cost (?P<graph_cost>[-\\d.]+) \\+ (?P<acoustic_cost>[-\\d.]+) = (?P<total_cost>[-\\d.]+) over (?P<num_frames>\\d+) frames.\"\n    )\n\n    def __init__(self, args: ScoreArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.score_options = args.score_options\n        self.lat_paths = args.lat_paths\n        self.rescored_lat_paths = args.rescored_lat_paths\n        self.carpa_rescored_lat_paths = args.carpa_rescored_lat_paths\n        self.words_paths = args.words_paths\n        self.tra_paths = args.tra_paths\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        with open(self.log_path, \"w\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                language_model_weight = self.score_options[\"language_model_weight\"]\n                word_insertion_penalty = self.score_options[\"word_insertion_penalty\"]\n                carpa_rescored_lat_path = self.carpa_rescored_lat_paths[dict_name]\n                rescored_lat_path = self.rescored_lat_paths[dict_name]\n                lat_path = self.lat_paths[dict_name]\n                words_path = self.words_paths[dict_name]\n                tra_path = self.tra_paths[dict_name]\n                if os.path.exists(carpa_rescored_lat_path):\n                    lat_path = carpa_rescored_lat_path\n                elif os.path.exists(rescored_lat_path):\n                    lat_path = rescored_lat_path\n                scale_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-scale\"),\n                        f\"--inv-acoustic-scale={language_model_weight}\",\n                        f\"ark:{lat_path}\",\n                        \"ark:-\",\n                    ],\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                penalty_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-add-penalty\"),\n                        f\"--word-ins-penalty={word_insertion_penalty}\",\n                        \"ark:-\",\n                        \"ark:-\",\n                    ],\n                    stdin=scale_proc.stdout,\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                best_path_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-best-path\"),\n                        f\"--word-symbol-table={words_path}\",\n                        \"ark:-\",\n                        f\"ark,t:{tra_path}\",\n                    ],\n                    stdin=penalty_proc.stdout,\n                    stderr=subprocess.PIPE,\n                    env=os.environ,\n                    encoding=\"utf8\",\n                )\n                for line in best_path_proc.stderr:\n                    log_file.write(line)\n                    m = self.progress_pattern.match(line.strip())\n                    if m:\n                        yield m.group(\"utterance\"), float(m.group(\"graph_cost\")), float(\n                            m.group(\"acoustic_cost\")\n                        ), float(m.group(\"total_cost\")), int(m.group(\"num_frames\"))\nmontreal_forced_aligner/abc.py\nclass FileExporterMixin(ExporterMixin, metaclass=abc.ABCMeta):\n    \"\"\"\n    Abstract mixin class for exporting TextGrid and text files\n\n    Parameters\n    ----------\n    cleanup_textgrids: bool\n        Flag for whether to clean up exported TextGrids\n    \"\"\"\n\n    def __init__(self, cleanup_textgrids: bool = True, **kwargs):\n        self.cleanup_textgrids = cleanup_textgrids\n        super().__init__(**kwargs)\n\n    @property\n    def backup_output_directory(self) -> Optional[str]:\n        \"\"\"Path to store files if overwriting is not allowed\"\"\"\n        if self.overwrite:\n            return None\n        return os.path.join(self.working_directory, \"backup\")\n\n    @abc.abstractmethod\n    def export_files(self, output_directory: str) -> None:\n        \"\"\"\n        Export files to an output directory\n\n        Parameters\n        ----------\n        output_directory: str\n            Directory to export to\n        \"\"\"\n        ...\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass FmllrRescoreArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.transcription.multiprocessing.FmllrRescoreFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    feature_strings: Dict[str, str]\n    model_path: str\n    fmllr_options: MetaDict\n    tmp_lat_paths: Dict[str, str]\n    final_lat_paths: Dict[str, str]\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass CarpaLmRescoreArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.transcription.multiprocessing.CarpaLmRescoreFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    lat_paths: Dict[str, str]\n    rescored_lat_paths: Dict[str, str]\n    old_g_paths: Dict[str, str]\n    new_g_paths: Dict[str, str]\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass FinalFmllrArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.transcription.multiprocessing.FinalFmllrFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    feature_strings: Dict[str, str]\n    model_path: str\n    fmllr_options: MetaDict\n    trans_paths: Dict[str, str]\n    spk2utt_paths: Dict[str, str]\n    tmp_lat_paths: Dict[str, str]\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass FinalFmllrFunction(KaldiFunction):\n\n    \"\"\"\n    Multiprocessing function for running final fMLLR estimation\n\n    See Also\n    --------\n    :func:`~montreal_forced_aligner.transcription.Transcriber.transcribe_fmllr`\n        Main function that calls this function in parallel\n    :meth:`.Transcriber.final_fmllr_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`lattice-determinize-pruned`\n        Relevant Kaldi binary\n    :kaldi_src:`lattice-to-post`\n        Relevant Kaldi binary\n    :kaldi_src:`weight-silence-post`\n        Relevant Kaldi binary\n    :kaldi_src:`gmm-est-fmllr`\n        Relevant Kaldi binary\n    :kaldi_src:`compose-transforms`\n        Relevant Kaldi binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.transcription.multiprocessing.FinalFmllrArguments`\n        Arguments for the function\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG.*Done (?P<done>\\d+) files, (?P<no_gpost>\\d+) with no g?posts, (?P<other_errors>\\d+) with other errors.\"\n    )\n\n    def __init__(self, args: FinalFmllrArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.feature_strings = args.feature_strings\n        self.model_path = args.model_path\n        self.fmllr_options = args.fmllr_options\n        self.trans_paths = args.trans_paths\n        self.tmp_lat_paths = args.tmp_lat_paths\n        self.spk2utt_paths = args.spk2utt_paths\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        with open(self.log_path, \"w\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                feature_string = self.feature_strings[dict_name]\n                trans_path = self.trans_paths[dict_name]\n                temp_trans_path = trans_path + \".temp\"\n                temp_composed_trans_path = trans_path + \".temp_composed\"\n                spk2utt_path = self.spk2utt_paths[dict_name]\n                tmp_lat_path = self.tmp_lat_paths[dict_name]\n                determinize_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-determinize-pruned\"),\n                        f\"--acoustic-scale={self.fmllr_options['acoustic_scale']}\",\n                        \"--beam=4.0\",\n                        f\"ark:{tmp_lat_path}\",\n                        \"ark:-\",\n                    ],\n                    stderr=log_file,\n                    stdout=subprocess.PIPE,\n                    env=os.environ,\n                )\n\n                latt_post_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-to-post\"),\n                        f\"--acoustic-scale={self.fmllr_options['acoustic_scale']}\",\n                        \"ark:-\",\n                        \"ark:-\",\n                    ],\n                    stdin=determinize_proc.stdout,\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                weight_silence_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"weight-silence-post\"),\n                        f\"{self.fmllr_options['silence_weight']}\",\n                        self.fmllr_options[\"sil_phones\"],\n                        self.model_path,\n                        \"ark:-\",\n                        \"ark:-\",\n                    ],\n                    stdin=latt_post_proc.stdout,\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                fmllr_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"gmm-est-fmllr\"),\n                        f\"--fmllr-update-type={self.fmllr_options['fmllr_update_type']}\",\n                        f\"--spk2utt=ark:{spk2utt_path}\",\n                        self.model_path,\n                        feature_string,\n                        \"ark,s,cs:-\",\n                        f\"ark:{temp_trans_path}\",\n                    ],\n                    stdin=weight_silence_proc.stdout,\n                    stderr=subprocess.PIPE,\n                    env=os.environ,\n                    encoding=\"utf8\",\n                )\n                for line in fmllr_proc.stderr:\n                    log_file.write(line)\n                    m = self.progress_pattern.match(line.strip())\n                    if m:\n                        yield int(m.group(\"done\")), int(m.group(\"no_gpost\")), int(\n                            m.group(\"other_errors\")\n                        )\n\n                compose_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"compose-transforms\"),\n                        \"--b-is-affine=true\",\n                        f\"ark:{temp_trans_path}\",\n                        f\"ark:{trans_path}\",\n                        f\"ark:{temp_composed_trans_path}\",\n                    ],\n                    stderr=log_file,\n                    stdin=fmllr_proc.stdout,\n                    env=os.environ,\n                )\n                compose_proc.communicate()\n                os.remove(trans_path)\n                os.remove(temp_trans_path)\n                os.rename(temp_composed_trans_path, trans_path)\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass InitialFmllrArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.transcription.multiprocessing.InitialFmllrFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    feature_strings: Dict[str, str]\n    model_path: str\n    fmllr_options: MetaDict\n    pre_trans_paths: Dict[str, str]\n    lat_paths: Dict[str, str]\n    spk2utt_paths: Dict[str, str]\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass CreateHclgArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.transcription.multiprocessing.CreateHclgFunction`\"\"\"\n\n    log_path: str\n    working_directory: str\n    path_template: str\n    words_path: str\n    carpa_path: str\n    small_arpa_path: str\n    medium_arpa_path: str\n    big_arpa_path: str\n    model_path: str\n    disambig_L_path: str\n    disambig_int_path: str\n    hclg_options: MetaDict\n    words_mapping: MappingType\n\n    @property\n    def hclg_path(self) -> str:\n        \"\"\"Path to HCLG FST file\"\"\"\n        return self.path_template.format(file_name=\"HCLG\")\nmontreal_forced_aligner/abc.py\nclass TopLevelMfaWorker(MfaWorker, TemporaryDirectoryMixin, metaclass=abc.ABCMeta):\n    \"\"\"\n    Abstract mixin for top-level workers in MFA.  This class holds properties about the larger workflow run.\n\n    Parameters\n    ----------\n    num_jobs: int\n        Number of jobs and processes to uses\n    clean: bool\n        Flag for whether to remove any old files in the work directory\n    \"\"\"\n\n    def __init__(\n        self,\n        num_jobs: int = 3,\n        clean: bool = False,\n        **kwargs,\n    ):\n        kwargs, skipped = type(self).extract_relevant_parameters(kwargs)\n        super().__init__(**kwargs)\n        self.num_jobs = num_jobs\n        self.clean = clean\n        self.initialized = False\n        self.start_time = time.time()\n        self.setup_logger()\n        if skipped:\n            self.logger.warning(f\"Skipped the following configuration keys: {comma_join(skipped)}\")\n\n    def __del__(self):\n        \"\"\"Ensure that loggers are cleaned up on delete\"\"\"\n        handlers = self.logger.handlers[:]\n        for handler in handlers:\n            handler.close()\n            self.logger.removeHandler(handler)\n\n    @abc.abstractmethod\n    def setup(self) -> None:\n        \"\"\"Abstract method for setting up a top-level worker\"\"\"\n        ...\n\n    @property\n    def working_directory(self) -> str:\n        \"\"\"Alias for a folder that contains worker information, separate from the data directory\"\"\"\n        return self.workflow_directory\n\n    @classmethod\n    def parse_args(cls, args: Optional[Namespace], unknown_args: Optional[List[str]]) -> MetaDict:\n        \"\"\"\n        Class method for parsing configuration parameters from command line arguments\n\n        Parameters\n        ----------\n        args: :class:`~argparse.Namespace`\n            Arguments parsed by argparse\n        unknown_args: list[str]\n            Optional list of arguments that were not parsed by argparse\n\n        Returns\n        -------\n        dict[str, Any]\n            Dictionary of specified configuration parameters\n        \"\"\"\n        param_types = cls.get_configuration_parameters()\n        params = {}\n        unknown_dict = {}\n        if unknown_args:\n            for i, a in enumerate(unknown_args):\n                if not a.startswith(\"--\"):\n                    continue\n                name = a.replace(\"--\", \"\")\n                if name not in param_types:\n                    continue\n                if i == len(unknown_args) - 1 or unknown_args[i + 1].startswith(\"--\"):\n                    val = True\n                else:\n                    val = unknown_args[i + 1]\n                unknown_dict[name] = val\n        for name, param_type in param_types.items():\n            if (name.endswith(\"_directory\") and name != \"audio_directory\") or name.endswith(\n                \"_path\"\n            ):\n                continue\n            if args is not None and hasattr(args, name):\n                params[name] = param_type(getattr(args, name))\n            elif name in unknown_dict:\n                params[name] = param_type(unknown_dict[name])\n                if param_type == bool:\n                    if unknown_dict[name].lower() == \"false\":\n                        params[name] = False\n        if getattr(args, \"disable_mp\", False):\n            params[\"use_mp\"] = False\n        elif getattr(args, \"disable_textgrid_cleanup\", False):\n            params[\"cleanup_textgrids\"] = False\n        return params\n\n    @classmethod\n    def parse_parameters(\n        cls,\n        config_path: Optional[str] = None,\n        args: Optional[Namespace] = None,\n        unknown_args: Optional[List[str]] = None,\n    ) -> MetaDict:\n        \"\"\"\n        Parse configuration parameters from a config file and command line arguments\n\n        Parameters\n        ----------\n        config_path: str, optional\n            Path to yaml configuration file\n        args: :class:`~argparse.Namespace`, optional\n            Arguments parsed by argparse\n        unknown_args: list[str], optional\n            List of unknown arguments from argparse\n\n        Returns\n        -------\n        dict[str, Any]\n            Dictionary of specified configuration parameters\n        \"\"\"\n        global_params = {}\n        if config_path and os.path.exists(config_path):\n            with open(config_path, \"r\", encoding=\"utf8\") as f:\n                data = yaml.load(f, Loader=yaml.SafeLoader)\n                for k, v in data.items():\n                    if v is None and k in {\"punctuation\", \"compound_markers\", \"clitic_markers\"}:\n                        v = []\n                    global_params[k] = v\n        global_params.update(cls.parse_args(args, unknown_args))\n        return global_params\n\n    @property\n    @abc.abstractmethod\n    def workflow_identifier(self) -> str:\n        \"\"\"Identifier of the worker's workflow\"\"\"\n        ...\n\n    @property\n    def worker_config_path(self):\n        \"\"\"Path to worker's configuration in the working directory\"\"\"\n        return os.path.join(self.output_directory, f\"{self.workflow_identifier}.yaml\")\n\n    def cleanup(self) -> None:\n        \"\"\"\n        Clean up loggers and output final message for top-level workers\n        \"\"\"\n        try:\n            if self.dirty:\n                self.logger.error(\"There was an error in the run, please see the log.\")\n            else:\n                self.logger.info(f\"Done! Everything took {time.time() - self.start_time} seconds\")\n            handlers = self.logger.handlers[:]\n            for handler in handlers:\n                handler.close()\n                self.logger.removeHandler(handler)\n            self.save_worker_config()\n        except (NameError, ValueError):  # already cleaned up\n            pass\n\n    def save_worker_config(self):\n        \"\"\"Export worker configuration to its working directory\"\"\"\n        with open(self.worker_config_path, \"w\") as f:\n            yaml.dump(self.configuration, f)\n\n    def _validate_previous_configuration(self, conf: MetaDict) -> bool:\n        \"\"\"\n        Validate the current configuration against a previous configuration\n\n        Parameters\n        ----------\n        conf: dict[str, Any]\n            Previous run's configuration\n\n        Returns\n        -------\n        bool\n            Flag for whether the current run is compatible with the previous one\n        \"\"\"\n        from montreal_forced_aligner.utils import get_mfa_version\n\n        clean = True\n        current_version = get_mfa_version()\n        if conf[\"dirty\"]:\n            self.logger.debug(\"Previous run ended in an error (maybe ctrl-c?)\")\n            clean = False\n        if \"type\" in conf:\n            command = conf[\"type\"]\n        elif \"command\" in conf:\n            command = conf[\"command\"]\n        else:\n            command = self.workflow_identifier\n        if command != self.workflow_identifier:\n            self.logger.debug(\n                f\"Previous run was a different subcommand than {self.workflow_identifier} (was {command})\"\n            )\n            clean = False\n        if conf.get(\"version\", current_version) != current_version:\n            self.logger.debug(\n                f\"Previous run was on {conf['version']} version (new run: {current_version})\"\n            )\n            clean = False\n        for key in [\n            \"corpus_directory\",\n            \"dictionary_path\",\n            \"acoustic_model_path\",\n            \"g2p_model_path\",\n            \"language_model_path\",\n        ]:\n            if conf.get(key, None) != getattr(self, key, None):\n                self.logger.debug(\n                    f\"Previous run used a different {key.replace('_', ' ')} than {getattr(self, key, None)} (was {conf.get(key, None)})\"\n                )\n                clean = False\n        return clean\n\n    def check_previous_run(self) -> bool:\n        \"\"\"\n        Check whether a previous run has any conflicting settings with the current run.\n\n        Returns\n        -------\n        bool\n            Flag for whether the current run is compatible with the previous one\n        \"\"\"\n        if not os.path.exists(self.worker_config_path):\n            return True\n        with open(self.worker_config_path, \"r\") as f:\n            conf = yaml.load(f, Loader=yaml.SafeLoader)\n        clean = self._validate_previous_configuration(conf)\n        if not clean:\n            self.logger.warning(\n                \"The previous run had a different configuration than the current, which may cause issues.\"\n                \" Please see the log for details or use --clean flag if issues are encountered.\"\n            )\n        return clean\n\n    @property\n    def identifier(self) -> str:\n        \"\"\"Combined identifier of the data source and workflow\"\"\"\n        return f\"{self.data_source_identifier}_{self.workflow_identifier}\"\n\n    @property\n    def output_directory(self) -> str:\n        \"\"\"Root temporary directory to store all of this worker's files\"\"\"\n        return os.path.join(self.temporary_directory, self.identifier)\n\n    @property\n    def workflow_directory(self) -> str:\n        \"\"\"Temporary directory to save work specific to the worker (i.e., not data)\"\"\"\n        return os.path.join(self.output_directory, self.workflow_identifier)\n\n    @property\n    def log_file(self):\n        \"\"\"Path to the worker's log file\"\"\"\n        return os.path.join(self.output_directory, f\"{self.workflow_identifier}.log\")\n\n    def setup_logger(self):\n        \"\"\"\n        Construct a logger for a command line run\n        \"\"\"\n        from .utils import CustomFormatter, get_mfa_version\n\n        current_version = get_mfa_version()\n        # Remove previous directory if versions are different\n        if os.path.exists(self.worker_config_path):\n            with open(self.worker_config_path, \"r\") as f:\n                conf = yaml.load(f, Loader=yaml.SafeLoader)\n            if conf.get(\"version\", current_version) != current_version:\n                self.clean = True\n        if self.clean:\n            shutil.rmtree(self.output_directory, ignore_errors=True)\n        os.makedirs(self.workflow_directory, exist_ok=True)\n        if os.path.exists(self.log_file):\n            os.remove(self.log_file)\n        self.logger = logging.getLogger(self.workflow_identifier)\n        self.logger.setLevel(logging.DEBUG)\n\n        file_handler = logging.FileHandler(self.log_file, encoding=\"utf8\")\n        file_handler.setLevel(logging.DEBUG)\n        formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n        file_handler.setFormatter(formatter)\n        self.logger.addHandler(file_handler)\n\n        handler = logging.StreamHandler(sys.stdout)\n        if self.verbose:\n            handler.setLevel(logging.DEBUG)\n        else:\n            handler.setLevel(logging.INFO)\n        handler.setFormatter(CustomFormatter())\n        self.logger.addHandler(handler)\n        self.logger.debug(\n            f\"Beginning run for {self.workflow_identifier} on {self.data_source_identifier}\"\n        )\n        if self.use_mp:\n            self.logger.debug(f\"Using multiprocessing with {self.num_jobs}\")\n        else:\n            self.logger.debug(f\"NOT using multiprocessing with {self.num_jobs}\")\n        self.logger.debug(f\"Set up logger for MFA version: {current_version}\")\n        if self.clean:\n            self.logger.debug(\"Cleaned previous run\")\n\n    def log_debug(self, message: str) -> None:\n        \"\"\"\n        Log a debug message. This function is a wrapper around the :meth:`logging.Logger.debug`\n\n        Parameters\n        ----------\n        message: str\n            Debug message to log\n        \"\"\"\n        self.logger.debug(message)\n\n    def log_info(self, message: str) -> None:\n        \"\"\"\n        Log an info message. This function is a wrapper around the :meth:`logging.Logger.info`\n\n        Parameters\n        ----------\n        message: str\n            Info message to log\n        \"\"\"\n        self.logger.info(message)\n\n    def log_warning(self, message: str) -> None:\n        \"\"\"\n        Log a warning message. This function is a wrapper around the :meth:`logging.Logger.warning`\n\n        Parameters\n        ----------\n        message: str\n            Warning message to log\n        \"\"\"\n        self.logger.warning(message)\n\n    def log_error(self, message: str) -> None:\n        \"\"\"\n        Log an error message. This function is a wrapper around the :meth:`logging.Logger.error`\n\n        Parameters\n        ----------\n        message: str\n            Error message to log\n        \"\"\"\n        self.logger.error(message)\nmontreal_forced_aligner/helper.py\ndef score_wer(gold: List[str], hypo: List[str]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Computes word error rate and character error rate for a transcription\n\n    Parameters\n    ----------\n    gold: list[str]\n        The reference words\n    hypo: list[str]\n        The hypothesized words\n\n    Returns\n    -------\n    int\n        Word Edit distance\n    int\n        Length of the gold words labels\n    int\n        Character edit distance\n    int\n        Length of the gold characters\n    \"\"\"\n    word_edits = edit_distance(gold, hypo)\n    character_gold = list(\"\".join(gold))\n    character_hypo = list(\"\".join(hypo))\n    character_edits = edit_distance(character_gold, character_hypo)\n    return word_edits, len(gold), character_edits, len(character_gold)\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass LatGenFmllrArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.transcription.multiprocessing.LatGenFmllrFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    feature_strings: Dict[str, str]\n    model_path: str\n    decode_options: MetaDict\n    word_symbol_paths: Dict[str, str]\n    hclg_paths: Dict[str, str]\n    tmp_lat_paths: Dict[str, str]\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass InitialFmllrFunction(KaldiFunction):\n    \"\"\"\n    Multiprocessing function for running initial fMLLR calculation\n\n    See Also\n    --------\n    :func:`~montreal_forced_aligner.transcription.Transcriber.transcribe_fmllr`\n        Main function that calls this function in parallel\n    :meth:`.Transcriber.initial_fmllr_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`lattice-to-post`\n        Relevant Kaldi binary\n    :kaldi_src:`weight-silence-post`\n        Relevant Kaldi binary\n    :kaldi_src:`gmm-post-to-gpost`\n        Relevant Kaldi binary\n    :kaldi_src:`gmm-est-fmllr-gpost`\n        Relevant Kaldi binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.transcription.multiprocessing.InitialFmllrArguments`\n        Arguments for the function\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG.*Done (?P<done>\\d+) files, (?P<no_gpost>\\d+) with no g?posts, (?P<other_errors>\\d+) with other errors.\"\n    )\n\n    def __init__(self, args: InitialFmllrArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.feature_strings = args.feature_strings\n        self.model_path = args.model_path\n        self.fmllr_options = args.fmllr_options\n        self.pre_trans_paths = args.pre_trans_paths\n        self.lat_paths = args.lat_paths\n        self.spk2utt_paths = args.spk2utt_paths\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        with open(self.log_path, \"w\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                lat_path = self.lat_paths[dict_name]\n                feature_string = self.feature_strings[dict_name]\n                spk2utt_path = self.spk2utt_paths[dict_name]\n                trans_path = self.pre_trans_paths[dict_name]\n\n                latt_post_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-to-post\"),\n                        f\"--acoustic-scale={self.fmllr_options['acoustic_scale']}\",\n                        f\"ark:{lat_path}\",\n                        \"ark:-\",\n                    ],\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                weight_silence_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"weight-silence-post\"),\n                        f\"{self.fmllr_options['silence_weight']}\",\n                        self.fmllr_options[\"sil_phones\"],\n                        self.model_path,\n                        \"ark:-\",\n                        \"ark:-\",\n                    ],\n                    stdin=latt_post_proc.stdout,\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                gmm_gpost_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"gmm-post-to-gpost\"),\n                        self.model_path,\n                        feature_string,\n                        \"ark:-\",\n                        \"ark:-\",\n                    ],\n                    stdin=weight_silence_proc.stdout,\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                fmllr_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"gmm-est-fmllr-gpost\"),\n                        f\"--fmllr-update-type={self.fmllr_options['fmllr_update_type']}\",\n                        f\"--spk2utt=ark:{spk2utt_path}\",\n                        self.model_path,\n                        feature_string,\n                        \"ark,s,cs:-\",\n                        f\"ark:{trans_path}\",\n                    ],\n                    stdin=gmm_gpost_proc.stdout,\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE,\n                    env=os.environ,\n                    encoding=\"utf8\",\n                )\n                for line in fmllr_proc.stderr:\n                    log_file.write(line)\n                    m = self.progress_pattern.match(line.strip())\n                    if m:\n                        yield int(m.group(\"done\")), int(m.group(\"no_gpost\")), int(\n                            m.group(\"other_errors\")\n                        )\nmontreal_forced_aligner/corpus/acoustic_corpus.py\nclass AcousticCorpusPronunciationMixin(\n    AcousticCorpusMixin, MultispeakerDictionaryMixin, metaclass=ABCMeta\n):\n    \"\"\"\n    Mixin for acoustic corpora with Pronunciation dictionaries\n\n    See Also\n    --------\n    :class:`~montreal_forced_aligner.corpus.acoustic_corpus.AcousticCorpusMixin`\n        For corpus parsing parameters\n    :class:`~montreal_forced_aligner.dictionary.multispeaker.MultispeakerDictionaryMixin`\n        For dictionary parsing parameters\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def load_corpus(self) -> None:\n        \"\"\"\n        Load the corpus\n        \"\"\"\n        all_begin = time.time()\n        self.dictionary_setup()\n        self.log_debug(f\"Using {self.phone_set_type}\")\n        self.log_debug(f\"Loaded dictionary in {time.time() - all_begin}\")\n\n        begin = time.time()\n        self._load_corpus()\n        self.log_debug(f\"Loaded corpus in {time.time() - begin}\")\n\n        begin = time.time()\n        self.set_lexicon_word_set(self.corpus_word_set)\n        self.log_debug(f\"Set up lexicon word set in {time.time() - begin}\")\n\n        begin = time.time()\n\n        self.log_debug(\"Topology:\")\n        for k, v in self.kaldi_phones_for_topo.items():\n            self.log_debug(f\"{k}: {', '.join(v)}\")\n        self.log_debug(\"Extra questions:\")\n        for k, v in self.extra_questions_mapping.items():\n            self.log_debug(f\"{k}: {', '.join(v)}\")\n        self.write_lexicon_information()\n        self.log_debug(f\"Wrote lexicon information in {time.time() - begin}\")\n\n        begin = time.time()\n        for speaker in self.speakers:\n            speaker.set_dictionary(self.get_dictionary(speaker.name))\n        self.log_debug(f\"Set dictionaries for speakers in {time.time() - begin}\")\n\n        begin = time.time()\n        self.initialize_jobs()\n        self.log_debug(f\"Initialized jobs in {time.time() - begin}\")\n        begin = time.time()\n        self.write_corpus_information()\n        self.log_debug(f\"Wrote corpus information in {time.time() - begin}\")\n\n        begin = time.time()\n        self.create_corpus_split()\n        self.log_debug(f\"Created corpus split directory in {time.time() - begin}\")\n\n        begin = time.time()\n        self.generate_features()\n        self.log_debug(f\"Generated features in {time.time() - begin}\")\n\n        begin = time.time()\n        self.calculate_oovs_found()\n        self.log_debug(f\"Calculated oovs found in {time.time() - begin}\")\n        self.log_debug(f\"Setting up corpus took {time.time() - all_begin} seconds\")\nmontreal_forced_aligner/models.py\nclass LanguageModel(Archive):\n    \"\"\"\n    Class for MFA language models\n    \"\"\"\n\n    model_type = \"language_model\"\n\n    arpa_extension = \".arpa\"\n    extensions = [f\".{FORMAT}\", arpa_extension, \".lm\"]\n\n    def __init__(self, source: str, root_directory: Optional[str] = None):\n        if source in LanguageModel.get_available_models():\n            source = LanguageModel.get_pretrained_path(source)\n        from .config import get_temporary_directory\n\n        if root_directory is None:\n            root_directory = get_temporary_directory()\n\n        if source.endswith(self.arpa_extension):\n            self.root_directory = root_directory\n            self._meta = {}\n            self.name, _ = os.path.splitext(os.path.basename(source))\n            self.dirname = os.path.join(root_directory, self.name)\n            if not os.path.exists(self.dirname):\n                os.makedirs(self.dirname, exist_ok=True)\n            copy(source, self.large_arpa_path)\n        else:\n            super().__init__(source, root_directory)\n\n    @property\n    def decode_arpa_path(self) -> str:\n        \"\"\"\n        Uses the smallest language model for decoding\n        \"\"\"\n        for path in [self.small_arpa_path, self.medium_arpa_path, self.large_arpa_path]:\n            if os.path.exists(path):\n                return path\n        raise LanguageModelNotFoundError()\n\n    @property\n    def carpa_path(self) -> str:\n        \"\"\"\n        Uses the largest language model for rescoring\n        \"\"\"\n        for path in [self.large_arpa_path, self.medium_arpa_path, self.small_arpa_path]:\n            if os.path.exists(path):\n                return path\n        raise LanguageModelNotFoundError()\n\n    @property\n    def small_arpa_path(self) -> str:\n        \"\"\"Small arpa path\"\"\"\n        return os.path.join(self.dirname, f\"{self.name}_small{self.arpa_extension}\")\n\n    @property\n    def medium_arpa_path(self) -> str:\n        \"\"\"Medium arpa path\"\"\"\n        return os.path.join(self.dirname, f\"{self.name}_med{self.arpa_extension}\")\n\n    @property\n    def large_arpa_path(self) -> str:\n        \"\"\"Large arpa path\"\"\"\n        return os.path.join(self.dirname, self.name + self.arpa_extension)\n\n    def add_arpa_file(self, arpa_path: str) -> None:\n        \"\"\"\n        Adds an ARPA file to the model\n\n        Parameters\n        ----------\n        arpa_path: str\n            Path to ARPA file\n        \"\"\"\n        output_name = self.large_arpa_path\n        if arpa_path.endswith(\"_small.arpa\"):\n            output_name = self.small_arpa_path\n        elif arpa_path.endswith(\"_medium.arpa\"):\n            output_name = self.medium_arpa_path\n        copyfile(arpa_path, output_name)\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass LmRescoreFunction(KaldiFunction):\n    \"\"\"\n    Multiprocessing function rescore lattices by replacing the small G.fst with the medium G.fst\n\n    See Also\n    --------\n    :func:`~montreal_forced_aligner.transcription.Transcriber.transcribe`\n        Main function that calls this function in parallel\n    :meth:`.Transcriber.lm_rescore_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`lattice-lmrescore-pruned`\n        Relevant Kaldi binary\n    :openfst_src:`fstproject`\n        Relevant OpenFst binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.transcription.multiprocessing.LmRescoreArguments`\n        Arguments for the function\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG .* Overall, succeeded for (?P<succeeded>\\d+) lattices, failed for (?P<failed>\\d+)\"\n    )\n\n    def __init__(self, args: LmRescoreArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.lat_paths = args.lat_paths\n        self.rescored_lat_paths = args.rescored_lat_paths\n        self.old_g_paths = args.old_g_paths\n        self.new_g_paths = args.new_g_paths\n        self.lm_rescore_options = args.lm_rescore_options\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        with open(self.log_path, \"w\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                lat_path = self.lat_paths[dict_name]\n                rescored_lat_path = self.rescored_lat_paths[dict_name]\n                old_g_path = self.old_g_paths[dict_name]\n                new_g_path = self.new_g_paths[dict_name]\n                if sys.platform == \"win32\":\n                    project_type_arg = \"--project_output=true\"\n                else:\n                    project_type_arg = \"--project_type=output\"\n                if os.path.exists(rescored_lat_path):\n                    continue\n\n                project_proc = subprocess.Popen(\n                    [thirdparty_binary(\"fstproject\"), project_type_arg, old_g_path],\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                lattice_scale_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-lmrescore-pruned\"),\n                        f\"--acoustic-scale={self.lm_rescore_options['acoustic_scale']}\",\n                        \"-\",\n                        f\"fstproject {project_type_arg} {new_g_path} |\",\n                        f\"ark:{lat_path}\",\n                        f\"ark:{rescored_lat_path}\",\n                    ],\n                    stdin=project_proc.stdout,\n                    stderr=subprocess.PIPE,\n                    env=os.environ,\n                    encoding=\"utf8\",\n                )\n                for line in lattice_scale_proc.stderr:\n                    log_file.write(line)\n                    m = self.progress_pattern.match(line.strip())\n                    if m:\n                        yield int(m.group(\"succeeded\")), int(m.group(\"failed\"))\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass LmRescoreArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.transcription.multiprocessing.LmRescoreFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    lm_rescore_options: MetaDict\n    lat_paths: Dict[str, str]\n    rescored_lat_paths: Dict[str, str]\n    old_g_paths: Dict[str, str]\n    new_g_paths: Dict[str, str]\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass CarpaLmRescoreFunction(KaldiFunction):\n    \"\"\"\n    Multiprocessing function to rescore lattices by replacing medium G.fst with large G.carpa\n\n    See Also\n    --------\n    :func:`~montreal_forced_aligner.transcription.Transcriber.transcribe`\n        Main function that calls this function in parallel\n    :meth:`.Transcriber.carpa_lm_rescore_arguments`\n        Job method for generating arguments for this function\n    :openfst_src:`fstproject`\n        Relevant OpenFst binary\n    :kaldi_src:`lattice-lmrescore`\n        Relevant Kaldi binary\n    :kaldi_src:`lattice-lmrescore-const-arpa`\n        Relevant Kaldi binary\n\n    Parameters\n    ----------\n    args: CarpaLmRescoreArguments\n        Arguments\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG .* Overall, succeeded for (?P<succeeded>\\d+) lattices, failed for (?P<failed>\\d+)\"\n    )\n\n    def __init__(self, args: CarpaLmRescoreArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.lat_paths = args.lat_paths\n        self.rescored_lat_paths = args.rescored_lat_paths\n        self.old_g_paths = args.old_g_paths\n        self.new_g_paths = args.new_g_paths\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        with open(self.log_path, \"a\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                if sys.platform == \"win32\":\n                    project_type_arg = \"--project_output=true\"\n                else:\n                    project_type_arg = \"--project_type=output\"\n                lat_path = self.lat_paths[dict_name]\n                rescored_lat_path = self.rescored_lat_paths[dict_name]\n                old_g_path = self.old_g_paths[dict_name]\n                new_g_path = self.new_g_paths[dict_name]\n                if os.path.exists(rescored_lat_path):\n                    continue\n                project_proc = subprocess.Popen(\n                    [thirdparty_binary(\"fstproject\"), project_type_arg, old_g_path],\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                lmrescore_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-lmrescore\"),\n                        \"--lm-scale=-1.0\",\n                        f\"ark:{lat_path}\",\n                        \"-\",\n                        \"ark:-\",\n                    ],\n                    stdout=subprocess.PIPE,\n                    stdin=project_proc.stdout,\n                    stderr=log_file,\n                    env=os.environ,\n                )\n                lmrescore_const_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"lattice-lmrescore-const-arpa\"),\n                        \"--lm-scale=1.0\",\n                        \"ark:-\",\n                        new_g_path,\n                        f\"ark:{rescored_lat_path}\",\n                    ],\n                    stdin=lmrescore_proc.stdout,\n                    stderr=subprocess.PIPE,\n                    env=os.environ,\n                    encoding=\"utf8\",\n                )\n                for line in lmrescore_const_proc.stderr:\n                    log_file.write(line)\n                    m = self.progress_pattern.match(line.strip())\n                    if m:\n                        yield int(m.group(\"succeeded\")), int(m.group(\"failed\"))\nmontreal_forced_aligner/utils.py\ndef thirdparty_binary(binary_name: str) -> str:\n    \"\"\"\n    Generate full path to a given binary name\n\n    Notes\n    -----\n    With the move to conda, this function is deprecated as conda will manage the path much better\n\n    Parameters\n    ----------\n    binary_name: str\n        Executable to run\n\n    Returns\n    -------\n    str\n        Full path to the executable\n    \"\"\"\n    bin_path = shutil.which(binary_name)\n    if bin_path is None:\n        if binary_name in [\"fstcompile\", \"fstarcsort\", \"fstconvert\"] and sys.platform != \"win32\":\n            raise ThirdpartyError(binary_name, open_fst=True)\n        else:\n            raise ThirdpartyError(binary_name)\n    return bin_path\nmontreal_forced_aligner/models.py\nclass AcousticModel(Archive):\n    \"\"\"\n    Class for storing acoustic models in MFA, exported as zip files containing the necessary Kaldi files\n    to be reused\n\n    \"\"\"\n\n    files = [\"final.mdl\", \"final.alimdl\", \"final.occs\", \"lda.mat\", \"tree\"]\n    extensions = [\".zip\", \".am\"]\n\n    model_type = \"acoustic\"\n\n    def __init__(self, source: str, root_directory: Optional[str] = None):\n        if source in AcousticModel.get_available_models():\n            source = AcousticModel.get_pretrained_path(source)\n\n        super().__init__(source, root_directory)\n\n    def add_meta_file(self, trainer: ModelExporterMixin) -> None:\n        \"\"\"\n        Add metadata file from a model trainer\n\n        Parameters\n        ----------\n        trainer: :class:`~montreal_forced_aligner.abc.ModelExporterMixin`\n            Trainer to supply metadata information about the acoustic model\n        \"\"\"\n        with open(os.path.join(self.dirname, \"meta.json\"), \"w\", encoding=\"utf8\") as f:\n            json.dump(trainer.meta, f)\n\n    @property\n    def parameters(self) -> MetaDict:\n        \"\"\"Parameters to pass to top-level workers\"\"\"\n        params = {**self.meta[\"features\"]}\n        params[\"non_silence_phones\"] = {x for x in self.meta[\"phones\"]}\n        params[\"oov_phone\"] = self.meta[\"oov_phone\"]\n        params[\"optional_silence_phone\"] = self.meta[\"optional_silence_phone\"]\n        params[\"other_noise_phone\"] = self.meta[\"other_noise_phone\"]\n        params[\"phone_set_type\"] = self.meta[\"phone_set_type\"]\n        return params\n\n    @property\n    def meta(self) -> MetaDict:\n        \"\"\"\n        Metadata information for the acoustic model\n        \"\"\"\n        default_features = {\n            \"feature_type\": \"mfcc\",\n            \"use_energy\": False,\n            \"frame_shift\": 10,\n            \"snip_edges\": True,\n            \"low_frequency\": 20,\n            \"high_frequency\": 7800,\n            \"sample_frequency\": 16000,\n            \"allow_downsample\": True,\n            \"allow_upsample\": True,\n            \"pitch\": False,\n            \"uses_cmvn\": True,\n            \"uses_deltas\": True,\n            \"uses_splices\": False,\n            \"uses_voiced\": False,\n            \"uses_speaker_adaptation\": False,\n            \"silence_weight\": 0.0,\n            \"fmllr_update_type\": \"full\",\n            \"splice_left_context\": 3,\n            \"splice_right_context\": 3,\n        }\n        if not self._meta:\n            meta_path = os.path.join(self.dirname, \"meta.json\")\n            format = \"json\"\n            if not os.path.exists(meta_path):\n                meta_path = os.path.join(self.dirname, \"meta.yaml\")\n                format = \"yaml\"\n            if not os.path.exists(meta_path):\n                self._meta = {\n                    \"version\": \"0.9.0\",\n                    \"architecture\": \"gmm-hmm\",\n                    \"features\": default_features,\n                }\n            else:\n                with open(meta_path, \"r\", encoding=\"utf8\") as f:\n                    if format == \"yaml\":\n                        self._meta = yaml.safe_load(f)\n                    else:\n                        self._meta = json.load(f)\n                if self._meta[\"features\"] == \"mfcc+deltas\":\n                    self._meta[\"features\"] = default_features\n            if \"phone_type\" not in self._meta:\n                self._meta[\"phone_type\"] = \"triphone\"\n            if \"optional_silence_phone\" not in self._meta:\n                self._meta[\"optional_silence_phone\"] = \"sil\"\n            if \"oov_phone\" not in self._meta:\n                self._meta[\"oov_phone\"] = \"spn\"\n            if \"other_noise_phone\" not in self._meta:\n                self._meta[\"other_noise_phone\"] = \"sp\"\n            if \"phone_set_type\" not in self._meta:\n                self._meta[\"phone_set_type\"] = \"UNKNOWN\"\n            self._meta[\"phones\"] = set(self._meta.get(\"phones\", []))\n            if (\n                \"uses_speaker_adaptation\" not in self._meta[\"features\"]\n                or not self._meta[\"features\"][\"uses_speaker_adaptation\"]\n            ):\n                self._meta[\"features\"][\"uses_speaker_adaptation\"] = os.path.exists(\n                    os.path.join(self.dirname, \"final.alimdl\")\n                )\n            if (\n                \"uses_splices\" not in self._meta[\"features\"]\n                or not self._meta[\"features\"][\"uses_splices\"]\n            ):\n                self._meta[\"features\"][\"uses_splices\"] = os.path.exists(\n                    os.path.join(self.dirname, \"lda.mat\")\n                )\n                if self._meta[\"features\"][\"uses_splices\"]:\n                    self._meta[\"features\"][\"uses_deltas\"] = False\n        self.parse_old_features()\n        return self._meta\n\n    def pretty_print(self) -> None:\n        \"\"\"\n        Prints the metadata information to the terminal\n        \"\"\"\n        from .utils import get_mfa_version\n\n        printer = TerminalPrinter()\n        configuration_data = {\"Acoustic model\": {\"name\": (self.name, \"green\"), \"data\": {}}}\n        version_color = \"green\"\n        if self.meta[\"version\"] != get_mfa_version():\n            version_color = \"red\"\n        configuration_data[\"Acoustic model\"][\"data\"][\"Version\"] = (\n            self.meta[\"version\"],\n            version_color,\n        )\n\n        if \"citation\" in self.meta:\n            configuration_data[\"Acoustic model\"][\"data\"][\"Citation\"] = self.meta[\"citation\"]\n        if \"train_date\" in self.meta:\n            configuration_data[\"Acoustic model\"][\"data\"][\"Train date\"] = self.meta[\"train_date\"]\n        configuration_data[\"Acoustic model\"][\"data\"][\"Architecture\"] = self.meta[\"architecture\"]\n        configuration_data[\"Acoustic model\"][\"data\"][\"Phone type\"] = self.meta[\"phone_type\"]\n        configuration_data[\"Acoustic model\"][\"data\"][\"Features\"] = {\n            \"Feature type\": self.meta[\"features\"][\"feature_type\"],\n            \"Frame shift\": self.meta[\"features\"][\"frame_shift\"],\n            \"Performs speaker adaptation\": self.meta[\"features\"][\"uses_speaker_adaptation\"],\n            \"Performs LDA on features\": self.meta[\"features\"][\"uses_splices\"],\n        }\n        if self.meta[\"phones\"]:\n            configuration_data[\"Acoustic model\"][\"data\"][\"Phones\"] = self.meta[\"phones\"]\n        else:\n            configuration_data[\"Acoustic model\"][\"data\"][\"Phones\"] = (\"None found!\", \"red\")\n\n        printer.print_config(configuration_data)\n\n    def add_model(self, source: str) -> None:\n        \"\"\"\n        Add file into archive\n\n        Parameters\n        ----------\n        source: str\n            File to add\n        \"\"\"\n        for f in self.files:\n            if os.path.exists(os.path.join(source, f)):\n                copyfile(os.path.join(source, f), os.path.join(self.dirname, f))\n\n    def export_model(self, destination: str) -> None:\n        \"\"\"\n        Extract the model files to a new directory\n\n        Parameters\n        ----------\n        destination: str\n            Destination directory to extract files to\n        \"\"\"\n        os.makedirs(destination, exist_ok=True)\n        for f in self.files:\n            if os.path.exists(os.path.join(self.dirname, f)):\n                copyfile(os.path.join(self.dirname, f), os.path.join(destination, f))\n\n    def log_details(self, logger: Logger) -> None:\n        \"\"\"\n        Log metadata information to a logger\n\n        Parameters\n        ----------\n        logger: :class:`~logging.Logger`\n            Logger to send debug information to\n        \"\"\"\n        logger.debug(\"\")\n        logger.debug(\"====ACOUSTIC MODEL INFO====\")\n        logger.debug(\"Acoustic model root directory: \" + self.root_directory)\n        logger.debug(\"Acoustic model dirname: \" + self.dirname)\n        meta_path = os.path.join(self.dirname, \"meta.json\")\n        if not os.path.exists(meta_path):\n            meta_path = os.path.join(self.dirname, \"meta.yaml\")\n        logger.debug(\"Acoustic model meta path: \" + meta_path)\n        if not os.path.exists(meta_path):\n            logger.debug(\"META.YAML DOES NOT EXIST, this may cause issues in validating the model\")\n        logger.debug(\"Acoustic model meta information:\")\n        stream = yaml.dump(self.meta)\n        logger.debug(stream)\n        logger.debug(\"\")\n\n    def validate(self, dictionary: DictionaryMixin) -> None:\n        \"\"\"\n        Validate this acoustic model against a pronunciation dictionary to ensure their\n        phone sets are compatible\n\n        Parameters\n        ----------\n        dictionary: :class:`~montreal_forced_aligner.dictionary.mixins.DictionaryMixin`\n            DictionaryMixin  to compare phone sets with\n\n        Raises\n        ------\n        :class:`~montreal_forced_aligner.exceptions.PronunciationAcousticMismatchError`\n            If there are phones missing from the acoustic model\n        \"\"\"\n        if isinstance(dictionary, G2PModel):\n            missing_phones = dictionary.meta[\"phones\"] - set(self.meta[\"phones\"])\n        else:\n            missing_phones = dictionary.non_silence_phones - set(self.meta[\"phones\"])\n        if missing_phones:\n            raise (PronunciationAcousticMismatchError(missing_phones))\nmontreal_forced_aligner/transcription/multiprocessing.py\nclass LatGenFmllrFunction(KaldiFunction):\n    \"\"\"\n    Regenerate lattices using initial fMLLR transforms\n\n    See Also\n    --------\n    :func:`~montreal_forced_aligner.transcription.Transcriber.transcribe_fmllr`\n        Main function that calls this function in parallel\n    :meth:`.Transcriber.lat_gen_fmllr_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`gmm-latgen-faster`\n        Relevant Kaldi binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.transcription.multiprocessing.LatGenFmllrArguments`\n        Arguments for the function\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG.*Log-like per frame for utterance (?P<utterance>.*) is (?P<loglike>[-\\d.]+) over (?P<num_frames>\\d+) frames.\"\n    )\n\n    def __init__(self, args: LatGenFmllrArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.feature_strings = args.feature_strings\n        self.tmp_lat_paths = args.tmp_lat_paths\n        self.word_symbol_paths = args.word_symbol_paths\n        self.hclg_paths = args.hclg_paths\n        self.decode_options = args.decode_options\n        self.model_path = args.model_path\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        with open(self.log_path, \"w\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                feature_string = self.feature_strings[dict_name]\n                words_path = self.word_symbol_paths[dict_name]\n                hclg_path = self.hclg_paths[dict_name]\n                tmp_lat_path = self.tmp_lat_paths[dict_name]\n                lat_gen_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"gmm-latgen-faster\"),\n                        f\"--max-active={self.decode_options['max_active']}\",\n                        f\"--beam={self.decode_options['beam']}\",\n                        f\"--lattice-beam={self.decode_options['lattice_beam']}\",\n                        f\"--acoustic-scale={self.decode_options['acoustic_scale']}\",\n                        \"--determinize-lattice=false\",\n                        \"--allow-partial=true\",\n                        f\"--word-symbol-table={words_path}\",\n                        self.model_path,\n                        hclg_path,\n                        feature_string,\n                        f\"ark:{tmp_lat_path}\",\n                    ],\n                    stderr=subprocess.PIPE,\n                    env=os.environ,\n                    encoding=\"utf8\",\n                )\n                for line in lat_gen_proc.stderr:\n                    log_file.write(line)\n                    m = self.progress_pattern.match(line.strip())\n                    if m:\n                        yield m.group(\"utterance\"), m.group(\"loglike\"), m.group(\"num_frames\")\nmontreal_forced_aligner/exceptions.py\nclass KaldiProcessingError(MFAError):\n    \"\"\"\n    Exception class for when a Kaldi binary has an exception\n\n    Parameters\n    ----------\n    error_logs: list[str]\n        List of Kaldi logs that had errors\n    log_file: str, optional\n        Overall log file to find more information\n    \"\"\"\n\n    def __init__(self, error_logs: List[str], log_file: Optional[str] = None):\n        super().__init__(\n            f\"There were {len(error_logs)} job(s) with errors when running Kaldi binaries.\"\n        )\n\n        if log_file is not None:\n            self.message_lines.append(\n                f\" For more details, please check {self.printer.error_text(log_file)}\"\n            )\n        self.error_logs = error_logs\n        self.log_file = log_file\n\n    def update_log_file(self, logger: logging.Logger) -> None:\n        \"\"\"\n        Update the log file output\n\n        Parameters\n        ----------\n        logger: logging.Logger\n            Logger\n        \"\"\"\n        if logger.handlers:\n            self.log_file = logger.handlers[0].baseFilename\n        self.message_lines = [\n            f\"There were {len(self.error_logs)} job(s) with errors when running Kaldi binaries.\"\n        ]\n        if self.log_file is not None:\n            self.message_lines.append(\n                f\" For more details, please check {self.printer.error_text(self.log_file)}\"\n            )\n", "answers": ["                    function = FmllrRescoreFunction(args)"], "length": 5354, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "affb55c8ffdf682e36326f29d9a44390d10a211cc1beb0ec"}
{"input": "from libmich.core.element import Bit, Str, Int, Layer, Block, show, debug, \\\n    log, ERR, WNG, DBG\nfrom libmich.utils.CRC16 import CRC16\nfrom binascii import unhexlify, hexlify\n# -*- coding: UTF-8 -*-\n#/**\n# * Software Name : libmich \n# * Version : 0.2.2\n# *\n# * Copyright © 2012. Benoit Michau. ANSSI.\n# *\n# * This program is free software: you can redistribute it and/or modify\n# * it under the terms of the GNU General Public License version 2 as published\n# * by the Free Software Foundation. \n# *\n# * This program is distributed in the hope that it will be useful,\n# * but WITHOUT ANY WARRANTY; without even the implied warranty of\n# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# * GNU General Public License for more details. \n# *\n# * You will find a copy of the terms and conditions of the GNU General Public\n# * License version 2 in the \"license.txt\" file or\n# * see http://www.gnu.org/licenses/ or write to the Free Software Foundation,\n# * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA\n# *\n# *--------------------------------------------------------\n# * File Name : formats/IEEE802154.py\n# * Created : 2012-01-28\n# * Authors : Benoit Michau \n# *--------------------------------------------------------\n#*/ \n\n#!/usr/bin/env python\n\n\n# generic imports\n\ndef unh(buf):\n    return unhexlify(buf.replace('\\n', '').replace(' ', ''))\n\n###\n#\n# IEEE 802.15.4 PHY and MAC format\n# PHY is the one at 2.4 GHz\n#\n# These are from IEEE 802.15.4 spec\nBool_dict = {0:'False', 1:'True'}\nType_dict = {0:'Beacon', 1:'Data', 2:'Ack', 3:'MAC command', # from standard IEEE 802.15.4\n             4:'Visibility', # from Samsung ETRI (802.15.7)\n             }\nAddr_dict = {0:'Not present', 1:'Reserved', \\\n             2:'16-bit address', 3:'64-bit address'}\nAddr_len = {0:0, 1:0, 2:2, 3:8}\n#\n", "context": "libmich/core/element.py\ndef debug(thres, level, string):\n    if level and level<=thres:\n        print('[%s] %s' %(debug_level[level], string))\nlibmich/core/element.py\ndef show(self, with_trans=False):\n    tr, re = '', ''\n    if self.is_transparent():\n        # TODO: eval the best convinience here\n        if not with_trans:\n            return ''\n        tr = ' - transparent'\n    else:\n        tr = ''\n    if self.ReprName != '':\n        re = ''.join((self.ReprName, ' '))\n    return '<%s[%s%s] : %s>' % ( re, self.CallName, tr, repr(self) )\nlibmich/core/element.py\nclass Layer(object):\n    '''\n    class built from stack of \"Str\", \"Int\", \"Bit\" and \"Layer\" objects\n    got from the initial constructorList.\n    Layer object is recursive: it can contain other Layer() instances\n    Layer does not require to be byte-aligned. This happens depending of the\n    presence of Bit() instances.\n    \n    when instantiated:\n    clones the list of \"Str\", \"Int\", \"Bit\" elements in the constructorList\n    to build a dynamic elementList, that can be changed afterwards (adding /\n    removing objects);\n    A common hierarchy level for the whole Layer is defined, it is useful \n    when used into \"Block\" to create hierarchical relationships: \n        self.hierarchy (int), self.inBlock (bool)\n        when .inBlock is True, provides: .get_payload(), .get_header(), \n             .has_next(), .get_next(), .get_previous(), and .Block\n    It provides several methods for calling elements in the layer:\n        by CallName / ReprName passed in attribute\n        by index in the elementList\n        can be iterated too\n        and many other manipulations are defined\n    It has also some common methods with \"Str\", \"Int\" and \"Bit\" to emulate \n    a common handling:\n    __str__, __len__, __int__, bit_len, getattr, showattr, show, map\n    '''\n    #\n    # debugging threshold for Layer:\n    dbg = ERR\n    # add some sanity checks\n    #safe = True\n    safe = False\n    # define the type of str() and map() method\n    _byte_aligned = True\n    # reserved attributes:\n    Reservd = ['CallName', 'ReprName', 'elementList', 'Len', 'BitLen',\n               'hierarchy', 'inBlock', 'Trans', 'ConstructorList',\n               'dbg', 'Reservd']\n    #\n    # represent transparent elements in __repr__()\n    _repr_trans = True\n    \n    # structure description:\n    constructorList = []\n    \n    def __init__(self, CallName='', ReprName='', Trans=False, **kwargs):\n        if type(CallName) is not str:\n            raise AttributeError('CallName must be a string')\n        elif len(CallName) == 0:\n            self.CallName = self.__class__.__name__\n        else:\n            self.CallName = CallName\n        if type(ReprName) is str and len(ReprName) > 0: \n            self.ReprName = ReprName\n        else: \n            self.ReprName = ''\n        self.elementList = []\n        self.set_hierarchy(0)\n        self.inBlock = False\n        self.Trans = Trans\n        \n        CallNames = []\n        for e in self.constructorList:\n            # This is for little players\n            #if isinstance(e, Element):\n            # OK, now let's put the balls on the table and\n            # make Layer recursive (so will have Layer() into Layer())\n            if isinstance(e, (Element, Layer)):\n                if e.CallName in self.Reservd:\n                    if self.safe or self.dbg >= ERR:\n                        log(ERR, '(Layer - %s) using a reserved '\n                            'attribute as CallName %s: aborting...' \\\n                          % (self.__class__, e.CallName))\n                    return\n                if e.CallName in CallNames:\n                    if self.dbg >= WNG:\n                        log(WNG, '(Layer - %s) different elements have ' \\\n                           'the same CallName %s' % (self.__class__, e.CallName))\n                if isinstance(e, Element):\n                    self.append(e.clone())\n                # do not clone Layer() as it breaks dynamic element inside\n                # i.e. element with PtFunc, LenFunc, DictFunc, TransFunc defined\n                # TODO: patch Layer().clone() method to solve this...\n                # lets try with deepcopy()\n                elif isinstance(e, Layer):\n                    self.append(e.clone())\n            CallNames.append(e.CallName)\n        \n        # check for bit alignment until we lost information on the Layer length\n        # also check if fixed length can be deduced\n        self.BitLen = 0\n        for e in self.elementList:\n            if self.dbg >= DBG:\n                log(DBG, '(Layer - %s) length verification for %s' \\\n                    % (self.__class__, e.CallName))\n            if isinstance(e, Bit):\n                self.BitLen += e.bit_len()\n            elif hasattr(e, 'Len') and type(e.Len) is int:\n                self.BitLen += (e.Len)*8\n            else:\n                self.BitLen, self.Len = 'var', 'var'\n                break\n        if type(self.BitLen) is int :\n            if self.BitLen % 8:\n                if self.dbg >= WNG and self._byte_aligned:\n                    log(WNG, '(Layer - %s) Elements seem not to be '\\\n                        'byte-aligned: hope you expect it!' \\\n                        % self.__class__)\n                # record length in bit (precise one) and in bytes (unprecised)\n                self.Len = 1 + self.BitLen//8\n            else:\n                self.Len = self.BitLen//8\n        #\n        # check additional args that would correspond to contained Element\n        args = kwargs.keys()\n        if self.dbg >= DBG:\n            log(DBG, '(Layer - %s) init kwargs: %s' % (self.__class__, args))\n        for e in self:\n            if hasattr(e, 'CallName') and e.CallName in args:\n                if hasattr(e, 'Pt'):\n                    e.Pt = kwargs[e.CallName]\n                else:\n                    kwe = kwargs[e.CallName]\n                    if isinstance(kwe, (tuple, list)):\n                        e.__init__(*kwe)\n                    elif isinstance(kwe, dict):\n                        e.__init__(**kwe)\n    \n    # define some basic list facilities for managing elements into the Layer, \n    # through the \"elementList\" attribute:\n    def __iter__(self):\n        if 'elementList' in self.__dict__.keys():\n            return self.__dict__['elementList'].__iter__()\n        else: return [].__iter__()\n    \n    def __getitem__(self, num):\n        return self.elementList[num]\n    \n    def __getslice__(self, i, j):\n        l = Layer('_slice_')\n        if not i or i < 0:\n            i=0\n        #maxj = len(self.elementList)-1\n        maxj = len(self.elementList)\n        if not j or j > maxj:\n            j = maxj\n        #\n        for k in xrange(i, j):\n            l.append( self[k] )\n        return l\n    \n    def __setitem__(self, num, value):\n        # special handling here: \n        # use to override the element value \n        # with its \"Val\" attribute (like when mapping a string)\n        self.elementList[num].Val = value\n    \n    def append(self, element):\n        #if isinstance(element, Element):\n        # make Layer recursive:\n        if isinstance(element, (Element, Layer)):\n            if self.dbg >= WNG and element.CallName in self.getattr():\n                log(WNG, '(Layer - %s) different elements have the same '\\\n                         'CallName %s' % (self.__class__, element.CallName))\n            self.elementList.append(element)\n    \n    def __lshift__(self, element):\n        self.append(element)\n        if isinstance(element, Layer):\n            element.inc_hierarchy(self.hierarchy)\n    \n    def insert(self, index, element):\n        CallNames = self.getattr()\n        #if isinstance(element, Element):\n        # make Layer recursive:\n        if isinstance(element, (Element, Layer)):\n            if self.dbg >= WNG and element.CallName in CallNames:\n                log(WNG, '(Layer - %s) different elements have the same '\\\n                         'CallName %s' % (self.__class__, element.CallName))\n            self.elementList.insert(index, element)\n    \n    def __rshift__(self, element):\n        self.insert(0, element)\n        if isinstance(element, Layer):\n            element.inc_hierarchy(self.hierarchy)\n    \n    def extend(self, newElementList):\n        for e in newElementList:\n            self.append(e)\n    \n    def remove(self, element):\n        for e in self:\n            if e == element:\n                self.elementList.remove(element)\n    \n    def replace(self, current_element, new_element):\n        # check index of the element ro replace\n        index = 0\n        for elt in self.elementList:\n            if elt == current_element:\n                self.remove(current_element)\n                self.insert(index, new_element)\n                return\n            else:\n                index += 1\n    \n    # define some attribute facilities for managing elements \n    # by their CallName into the Layer\n    # warning: dangerous when parsing data into Layer, \n    # with elements which could have same CallName\n    # \n    # list facilities can be preferred in this case\n    def __getattr__(self, name):\n        names = [x.CallName for x in self.elementList]\n        if name in names:\n            return self.elementList[ names.index(name) ]\n        names = [x.ReprName for x in self.elementList]\n        if name in names:\n            return self.elementList[ names.index(name) ]\n        #\n        return object.__getattribute__(self, name)\n        #return self.__getattribute__(name)\n        #return getattr(self, name)\n    \n    def __setattr__(self, name, value):\n        # special handling here: use to override the element value \n        # with its \"Val\" attribute (like when mapping a string)\n        for e in self:\n            if name == e.CallName or name == e.ReprName: \n                e.Val = value\n                return\n        return object.__setattr__(self, name, value)\n        raise AttributeError( '\"Layer\" has no \"%s\" attribute: %s' \\\n              % (name, self.getattr()) )\n    \n    def __hasattr__(self, name):\n        for e in self:\n            if name == e.CallName or name == e.ReprName: \n                return True\n        #return object.__hasattr__(self, name): \n        # not needed (does not work in the code... but works in python...)\n        raise AttributeError( '\"Layer\" has no \"%s\" attribute: %s' \\\n              % (name, self.getattr()) )\n    \n    # method for managing the Layer hierarchy (easy):\n    def set_hierarchy(self, hier=0):\n        self.hierarchy = hier\n        for e in self:\n            if isinstance(e, Layer):\n                e.set_hierarchy(hier)\n        \n    def inc_hierarchy(self, ref=None):\n        if ref is None:\n            self.set_hierarchy(self.hierarchy+1)\n        else: \n            self.set_hierarchy(self.hierarchy+ref+1)\n        #for l in self:\n        #    if isinstance(l, Layer):\n        #        l.hierarchy = self.hierarchy\n    \n    def dec_hierarchy(self, ref=None):\n        if ref is None: \n            self.set_hierarchy(self.hierarchy-1)\n        else: \n            self.set_hierarchy(self.hierarchy+ref-1)\n        #for l in self:\n        #    if isinstance(l, Layer):\n        #        l.hierarchy = self.hierarchy\n    \n    # define same methods as \"Element\" type for being use the same way\n    def __str__(self):\n        if self.dbg >= DBG:\n            log(DBG, '(Layer.__str__) entering str() for %s' % self.CallName)\n        # First take care of transparent Layer (e.g. in L3Mobile)\n        if hasattr(self, 'Trans') and self.Trans:\n            return ''\n        # dispatch to the right method depending of byte alignment\n        if self._byte_aligned is True:\n            return self.__str_aligned()\n        else:\n            return self.__str_unaligned()\n    \n    def __str_unaligned(self):\n        # then init resulting string \n        # and bit offset needed to shift unaligned strings\n        s = []\n        off = 0\n        # loop on each element into the Layer\n        # also on Layer into Layer...\n        for e in self:\n            shtr_e, bitlen_e = e.shtr(), e.bit_len()\n            rest_e = bitlen_e % 8\n            if self.dbg >= DBG:\n                log(DBG, '(Layer.__str__) %s: %s, %i, offset: %i' \\\n                    % (e.CallName, hexlify(shtr_e), bitlen_e, off))\n            # if s is not byte-aligned and e is not transparent\n            # update the last component of s\n            if off and shtr_e:\n                # 1st update last bits of s with MSB of e, \n                # before stacking with the rest of e\n                # (8 - off) is the room left in the LSB of s\n                s[-1] = ''.join((s[-1][:-1],\n                                  chr(ord(s[-1][-1]) + shtr_e.left_val(8-off)),\n                                  (shtr_e << (8-off))\n                                ))\n                # take care in case the shifting of e voids its last byte\n                if rest_e and rest_e-(8-off) <= 0:\n                    s[-1] = s[-1][:-1]\n                # update offset\n                if rest_e:\n                    off += bitlen_e\n                    off %= 8\n            # in case s is already aligned, append a new component to s\n            elif shtr_e:\n                s.append(shtr_e)\n                # update offset\n                if rest_e:\n                    off += rest_e\n            if self.dbg >= DBG:\n                log(DBG, '(Layer.__str__) %s' % hexlify(s))\n        # well done!\n        return ''.join(s)\n    \n    def __str_aligned(self):\n        s = []\n        BitStream = ''\n        # loop on each element in the Layer\n        # also on Layer into Layer...\n        for e in self:\n            # need special processing for stacking \"Bit\" element: \n            #   using \"BitStream\" variable\n            #   works only with contiguous \"Bit\" elements \n            #   to avoid byte-misalignment of other element in the Layer \n            #   (and programming complexity with shifting everywhere...)\n            if isinstance(e, Bit):\n                # manage element transparency with (Trans, TranFunc)\n                # and build a bitstream ('100110011...1101011') from Bit values\n                if not e.is_transparent():\n                    BitStream += str(e.__bin__())\n                # when arriving on a byte boundary from bitstream, \n                # create bytes and put it into the s variable\n                if len(BitStream) >= 8:\n                    while 1:\n                        s.append( pack('!B', int(BitStream[:8], 2)) )\n                        BitStream = BitStream[8:]\n                        if len(BitStream) < 8:\n                            break\n                if self.dbg >= DBG:\n                    log(DBG, '(Element) %s: %s, %s\\nBitstream: %s' \\\n                        % (e.CallName, e(), e.__bin__(), BitStream))\n            # when going to standard Str or Int element, \n            # or directly end of __str__ function \n            # verify the full BitStream has been consumed\n            # and continue to build the resulting string easily...\n            else:\n                # possible byte mis-alignment for Str / Int is not managed...\n                self.__is_aligned(BitStream)\n                BitStream = ''\n                if isinstance(e, Layer) and not e.Trans \\\n                or isinstance(e, Element):\n                    s.append( str(e) )\n        self.__is_aligned(BitStream)\n        return ''.join(s)\n    \n    def __is_aligned(self, BitStream):\n        if BitStream and self.dbg >= ERR:\n            log(ERR, '(Layer - %s) some of the Bit elements have not been ' \\\n                'stacked in the \"str(Layer)\"\\nremaining bitstream: %s' \\\n                % (self.__class__, BitStream))\n            if self.safe:\n                assert(not BitStream)\n    \n    def __call__(self):\n        return self.__str__()\n    \n    def __len__(self):\n        return len(self.__str__())\n    \n    def shtr(self):\n        return shtr(self.__str__())\n    \n    def bit_len(self):\n        # just go over all internal elements to track their own bit length\n        # updated attributes initialized when Layer was constructed\n        self.BitLen = 0\n        for e in self:\n            if hasattr(e, 'bit_len'):\n                self.BitLen += e.bit_len()\n            elif hasattr(e, '__len__'):\n                self.BitLen += len(e)*8\n        self.Len = 1 + (self.BitLen // 8) if self.BitLen % 8 \\\n                   else (self.BitLen // 8)\n        return self.BitLen\n    \n    def __hex__(self):\n        bit_len = self.bit_len()\n        hex_len = bit_len/4\n        if bit_len%4:\n            hex_len += 1\n        #\n        return self.__str__().encode('hex')[:hex_len]\n    \n    def __bin__(self):\n        bits = []\n        for e in self:\n            bits.append( e.__bin__() )\n        return ''.join(bits)\n    \n    def __int__(self):\n        # big endian integer representation of the string buffer\n        if self._byte_aligned:\n            return shtr(self).left_val(len(self)*8)\n        else:\n            return shtr(self).left_val(self.bit_len())\n    \n    def __repr__(self):\n        t = ''\n        if self.Trans:\n            t = ' - transparent '\n        s = '<%s[%s]%s: ' % ( self.ReprName, self.CallName, t )\n        for e in self:\n            if self._repr_trans or not e.is_transparent():\n                s += '%s(%s):%s, ' % ( e.CallName, e.ReprName, repr(e) )\n        s = s[:-2] + '>'\n        return s\n    \n    def map_len(self):\n        return len(self)\n    \n    def getattr(self):\n        return [e.CallName for e in self.elementList]\n    \n    def showattr(self):\n        for a in self.getattr():\n            print('%s : %s' % ( a, repr(self.__getattr__(a))) )\n    \n    def clone2(self):\n        # TODO: deepcopy is not adapted here, can create errors...\n        return deepcopy(self)\n    \n    def clone(self):\n        #\n        # build a new constructorList made of clones\n        constructorList_new = []\n        for e in self:\n            constructorList_new.append(e.clone())\n        #\n        # substitute the current constructorList with the one made of clones\n        constructorList_ori = self.__class__.constructorList\n        self.__class__.constructorList = constructorList_new\n        # instantiate the clone\n        c = self.__class__()\n        c.CallName = self.CallName\n        if hasattr(self, 'ReprName'):\n            c.ReprName = self.ReprName\n        if hasattr(self, 'Trans'):\n            c.Trans = self.Trans\n        # restore the original constructorList\n        self.__class__.constructorList = constructorList_ori\n        #\n        return c\n    \n    def is_transparent(self):\n        if self.Trans:\n            return True\n        else:\n            return False\n    \n    def show(self, with_trans=False):\n        re, tr = '', ''\n        if self.ReprName != '':\n            re = '%s ' % self.ReprName\n        if self.is_transparent():\n            # TODO: eval the best convinience here\n            if not with_trans:\n                return ''\n            tr = ' - transparent'\n        # Layer content\n        str_lst = [e.show().replace('\\n', '\\n ') for e in self]\n        # insert spaces for nested layers and filter out empty content\n        str_lst = [' %s\\n' % s for s in str_lst if s]\n        # insert layer's title\n        str_lst.insert(0, '### %s[%s]%s ###\\n' % (re, self.CallName, tr))\n        # return full inline string without last CR\n        return ''.join(str_lst)[:-1]\n    \n    def map(self, string=''):\n        if self.dbg >= DBG:\n            log(DBG, '(Layer.map) entering map() for %s' % self.CallName)\n        # First take care of transparent Layer (e.g. in L3Mobile)\n        if hasattr(self, 'Trans') and self.Trans:\n            return\n        # dispatch to the right method depending of byte alignment\n        if self._byte_aligned is True:\n            self.__map_aligned(string)\n        else:\n            self.__map_unaligned(string)\n    \n    def __map_unaligned(self, string=''):\n        s = shtr(string)\n        # otherwise go to map() over all elements\n        for e in self:\n            if self.dbg >= DBG:\n                log(DBG, '(Layer.__map_unaligned) %s, bit length: %i' \\\n                    % (e.CallName, e.bit_len()))\n                log(DBG, '(Layer.__map_unaligned) string: %s' % hexlify(s))\n            # this is beautiful\n            s = e.map_ret(s)\n    \n    def __map_aligned(self, string=''):\n        # Bit() elements are processed intermediary: \n        # 1st placed into BitStack\n        # and when BitStack is byte-aligned (check against BitStack_len)\n        # string buffer is then mapped to it\n        self.__BitStack = []\n        self.__BitStack_len = 0\n        # Furthermore, it manages only contiguous Bit elements \n        # for commodity... otherwise, all other elements should be shifted\n        #\n        for e in self:\n            # special processing for Bit() element:\n            if isinstance(e, Bit):\n                self.__add_to_bitstack(e)\n                # if BitStack is byte aligned, map string to it:\n                if self.__BitStack_len % 8 == 0:\n                    string = self.__map_to_bitstack(string)\n            # for other elements (Str(), Int(), Layer()), standard processing:   \n            else:\n                if self.__BitStack_len > 0 and self.dbg >= ERR:\n                    log(WNG, '(Layer - %s) some of the Bit elements have not ' \\\n                        'been mapped in the \"Layer\": not byte-aligned' \\\n                        % self.__class__)\n                if isinstance(e, (Layer, Element)) and not e.is_transparent():\n                    if len(string) < e.map_len() and self.dbg >= WNG:\n                        log(WNG, '(Layer - %s) String buffer not long ' \\\n                            'enough for %s' % (self.__class__, e.CallName))\n                        #if self.safe:\n                        #    return\n                    e.map(string)\n                    string = string[e.map_len():]\n        # delete .map() *internal* attributes\n        del self.__BitStack\n        del self.__BitStack_len\n    \n    def __add_to_bitstack(self, bit_elt):\n        # check for Bit() element transparency\n        if not bit_elt.is_transparent():\n            self.__BitStack += [bit_elt]\n            self.__BitStack_len += bit_elt.bit_len()\n            \n    def __map_to_bitstack(self, string):\n        # 1st check if string is long enough for the prepared BitStack\n        if len(string) < self.__BitStack_len//8 and self.dbg >= ERR:\n            log(ERR, '(Layer - %s) String buffer not long enough for %s' \\\n                % (self.__class__, self.__BitStack[-1].CallName))\n            #if self.safe:\n            #    return\n        # string buffer parsing is done through intermediary\n        # string buffer \"s_stack\"\n        s_stack = string[:self.__BitStack_len//8]\n        # create a bitstream \"s_bin\" for getting the full BitStack\n        s_bin = ''\n        for char in s_stack:\n            # convert to bitstream thanks to python native bit repr\n            s_bin_tmp = bin(ord(char))[2:]\n            # prepend 0 to align on byte (python does not do it)\n            # and append to the bitstream \"s_bin\" (string of 0 and 1)\n            s_bin = ''.join((s_bin, (8-len(s_bin_tmp))*'0', s_bin_tmp))\n        # map the bitstream \"s_bin\" into each BitStack element\n        for bit_elt in self.__BitStack:\n            bitlen = bit_elt.bit_len()\n            if bitlen:\n                # convert the bitstream \"s_bin\" into integer \n                # according to the length in bit of bit_elt\n                bit_elt.map_bit( int(s_bin[:bit_elt.bit_len()], 2) )\n                # truncate the \"s_bin\" bitstream\n                s_bin = s_bin[bit_elt.bit_len():]\n        # consume the global string buffer that has been mapped \n        # (from s_stack internal variable)\n        # and reinitialize self.__BitStack* attributes\n        string = string[self.__BitStack_len//8:]\n        self.__BitStack = []\n        self.__BitStack_len = 0\n        # finally return string to parent method .map()\n        return string\n    \n    # map_ret() maps a buffer to a Layer, the unaligned way,\n    # and returns the rest of the buffer that was not mapped\n    def map_ret(self, string=''):\n        if self.dbg >= DBG:\n            log(DBG, '(Layer.map_ret) entering map_ret() for %s' % self.CallName)\n        # First take care of transparent Layer (e.g. in L3Mobile)\n        if hasattr(self, 'Trans') and self.Trans:\n            return string\n        if self._byte_aligned is True:\n            self.__map_aligned(string)\n            return string[len(self):]\n        else:\n            # actually, map_ret() is only interesting for unaligned layers\n            s = shtr(string)\n            for e in self:\n                if self.dbg >= DBG:\n                    log(DBG, '(Layer.map_ret) %s, bit length: %i' \\\n                        % (e.CallName, e.bit_len()))\n                    log(DBG, '(Layer.map_ret) string: %s' % hexlify(s))\n                # this is beautiful\n                s = e.map_ret(s)\n            return s\n    \n    # define methods when Layer is in a Block:\n    # next, previous, header: return Layer object reference\n    # payload: returns Block object reference\n    def get_index(self):\n        if self.inBlock is not True: \n            return 0\n        i = 0\n        for l in self.Block:\n            if l == self: return i\n            else:  i += 1\n        # could happen if Layer is placed in several Block()\n        # and the last Block used is deleted\n        return False\n    \n    def has_next(self):\n        if self.inBlock is not True: \n            return False\n        return self.Block.has_index(self.get_index()+1)\n    \n    def get_next(self):\n        if self.has_next():\n            return self.Block[self.get_index()+1]\n        return RawLayer()\n    \n    def has_previous(self):\n        if self.inBlock is not True: \n            return False\n        index = self.get_index()\n        if index <= 0:\n            return False\n        return self.Block.has_index(index-1)\n        \n    def get_previous(self):\n        if self.has_previous():\n            return self.Block[self.get_index()-1]\n        return RawLayer()\n        \n    def get_header(self):\n        if self.has_previous():\n            index = self.get_index()\n            i = index - 1\n            while i >= 0:\n                if self.Block[i].hierarchy == self.hierarchy-1:\n                    return self.Block[i]\n                else:\n                    i -= 1\n        return RawLayer()\n    \n    def get_payload(self):\n        # return a Block, not a Layer like other methods \n        # for management into a Block\n        pay = Block('pay')\n        if self.has_next():\n            index = self.get_index()\n            for l in self.Block[ index+1 : ]:\n                if l.hierarchy > self.hierarchy:\n                    #pay.append( l.clone() )\n                    # not needed to append a clone\n                    # better keep reference to original layer\n                    pay.append( l )\n                else:\n                    break\n            if pay.num() == 0:\n                pay.append( RawLayer() )\n            return pay\n        pay.append( RawLayer() )\n        return pay\n    \n    def num(self):\n        return 1\n    \n    # this is to retrieve full Layer's dynamicity from a mapped layer\n    def reautomatize(self):\n        for e in self:\n            if hasattr(e, 'reautomatize'):\n                e.reautomatize()\n    \n    def parse(self, s=''):\n        self.map(s)\n    \n    # shar manipulation interface\n    def to_shar(self):\n        if hasattr(self, 'Trans') and self.Trans:\n            return shar()\n        bits = []\n        for e in self:\n            bits.append( e.to_shar().get_bits() )\n        s = shar()\n        s.set_bits( bits )\n        return s\n    \n    def map_shar(self, sh):\n        if self.dbg >= DBG:\n            log(DBG, '(Layer.map) entering map() for %s' % self.CallName)\n        # First take care of transparent Layer (e.g. in L3Mobile)\n        if hasattr(self, 'Trans') and self.Trans:\n            return\n        if not isinstance(sh, shar):\n            sh = shar(sh)\n        for e in self:\n            e.map_shar(sh)\nlibmich/core/element.py\ndef log(level=DBG, string=''):\n    # if needed, can be changed to write somewhere else\n    # will redirect all logs from the library\n    print('[libmich %s] %s' % (debug_level[level], string))\nlibmich/core/element.py\nclass Bit(Element):\n    '''\n    class defining a standard element, managed like a bit (e.g. a flag)\n    or bit-stream of variable bit length\n    Values are corresponding to unsigned integer: from 0 to pow(2, bit_len)-1.\n    It does not require to be byte-aligned.\n    \n    attributes:\n    Pt: to point to another object or direct integer value;\n    PtFunc: when defined, PtFunc(Pt) is used to generate the integer value;\n    Val: when defined, overwrites the Pt (and PtFunc) integer value, \n         used when mapping string to the element;\n    BitLen: length in bits of the bit stream;\n    BitLenFunc: to be used when mapping string with variable bit-length, \n                BitLenFunc(BitLen) is used;\n    Dict: dictionnary to use for a look-up when representing \n          the element into python;\n    Repr: representation style, binary, hexa or human: human uses Dict;\n    Trans: to define transparent element which has empty str() and len() to 0,\n           it \"nullifies\" its existence; can point to something for automation;\n    TransFunc: when defined, TransFunc(Trans) is used to automate the \n               transparency aspect: used e.g. for conditional element;\n    '''\n    # for object representation\n    _reprs = ['hex', 'bin', 'hum']\n    \n    def __init__(self, CallName='', ReprName=None, \n                 Pt=None, PtFunc=None, Val=None, \n                 BitLen=1, BitLenFunc=None,\n                 Dict=None, DictFunc=None, Repr='bin', \n                 Trans=False, TransFunc=None):\n        if CallName or not self.CallName:\n            self.CallName = CallName\n        if ReprName is None: \n            self.ReprName = ''\n        else: \n            self.ReprName = ReprName\n        self.Pt = Pt\n        self.PtFunc = PtFunc\n        self.Val = Val\n        self.BitLen = BitLen\n        self.BitLenFunc = BitLenFunc\n        self.Dict = Dict\n        self.DictFunc = DictFunc\n        self.Repr = Repr\n        self.Trans = Trans\n        self.TransFunc = TransFunc\n    \n    def __setattr__(self, attr, val):\n        # ensures no bullshit is provided into element's attributes \n        # (however, it is not a complete test...)\n        if self.safe:\n            if attr == 'CallName':\n                if type(val) is not str or len(val) == 0:\n                    raise AttributeError('CallName must be a non-null string')\n            elif attr == 'ReprName':\n                if type(val) is not str:\n                    raise AttributeError('ReprName must be a string')\n            elif attr == 'PtFunc':\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('PtFunc must be a function')\n            elif attr == 'Val':\n                if val is not None and not isinstance(val, (int, long)):\n                    raise AttributeError('Val must be an int')\n            elif attr == 'BitLenFunc':\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('BitLenFunc must be a function')\n            elif attr == 'DictFunc':\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('DictFunc must be a function')\n            elif attr == 'Repr':\n                if val not in self._reprs:\n                    raise AttributeError('Repr %s does not exist, use in: %s' \\\n                          % (val, self._reprs))\n            elif attr == 'TransFunc':\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('TransFunc must be a function')\n        object.__setattr__(self, attr, val)\n    \n    def __call__(self):\n        if self.Val is None and self.Pt is None: return 0\n        if self.Val is not None: return self.__confine(self.Val) \n        elif self.PtFunc is not None:\n            if self.safe:\n                assert( type(self.PtFunc(self.Pt)) is int )\n            return self.__confine(self.PtFunc(self.Pt))\n        else: return self.__confine(int(self.Pt))\n    \n    def __confine(self, value):\n        # makes sure value provided does not overflow bit length\n        return max( 0, min( pow(2, self.bit_len())-1, value ))\n    \n    def __str__(self):\n        # return the string representation of the integer value\n        # big-endian encoded\n        # left-aligned according to the bit length\n        # -> last bits of the last byte are nullified\n        # \n        # manages Element transparency\n        if self.is_transparent():\n            return ''\n        # do it the dirty way:\n        h = self.__hex__()\n        if not h:\n            return ''\n        if len(h) % 2: h = ''.join(('0', h))\n        return str(shtr(unhexlify(h)) << (8-(self.bit_len()%8))%8)\n    \n    def _shar__str__(self):\n        bitlen = self.bit_len()\n        if bitlen == 0:\n            return ''\n        ret = shar()\n        ret.set_uint(self(), bitlen)\n        return ret.to_buf()\n    \n    def __len__(self):\n        # just for fun here, \n        # but do not use this in program...\n        bitlen = self.bit_len()\n        if bitlen % 8:\n            return (bitlen//8) + 1\n        return bitlen//8\n    \n    def bit_len(self):\n        # manages Element transparency\n        if self.is_transparent():\n            return 0\n        # and standard bit length processing\n        if self.BitLenFunc is not None:\n            if self.safe:\n                assert( type(self.BitLenFunc(self.BitLen)) is int )\n            return self.BitLenFunc(self.BitLen)\n        else:\n            if self.safe:\n                assert( type(self.BitLen) is int )\n            return self.BitLen\n    \n    def map_len(self):\n        bitlen = self.bit_len()\n        if bitlen % 8:\n            return (bitlen//8)+1\n        return bitlen//8\n    \n    def __hex__(self):\n        bitlen = self.bit_len()\n        if not bitlen:\n            return ''\n        hexa = hex(self())[2:]\n        if hexa[-1] == 'L':\n            # thx to Python to add 'L' for long on hex repr...\n            hexa = hexa[:-1]\n        if self.bit_len()%4: \n            return '0'*(self.bit_len()//4 + 1 - len(hexa)) + hexa\n        else: \n            return '0'*(self.bit_len()//4 - len(hexa)) + hexa\n    \n    def __int__(self):\n        return self()\n        \n    def __bin__(self):\n        bitlen = self.bit_len()\n        if not bitlen:\n            return ''\n        binary = format(self(), 'b')\n        return (bitlen - len(binary))*'0' + binary\n        \n    def __repr__(self):\n        if self.Repr == 'hex': return '0x%s' % self.__hex__()\n        elif self.Repr == 'bin': return '0b%s' % self.__bin__()\n        elif self.Repr == 'hum':\n            value = self()\n            if self.DictFunc:\n                if self.safe:\n                    assert(hasattr(self.DictFunc(self.Dict), '__getitem__'))\n                try: val = '%i : %s' % (value, self.DictFunc(self.Dict)[value])\n                except KeyError: val = value\n            elif self.Dict:\n                try: val = '%i : %s' % (value, self.Dict[value])\n                except KeyError: val = value\n            else:\n                val = value\n            #return repr(val)\n            rep = repr(val)\n            if rep[-1] == 'L':\n                rep = rep[:-1]\n            return rep\n    \n    def getattr(self):\n        return ['CallName', 'ReprName', 'Pt', 'PtFunc', 'Val', 'BitLen',\n                'BitLenFunc', 'Dict', 'DictFunc', 'Repr', 'Trans', 'TransFunc']\n    \n    def showattr(self):\n        for a in self.getattr():\n            if a == 'Dict' and self.Dict is not None: \n                print('%s : %s' % ( a, self.__getattribute__(a).__class__) )\n            else: \n                print('%s : %s' % ( a, repr(self.__getattribute__(a))) )\n    \n    # cloning an element, used in set of elements\n    def clone(self):\n        clone = self.__class__(\n                 self.CallName, self.ReprName,\n                 self.Pt, self.PtFunc,\n                 self.Val, \n                 self.BitLen, self.BitLenFunc,\n                 self.Dict, self.DictFunc, self.Repr,\n                 self.Trans, self.TransFunc )\n        return clone\n    \n    def map(self, string=''):\n        # map each bit of the string from left to right\n        # using the shtr() class to shift the string\n        # string must be ascii-encoded (see shtr)\n        if not self.is_transparent():\n            self.map_bit( shtr(string).left_val(self.bit_len()) )\n    \n    def map_bit(self, value=0):\n        # map an int / long value\n        if self.safe:\n            assert( 0 <= value <= pow(2, self.bit_len()) )\n        self.Val = value\n    \n    def map_ret(self, string=''):\n        if self.is_transparent():\n            return string\n        else:\n            shtring = shtr(string)\n            bitlen = self.bit_len()\n            self.map_bit( shtring.left_val(bitlen) )\n            return shtring << bitlen\n    \n    # shar manipulation interface\n    def to_shar(self):\n        ret = shar()\n        ret.set_uint(self(), self.bit_len())\n        return ret\n    \n    def map_shar(self, sh):\n        if not self.is_transparent():\n            self.map_bit( sh.get_uint(self.bit_len()) )\nlibmich/core/element.py\nclass Block(object):\n    '''\n    class to build a block composed of \"Layer\" objects\n    define only methods, not content, which depends of the protocol or data model.\n    \n    when instantiated:\n    defines a layerList;\n    has methods to append, remove, extend, insert... layers into the block;\n    provides several methods for calling layers in the block;\n    to manage their hierarchy...;\n    and use of signs such as >> << | to include layers into the block;\n    \n    have also same methods as \"Layer\": map, show, clone\n    to emulate a common handling.\n    '''\n    # debugging thresholf for Block:\n    dbg = 0\n    \n    def __init__(self, Name=''):\n        if type(Name) is not str:\n            raise AttributeError('CallName must be a string')\n        self.CallName = Name\n        self.layerList = []\n        self.set_hierarchy(0)\n        self.inBlock = False\n\n    # define some basic list facilities for managing layers into the Block:\n    def __iter__(self):\n        if 'layerList' in self.__dict__.keys():\n            return self.__dict__['layerList'].__iter__()\n        else: return [].__iter__()\n    \n    def __getitem__(self, num):\n        return self.layerList[num]\n    \n    def __getattr__(self, attr):\n        for l in self:\n            if attr == l.CallName: return l\n        return object.__getattribute__(self, attr)\n    \n    def num(self):\n        return len(self.layerList)\n    \n    def has_index(self, index):\n        if index < self.num(): return True\n        return False\n    \n    def append(self, obj):\n        #if isinstance(obj, Layer):\n        # and the following will be great !!!\n        # this lib starts really to amaze me!\n        if isinstance(obj, (Layer, Block)):\n            obj.inBlock = True\n            # do not re-assign Layer.Block when building a payload\n            # referring to Layer.get_payload()\n            if self.CallName != 'pay':\n                obj.Block = self\n            # better keep original Layer / Block hierarchy\n            #obj.hierarchy = self.hierarchy\n            self.layerList.append(obj)\n    \n    def extend(self, block):\n    # would need some more intelligence...\n        if isinstance(block, Block):\n            self.layerList.extend(block.layerList)\n    \n    def insert(self, index, layer):\n        if isinstance(layer, Layer):\n            layer.inBlock = True\n            layer.Block = self\n            self.layerList.insert(index, layer)\n    \n    def remove(self, start, stop=None):\n        if stop is None:\n            self.layerList.remove( self.layerList[start] )\n        else:\n            for i in xrange(start, stop):\n                self.layerList.remove( self.layerList[start] )\n    \n    # method for Block hierarchy setting\n    def set_hierarchy(self, hier):\n        self.hierarchy = hier\n        for l in self:\n            l.set_hierarchy(l.hierarchy + hier)\n    \n    # method for managing all the Layers hierarchy in the Block (easy):\n    def inc_hierarchy(self, ref=0):\n        #self.hierarchy += 1+ref\n        #for l in self: l.hierarchy += 1+ref\n        self.set_hierarchy(self.hierarchy+1+ref)\n        \n    def dec_hierarchy(self, ref=0):\n        #self.hierarchy -= 1-ref\n        #for l in self: l.hierarchy -= 1-ref\n        self.set_hierarchy(self.hierarchy-1+ref)\n    \n    # define operations to insert layers into a block:\n    # OR: block | new_layer, append the new_layer with the same hierarchy \n    # as last layer in the block\n    def __or__(self, newLayer):\n        self.append(newLayer)\n        self[-1].set_hierarchy(self[-2].hierarchy)\n        #for l in self[-1]:\n        #    if isinstance(l, Layer):\n        #        l.hierarchy = self[-1].hierarchy\n    \n    # LSHIFT: block << new_layer, append the new_layer with a higher hierarchy\n    # than last layer in the block\n    def __lshift__(self, newLayer):\n        self.append(newLayer)\n        if self.num() > 1:\n            self[-1].inc_hierarchy( self[-2].hierarchy )\n        else:\n            self[-1].set_hierarchy(self.hierarchy)\n    \n    # RSHIFT: block >> new_layer, append the new_layer with a lower hierarchy\n    # than last layer in the block\n    def __rshift__(self, newLayer):\n        self.append(newLayer)\n        self[-1].dec_hierarchy( self[-2].hierarchy )\n    \n    # standard methods for common management with Layers\n    def __str__(self):\n        s = []\n        for l in self:\n            if not hasattr(self, 'Trans') or not l.Trans:\n                s.append( str(l) )\n        return ''.join(s)\n    \n    def shtr(self):\n        return shtr(self.__str__())\n    \n    def __len__(self):\n        return len(self.__str__())\n    \n    def __int__(self):\n        # big endian integer representation of the string buffer\n        if self._byte_aligned:\n            return shtr(self).left_val(len(self)*8)\n        else:\n            return shtr(self).left_val(self.bit_len())\n    \n    def __repr__(self):\n        s = '[[%s] ' % self.CallName\n        for l in self:\n            s += l.__repr__()\n        s = s + ' [%s]]' % self.CallName\n        return s\n    \n    def map_len(self):\n        return len(self)\n    \n    def clone(self):\n        clone = self.__class__()\n        clone.CallName, clone.layerList = self.CallName, []\n        for l in self:\n            if isinstance(l, Layer): \n                clone.append( l.clone() )\n            elif self.dbg >= ERR:\n                log(ERR, '(Block - %s) cloning not implemented for: %s' \\\n                    % (self.__class__, l))\n        return clone\n    \n    def show(self, with_trans=False):\n        s = '%s[[[ %s ]]]\\n' % (self.hierarchy*'\\t', self.CallName)\n        for l in self:\n            s += '\\t'*l.hierarchy + l.show(with_trans).replace('\\n', '\\n'+'\\t'*l.hierarchy) + '\\n'\n        return s[:-1]\n    \n    def map(self, string=''):\n        s = string\n        for l in self:\n            if not hasattr(l, 'Trans') or not l.Trans:\n                if hasattr(l, 'parse'):\n                    l.parse(s)\n                else:\n                    l.map(s)\n                s = s[l.map_len():]\n    \n    # this is to retrieve full Block's dynamicity from a parsed or mapped one\n    def reautomatize(self):\n        for l in self:\n            if hasattr(l, 'reautomatize'):\n                l.reautomatize()\nlibmich/core/element.py\nclass Str(Element):\n    '''\n    class defining a standard Element, \n    managed like a stream of byte(s), or string.\n    It is always byte-aligned (in term of length, at least)\n    \n    attributes:\n    Pt: to point to another stream object (can simply be a string);\n    PtFunc: when defined, PtFunc(Pt) is used \n            to generate the str() / len() representation;\n    Val: when defined, overwrites the Pt (and PtFunc) string value, \n         used when mapping a string buffer to the element;\n    Len: can be set to a fixed int value, or to another object\n         when called by LenFunc\n    LenFunc: to be used when mapping string buffer with variable length\n             (e.g. in TLV object), LenFunc(Len) is used;\n    Repr: python representation; binary, hexa, human or ipv4;\n    Trans: to define transparent element which has empty str() and len() to 0,\n           it \"nullifies\" its existence; can point to something for automation;\n    TransFunc: when defined, TransFunc(Trans) is used to automate the \n               transparency aspect: used e.g. for conditional element;\n    '''\n    \n    # this is used when printing the object representation\n    _repr_limit = 1024\n    _reprs = ['hex', 'bin', 'hum', 'ipv4']\n    \n    # padding is used when .Pt and .Val are None, \n    # but Str instance has still a defined .Len attribute\n    _padding_byte = '\\0'\n    \n    def __init__(self, CallName='', ReprName=None, \n                 Pt=None, PtFunc=None, Val=None, \n                 Len=None, LenFunc=None,\n                 Repr=\"hum\",\n                 Trans=False, TransFunc=None):\n        if CallName or not self.CallName:\n            self.CallName = CallName\n        if ReprName is None :\n            self.ReprName = ''\n        else :\n            self.ReprName = ReprName\n        self.Pt = Pt\n        self.PtFunc = PtFunc\n        self.Val = Val\n        self.Len = Len\n        self.LenFunc = LenFunc\n        self.Type = 'stream'\n        self.Repr = Repr\n        self.Trans = Trans\n        self.TransFunc = TransFunc\n    \n    def __setattr__(self, attr, val):\n        # ensures no bullshit is provided into element's attributes \n        # (however, it is not a exhaustive test...)\n        # managed with the class \"safe\" trigger\n        if self.safe :\n            if attr == 'CallName' :\n                if type(val) is not str or len(val) == 0 :\n                    raise AttributeError('CallName must be a non-null string')\n            elif attr == 'ReprName' :\n                if type(val) is not str:\n                    raise AttributeError('ReprName must be a string')\n            elif attr == 'PtFunc' :\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('PtFunc must be a function')\n            elif attr == 'Val' :\n                if val is not None and not isinstance(val, \\\n                (str, bytes, Element, Layer, Block, tuple, list)) :\n                    raise AttributeError('Val must be a string or something ' \\\n                    'that makes a string at the end...')\n            elif attr == 'Len' :\n                if val is not None and not isinstance(val, \\\n                (int, tuple, Element, type_funcs)) :\n                    raise AttributeError('Len must be an int or element')\n            elif attr == 'LenFunc' :\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('LenFunc must be a function')\n            elif attr == 'Repr' :\n                if val not in self._reprs :\n                    raise AttributeError('Repr %s does not exist, only: %s' \\\n                          % (val, self._reprs))\n            elif attr == 'TransFunc' :\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('TransFunc must be a function')\n        # this is for Layer() pointed by Pt attr in Str() object\n        #if isinstance(self.Pt, Layer) and hasattr(self.Pt, attr):\n        #    setattr(self.Pt, attr, val)\n        # ...does not work properly\n        # and the final standard python behaviour\n        object.__setattr__(self, attr, val)\n    \n    def __getattr__(self, attr):\n        # this is for Layer() pointed by Pt attr in Str() object\n        if isinstance(self.Pt, Layer) and hasattr(self.Pt, attr):\n            return getattr(self.Pt, attr)\n        # and the final standard python behaviour\n        object.__getattr__(self, attr)\n    \n    # the libmich internal instances check\n    # this is highly experimental...\n    def __is_intern_inst(self, obj):\n        return isinstance(obj, (Element, Layer, Block))\n    \n    # building basic methods for manipulating easily the Element \n    # from its attributes\n    def __call__(self, l=None):\n        # when length has fixed value:\n        if not l and type(self.Len) is int:\n            l = self.Len\n        #else:\n        #    l = None\n        # when no values are defined at all:\n        if self.Val is None and self.Pt is None: \n            if l: return l * self._padding_byte\n            else: return ''\n        # returning the right string:\n        # if defined, self.Val overrides self.Pt capabilities\n        elif self.Val is not None:\n            # allow to pass tuple or list of libmich internal instances\n            if isinstance(self.Val, (list, tuple)) \\\n            and False not in map(self.__is_intern_inst, self.Val):\n                return ''.join(map(str, self.Val))[:l]\n            return str(self.Val)[:l]\n        # else: use self.Pt capabilities to get the string\n        elif self.PtFunc is not None: \n            if self.safe: \n                assert(hasattr(self.PtFunc(self.Pt), '__str__'))\n            return str(self.PtFunc(self.Pt))[:l]\n        else:\n            # allow to pass tuple or list of libmich internal instances\n            if isinstance(self.Pt, (list, tuple)) \\\n            and False not in map(self.__is_intern_inst, self.Pt):\n                return ''.join(map(str, self.Pt))[:l]\n            # otherwise, handle simply as is\n            if self.safe: \n                assert(hasattr(self.Pt, '__str__'))\n            return str(self.Pt)[:l]\n    \n    def __str__(self):\n        # when Element is Transparent:\n        if self.is_transparent():\n            return ''\n        #else:\n        return self()\n    \n    def __len__(self):\n        # does not take the LenFunc(Len) into account\n        # When a Str is defined, the length is considered dependent of the Str\n        # the Str is dependent of the LenFunc(Len) only \n        # when mapping data into the Element\n        return len(self.__str__())\n    \n    def bit_len(self):\n        return len(self)*8\n    \n    def map_len(self):\n        # need special length definition \n        # when mapping a string to the 'Str' element \n        # that has no fixed length\n        #\n        # uses LenFunc, applied to Len, when length is variable:\n        # and TransFunc, applied to Trans, to managed potential transparency\n        # (e.g. for optional element triggered by other element)\n        #\n        if self.Len is None:\n            return None\n            #return 0\n        if self.LenFunc is None: \n            return self.Len\n        else:\n            if self.safe:\n                assert( type(self.LenFunc(self.Len)) in (int, long) )\n            return self.LenFunc(self.Len)\n    \n    def __int__(self):\n        # big endian integer representation of the string buffer\n        return shtr(self).left_val(len(self)*8)\n    \n    def __bin__(self):\n        # does not use the standard python 'bin' function to keep \n        # the right number of prefixed 0 bits\n        h = hex(self)\n        binary = ''\n        for i in xrange(0, len(h), 2):\n            b = format( int(h[i:i+2], 16), 'b' )\n            binary += ( 8-len(b) ) * '0' + b\n        return binary\n    \n    def __hex__(self):\n        return self().encode('hex')\n    \n    def __repr__(self):\n        # check for simple representations\n        if self.Pt is None and self.Val is None: \n            return repr(None)\n        if self.Repr == 'ipv4':\n            #if self.safe: assert( len(self) == 4 )\n            if len(self) != 4:\n                return '0x%s' % hex(self)\n            return inet_ntoa( self.__str__() )\n        elif self.Repr == 'hex': \n            ret = '0x%s' % hex(self)\n        elif self.Repr == 'bin': \n            ret = '0b%s' % self.__bin__()\n        # check for the best human-readable representation\n        elif self.Repr == 'hum':\n            # standard return\n            ret = repr( self() )\n            # complex return:\n            # allow to assign a full Block or Layer to a Str...\n            if self.__is_intern_inst(self.Pt):\n                ret = repr(self.Pt)\n            if self.__is_intern_inst(self.Val):\n                ret = repr(self.Val)\n            # allow to assign a list or tuple of Block or Layer...\n            if isinstance(self.Pt, (list, tuple)) \\\n            and False not in map(self.__is_intern_inst, self.Pt):\n                ret = '|'.join(map(repr, self.Pt))\n            if isinstance(self.Val, (list, tuple)) \\\n            and False not in map(self.__is_intern_inst, self.Val):\n                ret = '|'.join(map(repr, self.Val))\n            # finally, self.Val can be a raw value... still\n            if self.Val is not None and hasattr(self.Val, '__repr__'):\n                ret = repr(self.Val)\n        # truncate representation if string too long:\n        # avoid terminal panic...\n        if len(ret) <= self._repr_limit:\n            return ret\n        else:\n            return ret[:self._repr_limit-3]+'...'\n    \n    # some more methods for checking Element's attributes:\n    def getattr(self):\n        return ['CallName', 'ReprName', 'Pt', 'PtFunc', 'Val', 'Len',\n                'LenFunc', 'Type', 'Repr', 'Trans', 'TransFunc']\n    \n    def showattr(self):\n        for a in self.getattr():\n            print('%s : %s' % (a, repr(self.__getattribute__(a))) )\n    \n    # cloning an Element, useful for \"duplicating\" an Element \n    # without keeping any dependency\n    # used in Layer with Element\n    # However,\n    #...\n    # This is not that true, as an object pointed by .Pt or .Len or .Trans\n    # will not be updated to its clone()\n    # Conclusion:\n    # use this with care\n    def clone(self):\n        clone = self.__class__(\n                 self.CallName, self.ReprName,\n                 self.Pt, self.PtFunc,\n                 self.Val, \n                 self.Len, self.LenFunc,\n                 self.Repr,\n                 self.Trans, self.TransFunc )\n        return clone\n    \n    # standard method map() to map a string to the Element\n    def map(self, string=''):\n        if not self.is_transparent():\n            l = self.map_len()\n            if l is not None:\n                self.Val = string[:l]\n            else:\n                self.Val = string\n            if self.dbg >= DBG:\n                log(DBG, '(Element) mapping %s on %s, %s' \\\n                    % (repr(string), self.CallName, repr(self)))\n    \n    def map_ret(self, string=''):\n        self.map(string)\n        return string[len(self):]\n    \n    # shar manipulation interface\n    def to_shar(self):\n        ret = shar()\n        ret.set_buf(self())\n        return ret\n    \n    def map_shar(self, sh):\n        if not self.is_transparent():\n            l = self.map_len()\n            if l is not None:\n                self.Val = sh.get_buf(l*8)\n            else:\n                self.Val = sh.get_buf()\n            if self.dbg >= DBG:\n                log(DBG, '(Element) mapping %s on %s, %s' \\\n                    % (repr(string), self.CallName, repr(self)))\nlibmich/utils/CRC16.py\nclass CRC16(object):\r\n     \"\"\" \r\n     Class interface, like the Python library's cryptographic\r\n     hash functions (which CRC's are definitely not.)\r\n     \"\"\"\r\n     \r\n     def __init__(self, string=''):\r\n          self.val = 0\r\n          if string:\r\n               self.update(string)\r\n               \r\n     def update(self, string):\r\n          self.val = crcbitbybit(string)\r\n                    \r\n     def checksum(self):\r\n          return chr(self.val >> 8) + chr(self.val & 0xff)\r\n\r\n\r\n     def intchecksum(self):\r\n          return self.val\r\n\r\n     def hexchecksum(self):\r\n          return '%04x' % self.val\r\n\r\n     def copy(self):\r\n          clone = CRC16()\r\n          clone.val = self.val\r\n          return clone\r\nlibmich/core/element.py\nclass Int(Element):\n    '''\n    class defining a standard element, managed like an integer.\n    It can be signed (int) or unsigned (uint),\n    and support arbitrary byte-length:\n        int8, int16, int24, int32, int40, int48, int56, int64, int72, ...\n        uint8, uint16, uint24, uint32, ..., uint128, ...\n        and why not int65536 !\n    It is always byte-aligned (in term of length, at least).\n    \n    attributes:\n    Pt: to point to another object or direct integer value;\n    PtFunc: when defined, PtFunc(Pt) is used to generate the integer value;\n    Val: when defined, overwrites the Pt (and PtFunc) integer value, \n         used when mapping a string buffer to the element;\n    Type: type of integer for encoding, 8,16,24,32,40,48,56,64 bits signed or\n          unsigned integer;\n    Dict: dictionnary to use for a look-up when representing \n          the element into python;\n    Repr: representation style, binary, hexa or human: human uses Dict \n          if defined;\n    Trans: to define transparent element which has empty str() and len() to 0,\n           it \"nullifies\" its existence; can point to something for automation;\n    TransFunc: when defined, TransFunc(Trans) is used to automate the \n               transparency aspect: used e.g. for conditional element;\n    '''\n    # endianness is 'little' / 'l' or 'big' / 'b'\n    _endian = 'big'\n    # types format for struct library\n    # 24 (16+8), 40 (32+8), 48 (32+16), 56 (32+16+8)\n    _types = { 'int8':'b', 'int16':'h', 'int32':'i', 'int64':'q',\n               #'int24':None, 'int40':None, 'int48':None, 'int56':None,\n               'uint8':'B', 'uint16':'H', 'uint32':'I', 'uint64':'Q',\n               #'uint24':None, 'uint40':None, 'uint48':None, 'uint56':None,\n               }\n    #\n    # for object representation\n    _reprs = ['hex', 'bin', 'hum']\n    \n    def __init__(self, CallName='', ReprName=None,\n                 Pt=None, PtFunc=None, Val=None,\n                 Type='int32', Dict=None, DictFunc=None,\n                 Repr='hum',\n                 Trans=False, TransFunc=None):\n        if CallName or not self.CallName:\n            self.CallName = CallName\n        if ReprName is None:\n            self.ReprName = ''\n        else:\n            self.ReprName = ReprName\n        self.Pt = Pt\n        self.PtFunc = PtFunc\n        self.Val = Val\n        self.Type = Type\n        self.Dict = Dict\n        self.DictFunc = DictFunc\n        self.Repr = Repr\n        self.Trans = Trans\n        self.TransFunc = TransFunc\n        # automated attributes:\n        self.Len = int(self.Type.lstrip('uint'))//8\n    \n    def __setattr__(self, attr, val):\n        # ensures no bullshit is provided into element's attributes \n        # (however, it is not a complete test...)\n        if self.safe:\n            if attr == 'CallName':\n                if type(val) is not str or len(val) == 0:\n                    raise AttributeError('CallName must be a non-null string')\n            elif attr == 'ReprName':\n                if type(val) is not str:\n                    raise AttributeError('ReprName must be a string')\n            elif attr == 'PtFunc':\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('PtFunc must be a function')\n            elif attr == 'Val':\n                if val is not None and not isinstance(val, (int, long)):\n                    raise AttributeError('Val must be an int or long')\n            elif attr == 'Type':\n                cur = 0\n                if val[cur] == 'u':\n                    cur = 1\n                if val[cur:cur+3] != 'int' or int(val[cur+3:]) % 8 != 0:\n                    raise AttributeError('Type must be intX / uintX with X '\\\n                    'multiple of 8 bits (e.g. int24, uint32, int264, ...)')\n            elif attr == 'DictFunc':\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('DictFunc must be a function')\n            elif attr == 'Repr':\n                if val not in self._reprs:\n                    raise AttributeError('Repr %s does not exist, use in: %s' \\\n                          % (val, self._reprs))\n            elif attr == 'TransFunc':\n                if val is not None and not isinstance(val, type_funcs) :\n                    raise AttributeError('TransFunc must be a function')\n        if attr == 'Type':\n            self.Len = int(val.lstrip('uint'))//8\n        object.__setattr__(self, attr, val)\n    \n    def __call__(self):\n        # when no values are defined at all, arbitrary returns None:\n        if self.Val is None and self.Pt is None:\n            # instead of \"return None\" \n            # that triggers error when calling __str__() method\n            return 0\n        # else, Val overrides Pt capabilities:\n        # transparency are not taken into account in __call__, \n        # only for the __str__ representation\n        elif self.Val is not None: \n            return self.__confine( self.Val )\n        elif self.PtFunc is not None: \n            if self.safe: \n                assert( type(self.PtFunc(self.Pt)) in (int, long) )\n            return self.__confine(self.PtFunc(self.Pt))\n        else:\n            return self.__confine(int(self.Pt))\n    \n    def __confine(self, value):\n        # unsigned\n        if self.Type[0] == 'u':\n            return max(0, min(2**(8*self.Len)-1, value))\n        # signed\n        else:\n            return max(-2**(8*self.Len-1), min(2**(8*self.Len-1)-1, value))\n    \n    def __str__(self):\n        # manages Element transparency\n        if self.is_transparent():\n                return ''\n        # otherwise returns standard string values\n        return self.__pack()\n    \n    def __len__(self):\n        if self.is_transparent(): \n            return 0\n        return self.Len\n    \n    def bit_len(self):\n        return 8*self.__len__()\n    \n    # map_len() is a-priori not needed in \"Int\" element, \n    # but still kept for Element API uniformity\n    def map_len(self):\n        return self.__len__()\n    \n    # define integer value\n    def __int__(self):\n        return self()\n    \n    def __bin__(self):\n        # unsigned or positive signed:\n        val = self()\n        if self.Type[0] == 'u' \\\n        or self.Type[0] == 'i' and val >= 0 : \n            binstr = bin(val)[2:]\n            if self._endian[0] == 'l':\n                # little endian\n                bs = '0'*(8*self.__len__() - len(binstr)) + binstr\n                bs = [bs[i:i+8] for i in range(0, len(bs), 8)]\n                bs.reverse()\n                return ''.join(bs)\n            else:\n                # big endian\n                return '0'*(8*self.__len__() - len(binstr)) + binstr\n        # negative signed\n        else : \n            # takes 2' complement to the signed val\n            binstr = bin(val + 2**(8*self.__len__()-1))[2:]\n            if self._endian[0] == 'l':\n                # little endian\n                bs = '1' + '0'*(8*self.__len__() - len(binstr) - 1) + binstr\n                bs = [bs[i:i+8] for i in range(0, len(bs), 8)]\n                bs.reverse()\n                return ''.join(bs)\n            else:\n                # big endian\n                return '1' + '0'*(8*self.__len__() - len(binstr) - 1) + binstr\n    \n    def __hex__(self):\n        return hexlify(self.__pack())\n    \n    def __repr__(self):\n        if self.Pt is None and self.Val is None:\n            return repr(None)\n        if self.Repr == 'hex':\n            return '0x%s' % self.__hex__()\n        elif self.Repr == 'bin':\n            return '0b%s' % self.__bin__()\n        elif self.Repr == 'hum':\n            value = self()\n            if self.DictFunc:\n                if self.safe:\n                    assert(hasattr(self.DictFunc(self.Dict), '__getitem__'))\n                try:\n                    val = '%i : %s' % (value, self.DictFunc(self.Dict)[value])\n                except KeyError:\n                    val = value\n            elif self.Dict:\n                try:\n                    val = '%i : %s' % (value, self.Dict[value])\n                except KeyError:\n                    val = value\n            else:\n                val = value\n            rep = repr(val)\n            if rep[-1] == 'L':\n                return rep[:-1]\n            return rep\n    \n    def getattr(self):\n        return ['CallName', 'ReprName', 'Pt', 'PtFunc', 'Val', 'Len',\n                'Type', 'Dict', 'DictFunc', 'Repr', 'Trans', 'TransFunc']\n    \n    def showattr(self):\n        for a in self.getattr():\n            if a == \"Dict\" and self.Dict is not None:\n                print('%s : %s' % ( a, self.__getattribute__(a).__class__) )\n            else:\n                print('%s : %s' % ( a, repr(self.__getattribute__(a))) )\n    \n    def clone(self):\n        clone = self.__class__(\n                 self.CallName, self.ReprName,\n                 self.Pt, self.PtFunc,\n                 self.Val, self.Type,\n                 self.Dict, self.DictFunc, self.Repr, \n                 self.Trans, self.TransFunc )\n        #clone._endian = self._endian\n        return clone\n    \n    def map(self, string=''):\n        if not self.is_transparent():\n            # error log will be done by the Layer().map() method\n            # but do this not to throw exception\n            if len(string) < self.Len:\n                if self.dbg >= WNG:\n                    log(WNG, '(%s) %s map(string) : string not long enough' \\\n                        % (self.__class__, self.CallName))\n                return\n            self.Val = self.__unpack(string[:self.Len])\n    \n    def map_ret(self, string=''):\n        l = self.__len__()\n        if 0 < l <= len(string):\n            self.map(string)\n            return string[l:]\n        else:\n            return string\n    \n    def __pack(self):\n        # manage endianness (just in case...)\n        if self._endian[0] == 'l':\n            e = '<'\n        else:\n            e = '>'\n        if self.Len == 0:\n            return ''\n        elif self.Len in (1, 2, 4, 8):\n            # standard types for using Python struct\n            return pack(e+self._types[self.Type], self())\n        elif self.Type[0] == 'u':\n            # non-standard unsigned int types\n            return self.__pack_uX(e)\n        else:\n            # non-standard signed int types\n            return self.__pack_iX(e)\n    \n    def __unpack(self, string):\n        if self._endian[0] == 'l':\n            e = '<'\n        else:\n            e = '>'\n        if self.Len == 0:\n            return\n        elif self.Len in (1, 2, 4, 8):\n            # standard types for using Python struct\n            return unpack(e+self._types[self.Type], string[:self.Len])[0]\n        elif self.Type[0] == 'u':\n            # non-standard unsigned int types\n            return self.__unpack_uX(string[:self.Len], e)\n        else:\n            # non-standard signed int types\n            return self.__unpack_iX(string[:self.Len], e)\n    \n    def __pack_uX(self, e='>'):\n        if e == '<':\n            # little endian, support indefinite uint (e.g. uint3072)\n            if self.Len <= 8:\n                return pack('<Q', self())[:self.Len]\n            else:\n                #'''\n                u8 = decompose(0x100, self())\n                # pad with 0 until the right length\n                if len(u8) < self.Len:\n                    u8.extend( [0]*(self.Len-len(u8)) )\n                return pack('<'+self.Len*'B', *u8)\n        else:\n            # big endian, support indefinite uint too\n            if self.Len <= 8:\n                return pack('>Q', self())[-self.Len:]\n            else:\n                u64 = decompose(0x10000000000000000, self())\n                u64_len = 8*len(u64)\n                u64_pad = 0\n                if u64_len < self.Len:\n                    rest_len = self.Len - u64_len\n                    u64_pad = rest_len // 8\n                    if rest_len % 8:\n                        u64_pad += 1\n                    u64.extend( [0]*u64_pad )\n                u64.reverse()\n                return pack('>'+len(u64)*'Q', *u64)[-self.Len:]\n    \n    def __pack_iX(self, e='>'):\n        val = self()\n        # positive values are encoded just like uint\n        if val >= 0:\n            return self.__pack_uX(e)\n        #\n        # negative values, 2's complement encoding\n        if e == '<':\n            # little endian\n            if self.Len <= 8:\n                return pack('<Q', 2**(self.Len*8) - abs(val))[:self.Len]\n            else:\n                i8 = decompose(0x100, 2**(self.Len*8) - abs(val))\n                if len(i8) < self.Len:\n                    i8.extend( [0]*(self.Len-len(i8)) )\n                return pack('<'+self.Len*'B', *i8)\n        else:\n            # big endian\n            if self.Len <= 8:\n                return pack('>Q', 2**(self.Len*8) - abs(val))[-self.Len:]\n            else:\n                i8 = decompose(0x100, 2**(self.Len*8) - abs(val))\n                if len(i8) < self.Len:\n                    i8.extend( [0]*(self.Len-len(i8)) )\n                i8.reverse()\n                return pack('>'+self.Len*'B', *i8)\n    \n    def __unpack_uX(self, string, e='>'):\n        if e == '<':\n            # little endian, support indefinite uint (e.g. uint3072)\n            if self.Len <= 8:\n                return unpack('<Q', string + '\\0'*(8 - self.Len))[0]\n            else:\n                u8 = list(unpack('<'+self.Len*'B', string))\n                u8.reverse()\n                return reduce(lambda x,y: (x<<8)+y, u8)\n        else:\n            # big endian, support indefinite uint (e.g. uint3072)\n            if self.Len <= 8:\n                return unpack('>Q', '\\0'*(8 - self.Len) + string)[0]\n            else:\n                #'''\n                u64_len, u64_pad = self.Len // 8, self.Len % 8\n                if u64_pad:\n                    u64_len += 1\n                    string = '\\0'*u64_pad + string\n                u64 = unpack('>'+u64_len*'Q', string)\n                return reduce(lambda x,y:(x<<64)+y, u64)\n    \n    def __unpack_iX(self, string, e='>'):\n        if e == '<':\n            # little endian\n            if ord(string[-1]) & 0x80 == 0:\n                # check if it is a positive value\n                return self.__unpack_uX(string, e)\n            elif self.Len <= 8:\n                return unpack('<Q', string + '\\0'*(8 - self.Len))[0] \\\n                       - 2**(self.Len*8)\n            else:\n                i8 = list(unpack('<'+self.Len*'B', string))\n                i8.reverse()\n                return reduce(lambda x,y:(x<<8)+y, i8) - 2**(self.Len*8)\n        else:\n            # big endian\n            if ord(string[0]) & 0x80 == 0:\n                # check if it is a positive value\n                return self.__unpack_uX(string, e)\n            elif self.Len <= 8:\n                return unpack('>Q', '\\0'*(8 - self.Len) + string)[0] \\\n                       - 2**(self.Len*8)\n            else:\n                i8 = unpack('>'+self.Len*'B', string)\n                return reduce(lambda x,y:(x<<8)+y, i8) - 2**(self.Len*8)\n    \n    # shar manipulation interface\n    def to_shar(self):\n        ret = shar()\n        ret.set_buf(self.__str__())\n        return ret\n    \n    def map_shar(self, sh):\n        if len(sh)*8 < self.Len:\n            if self.dbg >= WNG:\n                log(WNG, '(%s) %s map(string) : shar buffer not long enough' \\\n                    % (self.__class__, self.CallName))\n            return\n        # standard handling\n        if not self.is_transparent():\n            self.map(sh.get_buf(len(self)*8))\nlibmich/core/element.py\nERR = 1\nlibmich/core/element.py\nWNG = 2\nlibmich/core/element.py\nDBG = 3\n", "answers": ["class IEEE802154(Block):"], "length": 7885, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "cc131a0161097adc000fbf6660b57883462333724839d2f9"}
{"input": "package de.fau.cs.mad.yasme.android.ui.fragments;\nimport android.app.AlertDialog;\nimport android.app.Fragment;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.text.InputType;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport de.fau.cs.mad.yasme.android.EditTextWithX;\nimport de.fau.cs.mad.yasme.android.R;\nimport de.fau.cs.mad.yasme.android.asyncTasks.database.GetTask;\nimport de.fau.cs.mad.yasme.android.asyncTasks.database.UpdateTask;\nimport de.fau.cs.mad.yasme.android.asyncTasks.server.ChangeChatProperties;\nimport de.fau.cs.mad.yasme.android.asyncTasks.server.ChangeOwnerAndLeaveTask;\nimport de.fau.cs.mad.yasme.android.asyncTasks.server.LeaveChatTask;\nimport de.fau.cs.mad.yasme.android.controller.FragmentObservable;\nimport de.fau.cs.mad.yasme.android.controller.Log;\nimport de.fau.cs.mad.yasme.android.controller.NotifiableFragment;\nimport de.fau.cs.mad.yasme.android.controller.ObservableRegistry;\nimport de.fau.cs.mad.yasme.android.controller.Sanitizer;\nimport de.fau.cs.mad.yasme.android.entities.Chat;\nimport de.fau.cs.mad.yasme.android.entities.User;\nimport de.fau.cs.mad.yasme.android.storage.DatabaseManager;\nimport de.fau.cs.mad.yasme.android.storage.dao.ChatDAO;\nimport de.fau.cs.mad.yasme.android.ui.AbstractYasmeActivity;\nimport de.fau.cs.mad.yasme.android.ui.UserAdapter;\nimport de.fau.cs.mad.yasme.android.ui.activities.ChatListActivity;\nimport de.fau.cs.mad.yasme.android.ui.activities.ChatSettingsActivity;\n\n\n\n\n/**\n * Created by Robert Meissner <robert.meissner@studium.fau.de> on 03.08.14.\n */\npublic class ChatSettingsInfo extends Fragment implements NotifiableFragment<Chat> {\n    private List<User> users;\n    protected UserAdapter mAdapter = null;\n    private View chatInfo;\n    private Chat chat;\n    private Button changeName, changeStatus, leaveChat, changeOwner, resetName, resetStatus;\n\n    public ChatSettingsInfo() {\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();", "context": "yasme/src/main/java/de/fau/cs/mad/yasme/android/entities/Chat.java\n@JsonIgnoreProperties(ignoreUnknown = true)\r\n@DatabaseTable(tableName = DatabaseConstants.CHAT_TABLE)\r\npublic class Chat implements Serializable {\r\n\r\n    @DatabaseField(columnName = DatabaseConstants.CHAT_ID, id = true)\r\n    private long id;\r\n\r\n    private List<User> participants;\r\n\r\n    @DatabaseField(columnName = DatabaseConstants.NAME_CHANGED)\r\n    private boolean nameChanged = false;\r\n\r\n    @DatabaseField(columnName = DatabaseConstants.STATUS_CHANGED)\r\n    private boolean statusChanged = false;\r\n\r\n    @DatabaseField(columnName = DatabaseConstants.CHAT_STATUS)\r\n    private String status;\r\n\r\n    @DatabaseField(columnName = DatabaseConstants.CHAT_NAME)\r\n    private String name;\r\n\r\n    @DatabaseField(columnName = DatabaseConstants.OWNER, foreign = true)\r\n    private User owner;\r\n\r\n    @DatabaseField(columnName = DatabaseConstants.CHAT_LAST_MODIFIED, dataType = DataType.DATE)\r\n    private Date lastModified;\r\n\r\n    @DatabaseField(columnName = DatabaseConstants.CHAT_CREATED)\r\n    private Date created;\r\n\r\n    @JsonIgnore\r\n    private String profilePicture;\r\n\r\n    @JsonIgnore\r\n    @ForeignCollectionField(columnName = DatabaseConstants.MESSAGES)\r\n    private Collection<Message> messages;\r\n\r\n    @JsonIgnore\r\n    @DatabaseField(columnName = DatabaseConstants.LAST_MESSAGE, foreign = true)\r\n    private Message lastMessage;\r\n\r\n    /**\r\n     * Constructors *\r\n     */\r\n    public Chat(long id) {\r\n        this.id = id;\r\n        this.participants = new ArrayList<User>();\r\n        this.messages = new ArrayList<Message>();\r\n    }\r\n\r\n    /**\r\n     * It is needed to set an id after calling this constructor!\r\n     *\r\n     * @param owner\r\n     * @param status\r\n     * @param name\r\n     */\r\n    public Chat(User owner, String status, String name) {\r\n        new Chat(0, new ArrayList<User>(), status, name, owner, new ArrayList<Message>());\r\n    }\r\n\r\n    public Chat(long id, List<User> participants, String status, String name,\r\n                User owner) {\r\n        new Chat(id, participants, status, name, owner, new ArrayList<Message>());\r\n    }\r\n\r\n    public Chat() {\r\n        // ORMLite needs a no-arg constructor\r\n    }\r\n\r\n    public Chat(long id, List<User> participants, String status, String name, User owner,\r\n                Collection<Message> messages) {\r\n        this.id = id;\r\n        this.participants = participants;\r\n        this.status = status;\r\n        this.name = name;\r\n        this.owner = owner;\r\n        this.messages = messages;\r\n    }\r\n\r\n    public Chat(Chat origin) throws IllegalAccessException {\r\n        Field[] fields = this.getClass().getDeclaredFields();\r\n        for (Field field : fields) {\r\n            field.set(this, field.get(origin));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Getters *\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Setters *\r\n     */\r\n    public void setId(long id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public int size() {\r\n        if (null == participants) {\r\n            Log.e(((Object) this).getClass().getSimpleName(), \"Participants are null\");\r\n            return -1;\r\n        }\r\n        return participants.size();\r\n    }\r\n\r\n    @JsonIgnoreProperties({\"pw\", \"email\", \"name\", \"devices\", \"lastModified\", \"created\"})\r\n    public ArrayList<User> getParticipants() {\r\n        if (participants == null) {\r\n            participants = new ArrayList<>();\r\n            User mDummy = new User(\"Dummy\", 12);\r\n            participants.add(mDummy);\r\n            // Without cast IntelliJ is not happy\r\n            Log.e(((Object) this).getClass().getSimpleName(), \"Participants are null\");\r\n        }\r\n        return new ArrayList<User>(participants);\r\n    }\r\n\r\n    public void setParticipants(List<User> participants) {\r\n        this.participants = participants;\r\n    }\r\n\r\n    public void setNameChanged(boolean nameChanged) {\r\n        this.nameChanged = nameChanged;\r\n    }\r\n\r\n    public void setStatusChanged(boolean statusChanged) {\r\n        this.statusChanged = statusChanged;\r\n    }\r\n\r\n    public boolean addParticipant(User newUser) {\r\n        if (participants == null) {\r\n            Log.e(((Object) this).getClass().getSimpleName(), \"Participants are null\");\r\n            return false;\r\n        }\r\n        participants.add(newUser);\r\n        return true;\r\n    }\r\n\r\n    public boolean removeParticipant(User delUser) {\r\n        if (participants == null) {\r\n            Log.e(((Object) this).getClass().getSimpleName(), \"Participants are null, sry.\");\r\n            return false;\r\n        }\r\n        boolean ret = false;\r\n        for (User u : participants) {\r\n            if (u.getId() != delUser.getId()) {\r\n                continue;\r\n            }\r\n            ret = participants.remove(u);\r\n            break;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public String getStatus() {\r\n        if (!this.statusChanged || this.status == null || this.status.isEmpty()) {\r\n            return (getNumberOfParticipants() + \" YASMEs\");\r\n        }\r\n        return this.status;\r\n    }\r\n\r\n    public void setStatus(String status, boolean isNotDefault) {\r\n        this.statusChanged = isNotDefault;\r\n        this.status = status;\r\n    }\r\n\r\n    public boolean getStatusChanged() {\r\n        return this.statusChanged;\r\n    }\r\n\r\n    public boolean getNameChanged() {\r\n        return this.nameChanged;\r\n    }\r\n\r\n    @JsonProperty(\"name\")\r\n    public String getName() {\r\n        if (this.nameChanged && this.name != null && this.name.length() > 0) {\r\n            return name;\r\n        }\r\n        // Create a new name\r\n        String returnName = \"\";\r\n        try {\r\n            int size = getParticipants().size();\r\n            for (int i = 0; i < size; i++) {\r\n                returnName += participants.get(i).getName();\r\n                if (i < size - 1) {\r\n                    returnName += \", \";\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            Log.d(this.getClass().getSimpleName(), e.getMessage());\r\n        }\r\n        return returnName;\r\n    }\r\n\r\n    public void setName(String name, boolean isNotDefault) {\r\n        this.nameChanged = isNotDefault;\r\n        this.name = name;\r\n    }\r\n\r\n    public Date getLastModified() {\r\n        return lastModified;\r\n    }\r\n\r\n    public void setLastModified(Timestamp lastModified) {\r\n        this.lastModified = lastModified;\r\n    }\r\n\r\n    public Date getCreated() {\r\n        return created;\r\n    }\r\n\r\n    public void setCreated(Timestamp created) {\r\n        this.created = created;\r\n    }\r\n\r\n    public String getProfilePicture() {\r\n        return profilePicture;\r\n    }\r\n\r\n    public void setProfilePicture(String profilePicture) {\r\n        this.profilePicture = profilePicture;\r\n    }\r\n\r\n    @JsonIgnoreProperties({\"pw\", \"email\", \"name\", \"devices\", \"lastModified\", \"created\"})\r\n    public User getOwner() {\r\n        if (owner == null) {\r\n            owner = new User(\"Dummy\", 12);\r\n        }\r\n        return owner;\r\n    }\r\n\r\n    public void setOwner(User owner) {\r\n        this.owner = owner;\r\n    }\r\n\r\n    @JsonIgnore\r\n    public int getNumberOfParticipants() {\r\n        if (participants != null) {\r\n            return participants.size();\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    @JsonIgnore\r\n    public ArrayList<Message> getMessages() {\r\n        if (messages == null) {\r\n            return new ArrayList<Message>();\r\n        }\r\n        return new ArrayList<Message>(messages);\r\n    }\r\n\r\n    public void setMessages(ArrayList<Message> messages) {\r\n        this.messages = messages;\r\n    }\r\n\r\n    public void setLastModified(Date lastModified) {\r\n        this.lastModified = lastModified;\r\n    }\r\n\r\n    /**\r\n     * Other Methods\r\n     */\r\n    @JsonIgnore\r\n    public boolean isOwner(long userId) {\r\n        if (owner.getId() == userId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public Message getLastMessage() {\r\n        return lastMessage;\r\n    }\r\n\r\n    public void setLastMessage(Message lastMessage) {\r\n        this.lastMessage = lastMessage;\r\n    }\r\n\r\n    public Chat clone() {\r\n        try {\r\n            return new Chat(this);\r\n        } catch (IllegalAccessException e) {\r\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/NotifiableFragment.java\npublic interface NotifiableFragment<T> {\n\n    void notifyFragment(T value);\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/asyncTasks/server/ChangeOwnerAndLeaveTask.java\npublic class ChangeOwnerAndLeaveTask extends AsyncTask<Long, Void, Boolean> {\n    private Chat chat;\n\n    public ChangeOwnerAndLeaveTask(Chat chat) {\n        this.chat = chat;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n    }\n\n    /**\n     * @param params 0 is id of new owner\n     *               1 is additional leave\n     * @return Returns true if it was successful, otherwise false\n     */\n    @Override\n    protected Boolean doInBackground(Long... params) {\n        try {\n            ChatTask.getInstance().changeOwnerOfChat(chat.getId(), params[0]);\n        } catch (RestServiceException e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return false;\n        }\n        chat.setOwner(DatabaseManager.INSTANCE.getUserDAO().get(params[0]));\n        if (params[1] == 1L) {\n            try {\n                ChatTask.getInstance().removeOneSelfFromChat(chat.getId());\n            } catch (RestServiceException e) {\n                Log.e(this.getClass().getSimpleName(), e.getMessage());\n                return false;\n            }\n            chat.removeParticipant(DatabaseManager.INSTANCE.getUserDAO()\n                    .get(DatabaseManager.INSTANCE.getUserId()));\n        }\n        DatabaseManager.INSTANCE.getChatDAO().update(chat);\n        return true;\n    }\n\n    @Override\n    protected void onPostExecute(final Boolean success) {\n        SpinnerObservable.getInstance().removeBackgroundTask(this);\n        if (success) {\n            Toaster.getInstance().toast(R.string.change_successful, Toast.LENGTH_LONG);\n            new GetMyChatsTask(ChatListFragment.class).startIfNecessary();\n        } else {\n            Toaster.getInstance().toast(R.string.change_not_successful, Toast.LENGTH_LONG);\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/EditTextWithX.java\npublic class EditTextWithX {\n    private EditText et;\n    private Drawable x;\n\n    public EditTextWithX(Context context) {\n        et = new EditText(context);\n        x = context.getResources().getDrawable(R.drawable.ic_action_cancel);\n        x.setBounds(0, 0, x.getIntrinsicWidth(), x.getIntrinsicHeight());\n        et.setCompoundDrawables(null, null, et.getText().toString().equals(\"\") ? null : x, null);\n        et.setOnTouchListener(new View.OnTouchListener() {\n            @Override\n            public boolean onTouch(View view, MotionEvent motionEvent) {\n                if (et.getCompoundDrawables()[2] == null) {\n                    return false;\n                }\n                if (motionEvent.getAction() != MotionEvent.ACTION_UP) {\n                    return false;\n                }\n                if (motionEvent.getX() > et.getWidth() - et.getPaddingRight() - x.getIntrinsicWidth()) {\n                    et.setText(\"\");\n                    et.setCompoundDrawables(null, null, null, null);\n                }\n                return false;\n            }\n        });\n        et.addTextChangedListener(new TextWatcher() {\n            @Override\n            public void onTextChanged(CharSequence s, int start, int before, int count) {\n                et.setCompoundDrawables(null, null, et.getText().toString().equals(\"\") ? null : x, null);\n            }\n\n            @Override\n            public void afterTextChanged(Editable arg0) {\n\n            }\n\n            @Override\n            public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\n            }\n        });\n    }\n\n    public EditText getEditText() {\n        return et;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/UserAdapter.java\npublic class UserAdapter extends ArrayAdapter<User> {\n    private List<User> users;\n    private final Context context;\n    private SparseBooleanArray selectedContacts = new SparseBooleanArray();\n    private int layout = R.layout.user_item;\n\n    public SparseBooleanArray getSelectedContacts() {\n        return selectedContacts;\n    }\n\n    /**\n     * @see <a href=\"http://developer.android.com/design/style/color.html\">Color palette used</a>\n     * from K9 Mail\n     */\n    public final static int CONTACT_DUMMY_COLORS_ARGB[] = {\n            0xff33B5E5,\n            0xffAA66CC,\n            0xff99CC00,\n            0xffFFBB33,\n            0xffFF4444,\n            0xff0099CC,\n            0xff9933CC,\n            0xff669900,\n            0xffFF8800,\n            0xffCC0000\n    };\n\n    public UserAdapter(Context context, int resource, List<User> users) {\n        super(context, resource, users);\n        this.users = users;\n        this.context = context;\n        this.layout = resource;\n    }\n\n    @Override\n    public void notifyDataSetChanged() {\n        selectedContacts = new SparseBooleanArray();\n        super.notifyDataSetChanged();\n    }\n\n    @Override\n    public View getView(final int position, View convertView, ViewGroup parent) {\n        User user = DatabaseManager.INSTANCE.getUserDAO().get(users.get(position).getId());\n        if (user == null) {\n            Log.w(this.getClass().getSimpleName(), \"User not found in DB\");\n            user = users.get(position);\n        }\n\n        LayoutInflater inflater = ((Activity) context).getLayoutInflater();\n\n        View rowView = inflater.inflate(layout, parent, false);\n\n        ImageView profileImage = (ImageView) rowView.findViewById(R.id.user_picture);\n        TextView initial = (TextView) rowView.findViewById(R.id.user_picture_text);\n        TextView profileName = (TextView) rowView.findViewById(R.id.user_name);\n        TextView profileId = (TextView) rowView.findViewById(R.id.user_id);\n        CheckBox checkBox;\n        if (layout == R.layout.user_item_checkbox) {\n            checkBox = (CheckBox) rowView.findViewById(R.id.checkBox);\n        } else {\n            checkBox = null;\n        }\n\n        boolean isSelf = (user.getId() == DatabaseManager.INSTANCE.getUserId());\n        if (isSelf) {\n            SharedPreferences storage = context\n                    .getSharedPreferences(AbstractYasmeActivity.STORAGE_PREFS, Context.MODE_PRIVATE);\n            user.setProfilePicture(storage.getString(AbstractYasmeActivity.PROFILE_PICTURE, null));\n        }\n\n        if (user.getProfilePicture() != null && !user.getProfilePicture().isEmpty()) {\n            // load picture from local storage\n            initial.setVisibility(View.GONE);\n            profileImage.setBackgroundColor(Color.TRANSPARENT);\n            profileImage.setImageBitmap(PictureManager.INSTANCE.getPicture(user, 50, 50));\n        } else {\n            // no local picture found. Set default pic\n            profileImage.setBackgroundColor(CONTACT_DUMMY_COLORS_ARGB\n                    [(int) user.getId() % CONTACT_DUMMY_COLORS_ARGB.length]);\n            initial.setText(user.getName().substring(0, 1).toUpperCase());\n        }\n\n        profileName.setText(user.getName());\n        profileId.setText(\"YD \" + user.getId());\n        if (checkBox != null) {\n            checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n                @Override\n                public void onCheckedChanged(CompoundButton compoundButton, boolean b) {\n                    selectedContacts.append(position, b);\n                }\n            });\n        }\n\n        rowView.requestFocus();\n        return rowView;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/storage/dao/ChatDAO.java\npublic interface ChatDAO extends DAO<Chat> {\n\n    /**\n     * Creates a chat item but only if the ID does not already exist in the table. This\n     * extracts the id from the chat parameter, queries for it's id, returning the data if it\n     * exists. If it does not exist create will be called with the parameter.\n     * @param chat to be added\n     * @return given chat or null if an error occurs\n     */\n    public Chat addIfNotExists(Chat chat);\n\n\n    /**\n     * This method is a combination of addIfNotExists and update for the sake of convenience.\n     * Queries for a chat item with the specified id. If there is none, addIfNotExists is called, otherwise update.\n     * @param chat to be added or updated\n     * @return given chat after insertion / update\n     */\n    public Chat addOrUpdate(Chat chat);\n\n    /**\n     * Retrieves an object associated with a specific ID.\n     * @param id Identifier that matches a specific row in the database to find and return.\n     * @return The object that has the ID field which equals id or null if no matches.\n     */\n    public Chat get(long id);\n\n    /**\n     * Query for all of the items in the object table\n     * @return list of all chats or null on error\n     */\n    public List<Chat> getAll();\n\n\n    /**\n     * Retrieves all chats from the database which are held between the exact list of given users\n     * @param users who participate in the chat to return. Don't forget that you are a participant as well and thus should be present in the list\n     * @return list of chats which matched the conditions\n     */\n    public List<Chat> getByParticipantsExact(Set<User> users);\n\n\n    /**\n     * Retrieves all chats from the database which are held between the given users or more\n     * @param users who participate in the chat to look for\n     * @return list of chats which have the given users (and more) as participants\n     */\n    public List<Chat> getByTheseParticipantsOrMore(Set<User> users);\n\n    /**\n     * Store the fields from an object to the database row corresponding to the id from the data parameter. If you have\n     * made changes to an object, this is how you persist those changes to the database. You cannot use this method to\n     * update the id field\n     * @param chat to be updated\n     * @return given chat or null on error\n     */\n    public Chat update(Chat chat);\n\n\n    /**\n     * Delete the database row corresponding to the id from the data parameter.\n     * @param chat to be deleted\n     * @return true on success, false otherwise\n     */\n    public boolean delete(Chat chat);\n\n\n    /**\n     * Replaces all currently stored chats with given ones. Updates old chats with the values from the new one if their id matches.\n     * @param newChats to be stored\n     * @return true if successful, false otherwise\n     */\n    public boolean refreshAll(List<Chat> newChats);\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/asyncTasks/server/LeaveChatTask.java\npublic class LeaveChatTask extends AsyncTask<Long, Void, Boolean> {\n    private Chat chat;\n\n    public LeaveChatTask(Chat chat) {\n        this.chat = chat;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n    }\n\n    /**\n     * @return true an success, otherwise false\n     */\n    @Override\n    protected Boolean doInBackground(Long... params) {\n        try {\n            ChatTask.getInstance().removeOneSelfFromChat(chat.getId());\n        } catch (RestServiceException e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    protected void onPostExecute(final Boolean success) {\n        SpinnerObservable.getInstance().removeBackgroundTask(this);\n        if (success) {\n            Toaster.getInstance().toast(R.string.change_successful, Toast.LENGTH_SHORT);\n            new GetMyChatsTask(ChatListFragment.class).startIfNecessary();\n        } else {\n            Toaster.getInstance().toast(R.string.change_not_successful, Toast.LENGTH_SHORT);\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/storage/DatabaseManager.java\npublic enum DatabaseManager {\n    INSTANCE;\n\n    private boolean mInitialized = false;\n    private boolean mDBInitialized = false;\n    private DatabaseHelper mHelper;\n    private Context mContext;\n    private long mUserId = -1;\n    private long mDeviceId = -1;\n    private String mAccessToken = null;\n    private long serverInfoUpdateTime = -1;\n    private ServerInfo serverInfo = null;\n    private SharedPreferences mSharedPreferences, mSettings;\n    private String mUserEmail;\n    private NewMessageNotificationManager notifier = null;\n\n    private UserDAO userDAO;\n    private ChatDAO chatDAO;\n    private MessageDAO messageDAO;\n    private MessageKeyDAO messageKeyDAO;\n    private DeviceDAO deviceDAO;\n\n\n    public void init(Context context, SharedPreferences sharedPreferences,\n                     SharedPreferences settings, long userId) {\n        mContext = context;\n        mSharedPreferences = sharedPreferences;\n        mSettings = settings;\n        mUserId = userId;\n        initDB(context, userId);\n        initializeDAOs();\n        mInitialized = true;\n    }\n\n    public void initDB(Context context, long userId) {\n        mHelper = new DatabaseHelper(context, userId);\n        mDBInitialized = true;\n    }\n\n    public boolean isInitialized() {\n        return mInitialized;\n    }\n\n    public boolean isDBInitialized() {\n        return mDBInitialized;\n    }\n\n    private DatabaseHelper getHelper() {\n        return mHelper;\n    }\n\n    public SharedPreferences getSharedPreferences() {\n        return mSharedPreferences;\n    }\n\n    public SharedPreferences getSettings() {\n        return mSettings;\n    }\n\n    public Context getContext() {\n        return mContext;\n    }\n\n    private void initializeDAOs() {\n        UserDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        userDAO = UserDAOImpl.INSTANCE;\n\n        ChatDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        chatDAO = ChatDAOImpl.INSTANCE;\n\n        MessageDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        messageDAO = MessageDAOImpl.INSTANCE;\n\n        MessageKeyDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        messageKeyDAO = MessageKeyDAOImpl.INSTANCE;\n\n        DeviceDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        deviceDAO = DeviceDAOImpl.INSTANCE;\n    }\n\n    public UserDAO getUserDAO() {\n        return userDAO;\n    }\n\n    public ChatDAO getChatDAO() {\n        return chatDAO;\n    }\n\n    public MessageDAO getMessageDAO() {\n        return messageDAO;\n    }\n\n    public MessageKeyDAO getMessageKeyDAO() {\n        return messageKeyDAO;\n    }\n\n    public DeviceDAO getDeviceDAO() {\n        return deviceDAO;\n    }\n\n    public long getUserId() {\n        if (-1 == mUserId) {\n            mUserId = getSharedPreferences().getLong(AbstractYasmeActivity.USER_ID, -1);\n        }\n        return mUserId;\n    }\n\n    public void setUserId(long mUserId) {\n        this.mUserId = mUserId;\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putLong(AbstractYasmeActivity.USER_ID, mUserId);\n        editor.apply();\n    }\n\n    public long getDeviceId() {\n        if (-1 == mDeviceId) {\n            mDeviceId = getSharedPreferences().getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n        }\n        return mDeviceId;\n    }\n\n    public void setDeviceId(long mDeviceId) {\n        this.mDeviceId = mDeviceId;\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putLong(AbstractYasmeActivity.DEVICE_ID, mDeviceId);\n        editor.apply();\n    }\n\n    public String getAccessToken() {\n        if (null == mAccessToken) {\n            mAccessToken = getSharedPreferences().getString(AbstractYasmeActivity.ACCESSTOKEN, null);\n        }\n        return mAccessToken;\n    }\n\n    public void setAccessToken(String accessToken) {\n        this.mAccessToken = accessToken;\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putString(AbstractYasmeActivity.ACCESSTOKEN, mAccessToken);\n        editor.commit();\n    }\n\n    public long getServerInfoUpdateTime() {\n        if (-1 == serverInfoUpdateTime) {\n            serverInfoUpdateTime = getSharedPreferences().getLong(AbstractYasmeActivity.SERVERINFOUPDATETIME, -1);\n        }\n        return serverInfoUpdateTime;\n    }\n\n    public void setServerInfoUpdateTime() {\n        this.serverInfoUpdateTime = System.currentTimeMillis();\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putLong(AbstractYasmeActivity.SERVERINFOUPDATETIME, serverInfoUpdateTime);\n        editor.commit();\n    }\n\n    public ServerInfo getServerInfo() {\n        return serverInfo;\n    }\n\n    public void setServerInfo(ServerInfo serverInfo) {\n        this.serverInfo = serverInfo;\n    }\n\n    public String getUserEmail() {\n        if (null == mUserEmail || \"\" == mUserEmail) {\n            mUserEmail = getSharedPreferences().getString(AbstractYasmeActivity.USER_MAIL, null);\n        }\n        return mUserEmail;\n    }\n\n    public void setUserEmail(String mUserEmail) {\n        this.mUserEmail = mUserEmail;\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putString(AbstractYasmeActivity.USER_MAIL, mUserEmail);\n        editor.commit();\n    }\n\n    public NewMessageNotificationManager getNotifier() {\n        if (notifier == null) {\n            notifier = new NewMessageNotificationManager();\n        }\n        return notifier;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/ObservableRegistry.java\npublic class ObservableRegistry {\n\n    private static ArrayList<ObservableRegistryEntry> entries = new ArrayList<ObservableRegistryEntry>();\n\n    public static <T extends NotifiableFragment<P>, P> FragmentObservable<T, P> getObservable(Class fragmentClass) {\n        for (ObservableRegistryEntry entry : entries) {\n            if (entry.check(fragmentClass)) {\n                Log.d(\"ObserverRegistry\",\"Returned existing observable\");\n                return (FragmentObservable<T,P>) entry.getObs(); // no idea how to solve this... \n            }\n        }\n\n        FragmentObservable<T, P> res = new FragmentObservable<T, P>();\n        Log.d(\"ObserverRegistry\",\"Created new observable\");\n        entries.add(new ObservableRegistryEntry<P>(res,fragmentClass));\n        return res;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/Log.java\npublic class Log {\r\n    static final boolean LOG_I = BuildConfig.DEBUG;\r\n    static final boolean LOG_E = BuildConfig.DEBUG;\r\n    static final boolean LOG_D = BuildConfig.DEBUG;\r\n    static final boolean LOG_V = BuildConfig.DEBUG;\r\n    static final boolean LOG_W = BuildConfig.DEBUG;\r\n\r\n    public static void i(String tag, String string) {\r\n        if (LOG_I) android.util.Log.i(tag, string);\r\n    }\r\n    public static void e(String tag, String string) {\r\n        if (LOG_E) android.util.Log.e(tag, string);\r\n    }\r\n    public static void d(String tag, String string) {\r\n        if (LOG_D) android.util.Log.d(tag, string);\r\n    }\r\n    public static void v(String tag, String string) {\r\n        if (LOG_V) android.util.Log.v(tag, string);\r\n    }\r\n    public static void w(String tag, String string) {\r\n        if (LOG_W) android.util.Log.w(tag, string);\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/asyncTasks/server/ChangeChatProperties.java\npublic class ChangeChatProperties extends AsyncTask<String, Void, Boolean> {\n    private Chat chat;\n    private Class classToNotify;\n\n    public ChangeChatProperties(Chat chat, Class classToNotify) {\n        this.chat = chat;\n        this.classToNotify = classToNotify;\n    }\n\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n    }\n\n    /**\n     * @return Returns true if it was successful, otherwise false\n     */\n    @Override\n    protected Boolean doInBackground(String... params) {\n        try {\n            ChatTask.getInstance().updateChat(chat);\n        } catch (RestServiceException e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return false;\n        }\n        DatabaseManager.INSTANCE.getChatDAO().update(chat);\n        return true;\n    }\n\n    /**\n     *\n     */\n    protected void onPostExecute(final Boolean success) {\n        SpinnerObservable.getInstance().removeBackgroundTask(this);\n        if (success) {\n            ObservableRegistry.getObservable(classToNotify).notifyFragments(chat);\n            Toaster.getInstance().toast(R.string.change_successful, Toast.LENGTH_LONG);\n        } else {\n            Toaster.getInstance().toast(R.string.change_not_successful, Toast.LENGTH_LONG);\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/activities/ChatSettingsActivity.java\npublic class ChatSettingsActivity extends AbstractYasmeActivity {\n    /**\n     * The {@link android.support.v4.view.PagerAdapter} that will provide\n     * fragments for each of the sections. We use a\n     * {@link android.support.v13.app.FragmentPagerAdapter} derivative, which will keep every\n     * loaded fragment in memory. If this becomes too memory intensive, it\n     * may be best to switch to a\n     * {@link android.support.v13.app.FragmentStatePagerAdapter}.\n     */\n    public static final String CHAT_ID = \"chatId\";\n\n    ChatSettingsActivity.SectionsPagerAdapter mSectionsPagerAdapter;\n    ViewPager mViewPager;\n\n    private long chatId;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        //progress bar in actionbar\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n\n        chatId = getIntent().getLongExtra(CHAT_ID, -1);\n        if (chatId <= 0) {\n            throw new IllegalArgumentException(\"chatId <= 0\");\n        }\n\n        setContentView(R.layout.activity_contact);\n\n        // Set up the action bar.\n        final ActionBar actionBar = getActionBar();\n        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);\n\n        // Create the adapter that will return a fragment for each of the three\n        // primary sections of the activity.\n        mSectionsPagerAdapter = new SectionsPagerAdapter(getFragmentManager());\n\n        // Set up the ViewPager with the sections adapter.\n        mViewPager = (ViewPager) findViewById(R.id.pager);\n        if(mViewPager == null) {\n            Log.e(this.getClass().getSimpleName(), \"ViewPager ist null\");\n        }\n        mViewPager.setAdapter(mSectionsPagerAdapter);\n\n        // When swiping between different sections, select the corresponding\n        // tab. We can also use ActionBar.Tab#select() to do this if we have\n        // a reference to the Tab.\n        mViewPager.setOnPageChangeListener(new ViewPager.SimpleOnPageChangeListener() {\n            @Override\n            public void onPageSelected(int position) {\n                actionBar.setSelectedNavigationItem(position);\n            }\n        });\n\n        // Create a tab listener that is called when the user changes tabs.\n        ActionBar.TabListener tabListener = new ActionBar.TabListener() {\n            public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {\n                // When the tab is selected, switch to the\n                // corresponding page in the ViewPager.\n                mViewPager.setCurrentItem(tab.getPosition());\n            }\n\n            public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) {\n                // hide the given tab\n            }\n\n            public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) {\n                // probably ignore this event\n            }\n        };\n\n        // Add tabs, specifying the tab's text and TabListener\n        for (int i = 0; i < mSectionsPagerAdapter.getCount(); i++) {\n            actionBar.addTab(actionBar.newTab().setText(mSectionsPagerAdapter.getPageTitle(i))\n                    .setTabListener(tabListener));\n        }\n    }\n\n\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.chat, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int itemId = item.getItemId();\n        if (itemId == android.R.id.home) {\n            onBackPressed();\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n\n    @Override\n    public void onBackPressed() {\n        Intent intent = new Intent(this, ChatActivity.class);\n        intent.putExtra(AbstractYasmeActivity.CHAT_ID, chatId);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n        startActivity(intent);\n    }\n\n    /**\n     * A {@link android.support.v13.app.FragmentPagerAdapter} that returns a fragment corresponding to\n     * one of the sections/tabs/pages.\n     */\n    public class SectionsPagerAdapter extends FragmentPagerAdapter {\n\n        public SectionsPagerAdapter(FragmentManager fm) {\n            super(fm);\n        }\n\n        @Override\n        public Fragment getItem(int position) {\n            // getItem is called to instantiate the fragment for the given page.\n\n            // It may be a better idea to pass the chat id and retrieve\n            Bundle args = new Bundle();\n            args.putLong(CHAT_ID, chatId);\n\n            switch (position){\n                case 0:\n                    ChatSettingsInfo csi = new ChatSettingsInfo();\n                    csi.setArguments(args);\n                    return csi;\n                case 1:\n                    ChatSettingsAdd csa = new ChatSettingsAdd();\n                    csa.setArguments(args);\n                    return csa;\n                case 2:\n                    ChatSettingsRemove csr = new ChatSettingsRemove();\n                    csr.setArguments(args);\n                    return csr;\n                default:\n                    ChatSettingsInfo csid = new ChatSettingsInfo();\n                    csid.setArguments(args);\n                    return csid;\n            }\n        }\n\n\n        @Override\n        public int getCount() {\n            return 3;\n        }\n\n        @Override\n        public CharSequence getPageTitle(int position) {\n            Locale l = Locale.getDefault();\n            switch (position) {\n                case 0:\n                    return getString(R.string.settings_title_tab1).toUpperCase(l);\n                case 1:\n                    return getString(R.string.settings_title_tab2).toUpperCase(l);\n                case 2:\n                    return getString(R.string.settings_title_tab3).toUpperCase(l);\n\n            }\n            return null;\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/activities/ChatListActivity.java\npublic class ChatListActivity extends AbstractYasmeActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        //progress bar in actionbar\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n\n        setContentView(R.layout.activity_with_single_fragment);\n\n        if (HttpClient.context == null) {\n            HttpClient.context = this.getApplicationContext();\n        }\n\n        SharedPreferences devicePrefs = getSharedPreferences(DEVICE_PREFS, MODE_PRIVATE);\n\n        // Make sure that the device has been registered. Otherwise several other tasks will fail\n        long deviceId = DatabaseManager.INSTANCE.getDeviceId();\n        if (deviceId <= 0) {\n            Log.e(this.getClass().getSimpleName(), \"Device id should not be <= 0 after login. \" +\n                    \"Looks like the device registration failed but no one was notified about that\");\n        }\n\n        if (savedInstanceState == null) {\n            getFragmentManager().beginTransaction()\n                    .add(R.id.singleFragmentContainer, new ChatListFragment()).commit();\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.chatlist, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        if (id == R.id.action_add_chat) {\n            Intent intent = new Intent(this, InviteToChatActivity.class);\n            startActivity(intent);\n            return true;\n        }\n        if (id == R.id.sign_out) {\n            new LogoutTask().execute();\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    protected void startLoginActivity() {\n        //setSignedInFlag(false);\n        DatabaseManager.INSTANCE.setAccessToken(null);\n        Intent intent = new Intent(this, LoginActivity.class);\n        startActivity(intent);\n        finish();\n    }\n\n    private class LogoutTask extends AsyncTask<Void, Void, Boolean> {\n        @Override\n        protected Boolean doInBackground(Void... voids) {\n            try {\n                AuthorizationTask.getInstance().logoutUser();\n            } catch (RestServiceException e) {\n                Log.e(this.getClass().getSimpleName(), e.getMessage());\n                Log.i(this.getClass().getSimpleName(), \"Sign out not succesfull\");\n                return false;\n            }\n            return true;\n        }\n\n        protected void onPostExecute(Boolean success) {\n            if (!success) {\n                return;\n            }\n            startLoginActivity();\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/FragmentObservable.java\npublic class FragmentObservable<T extends NotifiableFragment<P>,  P> {\r\n    private Set<T> fragments;\r\n    private P buffer;\r\n\r\n    public FragmentObservable() {\r\n        fragments = new HashSet<T>();\r\n    }\r\n\r\n    public void register(T fragment) {\r\n        fragments.add(fragment);\r\n        if (buffer != null) {\r\n            notifyFragments(buffer);\r\n        }\r\n    }\r\n\r\n    public void remove(T fragment) {\r\n        fragments.remove(fragment);\r\n    }\r\n\r\n    //addIfNotExists\r\n    public void notifyFragments(P parameter) {\r\n        buffer = parameter;\r\n        for (T fragment : fragments) {\r\n            try {\r\n                Log.d(this.getClass().getSimpleName(), \"Notify fragment: \" + fragment.getClass().getSimpleName());\r\n                fragment.notifyFragment(parameter);\r\n                buffer = null;\r\n            } catch (Exception e) {\r\n                Log.e(this.getClass().getSimpleName(), \"Notify fragment failed: \" + fragment.getClass().getSimpleName());\r\n            }\r\n        }\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/asyncTasks/database/GetTask.java\npublic class GetTask<D extends Object, T extends DAO<D>> extends AsyncTask<Object, Void, Boolean> {\n\n    private T specificDAO;\n    private long idToGet;\n    private D data;\n    private Class classToNotify;\n\n    public GetTask(T specificDAO, long idToGet, Class classToNotify) {\n        this.specificDAO = specificDAO;\n        this.idToGet = idToGet;\n        this.classToNotify = classToNotify;\n    }\n\n    @Override\n    protected Boolean doInBackground(Object... objects) {\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n        return null != (data = specificDAO.get(idToGet));\n    }\n\n    @Override\n    protected void onPostExecute(Boolean success) {\n        SpinnerObservable.getInstance().removeBackgroundTask(this);\n        if (success) {\n            // Notify\n            ObservableRegistry.getObservable(classToNotify).notifyFragments(data);\n        } else {\n            Log.w(this.getClass().getSimpleName(), \"Did not invoke notification as task did not finish successfully.\");\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/asyncTasks/database/UpdateTask.java\npublic class UpdateTask<D extends Object, T extends DAO<D>> extends AsyncTask<Object, Void, Boolean> {\n\n    private T specificDAO;\n    private D data;\n    private Class classToNotify;\n\n    public UpdateTask(T specificDAO, D data, Class classToNotify) {\n        this.specificDAO = specificDAO;\n        this.data = data;\n        this.classToNotify = classToNotify;\n    }\n\n    @Override\n    protected Boolean doInBackground(Object... objects) {\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n        return null != (data = specificDAO.update(data));\n    }\n\n    @Override\n    protected void onPostExecute(Boolean success) {\n        SpinnerObservable.getInstance().removeBackgroundTask(this);\n        if (success) {\n            // Notify\n            ObservableRegistry.getObservable(classToNotify).notifyFragments(data);\n        } else {\n            Log.w(this.getClass().getSimpleName(), \"Did not invoke notification as task did not finish successfully.\");\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/Sanitizer.java\npublic class Sanitizer {\n    private static String regex = \"A-Za-z0-9 \";\n\n    public static String sanitize(String input) {\n        // Replace all non-alphanumerical and non-whitespace characters\n        return input.replaceAll(\"[^\"+regex+\"]\",\"\");\n    }\n\n    public static String sanitize(String input, String extra) {\n        return input.replaceAll(\"[^\"+regex+extra+\"]\",\"\");\n    }\n\n    public String getRegex() { return this.regex; }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/User.java\n@JsonIgnoreProperties(ignoreUnknown = true)\n@DatabaseTable(tableName = DatabaseConstants.USER_TABLE)\npublic class User implements Serializable {\n\n    @DatabaseField(columnName = DatabaseConstants.USER_ID, id = true)\n    private long id;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_NAME)\n    private String name;\n\n    //@DatabaseField(columnName = DatabaseConstants.USER_EMAIL)\n    private String email;\n\n    private String pw;\n\n    @JsonIgnore\n    private List<Device> devices;   // Just for convenience\n\n    @DatabaseField(columnName = DatabaseConstants.USER_LAST_MODIFIED)\n    private Date lastModified;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_CREATED)\n    private Date created;\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.USER_PICTURE)\n    private String profilePicture;\n\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.CONTACT)\n    private int contactFlag = 0;\n\n\n    public User(String pw, String name, String email) {\n        this.pw = pw;\n        this.name = name;\n        this.email = email;\n    }\n\n    public User(String email, String pw) {\n        this.email = email;\n        this.pw = pw;\n    }\n\n    public User(String name, long id) {\n        this.name = name;\n        this.id = id;\n    }\n\n    public User(long id) {\n        this.id = id;\n    }\n\n    public User(String name, String email, long id) {\n        this.name = name;\n        this.email = email;\n        this.id = id;\n    }\n\n    public User() {\n        // ORMLite needs a no-arg constructor\n    }\n\n    /*\n     * Getters\n     */\n\n    @JsonIgnoreProperties({\"id\", \"user\", \"publicKey\", \"product\", \"lastModified\"})\n    public List<Device> getDevices() {\n        return devices;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPw() {\n        return pw;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Date getLastModified() {\n        return lastModified;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public String getProfilePicture() {\n        return profilePicture;\n    }\n\n    /*\n     * Setters\n     */\n\n    public void setDevices(List<Device> devices) {\n        this.devices = devices;\n    }\n\n    public void setPw(String pw) {\n        this.pw = pw;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setProfilePicture(String profilePicture) {\n        this.profilePicture = profilePicture;\n    }\n\n    @JsonIgnore\n    public void addToContacts() {\n        contactFlag = 1;\n    }\n\n    @JsonIgnore\n    public void removeFromContacts() {\n        contactFlag = 0;\n    }\n\n    @JsonIgnore\n    public boolean isContact() {\n        return contactFlag == 1;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/AbstractYasmeActivity.java\npublic abstract class AbstractYasmeActivity extends Activity implements Toastable {\n    public final static String USER_ID = \"de.fau.cs.mad.yasme.android.USER_ID\";\n    public final static String USER_NAME = \"de.fau.cs.mad.yasme.android.USER_NAME\";\n    public final static String USER_MAIL = \"de.fau.cs.mad.yasme.android.USER_MAIL\";\n    public final static String USER_PW = \"de.fau.cs.mad.yasme.android.USER_PW\";\n    public final static String DEVICE_ID = \"de.fau.cs.mad.yasme.android.DEVICE_ID\";\n    public final static String PROFILE_PICTURE = \"de.fau.cs.mad.yasme.android.PROFILE_PICTURE\";\n\n    public final static String CHAT_ID = \"de.fau.cs.mad.yasme.android.CHAT_ID\";\n    public final static String LAST_MESSAGE_ID = \"de.fau.cs.mad.yasme.android.LAST_MESSAGE_ID\";\n\n    public final static String ACCESSTOKEN = \"de.fau.cs.mad.yasme.android.ACCESSTOKEN\";\n    public final static String SIGN_IN = \"de.fau.cs.mad.yasme.android.SIGN_IN\";\n\n    public final static String SERVERINFOUPDATETIME = \"de.fau.cs.mad.yasme.android.SERVERINFOUPDATETIME\";\n    public final static String SERVERMESSAGE = \"de.fau.cs.mad.yasme.android.SERVERMESSAGE\";\n\n    public final static String STORAGE_PREFS = \"de.fau.cs.mad.yasme.android.STORAGE_PREFS\";\n    public final static String SETTINGS_PREFS = \"de.fau.cs.mad.yasme.android.SETTINGS_PREFS\";\n    public final static String DEVICE_PREFS = \"de.fau.cs.mad.yasme.android.DEVICE_PREFS\";\n    public final static String PUSH_PREFS = \"de.fau.cs.mad.yasme.android.PUSH_PREFS\";\n\n    public final static String NOTIFICATION_VIBRATE = \"de.fau.cs.mad.yasme.android.NOTIFICATION_VIBRATE\";\n    public final static String NOTIFICATION_SOUND = \"de.fau.cs.mad.yasme.android.NOTIFICATION_SOUND\";\n\n\n    //GCM Properties\n    public static final String PROPERTY_REG_ID = \"registration_id\";\n    public static final String PROPERTY_APP_VERSION = \"appVersion\";\n    public static final String SENDER_ID = \"688782154540\"; //\"104759172131\";\n    public static final int PLAY_SERVICES_RESOLUTION_REQUEST = 9000;\n    public static final String TAG = \"YasmeGCM\";\n\n    protected User selfUser;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        if (!ConnectionTask.isInitialized()) {\n            String server = getResources().getString(R.string.server_host);\n            if (BuildConfig.DEBUG) {\n                server = getResources().getString(R.string.server_host_debug);\n            }\n            Log.d(getClass().getSimpleName(), \"YASME-Server: \" + server);\n            ConnectionTask.initParams(getResources().getString(R.string.server_scheme),\n                    server,\n                    getResources().getString(R.string.server_port), getResources().getString(R.string.language), getVersion());\n        }\n\n        SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n        SharedPreferences settings = getSharedPreferences(SETTINGS_PREFS, MODE_PRIVATE);\n        Long userId = storage.getLong(USER_ID, 0);\n        String userName = storage.getString(USER_NAME, \"\");\n        String userMail = storage.getString(USER_MAIL, \"\");\n        String userPw = storage.getString(USER_PW, \"password\");\n\n        if(selfUser==null) {\n            selfUser = new User();\n        }\n        selfUser.setId(userId);\n        selfUser.setName(userName);\n        selfUser.setEmail(userMail);\n        selfUser.setPw(userPw);\n\n\n        //Initialize databaseManager (once in application)\n        if (!DatabaseManager.INSTANCE.isInitialized()) {\n            DatabaseManager.INSTANCE.init(this, storage, settings, userId);\n        }\n        //Init QR-Code\n        QR.init(false);\n\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Toaster.getInstance().register(this);\n        stopSpinning();\n        SpinnerObservable.getInstance().registerActivity(this);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        Toaster.getInstance().remove(this);\n        SpinnerObservable.getInstance().removeActivity(this);\n    }\n\n    public void setActionBarTitle(String title) {\n        getActionBar().setTitle(title);\n    }\n\n    public void setActionBarTitle(String title, String subtitle) {\n        getActionBar().setTitle(title);\n        getActionBar().setSubtitle(subtitle);\n    }\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        Intent intent;\n        int itemId = item.getItemId();\n        switch (itemId) {\n            case android.R.id.home:\n                if (NavUtils.getParentActivityName(this) != null) {\n                    NavUtils.navigateUpFromSameTask(this);\n                }\n                return true;\n            case R.id.action_settings:\n                intent = new Intent(this, SettingsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_chats:\n                intent = new Intent(this, ChatListActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_add_chat:\n                intent = new Intent(this, InviteToChatActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            case R.id.action_contacts:\n                intent = new Intent(this, ContactActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            default:\n                return super.onOptionsItemSelected(item);\n\n        }\n    }\n\n    public String getSelfName() {\n\n        if(selfUser==null) {\n            SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n            Long userId = storage.getLong(USER_ID, 0);\n            String userName = storage.getString(USER_NAME, \"\");\n            String userMail = storage.getString(USER_MAIL, \"\");\n            String userPw = storage.getString(USER_PW, \"password\");\n\n            selfUser = new User();\n            selfUser.setId(userId);\n            selfUser.setName(userName);\n            selfUser.setEmail(userMail);\n            selfUser.setPw(userPw);\n        }\n        if (selfUser.getName().isEmpty()) {\n            String name = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_NAME, \"\");\n            selfUser.setName(name);\n        }\n        return selfUser.getName();\n    }\n\n    public User getSelfUser() {\n        return selfUser;\n    }\n\n    public String getUserMail() {\n        if (selfUser == null || selfUser.getEmail().isEmpty()) {\n            String mail = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_MAIL, \"\");\n            selfUser.setEmail(mail);\n        }\n        return selfUser.getEmail();\n    }\n\n    public long getUserId() {\n        return selfUser.getId();\n    }\n\n    public String getOwnProfilePicture() {\n        String path = selfUser.getProfilePicture();\n        if (path == null || path.isEmpty()) {\n            path = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(PROFILE_PICTURE, null);\n        }\n        return path;\n    }\n\n    public void setOwnProfilePicture(String ownProfilePicture) {\n        selfUser.setProfilePicture(ownProfilePicture);\n        SharedPreferences.Editor editor = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).edit();\n        editor.putString(AbstractYasmeActivity.PROFILE_PICTURE, ownProfilePicture);\n        editor.commit();\n    }\n\n    public String getAccessToken() {\n        return DatabaseManager.INSTANCE.getAccessToken();\n    }\n\n    public void toast(final int messageId, final int duration) {\n        String text = getApplicationContext().getResources().getString(messageId);\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration) {\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration, final int gravity) {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                Toast toast = Toast.makeText(getApplicationContext(), text, duration);\n                if (-1 != gravity) {\n                    toast.setGravity(gravity, 0, 0);\n                }\n                // otherwise use default position\n                Log.d(getClass().getSimpleName(), \"Toast: \" + text);\n                toast.show();\n            }\n        });\n    }\n\n    public void startSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(true);\n            }\n        });\n    }\n\n    public void stopSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(false);\n            }\n        });\n    }\n\n    public int getVersion() {\n        try {\n            return getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;\n        } catch (Exception e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return 0;\n        }\n    }\n\n}\n", "answers": ["        Log.d(this.getClass().getSimpleName(), \"onStart\");"], "length": 4792, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "5b87cd00de4bad75cfc232e4b38a4c44e9372480c6e99837"}
{"input": "from fints.fields import CodeField, DataElementField, DataElementGroupField\nfrom fints.formals import (\n    KTI1, BankIdentifier, ChallengeValidUntil, Language2,\n    ParameterChallengeClass, ParameterPinTan, ParameterTwostepTAN1,\n    ParameterTwostepTAN2, ParameterTwostepTAN3, ParameterTwostepTAN4,\n    ParameterTwostepTAN5, ParameterTwostepTAN6, ResponseHHDUC,\n    SystemIDStatus, TANMedia4, TANMedia5, TANMediaClass3,\n    TANMediaClass4, TANMediaType2, TANUsageOption,\n)\nfrom .base import FinTS3Segment, ParameterSegment\n    tan_medium_name = DataElementField(type='an', max_length=32, required=False, _d=\"Bezeichnung des TAN-Mediums\")\n    response_hhd_uc = DataElementGroupField(type=ResponseHHDUC, required=False, _d=\"Antwort HHD_UC\")\n\n\nclass HITAN2(FinTS3Segment):\n    \"\"\"Zwei-Schritt-TAN-Einreichung Rückmeldung, version 2\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n    tan_process = DataElementField(type='code', length=1, _d=\"TAN-Prozess\")\n    task_hash_value = DataElementField(type='bin', max_length=256, required=False, _d=\"Auftrags-Hashwert\")\n    task_reference = DataElementField(type='an', max_length=35, required=False, _d=\"Auftragsreferenz\")\n    challenge = DataElementField(type='an', max_length=2048, required=False, _d=\"Challenge\")\n    challenge_valid_until = DataElementGroupField(type=ChallengeValidUntil, required=False, _d=\"Gültigkeitsdatum und -uhrzeit für Challenge\")\n    tan_list_number = DataElementField(type='an', max_length=20, required=False, _d=\"TAN-Listennummer\")\n    ben = DataElementField(type='an', max_length=99, required=False, _d=\"BEN\")\n\n\nclass HITAN3(FinTS3Segment):\n    \"\"\"Zwei-Schritt-TAN-Einreichung Rückmeldung, version 3\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n    tan_process = DataElementField(type='code', length=1, _d=\"TAN-Prozess\")\n    task_hash_value = DataElementField(type='bin', max_length=256, required=False, _d=\"Auftrags-Hashwert\")\n    task_reference = DataElementField(type='an', max_length=35, required=False, _d=\"Auftragsreferenz\")\n    challenge = DataElementField(type='an', max_length=2048, required=False, _d=\"Challenge\")\n    challenge_valid_until = DataElementGroupField(type=ChallengeValidUntil, required=False, _d=\"Gültigkeitsdatum und -uhrzeit für Challenge\")\n    tan_list_number = DataElementField(type='an', max_length=20, required=False, _d=\"TAN-Listennummer\")\n    ben = DataElementField(type='an', max_length=99, required=False, _d=\"BEN\")\n    tan_medium_name = DataElementField(type='an', max_length=32, required=False, _d=\"Bezeichnung des TAN-Mediums\")\n\n\nclass HITAN5(FinTS3Segment):\n    \"\"\"Zwei-Schritt-TAN-Einreichung Rückmeldung, version 5\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n    tan_process = DataElementField(type='code', length=1, _d=\"TAN-Prozess\")\n    task_hash_value = DataElementField(type='bin', max_length=256, required=False, _d=\"Auftrags-Hashwert\")\n    task_reference = DataElementField(type='an', max_length=35, required=False, _d=\"Auftragsreferenz\")\n    challenge = DataElementField(type='an', max_length=2048, required=False, _d=\"Challenge\")\n    challenge_hhduc = DataElementField(type='bin', required=False, _d=\"Challenge HHD_UC\")\n    challenge_valid_until = DataElementGroupField(type=ChallengeValidUntil, required=False, _d=\"Gültigkeitsdatum und -uhrzeit für Challenge\")\n    tan_list_number = DataElementField(type='an', max_length=20, required=False, _d=\"TAN-Listennummer\")\n    ben = DataElementField(type='an', max_length=99, required=False, _d=\"BEN\")\n    tan_medium_name = DataElementField(type='an', max_length=32, required=False, _d=\"Bezeichnung des TAN-Mediums\")\n\n\nclass HITAN6(FinTS3Segment):\n    \"\"\"Zwei-Schritt-TAN-Einreichung Rückmeldung, version 6\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n    tan_process = DataElementField(type='code', length=1, _d=\"TAN-Prozess\")\n    task_hash_value = DataElementField(type='bin', max_length=256, required=False, _d=\"Auftrags-Hashwert\")\n    task_reference = DataElementField(type='an', max_length=35, required=False, _d=\"Auftragsreferenz\")\n    challenge = DataElementField(type='an', max_length=2048, required=False, _d=\"Challenge\")\n    challenge_hhduc = DataElementField(type='bin', required=False, _d=\"Challenge HHD_UC\")\n    challenge_valid_until = DataElementGroupField(type=ChallengeValidUntil, required=False, _d=\"Gültigkeitsdatum und -uhrzeit für Challenge\")\n    tan_medium_name = DataElementField(type='an', max_length=32, required=False, _d=\"Bezeichnung des TAN-Mediums\")\n\n\nclass HKTAB4(FinTS3Segment):\n    \"\"\"TAN-Generator/Liste anzeigen Bestand, version 4\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    tan_media_type = CodeField(enum=TANMediaType2, _d=\"TAN-Medium-Art\")\n    tan_media_class = CodeField(enum=TANMediaClass3, _d=\"TAN-Medium-Klasse\")\n\n\nclass HITAB4(FinTS3Segment):\n    \"\"\"TAN-Generator/Liste anzeigen Bestand Rückmeldung, version 4\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    tan_usage_option = CodeField(enum=TANUsageOption, _d=\"TAN_Einsatzoption\")\n    tan_media_list = DataElementGroupField(type=TANMedia4, max_count=99, required=False, _d=\"TAN-Medium-Liste\")\n\n\nclass HKTAB5(FinTS3Segment):\n    \"\"\"TAN-Generator/Liste anzeigen Bestand, version 5\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    tan_media_type = CodeField(enum=TANMediaType2, _d=\"TAN-Medium-Art\")\n    tan_media_class = CodeField(enum=TANMediaClass4, _d=\"TAN-Medium-Klasse\")\n\n\nclass HITAB5(FinTS3Segment):\n    \"\"\"TAN-Generator/Liste anzeigen Bestand Rückmeldung, version 5\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    tan_usage_option = CodeField(enum=TANUsageOption, _d=\"TAN_Einsatzoption\")\n    tan_media_list = DataElementGroupField(type=TANMedia5, max_count=99, required=False, _d=\"TAN-Medium-Liste\")\n\n\nclass HITANSBase(ParameterSegment):\n    pass\n\n\nclass HITANS1(HITANSBase):\n    parameter = DataElementGroupField(type=ParameterTwostepTAN1)\n\n\nclass HITANS2(HITANSBase):\n    parameter = DataElementGroupField(type=ParameterTwostepTAN2)\n\n\nclass HITANS3(HITANSBase):\n    parameter = DataElementGroupField(type=ParameterTwostepTAN3)\n\n\nclass HITANS4(HITANSBase):\n    parameter = DataElementGroupField(type=ParameterTwostepTAN4)\n\n\nclass HITANS5(HITANSBase):\n    parameter = DataElementGroupField(type=ParameterTwostepTAN5)\n\n\nclass HITANS6(HITANSBase):\n", "context": "fints/formals.py\nclass ParameterChallengeClass(DataElementGroup):\n    \"\"\"Parameter Challenge-Klasse\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n    parameters = DataElementField(type='an', max_length=999, count=9, required=False)\nfints/formals.py\nclass BankIdentifier(DataElementGroup):\n    COUNTRY_ALPHA_TO_NUMERIC = {\n        # Kapitel E.4 der SEPA-Geschäftsvorfälle\n        'BE': '056',\n        'BG': '100',\n        'DK': '208',\n        'DE': '280',\n        'FI': '246',\n        'FR': '250',\n        'GR': '300',\n        'GB': '826',\n        'IE': '372',\n        'IS': '352',\n        'IT': '380',\n        'JP': '392',\n        'CA': '124',\n        'HR': '191',\n        'LI': '438',\n        'LU': '442',\n        'NL': '528',\n        'AT': '040',\n        'PL': '616',\n        'PT': '620',\n        'RO': '642',\n        'RU': '643',\n        'SE': '752',\n        'CH': '756',\n        'SK': '703',\n        'SI': '705',\n        'ES': '724',\n        'CZ': '203',\n        'TR': '792',\n        'HU': '348',\n        'US': '840',\n        'EU': '978'\n    }\n    COUNTRY_NUMERIC_TO_ALPHA = {v: k for k, v in COUNTRY_ALPHA_TO_NUMERIC.items()}\n    COUNTRY_NUMERIC_TO_ALPHA['276'] = 'DE'  # not yet in use by banks, but defined by ISO\n\n    country_identifier = DataElementField(type='ctr')\n    bank_code = DataElementField(type='an', max_length=30)\nfints/fields.py\nclass CodeField(CodeFieldMixin, AlphanumericField):\n    type = 'code'\n    _DOC_TYPE = str\nfints/formals.py\nclass KTI1(DataElementGroup):\n    \"\"\"Kontoverbindung international, version 1\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Messages -- Multibankfähige Geschäftsvorfälle \"\"\"\n    iban = DataElementField(type='an', max_length=34, required=False, _d=\"IBAN\")\n    bic = DataElementField(type='an', max_length=11, required=False, _d=\"BIC\")\n    account_number = DataElementField(type='id', required=False, _d=\"Konto-/Depotnummer\")\n    subaccount_number = DataElementField(type='id', required=False, _d=\"Unterkontomerkmal\")\n    bank_identifier = DataElementGroupField(type=BankIdentifier, required=False, _d=\"Kreditinstitutskennung\")\n\n    @classmethod\n    def from_sepa_account(cls, acc):\n        return cls(\n            iban=acc.iban,\n            bic=acc.bic,\n        )\nfints/formals.py\nclass TANMediaClass4(RepresentableEnum):\n    \"\"\"TAN-Medium-Klasse, version 4\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    ALL = 'A'  #: Alle Medien\n    LIST = 'L'  #: Liste\n    GENERATOR = 'G'  #: TAN-Generator\n    MOBILE = 'M'  #: Mobiltelefon mit mobileTAN\n    SECODER = 'S'  #: Secoder\n    BILATERAL = 'B'  #: Bilateral vereinbart\nfints/formals.py\nclass ParameterTwostepTAN1(ParameterTwostepCommon):\n    security_profile_bank_signature = DataElementField(type='code', length=1)\n    twostep_parameters = DataElementGroupField(type=TwoStepParameters1, min_count=1, max_count=98)\nfints/formals.py\nclass ParameterTwostepTAN4(ParameterTwostepCommon):\n    twostep_parameters = DataElementGroupField(type=TwoStepParameters4, min_count=1, max_count=98)\nfints/formals.py\nclass TANMedia5(DataElementGroup):\n    \"\"\"TAN-Medium-Liste, version 5\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    tan_medium_class = CodeField(enum=TANMediaClass4, _d=\"TAN-Medium-Klasse\")\n    status = CodeField(enum=TANMediumStatus, _d=\"Status\")\n    security_function = DataElementField(type='num', required=False, _d=\"Sicherheitsfunktion, kodiert\")\n    card_number = DataElementField(type='id', required=False, _d=\"Kartennummer\")\n    card_sequence = DataElementField(type='id', required=False, _d=\"Kartenfolgenummer\")\n    card_type = DataElementField(type='num', required=False, _d=\"Kartenart\")\n    account = DataElementGroupField(type=Account3, required=False, _d=\"Kontonummer Auftraggeber\")\n    valid_from = DataElementField(type='dat', required=False, _d=\"Gültig ab\")\n    valid_until = DataElementField(type='dat', required=False, _d=\"Gültig bis\")\n    tan_list_number = DataElementField(type='an', max_length=20, required=False, _d=\"TAN-Listennummer\")\n    tan_medium_name = DataElementField(type='an', max_length=32, required=False, _d=\"Bezeichnung des TAN-Mediums\")\n    mobile_number_masked = DataElementField(type='an', max_length=35, required=False, _d=\"Mobiltelefonnummer, verschleiert\")\n    mobile_number = DataElementField(type='an', max_length=35, required=False, _d=\"Mobiltelefonnummer\")\n    sms_charge_account = DataElementGroupField(type=KTI1, required=False, _d=\"SMS-Abbuchungskonto\")\n    number_free_tans = DataElementField(type='num', max_length=3, required=False, _d=\"Anzahl freie TANs\")\n    last_use = DataElementField(type='dat', required=False, _d=\"Letzte Benutzung\")\n    active_since = DataElementField(type='dat', required=False, _d=\"Freigeschaltet am\")\nfints/formals.py\nclass ParameterTwostepTAN6(ParameterTwostepCommon):\n    twostep_parameters = DataElementGroupField(type=TwoStepParameters6, min_count=1, max_count=98)\nfints/formals.py\nclass SystemIDStatus(RepresentableEnum):\n    \"\"\"Kundensystem-Status, version 2\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Formals\"\"\"\n    ID_UNNECESSARY = '0'  #: Kundensystem-ID wird nicht benötigt\n    ID_NECESSARY = '1'  #: Kundensystem-ID wird benötigt\nfints/formals.py\nclass ParameterPinTan(DataElementGroup):\n    min_pin_length = DataElementField(type='num', max_length=2, required=False)\n    max_pin_length = DataElementField(type='num', max_length=2, required=False)\n    max_tan_length = DataElementField(type='num', max_length=2, required=False)\n    user_id_field_text = DataElementField(type='an', max_length=30, required=False)\n    customer_id_field_text = DataElementField(type='an', max_length=30, required=False)\n    transaction_tans_required = DataElementGroupField(type=TransactionTanRequired, max_count=999, required=False)\nfints/formals.py\nclass ParameterTwostepTAN2(ParameterTwostepCommon):\n    twostep_parameters = DataElementGroupField(type=TwoStepParameters2, min_count=1, max_count=98)\nfints/fields.py\nclass DataElementField(DocTypeMixin, TypedField):\n    pass\nfints/formals.py\nclass ChallengeValidUntil(DataElementGroup):\n    \"\"\"Gültigkeitsdatum und -uhrzeit für Challenge\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n    date = DataElementField(type='dat', _d=\"Datum\")\n    time = DataElementField(type='tim', _d=\"Uhrzeit\")\nfints/formals.py\nclass TANUsageOption(RepresentableEnum):\n    \"\"\"TAN-Einsatzoption\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    ALL_ACTIVE = '0'  #: Kunde kann alle \"aktiven\" Medien parallel nutzen\n    EXACTLY_ONE = '1'  #: Kunde kann genau ein Medium zu einer Zeit nutzen\n    MOBILE_AND_GENERATOR = '2'  #: Kunde kann ein Mobiltelefon und einen TAN-Generator parallel nutzen\nfints/formals.py\nclass TANMediaClass3(RepresentableEnum):\n    \"\"\"TAN-Medium-Klasse, version 3\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    ALL = 'A'  #: Alle Medien\n    LIST = 'L'  #: Liste\n    GENERATOR = 'G'  #: TAN-Generator\n    MOBILE = 'M'  #: Mobiltelefon mit mobileTAN\n    SECODER = 'S'  #: Secoder\nfints/formals.py\nclass Language2(RepresentableEnum):\n    \"\"\"Dialogsprache\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Formals\"\"\"\n    DEFAULT = '0'  #: Standard\n    DE = '1'  #: Deutsch, 'de', Subset Deutsch, Codeset 1 (Latin 1)\n    EN = '2'  #: Englisch, 'en', Subset Englisch, Codeset 1 (Latin 1)\n    FR = '3'  #: Französisch, 'fr', Subset Französisch, Codeset 1 (Latin 1)\nfints/segments/base.py\nclass FinTS3Segment(Container, SubclassesMixin, metaclass=FinTS3SegmentMeta):\n    header = DataElementGroupField(type=SegmentHeader, _d=\"Segmentkopf\")\n\n    @classproperty\n    def TYPE(cls):\n        match = TYPE_VERSION_RE.match(cls.__name__)\n        if match:\n            return match.group(1)\n\n    @classproperty\n    def VERSION(cls):\n        match = TYPE_VERSION_RE.match(cls.__name__)\n        if match:\n            return int(match.group(2))\n\n    def __init__(self, *args, **kwargs):\n        if 'header' not in kwargs:\n            kwargs['header'] = SegmentHeader(self.TYPE, None, self.VERSION)\n\n        args = (kwargs.pop('header'), ) + args\n\n        super().__init__(*args, **kwargs)\n\n    @classmethod\n    def find_subclass(cls, segment):\n        h = SegmentHeader.naive_parse(segment[0])\n        target_cls = None\n\n        for possible_cls in cls._all_subclasses():\n            if getattr(possible_cls, 'TYPE', None) == h.type and getattr(possible_cls, 'VERSION', None) == h.version:\n                target_cls = possible_cls\n\n        if not target_cls:\n            target_cls = cls\n\n        return target_cls\nfints/formals.py\nclass ParameterTwostepTAN3(ParameterTwostepCommon):\n    twostep_parameters = DataElementGroupField(type=TwoStepParameters3, min_count=1, max_count=98)\nfints/formals.py\nclass ParameterTwostepTAN5(ParameterTwostepCommon):\n    twostep_parameters = DataElementGroupField(type=TwoStepParameters5, min_count=1, max_count=98)\nfints/segments/base.py\nclass ParameterSegment(FinTS3Segment):\n    max_number_tasks = DataElementField(type='num', max_length=3, _d=\"Maximale Anzahl Aufträge\")\n    min_number_signatures = DataElementField(type='num', length=1, _d=\"Anzahl Signaturen mindestens\")\n    security_class = IntCodeField(SecurityClass, length=1, _d=\"Sicherheitsklasse\")\nfints/formals.py\nclass TANMedia4(DataElementGroup):\n    \"\"\"TAN-Medium-Liste, version 4\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    tan_medium_class = CodeField(enum=TANMediaClass3, _d=\"TAN-Medium-Klasse\")\n    status = CodeField(enum=TANMediumStatus, _d=\"Status\")\n    card_number = DataElementField(type='id', required=False, _d=\"Kartennummer\")\n    card_sequence = DataElementField(type='id', required=False, _d=\"Kartenfolgenummer\")\n    card_type = DataElementField(type='num', required=False, _d=\"Kartenart\")\n    account = DataElementGroupField(type=Account3, required=False, _d=\"Kontonummer Auftraggeber\")\n    valid_from = DataElementField(type='dat', required=False, _d=\"Gültig ab\")\n    valid_until = DataElementField(type='dat', required=False, _d=\"Gültig bis\")\n    tan_list_number = DataElementField(type='an', max_length=20, required=False, _d=\"TAN-Listennummer\")\n    tan_medium_name = DataElementField(type='an', max_length=32, required=False, _d=\"Bezeichnung des TAN-Mediums\")\n    mobile_number_masked = DataElementField(type='an', max_length=35, required=False, _d=\"Mobiltelefonnummer, verschleiert\")\n    mobile_number = DataElementField(type='an', max_length=35, required=False, _d=\"Mobiltelefonnummer\")\n    sms_charge_account = DataElementGroupField(type=KTI1, required=False, _d=\"SMS-Abbuchungskonto\")\n    number_free_tans = DataElementField(type='num', max_length=3, required=False, _d=\"Anzahl freie TANs\")\n    last_use = DataElementField(type='dat', required=False, _d=\"Letzte Benutzung\")\n    active_since = DataElementField(type='dat', required=False, _d=\"Freigeschaltet am\")\nfints/formals.py\nclass TANMediaType2(RepresentableEnum):\n    \"\"\"TAN-Medium-Art\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n\n    ALL = '0'  #: Alle\n    ACTIVE = '1'  #: Aktiv\n    AVAILABLE = '2'  #: Verfügbar\nfints/formals.py\nclass ResponseHHDUC(DataElementGroup):\n    \"\"\"Antwort HHD_UC\n\n    Source: FinTS Financial Transaction Services, Schnittstellenspezifikation, Sicherheitsverfahren PIN/TAN\"\"\"\n    atc = DataElementField(type='an', max_length=5, _d=\"ATC\")\n    ac = DataElementField(type='bin', max_length=256, _d=\"Application Cryptogram AC\")\n    ef_id_data = DataElementField(type='bin', max_length=256, _d=\"EF_ID Data\")\n    cvr = DataElementField(type='bin', max_length=256, _d=\"CVR\")\n    version_info_chiptan = DataElementField(type='bin', max_length=256, _d=\"Versionsinfo der chipTAN-Applikation\")\nfints/fields.py\nclass DataElementGroupField(DocTypeMixin, ContainerField):\n    pass\n", "answers": ["    parameter = DataElementGroupField(type=ParameterTwostepTAN6)"], "length": 1364, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "d4a87c94d3c020dfbca0bf801c08cdfc5761894b274f7bd4"}
{"input": "import os\nimport sys\nimport math\nimport argparse\nimport datetime\nimport pytz\nimport json\n    import tkMessageBox as messagebox\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport RMS.ConfigReader as cr\nimport pyximport\n    from tkinter import messagebox\nfrom matplotlib.font_manager import FontProperties\nfrom RMS.Astrometry.ApplyAstrometry import xyToRaDecPP, applyAstrometryFTPdetectinfo\nfrom RMS.Astrometry.Conversions import J2000_JD, datetime2JD, jd2Date, raDec2AltAz\nfrom RMS.Formats.FFfile import filenameToDatetime\nfrom RMS.Formats.FRbin import read as readFR\nfrom RMS.Formats.FRbin import validFRName\nfrom RMS.Formats.FTPdetectinfo import writeFTPdetectinfo\nfrom RMS.Formats.FrameInterface import detectInputType\nfrom RMS.Formats.Platepar import Platepar\nfrom RMS.Misc import openFileDialog\nfrom RMS.Pickling import loadPickle, savePickle\nfrom RMS.Routines import Image\nfrom RMS.Routines import RollingShutterCorrection\nfrom RMS.Astrometry.CyFunctions import equatorialCoordPrecession\n\n\n        if not only_number_update:\n            self.updateImage()\n            self.printStatus()\n\n\n    def setFrame(self, fr_num, only_number_update=False):\n        \"\"\" Set the current frame number.\n\n        Arguments:\n            fr_num: [float] Frame number to set.\n        Keyword arguments:\n            only_number_update: [bool] Just cycle the frame number if True. False by default. This is used\n                when skipping multiple frames.\n        \"\"\"\n\n        if not only_number_update:\n\n            # Compute the intensity sum done on the previous frame\n            self.computeIntensitySum()\n\n\n        # Increment the frame\n        if self.img_handle is not None:\n            self.img_handle.setFrame(fr_num)\n\n            self.current_frame = self.img_handle.current_frame\n\n        else:\n            self.current_frame = fr_num%self.nframes\n\n\n        if not only_number_update:\n            self.updateImage()\n            self.printStatus()\n\n\n    def getRollingShutterCorrectedFrameNo(self, pick):\n        \"\"\" Given a pick object, return rolling shutter corrected (or not, depending on the config) frame\n            number.\n        \"\"\"\n\n        # Correct the rolling shutter effect\n        if self.config.deinterlace_order == -1:\n\n            # Get image height\n            if self.img_handle is None:\n                img_h = self.config.height\n\n            else:\n                img_h = self.img_handle.ff.maxpixel.shape[0]\n\n            # Compute the corrected frame time\n            frame_no = RollingShutterCorrection.correctRollingShutterTemporal(pick.frame, \\\n                pick.y_centroid, img_h)\n\n        # If global shutter, do no correction\n        else:\n            frame_no = pick.frame\n\n\n        return frame_no\n\n\n    def saveState(self):\n        \"\"\" Save the current state of the program to a file, so it can be reloaded. \"\"\"\n\n        state_date_str = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S.%f\")[:-3]\n        state_file = 'manualReduction_{:s}.state'.format(state_date_str)\n\n        # Save the state to a pickle file\n        savePickle(self, self.dir_path, state_file)\n\n        # Write the latest pickle fine\n        savePickle(self, self.dir_path, 'manualReduction_latest.state')\n\n        print('Saved state to file:', state_file)\n\n\n\n    def saveJSON(self):\n        \"\"\" Save the picks in a JSON file. \"\"\"\n\n        # Compute the intensity sum done on the previous frame\n        self.computeIntensitySum()\n\n\n        json_dict = {}\n\n\n        # If the platepar was loaded, save the station info\n        station_dict = {}\n        if self.platepar is not None:\n\n            station_dict['station_id'] = self.platepar.station_code\n            station_dict['lat'] = self.platepar.lat\n            station_dict['lon'] = self.platepar.lon\n            station_dict['elev'] = self.platepar.elev\n\n            station_name = self.platepar.station_code\n\n        else:\n\n            station_dict['station_id'] = self.config.stationID\n            station_dict['lat'] = self.config.latitude\n            station_dict['lon'] = self.config.longitude\n            station_dict['elev'] = self.config.elevation\n\n            station_name = self.station_name\n\n        # Add station data to JSON file\n        json_dict['station'] = station_dict\n\n\n\n        # Save reference time (Julian date)\n        if self.img_handle is not None:\n\n            # Get time from image handle\n", "context": "RMS/Formats/Platepar.py\nclass Platepar(object):\n    def __init__(self, distortion_type=\"poly3+radial\"):\n        \"\"\" Astrometric and photometric calibration plate parameters. Several distortion types are supported.\n\n        Arguments:\n            file_name: [string] Path to the platepar file.\n        Keyword arguments:\n            distortion_type: [str] Distortion type. It can be one of the following:\n                - \"poly3+radial\" - 3rd order polynomial fit including a single radial term\n                - \"poly3+radial3\" - 3rd order polynomial fit including two radial terms (r + r^3)\n                - \"radial3-all\" - 3rd order radial distortion, all powers\n                - \"radial4-all\" - 4rd order radial distortion, all powers\n                - \"radial5-all\" - 5rd order radial distortion, all powers\n                - \"radial3-odd\" - 3rd order radial distortion, only odd powers\n                - \"radial5-odd\" - 5th order radial distortion, only odd powers\n                - \"radial7-odd\" - 7th order radial distortion, only odd powers\n                - \"radial9-odd\" - 7th order radial distortion, only odd powers\n\n        Return:\n            self: [object] Instance of this class with loaded platepar parameters.\n        \"\"\"\n\n        self.version = 2\n\n        # Set the distortion type\n        self.distortion_type = distortion_type\n        self.setDistortionType(self.distortion_type)\n\n\n\n        # Station coordinates\n        self.lat = self.lon = self.elev = 0\n\n        # Reference time and date\n        self.time = 0\n        self.JD = 2451545.0\n\n        # UT correction\n        self.UT_corr = 0\n\n        self.Ho = 0\n        self.X_res = 1280\n        self.Y_res = 720\n\n        self.fov_h = 88\n        self.fov_v = 45\n\n        # FOV centre\n        self.RA_d = 0\n        self.dec_d = 0\n        self.pos_angle_ref = 0\n        self.rotation_from_horiz = 0\n\n        self.az_centre = 0\n        self.alt_centre = 0\n\n        # FOV scale (px/deg)\n        self.F_scale = 1.0\n\n        # Refraction on/off\n        self.refraction = True\n\n        # If the calibration was done without then refraction and points on the sky are measured, then they \n        #   need to be corrected for refraction. WARNING: This should not be used if the distortion model \n        #   itself compensates for the refraction (e.g. the polynomial model)\n        self.measurement_apparent_to_true_refraction = False\n\n        # Equal aspect (X and Y scales are equal) - used ONLY for radial distortion\n        self.equal_aspect = True\n\n        # Force distortion centre to image centre\n        self.force_distortion_centre = False\n\n        # Asymmetry correction - used ONLY for radial distortion\n        self.asymmetry_corr = False\n\n        # Photometry calibration\n        self.mag_0 = -2.5\n        self.mag_lev = 1.0\n        self.mag_lev_stddev = 0.0\n        self.gamma = 1.0\n        self.vignetting_coeff = 0.001\n        self.vignetting_fixed = True\n\n        # Extinction correction scaling\n        self.extinction_scale = 0.6\n\n        self.station_code = \"None\"\n\n        self.star_list = None\n\n        # Flag to indicate that the platepar was refined with CheckFit\n        self.auto_check_fit_refined = False\n\n        # Flag to indicate that the platepar was successfuly auto recalibrated on an individual FF files\n        self.auto_recalibrated = False\n\n        # Init the distortion parameters\n        self.resetDistortionParameters()\n\n\n    def resetDistortionParameters(self, preserve_centre=False):\n        \"\"\" Set the distortion parameters to zero.\n\n        Keyword arguments:\n            preserve_centre: [bool] Don't reset the distortion centre. False by default, in which case it will\n                be reset.\n        \"\"\"\n\n        # Store the distortion centre if it needs to be preserved\n        if preserve_centre:\n\n            # Preserve centre for the radial distortion\n            if self.distortion_type.startswith(\"radial\"):\n\n                # Note that the radial distortion parameters are kept in the X poly array\n                x_centre_fwd, y_centre_fwd = self.x_poly_fwd[0], self.x_poly_fwd[1]\n                x_centre_rev, y_centre_rev = self.x_poly_rev[0], self.x_poly_rev[1]\n\n            else:\n\n                # Preserve centre for the polynomial distortion\n                x_centre_fwd, x_centre_rev = self.x_poly_fwd[0], self.x_poly_rev[0]\n                y_centre_fwd, y_centre_rev = self.y_poly_fwd[0], self.y_poly_rev[0]\n\n\n        # Reset distortion fit (forward and reverse)\n        self.x_poly_fwd = np.zeros(shape=(self.poly_length,), dtype=np.float64)\n        self.y_poly_fwd = np.zeros(shape=(self.poly_length,), dtype=np.float64)\n        self.x_poly_rev = np.zeros(shape=(self.poly_length,), dtype=np.float64)\n        self.y_poly_rev = np.zeros(shape=(self.poly_length,), dtype=np.float64)\n\n\n\n        # Preserve the image centre\n        if preserve_centre:\n\n            # Preserve centre for the radial distortion\n            if self.distortion_type.startswith(\"radial\") and (not self.force_distortion_centre):\n\n                # Note that the radial distortion parameters are kept in the X poly array\n                self.x_poly_fwd[0], self.x_poly_fwd[1] = x_centre_fwd, y_centre_fwd\n                self.x_poly_rev[0], self.x_poly_rev[1] = x_centre_rev, y_centre_rev\n\n            else:\n\n                # Preserve centre for the polynomial distortion\n                self.x_poly_fwd[0], self.x_poly_rev[0] = x_centre_fwd, x_centre_rev\n                self.y_poly_fwd[0], self.y_poly_rev[0] = y_centre_fwd, y_centre_rev\n\n\n        # Reset the image centre\n        else:\n            # Set the first coeffs to 0.5, as that is the real centre of the FOV\n            self.x_poly_fwd[0] = 0.5\n            self.y_poly_fwd[0] = 0.5\n            self.x_poly_rev[0] = 0.5\n            self.y_poly_rev[0] = 0.5\n\n            # If the distortion is radial, set the second X parameter to 0.5, as x_poly[1] is used for the Y\n            #   offset in the radial models\n            if self.distortion_type.startswith(\"radial\"):\n                self.x_poly_fwd[0] /= self.X_res/2\n                self.x_poly_rev[0] /= self.X_res/2\n                self.x_poly_fwd[1] = 0.5/(self.Y_res/2)\n                self.x_poly_rev[1] = 0.5/(self.Y_res/2)\n\n                # If the distortion center is forced to the center of the image, reset all parameters to zero\n                if self.force_distortion_centre:\n                    self.x_poly_fwd *= 0\n                    self.x_poly_rev *= 0\n\n\n\n        self.x_poly = self.x_poly_fwd\n        self.y_poly = self.y_poly_fwd\n\n\n\n    def setDistortionType(self, distortion_type, reset_params=True):\n        \"\"\" Sets the distortion type. \"\"\"\n\n        # List of distortion types\n        self.distortion_type_list = [\n            \"poly3+radial\", \\\n            \"poly3+radial3\", \\\n            \"poly3+radial5\", \\\n            \"radial3-all\", \\\n            \"radial4-all\", \\\n            \"radial5-all\", \\\n            \"radial3-odd\", \\\n            \"radial5-odd\", \\\n            \"radial7-odd\", \\\n            \"radial9-odd\", \\\n            ]\n\n        # Lenghts of full polynomials, (including distortion center, aspect, and asymmetry correction for \n        #   radial distortions)\n        self.distortion_type_poly_length = [\n            12, 13, 14, 7, 8, 9, 6, 7, 8, 9\n        ]\n\n        # Set the length of the distortion polynomial depending on the distortion type\n        if distortion_type in self.distortion_type_list:\n\n            # If the new distortion type (poly vs radial) is different from the old, reset the parameters\n            if (distortion_type[:4] != self.distortion_type[:4]):\n                reset_params = True\n\n            # If the all vs odd only radial powers type is changed, reset the distortion\n            if distortion_type.startswith(\"radial\"):\n                if (distortion_type[-3:] != self.distortion_type[-3:]):\n                    reset_params = True\n\n            \n            self.distortion_type = distortion_type\n\n            # Get the polynomial length\n            self.poly_length = self.distortion_type_poly_length[self.distortion_type_list.index(distortion_type)]\n\n\n            # Remove distortion center for radial distortions if it's not used\n            if distortion_type.startswith(\"radial\"):\n                if self.force_distortion_centre:\n                    self.poly_length -= 2\n\n            # Remove aspect parameter for radial distortions if it's not used\n            if distortion_type.startswith(\"radial\"):\n                if self.equal_aspect:\n                    self.poly_length -= 1\n\n            # Remove asymmetry correction parameters for radial distortions if they are not used\n            if distortion_type.startswith(\"radial\"):\n                if not self.asymmetry_corr:\n                    self.poly_length -= 2\n\n\n\n        else:\n            raise ValueError(\"The distortion type is not recognized: {:s}\".format(self.distortion_type))\n\n\n        # Reset distortion parameters\n        if reset_params:\n            self.resetDistortionParameters()\n\n\n        # Set the correct polynomial size\n        self.padDictParams()\n\n\n    def addVignettingCoeff(self, use_flat):\n        \"\"\" Add a vignetting coeff to the platepar if it doesn't have one.\n\n        Arguments:\n            use_flat: [bool] Is the flat used or not.\n        \"\"\"\n\n        # Add a vignetting coefficient if it's not set\n        if self.vignetting_coeff is None:\n\n            # Only add it if a flat is not used\n            if use_flat:\n                self.vignetting_coeff = 0.0\n\n            else:\n\n                # Use 0.001 rad/px as the default coefficeint, as that's the one for 3.6 mm f/0.95 and 16 mm\n                #   f/1.0 lenses. The vignetting coeff is dependent on the resolution, the default value of\n                #   0.001 rad/px is for 720p.\n                self.vignetting_coeff = 0.001*np.hypot(1280, 720)/np.hypot(self.X_res, self.Y_res)\n\n\n    def fitPointing(self, jd, img_stars, catalog_stars, fixed_scale=False):\n        \"\"\" Fit pointing parameters to the list of star image and celectial catalog coordinates.\n        At least 4 stars are needed to fit the rigid body parameters.\n        \n        New parameters are saved to the given object (self).\n\n        Arguments:\n            jd: [float] Julian date of the image.\n            img_stars: [list] A list of (x, y, intensity_sum) entires for every star.\n            catalog_stars: [list] A list of (ra, dec, mag) entries for every star (degrees).\n\n        Keyword arguments:\n            fixed_scale: [bool] Keep the scale fixed. False by default.\n            \n        \"\"\"\n\n\n        def _calcImageResidualsAstro(params, platepar, jd, catalog_stars, img_stars):\n            \"\"\" Calculates the differences between the stars on the image and catalog stars in image\n                coordinates with the given astrometrical solution.\n            \"\"\"\n\n            # Extract fitting parameters\n            ra_ref, dec_ref, pos_angle_ref = params[:3]\n            if not fixed_scale:\n                F_scale = params[3]\n\n            img_x, img_y, _ = img_stars.T\n\n            pp_copy = copy.deepcopy(platepar)\n\n            # Assign guessed parameters\n            pp_copy.RA_d = ra_ref\n            pp_copy.dec_d = dec_ref\n            pp_copy.pos_angle_ref = pos_angle_ref\n\n            if not fixed_scale:\n                pp_copy.F_scale = abs(F_scale)\n\n\n            # Get image coordinates of catalog stars\n            catalog_x, catalog_y, catalog_mag = getCatalogStarsImagePositions(catalog_stars, jd, pp_copy)\n\n            # Calculate the sum of squared distances between image stars and catalog stars\n            dist_sum = np.sum((catalog_x - img_x)**2 + (catalog_y - img_y)**2)\n\n            return dist_sum\n\n\n        def _calcSkyResidualsAstro(params, platepar, jd, catalog_stars, img_stars):\n            \"\"\" Calculates the differences between the stars on the image and catalog stars in sky\n                coordinates with the given astrometrical solution.\n            \"\"\"\n\n            # Extract fitting parameters\n            ra_ref, dec_ref, pos_angle_ref = params[:3]\n            if not fixed_scale:\n                F_scale = params[3]\n\n            img_x, img_y, _ = img_stars.T\n\n            pp_copy = copy.deepcopy(platepar)\n\n            # Assign guessed parameters\n            pp_copy.RA_d = ra_ref\n            pp_copy.dec_d = dec_ref\n            pp_copy.pos_angle_ref = pos_angle_ref\n\n            if not fixed_scale:\n                pp_copy.F_scale = abs(F_scale)\n\n                \n\n            img_x, img_y, _ = img_stars.T\n\n            # Get image coordinates of catalog stars\n            ra_array, dec_array = getPairedStarsSkyPositions(img_x, img_y, jd, pp_copy)\n\n            ra_catalog, dec_catalog, _ = catalog_stars.T\n\n            # Compute the sum of the angular separation\n            separation_sum = np.sum(angularSeparation(np.radians(ra_array), np.radians(dec_array), \\\n                np.radians(ra_catalog), np.radians(dec_catalog))**2)\n\n\n            return separation_sum\n\n\n        # Initial parameters for the astrometric fit\n        p0 = [self.RA_d, self.dec_d, self.pos_angle_ref]\n\n        # Add fitting scale if not fixed\n        if not fixed_scale:\n            p0 += [abs(self.F_scale)]\n\n\n        # Fit the astrometric parameters using the reverse transform for reference        \n        res = scipy.optimize.minimize(_calcImageResidualsAstro, p0, \\\n            args=(self, jd, catalog_stars, img_stars), method='SLSQP')\n\n        # # Fit the astrometric parameters using the forward transform for reference\n        #   WARNING: USING THIS MAKES THE FIT UNSTABLE\n        # res = scipy.optimize.minimize(_calcSkyResidualsAstro, p0, args=(self, jd, \\\n        #     catalog_stars, img_stars), method='Nelder-Mead')\n\n        # Update fitted astrometric parameters\n        self.RA_d, self.dec_d, self.pos_angle_ref = res.x[:3]\n        if not fixed_scale:\n            self.F_scale = res.x[3]\n\n\n        # Force scale to be positive\n        self.F_scale = abs(self.F_scale)\n        \n        \n        # Update alt/az of pointing\n        self.updateRefAltAz()\n\n\n\n\n    def fitAstrometry(self, jd, img_stars, catalog_stars, first_platepar_fit=False, fit_only_pointing=False,\n        fixed_scale=False):\n        \"\"\" Fit astrometric parameters to the list of star image and celectial catalog coordinates.\n        At least 4 stars are needed to fit the rigid body parameters.\n        \n        New parameters are saved to the given object (self).\n\n        Arguments:\n            jd: [float] Julian date of the image.\n            img_stars: [list] A list of (x, y, intensity_sum) entires for every star.\n            catalog_stars: [list] A list of (ra, dec, mag) entries for every star (degrees).\n\n        Keyword arguments:\n            first_platepar_fit: [bool] Fit a platepar from scratch. False by default.\n            fit_only_pointing: [bool] Only fit the pointing parameters, and not distortion.\n            fixed_scale: [bool] Keep the scale fixed. False by default.\n\n        \"\"\"\n\n\n\n        def _calcImageResidualsDistortion(params, platepar, jd, catalog_stars, img_stars, dimension):\n            \"\"\" Calculates the differences between the stars on the image and catalog stars in image\n                coordinates with the given astrometrical solution.\n            Arguments:\n                ...\n                dimension: [str] 'x' for X polynomial fit, 'y' for Y polynomial fit\n            \"\"\"\n\n            # Set distortion parameters\n            pp_copy = copy.deepcopy(platepar)\n\n            if (dimension == 'x') or (dimension == 'radial'):\n                pp_copy.x_poly_rev = params\n                pp_copy.y_poly_rev = np.zeros(platepar.poly_length)\n\n            else:\n                pp_copy.x_poly_rev = np.zeros(platepar.poly_length)\n                pp_copy.y_poly_rev = params\n\n\n            img_x, img_y, _ = img_stars.T\n\n\n            # Get image coordinates of catalog stars\n            catalog_x, catalog_y, catalog_mag = getCatalogStarsImagePositions(catalog_stars, jd, pp_copy)\n\n\n            # Calculate the sum of squared distances between image stars and catalog stars, per every\n            #   dimension\n            if dimension == 'x':\n                dist_sum = np.sum((catalog_x - img_x)**2)\n\n            elif dimension == 'y':\n                dist_sum = np.sum((catalog_y - img_y)**2)\n\n            # Minimization for the radial distortion\n            else:\n\n                # Compute the image fit error\n                dist_sum = np.sum((catalog_x - img_x)**2 + (catalog_y - img_y)**2)\n\n\n            return dist_sum\n\n\n        # Modify the residuals function so that it takes a list of arguments\n        def _calcImageResidualsDistortionListArguments(params, *args, **kwargs):\n            return [_calcImageResidualsDistortion(param_line, *args, **kwargs) for param_line in params]\n\n\n        def _calcSkyResidualsDistortion(params, platepar, jd, catalog_stars, img_stars, dimension):\n            \"\"\" Calculates the differences between the stars on the image and catalog stars in sky\n                coordinates with the given astrometrical solution.\n            Arguments:\n                ...\n                dimension: [str] 'x' for X polynomial fit, 'y' for Y polynomial fit\n            \"\"\"\n\n            pp_copy = copy.deepcopy(platepar)\n\n            if (dimension == 'x') or (dimension == 'radial'):\n                pp_copy.x_poly_fwd = params\n\n            else:\n                pp_copy.y_poly_fwd = params\n\n\n            img_x, img_y, _ = img_stars.T\n\n            # Get image coordinates of catalog stars\n            ra_array, dec_array = getPairedStarsSkyPositions(img_x, img_y, jd, pp_copy)\n\n            ra_catalog, dec_catalog, _ = catalog_stars.T\n\n            # Compute the sum of the angular separation\n            separation_sum = np.sum(angularSeparation(np.radians(ra_array), np.radians(dec_array), \\\n                np.radians(ra_catalog), np.radians(dec_catalog))**2)\n\n            return separation_sum\n\n\n        # Modify the residuals function so that it takes a list of arguments\n        def _calcSkyResidualsDistortionListArguments(params, *args, **kwargs):\n            return [_calcSkyResidualsDistortion(param_line, *args, **kwargs) for param_line in params]\n\n\n\n        def _calcImageResidualsAstroAndDistortionRadial(params, platepar, jd, catalog_stars, img_stars):\n            \"\"\" Calculates the differences between the stars on the image and catalog stars in image\n                coordinates with the given astrometrical solution. Pointing and distortion paramters are used\n                in the fit.\n\n            Arguments:\n                ...\n                dimension: [str] 'x' for X polynomial fit, 'y' for Y polynomial fit\n            \"\"\"\n\n            # Set distortion parameters\n            pp_copy = copy.deepcopy(platepar)\n\n            \n            # Unpack pointing parameters and assign to the copy of platepar used for the fit\n            ra_ref, dec_ref, pos_angle_ref, F_scale = params[:4]\n\n            pp_copy = copy.deepcopy(platepar)\n\n            # Unnormalize the pointing parameters\n            pp_copy.RA_d = (360*ra_ref)%(360)\n            pp_copy.dec_d = -90 + (90*dec_ref + 90)%(180.000001)\n            pp_copy.pos_angle_ref = (360*pos_angle_ref)%(360)\n            pp_copy.F_scale = abs(F_scale)\n\n\n            # Assign distortion parameters\n            pp_copy.x_poly_rev = params[4:]\n\n\n            img_x, img_y, _ = img_stars.T\n\n            # Get image coordinates of catalog stars\n            catalog_x, catalog_y, catalog_mag = getCatalogStarsImagePositions(catalog_stars, jd, pp_copy)\n\n\n            # Calculate the sum of squared distances between image stars and catalog stars\n            dist_sum = np.sum((catalog_x - img_x)**2 + (catalog_y - img_y)**2)\n\n\n            return dist_sum\n\n\n        def _calcSkyResidualsAstroAndDistortionRadial(params, platepar, jd, catalog_stars, img_stars):\n            \"\"\" Calculates the differences between the stars on the image and catalog stars in celestial\n                coordinates with the given astrometrical solution. Pointing and distortion paramters are used\n                in the fit.\n    \n            \"\"\"\n\n            # Set distortion parameters\n            pp_copy = copy.deepcopy(platepar)\n\n            \n            # Unpack pointing parameters and assign to the copy of platepar used for the fit\n            ra_ref, dec_ref, pos_angle_ref, F_scale = params[:4]\n\n            pp_copy = copy.deepcopy(platepar)\n\n            # Unnormalize the pointing parameters\n            pp_copy.RA_d = (360*ra_ref)%(360)\n            pp_copy.dec_d = -90 + (90*dec_ref + 90)%(180.000001)\n            pp_copy.pos_angle_ref = (360*pos_angle_ref)%(360)\n            pp_copy.F_scale = abs(F_scale)\n\n\n            # Assign distortion parameters\n            pp_copy.x_poly_fwd = params[4:]\n\n\n            img_x, img_y, _ = img_stars.T\n\n            # Get image coordinates of catalog stars\n            ra_array, dec_array = getPairedStarsSkyPositions(img_x, img_y, jd, pp_copy)\n\n            ra_catalog, dec_catalog, _ = catalog_stars.T\n\n            # Compute the sum of the angular separation\n            separation_sum = np.sum(angularSeparation(np.radians(ra_array), np.radians(dec_array), \\\n                np.radians(ra_catalog), np.radians(dec_catalog))**2)\n\n\n            return separation_sum\n\n\n        # print('ASTRO', _calcImageResidualsAstro([self.RA_d, self.dec_d,\n        #     self.pos_angle_ref, self.F_scale],  catalog_stars, img_stars))\n\n        # print('DIS_X', _calcImageResidualsDistortion(self.x_poly_rev,  catalog_stars, \\\n        #     img_stars, 'x'))\n\n        # print('DIS_Y', _calcImageResidualsDistortion(self.y_poly_rev,  catalog_stars, \\\n        #     img_stars, 'y'))\n\n\n\n        ### ASTROMETRIC PARAMETERS FIT ###\n\n        # Fit the pointing parameters (RA, Dec, rotation, scale)\n        #   Only do the fit for the polynomial distortion model, or the first time if the radial distortion\n        #   is used\n        if self.distortion_type.startswith(\"poly\") \\\n            or (not self.distortion_type.startswith(\"poly\") and first_platepar_fit) or fit_only_pointing:\n\n            self.fitPointing(jd, img_stars, catalog_stars, fixed_scale=fixed_scale)\n\n        ### ###\n\n\n\n        ### DISTORTION FIT ###\n\n        # Fit the polynomial distortion parameters if there are enough picked stars\n        min_fit_stars = self.poly_length + 1\n\n        if (len(img_stars) >= min_fit_stars) and (not fit_only_pointing):\n\n            # Fit the polynomial distortion\n            if self.distortion_type.startswith(\"poly\"):\n\n\n                ### REVERSE MAPPING FIT ###\n\n                # Fit distortion parameters in X direction, reverse mapping\n                res = scipy.optimize.minimize(_calcImageResidualsDistortion, self.x_poly_rev, \\\n                    args=(self, jd, catalog_stars, img_stars, 'x'), method='Nelder-Mead', \\\n                    options={'maxiter': 10000, 'adaptive': True})\n\n                # Exctact fitted X polynomial\n                self.x_poly_rev = res.x\n\n                # Fit distortion parameters in Y direction, reverse mapping\n                res = scipy.optimize.minimize(_calcImageResidualsDistortion, self.y_poly_rev, \\\n                    args=(self, jd, catalog_stars, img_stars, 'y'), method='Nelder-Mead', \\\n                    options={'maxiter': 10000, 'adaptive': True})\n\n                # Extract fitted Y polynomial\n                self.y_poly_rev = res.x\n\n\n                ### ###\n\n\n                # If this is the first fit of the distortion, set the forward parametrs to be equal to the reverse\n                if first_platepar_fit:\n\n                    self.x_poly_fwd = np.array(self.x_poly_rev)\n                    self.y_poly_fwd = np.array(self.y_poly_rev)\n\n\n\n                ### FORWARD MAPPING FIT ###\n\n                # Fit distortion parameters in X direction, forward mapping\n                res = scipy.optimize.minimize(_calcSkyResidualsDistortion, self.x_poly_fwd, \\\n                    args=(self, jd, catalog_stars, img_stars, 'x'), method='Nelder-Mead', \\\n                    options={'maxiter': 10000, 'adaptive': True})\n\n                # Extract fitted X polynomial\n                self.x_poly_fwd = res.x\n\n\n                # Fit distortion parameters in Y direction, forward mapping\n                res = scipy.optimize.minimize(_calcSkyResidualsDistortion, self.y_poly_fwd, \\\n                    args=(self, jd, catalog_stars, img_stars, 'y'), method='Nelder-Mead', \\\n                    options={'maxiter': 10000, 'adaptive': True})\n\n                # IMPORTANT NOTE - the X polynomial is used to store the fit paramters\n                self.y_poly_fwd = res.x\n\n\n                ### ###\n\n\n            # Fit radial distortion (+ pointing)\n            else:\n\n\n                ### FORWARD MAPPING FIT ###\n\n\n                # # Fit the radial distortion - the X polynomial is used to store the fit paramters\n                # res = scipy.optimize.minimize(_calcSkyResidualsDistortion, self.x_poly_fwd, \\\n                #     args=(self, jd, catalog_stars, img_stars, 'radial'), method='Nelder-Mead', \\\n                #     options={'maxiter': 10000, 'adaptive': True})\n\n\n                # # Extract distortion parameters, IMPORTANT NOTE - the X polynomial is used to store the \n                # #   fit paramters\n                # self.x_poly_fwd = res.x\n\n\n\n                # Fitting the pointing direction below! - if used, it should be put BEFORE the reverse fit!\n                # Initial parameters for the pointing and distortion fit (normalize to the 0-1 range)\n                p0  = [self.RA_d/360, self.dec_d/90, self.pos_angle_ref/360, abs(self.F_scale)]\n                p0 += self.x_poly_fwd.tolist()\n\n                # Fit the radial distortion - the X polynomial is used to store the fit paramters\n                res = scipy.optimize.minimize(_calcSkyResidualsAstroAndDistortionRadial, p0, \\\n                    args=(self, jd, catalog_stars, img_stars), method='Nelder-Mead', \\\n                    options={'maxiter': 10000, 'adaptive': True})\n\n                # Update fitted astrometric parameters (Unnormalize the pointing parameters)\n                ra_ref, dec_ref, pos_angle_ref, F_scale = res.x[:4]\n                self.RA_d = (360*ra_ref)%(360)\n                self.dec_d = -90 + (90*dec_ref + 90)%(180.000001)\n                self.pos_angle_ref = (360*pos_angle_ref)%(360)\n                self.F_scale = abs(F_scale)\n\n                self.updateRefAltAz()\n\n\n                # Extract distortion parameters, IMPORTANT NOTE - the X polynomial is used to store the \n                #   fit paramters\n                self.x_poly_fwd = res.x[4:]\n\n                ### ###\n\n\n                # If this is the first fit of the distortion, set the forward parametrs to be equal to the reverse\n                if first_platepar_fit:\n                    self.x_poly_rev = np.array(self.x_poly_fwd)\n\n\n                ### REVERSE MAPPING FIT ###\n\n\n                # # Initial parameters for the pointing and distortion fit (normalize to the 0-1 range)\n                # p0  = [self.RA_d/360.0, self.dec_d/90.0, self.pos_angle_ref/360.0, abs(self.F_scale)]\n                # p0 += self.x_poly_rev.tolist()\n\n\n                # # Fit the radial distortion - the X polynomial is used to store the fit paramters\n                # res = scipy.optimize.minimize(_calcImageResidualsAstroAndDistortionRadial, p0, \\\n                #     args=(self, jd, catalog_stars, img_stars), method='Nelder-Mead', \\\n                #     options={'maxiter': 10000, 'adaptive': True})\n\n\n                # # Update fitted astrometric parameters (Unnormalize the pointing parameters)\n                # ra_ref, dec_ref, pos_angle_ref, F_scale = res.x[:4]\n                # self.RA_d = (360*ra_ref)%(360)\n                # self.dec_d = -90 + (90*dec_ref + 90)%(180.000001)\n                # self.pos_angle_ref = (360*pos_angle_ref)%(360)\n                # self.F_scale = abs(F_scale)\n\n                # # Compute reference Alt/Az to apparent coordinates, epoch of date\n                # self.updateRefAltAz()\n\n\n                # # Extract distortion parameters, IMPORTANT NOTE - the X polynomial is used to store the \n                # #   fit paramters\n                # self.x_poly_rev = res.x[4:]\n\n\n\n                ## Distortion-only fit below!\n\n                # Fit the radial distortion - the X polynomial is used to store the fit paramters\n                res = scipy.optimize.minimize(_calcImageResidualsDistortion, self.x_poly_rev, \\\n                    args=(self, jd, catalog_stars, img_stars, 'radial'), method='Nelder-Mead', \\\n                    options={'maxiter': 10000, 'adaptive': True})\n\n\n                # Extract distortion parameters, IMPORTANT NOTE - the X polynomial is used to store the \n                #   fit paramters\n                self.x_poly_rev = res.x\n\n\n                ### ###\n\n\n\n\n        else:\n            if (len(img_stars) < min_fit_stars):\n                print('Too few stars to fit the distortion, only the astrometric parameters where fitted!')\n\n\n        # Set the list of stars used for the fit to the platepar\n        fit_star_list = []\n        for img_coords, cat_coords in zip(img_stars, catalog_stars):\n\n            # Store time, image coordinate x, y, intensity, catalog ra, dec, mag\n            fit_star_list.append([jd] + img_coords.tolist() + cat_coords.tolist())\n\n\n        self.star_list = fit_star_list\n\n\n        # Set the flag to indicate that the platepar was manually fitted\n        self.auto_check_fit_refined = False\n        self.auto_recalibrated = False\n\n        ### ###\n\n\n    def parseLine(self, f):\n        \"\"\" Read next line, split the line and convert parameters to float.\n        @param f: [file handle] file we want to read\n        @return (a1, a2, ...): [tuple of floats] parsed data from the line\n        \"\"\"\n\n        return map(float, f.readline().split())\n\n\n    def padDictParams(self):\n        \"\"\" Update the array length if an old platepar version was loaded which was shorter/longer. \"\"\"\n\n        # Extend the array if it's too short\n        if self.x_poly_fwd.shape[0] < self.poly_length:\n            self.x_poly_fwd = np.pad(self.x_poly_fwd, (0, self.poly_length - self.x_poly_fwd.shape[0]), \\\n                'constant', constant_values=0)\n            self.x_poly_rev = np.pad(self.x_poly_rev, (0, self.poly_length - self.x_poly_rev.shape[0]), \\\n                'constant', constant_values=0)\n            self.y_poly_fwd = np.pad(self.y_poly_fwd, (0, self.poly_length - self.y_poly_fwd.shape[0]), \\\n                'constant', constant_values=0)\n            self.y_poly_rev = np.pad(self.y_poly_rev, (0, self.poly_length - self.y_poly_rev.shape[0]), \\\n                'constant', constant_values=0)\n\n\n        # Cut the array if it's too long\n        if self.x_poly_fwd.shape[0] > self.poly_length:\n            self.x_poly_fwd = self.x_poly_fwd[:self.poly_length]\n            self.x_poly_rev = self.x_poly_rev[:self.poly_length]\n            self.y_poly_fwd = self.y_poly_fwd[:self.poly_length]\n            self.y_poly_rev = self.y_poly_rev[:self.poly_length]\n\n\n    def loadFromDict(self, platepar_dict, use_flat=None):\n        \"\"\" Load the platepar from a dictionary. \"\"\"\n\n        # Parse JSON into an object with attributes corresponding to dict keys\n        self.__dict__ = platepar_dict\n\n        # Add the version if it was not in the platepar (v1 platepars didn't have a version)\n        if not 'version' in self.__dict__:\n            self.version = 1\n\n\n        # If the refraction was not used for the fit, assume it is disabled\n        if not 'refraction' in self.__dict__:\n            self.refraction = False\n\n\n        # If the measurement correction for refraction (if it was not taken into account during calibration)\n        #   is not present, assume it's false\n        if not 'measurement_apparent_to_true_refraction' in self.__dict__:\n            self.measurement_apparent_to_true_refraction = False\n\n\n        # Add equal aspect\n        if not 'equal_aspect' in self.__dict__:\n            self.equal_aspect = False\n\n\n        # Add asymmetry correction\n        if not 'asymmetry_corr' in self.__dict__:\n            self.asymmetry_corr = False\n\n\n        # Add forcing distortion centre to image center\n        if not 'force_distortion_centre' in self.__dict__:\n            self.force_distortion_centre = False\n\n\n        # Add the distortion type if not present (assume it's the polynomal type with the radial term)\n        if not 'distortion_type' in self.__dict__:\n\n            # Check if the variable with the typo was used and correct it\n            if 'distortion_type' in self.__dict__:\n                self.distortion_type = self.distortion_type\n                del self.distortion_type\n\n            # Otherwise, assume the polynomial type\n            else:\n                self.distortion_type = \"poly3+radial\"\n\n        # Add UT correction if it was not in the platepar\n        if not 'UT_corr' in self.__dict__:\n            self.UT_corr = 0\n\n        # Add the gamma if it was not in the platepar\n        if not 'gamma' in self.__dict__:\n            self.gamma = 1.0\n\n        # Add the vignetting coefficient if it was not in the platepar\n        if not 'vignetting_coeff' in self.__dict__:\n            self.vignetting_coeff = None\n\n            # Add the default vignetting coeff\n            self.addVignettingCoeff(use_flat=use_flat)\n\n        # Add keeping the vignetting coefficient fixed\n        if not 'vignetting_fixed' in self.__dict__:\n            self.vignetting_fixed = False\n\n        # Add extinction scale\n        if not 'extinction_scale' in self.__dict__:\n            self.extinction_scale = 1.0\n\n        # Add the list of calibration stars if it was not in the platepar\n        if not 'star_list' in self.__dict__:\n            self.star_list = []\n\n        # If v1 only the backward distortion coeffs were fitted, so use load them for both forward and\n        #   reverse if nothing else is available\n        if not 'x_poly_fwd' in self.__dict__:\n\n            self.x_poly_fwd = np.array(self.x_poly)\n            self.x_poly_rev = np.array(self.x_poly)\n            self.y_poly_fwd = np.array(self.y_poly)\n            self.y_poly_rev = np.array(self.y_poly)\n\n\n        # Convert lists to numpy arrays\n        self.x_poly_fwd = np.array(self.x_poly_fwd)\n        self.x_poly_rev = np.array(self.x_poly_rev)\n        self.y_poly_fwd = np.array(self.y_poly_fwd)\n        self.y_poly_rev = np.array(self.y_poly_rev)\n\n\n        # Set the distortion type\n        self.setDistortionType(self.distortion_type, reset_params=False)\n\n\n        # Set polynomial parameters used by the old code\n        self.x_poly = self.x_poly_fwd\n        self.y_poly = self.y_poly_fwd\n\n\n        # Add rotation from horizontal\n        if not 'rotation_from_horiz' in self.__dict__:\n            self.rotation_from_horiz = RMS.Astrometry.ApplyAstrometry.rotationWrtHorizon(self)\n\n        # Calculate the datetime\n        self.time = jd2Date(self.JD, dt_obj=True)\n\n\n\n\n    def read(self, file_name, fmt=None, use_flat=None):\n        \"\"\" Read the platepar.\n\n        Arguments:\n            file_name: [str] Path and the name of the platepar to read.\n        Keyword arguments:\n            fmt: [str] Format of the platepar file. 'json' for JSON format and 'txt' for the usual CMN textual\n                format.\n            use_flat: [bool] Indicates wheter a flat is used or not. None by default.\n        Return:\n            fmt: [str]\n        \"\"\"\n\n\n        # Check if platepar exists\n        if not os.path.isfile(file_name):\n            return False\n\n\n        # Determine the type of the platepar if it is not given\n        if fmt is None:\n\n            with open(file_name) as f:\n                data = \" \".join(f.readlines())\n\n                # Try parsing the file as JSON\n                try:\n                    json.loads(data)\n                    fmt = 'json'\n\n                except:\n                    fmt = 'txt'\n\n\n        # Load the file as JSON\n        if fmt == 'json':\n\n            # Load the JSON file\n            with open(file_name) as f:\n                data = \" \".join(f.readlines())\n\n            # Load the platepar from the JSON dictionary\n            self.loadFromDict(json.loads(data), use_flat=use_flat)\n\n\n\n\n        # Load the file as TXT (old CMN format)\n        else:\n\n            with open(file_name) as f:\n\n                self.UT_corr = 0\n                self.gamma = 1.0\n                self.star_list = []\n\n                # Parse latitude, longitude, elevation\n                self.lon, self.lat, self.elev = self.parseLine(f)\n\n                # Parse date and time as int\n                D, M, Y, h, m, s = map(int, f.readline().split())\n\n                # Calculate the datetime of the platepar time\n                self.time = datetime.datetime(Y, M, D, h, m, s)\n\n                # Convert time to JD\n                self.JD = date2JD(Y, M, D, h, m, s)\n\n                # Calculate the reference hour angle\n                T = (self.JD - 2451545.0)/36525.0\n                self.Ho = (280.46061837 + 360.98564736629*(self.JD - 2451545.0) + 0.000387933*T**2 - \\\n                    T**3/38710000.0)%360\n\n                # Parse camera parameters\n                self.X_res, self.Y_res, self.focal_length = self.parseLine(f)\n\n                # Parse the right ascension of the image centre\n                self.RA_d, self.RA_H, self.RA_M, self.RA_S = self.parseLine(f)\n\n                # Parse the declination of the image centre\n                self.dec_d, self.dec_D, self.dec_M, self.dec_S = self.parseLine(f)\n\n                # Parse the rotation parameter\n                self.pos_angle_ref = self.parseLine(f)[0]\n\n                # Parse the image scale (convert from arcsec/px to px/deg)\n                self.F_scale = self.parseLine(f)[0]\n                self.F_scale = 3600/self.F_scale\n\n                # Load magnitude slope parameters\n                self.mag_0, self.mag_lev = self.parseLine(f)\n\n                # Load X axis polynomial parameters\n                self.x_poly_fwd = self.x_poly_rev = np.zeros(shape=(self.poly_length,), dtype=np.float64)\n                for i in range(self.poly_length):\n                    self.x_poly_fwd[i] = self.x_poly_fwd[i] = self.parseLine(f)[0]\n\n                # Load Y axis polynomial parameters\n                self.y_poly_fwd = self.y_poly_rev = np.zeros(shape=(self.poly_length,), dtype=np.float64)\n                for i in range(self.poly_length):\n                    self.y_poly_fwd[i] = self.y_poly_rev[i] = self.parseLine(f)[0]\n\n                # Read station code\n                self.station_code = f.readline().replace('\\r', '').replace('\\n', '')\n\n\n        # Add a default vignetting coefficient if it already doesn't exist\n        self.addVignettingCoeff(use_flat)\n\n        return fmt\n\n\n    def jsonStr(self):\n        \"\"\" Returns the JSON representation of the platepar as a string. \"\"\"\n\n        # Make a copy of the platepar object, which will be modified for writing\n        self2 = copy.deepcopy(self)\n\n        # Convert numpy arrays to list, which can be serialized\n        self2.x_poly_fwd = self.x_poly_fwd.tolist()\n        self2.x_poly_rev = self.x_poly_rev.tolist()\n        self2.y_poly_fwd = self.y_poly_fwd.tolist()\n        self2.y_poly_rev = self.y_poly_rev.tolist()\n        del self2.time\n\n        # For compatibility with old procedures, write the forward distortion parameters as x, y\n        self2.x_poly = self.x_poly_fwd.tolist()\n        self2.y_poly = self.y_poly_fwd.tolist()\n\n        out_str = json.dumps(self2, default=lambda o: o.__dict__, indent=4, sort_keys=True)\n\n        return out_str\n\n\n    def write(self, file_path, fmt=None, fov=None, ret_written=False):\n        \"\"\" Write platepar to file.\n\n        Arguments:\n            file_path: [str] Path and the name of the platepar to write.\n        Keyword arguments:\n            fmt: [str] Format of the platepar file. 'json' for JSON format and 'txt' for the usual CMN textual\n                format. The format is JSON by default.\n            fov: [tuple] Tuple of horizontal and vertical FOV size in degree. None by default.\n            ret_written: [bool] If True, the JSON string of the platepar instead of writing it to disk.\n        Return:\n            fmt: [str] Platepar format.\n        \"\"\"\n\n        # If the FOV size was given, store it\n        if fov is not None:\n            self.fov_h, self.fov_v = fov\n\n\n        # Set JSON to be the defualt format\n        if fmt is None:\n            fmt = 'json'\n\n\n        # If the format is JSON, write a JSON file\n        if fmt == 'json':\n\n            out_str = self.jsonStr()\n\n            with open(file_path, 'w') as f:\n                f.write(out_str)\n\n            if ret_written:\n                return fmt, out_str\n\n\n        # Old CMN format\n        else:\n\n            with open(file_path, 'w') as f:\n\n                # Write geo coords\n                f.write('{:9.6f} {:9.6f} {:04d}\\n'.format(self.lon, self.lat, int(self.elev)))\n\n                # Calculate reference time from reference JD\n                Y, M, D, h, m, s, ms = list(map(int, jd2Date(self.JD)))\n\n                # Write the reference time\n                f.write('{:02d} {:02d} {:04d} {:02d} {:02d} {:02d}\\n'.format(D, M, Y, h, m, s))\n\n                # Write resolution and focal length\n                f.write('{:d} {:d} {:f}\\n'.format(int(self.X_res), int(self.Y_res), self.focal_length))\n\n                # Write reference RA\n                self.RA_H = int(self.RA_d/15)\n                self.RA_M = int((self.RA_d/15 - self.RA_H)*60)\n                self.RA_S = int(((self.RA_d/15 - self.RA_H)*60 - self.RA_M)*60)\n\n                f.write(\"{:7.3f} {:02d} {:02d} {:02d}\\n\".format(self.RA_d, self.RA_H, self.RA_M, self.RA_S))\n\n                # Write reference Dec\n                self.dec_D = int(self.dec_d)\n                self.dec_M = int((self.dec_d - self.dec_D)*60)\n                self.dec_S = int(((self.dec_d - self.dec_D)*60 - self.dec_M)*60)\n\n                f.write(\"{:+7.3f} {:02d} {:02d} {:02d}\\n\".format(self.dec_d, self.dec_D, self.dec_M, self.dec_S))\n\n                # Write rotation parameter\n                f.write('{:<7.3f}\\n'.format(self.pos_angle_ref))\n\n                # Write F scale\n                f.write('{:<5.1f}\\n'.format(3600/self.F_scale))\n\n                # Write magnitude fit\n                f.write(\"{:.3f} {:.3f}\\n\".format(self.mag_0, self.mag_lev))\n\n                # Write X distortion polynomial\n                for x_elem in self.x_poly_fwd:\n                    f.write('{:+E}\\n'.format(x_elem))\n\n                # Write y distortion polynomial\n                for y_elem in self.y_poly_fwd:\n                    f.write('{:+E}\\n'.format(y_elem))\n\n                # Write station code\n                f.write(str(self.station_code) + '\\n')\n\n            if ret_written:\n                with open(file_path) as f:\n                    out_str = \"\\n\".join(f.readlines())\n\n                return fmt, out_str\n\n\n        return fmt\n\n\n    def updateRefAltAz(self):\n        \"\"\" Update the reference apparent azimuth and altitude from the reference RA and Dec. \"\"\"\n\n        # Compute reference Alt/Az to apparent coordinates, epoch of date\n        az_centre, alt_centre = cyTrueRaDec2ApparentAltAz( \\\n            np.radians(self.RA_d), np.radians(self.dec_d), self.JD, \\\n            np.radians(self.lat), np.radians(self.lon), self.refraction)\n        self.az_centre, self.alt_centre = np.degrees(az_centre), np.degrees(alt_centre)\n\n        # Update the rotation wrt horizon\n        self.rotation_from_horiz = RMS.Astrometry.ApplyAstrometry.rotationWrtHorizon(self)\n\n\n    def updateRefRADec(self, skip_rot_update=False, preserve_rotation=False):\n        \"\"\" Update the reference RA and Dec (true in J2000) from Alt/Az (apparent in epoch of date). \"\"\"\n\n        if (not skip_rot_update) and (not preserve_rotation):\n\n            # Save the current rotation w.r.t horizon value\n            self.rotation_from_horiz = RMS.Astrometry.ApplyAstrometry.rotationWrtHorizon(self)\n\n\n        # Convert the reference apparent Alt/Az in the epoch of date to true RA/Dec in J2000\n        ra, dec = cyApparentAltAz2TrueRADec(\\\n            np.radians(self.az_centre), np.radians(self.alt_centre), self.JD, \\\n            np.radians(self.lat), np.radians(self.lon), self.refraction)\n\n\n        # Assign the computed RA/Dec to platepar\n        self.RA_d = np.degrees(ra)\n        self.dec_d = np.degrees(dec)\n\n\n        if not skip_rot_update:\n\n            # Update the position angle so that the rotation wrt horizon doesn't change\n            self.pos_angle_ref = RMS.Astrometry.ApplyAstrometry.rotationWrtHorizonToPosAngle(self, \\\n                self.rotation_from_horiz)\n\n\n    def switchToGroundPicks(self):\n        \"\"\" Switch the reference pointing so that points on the ground may be correctly measured. \"\"\"\n\n        # If the refraction was on, turn if off and correct the centre\n        if self.refraction:\n            \n            self.refraction = False\n\n            # Preserve the reference elevation of the pointing as the apparent pointing\n            # self.alt_centre = np.degrees(pyRefractionTrueToApparent(np.radians(self.alt_centre)))\n\n            self.updateRefRADec(preserve_rotation=True)\n\n\n\n    def __repr__(self):\n\n        # Compute alt/az pointing\n        azim, elev = trueRaDec2ApparentAltAz(self.RA_d, self.dec_d, self.JD, self.lat, self.lon, \\\n            refraction=self.refraction)\n\n        out_str  = \"Platepar\\n\"\n        out_str += \"--------\\n\"\n        out_str += \"Camera info:\\n\"\n        out_str += \"    Lat (+N)  = {:+11.6f} deg\\n\".format(self.lat)\n        out_str += \"    Lon (+E)  = {:+11.6f} deg\\n\".format(self.lon)\n        out_str += \"    Ele (MSL) = {:11.2f} m\\n\".format(self.elev)\n        out_str += \"    FOV       = {:6.2f} x {:6.2f} deg\\n\".format(*RMS.Astrometry.ApplyAstrometry.computeFOVSize(self))\n        out_str += \"    Img res   = {:6d} x {:6d} px\\n\".format(self.X_res, self.Y_res)\n        out_str += \"Reference pointing - equatorial (J2000):\\n\"\n        out_str += \"    JD      = {:.10f} \\n\".format(self.JD)\n        out_str += \"    RA      = {:11.6f} deg\\n\".format(self.RA_d)\n        out_str += \"    Dec     = {:+11.6f} deg\\n\".format(self.dec_d)\n        out_str += \"    Pos ang = {:.6f} deg\\n\".format(self.pos_angle_ref)\n        out_str += \"    Pix scl = {:.2f} arcmin/px\\n\".format(60/self.F_scale)\n        out_str += \"Reference pointing - apparent azimuthal (date):\\n\"\n        out_str += \"    Azim    = {:.6f} deg (+E of N)\\n\".format(azim)\n        out_str += \"    Alt     = {:.6f} deg\\n\".format(elev)\n        out_str += \"    Rot/hor = {:.6f} deg\\n\".format(RMS.Astrometry.ApplyAstrometry.rotationWrtHorizon(self))\n        out_str += \"Distortion:\\n\"\n        out_str += \"    Type = {:s}\\n\".format(self.distortion_type)\n\n        # If the polynomial is used, the X axis parameters are stored in x_poly, otherwise radials paramters\n        #   are used\n        if self.distortion_type.startswith(\"poly\"):\n            out_str += \"    Distortion coeffs (polynomial):\\n\"\n            dist_string = \"X\"\n\n            # Poly parameters for printing (needed for radial which will be modified)\n            x_poly_fwd_print = self.x_poly_fwd\n            x_poly_rev_print = self.x_poly_rev\n\n        # Radial coefficients\n        else:\n            out_str += \"    Distortion coeffs (radial):\\n\"\n\n            out_str += \"           \"\n            if not self.force_distortion_centre:\n                out_str += \" x0 (px),  y0 (px), \"\n\n            if not self.equal_aspect:\n                out_str += \"aspect-1, \"\n\n            if self.asymmetry_corr:\n                out_str += \"      a1, a2 (deg), \"\n\n            out_str +=\"      k1,       k2,       k3,       k4\\n\"\n            \n            dist_string = \"\"\n\n\n\n            x_poly_fwd_print = np.array(self.x_poly_fwd)\n            x_poly_rev_print = np.array(self.x_poly_rev)\n\n            if not self.force_distortion_centre:\n\n                # Report x0 and y0 in px (unnormalize and wrap)\n                x_poly_fwd_print[0] *= self.X_res/2\n                x_poly_fwd_print[1] *= self.Y_res/2\n                x_poly_rev_print[0] *= self.X_res/2\n                x_poly_rev_print[1] *= self.Y_res/2\n                x_poly_fwd_print[0] = -self.X_res/2.0 + (x_poly_fwd_print[0] + self.X_res/2.0)%self.X_res\n                x_poly_fwd_print[1] = -self.Y_res/2.0 + (x_poly_fwd_print[1] + self.Y_res/2.0)%self.Y_res\n                x_poly_rev_print[0] = -self.X_res/2.0 + (x_poly_rev_print[0] + self.X_res/2.0)%self.X_res\n                x_poly_rev_print[1] = -self.Y_res/2.0 + (x_poly_rev_print[1] + self.Y_res/2.0)%self.Y_res\n\n            \n            # Convert the asymmetry correction parameter to degrees\n            if self.asymmetry_corr:\n                asym_ang_index = 4\n                \n                if self.force_distortion_centre:\n                    asym_ang_index -= 2\n\n                if self.equal_aspect:\n                    asym_ang_index -= 1\n\n                x_poly_fwd_print[asym_ang_index] = np.degrees((2*np.pi*x_poly_fwd_print[asym_ang_index]) \\\n                    %(2*np.pi))\n                x_poly_rev_print[asym_ang_index] = np.degrees((2*np.pi*x_poly_rev_print[asym_ang_index]) \\\n                    %(2*np.pi))\n\n\n\n\n        out_str += \"img2sky {:s} = {:s}\\n\".format(dist_string, \", \".join([\"{:+8.3f}\".format(c) \\\n            if abs(c) > 10e-4 else \"{:+8.1e}\".format(c) for c in x_poly_fwd_print]))\n        out_str += \"sky2img {:s} = {:s}\\n\".format(dist_string, \", \".join([\"{:+8.3f}\".format(c) \\\n            if abs(c) > 10e-4 else \"{:+8.1e}\".format(c) for c in x_poly_rev_print]))\n\n        # Only print the rest if the polynomial fit is used\n        if self.distortion_type.startswith(\"poly\"):\n            out_str += \"img2sky Y = {:s}\\n\".format(\", \".join([\"{:+8.3f}\".format(c) \\\n                if abs(c) > 10e-4 else \"{:+8.1e}\".format(c) for c in self.y_poly_fwd]))\n            out_str += \"sky2img Y = {:s}\\n\".format(\", \".join([\"{:+8.3f}\".format(c) \\\n                if abs(c) > 10e-4 else \"{:+8.1e}\".format(c) for c in self.y_poly_rev]))\n\n        return out_str\nRMS/Routines/Image.py\n    USING_SCIPY_IMREAD = True\n    USING_SCIPY_IMREAD = False\ndef loadRaw(img_path):\ndef loadImage(img_path, flatten=-1):\ndef saveImage(img_path, img, add_timestamp=False):\ndef binImage(img, bin_factor, method='avg'):\ndef thresholdImg(img, avepixel, stdpixel, k1, j1, ff=False, mask=None, mask_ave_bright=True):\ndef thresholdFF(ff, k1, j1, mask=None, mask_ave_bright=False):\ndef gammaCorrection(intensity, gamma, bp=0, wp=255):\ndef applyBrightnessAndContrast(img, brightness, contrast):\ndef adjustLevels(img_array, minv, gamma, maxv, nbits=None, scaleto8bits=False):\n    def __init__(self, flat_img, dark=None):\n    def applyDark(self, dark):\n    def computeAverage(self):\n    def fixValues(self):\n    def binFlat(self, binning_factor, binning_method):\ndef loadFlat(dir_path, file_name, dtype=None, byteswap=False, dark=None):\ndef applyFlat(img, flat_struct):\ndef loadDark(dir_path, file_name, dtype=None, byteswap=False):\ndef applyDark(img, dark_img):\ndef deinterlaceOdd(img):\ndef deinterlaceEven(img):\ndef blendLighten(arr1, arr2):\ndef deinterlaceBlend(img):\ndef fillCircle(photom_mask, x_cent, y_cent, radius):\ndef thickLine(img_h, img_w, x_cent, y_cent, length, rotation, radius):\nclass FlatStruct(object):\nRMS/Misc.py\ndef openFileDialog(dir_path, initialfile, title, mpl, filetypes=()):\n    \"\"\" Open the file dialog and close it properly, depending on the backend used. \n    \n    Arguments:\n        dir_path: [str] Initial path of the directory.\n        initialfile: [str] Initial file to load.\n        title: [str] Title of the file dialog window.\n        mpl: [matplotlib instance] Instace of matplotlib import which is used to determine the used backend.\n        filetypes: [list of tuples] A tuple with file type pairs to filter (label, pattern)\n\n    Return:\n        file_name: [str] Path to the chosen file.\n    \"\"\"\n\n    root = tkinter.Tk()\n    root.withdraw()\n    root.update()\n\n    # Open the file dialog\n    file_name = filedialog.askopenfilename(initialdir=dir_path,\n        initialfile=initialfile, title=title, filetypes=filetypes)\n    root.update()\n\n    if (mpl.get_backend() != 'TkAgg') and (mpl.get_backend() != 'WXAgg'):\n        root.quit()\n    else:\n        root.destroy()\n\n\n    return file_name\nRMS/Astrometry/ApplyAstrometry.py\ndef applyAstrometryFTPdetectinfo(dir_path, ftp_detectinfo_file, platepar_file, UT_corr=0, platepar=None):\n    \"\"\" Use the given platepar to calculate the celestial coordinates of detected meteors from a FTPdetectinfo\n        file and save the updates values.\n    Arguments:\n        dir_path: [str] Path to the night.\n        ftp_detectinfo_file: [str] Name of the FTPdetectinfo file.\n        platepar_file: [str] Name of the platepar file.\n    Keyword arguments:\n        UT_corr: [float] Difference of time from UTC in hours.\n        platepar: [Platepar obj] Loaded platepar. None by default. If given, the platepar file won't be read,\n            but this platepar structure will be used instead.\n    Return:\n        None\n    \"\"\"\n\n    # If the FTPdetectinfo file does not exist, skip everything\n    if not os.path.isfile(os.path.join(dir_path, ftp_detectinfo_file)):\n        print('The given FTPdetectinfo file does not exist:', os.path.join(dir_path, ftp_detectinfo_file))\n        print('The astrometry was not computed!')\n        return None\n\n    # Save a copy of the uncalibrated FTPdetectinfo\n    ftp_detectinfo_copy = \"\".join(ftp_detectinfo_file.split('.')[:-1]) + \"_uncalibrated.txt\"\n\n    # Back up the original FTPdetectinfo, only if a backup does not exist already\n    if not os.path.isfile(os.path.join(dir_path, ftp_detectinfo_copy)):\n        shutil.copy2(os.path.join(dir_path, ftp_detectinfo_file), os.path.join(dir_path, ftp_detectinfo_copy))\n\n    # Load platepar from file if not given\n    if platepar is None:\n\n        # Load the platepar\n        platepar = RMS.Formats.Platepar.Platepar()\n        platepar.read(os.path.join(dir_path, platepar_file), use_flat=None)\n\n\n    # Load the FTPdetectinfo file\n    meteor_data = readFTPdetectinfo(dir_path, ftp_detectinfo_file)\n\n    # List for final meteor data\n    meteor_list = []\n\n    # Go through every meteor\n    for meteor in meteor_data:\n\n        ff_name, cam_code, meteor_No, n_segments, fps, hnr, mle, binn, px_fm, rho, phi, meteor_meas = meteor\n\n        # Apply the platepar to the given centroids\n        meteor_picks = applyPlateparToCentroids(ff_name, fps, meteor_meas, platepar)\n\n        # Add the calculated values to the final list\n        meteor_list.append([ff_name, meteor_No, rho, phi, meteor_picks])\n\n\n    # Calibration string to be written to the FTPdetectinfo file\n    calib_str = 'Calibrated with RMS on: ' + str(datetime.datetime.utcnow()) + ' UTC'\n\n    # If no meteors were detected, set dummpy parameters\n    if len(meteor_list) == 0:\n        cam_code = ''\n        fps = 0\n\n    # Save the updated FTPdetectinfo\n    writeFTPdetectinfo(meteor_list, dir_path, ftp_detectinfo_file, dir_path, cam_code, fps, \n        calibration=calib_str, celestial_coords_given=True)\nRMS/Formats/FRbin.py\ndef validFRName(fr_name):\n    \"\"\" Checks if the given file is an FR file. \n    \n    Arguments:\n        fr_name: [str] Name of the FR file\n    \"\"\"\n\n    if fr_name.startswith('FR') and fr_name.endswith('.bin'):\n        return True\n\n    else:\n        return False\nRMS/Formats/FRbin.py\ndef read(dir_path, filename):\n    \"\"\" Read an FR*.bin file.\n    \n    Arguments:\n        dir_path: [str] Path to directory containing file.\n        filename: [str] Name of FR*.bin file (either with the FR prefix and the .bin suffix, or without).\n    \n    Return:\n        fr: [fr_struct instance] \n\n    \"\"\"\n    if filename[:2] == \"FR\":\n        fid = open(os.path.join(dir_path, filename), \"rb\")\n    else:\n        fid = open(os.path.join(dir_path, \"FR_\" + filename + \".bin\"), \"rb\")\n\n    fr = fr_struct()\n\n    fr.lines = np.fromfile(fid, dtype=np.uint32, count=1)[0]\n\n    for i in range(fr.lines):\n        frameNum = np.fromfile(fid, dtype=np.uint32, count=1)[0]\n        yc = []\n        xc = []\n        t = []\n        size = []\n        frames = []\n\n        for z in range(frameNum):\n            yc.append(int(np.fromfile(fid, dtype=np.uint32, count=1)))\n            xc.append(int(np.fromfile(fid, dtype=np.uint32, count=1)))\n            t.append(int(np.fromfile(fid, dtype=np.uint32, count=1)))\n            size.append(int(np.fromfile(fid, dtype=np.uint32, count=1)))\n            frames.append(np.reshape(np.fromfile(fid, dtype=np.uint8, count=size[-1]**2), (size[-1], size[-1])))\n\n        fr.frameNum.append(frameNum)\n        fr.yc.append(yc)\n        fr.xc.append(xc)\n        fr.t.append(t)\n        fr.size.append(size)\n        fr.frames.append(frames)\n\n    return fr\nRMS/Astrometry/ApplyAstrometry.py\ndef xyToRaDecPP(time_data, X_data, Y_data, level_data, platepar, extinction_correction=True, \\\n    measurement=False):\n    \"\"\" Converts image XY to RA,Dec, but it takes a platepar instead of individual parameters. \n\n    Arguments:\n        time_data: [2D ndarray] Numpy array containing time tuples of each data point (year, month, day,\n            hour, minute, second, millisecond).\n        X_data: [ndarray] 1D numpy array containing the image X component.\n        Y_data: [ndarray] 1D numpy array containing the image Y component.\n        level_data: [ndarray] Levels of the meteor centroid.\n        platepar: [Platepar structure] Astrometry parameters.\n\n    Keyword arguments:\n        extinction_correction: [bool] Apply extinction correction. True by default. False is set to prevent \n            infinite recursion in extinctionCorrectionApparentToTrue when set to True.\n        measurement: [bool] Indicates if the given images values are image measurements. Used for correcting\n            celestial coordinates for refraction if the refraction was not taken into account during\n            plate fitting.\n\n    Return:\n        (JD_data, RA_data, dec_data, magnitude_data): [tuple of ndarrays]\n            JD_data: [ndarray] Julian date of each data point.\n            RA_data: [ndarray] Right ascension of each point (deg).\n            dec_data: [ndarray] Declination of each point (deg).\n            magnitude_data: [ndarray] Array of meteor's lightcurve apparent magnitudes.\n    \"\"\"\n\n\n    # Convert time to Julian date\n    JD_data = np.array([date2JD(*time_data_entry) for time_data_entry in time_data], dtype=np.float64)\n\n    # Convert x,y to RA/Dec using a fast cython function\n    RA_data, dec_data = cyXYToRADec(JD_data, np.array(X_data, dtype=np.float64), \\\n        np.array(Y_data, dtype=np.float64), float(platepar.lat), float(platepar.lon), float(platepar.X_res), \\\n        float(platepar.Y_res), float(platepar.Ho), float(platepar.RA_d), float(platepar.dec_d), \\\n        float(platepar.pos_angle_ref), float(platepar.F_scale), platepar.x_poly_fwd, platepar.y_poly_fwd, \\\n        unicode(platepar.distortion_type), refraction=platepar.refraction, \\\n        equal_aspect=platepar.equal_aspect, force_distortion_centre=platepar.force_distortion_centre, \\\n        asymmetry_corr=platepar.asymmetry_corr)\n\n    # Correct the coordinates for refraction if it wasn't taken into account during the astrometry calibration\n    #   procedure\n    if (not platepar.refraction) and measurement and platepar.measurement_apparent_to_true_refraction:\n        for i, entry in enumerate(zip(JD_data, RA_data, dec_data)):\n            jd, ra, dec = entry\n            ra, dec = eqRefractionApparentToTrue(np.radians(ra), np.radians(dec), jd, \\\n                np.radians(platepar.lat), np.radians(platepar.lon))\n\n            RA_data[i] = np.degrees(ra)\n            dec_data[i] = np.degrees(dec)\n            \n\n    # Compute radiia from image centre\n    radius_arr = np.hypot(np.array(X_data) - platepar.X_res/2, np.array(Y_data) - platepar.Y_res/2)\n\n    # Calculate magnitudes\n    magnitude_data = calculateMagnitudes(level_data, radius_arr, platepar.mag_lev, platepar.vignetting_coeff)\n\n\n    # Extinction correction\n    if extinction_correction:\n        magnitude_data = extinctionCorrectionApparentToTrue(magnitude_data, X_data, Y_data, JD_data[0], \\\n            platepar)\n\n\n    return JD_data, RA_data, dec_data, magnitude_data\nRMS/Pickling.py\ndef savePickle(obj, dir_path, file_name):\n    \"\"\" Dump the given object into a file using Python 'pickling'. The file can be loaded into Python\n        ('unpickled') afterwards for further use.\n\n    Arguments:\n    \tobj: [object] Object which will be pickled.\n        dir_path: [str] Path of the directory where the pickle file will be stored.\n        file_name: [str] Name of the file where the object will be stored.\n\n    \"\"\"\n\n    mkdirP(dir_path)\n\n    with open(os.path.join(dir_path, file_name), 'wb') as f:\n        pickle.dump(obj, f, protocol=2)\nRMS/Astrometry/Conversions.py\ndef raDec2AltAz(ra, dec, jd, lat, lon):\n    \"\"\" Calculate the reference azimuth and altitude of the centre of the FOV from the given RA/Dec.\n    Arguments:\n        ra:  [float] Right ascension in degrees.\n        dec: [float] Declination in degrees.\n        jd: [float] Reference Julian date.\n        lat: [float] Latitude +N in degrees.\n        lon: [float] Longitude +E in degrees.\n    Return:\n        (azim, elev): [tuple of float]: Azimuth and elevation (degrees).\n    \"\"\"\n    ra = np.radians(ra)\n    dec = np.radians(dec)\n    lat = np.radians(lat)\n    lon = np.radians(lon)\n\n    # Compute azim and elev using a fast cython function\n    if isinstance(ra, float) or isinstance(ra, int) or isinstance(ra, np.float64):\n        azim, elev = cyraDec2AltAz(ra, dec, jd, lat, lon)\n\n    elif isinstance(ra, np.ndarray):\n        # Compute it for numpy arrays\n        azim, elev = cyraDec2AltAz_vect(ra, dec, jd, lat, lon)\n\n    else:\n        raise TypeError(\"ra must be a number or np.ndarray, given: {}\".format(type(ra)))\n\n    return np.degrees(azim), np.degrees(elev)\nRMS/Formats/FFfile.py\ndef filenameToDatetime(file_name):\n    \"\"\" Converts FF bin file name to a datetime object.\n\n    Arguments:\n        file_name: [str] Name of a FF file.\n\n    Return:\n        [datetime object] Date and time of the first frame in the FF file.\n\n    \"\"\"\n\n    # e.g.  FF499_20170626_020520_353_0005120.bin\n    # or FF_CA0001_20170626_020520_353_0005120.fits\n\n    file_name = file_name.split('_')\n\n    # Check the number of list elements, and the new fits format has one more underscore\n    i = 0\n    if len(file_name[0]) == 2:\n        i = 1\n\n    date = file_name[i + 1]\n    year = int(date[:4])\n    month = int(date[4:6])\n    day = int(date[6:8])\n\n    time = file_name[i + 2]\n    hour = int(time[:2])\n    minute = int(time[2:4])\n    seconds = int(time[4:6])\n\n    ms = int(file_name[i + 3])\n\n\n    return datetime.datetime(year, month, day, hour, minute, seconds, ms*1000)\nRMS/Astrometry/Conversions.py\ndef jd2Date(jd, UT_corr=0, dt_obj=False):\n    \"\"\" Converts the given Julian date to (year, month, day, hour, minute, second, millisecond) tuple.\n    Arguments:\n        jd: [float] Julian date\n    Keyword arguments:\n        UT_corr: [float] UT correction in hours (difference from local time to UT)\n        dt_obj: [bool] returns a datetime object if True. False by default.\n    Return:\n        (year, month, day, hour, minute, second, millisecond)\n    \"\"\"\n\n    dt = timedelta(days=jd)\n\n    try:\n        date = dt + JULIAN_EPOCH - J2000_JD + timedelta(hours=UT_corr)\n\n    # If the date is out of range (i.e. before year 1) use year 1. This is the limitation in the datetime\n    # library. Time handling should be switched to astropy.time\n    except OverflowError:\n        date = datetime(MINYEAR, 1, 1, 0, 0, 0)\n\n    # Return a datetime object if dt_obj == True\n    if dt_obj:\n        return date\n\n    return date.year, date.month, date.day, date.hour, date.minute, date.second, date.microsecond/1000.0\nRMS/Pickling.py\ndef loadPickle(dir_path, file_name):\n    \"\"\" Loads pickle file.\n\t\n\tArguments:\n\t\tdir_path: [str] Path of the directory where the pickle file will be stored.\n        file_name: [str] Name of the file where the object will be stored.\n\n    \"\"\"\n\n    with open(os.path.join(dir_path, file_name), 'rb') as f:\n\n        # Try loading the Pickle file\n\n        try:\n            # Python 2\n            if sys.version_info[0] < 3:\n                return pickle.load(f)\n\n            # Python 3\n            else:\n                return pickle.load(f, encoding='latin1')\n\n        except (IOError, EOFError, TypeError, KeyError):\n            \n            print('The pickle file was corruped and could not be loaded:', os.path.join(dir_path, file_name))\n            return None\nRMS/Astrometry/Conversions.py\nJ2000_JD = timedelta(2451545)  # julian epoch in julian dates\nRMS/Formats/FrameInterface.py\ndef detectInputType(input_path, config, beginning_time=None, fps=None, skip_ff_dir=False, detection=False,\n    use_fr_files=False):\n    \"\"\" Given the folder of a file, detect the input format.\n\n    Arguments:\n        input_path: [str] Input directory path (e.g. dir with FF files or path to a video file).\n        config: [Config Struct]\n\n    Keyword arguments:\n        beginning_time: [datetime] Datetime of the video beginning. Optional, only can be given for\n            video input formats.\n        fps: [float] Frames per second, used only when images in a folder are used. If it's not given,\n            it will be read from the config file.\n        skip_ff_dir: [bool] Skip the input type where there are multiple FFs in the same directory. False\n            by default. This is only used for ManualReduction.\n        detection: [bool] Indicates that the input is used for detection. False by default. This will\n                control whether the binning is applied or not. No effect on FF image handle.\n        use_fr_files: [bool] Include FR files together with FF files. False by default, only used in SkyFit.\n\n    \"\"\"\n    \n\n    if os.path.isdir(input_path):\n\n        # Detect input type if a directory is given\n        img_handle = detectInputTypeFolder(input_path, config, beginning_time=beginning_time, fps=fps, \\\n            skip_ff_dir=skip_ff_dir, detection=detection, use_fr_files=use_fr_files)\n        \n    else:\n        # Detect input type if a path to a file is given\n        img_handle = detectInputTypeFile(input_path, config, beginning_time=beginning_time, fps=fps, \\\n            detection=fps)\n\n    return img_handle\nRMS/Astrometry/Conversions.py\ndef datetime2JD(dt, UT_corr=0.0):\n    \"\"\" Converts a datetime object to Julian date.\n    Arguments:\n        dt: [datetime object]\n    Keyword arguments:\n        UT_corr: [float] UT correction in hours (difference from local time to UT)\n    Return:\n        jd: [float] Julian date\n    \"\"\"\n\n    return date2JD(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.microsecond/1000.0,\n                   UT_corr=UT_corr)\n", "answers": ["            jdt_ref = datetime2JD(self.img_handle.beginning_datetime)"], "length": 7066, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "bc08279586ccf2dbeb70cbf0966fec0dda148be0114d75d1"}
{"input": "import android.annotation.SuppressLint;\nimport android.app.AlertDialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.PowerManager;\nimport android.support.v4.app.FragmentManager;\nimport android.text.Html;\nimport android.text.Layout;\nimport android.text.Spannable;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.text.TextWatcher;\nimport android.text.method.LinkMovementMethod;\nimport android.text.style.URLSpan;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.EditText;\nimport android.widget.ExpandableListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport org.matrix.androidsdk.HomeserverConnectionConfig;\nimport org.matrix.androidsdk.MXSession;\nimport org.matrix.androidsdk.call.IMXCall;\nimport org.matrix.androidsdk.call.MXCallsManager;\nimport org.matrix.androidsdk.data.Room;\nimport org.matrix.androidsdk.data.RoomState;\nimport org.matrix.androidsdk.data.RoomSummary;\nimport org.matrix.androidsdk.fragments.IconAndTextDialogFragment;\nimport org.matrix.androidsdk.listeners.MXEventListener;\nimport org.matrix.androidsdk.rest.callback.ApiCallback;\nimport org.matrix.androidsdk.rest.callback.SimpleApiCallback;\nimport org.matrix.androidsdk.rest.client.LoginRestClient;\nimport org.matrix.androidsdk.rest.model.Event;\nimport org.matrix.androidsdk.rest.model.MatrixError;\nimport org.matrix.androidsdk.rest.model.PublicRoom;\nimport org.matrix.androidsdk.rest.model.RoomMember;\nimport org.matrix.androidsdk.rest.model.login.Credentials;\nimport org.matrix.androidsdk.util.EventUtils;\nimport org.matrix.androidsdk.util.JsonUtils;\nimport org.matrix.console.ConsoleApplication;\nimport org.matrix.console.LoginHandler;\nimport org.matrix.console.Matrix;\nimport org.matrix.console.MyPresenceManager;\nimport org.matrix.console.R;\nimport org.matrix.console.ViewedRoomTracker;\nimport org.matrix.console.adapters.ConsoleRoomSummaryAdapter;\nimport org.matrix.console.adapters.DrawerAdapter;\nimport org.matrix.console.db.ConsoleContentProvider;\nimport org.matrix.console.fragments.AccountsSelectionDialogFragment;\nimport org.matrix.console.fragments.ContactsListDialogFragment;\nimport org.matrix.console.fragments.RoomCreationDialogFragment;\nimport org.matrix.console.gcm.GcmRegistrationManager;\nimport org.matrix.console.services.EventStreamService;\nimport org.matrix.console.util.RageShake;\nimport org.matrix.console.view.AddAccountAlertDialog;\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\n/*\n * Copyright 2014 OpenMarket Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.matrix.console.activity;\n\n\n\n\n\n/**\n * Displays the main screen of the app, with rooms the user has joined and the ability to create\n * new rooms.\n */\npublic class HomeActivity extends MXCActionBarActivity {\n\n    private static final String LOG_TAG = \"HomeActivity\";\n\n    private ExpandableListView mMyRoomList = null;\n\n    private static final String PUBLIC_ROOMS_LIST_LIST = \"PUBLIC_ROOMS_LIST_LIST\";\n\n    private static final String TAG_FRAGMENT_CONTACTS_LIST = \"org.matrix.console.HomeActivity.TAG_FRAGMENT_CONTACTS_LIST\";\n    private static final String TAG_FRAGMENT_CREATE_ROOM_DIALOG = \"org.matrix.console.HomeActivity.TAG_FRAGMENT_CREATE_ROOM_DIALOG\";\n\n    private static final String TAG_FRAGMENT_ROOM_OPTIONS = \"org.matrix.console.HomeActivity.TAG_FRAGMENT_ROOM_OPTIONS\";\n\n    public static final String EXTRA_JUMP_TO_ROOM_ID = \"org.matrix.console.HomeActivity.EXTRA_JUMP_TO_ROOM_ID\";\n    public static final String EXTRA_JUMP_MATRIX_ID = \"org.matrix.console.HomeActivity.EXTRA_JUMP_MATRIX_ID\";\n    public static final String EXTRA_ROOM_INTENT = \"org.matrix.console.HomeActivity.EXTRA_ROOM_INTENT\";\n\n    private ArrayList<String> mHomeServerNames = null;\n    private ArrayList<List<PublicRoom>> mPublicRoomsListList = null;\n\n    private boolean mIsPaused = false;\n\n    private ArrayList<Integer> mExpandedGroups = null;\n\n    private String mAutomaticallyOpenedRoomId = null;\n    private String mAutomaticallyOpenedMatrixId = null;\n    private Intent mOpenedRoomIntent = null;\n\n    private boolean refreshOnChunkEnd = false;\n\n    private MenuItem mCallMenuItem = null;\n\n    // about\n    private AlertDialog mMainAboutDialog = null;\n    private String mLicenseString = null;\n\n    // sliding menu\n    private final Integer[] mSlideMenuTitleIds = new Integer[]{\n            //R.string.action_search_contact,\n            //R.string.action_search_room,\n            R.string.create_room,\n            R.string.join_room,\n           // R.string.action_mark_all_as_read,\n            R.string.action_add_account,\n            R.string.action_remove_account,\n            R.string.action_settings,\n            R.string.action_disconnect,\n            R.string.action_logout,\n            R.string.send_bug_report,\n            R.string.about,\n    };\n\n    // sliding menu\n    private final Integer[] mSlideMenuResourceIds = new Integer[]{\n            //R.drawable.ic_material_search, // R.string.action_search_contact,\n            //R.drawable.ic_material_find_in_page, // R.string.action_search_room,\n            R.drawable.ic_material_group_add, //R.string.create_room,\n            R.drawable.ic_material_group, // R.string.join_room,\n            //R.drawable.ic_material_done_all, // R.string.action_mark_all_as_read,\n            R.drawable.ic_material_person_add, // R.string.action_add_account,\n            R.drawable.ic_material_remove_circle_outline, // R.string.action_remove_account,\n            R.drawable.ic_material_settings, //  R.string.action_settings,\n            R.drawable.ic_material_clear, // R.string.action_disconnect,\n            R.drawable.ic_material_exit_to_app, // R.string.action_logout,\n            R.drawable.ic_material_bug_report, // R.string.send_bug_report,\n            R.drawable.ic_menu_matrix_transparent, // R.string.about,\n    };\n\n    private HashMap<MXSession, MXEventListener> mListenersBySession = new HashMap<MXSession, MXEventListener>();\n    private HashMap<MXSession, MXCallsManager.MXCallsManagerListener> mCallListenersBySession = new HashMap<MXSession, MXCallsManager.MXCallsManagerListener>();\n\n    private ConsoleRoomSummaryAdapter mAdapter;\n    private EditText mSearchRoomEditText;\n\n    private void refreshPublicRoomsList() {", "context": "console/src/main/java/org/matrix/console/MyPresenceManager.java\npublic class MyPresenceManager {\n    private static final String LOG_TAG = \"MyPresenceManager\";\n\n    // The delay we wait for before actually advertising in case it changes in the meantime.\n    // This is useful when saying we're unavailable on an activity's onPause to differentiate between\n    // backgrounding the app and just switching activities.\n    private static final int DELAY_TS = 3000;\n\n    // Array of presence states ordered by priority. If the current device thinks our user is online,\n    // it will disregard a presence event saying the user is unavailable and advertise that they are in\n    // fact online as a correction.\n    private static String[] orderedPresenceArray = new String[] {\n            User.PRESENCE_ONLINE,\n            User.PRESENCE_UNAVAILABLE,\n            User.PRESENCE_OFFLINE\n    };\n    // We need the reverse structure to associate an order to a given presence state\n    private static Map<String, Integer> presenceOrderMap = new HashMap<String, Integer>();\n    static {\n        for (int i = 0; i < orderedPresenceArray.length; i++) {\n            presenceOrderMap.put(orderedPresenceArray[i], i);\n        }\n    }\n\n    private static HashMap<MXSession, MyPresenceManager> instances = new HashMap<MXSession, MyPresenceManager>();\n\n    private MyUser myUser;\n    private Handler mHandler;\n    private String latestAdvertisedPresence = \"\"; // Presence we're advertising\n\n    private MyPresenceManager(Context context, MXSession session) {\n        myUser = session.getMyUser();\n        mHandler = new Handler(Looper.getMainLooper());\n\n        myUser.addEventListener(new MXEventListener() {\n            @Override\n            public void onPresenceUpdate(Event event, User user) {\n                myUser.presence = user.presence;\n\n                // If the received presence is the same as the last one we've advertised, this must be\n                // the event stream sending back our own event => nothing more to do\n                if (!user.presence.equals(latestAdvertisedPresence)) {\n                    // If we're here, the presence event comes from another of this user's devices. If it's saying for example that it's\n                    // offline but we're currently online, our presence takes precedence; in which case, we broadcast the correction\n                    Integer newPresenceOrder = presenceOrderMap.get(user.presence);\n                    if (newPresenceOrder != null) {\n                        int ourPresenceOrder = presenceOrderMap.get(latestAdvertisedPresence);\n                        // If the new presence is further down the order list, we correct it\n                        if (newPresenceOrder > ourPresenceOrder) {\n                            advertisePresence(latestAdvertisedPresence);\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Create an instance without any check.\n     * @param context\n     * @param session\n     * @return\n     */\n    private static MyPresenceManager createInstance(Context context, MXSession session) {\n        MyPresenceManager instance = new MyPresenceManager(context, session);\n        instances.put(session, instance);\n        return instance;\n    }\n\n    /**\n     * Search a presence manager from a dedicated session\n     * @param context the context\n     * @param session the session\n     * @return the linked presence manager\n     */\n    public static synchronized MyPresenceManager getInstance(Context context, MXSession session) {\n        MyPresenceManager instance = instances.get(session);\n        if (instance == null) {\n            instance = createInstance(context, session);\n        }\n        return instance;\n    }\n\n    /**\n     * Create an MyPresenceManager instance for each session if it was not yet done.\n     * @param context the context\n     * @param sessions the sessions\n     */\n    public static synchronized void createPresenceManager(Context context, Collection<MXSession> sessions) {\n        for(MXSession session : sessions) {\n            if (!instances.containsKey(session)) {\n                createInstance(context, session);\n            }\n        }\n    }\n\n    /**\n     * Remove a presence manager for a session.\n     * @param session the session\n     */\n    public static synchronized void remove(MXSession session) {\n        instances.remove(session);\n    }\n\n    /**\n     * Send the advertise presence message.\n     * @param presence the presence message.\n     */\n    public void advertisePresence(String presence) {\n        if (!latestAdvertisedPresence.equals(presence)) {\n            latestAdvertisedPresence = presence;\n\n            Log.d(LOG_TAG, \"Advertising presence \" + presence);\n            myUser.updatePresence(presence, null, null);\n        }\n    }\n\n    private static void advertiseAll(String presence) {\n        Collection<MyPresenceManager> values = instances.values();\n\n        for(MyPresenceManager myPresenceManager : values) {\n            myPresenceManager.advertisePresence(presence);\n        }\n    }\n\n    public static void advertiseAllOnline() {\n        advertiseAll(User.PRESENCE_ONLINE);\n    }\n\n    public static void advertiseAllOffline() {\n        advertiseAll(User.PRESENCE_OFFLINE);\n    }\n\n    public static void advertiseAllUnavailable() {\n        advertiseAll(User.PRESENCE_UNAVAILABLE);\n    }\n\n    public void advertiseOffline() {\n        advertisePresence(User.PRESENCE_OFFLINE);\n    }\n}\nconsole/src/main/java/org/matrix/console/LoginHandler.java\npublic class LoginHandler {\n    private static final String LOG_TAG = \"LoginHandler\";\n\n    /**\n     * Try to login.\n     * The MXSession is created if the operation succeeds.\n     * @param ctx the context.\n     * @param hsConfig The homeserver config.\n     * @param username The username.\n     * @param password The password;\n     * @param callback The callback.\n     */\n    public void login(Context ctx, final HomeserverConnectionConfig hsConfig, final String username, final String password,\n                              final SimpleApiCallback<HomeserverConnectionConfig> callback) {\n        final Context appCtx = ctx.getApplicationContext();\n        LoginRestClient client = new LoginRestClient(hsConfig);\n\n        client.loginWithPassword(username, password, new SimpleApiCallback<Credentials>() {\n            @Override\n            public void onSuccess(Credentials credentials) {\n                Collection<MXSession> sessions = Matrix.getMXSessions(appCtx);\n                Boolean isDuplicated = false;\n\n                for (MXSession existingSession : sessions) {\n                    Credentials cred = existingSession.getCredentials();\n                    isDuplicated |= TextUtils.equals(credentials.userId, cred.userId) && TextUtils.equals(credentials.homeServer, cred.homeServer);\n                }\n\n                if (!isDuplicated) {\n                    hsConfig.setCredentials(credentials);\n                    MXSession session = Matrix.getInstance(appCtx).createSession(hsConfig);\n                    Matrix.getInstance(appCtx).addSession(session);\n                }\n\n                Log.d(LOG_TAG, \"client loginWithPassword succeeded.\");\n                callback.onSuccess(hsConfig);\n            }\n\n            @Override\n            public void onNetworkError(final Exception e) {\n                UnrecognizedCertificateException unrecCertEx = CertUtil.getCertificateException(e);\n                if (unrecCertEx != null) {\n                    final Fingerprint fingerprint = unrecCertEx.getFingerprint();\n                    Log.d(LOG_TAG, \"Found fingerprint: SHA-256: \" + fingerprint.getBytesAsHexString());\n                    // TODO: Handle this. For example by displaying a \"Do you trust this cert?\" dialog\n\n                    UnrecognizedCertHandler.show(hsConfig, fingerprint, false, new UnrecognizedCertHandler.Callback() {\n                        @Override\n                        public void onAccept() {\n                            login(appCtx, hsConfig, username, password, callback);\n                        }\n\n                        @Override\n                        public void onIgnore() {\n                            callback.onNetworkError(e);\n                        }\n\n                        @Override\n                        public void onReject() {\n                            callback.onNetworkError(e);\n                        }\n                    });\n                } else {\n                    callback.onNetworkError(e);\n                }\n            }\n\n            @Override\n            public void onUnexpectedError(Exception e) {\n                callback.onUnexpectedError(e);\n            }\n\n            @Override\n            public void onMatrixError(MatrixError e) {\n                callback.onMatrixError(e);\n            }\n        });\n    }\n\n    /**\n     * Retrieve the supported flows of a home server.\n     * @param ctx the application conttext.\n     * @param hsConfig the home server config.\n     * @param callback the supported flows list callback.\n     */\n    public void getSupportedFlows(Context ctx, final HomeserverConnectionConfig hsConfig, final SimpleApiCallback<List<LoginFlow>> callback) {\n        final Context appCtx = ctx.getApplicationContext();\n        LoginRestClient client = new LoginRestClient(hsConfig);\n\n        client.getSupportedLoginFlows(new SimpleApiCallback<List<LoginFlow>>() {\n            @Override\n            public void onSuccess(List<LoginFlow> flows) {\n                Log.d(LOG_TAG, \"getSupportedFlows \" + flows);\n                callback.onSuccess(flows);\n            }\n\n            @Override\n            public void onNetworkError(final Exception e) {\n                UnrecognizedCertificateException unrecCertEx = CertUtil.getCertificateException(e);\n                if (unrecCertEx != null) {\n                    final Fingerprint fingerprint = unrecCertEx.getFingerprint();\n                    Log.d(LOG_TAG, \"Found fingerprint: SHA-256: \" + fingerprint.getBytesAsHexString());\n\n                    UnrecognizedCertHandler.show(hsConfig, fingerprint, false, new UnrecognizedCertHandler.Callback() {\n                        @Override\n                        public void onAccept() {\n                            getSupportedFlows(appCtx, hsConfig, callback);\n                        }\n\n                        @Override\n                        public void onIgnore() {\n                            callback.onNetworkError(e);\n                        }\n\n                        @Override\n                        public void onReject() {\n                            callback.onNetworkError(e);\n                        }\n                    });\n                } else {\n                    callback.onNetworkError(e);\n                }\n            }\n\n            @Override\n            public void onUnexpectedError(Exception e) {\n                callback.onUnexpectedError(e);\n            }\n\n            @Override\n            public void onMatrixError(MatrixError e) {\n                callback.onMatrixError(e);\n            }\n        });\n    }\n\n}\nconsole/src/main/java/org/matrix/console/db/ConsoleContentProvider.java\npublic class ConsoleContentProvider extends ContentProvider {\n\n    public static String AUTHORITIES = \"org.matrix.console.ConsoleApplication.provider\";\n\n\n    /**\n     * Convert an absolute file path to a Content path\n     * @param context the application context\n     * @param path the absolute path to convert.\n     * @return the content URI.\n     */\n    public static Uri absolutePathToUri(Context context, String path) {\n        String basePath = context.getFilesDir().getAbsolutePath();\n\n        if ((null != path) && path.startsWith(basePath)) {\n            return Uri.parse(\"content://\" + ConsoleContentProvider.AUTHORITIES + path.substring(basePath.length()));\n        }\n\n        return null;\n    }\n\n    @Override\n    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {\n        File privateFile = new File(getContext().getFilesDir(), uri.getPath());\n        return ParcelFileDescriptor.open(privateFile, ParcelFileDescriptor.MODE_READ_ONLY);\n    }\n\n    @Override\n    public int delete(Uri arg0, String arg1, String[] arg2) {\n        return 0;\n    }\n\n    @Override\n    public String getType(Uri arg0) {\n        String type = null;\n        String extension = MimeTypeMap.getFileExtensionFromUrl(arg0.toString());\n        if (extension != null) {\n            MimeTypeMap mime = MimeTypeMap.getSingleton();\n            type = mime.getMimeTypeFromExtension(extension);\n        }\n\n        return type;\n    }\n\n    @Override\n    public Uri insert(Uri arg0, ContentValues arg1) {\n        return null;\n    }\n\n    @Override\n    public boolean onCreate() {\n        return false;\n    }\n\n    @Override\n    public Cursor query(Uri arg0, String[] arg1, String arg2, String[] arg3,\n                        String arg4) {\n        return null;\n    }\n\n    @Override\n    public int update(Uri arg0, ContentValues arg1, String arg2, String[] arg3) {\n        return 0;\n    }\n}\nconsole/src/main/java/org/matrix/console/ViewedRoomTracker.java\npublic class ViewedRoomTracker {\n\n    private static ViewedRoomTracker instance = null;\n\n    private String mViewedRoomId = null;\n    private String mMatrixId = null;\n\n    private ViewedRoomTracker(){\n    }\n\n    public static synchronized ViewedRoomTracker getInstance() {\n        if (instance == null) {\n            instance = new ViewedRoomTracker();\n        }\n        return instance;\n    }\n\n    public String getViewedRoomId() {\n        return mViewedRoomId;\n    }\n\n    public String getMatrixId() {\n        return mMatrixId;\n    }\n\n    public void setViewedRoomId(String roomId) {\n        mViewedRoomId = roomId;\n    }\n\n    public void setMatrixId(String matrixId) {\n        mMatrixId = matrixId;\n    }\n}\nconsole/src/main/java/org/matrix/console/view/AddAccountAlertDialog.java\npublic class AddAccountAlertDialog extends AlertDialog.Builder  {\n    // the onActivityResult identitier\n    public static final int FALLBACK_LOGIN_ACTIVITY_REQUEST_CODE = 2718;\n\n    // UI items\n    Activity mActivity;\n    EditText mUsernameEditText;\n    EditText mPasswordEditText;\n    EditText mHomeServerEditText;\n    View mSearchMaskView;\n    AlertDialog mDialog;\n\n    // the latest home server URL.\n    String mHomeServerUrl;\n\n    /**\n     * Creator.\n     * @param activity the activity creator\n     */\n    public AddAccountAlertDialog(Activity activity) {\n        super(activity);\n        mActivity = activity;\n\n        LayoutInflater layoutInflater = LayoutInflater.from(activity);\n\n        // extract the layout\n        View layout = layoutInflater.inflate(R.layout.fragment_dialog_add_account, null);\n\n        // and the useful UI items\n        mUsernameEditText = (EditText) layout.findViewById(R.id.editText_username);\n        mPasswordEditText = (EditText) layout.findViewById(R.id.editText_password);\n        mHomeServerEditText = (EditText) layout.findViewById(R.id.editText_hs);\n        mSearchMaskView = layout.findViewById(R.id.search_mask_view);\n        mSearchMaskView.setVisibility(View.GONE);\n        mHomeServerUrl = mHomeServerEditText.getText().toString();\n\n        // detect if the user taps on the next / done button\n        mHomeServerEditText.setOnEditorActionListener(new TextView.OnEditorActionListener() {\n            @Override\n            public boolean onEditorAction(TextView view, int actionId, KeyEvent event) {\n                if (actionId == EditorInfo.IME_ACTION_DONE) {\n                    return onHomeServerUrlUpdate();\n                }\n                return false;\n            }\n        });\n\n        // disable the OK if the home server url is not the same\n        mHomeServerEditText.addTextChangedListener(new TextWatcher() {\n            public void afterTextChanged(android.text.Editable s) {\n                mDialog.getButton(AlertDialog.BUTTON_POSITIVE).setEnabled(TextUtils.equals(mHomeServerUrl, mHomeServerEditText.getText().toString()));\n            }\n\n            public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n            }\n\n            public void onTextChanged(CharSequence s, int start, int before, int count) {\n            }\n        });\n\n\n        // detect the focus changes\n        mHomeServerEditText.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n            public void onFocusChange(View v, boolean hasFocus) {\n                if (!hasFocus) {\n                    onHomeServerUrlUpdate();\n                }\n            }\n        });\n\n        // dialog title and layout\n        setTitle(R.string.action_add_account);\n        setView(layout);\n\n        // buttons management.\n        setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int whichButton) {\n                onLogin();\n            }\n        });\n\n        setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int whichButton) {\n\n            }\n        });\n    }\n\n    /**\n     * Create and show the dialog.\n     * @return the shown dialog.\n     */\n    public AlertDialog show() {\n        mDialog = super.show();\n        return mDialog;\n    }\n\n    /**\n     * Check if the home server URL after its edition.\n     * The flows request is triggered to check if the dialog supports the login.\n     * The fallback activity is launched if it is not supported.\n     * @return true if a flows check request is triggered.\n     */\n    private Boolean onHomeServerUrlUpdate() {\n        // the user validates the homeserver url\n        if (!TextUtils.equals(mHomeServerUrl, mHomeServerEditText.getText().toString())) {\n            mHomeServerUrl = mHomeServerEditText.getText().toString();\n            checkFlows();\n            return true;\n        } el