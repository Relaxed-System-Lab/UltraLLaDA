{"input": "import waterwave.net.aio.define.AioServerDataDealer;\r\nimport waterwave.proxy.router.ProxyRouter;\r\nimport java.io.IOException;\r\nimport java.net.SocketAddress;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.WritePendingException;\r\nimport java.util.LinkedList;\r\nimport shui.common.buffer.BufferTools;\r\nimport shui.common.log.Logger;\r\nimport shui.common.service.ThreadSharedService;\r\nimport shui.common.util.CommonUtil;\r\nimport waterwave.net.aio.AioClient;\r\nimport waterwave.net.aio.AioClientChannel;\r\nimport waterwave.net.aio.AioServerChannel;\r\nimport waterwave.net.aio.define.AioClientDataDealer;\r\n/*\r\n * Licensed to waterwave under one or more contributor\r\n *  \r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *  \r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *  \r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage waterwave.proxy.aio;\r\n\r\n\r\n\r\n/**\r\n * \r\n * @author vv\r\n * \r\n * \r\n *         server:in -> queue \r\n *         client:in -> queue\r\n * \r\n *\r\n */\r\npublic class ProxyAioDataDealer extends ThreadSharedService implements AioServerDataDealer, AioClientDataDealer {\r\n\r\n\tAioClientChannel cc;\r\n\tAioServerChannel sc;\r\n\r\n\tAioClient client;\r\n\tSocketAddress remote;\r\n\r\n\tprivate boolean clientIniting;\r\n\r\n\tpublic ProxyAioDataDealer() {\r\n\r\n\t}\r\n\t\r\n\tfinal static boolean debug = false;\r\n\t\r\n\r\n\tpublic AioClient getClient() {\r\n\t\treturn client;\r\n\t}\r\n\tpublic void setClient(AioClient client) {\r\n\t\tthis.client = client;\r\n\t}\r\n\r\n\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\t\r\n\r\n\r\n\t@Override\r\n\tpublic void serverOnConnect(AioServerChannel channel) {\r\n\t\tthis.sc = channel;\r\n\t\t\r\n\t\tclientIniting = true;\r\n\t\ttry {\r\n\t\t\tremote = ProxyRouter.getStaticRemote();\r\n\t\t\tclient.connect(remote, this);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthis.clientOnError(null, e, null);\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void serverBeforeRead(AioServerChannel channel) {\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void serverOnData(AioServerChannel channel, ByteBuffer b, int bytes) {\r\n\t\t//log.log(1, \"serverOnData...\", b);\r\n\t\t\r\n\t\t//TODO\r\n\t\t//Logger.log(new String(BufferTools.getBuffer2Byte(b)));\r\n\t\t\r\n\t\t//init client\r\n\t\tif (cc == null) {\r\n\t\t\tif (clientIniting) {\r\n\t\t\t\tlog.log(9, \"serverOnData clientIniting long ...............\");\r\n\t\t\t}\r\n\r\n//\t\t\tclientIniting = true;\r\n//\t\t\ttry {\r\n//\t\t\t\tremote = ProxyAioRouter.getStaticRemote();\r\n//\t\t\t\tclient.connect(remote, this);\r\n//\t\t\t} catch (IOException e) {\r\n//\t\t\t\tthis.clientOnError(null, e, null);\r\n//\t\t\t\te.printStackTrace();\r\n//\t\t\t}\r\n\t\t\twaitingToIniting(b);\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t//normal\r\n\t\t\twriteToClient(b);\r\n\t\t\tchekcServerQueue();\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\r\n\t@Override\r\n\tpublic void serverAfterWrite(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n\t\tchekcServerQueue();\r\n\t}\r\n\t\r\n\tprivate final LinkedList<ByteBuffer> cq = new LinkedList<>();\r\n\tprivate final LinkedList<ByteBuffer> sq = new LinkedList<>();\r\n\t\r\n\tprivate void waitingToIniting(ByteBuffer buffer) {\r\n\t\tsynchronized (cq) {\r\n\t\t\tcq.add(buffer);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\tprivate final void writeToClient(ByteBuffer buffer) {\r\n\t\tsynchronized (cq) {\r\n\t\t\tif (cq.size() == 0) {\r\n\t\t\t\twriteToClient0(buffer);\r\n\t\t\t} else {\r\n\t\t\t\tcq.add(buffer);\r\n\t\t\t\twriteClientFromQueue();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final void writeToServer(ByteBuffer buffer) {\r\n\t\tsynchronized (sq) {\r\n\t\t\tif (sq.size() == 0) {\r\n\t\t\t\twriteToServer0(buffer);\r\n\t\t\t} else {\r\n\t\t\t\tsq.add(buffer);\r\n\t\t\t\twriteServerFromQueue();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final void writeToServer0(ByteBuffer buffer) {\r\n\t\ttry {\r\n\t\t\tbuffer.flip();\r\n\t\t\tsc.write(buffer);\r\n\t\t} catch (WritePendingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tbuffer.position(buffer.limit());\r\n\t\t\tsq.add(buffer);\r\n\t\t\twriteServerFromQueue();\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final void writeToClient0(ByteBuffer buffer) {\r\n\t\ttry {\r\n\t\t\tbuffer.flip();\r\n\t\t\tcc.write(buffer);\r\n\t\t} catch (WritePendingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tbuffer.position(buffer.limit());\r\n\t\t\tcq.add(buffer);\r\n\t\t\twriteClientFromQueue();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * client writeQueue and merge Buffer;\r\n\t * \r\n\t */\r\n\tprivate final void writeClientFromQueue() {\r\n\t\t//log.log(1, \"cq\", cq, cq.size());\r\n\t\tByteBuffer b0 = cq.poll();\r\n\t\t\r\n\t\tfor (;;) {\r\n\t\t\tByteBuffer b1 = cq.peek();\r\n\t\t\tif (b1 == null) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tint r0 = b0.remaining();\r\n\t\t\tint s1 = b1.position();\r\n\t\t\tif (s1 > r0) {\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tif(b0 != b1) {\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tb0.put(b1);\r\n\t\t\t\tcq.poll();\r", "context": "src/main/java/waterwave/proxy/router/ProxyRouter.java\npublic class ProxyRouter {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n\tpublic static SocketAddress staticRemote;\r\n\tpublic static InetAddress staticRemoteIp;\r\n\tpublic static int staticRemotePort;\r\n\tpublic static SocketAddress getStaticRemote() {\r\n\t\t// TODO Auto-generated method stub\r\n\t\treturn staticRemote;\r\n\t}\r\n\r\n}\r\nsrc/main/java/shui/common/util/CommonUtil.java\npublic class CommonUtil {\r\n\tpublic static String getLocalIp() {\r\n\t\tInetAddress addr;\r\n\t\ttry {\r\n\t\t\taddr = InetAddress.getLocalHost();\r\n\t\t\tString ip = addr.getHostAddress().toString();\r\n\t\t\treturn ip;\r\n\t\t} catch (UnknownHostException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn null;\r\n\r\n\t}\r\n\t\r\n\tpublic final static String getStringFromException(Throwable e) {\r\n\r\n\t\tStringWriter sw = new StringWriter();\r\n\t\tPrintWriter ps = new PrintWriter(sw);\r\n\r\n\t\te.printStackTrace(ps);\r\n\r\n\t\treturn sw.toString();\r\n\t}\r\n}\r\nsrc/main/java/shui/common/service/ThreadSharedService.java\npublic class ThreadSharedService {\r\n\tprotected final Logger log = new SimpleLogger(true);\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\r\n\t}\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/AioClient.java\npublic final class AioClient extends AioService implements Runnable {\r\n\r\n\t// private final AsynchronousSocketChannel listener;\r\n\tprivate final AsynchronousChannelGroup channelGroup;\r\n\tprivate final AioDataDealerFactory aioDataDealerFactory;\r\n\t\r\n\tprivate final Map<Integer, AioServerChannel> connections = new ConcurrentHashMap<Integer, AioServerChannel>();\r\n\t\r\n\r\n\tpublic AioClient(ExecutorService channelWorkers, AioDataDealerFactory aioDataDealerFactory) throws IOException {\r\n\t\t// ExecutorService channelWorkers = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), Executors.defaultThreadFactory());\r\n\t\tchannelGroup = AsynchronousChannelGroup.withThreadPool(channelWorkers);\r\n\t\tthis.aioDataDealerFactory = aioDataDealerFactory;\r\n\t}\r\n\r\n\tclass AcceptHandler implements CompletionHandler<Void, Void> {\r\n\t\tprivate final AsynchronousSocketChannel listener;\r\n\t\tprivate final AioClientDataDealer aioClientDataDealer;\r\n\r\n\t\tpublic AcceptHandler(AsynchronousSocketChannel listener, AioClientDataDealer aioClientDataDealer) {\r\n\t\t\tsuper();\r\n\t\t\tthis.listener = listener;\r\n\t\t\tthis.aioClientDataDealer = aioClientDataDealer;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void completed(Void result, Void attachment) {\r\n\t\t\t//log.log(1, \"Client AcceptHandler connected \");\r\n\t\t\thandleNewConnection(listener, aioClientDataDealer);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable exc, Void attachment) {\r\n\t\t\t//log.log(1, \"Client AcceptHandler failed result: \" + exc);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tpublic AsynchronousSocketChannel connect(SocketAddress remote) throws IOException {\r\n\t\treturn connect(remote, null);\r\n\t}\r\n\tpublic AsynchronousSocketChannel connect(SocketAddress remote, AioClientDataDealer aioClientDataDealer) throws IOException {\r\n\t\tAsynchronousSocketChannel listener = createListener(channelGroup);\r\n\t\t//log.log(1, \"client start connect\");\r\n\r\n\t\tAcceptHandler acceptHandler = new AcceptHandler(listener, aioClientDataDealer);\r\n\r\n\t\tlistener.connect(remote, null, acceptHandler);\r\n\t\treturn listener;\r\n\t}\r\n\r\n\tprotected void handleNewConnection(AsynchronousSocketChannel channel, AioClientDataDealer aioClientDataDealer) {\r\n\t\tif (!channel.isOpen()) {\r\n\t\t\t//log.log(1, \"handleNewConnection closed.. \");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tAioClientDataDealer dealer = null;\r\n\t\tif (aioClientDataDealer != null) {\r\n\t\t\tdealer = aioClientDataDealer;\r\n\t\t} else {\r\n\t\t\taioDataDealerFactory.getAioClientDataDealer();\r\n\t\t}\r\n\r\n\t\tint channelId = getChannelId();\r\n\t\tAioClientChannel aioChannel = new AioClientChannel(channelId, channel, dealer, this);\r\n\t\t\r\n\t\t// connections.add(aioChannel);\r\n\t\taioChannel.run(null);\r\n\t\t\r\n\t\tdealer.clientOnConnect(aioChannel);\r\n\r\n\t\t// String w = \"GET / HTTP/1.1 \\n\\n\";\r\n\t\t// ByteBuffer buffer = ByteBuffer.wrap(w.getBytes());\r\n\t\t// System.out.println(\"set write \");\r\n\t\t// channel.write(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {\r\n\t\t// @Override\r\n\t\t// public void completed(Integer result, ByteBuffer buffer) {\r\n\t\t// if (buffer.hasRemaining()) {\r\n\t\t// System.out.println(\"write... \");\r\n\t\t// channel.write(buffer, buffer, this);\r\n\t\t// } else {\r\n\t\t// // Go back and check if there is new data to write\r\n\t\t// // writeFromQueue();\r\n\t\t// System.out.println(\"write complete \" + result);\r\n\t\t// }\r\n\t\t// }\r\n\t\t//\r\n\t\t// @Override\r\n\t\t// public void failed(Throwable exc, ByteBuffer attachment) {\r\n\t\t// }\r\n\t\t// });\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * \r\n\t * \r\n\t * @param channelGroup\r\n\t * @return\r\n\t * @throws IOException\r\n\t * \r\n\t * \r\n\t *             SO_SNDBUF The size of the socket send buffer .\r\n\t *             SO_RCVBUF The size of the socket receive buffer. \r\n\t *             SO_KEEPALIVE Keep connection alive. \r\n\t *             SO_REUSEADDR Re-use address .\r\n\t *             TCP_NODELAY Disable the Nagle algorithm.\r\n\t * \r\n\t * \r\n\t */\r\n\tprivate AsynchronousSocketChannel createListener(AsynchronousChannelGroup channelGroup) throws IOException {\r\n\t\tfinal AsynchronousSocketChannel listener = AsynchronousSocketChannel.open(channelGroup);\r\n\t\t//TODO\r\n\t\t//listener.setOption(StandardSocketOptions.TCP_NODELAY, true);\r\n\t\tlistener.setOption(StandardSocketOptions.SO_REUSEADDR, true);\r\n\t\tlistener.setOption(StandardSocketOptions.SO_RCVBUF, 16 * 1024);\r\n\t\tlistener.setOption(StandardSocketOptions.SO_SNDBUF, 16 * 1024);\r\n\t\treturn listener;\r\n\t}\r\n\r\n\t//for test\r\n\t@Override\r\n\tpublic void run() {\r\n\t\tSystem.out.println(Thread.currentThread().getName() + \"---run\");\r\n\r\n\t\tInetSocketAddress r = new InetSocketAddress(\"10.213.33.176\", 11200);\r\n\t\ttry {\r\n\t\t\tAsynchronousSocketChannel channel = connect(r);\r\n\t\t\tSystem.out.println(channel);\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate AtomicInteger channelId = new AtomicInteger();\r\n\tprivate int getChannelId() {\r\n\t\treturn channelId.incrementAndGet();\r\n\t}\r\n\r\n\tpublic void removeAioChannel(AioClientChannel client) {\r\n       connections.remove(client.getChannelId());\r\n\t}\r\n\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\ttry {\r\n\t\t\tint threadCap = 4;\r\n\t\t\tExecutorService channelWorkers = Executors.newFixedThreadPool(threadCap, Executors.defaultThreadFactory());\r\n\t\t\tAioClient c = new AioClient(channelWorkers, null);\r\n\t\t\tc.run();\r\n\r\n\t\t\tThread.sleep(100000);\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/AioClientChannel.java\npublic final class AioClientChannel extends AioChannel{\r\n\t\r\n\tprivate final AsynchronousSocketChannel channel;\r\n\tprivate final AioClientDataDealer dealer;\r\n\t\r\n\tprivate final AioClient aioClient;\r\n\tprivate final int channelId;\r\n\t\r\n\t\r\n\t\r\n\r\n\tpublic AsynchronousSocketChannel getChannel() {\r\n\t\treturn channel;\r\n\t}\r\n\r\n\tpublic int getChannelId() {\r\n\t\treturn channelId;\r\n\t}\t\r\n\r\n\tpublic AioClientChannel(int channelId, AsynchronousSocketChannel channel, AioClientDataDealer dealer, AioClient aioClient) {\r\n\t\tthis.channelId = channelId;\r\n\t\tthis.channel = channel;\r\n\t\tthis.dealer = dealer;\r\n\t\tthis.aioClient = aioClient;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n\tpublic void run(ReadHandler reader) {\r\n\t\tdealer.clientBeforeRead(this);\r\n\t\tif(reader == null){\r\n\t\t\t//new\r\n\t\t\treader = new ReadHandler(this);\r\n\t\t}\r\n\t\tread(reader);\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n     * Runs a cycle of doing a beforeRead action and then enqueuing a new\r\n     * read on the client. Handles closed channels and errors while reading.\r\n     * If the client is still connected a new round of actions are called.\r\n     */\r\n\tclass ReadHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioClientChannel clientChannel;\r\n\t\t\r\n        public ReadHandler(AioClientChannel clientChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.clientChannel = clientChannel;\r\n\t\t}\r\n\r\n        @Override\r\n\t\tpublic void completed(Integer result, ByteBuffer buffer) {\r\n\t\t\t// if result is negative or zero the connection has been closed or something gone wrong\r\n\t\t\t//log.log(1, \"client ReadHandler read success: \");\r\n\t\t\tif (result < 1) {\r\n\t\t\t\tclientChannel.close();\r\n\t\t\t\tdealer.clientOnClose(clientChannel);\r\n\t\t\t\t\r\n\t\t\t\t//log.log(1, \"result < 1 ReadHandler Closing connection to \" + channel);\r\n\t\t\t} else {\r\n//\t\t\t\tSystem.out.println(\"result: \" + result);\r\n//\t\t\t\t// callback.onData(client, buffer, result);\r\n//\t\t\t\tbuffer.flip();\r\n//\t\t\t\tString name;\r\n//\t\t\t\tname = new String(buffer.array(), 0, result);\r\n//\t\t\t\tSystem.out.println(\"data: \" + name);\r\n//\t\t\t\t// enqueue next round of actions\r\n//\t\t\t\t// client.run();\r\n\t\t\t\t\r\n\t\t\t\tdealer.clientOnData(clientChannel, buffer, result);\r\n                // enqueue next round of actions\r\n\t\t\t\tclientChannel.run(this);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable e, ByteBuffer buffer) {\r\n\t\t\tlog.log(9, \"client ReadHandler read fail: \" + e);\r\n\t\t\t\r\n\t\t\tclientChannel.close();\r\n\t\t\tdealer.clientOnError(clientChannel, e, buffer);\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n\t\r\n\tclass WriteHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioClientChannel clientChannel;\r\n\t\t\r\n        public WriteHandler(AioClientChannel clientChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.clientChannel = clientChannel;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void completed(Integer result, ByteBuffer buffer) {\r\n\t\t\t// if result is negative or zero the connection has been closed or something gone wrong\r\n\t\t\t//log.log(1, \"client WriteHandler write success: \");\r\n\t\t\tif (buffer.hasRemaining()) {\r\n\t\t\t\t//log.log(1, \"client WriteHandler write...  hasRemaining \");\r\n\t\t\t\tchannel.write(buffer, buffer, this);\r\n\t\t\t} else {\r\n\t\t\t\t// Go back and check if there is new data to write\r\n\t\t\t\t// writeFromQueue();\r\n\t\t\t\t//log.log(1, \"client write complete \" + result);\r\n\r\n\t\t\t}\r\n\t\t\tdealer.clientAfterWrite(clientChannel, buffer, result);\r\n\t\t\t\r\n\t\t\tBufferTools.returnBuffer(buffer);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable e, ByteBuffer buffer) {\r\n\t\t\tlog.log(9, \"client WriteHandler write fail: \" + e);\r\n\t\t\tclientChannel.close();\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n\t\r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    public final void read(CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n    \t//log.log(1, \"Cliet: start client read \");\r\n    \t\r\n        ByteBuffer input = BufferTools.getBuffer();\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.read(input, input, completionHandler);\r\n    }\r\n    \r\n    \r\n    private CompletionHandler<Integer, ? super ByteBuffer> writerHandler = null;\r\n    public final void write(final ByteBuffer input) {\r\n    \tif(this.writerHandler == null) {\r\n    \t\twriterHandler = new WriteHandler(this);\r\n    \t}\r\n    \twrite(input, writerHandler);\r\n    }\r\n    \r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    protected final void write(ByteBuffer b ,CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n    \t//log.log(1, \"start client write \");\r\n    \t\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.write(b, b, completionHandler);\r\n    }\r\n    \r\n\r\n\tpublic void close() {\r\n        try {\r\n            channel.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        aioClient.removeAioChannel(this);\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/AioServerChannel.java\npublic final class AioServerChannel extends AioChannel{\r\n\t\r\n\tprivate final AsynchronousSocketChannel channel;\r\n\tprivate final AioServerDataDealer dealer;\r\n\tprivate final AioServer aioServer;\r\n\tprivate final int channelId;\r\n    //private final Queue<ByteBuffer> queue = new LinkedList<ByteBuffer>();\r\n\tprivate final Queue<ByteBuffer> queue = null;\r\n    \r\n    private boolean writing = false;\r\n\t\r\n    \r\n\r\n\tpublic int getChannelId() {\r\n\t\treturn channelId;\r\n\t}\r\n\r\n\r\n\tpublic AioServerChannel(int channelId, AsynchronousSocketChannel channel, AioServerDataDealer dealer, AioServer aioServer) {\r\n\t\tdealer.serverOnConnect(this);\r\n\t\tthis.channel = channel;\r\n\t\tthis.dealer = dealer;\r\n\t\tthis.aioServer = aioServer;\r\n\t\tthis.channelId = channelId;\r\n\t}\r\n\r\n\r\n\tpublic void run(ReadHandler reader) {\r\n\t\tdealer.serverBeforeRead(this);\r\n\t\tif (reader == null) {\r\n\t\t\treader = new ReadHandler(this);\r\n\t\t}\r\n\t\tread(reader);\r\n\r\n\t}\r\n\t\r\n    /**\r\n     * Runs a cycle of doing a beforeRead action and then enqueuing a new\r\n     * read on the client. Handles closed channels and errors while reading.\r\n     * If the client is still connected a new round of actions are called.\r\n     */\r\n\tclass ReadHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioServerChannel serverChannel;\r\n\t\t\r\n        public ReadHandler(AioServerChannel serverChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.serverChannel = serverChannel;\r\n\t\t}\r\n\r\n\t\t@Override\r\n        public void completed(Integer result, ByteBuffer buffer) {\r\n            // if result is negative or zero the connection has been closed or something gone wrong\r\n            if (result < 1) {\r\n            \t//log.log(1, \"server:ReadHandler result < 1 Closing connection to \" + serverChannel);\r\n            \t\r\n            \tserverChannel.close();\r\n            \tdealer.serverOnClose(serverChannel);\r\n            \t\r\n            } else {\r\n            \tdealer.serverOnData(serverChannel, buffer, result);\r\n                // enqueue next round of actions\r\n                serverChannel.run(this);\r\n            }\r\n        }\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable exc, ByteBuffer attachment) {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\tserverChannel.close();\r\n\t\t\t\r\n\t\t\tdealer.serverOnError(serverChannel, exc, attachment);\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n\t\r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    public final void read(CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n        ByteBuffer input = BufferTools.getBuffer();\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.read(input, input, completionHandler);\r\n    }\r\n    \r\n\r\n    \r\n\tclass WriteHandler implements CompletionHandler<Integer, ByteBuffer>{\r\n\t\tAioServerChannel serverChannel;\r\n\t\t\r\n        public WriteHandler(AioServerChannel serverChannel) {\r\n\t\t\tsuper();\r\n\t\t\tthis.serverChannel = serverChannel;\r\n\t\t}\r\n\r\n        @Override\r\n\t\tpublic void completed(Integer result, ByteBuffer buffer) {\r\n\t\t\t// if result is negative or zero the connection has been closed or something gone wrong\r\n\t\t\t//System.out.println(\"read success: \");\r\n\t\t\tif (buffer.hasRemaining()) {\r\n\t\t\t\t//log.log(1, \"server write... \");\r\n\t\t\t\tchannel.write(buffer, buffer, this);\r\n\t\t\t} else {\r\n\t\t\t\t// Go back and check if there is new data to write\r\n\t\t\t\t// writeFromQueue();\r\n\t\t\t\t//log.log(1, \"server write complete \" + result);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tdealer.serverAfterWrite(serverChannel, buffer, result);\r\n\t\t\tBufferTools.returnBuffer(buffer);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void failed(Throwable exc, ByteBuffer buffer) {\r\n\t\t\tlog.log(9, \"server WriteHandler write fail: \" + exc);\r\n\t\t\tserverChannel.close();\r\n\t\t}\r\n\t\t\r\n//\t\tpublic void onData(AioServerChannel channel, ByteBuffer buffer, int bytes) {\r\n//\t        buffer.flip();\r\n//\t        // Just append the message on the buffer\r\n//\t        //AioServerChannel.appendMessage(new String(buffer.array(), 0, bytes));\r\n//\t    }\r\n\t\t\r\n\t}\r\n    \r\n    \r\n\r\n    \r\n    private CompletionHandler<Integer, ? super ByteBuffer> writerHandler = null;\r\n    public final void write(final ByteBuffer input) {\r\n    \tif(this.writerHandler == null) {\r\n    \t\twriterHandler = new WriteHandler(this);\r\n    \t}\r\n    \twrite(input, writerHandler);\r\n    }\r\n    \r\n    /**\r\n     * Enqueue a read\r\n     * @param completionHandler callback on completed read\r\n     */\r\n    protected final void write(ByteBuffer b ,CompletionHandler<Integer, ? super ByteBuffer> completionHandler) {\r\n    \t//log.log(1, \"start server write \");\r\n    \t\r\n        if (!channel.isOpen()) {\r\n            return;\r\n        }\r\n        channel.write(b, b, completionHandler);\r\n    }\r\n    \r\n\r\n\r\n\t\r\n\t/**\r\n     * Closes the channel\r\n     */\r\n    public void close() {\r\n        try {\r\n            channel.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        aioServer.removeAioChannel(this);\r\n    }\r\n\r\n\r\n    \r\n    /**\r\n     * Enqueues a write of the buffer to the channel.\r\n     * The call is asynchronous so the buffer is not safe to modify after\r\n     * passing the buffer here.\r\n     *\r\n     * @param buffer the buffer to send to the channel\r\n     */\r\n    @Deprecated\r\n    public void writeOld(final ByteBuffer buffer) {\r\n        boolean threadShouldWrite = false;\r\n\r\n        synchronized(queue) {\r\n            queue.add(buffer);\r\n            // Currently no thread writing, make this thread dispatch a write\r\n            if (!writing) {\r\n                writing = true;\r\n                threadShouldWrite = true;\r\n            }\r\n        }\r\n\r\n        if (threadShouldWrite) {\r\n        \twriteFromQueueOld();\r\n        }\r\n    }\r\n    \r\n    @Deprecated\r\n    private void writeFromQueueOld() {\r\n        ByteBuffer buffer;\r\n\r\n        synchronized (queue) {\r\n            buffer = queue.poll();\r\n            if (buffer == null) {\r\n                writing = false;\r\n            }\r\n        }\r\n\r\n        // No new data in buffer to write\r\n        if (writing) {\r\n        \twriteBufferOld(buffer);\r\n        }\r\n    }\r\n    \r\n    @Deprecated\r\n    private void writeBufferOld(ByteBuffer buffer) {\r\n        channel.write(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {\r\n            @Override\r\n            public void completed(Integer result, ByteBuffer buffer) {\r\n                if (buffer.hasRemaining()) {\r\n                    channel.write(buffer, buffer, this);\r\n                } else {\r\n                    // Go back and check if there is new data to write\r\n                \twriteFromQueueOld();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void failed(Throwable exc, ByteBuffer attachment) {\r\n            }\r\n        });\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * Sends a message\r\n     * @param string the message\r\n     */\r\n    @Deprecated\r\n    public void writeStringMessageOld(String string) {\r\n    \twriteOld(ByteBuffer.wrap(string.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Send a message from a specific client\r\n     * @param client the message is sent from\r\n     * @param message to send\r\n     */\r\n    @Deprecated\r\n    public void writeMessageFromOld(AioServerChannel client, String message) {\r\n        if (dealer.serverAcceptsMessages()) {\r\n            //writeStringMessage(client.getUserName() + \": \" + message);\r\n        }\r\n    }\r\n    \r\n\r\n\t\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/define/AioServerDataDealer.java\npublic interface AioServerDataDealer {\r\n\t\r\n\tvoid serverOnConnect(AioServerChannel channel);\r\n    void serverBeforeRead(AioServerChannel channel);\r\n    void serverOnData(AioServerChannel channel, ByteBuffer buffer, int bytes);\r\n    void serverAfterWrite(AioServerChannel channel, ByteBuffer buffer, int bytes);\r\n    void serverOnError(AioServerChannel channel,Throwable exc, ByteBuffer attachment);\r\n    void serverOnClose(AioServerChannel channel);\r\n    boolean serverAcceptsMessages();\r\n    \r\n\r\n}\r\nsrc/main/java/shui/common/buffer/BufferTools.java\npublic class BufferTools {\r\n\r\n\tprivate final static BufferPoolNIO bp = new BufferPoolNIO(2 * 1024, 32 * 1024);\r\n\t\r\n\tpublic final static ByteBuffer getBuffer() {\r\n\t\t//ByteBuffer input = ByteBuffer.allocate(16 * 1024);\r\n\t\tByteBuffer input = bp.allocate();\r\n\t\treturn input;\r\n\t}\r\n\r\n\tpublic final static void returnBuffer(ByteBuffer buffer) {\r\n\t\tbp.recycle(buffer);\r\n\t\t\r\n\t}\r\n\tpublic final static byte[] getBuffer2Byte(ByteBuffer b) {\r\n\t\tint p = b.position();\r\n\t\tbyte[] r = new byte[p];\r\n\t\tif (b.position() != 0) {\r\n\t\t\tb.flip();\r\n\t\t}\r\n\t\tb.get(r, 0, p);\r\n\r\n\t\treturn r;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n\r\n}\r\nsrc/main/java/waterwave/net/aio/define/AioClientDataDealer.java\npublic interface AioClientDataDealer {\r\n\r\n    \r\n\tvoid clientBeforeRead(AioClientChannel channel);\r\n\tvoid clientOnConnect(AioClientChannel channel);\r\n\tvoid clientOnData(AioClientChannel channel, ByteBuffer buffer, int result);\r\n\tvoid clientAfterWrite(AioClientChannel channel, ByteBuffer buffer, int bytes);\r\n\tvoid clientOnError(AioClientChannel channel,Throwable exc, ByteBuffer attachment);\r\n    void clientOnClose(AioClientChannel channel);\r\n\tboolean clientAcceptsMessages();\r\n}\r\nsrc/main/java/shui/common/log/Logger.java\npublic abstract class Logger {\r\n\r\n\tpublic String threadInfo = null;\r\n\tpublic int level;\r\n\r\n\tprotected boolean printTime = true;\r\n\tprotected boolean printThreadInfo = true;\r\n\r\n\tpublic Logger() {\r\n\t}\r\n\r\n\tpublic Logger(boolean printTime) {\r\n\t\tthis();\r\n\t\tthis.printTime = printTime;\r\n\t}\r\n\r\n\t\r\n\tpublic abstract void log(int level, Object o) ;\r\n\tpublic abstract void log(int level, Object... os) ;\r\n\tpublic abstract PrintWriter getErrorWriter();\r\n\r\n\r\n\tpublic final static void log(byte[] bs) {\r\n\t\tfor (byte b : bs) {\r\n\t\t\tlog1(b);\r\n\t\t\tlog1(\"\\t\");\r\n\t\t}\r\n\t\tlog(\"\\t\");\r\n\t}\r\n\t\r\n\t\r\n\tpublic final static void log1(Object o) {\r\n\t\tSystem.out.print(o);\r\n\t}\r\n\t\r\n\tpublic final static void log(Object o) {\r\n\t\tSystem.out.println(o);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t}\r\n\r\n}\r\n", "answers": ["\t\t\t\tBufferTools.returnBuffer(b1);\r"], "length": 2646, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "2f63d9a3d25c12812b10eb407a92d3744aaa94835463eb5b"}
{"input": "from math import pi\nfrom PyQt5 import QtGui\nfrom PyQt5.QtCore import QLocale\nfrom PyQt5.QtWidgets import QComboBox, QLineEdit, QHBoxLayout, QTableWidget, QPushButton, QTableWidgetItem, QInputDialog\nfrom PyQt5.QtWidgets import QDialog\nfrom PyQt5.QtWidgets import QDialogButtonBox\nfrom PyQt5.QtWidgets import QGridLayout\nfrom PyQt5.QtWidgets import QLabel\nfrom PyQt5.QtWidgets import QVBoxLayout\nfrom PyQt5.QtWidgets import QWidget\nfrom Business.ParameterActions import create_new_standard, create_new_type, remove_standard, remove_type\nfrom Data.Axis import Axis\nfrom Data.Parameters import Parameters\nfrom Data.Proformer import ProformerType\nfrom GUI.Widgets.SketchViewWidget import SketchViewWidget\nfrom GUI.init import formula_from_locale, gui_scale, tr\n\t\tcontents_layout.addWidget(self._sa_combo_box, 1, 1)\n\t\tcontents_layout.addWidget(self._ea_combo_box, 2, 1)\n\t\tself.layout().addWidget(contents_widget)\n\t\tdialog_buttons = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)\n\t\tdialog_buttons.accepted.connect(self.accept)\n\t\tdialog_buttons.rejected.connect(self.reject)\n\t\tself.layout().addWidget(dialog_buttons)\n\n\tdef radius_param(self):\n\t\treturn self._radius_combo_box.currentText()\n\n\tdef start_angle_param(self):\n\t\treturn self._sa_combo_box.currentText()\n\n\tdef end_angle_param(self):\n\t\treturn self._ea_combo_box.currentText()\n\n\nclass StandardTypeManager(QDialog):\n\tdef __init__(self, parent, parameters):\n\t\tQDialog.__init__(self, parent)\n\t\tself._parameters = parameters\n\t\tself.setLayout(QVBoxLayout())\n\t\tdialog_buttons = QDialogButtonBox(QDialogButtonBox.Close)\n\t\tdialog_buttons.close.connect(self.accept)\n\t\tself.layout().addWidget(dialog_buttons)\n\n\nclass SketchMirrorDialog(QDialog):\n\tdef __init__(self, parent, sketch):\n\t\tQDialog.__init__(self, parent)\n\t\tself._sketch = sketch\n\t\tself.setWindowTitle(tr(\"Mirror\", 'dialogs'))\n\t\tself.setLayout(QVBoxLayout())\n\t\tcontents_widget = QWidget(self)\n\t\tcontents_layout = QGridLayout()\n\t\tcontents_widget.setLayout(contents_layout)\n\t\tself._mirror_type = ProformerType.Mirror\n\n\t\tcontents_layout.addWidget(QLabel(tr(\"Mirror type\", 'dialogs')), 0, 0)\n\t\tcontents_layout.addWidget(QLabel(tr(\"Mirror line\", 'dialogs')), 1, 0)\n\n\t\tself._mirror_type_combo_box = QComboBox()\n\t\tself._mirror_line_combo_box = QComboBox()\n\t\tself._mirror_type_combo_box.currentIndexChanged.connect(self.on_mirror_type_selection_changed)\n\n\t\tself._mirror_type_combo_box.addItem(ProformerType.Mirror.name, ProformerType.Mirror.value)\n\t\tself._mirror_type_combo_box.addItem(ProformerType.MirrorX.name, ProformerType.MirrorX.value)\n\t\tself._mirror_type_combo_box.addItem(ProformerType.MirrorY.name, ProformerType.MirrorY.value)\n\t\tself._mirror_type_combo_box.addItem(ProformerType.MirrorXY.name, ProformerType.MirrorXY.value)\n\t\tself._mirror_type_combo_box.setEditable(True)\n\t\t#self._mirror_line_combo_box.addItems(self._params)\n\t\tself._mirror_line_combo_box.setEditable(True)\n\t\t#self._ea_combo_box.addItems(self._params)\n\t\t#self._ea_combo_box.setEditable(True)\n\t\tcontents_layout.addWidget(self._mirror_type_combo_box, 0, 1)\n\t\tcontents_layout.addWidget(self._mirror_line_combo_box, 1, 1)\n\n\t\tself.layout().addWidget(contents_widget)\n\t\tself._sketch_view = SketchViewWidget(self, sketch, sketch.document)\n\t\tself._sketch_view.set_change_listener(self)\n\t\tself._sketch_view.edges_selectable = True\n\t\t#self._sketch_view.set_sketch(sketch)\n\t\tself.layout().addWidget(self._sketch_view)\n\n\t\tdialog_buttons = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)\n\t\tdialog_buttons.accepted.connect(self.accept)\n\t\tdialog_buttons.rejected.connect(self.reject)\n\t\tself.layout().addWidget(dialog_buttons)\n\t\tself.fill_mirror_axi()\n\n\t@property\n\tdef mirror_type(self):\n\t\treturn self._mirror_type\n\n\t@property\n\tdef mirror_axis(self):\n\t\treturn self._sketch.get_edge_by_name(self._mirror_line_combo_box.currentText())\n\n\tdef on_edge_selected(self, edge):\n\t\tself._mirror_line_combo_box.setCurrentText(edge.name)\n\n\tdef on_area_selected(self, area):\n\t\tself._area_combo_box.setCurrentText(area.name)\n\n\tdef on_mirror_type_selection_changed(self):\n\t\tindex = self._mirror_type_combo_box.currentIndex()\n\t\tif index == 0:\n\t\t\tself._mirror_type = ProformerType.Mirror\n\t\t\tself._mirror_line_combo_box.setEnabled(True)\n\t\t\tself._mirror_line_combo_box.setCurrentIndex(0)\n\t\telif index == 1:\n\t\t\tself._mirror_type = ProformerType.MirrorX\n\t\t\tself._mirror_line_combo_box.setEnabled(False)\n\t\t\tself._mirror_line_combo_box.setCurrentText(\"X axis\")\n\t\telif index == 2:\n\t\t\tself._mirror_type = ProformerType.MirrorY\n\t\t\tself._mirror_line_combo_box.setEnabled(False)\n\t\t\tself._mirror_line_combo_box.setCurrentText(\"Y axis\")\n\t\telse:\n\t\t\tself._mirror_type = ProformerType.MirrorXY\n\t\t\tself._mirror_line_combo_box.setEnabled(False)\n\t\t\tself._mirror_line_combo_box.setCurrentText(\"XY axis\")\n\n\tdef fill_mirror_axi(self):\n\t\tself._mirror_line_combo_box.clear()\n\t\t# self._mirror_line_combo_box.addItems(['X Axis', 'Y Axis'])\n\t\tedge_names = []\n\t\tsketch = self._sketch\n\t\tself._sketch_view.set_sketch(sketch)\n\t\tfor edge in sketch.get_edges():\n\t\t\tedge_names.append(edge.name)\n\t\tedge_names.sort()\n\t\tself._mirror_line_combo_box.addItems(edge_names)\n\nclass ParameterSelectWidget():\n\tdef __init__(self, parent, parameters, layout, row, caption=\"\"):\n\t\tself._parameters = parameters\n\n\t\tself._caption_label = QLabel(caption)\n", "context": "GUI/Widgets/SketchViewWidget.py\nclass SketchViewWidget(QWidget):\n\tdef __init__(self, parent, sketch, document):\n\t\tQWidget.__init__(self, parent)\n\t\tself._doc = document\n\t\tself._sketch = sketch\n\t\tself.setMinimumHeight(250)\n\t\tself.setMinimumWidth(250)\n\t\tself.setMouseTracking(True)\n\t\tself._show_areas = False\n\t\tself._areas_selectable = False\n\t\tself._edges_selectable = False\n\t\tself._keypoints_selectable = False\n\t\tself._change_listener = None\n\t\tself._selected_areas = []\n\t\tself._selected_edges = []\n\t\tself._selected_kps = []\n\t\tself._area_hover = None\n\t\tself._edge_hover = None\n\t\tself._kp_hover = None\n\t\tself._mouse_position = None\n\n\t@property\n\tdef selected_kps(self):\n\t    return self._selected_kps\n\n\t@selected_kps.setter\n\tdef selected_kps(self, value):\n\t\tself._selected_kps = value\n\t\tself.update()\n\n\tdef mouseMoveEvent(self, q_mouse_event):\n\t\tposition = q_mouse_event.pos()\n\t\tif self._mouse_position is not None:\n\t\t\tmouse_move_x = self._mouse_position.x() - position.x()\n\t\t\tmouse_move_y = self._mouse_position.y() - position.y()\n\t\telse:\n\t\t\tmouse_move_x = 0\n\t\t\tmouse_move_y = 0\n\t\tself._mouse_position = position\n\t\tif self._sketch is None:\n\t\t\treturn\n\t\tupdate_view = False\n\t\tif self._area_hover is not None or self._edge_hover is not None:\n\t\t\tupdate_view = True\n\t\tself._area_hover = None\n\t\tself._edge_hover = None\n\t\twidth = self.width() / 2\n\t\theight = self.height() / 2\n\t\tlimits = self._sketch.get_limits()\n\t\tsketch_width = limits[2] - limits[0]\n\t\tsketch_height = limits[3] - limits[1]\n\t\tscale_x = self.width() / sketch_width\n\t\tscale_y = self.height() / sketch_height\n\t\tscale = min(scale_x, scale_y) * 0.9\n\t\toffset = Vertex(-limits[0] - sketch_width / 2, -limits[1] - sketch_height / 2)\n\t\tx = (self._mouse_position.x() - width) / scale - offset.x\n\t\ty = -((self._mouse_position.y() - height) / scale + offset.y)\n\n\n\t\tif self._keypoints_selectable:\n\t\t\tfor key_point in self._sketch.get_keypoints():\n\t\t\t\tx1 = key_point.x\n\t\t\t\ty1 = key_point.y\n\t\t\t\tif abs(x1 - x) < 5 / scale and abs(y1 - y) < 5 / scale:\n\t\t\t\t\tself._kp_hover = key_point\n\t\t\t\t\tupdate_view = True\n\t\t\t\t\tbreak\n\t\tif self._edges_selectable:\n\t\t\tsmallest_dist = 10e10\n\t\t\tclosest_edge = None\n\t\t\tfor edge in self._sketch.get_edges():\n\t\t\t\tdist = edge.distance(Vertex(x, y, 0))\n\t\t\t\tif dist < smallest_dist:\n\t\t\t\t\tsmallest_dist = dist\n\t\t\t\t\tclosest_edge = edge\n\t\t\tif smallest_dist * scale < 10:\n\t\t\t\tself._edge_hover = closest_edge\n\t\t\t\tupdate_view = True\n\t\tif self._areas_selectable and self._edge_hover is None:\n\t\t\tfor area in self._sketch.get_areas():\n\t\t\t\tif area.inside(Vertex(x, y, 0)):\n\t\t\t\t\tself._area_hover = area\n\t\t\t\t\tupdate_view = True\n\t\t\t\t\tbreak\n\t\tif update_view:\n\t\t\tself.update()\n\n\tdef mousePressEvent(self, q_mouse_event):\n\t\tself.setFocus()\n\t\tposition = q_mouse_event.pos()\n\t\tif q_mouse_event.button() == 4:\n\t\t\treturn\n\t\tif q_mouse_event.button() == 1:\n\t\t\tpass\n\n\t\tif self._kp_hover is not None and self._keypoints_selectable:\n\t\t\tself._selected_kps.clear()\n\t\t\tself._selected_kps.append(self._kp_hover)\n\t\t\tif self._change_listener is not None:\n\t\t\t\tself._change_listener.on_kp_selected(self._kp_hover)\n\t\t\tself.update()\n\n\t\tif self._edge_hover is not None and self._edges_selectable:\n\t\t\tself._selected_edges.clear()\n\t\t\tself._selected_edges.append(self._edge_hover)\n\t\t\tif self._change_listener is not None:\n\t\t\t\tself._change_listener.on_edge_selected(self._edge_hover)\n\t\t\tself.update()\n\n\t\tif self._area_hover is not None and self._areas_selectable and self._edge_hover is None:\n\t\t\tself._selected_areas.clear()\n\t\t\tself._selected_areas.append(self._area_hover)\n\t\t\tif self._change_listener is not None:\n\t\t\t\tself._change_listener.on_area_selected(self._area_hover)\n\t\t\tself.update()\n\n\t@property\n\tdef show_areas(self):\n\t\treturn self._show_areas\n\n\t@show_areas.setter\n\tdef show_areas(self, value):\n\t\tself._show_areas = value\n\t\tself.update()\n\n\t@property\n\tdef areas_selectable(self):\n\t\treturn self._areas_selectable\n\n\t@areas_selectable.setter\n\tdef areas_selectable(self, value):\n\t\tself._areas_selectable = value\n\n\tdef set_sketch(self, sketch):\n\t\tself._sketch = sketch\n\t\tself.update()\n\n\t@property\n\tdef edges_selectable(self):\n\t\treturn self._edges_selectable\n\n\t@edges_selectable.setter\n\tdef edges_selectable(self, value):\n\t\tself._edges_selectable = value\n\n\t@property\n\tdef keypoints_selectable(self):\n\t  return self._keypoints_selectable\n\n\t@keypoints_selectable.setter\n\tdef keypoints_selectable(self, value):\n\t\tself._keypoints_selectable = value\n\n\tdef set_change_listener(self, change_listener):\n\t\tself._change_listener = change_listener\n\n\tdef paintEvent(self, event):\n\t\tqp = QPainter()\n\t\tqp.begin(self)\n\t\tqp.setRenderHint(QPainter.Antialiasing)\n\n\t\tqp.fillRect(event.rect(), QColor(255, 255, 255))\n\t\thalf_width = self.width() / 2\n\t\thalf_height = self.height() / 2\n\t\tcenter = Vertex(half_width, half_height)\n\t\tif self._sketch is not None:\n\t\t\tlimits = self._sketch.get_limits()\n\t\t\tsketch_width = limits[2] - limits[0]\n\t\t\tsketch_height = limits[3] - limits[1]\n\t\t\tscale_x = self.width() / sketch_width\n\t\t\tscale_y = self.height() / sketch_height\n\t\t\tscale = min(scale_x, scale_y) * 0.9\n\n\t\t\tpens = create_pens(self._doc, 6000/scale, QColor(0, 0, 0))\n\t\t\tpens_hover = create_pens(self._doc, 6000/scale, QColor(100, 100, 200), 1)\n\t\t\tpens_select_high = create_pens(self._doc, 6000/scale, QColor(255, 0, 0), 2)\n\t\t\tpens_select = create_pens(self._doc, 6000/scale, QColor(255, 255, 255))\n\n\t\t\toffset = Vertex(-limits[0] - sketch_width / 2, -limits[1] - sketch_height / 2)\n\t\t\tdraw_sketch(qp, self._sketch, scale, 1/scale, offset, center, 0, pens, {})\n\n\t\t\tqp.save()\n\t\t\tqp.translate(center.x, center.y)\n\t\t\tqp.scale(scale, scale)\n\t\t\tqp.translate(offset.x, -offset.y)\n\t\t\tfor edge in self._selected_edges:\n\t\t\t\tdraw_edge(edge, qp, pens_select_high, None)\n\t\t\tfor edge in self._selected_edges:\n\t\t\t\tdraw_edge(edge, qp, pens_select, None)\n\t\t\tif self._keypoints_selectable:\n\t\t\t\tqp.setPen(pens['default'])\n\t\t\t\tfor kp in self._sketch.get_keypoints():\n\t\t\t\t\tdraw_kp(qp, kp, scale)\n\t\t\t\tif self._kp_hover:\n\t\t\t\t\tqp.setPen(pens_hover['default'])\n\t\t\t\t\tdraw_kp(qp, self._kp_hover, scale)\n\t\t\tif len(self._selected_kps) > 0:\n\t\t\t\tqp.setPen(pens_select_high['default'])\n\t\t\t\tfor kp in self._selected_kps:\n\t\t\t\t\tdraw_kp(qp, kp, scale)\n\t\t\tif self._edge_hover is not None:\n\t\t\t\tdraw_edge(self._edge_hover, qp, pens_hover, None)\n\t\t\tif self._show_areas:\n\t\t\t\tqp.setPen(pens['default'])\n\t\t\t\tfor area in self._sketch.get_areas():\n\t\t\t\t\tdraw_area(area, qp, True, QBrush(QColor(150, 150, 150, 80)), 1/scale, None)\n\t\t\t\tfor area in self._selected_areas:\n\t\t\t\t\tdraw_area(area, qp, True, QBrush(QColor(150, 150, 200, 150)), 1/scale, None)\n\t\t\t\tif self._area_hover is not None:\n\t\t\t\t\tdraw_area(self._area_hover, qp, True, QBrush(QColor(150, 150, 200, 80)), 1/scale, None)\n\t\t\tqp.restore()\n\n\t\tqp.end()\nBusiness/ParameterActions.py\ndef remove_standard(parameters_object: Parameters, standard_name):\n\tparameters_object.remove_standard(standard_name)\nData/Proformer.py\nclass ProformerType(Enum):\n\tCircular = 0\n\tDiamond = 1\n\tTriangular = 2\n\tSquare = 3\n\tRectangular = 4\n\tMirror = 5\n\tMirrorX = 6\n\tMirrorY = 7\n\tMirrorXY = 8\nBusiness/ParameterActions.py\ndef create_new_standard(parameters_object: Parameters, standard_name):\n\tparameters_object.make_standard(standard_name)\nData/Axis.py\nclass Axis(NamedObservableObject, IdObject):\n\tdef __init__(self, document, name=\"New Axis\"):\n\t\tNamedObservableObject.__init__(self, name)\n\t\tIdObject.__init__(self)\n\t\tself._doc = document\n\t\tself._sketch = None\n\t\tself._edge = None\n\t\tself._pm = None\n\t\tself._origo = Vertex()\n\t\tself._direction = Vertex(1, 1, 1)\n\n\t@property\n\tdef direction(self):\n\t\treturn self._direction\n\n\t@property\n\tdef origo(self):\n\t\treturn self._origo\n\n\tdef on_edge_changed(self, event):\n\t\told_value = self._origo\n\t\tkps = self._edge.get_end_key_points()\n\t\tself._origo.x = kps[0].x\n\t\tself._origo.y = kps[0].y\n\t\tself._origo.z = kps[0].z\n\t\tself._direction.xyz = kps[1].xyz - kps[0].xyz\n\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectChanged, event.sender))\n\t\tself.changed(ValueChangeEvent(self, 'origo', old_value, self._origo))\n\t\tself._pm = None\n\t\tif event.type == ChangeEvent.Deleted:\n\t\t\tevent.sender.remove_change_handler(self.on_edge_changed)\n\t\t\tself._sketch = None\n\n\tdef set_edge_governor(self, edge, sketch):\n\t\tif self._edge is not None:\n\t\t\tself._edge.remove_change_handler(self.on_edge_changed)\n\t\tself._edge = edge\n\t\tself._sketch = sketch\n\t\tkps = self._edge.get_end_key_points()\n\t\tself._origo.x = kps[0].x\n\t\tself._origo.y = kps[0].y\n\t\tself._origo.z = kps[0].z\n\t\tself._direction.xyz = kps[1].xyz - kps[0].xyz\n\t\tself._edge.add_change_handler(self.on_edge_changed)\n\n\tdef get_projection_matrix(self):\n\t\tif self._pm is None:\n\t\t\tif self._direction.z == 0:\n\t\t\t\tangle = atan2(self._direction.y, self._direction.x) + pi / 2\n\t\t\telif self._direction.x == 0:\n\t\t\t\tangle = atan2(self._direction.y, self._direction.z) + pi / 2\n\t\t\telse:\n\t\t\t\tangle = atan2(self._direction.x, self._direction.z) + pi / 2\n\t\t\td2 = np.array([cos(angle), sin(angle), self._direction.z])\n\t\t\tcp = np.cross(self._direction.xyz, d2)\n\t\t\td2 = cp / np.linalg.norm(cp)\n\t\t\tcp = np.cross(self._direction.xyz, d2)\n\t\t\td3 = cp / np.linalg.norm(cp)\n\t\t\td1 = self._direction.xyz / np.linalg.norm(self._direction.xyz)\n\t\t\tpm = np.array([d1, d2, d3])\n\t\t\tself._pm = pm\n\t\telse:\n\t\t\tpm = self._pm\n\t\treturn pm\n\n\tdef distance(self, point):\n\t\tp1 = self._origo.xyz\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point.xyz - p1)\n\t\tnewp[0] = 0.0\n\t\tdistance = np.linalg.norm(newp)\n\t\treturn distance\n\n\tdef distance_xyz(self, point):\n\t\tp1 = self._origo.xyz\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point - p1)\n\t\tnewp[0] = 0.0\n\t\tdistance = np.linalg.norm(newp)\n\t\treturn distance\n\n\tdef project_point(self, point):\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point.xyz - self._origo.xyz)\n\t\treturn newp[0] * pm[0] + self._origo.xyz\n\n\tdef project_point_xyz(self, point):\n\t\tpm = self.get_projection_matrix()\n\t\tnewp = pm.dot(point - self._origo.xyz)\n\t\treturn newp[0] * pm[0] + self._origo.xyz\n\n\t@property\n\tdef _sketch_uid(self):\n\t\tif self._sketch is None:\n\t\t\treturn None\n\t\telse:\n\t\t\treturn self._sketch.uid\n\n\t@property\n\tdef _edge_uid(self):\n\t\tif self._edge is None:\n\t\t\treturn None\n\t\telse:\n\t\t\treturn self._edge.uid\n\n\tdef serialize_json(self):\n\t\treturn {\n\t\t\t'no': NamedObservableObject.serialize_json(self),\n\t\t\t'uid': IdObject.serialize_json(self),\n\t\t\t'sketch_uid': self._sketch_uid,\n\t\t\t'edge_uid': self._edge_uid,\n\t\t\t'origo': self._origo,\n\t\t\t'direction': self._direction\n\t\t}\n\n\t@staticmethod\n\tdef deserialize(data, document):\n\t\taxis = Axis(document)\n\t\tif data is not None:\n\t\t\taxis.deserialize_data(data)\n\t\treturn axis\n\n\tdef deserialize_data(self, data):\n\t\tIdObject.deserialize_data(self, data.get('uid', {'uid': self.uid}))\n\t\tNamedObservableObject.deserialize_data(self, data['no'])\n\t\tsketch_uid = data['sketch_uid']\n\t\tif sketch_uid is not None:\n\t\t\tself._sketch = self._doc.get_geometries().get_geometry(sketch_uid)\n\t\tedge_uid = data['edge_uid']\n\t\tif self._sketch is not None and edge_uid is not None:\n\t\t\tself._edge = self._sketch.get_edge(edge_uid)\n\t\t\tself._edge.add_change_handler(self.on_edge_changed)\n\t\tself._origo = Vertex.deserialize(data['origo'])\n\t\tself._direction = Vertex.deserialize(data['direction'])\n\t\tif self._edge is not None:\n\t\t\tself.on_edge_changed(ChangeEvent(self, ChangeEvent.ObjectChanged, self._edge))\nGUI/init.py\ndef formula_from_locale(formula):\n\tlocale = QLocale()\n\tif locale.decimalPoint() == \",\":\n\t\treturn formula.replace(\",\", \".\").replace(\";\", \",\")\n\treturn formula\nGUI/init.py\ndef tr(string, context_name='app'):\n\tvalue = QCoreApplication.translate(context_name, string)\n\ttry:\n\t\tcontext = contexts[context_name]\n\texcept KeyError:\n\t\tcontexts[context_name] = {}\n\t\tcontext = contexts[context_name]\n\tcontext[string] = value\n\treturn value\nGUI/init.py\ndef gui_scale():\n\tscreen = QApplication.screens()[0];\n\tdpi = screen.logicalDotsPerInch()\n\treturn dpi / 96\nData/Parameters.py\nclass Parameters(ParametersBase):\n\tdef __init__(self, name, parent=None):\n\t\tParametersBase.__init__(self, name)\n\t\tself._parameter_list = []\n\t\tself._params = {}\n\t\tself._parent = parent\n\t\tself._custom_name_getter = None\n\t\tself._standards = {}\n\t\tself._current_standard_name = \"Normal\"\n\t\tself._current_type_name = \"Default\"\n\t\tself._current_type = self.make_type(self._current_standard_name, self._current_type_name)\n\n\t@property\n\tdef document(self):\n\t\tif self._parent is None:\n\t\t\treturn self\n\t\telse:\n\t\t\treturn self._parent.document\n\n\t@property\n\tdef parent(self):\n\t\treturn self._parent\n\n\tdef param_in_current_type(self, param):\n\t\tif self._current_type is None:\n\t\t\treturn False\n\t\treturn param.uid in self._current_type\n\n\tdef make_standard(self, name):\n\t\tstandard = {}\n\t\tself._standards[name] = standard\n\t\treturn standard\n\n\t@property\n\tdef standards(self):\n\t\treturn list(self._standards.keys())\n\n\t@property\n\tdef standard(self):\n\t\treturn self._current_standard_name\n\n\t@standard.setter\n\tdef standard(self, value):\n\t\tif value in self._standards:\n\t\t\tself._current_standard_name = value\n\t\t\tself._current_type_name = \"\"\n\t\t\tself._current_type = None\n\n\t@property\n\tdef types(self):\n\t\treturn self._standards[self._current_standard_name].keys()\n\n\tdef get_types_from_standard(self, standard):\n\t\tif standard in self._standards:\n\t\t\treturn list(self._standards[standard].keys())\n\t\treturn []\n\n\tdef make_type(self, standard_name, type_name):\n\t\tif standard_name not in self._standards:\n\t\t\tstandard = {}\n\t\t\tself._standards[standard_name] = standard\n\t\telse:\n\t\t\tstandard = self._standards[standard_name]\n\t\ttype = {}\n\t\tstandard[type_name] = type\n\t\treturn type\n\n\t@property\n\tdef type(self):\n\t\treturn self._current_type_name\n\n\t@type.setter\n\tdef type(self, type_name):\n\t\tif type_name in self._standards[self._current_standard_name]:\n\t\t\tself._current_type = self._standards[self._current_standard_name][type_name]\n\t\t\tself._current_type_name = type_name\n\t\t\tif self._current_type is None:\n\t\t\t\treturn\n\t\t\tfor param_definition_tuple in self._current_type.items():\n\t\t\t\tuid = param_definition_tuple[0]\n\t\t\t\tval = param_definition_tuple[1]\n\t\t\t\tif uid in self._params:\n\t\t\t\t\tparam = self._params[uid]\n\t\t\t\t\told_value = param.value\n\t\t\t\t\tparam.internal_formula = val['if']\n\t\t\t\t\tparam.internal_value = param.evaluate(None)\n\t\t\t\t\tchange_object = {\n\t\t\t\t\t\t'new value': param.value,\n\t\t\t\t\t\t'old value': old_value,\n\t\t\t\t\t\t'instance': None\n\t\t\t\t\t}\n\t\t\t\t\tparam.changed(ChangeEvent(param, ChangeEvent.ValueChanged, change_object))\n\t\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectChanged, self))\n\n\tdef _add_parameter_object(self, param):\n\t\tparam.add_change_handler(self.on_parameter_changed)\n\t\tself.changed(ChangeEvent(self, ChangeEvent.BeforeObjectAdded, param))\n\t\tself._params[param.uid] = param\n\t\tself._parameter_list.append(param.uid)\n\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectAdded, param))\n\n\tdef _remove_parameter_object(self, uid):\n\t\tif uid in self._params:\n\t\t\tself._params.pop(uid)\n\n\tdef get_parameter_by_uid(self, uid) -> Parameter:\n\t\tif uid in self._params:\n\t\t\treturn self._params[uid]\n\t\telif self._parent is not None:\n\t\t\treturn self._parent.get_parameter_by_uid(uid)\n\t\telse:\n\t\t\treturn None\n\n\tdef get_parameter_by_name(self, name) -> Parameter:\n\t\tparam = None\n\t\tfor prm in self._params.values():\n\t\t\tif prm.name == name:\n\t\t\t\tparam = prm\n\t\tif param is None and self._custom_name_getter is not None:\n\t\t\tparam = self._custom_name_getter(name)\n\t\tif param is None and self._parent is not None:\n\t\t\tparam = self._parent.get_parameter_by_name(name)\n\n\t\treturn param\n\n\tdef get_all_local_parameters(self):\n\t\tparams = list(self._params.items())\n\t\treturn params\n\n\tdef get_all_parameters(self):\n\t\tparams = list(self._params.values())\n\t\tif self._parent is not None:\n\t\t\tparams.extend(self._parent.get_all_parameters())\n\t\treturn params\n\n\tdef create_parameter(self, name=None, value=0.0):\n\t\tif name is None:\n\t\t\tif self._parent is None:\n\t\t\t\tname = \"Global\" + str(len(self._parameter_list))\n\t\t\telse:\n\t\t\t\tname = self.name + str(len(self._parameter_list))\n\t\tparam = Parameter(self, name, value)\n\t\tself._add_parameter_object(param)\n\t\treturn param\n\n\tdef delete_parameter(self, uid):\n\t\tparam = self.get_parameter_by_uid(uid)\n\t\tif param is not None:\n\t\t\tparam.remove_change_handler(self.on_parameter_changed)\n\t\t\tself.changed(ChangeEvent(self, ChangeEvent.BeforeObjectRemoved, param))\n\t\t\tself._parameter_list.remove(uid)\n\t\t\tself.changed(ChangeEvent(self, ChangeEvent.ObjectRemoved, param))\n\t\t\tself._remove_parameter_object(uid)\n\t\t\tparam.changed(ChangeEvent(param, ChangeEvent.Deleted, param))\n\n\tdef delete_parameters(self, params):\n\t\tfor param in params:\n\t\t\tif param.uid in self._parameter_list:\n\t\t\t\tself.delete_parameter(param.uid)\n\n\tdef on_parameter_changed(self, event):\n\t\tparam = event.sender\n\t\tself.changed(ChangeEvent(self, event.type, event.sender))\n\t\tif self._current_type is not None and param.uid in self._params:\n\t\t\tif 'instance' in event.object and 'new formula' in event.object:\n\t\t\t\tif event.object['instance'] is None and event.object['new formula'] != event.object['old formula']:\n\n\t\t\t\t\tif param.uid in self._current_type:\n\t\t\t\t\t\tpredef = self._current_type[param.uid]\n\t\t\t\t\telse:\n\t\t\t\t\t\tpredef = {}\n\t\t\t\t\t\tself._current_type[param.uid] = predef\n\t\t\t\t\tpredef['if'] = param.internal_formula\n\t\t\t\t\tpredef['iv'] = param.internal_value\n\n\tdef get_index_of(self, parameter):\n\t\tif parameter.uid in self._parameter_list:\n\t\t\treturn self._parameter_list.index(parameter.uid)\n\t\telse:\n\t\t\treturn -1\n\n\t@property\n\tdef length(self):\n\t\treturn len(self._parameter_list)\n\n\t@property\n\tdef length_all(self):\n\t\tif self._parent is not None:\n\t\t\treturn self._parent.length_all + self.length\n\t\telse:\n\t\t\treturn self.length\n\n\tdef get_parameter_item(self, index):\n\t\tif index >= self.length:\n\t\t\treturn self._parent.get_parameter_item(index - self.length)\n\t\telse:\n\t\t\tuid = self._parameter_list[index]\n\t\tparam = self.get_parameter_by_uid(uid)\n\t\treturn param\n\n\tdef serialize_json(self):\n\t\treturn {\n\t\t\t'name': self._name,\n\t\t\t'params': self._params,\n\t\t\t'parameter_list': self._parameter_list,\n\t\t\t'pps': self._standards,\n\t\t\t'csn': self._current_standard_name,\n\t\t\t'ctn': self._current_type_name\n\t\t}\n\n\t@staticmethod\n\tdef deserialize(data, parent):\n\t\tparam = Parameters(parent)\n\t\tparam.deserialize_data(data)\n\t\treturn param\n\n\tdef deserialize_data(self, data):\n\t\tself._parameter_list = data.get('parameter_list', [])\n\t\tself._name = data.get('name', 'name missing')\n\t\tself._standards = data.get('pps', self._standards)\n\t\tself._current_standard_name = data.get(\"csn\", self._current_standard_name)\n\t\tself._current_type_name = data.get(\"ctn\", self._current_type_name)\n\t\tself._current_type = self._standards[self._current_standard_name][self._current_type_name]\n\t\tfor param_data in data.get('params', {}).items():\n\t\t\tparam = Parameter.deserialize(param_data[1], self)\n\t\t\tself._params[param.uid] = param\n\t\t\tparam.add_change_handler(self.on_parameter_changed)\n\n\t\tfor param_tuple in self._params.items():\n\t\t\tif param_tuple[1].formula != '':\n\t\t\t\ttry:\n\t\t\t\t\tparam_tuple[1].value = param_tuple[1].formula\n\t\t\t\texcept Exception as e:\n\t\t\t\t\tpass\nBusiness/ParameterActions.py\ndef remove_type(parameters_object: Parameters, standard_name, type_name):\n\tparameters_object.remove_type(standard_name, type_name)\nBusiness/ParameterActions.py\ndef create_new_type(parameters_object: Parameters, standard_name, type_name):\n\tparameters_object.make_type(standard_name, type_name)\n", "answers": ["\t\tself._caption_label.setMinimumWidth(100*gui_scale())"], "length": 2012, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "4d2668d05f3f636a1bb6b0389a03b382f3f3e06b19dec51d"}
{"input": "import re\nimport struct\nfrom itertools import zip_longest\nfrom mutagen._tags import Tags\nfrom mutagen._util import DictProxy, convert_error, read_full\nfrom ._util import BitPaddedInt, unsynch, ID3JunkFrameError, \\\n    ID3EncryptionUnsupportedError, is_valid_frame_id, error, \\\n    ID3NoHeaderError, ID3UnsupportedVersionError, ID3SaveConfig\nfrom ._frames import TDRC, APIC, TDOR, TIME, TIPL, TORY, TDAT, Frames_2_2, \\\n    TextFrame, TYER, Frame, IPLS, Frames\n                timestamps.append(timestamp)\n        if timestamps and \"TDRC\" not in self:\n            self.add(TDRC(encoding=0, text=timestamps))\n\n        # TORY can be the first part of a TDOR.\n        if \"TORY\" in self:\n            f = self.pop(\"TORY\")\n            if \"TDOR\" not in self:\n                try:\n                    self.add(TDOR(encoding=0, text=str(f)))\n                except UnicodeDecodeError:\n                    pass\n\n        # IPLS is now TIPL.\n        if \"IPLS\" in self:\n            f = self.pop(\"IPLS\")\n            if \"TIPL\" not in self:\n                self.add(TIPL(encoding=f.encoding, people=f.people))\n\n        # These can't be trivially translated to any ID3v2.4 tags, or\n        # should have been removed already.\n        for key in [\"RVAD\", \"EQUA\", \"TRDA\", \"TSIZ\", \"TDAT\", \"TIME\"]:\n            if key in self:\n                del(self[key])\n\n        # Recurse into chapters\n        for f in self.getall(\"CHAP\"):\n            f.sub_frames.update_to_v24()\n        for f in self.getall(\"CTOC\"):\n            f.sub_frames.update_to_v24()\n\n    def update_to_v23(self):\n        \"\"\"Convert older (and newer) tags into an ID3v2.3 tag.\n\n        This updates incompatible ID3v2 frames to ID3v2.3 ones. If you\n        intend to save tags as ID3v2.3, you must call this function\n        at some point.\n\n        If you want to to go off spec and include some v2.4 frames\n        in v2.3, remove them before calling this and add them back afterwards.\n        \"\"\"\n\n        self.__update_common()\n\n        # TMCL, TIPL -> TIPL\n        if \"TIPL\" in self or \"TMCL\" in self:\n            people = []\n            if \"TIPL\" in self:\n                f = self.pop(\"TIPL\")\n                people.extend(f.people)\n            if \"TMCL\" in self:\n                f = self.pop(\"TMCL\")\n                people.extend(f.people)\n            if \"IPLS\" not in self:\n                self.add(IPLS(encoding=f.encoding, people=people))\n\n        # TDOR -> TORY\n        if \"TDOR\" in self:\n            f = self.pop(\"TDOR\")\n            if f.text:\n                d = f.text[0]\n                if d.year and \"TORY\" not in self:\n                    self.add(TORY(encoding=f.encoding, text=\"%04d\" % d.year))\n\n        # TDRC -> TYER, TDAT, TIME\n        if \"TDRC\" in self:\n            f = self.pop(\"TDRC\")\n            if f.text:\n                d = f.text[0]\n                if d.year and \"TYER\" not in self:\n                    self.add(TYER(encoding=f.encoding, text=\"%04d\" % d.year))\n                if d.month and d.day and \"TDAT\" not in self:\n                    self.add(TDAT(encoding=f.encoding,\n                                  text=\"%02d%02d\" % (d.day, d.month)))\n                if d.hour and d.minute and \"TIME\" not in self:\n                    self.add(TIME(encoding=f.encoding,\n                                  text=\"%02d%02d\" % (d.hour, d.minute)))\n\n        # New frames added in v2.4\n        v24_frames = [\n            'ASPI', 'EQU2', 'RVA2', 'SEEK', 'SIGN', 'TDEN', 'TDOR',\n            'TDRC', 'TDRL', 'TDTG', 'TIPL', 'TMCL', 'TMOO', 'TPRO',\n            'TSOA', 'TSOP', 'TSOT', 'TSST',\n        ]\n\n        for key in v24_frames:\n            if key in self:\n                del(self[key])\n\n        # Recurse into chapters\n        for f in self.getall(\"CHAP\"):\n            f.sub_frames.update_to_v23()\n        for f in self.getall(\"CTOC\"):\n            f.sub_frames.update_to_v23()\n\n    def _copy(self):\n        \"\"\"Creates a shallow copy of all tags\"\"\"\n\n        items = self.items()\n        subs = {}\n        for f in (self.getall(\"CHAP\") + self.getall(\"CTOC\")):\n            subs[f.HashKey] = f.sub_frames._copy()\n        return (items, subs)\n\n    def _restore(self, value):\n        \"\"\"Restores the state copied with _copy()\"\"\"\n\n        items, subs = value\n        self.clear()\n        for key, value in items:\n            self[key] = value\n            if key in subs:\n                value.sub_frames._restore(subs[key])\n\n\ndef save_frame(frame, name=None, config=None):\n    if config is None:\n        config = ID3SaveConfig()\n\n    flags = 0\n", "context": "mutagen/id3/_frames.py\ndef _bytes2key(b):\n    def __init__(self, *args, **kwargs):\n    def __setattr__(self, name, value):\n    def _setattr(self, name, value):\n    def _to_other(self, other):\n    def _merge_frame(self, other):\n    def _upgrade_frame(self):\n    def _get_v23_frame(self, **kwargs):\n    def HashKey(self):\n    def FrameID(self):\n    def __repr__(self):\n    def _readData(self, id3, data):\n    def _writeData(self, config=None):\n    def pprint(self):\n    def _pprint(self):\n    def _fromData(cls, header, tflags, data):\n    def __hash__(self: object):\n    def HashKey(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def __getitem__(self, item):\n    def __iter__(self):\n    def append(self, value):\n    def extend(self, value):\n    def _merge_frame(self, other):\n    def _pprint(self):\n    def __pos__(self):\n    def __pos__(self):\n    def __bytes__(self):\n    def __str__(self):\n    def _pprint(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def __get_genres(self):\n    def __set_genres(self, genres):\n    def __decode(self, value):\n    def _pprint(self):\n    def HashKey(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def _pprint(self):\n    def __eq__(self, other):\n    def __str__(self):\n    def __bytes__(self):\n    def HashKey(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def HashKey(self):\n    def _merge_frame(self, other):\n    def _pprint(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def _pprint(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def _pprint(self):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def __pos__(self):\n    def HashKey(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(s, o):\n    def _pprint(self):\n    def HashKey(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __bytes__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __pos__(self):\n    def __bytes__(self):\n    def __str__(self):\n    def __eq__(self, other):\n    def HashKey(self):\n    def __bytes__(self):\n    def __eq__(self, other):\n    def _pprint(self):\n    def HashKey(self):\n    def __bytes__(self):\n    def __eq__(self, other):\n    def __pos__(self):\n    def __eq__(self, other):\n    def __eq__(self, other):\n    def _to_other(self, other):\n    def _to_other(self, other):\n    def __eq__(self, other):\n    def _to_other(self, other):\nclass Frame(object):\nclass CHAP(Frame):\nclass CTOC(Frame):\nclass TextFrame(Frame):\nclass NumericTextFrame(TextFrame):\nclass NumericPartTextFrame(TextFrame):\nclass TimeStampTextFrame(TextFrame):\nclass UrlFrame(Frame):\nclass UrlFrameU(UrlFrame):\nclass TALB(TextFrame):\nclass TBPM(NumericTextFrame):\nclass TCOM(TextFrame):\nclass TCON(TextFrame):\nclass TCOP(TextFrame):\nclass TCMP(NumericTextFrame):\nclass TDAT(TextFrame):\nclass TDEN(TimeStampTextFrame):\nclass TDES(TextFrame):\nclass TKWD(TextFrame):\nclass TCAT(TextFrame):\nclass MVNM(TextFrame):\nclass MVN(MVNM):\nclass MVIN(NumericPartTextFrame):\nclass MVI(MVIN):\nclass GRP1(TextFrame):\nclass GP1(GRP1):\nclass TDOR(TimeStampTextFrame):\nclass TDLY(NumericTextFrame):\nclass TDRC(TimeStampTextFrame):\nclass TDRL(TimeStampTextFrame):\nclass TDTG(TimeStampTextFrame):\nclass TENC(TextFrame):\nclass TEXT(TextFrame):\nclass TFLT(TextFrame):\nclass TGID(TextFrame):\nclass TIME(TextFrame):\nclass TIT1(TextFrame):\nclass TIT2(TextFrame):\nclass TIT3(TextFrame):\nclass TKEY(TextFrame):\nclass TLAN(TextFrame):\nclass TLEN(NumericTextFrame):\nclass TMED(TextFrame):\nclass TMOO(TextFrame):\nclass TOAL(TextFrame):\nclass TOFN(TextFrame):\nclass TOLY(TextFrame):\nclass TOPE(TextFrame):\nclass TORY(NumericTextFrame):\nclass TOWN(TextFrame):\nclass TPE1(TextFrame):\nclass TPE2(TextFrame):\nclass TPE3(TextFrame):\nclass TPE4(TextFrame):\nclass TPOS(NumericPartTextFrame):\nclass TPRO(TextFrame):\nclass TPUB(TextFrame):\nclass TRCK(NumericPartTextFrame):\nclass TRDA(TextFrame):\nclass TRSN(TextFrame):\nclass TRSO(TextFrame):\nclass TSIZ(NumericTextFrame):\nclass TSO2(TextFrame):\nclass TSOA(TextFrame):\nclass TSOC(TextFrame):\nclass TSOP(TextFrame):\nclass TSOT(TextFrame):\nclass TSRC(TextFrame):\nclass TSSE(TextFrame):\nclass TSST(TextFrame):\nclass TYER(NumericTextFrame):\nclass TXXX(TextFrame):\nclass WCOM(UrlFrameU):\nclass WCOP(UrlFrame):\nclass WFED(UrlFrame):\nclass WOAF(UrlFrame):\nclass WOAR(UrlFrameU):\nclass WOAS(UrlFrame):\nclass WORS(UrlFrame):\nclass WPAY(UrlFrame):\nclass WPUB(UrlFrame):\nclass WXXX(UrlFrame):\nclass PairedTextFrame(Frame):\nclass TIPL(PairedTextFrame):\nclass TMCL(PairedTextFrame):\nclass IPLS(TIPL):\nclass BinaryFrame(Frame):\nclass MCDI(BinaryFrame):\nclass ETCO(Frame):\nclass MLLT(Frame):\nclass SYTC(Frame):\nclass USLT(Frame):\nclass SYLT(Frame):\nclass COMM(TextFrame):\nclass RVA2(Frame):\nclass EQU2(Frame):\nclass RVAD(Frame):\nclass RVRB(Frame):\nclass APIC(Frame):\nclass PCNT(Frame):\nclass PCST(Frame):\nclass POPM(Frame):\nclass GEOB(Frame):\nclass RBUF(Frame):\nclass AENC(Frame):\nclass LINK(Frame):\nclass POSS(Frame):\nclass UFID(Frame):\nclass USER(Frame):\nclass OWNE(Frame):\nclass COMR(Frame):\nclass ENCR(Frame):\nclass GRID(Frame):\nclass PRIV(Frame):\nclass SIGN(Frame):\nclass SEEK(Frame):\nclass ASPI(Frame):\nclass UFI(UFID):\nclass TT1(TIT1):\nclass TT2(TIT2):\nclass TT3(TIT3):\nclass TP1(TPE1):\nclass TP2(TPE2):\nclass TP3(TPE3):\nclass TP4(TPE4):\nclass TCM(TCOM):\nclass TXT(TEXT):\nclass TLA(TLAN):\nclass TCO(TCON):\nclass TAL(TALB):\nclass TPA(TPOS):\nclass TRK(TRCK):\nclass TRC(TSRC):\nclass TYE(TYER):\nclass TDA(TDAT):\nclass TIM(TIME):\nclass TRD(TRDA):\nclass TMT(TMED):\nclass TFT(TFLT):\nclass TBP(TBPM):\nclass TCP(TCMP):\nclass TCR(TCOP):\nclass TPB(TPUB):\nclass TEN(TENC):\nclass TST(TSOT):\nclass TSA(TSOA):\nclass TS2(TSO2):\nclass TSP(TSOP):\nclass TSC(TSOC):\nclass TSS(TSSE):\nclass TOF(TOFN):\nclass TLE(TLEN):\nclass TSI(TSIZ):\nclass TDY(TDLY):\nclass TKE(TKEY):\nclass TOT(TOAL):\nclass TOA(TOPE):\nclass TOL(TOLY):\nclass TOR(TORY):\nclass TXX(TXXX):\nclass WAF(WOAF):\nclass WAR(WOAR):\nclass WAS(WOAS):\nclass WCM(WCOM):\nclass WCP(WCOP):\nclass WPB(WPUB):\nclass WXX(WXXX):\nclass IPL(IPLS):\nclass MCI(MCDI):\nclass ETC(ETCO):\nclass MLL(MLLT):\nclass STC(SYTC):\nclass ULT(USLT):\nclass SLT(SYLT):\nclass COM(COMM):\nclass RVA(RVAD):\nclass REV(RVRB):\nclass PIC(APIC):\nclass GEO(GEOB):\nclass CNT(PCNT):\nclass POP(POPM):\nclass BUF(RBUF):\nclass CRM(Frame):\nclass CRA(AENC):\nclass LNK(LINK):\n    FLAG23_ALTERTAG = 0x8000\n    FLAG23_ALTERFILE = 0x4000\n    FLAG23_READONLY = 0x2000\n    FLAG23_COMPRESS = 0x0080\n    FLAG23_ENCRYPT = 0x0040\n    FLAG23_GROUP = 0x0020\n    FLAG24_ALTERTAG = 0x4000\n    FLAG24_ALTERFILE = 0x2000\n    FLAG24_READONLY = 0x1000\n    FLAG24_GROUPID = 0x0040\n    FLAG24_COMPRESS = 0x0008\n    FLAG24_ENCRYPT = 0x0004\n    FLAG24_UNSYNCH = 0x0002\n    FLAG24_DATALEN = 0x0001\n    GENRES = GENRES\nmutagen/_util.py\ndef read_full(fileobj, size):\n    \"\"\"Like fileobj.read but raises IOError if not all requested data is\n    returned.\n\n    If you want to distinguish IOError and the EOS case, better handle\n    the error yourself instead of using this.\n\n    Args:\n        fileobj (fileobj)\n        size (int): amount of bytes to read\n    Raises:\n        IOError: In case read fails or not enough data is read\n    \"\"\"\n\n    if size < 0:\n        raise ValueError(\"size must not be negative\")\n\n    data = fileobj.read(size)\n    if len(data) != size:\n        raise IOError\n    return data\nmutagen/id3/_util.py\nclass error(MutagenError):\n    pass\nmutagen/id3/_util.py\nclass ID3UnsupportedVersionError(error, NotImplementedError):\n    pass\nmutagen/id3/_util.py\ndef is_valid_frame_id(frame_id):\n    return frame_id.isalnum() and frame_id.isupper()\nmutagen/id3/_util.py\nclass ID3NoHeaderError(error, ValueError):\n    pass\nmutagen/_util.py\nclass DictProxy(DictMixin):\n    def __init__(self, *args, **kwargs):\n        self.__dict = {}\n        super(DictProxy, self).__init__(*args, **kwargs)\n\n    def __getitem__(self, key):\n        return self.__dict[key]\n\n    def __setitem__(self, key, value):\n        self.__dict[key] = value\n\n    def __delitem__(self, key):\n        del(self.__dict[key])\n\n    def keys(self):\n        return self.__dict.keys()\nmutagen/id3/_util.py\nclass BitPaddedInt(int, _BitPaddedMixin):\n\n    def __new__(cls, value, bits=7, bigendian=True):\n\n        mask = (1 << (bits)) - 1\n        numeric_value = 0\n        shift = 0\n\n        if isinstance(value, int):\n            if value < 0:\n                raise ValueError\n            while value:\n                numeric_value += (value & mask) << shift\n                value >>= 8\n                shift += bits\n        elif isinstance(value, bytes):\n            if bigendian:\n                value = reversed(value)\n            for byte in bytearray(value):\n                numeric_value += (byte & mask) << shift\n                shift += bits\n        else:\n            raise TypeError\n\n        self = int.__new__(BitPaddedInt, numeric_value)\n\n        self.bits = bits\n        self.bigendian = bigendian\n        return self\nmutagen/_util.py\ndef convert_error(exc_src, exc_dest):\n    \"\"\"A decorator for reraising exceptions with a different type.\n    Mostly useful for IOError.\n\n    Args:\n        exc_src (type): The source exception type\n        exc_dest (type): The target exception type.\n    \"\"\"\n\n    def wrap(func):\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except exc_dest:\n                raise\n            except exc_src as err:\n                reraise(exc_dest, err, sys.exc_info()[2])\n\n        return wrapper\n\n    return wrap\nmutagen/_tags.py\nclass Tags(object):\n    \"\"\"`Tags` is the base class for many of the tag objects in Mutagen.\n\n    In many cases it has a dict like interface.\n    \"\"\"\n\n    __module__ = \"mutagen\"\n\n    def pprint(self):\n        \"\"\"\n        Returns:\n            text: tag information\n        \"\"\"\n\n        raise NotImplementedError\nmutagen/id3/_util.py\nclass ID3EncryptionUnsupportedError(error, NotImplementedError):\n    pass\nmutagen/id3/_util.py\nclass ID3JunkFrameError(error):\n    pass\nmutagen/id3/_util.py\nclass ID3SaveConfig(object):\n\n    def __init__(self, v2_version=4, v23_separator=None):\n        assert v2_version in (3, 4)\n        self.v2_version = v2_version\n        self.v23_separator = v23_separator\nmutagen/id3/_util.py\nclass unsynch(object):\n    @staticmethod\n    def decode(value):\n        fragments = bytearray(value).split(b'\\xff')\n        if len(fragments) > 1 and not fragments[-1]:\n            raise ValueError('string ended unsafe')\n\n        for f in fragments[1:]:\n            if (not f) or (f[0] >= 0xE0):\n                raise ValueError('invalid sync-safe string')\n\n            if f[0] == 0x00:\n                del f[0]\n\n        return bytes(bytearray(b'\\xff').join(fragments))\n\n    @staticmethod\n    def encode(value):\n        fragments = bytearray(value).split(b'\\xff')\n        for f in fragments[1:]:\n            if (not f) or (f[0] >= 0xE0) or (f[0] == 0x00):\n                f.insert(0, 0x00)\n        return bytes(bytearray(b'\\xff').join(fragments))\n", "answers": ["    if isinstance(frame, TextFrame):"], "length": 1608, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "22cc5edeea2a251a75ec8950fd9bd0000a1dc7ee084af4ce"}
{"input": "import wx.html\nfrom history import *\nfrom controls import *\nfrom planning import *\nfrom cotisation import *\nfrom document_dialog import *\nfrom generation.contrat_accueil import ContratAccueilModifications, DevisAccueilModifications, FraisGardeModifications, AvenantContratAccueilModifications\nfrom config import config\nfrom database import Inscrit, TimeslotInscription, Fratrie, Referent, Parent, CongeInscrit, Inscription, Revenu\n#    Gertrude is free software; you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation; either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    Gertrude is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with Gertrude; if not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\n\n\n\nclass FraisGardePanel(wx.Panel):\n    def __init__(self, parent):\n        self.parent = parent\n        self.inscrit = None\n        wx.Panel.__init__(self, parent)\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer1 = wx.BoxSizer(wx.HORIZONTAL)\n        self.periodechoice = wx.Choice(self, size=(220, -1))\n        self.Bind(wx.EVT_CHOICE, self.onPeriodeChoice, self.periodechoice)\n        sizer1.Add(self.periodechoice, 0, wx.ALIGN_CENTER_VERTICAL)\n        self.frais_accueil_button = wx.Button(self, -1, \"Exporter\")\n        sizer1.Add(self.frais_accueil_button, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT, 5)\n        self.Bind(wx.EVT_BUTTON, self.EvtGenerationFraisAccueil, self.frais_accueil_button)\n        if IsTemplateFile(\"Devis accueil.odt\"):\n            self.devis_button = wx.Button(self, -1, \"Générer un devis\")\n            sizer1.Add(self.devis_button, 0, wx.LEFT, 5)\n            self.Bind(wx.EVT_BUTTON, self.EvtGenerationDevis, self.devis_button)\n        else:\n            self.devis_button = None\n        self.contrat_button = wx.Button(self, -1, \"Générer le contrat\")\n        sizer1.Add(self.contrat_button, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT, 5)\n        self.Bind(wx.EVT_BUTTON, self.EvtGenerationContrat, self.contrat_button)\n        if IsTemplateFile(\"Avenant contrat accueil.odt\"):\n            self.avenant_button = wx.Button(self, -1, \"Générer un avenant\")\n            sizer1.Add(self.avenant_button, 0, wx.LEFT, 5)\n            self.Bind(wx.EVT_BUTTON, self.EvtGenerationAvenant, self.avenant_button)\n        else:\n            self.avenant_button = None\n        self.sizer.Add(sizer1, 0, wx.ALL, 5)\n        self.html_window = wx.html.HtmlWindow(self, style=wx.SUNKEN_BORDER)\n        self.sizer.Add(self.html_window, 1, wx.EXPAND | wx.ALL-wx.TOP, 5)\n        self.SetSizer(self.sizer)\n\n    def EnableButtons(self, state):\n        for button in (self.contrat_button, self.devis_button, self.avenant_button, self.frais_accueil_button):\n            if button:\n                button.Enable(state)\n\n    def UpdatePage(self):\n        if self.inscrit is None:\n            self.html = '<html><body>Aucun inscrit s&eacute;lectionn&eacute; !</body></html>'\n            self.periodechoice.Disable()\n        elif not self.current_cotisation:\n            self.html = '<html><body>Aucune inscription !</body></html>'\n            self.periodechoice.Disable()\n        else:\n            context = self.current_cotisation[-1]\n            if isinstance(context, CotisationException):\n                error = '<br>'.join(context.errors)\n                self.html = \"<html><body><b>Les frais de garde ne peuvent être calcul&eacute;s pour la (les) raison(s) suivante(s) :</b><br>\" + error + \"</body></html>\"\n                self.EnableButtons(False)\n            else:\n                self.html = generateFraisGardeHtml(context)\n                self.EnableButtons(True)\n        self.html_window.SetPage(self.html)\n        \n    def SetInscrit(self, inscrit):\n        self.inscrit = inscrit\n        self.UpdateContents()\n    \n    def UpdateContents(self):\n        self.periodechoice.Clear()\n        if self.inscrit:\n            self.cotisations = GetCotisations(self.inscrit)\n            if len(self.cotisations) > 0:\n                index = len(self.cotisations) - 1\n                self.current_cotisation = self.cotisations[index]\n                for i, cotisation in enumerate(self.cotisations):\n                    if cotisation[0] and cotisation[0] <= today and (not cotisation[1] or today <= cotisation[1]):\n                        self.current_cotisation = cotisation\n                        index = i\n                        break\n                self.periodechoice.Enable()\n                self.EnableButtons(True)\n                for c in self.cotisations:\n                    self.periodechoice.Append(date2str(c[0]) + ' - ' + date2str(c[1]))\n                self.periodechoice.SetSelection(index)\n            else:\n                self.current_cotisation = None\n                self.periodechoice.Disable()\n                self.EnableButtons(False)\n        else:\n            self.current_cotisation = None\n            self.periodechoice.Disable()\n            self.EnableButtons(False)\n        self.UpdatePage()\n        \n    def onPeriodeChoice(self, evt):\n        ctrl = evt.GetEventObject()\n        self.current_cotisation = self.cotisations[ctrl.GetSelection()]\n        self.UpdatePage()\n        \n    def EvtGenerationFraisAccueil(self, _):\n        DocumentDialog(self, FraisGardeModifications(self.inscrit, self.current_cotisation[0])).ShowModal()\n\n    def EvtGenerationDevis(self, _):\n        DocumentDialog(self, DevisAccueilModifications(self.inscrit, self.current_cotisation[0])).ShowModal()\n\n    def EvtGenerationContrat(self, _):\n        DocumentDialog(self, ContratAccueilModifications(self.inscrit, self.current_cotisation[0])).ShowModal()\n\n    def EvtGenerationAvenant(self, _):\n", "context": "database.py\nclass TimeslotInscription(Base, Timeslot):\n    __tablename__ = \"ref_activities\"\n    idx = Column(Integer, primary_key=True)\n    inscription_id = Column(Integer, ForeignKey(\"inscriptions.idx\"))\n    inscription = relationship(Inscription)\n    day = Column(Integer)\n    activity_id = Column(Integer, ForeignKey(\"activities.idx\"), name=\"activity\")\n    activity = relationship(Activite)\n    debut = Column(Integer)\n    fin = Column(Integer)\ngeneration/contrat_accueil.py\nclass ContratAccueilModifications(OdtDocumentAccueilModifications):\n    title = \"Contrat d'accueil\"\n    template = 'Contrat accueil.odt'\n\n    def __init__(self, who, date):\n        OdtDocumentAccueilModifications.__init__(self, who, date)\n        if self.inscription.mode == MODE_TEMPS_PARTIEL and IsTemplateFile(\"Contrat accueil temps partiel.odt\"):\n            self.template = \"Contrat accueil temps partiel.odt\"\n        elif self.inscription.mode == MODE_FORFAIT_MENSUEL and IsTemplateFile(\"Contrat accueil forfait mensuel.odt\"):\n            self.template = \"Contrat accueil forfait mensuel.odt\"\n        elif self.inscription.mode == MODE_HALTE_GARDERIE and IsTemplateFile(\"Contrat accueil halte garderie.odt\"):\n            self.template = \"Contrat accueil halte garderie.odt\"\n        self.default_output = \"Contrat accueil %s - %s.odt\" % (GetPrenomNom(who), GetDateString(date, weekday=False))\ndatabase.py\nclass Referent(Base):\n    __tablename__ = \"referents\"\n    idx = Column(Integer, primary_key=True)\n    famille_id = Column(Integer, ForeignKey(\"familles.idx\"))\n    famille = relationship(Famille)\n    prenom = Column(String)\n    nom = Column(String)\n    telephone = Column(String)\n\n    def __init__(self, famille, prenom=None, nom=None, telephone=None):\n        Base.__init__(self, famille=famille, prenom=prenom, nom=nom, telephone=telephone)\ndatabase.py\nclass Inscrit(Base):\n    __tablename__ = \"inscrits\"\n    idx = Column(Integer, primary_key=True)\n    creche_id = Column(Integer, ForeignKey(\"creche.idx\"))\n    creche = relationship(Creche)\n    famille_id = Column(Integer, ForeignKey(\"familles.idx\"))\n    famille = relationship(Famille)\n    prenom = Column(String, default=\"\")\n    nom = Column(String, default=\"\")\n    sexe = Column(Integer, default=MASCULIN)\n    naissance = Column(Date)\n    handicap = Column(Boolean, default=False)\n    marche = Column(Boolean, default=False)\n    photo = Column(String)\n    notes = Column(String, default=\"\")\n    combinaison = Column(String, default=\"\")\n    categorie_id = Column(Integer, ForeignKey(\"categories.idx\"))\n    categorie = relationship(\"Categorie\")\n    allergies = Column(String, default=\"\")\n    garde_alternee = Column(Boolean, default=False)\n    type_repas = Column(Integer, default=REPAS_PUREE)\n    type_repas2 = Column(Integer, default=REPAS_ASSIETTE)\n    date_premier_contact = Column(Date)\n    date_entretien_directrice = Column(Date)\n    date_envoi_devis = Column(Date)\n    date_reponse_parents = Column(Date)\n    preinscription_state = Column(Integer)\n    inscriptions = relationship(\"Inscription\", cascade=\"all, delete-orphan\")\n    days = relationship(\"TimeslotInscrit\", collection_class=lambda: DayCollection(\"date\"), cascade=\"all, delete-orphan\")\n    weekslots = relationship(\"WeekSlotInscrit\", cascade=\"all, delete-orphan\")\n    commentaires = relationship(\"CommentaireInscrit\", collection_class=attribute_mapped_collection(\"date\"), cascade=\"all, delete-orphan\")\n    clotures = relationship(\"ClotureFacture\", collection_class=attribute_mapped_collection(\"date\"), cascade=\"all, delete-orphan\")\n    conges = relationship(\"CongeInscrit\", cascade=\"all, delete-orphan\")\n    corrections = relationship(\"Correction\", collection_class=attribute_mapped_collection(\"date\"), cascade=\"all, delete-orphan\")\n\n    def __init__(self, prenom=\"\", nom=\"\", sexe=MASCULIN, handicap=False, allergies=\"\", automatic=True, **kwargs):\n        Base.__init__(self, prenom=prenom, nom=nom, sexe=sexe, handicap=handicap, allergies=allergies, **kwargs)\n        self.famille = Famille(creche=self.creche, automatic=automatic)\n        self.famille.inscrits.append(self)\n        if automatic:\n            self.inscriptions.append(Inscription(inscrit=self))\n        self.jours_conges = {}\n\n    @reconstructor\n    def init_on_load(self):\n        self.calcule_jours_conges()\n\n    def slug(self):\n        return \"child-%d\" % self.idx\n\n    def get_preinscription_state(self):\n        if self.preinscription_state >= STATE_ACCORD_PARENTS:\n            pass\n        elif not self.date_premier_contact:\n            self.preinscription_state = STATE_PREINSCRIPTION_RECUE\n        elif not self.date_entretien_directrice:\n            self.preinscription_state = STATE_ATTENTE_ENTRETIEN\n        elif self.date_entretien_directrice > datetime.date.today():\n            self.preinscription_state = STATE_ENTRETIEN_PROGRAMME\n        elif not self.date_envoi_devis:\n            self.preinscription_state = STATE_DEVIS_A_ENVOYER\n        elif not self.date_reponse_parents:\n            self.preinscription_state = STATE_ATTENTE_REPONSE_PARENTS\n        else:\n            self.preinscription_state = STATE_ATTENTE_REPONSE_PARENTS\n        return self.preinscription_state\n\n    def get_groupe_order(self, date):\n        inscription = self.get_inscription(date)\n        return inscription.groupe.ordre if inscription and inscription.groupe else 255\n\n    def get_groupe_auto(self):\n        result = None\n        age = GetAge(self.naissance)\n        for groupe in self.creche.groupes:\n            if not groupe.age_maximum or age <= groupe.age_maximum:\n                if result is None or not result.age_maximum or (groupe.age_maximum and groupe.age_maximum < result.age_maximum):\n                    result = groupe\n        return result\n\n    def get_facture_cloturee(self, date):\n        if self.creche.temps_facturation == FACTURATION_FIN_MOIS:\n            result = self.clotures.get(GetMonthEnd(date), None)\n            if result:\n                return result\n        return self.clotures.get(GetMonthStart(date), None)\n\n    def get_week_slots(self, monday):\n        return [weekslot for weekslot in self.weekslots if weekslot.date == monday]\n\n    def get_week_activity_slot(self, monday, activity):\n        for weekslot in self.weekslots:\n            # print(weekslot.date, weekslot.activity, activity, weekslot)\n            if weekslot.date == monday and weekslot.activity == activity:\n                return weekslot\n        else:\n            return None\n\n    def add_conge(self, conge):\n        self.conges.append(conge)\n        self.calcule_jours_conges()\n\n    def delete_conge(self, conge):\n        self.conges.remove(conge)\n        self.calcule_jours_conges()\n\n    def calcule_jours_conges(self):\n        self.jours_conges = {}\n\n        def AddPeriode(debut, fin, conge):\n            date = debut\n            while date <= fin:\n                if date not in self.creche.jours_fermeture:\n                    self.jours_conges[date] = conge\n                date += datetime.timedelta(1)\n\n        for conge in self.conges:\n            if conge.debut:\n                try:\n                    count = conge.debut.count('/')\n                    if count == 2:\n                        debut = str2date(conge.debut)\n                        if not conge.fin or conge.fin.strip() == \"\":\n                            fin = debut\n                        else:\n                            fin = str2date(conge.fin)\n                        AddPeriode(debut, fin, conge)\n                    elif count == 1:\n                        for year in range(config.first_date.year, config.last_date.year + 1):\n                            debut = str2date(conge.debut, year)\n                            if not conge.fin or conge.fin.strip() == \"\":\n                                fin = debut\n                            else:\n                                fin = str2date(conge.fin, year)\n                            AddPeriode(debut, fin, conge)\n                except Exception as e:\n                    print(\"Exception congé %s %s\" % (self.prenom, self.nom), e)\n\n    def is_present(self, debut, fin, site=None, handicap=None, reservataire=None):\n        for inscription in self.inscriptions:\n            inscription_fin = inscription.depart if inscription.depart else inscription.fin\n            if ((inscription_fin is None or inscription_fin >= debut) and\n                    (not self.creche.preinscriptions or not inscription.preinscription) and\n                    (site is None or inscription.site == site) and\n                    (reservataire is None or inscription.reservataire == reservataire) and\n                    (inscription.debut is not None) and\n                    (not fin or inscription.debut <= fin) and\n                    (handicap is None or self.handicap == handicap)):\n                return True\n        return False\n\n    def get_mode_arrondi(self):\n        return self.creche.arrondi_heures\n\n    def get_allergies(self):\n        return [allergie.strip() for allergie in self.allergies.split(\",\")]\n\n    def has_facture(self, date, site=None):\n        if not date:  # or date.month in database.creche.mois_sans_facture:\n            return False\n        month_start = GetMonthStart(date)\n        month_end = GetMonthEnd(date)\n        if self.get_inscriptions(month_start, month_end, site):\n            return True\n        if self.creche.temps_facturation != FACTURATION_FIN_MOIS:\n            previous_month_end = month_start - datetime.timedelta(1)\n            previous_month_start = GetMonthStart(previous_month_end)\n            if self.get_inscriptions(previous_month_start, previous_month_end, site):\n                day = previous_month_start\n                while day.month == previous_month_start.month:\n                    state = self.GetState(day)\n                    if state.heures_facturees != state.heures_contractualisees:\n                        return True\n                    day += datetime.timedelta(1)\n        return False\n\n    def get_factures_list(self):\n        result = []\n        date = config.get_first_monday()\n        while date <= datetime.date.today():\n            if self.has_facture(date):\n                result.append(date)\n            date = GetNextMonthStart(date)\n        return result\n\n    def GetPeriodeInscriptions(self):\n        if len(self.inscriptions) == 0:\n            return None, None\n        else:\n            debut, fin = self.inscriptions[0].debut, self.inscriptions[0].fin\n            for inscription in self.inscriptions:\n                if debut is None or (inscription.debut is not None and inscription.debut < debut):\n                    debut = inscription.debut\n                if fin is not None and (inscription.fin is None or inscription.fin > fin):\n                    fin = inscription.fin\n            return debut, fin\n\n    def get_planning(self, date):\n        return self.get_inscription(date)\n\n    def get_contrat(self, date):\n        return self.get_inscription(date)\n\n    def get_inscription(self, date, preinscription=False, departanticipe=True, array=False):\n        result = []\n        for inscription in self.inscriptions:\n            if (preinscription or not self.creche.preinscriptions or not inscription.preinscription) and \\\n                    (inscription.debut and date >= inscription.debut and (not inscription.fin or date <= inscription.fin)) and \\\n                    (not departanticipe or not inscription.depart or date <= inscription.depart):\n                if array:\n                    result.append(inscription)\n                else:\n                    return inscription\n        if array:\n            return result\n        else:\n            return None\n\n    def get_inscriptions(self, date_debut=None, date_fin=None, site=None, preinscriptions=False, departanticipe=True):\n        result = []\n        if not date_debut:\n            date_debut = datetime.date.min\n        if not date_fin:\n            date_fin = datetime.date.max\n        for inscription in self.inscriptions:\n            if (site is None or site == inscription.site) \\\n                    and (preinscriptions or not self.creche.preinscriptions or not inscription.preinscription) \\\n                    and inscription.debut:\n                date_debut_periode = inscription.debut\n                try:\n                    if departanticipe and inscription.depart:\n                        date_fin_periode = inscription.depart\n                    elif inscription.fin:\n                        date_fin_periode = inscription.fin\n                    else:\n                        date_fin_periode = datetime.date.max\n                    if date_fin_periode < date_debut_periode:\n                        print(\"Période incorrecte pour %s %s :\" % (self.prenom, self.nom), date_debut_periode, date_fin_periode)\n                        continue\n                    if (date_debut_periode <= date_debut <= date_fin_periode) or (date_debut_periode <= date_fin <= date_fin_periode) or (date_debut < date_debut_periode and date_fin > date_fin_periode):\n                        result.append(inscription)\n                except Exception as e:\n                    print(\"Exception inscriptions\", e)\n        result.sort(key=lambda inscription: inscription.debut)\n        return result\n\n    def is_date_conge(self, date):\n        if date in self.creche.jours_fermeture:\n            return True\n        if date in self.jours_conges:\n            if self.creche.conges_inscription != GESTION_CONGES_INSCRIPTION_MENSUALISES_AVEC_POSSIBILITE_DE_SUPPLEMENT:\n                return True\n            if date in self.days:\n                return self.days[date].get_state() == ABSENT\n        return False\n\n    def GetRattachement(self):\n        result = None\n        for inscrit in self.creche.inscrits:\n            if inscrit is not self:\n                if inscrit.famille is self.famille:\n                    return True\n                if inscrit.nom == self.nom:\n                    result = False\n        return result\n\n    def ChangeRattachement(self, state):\n        if state:\n            for inscrit in self.creche.inscrits:\n                if inscrit is not self and inscrit.nom == self.nom:\n                    self.famille = inscrit.famille\n                    break\n        else:\n            self.famille = Famille(creche=self.creche)\n\n    def GetJournee(self, date):\n        if self.is_date_conge(date):\n            return None\n\n        inscription = self.get_inscription(date)\n        if inscription is None:\n            return None\n\n        result = self.days.get(date, None)\n        if result:\n            return result\n\n        return self.GetJourneeReference(date)\n\n    def GetJourneeReference(self, date):\n        if date in self.jours_conges:\n            return Day()\n        else:\n            inscription = self.get_inscription(date)\n            if inscription:\n                return inscription.get_day_from_date(date)\n            else:\n                return None\n\n    def get_nombre_jours_maladie(self, date):\n        # recherche du premier et du dernier jour\n        premier_jour_maladie = tmp = date\n        nombre_jours_ouvres_maladie = 0\n        pile = 0\n        while tmp > self.inscriptions[0].debut:\n            tmp -= datetime.timedelta(1)\n            state = self.get_state(tmp)\n            if tmp not in self.creche.jours_fermeture:\n                pile += 1\n            if state == MALADE:\n                premier_jour_maladie = tmp\n                if self.creche.traitement_maladie == DEDUCTION_MALADIE_AVEC_CARENCE_JOURS_CONSECUTIFS:\n                    nombre_jours_ouvres_maladie += 1\n                else:\n                    nombre_jours_ouvres_maladie += pile\n                pile = 0\n            elif state != ABSENT:\n                break\n        if self.creche.traitement_maladie in (DEDUCTION_MALADIE_AVEC_CARENCE_JOURS_OUVRES, DEDUCTION_MALADIE_AVEC_CARENCE_JOURS_CONSECUTIFS):\n            nombre_jours_maladie = nombre_jours_ouvres_maladie + 1\n        elif self.creche.traitement_maladie == DEDUCTION_MALADIE_AVEC_CARENCE_JOURS_CALENDAIRES:\n            nombre_jours_maladie = (date - premier_jour_maladie).days + 1\n        else:\n            dernier_jour_maladie = tmp = date\n            while not self.inscriptions[-1].fin or tmp < self.inscriptions[-1].fin:\n                tmp += datetime.timedelta(1)\n                state = self.get_state(tmp)\n                if state == MALADE:\n                    dernier_jour_maladie = tmp\n                else:\n                    break\n            nombre_jours_maladie = (dernier_jour_maladie - premier_jour_maladie).days + 1\n        return nombre_jours_maladie\n\n    def GetState(self, date, mode_arrondi=SANS_ARRONDI):\n        \"\"\"Retourne les infos sur une journée\n        :param date: la journée\n        \"\"\"\n\n        if self.is_date_conge(date):\n            return State(ABSENT)\n\n        inscription = self.get_inscription(date)\n        if inscription is None:\n            return State(ABSENT)\n\n        reference = self.GetJourneeReference(date)  # Attention pas depuis inscription à cause des congés inscription avec supplément\n        heures_reference = reference.get_duration(mode_arrondi)\n        ref_state = reference.get_state()\n\n        if self.creche.jours_fermeture_non_prevus.get(date):\n            return State(ABSENT, heures_reference, 0, 0)\n\n        if date in self.days:\n            journee = self.days[date]\n            state = journee.get_state()\n            if state == ABSENCE_NON_PREVENUE:\n                heures_facturees = heures_reference\n                if heures_facturees == 0:\n                    for timeslot in journee.timeslots:\n                        if timeslot.activity.mode == MODE_ABSENCE_NON_PREVENUE:\n                            heures_facturees += timeslot.get_duration()\n                        heures_facturees = heures_facturees / 60\n                return State(state, heures_reference, 0, heures_facturees)\n            elif state == HOPITAL:\n                return State(state, heures_reference, 0, 0)\n            elif state == MALADE and self.get_nombre_jours_maladie(date) > self.creche.minimum_maladie:\n                return State(state, heures_reference, 0, 0)\n            elif state in (MALADE, MALADE_SANS_JUSTIFICATIF, ABSENCE_NON_PREVENUE, ABSENCE_CONGE_SANS_PREAVIS):\n                return State(state, heures_reference, 0, heures_reference)\n            elif state in (ABSENT, VACANCES):\n                if inscription.mode == MODE_TEMPS_PLEIN or ref_state:\n                    return State(VACANCES, heures_reference, 0, heures_reference)\n                else:\n                    return State(ABSENT, heures_reference, 0, heures_reference)\n            else:  # PRESENT\n                tranche = 5.0 / 60\n                heures_realisees = 0.0\n                heures_facturees = 0.0\n\n                # TODO une petite fonction pour ce code duplique dans le test\n                timeslots = GetUnionTimeslots([timeslot for timeslot in journee.timeslots if timeslot.activity.mode in (0, MODE_PRESENCE_NON_FACTUREE)])\n                for timeslot in timeslots:\n                    heures_realisees += tranche * GetDureeArrondie(self.creche.arrondi_heures, timeslot.debut, timeslot.fin)\n\n                union = GetUnionHeures(journee, reference)\n                if inscription.IsInPeriodeAdaptation(date):\n                    if self.creche.facturation_periode_adaptation == FACTURATION_HORAIRES_REELS:\n                        union = journee.timeslots\n                    for timeslot in union:\n                        heures_facturees += tranche * GetDureeArrondie(self.creche.arrondi_facturation_periode_adaptation, timeslot.debut, timeslot.fin)\n                else:\n                    for timeslot in union:\n                        heures_facturees += tranche * GetDureeArrondie(self.creche.arrondi_facturation, timeslot.debut, timeslot.fin)\n                    timeslots_presence_non_facturee = GetUnionTimeslots([timeslot for timeslot in journee.timeslots if timeslot.activity.mode == MODE_PRESENCE_NON_FACTUREE])\n                    for timeslot in timeslots_presence_non_facturee:\n                        heures_facturees -= tranche * GetDureeArrondie(self.creche.arrondi_facturation, timeslot.debut, timeslot.fin)\n\n                return State(PRESENT, heures_reference, heures_realisees, heures_facturees)\n        else:\n            if ref_state:\n                return State(PRESENT, heures_reference, heures_reference, heures_reference)\n            else:\n                return State(ABSENT)\n\n    def get_state(self, date):\n        if self.is_date_conge(date):\n            return ABSENT\n        elif date in self.days:\n            return self.days[date].get_state()\n        else:\n            inscription = self.get_inscription(date)\n            return inscription.get_day_from_date(date).get_state() if inscription else ABSENT\n\n    def GetExtraActivites(self, date):\n        # TODO il y a un problème avec les CONGES_AVEC_POSSIBILITE_DE_SUPPLEMENT parce que la journée retournée est la journée de référence et donc les activités sont comptées à tort\n        day = self.GetJournee(date)\n        if day is None:\n            return []\n        result = set()\n        for timeslot in day.timeslots:\n            if timeslot.activity.mode > 0:\n                result.add(timeslot)\n        if result:\n            for activity in self.creche.activites:\n                if activity.mode == MODE_SYSTEMATIQUE_SANS_HORAIRES:\n                    result.add(Timeslot(debut=None, fin=None, activity=activity))\n        return result\n\n    def GetTotalActivitesPresenceNonFacturee(self, date):\n        day = self.GetJournee(date)\n        return 0 if day is None else day.get_duration_per_activity_mode(MODE_PRESENCE_NON_FACTUREE)\n\n    def GetTotalActivitesPresenceFactureesEnSupplement(self, date):\n        day = self.GetJournee(date)\n        return 0 if day is None else day.get_duration_per_activity_mode(MODE_PRESENCE_SUPPLEMENTAIRE)\n\n    def GetTotalActivitesConges(self, date):\n        day = self.GetJournee(date)\n        return 0 if day is None else day.get_duration_per_activity_mode(MODE_CONGES)\n\n    def GetDecomptePermanences(self):\n        today = datetime.date.today()\n        total, effectue = 0.0, 0.0\n        date = self.creche.date_raz_permanences\n        if date:\n            while date < today:\n                journee = self.GetJournee(date)\n                if journee:\n                    effectue += journee.get_duration_permanences()\n                date += datetime.timedelta(1)\n            anniversaire = GetDateAnniversaire(self.creche.date_raz_permanences)\n            for inscription in self.inscriptions:\n                if inscription.debut is not None and self.creche.date_raz_permanences <= inscription.debut < today:\n                    fin = inscription.fin if inscription.fin else anniversaire\n                    if fin < today:\n                        total += inscription.heures_permanences\n                    else:\n                        total += inscription.heures_permanences * (today - inscription.debut).days / (fin - inscription.debut).days\n        return total, effectue\n\n    def GetRegime(self, date):\n        result = 0\n        for parent in self.famille.parents:\n            if parent:\n                revenu = Select(parent.revenus, date)\n                if revenu and revenu.regime:\n                    result = revenu.regime\n                    break\n        return result\ndatabase.py\nclass Fratrie(Base):\n    __tablename__ = \"fratries\"\n    idx = Column(Integer, primary_key=True)\n    famille_id = Column(Integer, ForeignKey(\"familles.idx\"))\n    famille = relationship(Famille)\n    prenom = Column(String)\n    naissance = Column(Date)\n    entree = Column(Date)\n    sortie = Column(Date)\n\n    def __init__(self, famille, prenom=None, naissance=None, entree=None, sortie=None):\n        Base.__init__(self, famille=famille, prenom=prenom, naissance=naissance, entree=entree, sortie=sortie)\ndatabase.py\nclass Revenu(Base):\n    __tablename__ = \"revenus\"\n    idx = Column(Integer, primary_key=True)\n    parent_id = Column(Integer, ForeignKey(\"parents.idx\"))\n    parent = relationship(Parent)\n    debut = Column(Date)\n    fin = Column(Date)\n    revenu = Column(Integer, default=\"\")\n    chomage = Column(Boolean, default=False)\n    conge_parental = Column(Boolean, default=False)\n    regime = Column(Integer, default=0)\n\n    def __init__(self, parent, debut=None, fin=None, revenu=\"\", chomage=False, conge_parental=False, regime=0, **kwargs):\n        Base.__init__(self, parent=parent, debut=debut, fin=fin, revenu=revenu, chomage=chomage, conge_parental=conge_parental, regime=regime, **kwargs)\nconfig.py\nCONFIG_FILENAME = \"gertrude.ini\"\nDEFAULT_SECTION = \"gertrude\"\n    DEFAULT_DATABASE = \"gertrude.db\"\n    BACKUPS_DIRECTORY = \"./backups\"\n    CONFIG_PATHS = [\"\"]\n    HOME = os.path.expanduser(\"~\")\n    GERTRUDE_DIRECTORY = HOME + \"/.gertrude\"\n    DEFAULT_DATABASE = GERTRUDE_DIRECTORY + \"/gertrude.db\"\n    BACKUPS_DIRECTORY = GERTRUDE_DIRECTORY + '/backups'\n    CONFIG_PATHS = [\"./\", GERTRUDE_DIRECTORY + \"/\", \"/etc/gertrude/\"]\nDEMO_DATABASE = \"demo.db\"\ndef getDefaultDocumentsDirectory():\n    def __init__(self, parser, name=None):\n    def getStringParameter(self, key, default=\"\"):\n    def getIntegerParameter(self, key, default=0):\n    def getDateParameter(self, key, default=None):\n    def getTimeParameter(self, key, default=None):\n    def getOptionsParameter(self):\n    def getWindowSize(self):\n    def getPictos(self):\n    def getDocumentsDirectory(self):\n    def getTemplatesDirectory(self):\n    def getBackupsDirectory(self):\n    def __init__(self):\n    def __init__(self):\n    def find_config_file():\n    def load(self, path=None, progress_handler=default_progress_handler):\n    def save(self, progress_handler):\n    def set_current_section(self, section_name):\n    def get_first_monday(self):\n    def is_date_after_reglements_start(self, date):\n    def __getattr__(self, key):\n    def Filter():\n    def Update():\nclass Section(object):\nclass DefaultConfig(object):\nclass Config(object):\ngeneration/contrat_accueil.py\nclass FraisGardeModifications(DocumentAccueilModifications):\n    title = \"Frais de garde\"\n    template = \"Frais de garde.ods\"\n\n    def __init__(self, who, date):\n        DocumentAccueilModifications.__init__(self, who, date)\n        self.multi = False\n        self.default_output = \"Frais de garde %s - %s.odt\" % (GetPrenomNom(who), GetDateString(date, weekday=False))\n        \n    def execute(self, filename, dom):\n        if filename != 'content.xml':\n            return None\n        \n        spreadsheet = dom.getElementsByTagName('office:spreadsheet').item(0)\n        table = spreadsheet.getElementsByTagName(\"table:table\").item(0)       \n        lignes = table.getElementsByTagName(\"table:table-row\")\n\n        fields = self.GetFields()\n        ReplaceFields(lignes, fields)\n\n        if len(self.cotisation.revenus_parents) < 2:\n            RemoveNodesContaining(lignes, \"parent2\")\n        elif not self.cotisation.revenus_parents[1][2]:\n            RemoveNodesContaining(lignes, \"abattement-parent2\")\n        if len(self.cotisation.revenus_parents) < 1:\n            RemoveNodesContaining(lignes, \"parent1\")\n        elif not self.cotisation.revenus_parents[0][2]:\n            RemoveNodesContaining(lignes, \"abattement-parent1\")\n            \n        if database.creche.mode_facturation == FACTURATION_FORFAIT_MENSUEL:\n            RemoveNodesContaining(lignes, \"assiette-annuelle\")\n            RemoveNodesContaining(lignes, \"assiette-mensuelle\")\n            RemoveNodesContaining(lignes, \"taux-effort\")\n            RemoveNodesContaining(lignes, \"heures-mois\")\n            RemoveNodesContaining(lignes, \"montant-heure-garde\")\n\n        return {}\ngeneration/contrat_accueil.py\nclass AvenantContratAccueilModifications(OdtDocumentAccueilModifications):\n    title = \"Avenant au contrat d'accueil\"\n    template = \"Avenant contrat accueil.odt\"\n\n    def __init__(self, who, date):\n        OdtDocumentAccueilModifications.__init__(self, who, date)\n        self.default_output = \"Avenant contrat accueil %s - %s.odt\" % (GetPrenomNom(who), GetDateString(date, weekday=False))\ndatabase.py\nclass Inscription(Base, PeriodeReference):\n    __tablename__ = \"inscriptions\"\n    idx = Column(Integer, primary_key=True)\n    inscrit_id = Column(Integer, ForeignKey(\"inscrits.idx\"))\n    inscrit = relationship(Inscrit)\n    preinscription = Column(Boolean)\n    reservataire_id = Column(Integer, ForeignKey(\"reservataires.idx\"))\n    reservataire = relationship(Reservataire)\n    groupe_id = Column(Integer, ForeignKey(\"groupes.idx\"))\n    groupe = relationship(\"Groupe\")\n    forfait_mensuel = Column(Float, default=0)\n    frais_inscription = Column(Float, default=0)\n    allocation_mensuelle_caf = Column(Float)\n    site_id = Column(Integer, ForeignKey(\"sites.idx\"))\n    site = relationship(Site)\n    _sites_preinscription = Column(String, name=\"sites_preinscription\")\n    professeur_id = Column(Integer, ForeignKey(\"professeurs.idx\"))\n    professeur = relationship(Professeur)\n    debut_asap = Column(Boolean)\n    debut = Column(Date)\n    fin = Column(Date)\n    depart = Column(Date)\n    mode = Column(Integer)\n    fin_periode_adaptation = Column(Date)\n    duree_reference = Column(Integer, default=7)\n    forfait_mensuel_heures = Column(Float, default=0)\n    semaines_conges = Column(Integer, default=0)\n    heures_permanences = Column(Float, default=0)\n    newsletters = Column(Integer, default=\"\")\n    tarifs = Column(Integer, default=0)\n    days = relationship(\"TimeslotInscription\", collection_class=lambda: DayCollection(\"day\"), cascade=\"all, delete-orphan\")\n\n    def __init__(self, inscrit, mode=MODE_TEMPS_PARTIEL, duree_reference=7, debut=datetime.date.today(), forfait_mensuel_heures=0, forfait_mensuel=0, frais_inscription=0, semaines_conges=0, heures_permanences=0, tarifs=0, allocation_mensuelle_caf=0, **kwargs):\n        Base.__init__(self, inscrit=inscrit, mode=mode, duree_reference=duree_reference, debut=debut, forfait_mensuel_heures=forfait_mensuel_heures, forfait_mensuel=forfait_mensuel, frais_inscription=frais_inscription, semaines_conges=semaines_conges, heures_permanences=heures_permanences, tarifs=tarifs, allocation_mensuelle_caf=allocation_mensuelle_caf, **kwargs)\n        if is_power_of_two(inscrit.creche.modes_inscription):\n            self.mode = int(math.log(inscrit.creche.modes_inscription, 2))\n        self.__dict__[\"sites_preinscription\"] = []\n\n    @reconstructor\n    def init_on_load(self):\n        self.__dict__[\"sites_preinscription\"] = []\n        if self._sites_preinscription:\n            sites_list = [int(index) for index in self._sites_preinscription.split()]\n            for site in self.inscrit.creche.sites:\n                if site.idx in sites_list:\n                    self.sites_preinscription.append(site)\n\n    def __setattr__(self, name, value):\n        Base.__setattr__(self, name, value)\n        # TODO remove this in next conversions\n        if name == \"sites_preinscription\":\n            self._sites_preinscription = \" \".join([str(value.idx) for value in value])\n\n    def GetNombreJoursCongesPeriode(self):\n        if self.preinscription:\n            return 0\n        elif self.semaines_conges:\n            if self.mode == MODE_FORFAIT_HEBDOMADAIRE:\n                return self.semaines_conges * 7\n            else:\n                return self.semaines_conges * self.get_days_per_week()\n        else:\n            return 0\n\n    def GetNombreJoursCongesPris(self, debut, fin):\n        jours = 0\n        date = debut\n        # print \"GetNombreJoursCongesPris(%s - %s)\" % (debut, fin)\n\n        if config.options & REGULARISATION_UNIQUEMENT_SEMAINES_FERMETURE:\n            while date <= fin:\n                if date in self.inscrit.creche.jours_conges:\n                    # print(date)\n                    jours += 1\n                date += datetime.timedelta(1)\n            return jours\n\n        while date <= fin:\n            if self.mode in (MODE_FORFAIT_HEBDOMADAIRE, MODE_FORFAIT_MENSUEL):\n                if date in self.inscrit.creche.periodes_fermeture or date in self.inscrit.jours_conges:\n                    # print(date)\n                    jours += 1\n            else:\n                state = self.inscrit.get_state(date)\n                if self.inscrit.creche.facturation_jours_feries == ABSENCES_DEDUITES_EN_JOURS:\n                    if state == VACANCES:\n                        # print(\"VACANCES\", date)\n                        jours += 1\n                else:\n                    if state in (ABSENT, VACANCES):\n                        reference = self.get_day_from_date(date)\n                        if reference.get_duration() > 0:\n                            # print(date)\n                            jours += 1\n            date += datetime.timedelta(1)\n        return jours\n\n    def GetDebutDecompteJoursConges(self):\n        if self.fin_periode_adaptation:\n            return self.fin_periode_adaptation + datetime.timedelta(1)\n        else:\n            return self.debut\n\n    def GetFin(self):\n        return self.depart if (self.inscrit.creche.gestion_depart_anticipe and self.depart) else (self.fin if self.fin else datetime.date.max)\n\n    def GetFinDecompteJoursConges(self):\n        if self.inscrit.creche.gestion_depart_anticipe and self.depart:\n            return self.depart\n        else:\n            return self.fin\n\n    def GetNombreJoursCongesPoses(self):\n        if self.debut and self.fin and not self.preinscription:\n            return self.GetNombreJoursCongesPris(self.GetDebutDecompteJoursConges(), self.GetFinDecompteJoursConges())\n        else:\n            return 0\n\n    def IsNombreSemainesCongesDepasse(self, jalon):\n        if self.inscrit.creche.facturation_jours_feries == ABSENCES_DEDUITES_SANS_LIMITE:\n            return False\n        if self.mode == MODE_FORFAIT_GLOBAL_CONTRAT:\n            return False\n        if self.debut:\n            if not self.semaines_conges:\n                return True\n            debut = self.GetDebutDecompteJoursConges()\n            pris = self.GetNombreJoursCongesPris(debut, jalon)\n            total = self.GetNombreJoursCongesPeriode()\n            return pris > total\n        else:\n            return False\n\n    def GetDatesFromReference(self, index):\n        if self.debut is not None:\n            fin = self.fin if self.fin else datetime.date(self.debut.year + 1, self.debut.month, self.debut.day)\n            date = self.debut + datetime.timedelta(index + 7 - self.debut.weekday())\n            while date < fin:\n                yield date\n                date += datetime.timedelta(self.duree_reference)\n\n    def IsInPeriodeAdaptation(self, date):\n        if self.debut is None or self.fin_periode_adaptation is None:\n            return False\n        return self.debut <= date <= self.fin_periode_adaptation\n\n    def GetListeActivites(self):\n        result = []\n        for i in range(self.duree_reference):\n            jour = self.get_day_from_index(i)\n            s = jour.GetHeureArriveeDepart()\n            if s:\n                if self.duree_reference <= 7:\n                    s = days[i] + \" \" + s\n                else:\n                    s = days[i % 7] + \" semaine %d\" % (1 + (i / 7)) + s\n                result.append(s)\n        return ', '.join(result)\ndatabase.py\nclass Parent(Base):\n    __tablename__ = \"parents\"\n    idx = Column(Integer, primary_key=True)\n    famille_id = Column(Integer, ForeignKey(\"familles.idx\"))\n    famille = relation(Famille)\n    sexe = Column(Integer, default=MASCULIN)\n    prenom = Column(String, default=\"\")\n    nom = Column(String, default=\"\")\n    adresse = Column(String, default=\"\")\n    code_postal = Column(Integer, default=\"\")\n    ville = Column(String, default=\"\")\n    telephone_domicile = Column(String, default=\"\")\n    telephone_domicile_notes = Column(String, default=\"\")\n    telephone_portable = Column(String, default=\"\")\n    telephone_portable_notes = Column(String, default=\"\")\n    telephone_travail = Column(String, default=\"\")\n    telephone_travail_notes = Column(String, default=\"\")\n    profession = Column(String, default=\"\")\n    email = Column(String, default=\"\")\n    revenus = relationship(\"Revenu\", cascade=\"all, delete-orphan\")\n\n    def __init__(self, famille, sexe=FEMININ, prenom=\"\", nom=\"\", adresse=\"\", code_postal=\"\", ville=\"\",\n                 telephone_domicile=\"\", telephone_domicile_notes=\"\", telephone_portable=\"\", telephone_portable_notes=\"\", telephone_travail=\"\", telephone_travail_notes=\"\",\n                 profession=\"\", email=\"\", add_revenus=True, **kwargs):\n        Base.__init__(self,\n                      famille=famille,\n                      sexe=sexe,\n                      prenom=prenom,\n                      nom=nom,\n                      adresse=adresse,\n                      code_postal=code_postal,\n                      ville=ville,\n                      telephone_domicile=telephone_domicile,\n                      telephone_domicile_notes=telephone_domicile_notes,\n                      telephone_portable=telephone_portable,\n                      telephone_portable_notes=telephone_portable_notes,\n                      telephone_travail=telephone_travail,\n                      telephone_travail_notes=telephone_travail_notes,\n                      profession=profession,\n                      email=email,\n                      **kwargs)\n        if add_revenus:\n            date_revenus = famille.creche.GetDateRevenus(datetime.date.today())\n            self.revenus.append(Revenu(self, GetYearStart(date_revenus), GetYearEnd(date_revenus)))\ndatabase.py\nclass CongeInscrit(Base):\n    __tablename__ = \"conges_inscrits\"\n    idx = Column(Integer, primary_key=True)\n    inscrit_id = Column(Integer, ForeignKey(\"inscrits.idx\"))\n    inscrit = relationship(Inscrit)\n    debut = Column(String)\n    fin = Column(String)\n    label = Column(String)\n\n    def __init__(self, inscrit, **kwargs):\n        Base.__init__(self, inscrit=inscrit, **kwargs)\n\n    def __setattr__(self, name, value):\n        # Call the parent class method first.\n        super(CongeInscrit, self).__setattr__(name, value)\n        if self.inscrit and name in (\"debut\", \"fin\"):\n            self.inscrit.calcule_jours_conges()\ngeneration/contrat_accueil.py\nclass DevisAccueilModifications(OdtDocumentAccueilModifications):\n    title = \"Devis\"\n    template = \"Devis accueil.odt\"\n\n    def __init__(self, who, date):\n        OdtDocumentAccueilModifications.__init__(self, who, date)\n        self.default_output = \"Devis accueil %s - %s.odt\" % (GetPrenomNom(who), GetDateString(date, weekday=False))\n", "answers": ["        DocumentDialog(self, AvenantContratAccueilModifications(self.inscrit, self.current_cotisation[0])).ShowModal()"], "length": 3291, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "6b4f4a52ac5e336182dc4a4f91a06a0476144355eda7d4f7"}
{"input": "package io.github.redwallhp.athenagm;\nimport com.sk89q.worldedit.bukkit.WorldEditPlugin;\nimport io.github.redwallhp.athenagm.arenas.ArenaHandler;\nimport io.github.redwallhp.athenagm.commands.AdminCommands;\nimport io.github.redwallhp.athenagm.commands.ArenaCommands;\nimport io.github.redwallhp.athenagm.commands.MatchCommands;\nimport io.github.redwallhp.athenagm.configuration.Configuration;\nimport io.github.redwallhp.athenagm.hub.Hub;\nimport io.github.redwallhp.athenagm.maps.VoidGenerator;\nimport io.github.redwallhp.athenagm.modules.Module;\nimport io.github.redwallhp.athenagm.modules.ModuleLoader;\nimport io.github.redwallhp.athenagm.regions.RegionHandler;\nimport io.github.redwallhp.athenagm.tracker.Tracker;\nimport org.bukkit.Bukkit;\nimport org.bukkit.generator.ChunkGenerator;\nimport org.bukkit.plugin.Plugin;\nimport org.bukkit.plugin.java.JavaPlugin;\nimport java.io.File;\n\n\n\n\n/**\n * Project copyright 2015 redwall_hp\n * Licensed under the Lesser GNU Public License\n * http://www.gnu.org/licenses/lgpl-3.0.en.html\n * http://github.com/redwallhp\n */\npublic class AthenaGM extends JavaPlugin {\n\n\n    public Configuration config;", "context": "src/main/java/io/github/redwallhp/athenagm/commands/MatchCommands.java\npublic class MatchCommands implements CommandExecutor {\n\n\n    private AthenaGM plugin;\n\n\n    public MatchCommands(AthenaGM plugin) {\n        this.plugin = plugin;\n        plugin.getCommand(\"teams\").setExecutor(this);\n        plugin.getCommand(\"team\").setExecutor(this);\n        plugin.getCommand(\"autojoin\").setExecutor(this);\n        plugin.getCommand(\"spectate\").setExecutor(this);\n        plugin.getCommand(\"score\").setExecutor(this);\n        plugin.getCommand(\"players\").setExecutor(this);\n        plugin.getCommand(\"timeleft\").setExecutor(this);\n        plugin.getCommand(\"tmsg\").setExecutor(this);\n    }\n\n\n    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n\n        if (cmd.getName().equalsIgnoreCase(\"teams\")) {\n            listTeams(sender);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"team\")) {\n            joinTeam(sender, args);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"autojoin\")) {\n            autoJoinTeam(sender);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"spectate\")) {\n            String[] arguments = { \"spectator\" };\n            joinTeam(sender, arguments);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"score\")) {\n            printPlayerScore(sender);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"players\")) {\n            printPlayersList(sender);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"timeleft\")) {\n            timeLeft(sender, args);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"tmsg\")) {\n            teamChat(sender, args);\n            return true;\n        }\n\n        return false;\n\n    }\n\n\n    private void listTeams(CommandSender sender) {\n\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"You must join an arena to list teams.\");\n            return;\n        }\n\n        Player player = (Player) sender;\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(player);\n\n        if (arena == null) {\n            sender.sendMessage(ChatColor.RED + \"You must join an arena to list teams.\");\n            return;\n        }\n\n        List<String> teamStrings = new ArrayList<String>();\n        for (Team team : arena.getMatch().getTeams().values()) {\n            teamStrings.add(String.format(\"%s%s (%d/%d)%s\", team.getChatColor(), team.getId(), team.getPlayers().size(), team.getSize(), ChatColor.RESET));\n        }\n\n        String list = StringUtil.joinList(\", \", teamStrings);\n        sender.sendMessage(String.format(\"%sTeams: %s\", ChatColor.DARK_AQUA, list));\n\n    }\n\n\n    private void joinTeam(CommandSender sender, String[] args) {\n\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't join a team.\");\n            return;\n        }\n\n        if (args.length != 1) {\n            sender.sendMessage(ChatColor.RED + \"Usage: /team <team id>\");\n            return;\n        }\n\n        Player player = (Player) sender;\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(player);\n\n        if (arena == null) {\n            sender.sendMessage(ChatColor.RED + \"You must join an arena first.\");\n            return;\n        }\n\n        for (Team team : arena.getMatch().getTeams().values()) {\n            if (team.getId().equalsIgnoreCase(args[0])) {\n                team.add(player, false);\n                return;\n            }\n        }\n\n        sender.sendMessage(ChatColor.RED + \"Invalid team id.\");\n\n    }\n\n\n    private void autoJoinTeam(CommandSender sender) {\n\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't join a team.\");\n            return;\n        }\n\n        Player player = (Player) sender;\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(player);\n\n        if (arena == null) {\n            sender.sendMessage(ChatColor.RED + \"You must join an arena first.\");\n            return;\n        }\n\n        Team lowest = null;\n        for (Team t : arena.getMatch().getTeams().values()) {\n            if (t.isSpectator()) continue;\n            if (t.getPlayers().size() >= t.getSize()) continue;\n            if (lowest == null || t.getPlayers().size() < lowest.getPlayers().size()) {\n                lowest = t;\n            }\n        }\n\n        if (lowest != null) {\n            lowest.add(player, false);\n        } else {\n            sender.sendMessage(ChatColor.RED + \"Unable to join team.\");\n        }\n\n    }\n\n\n    private void printPlayerScore(CommandSender sender) {\n\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't have a score.\");\n            return;\n        }\n\n        Player player = (Player) sender;\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(player);\n        if (arena == null) {\n            sender.sendMessage(ChatColor.RED + \"You must join an arena first.\");\n            return;\n        }\n        Team team = PlayerUtil.getTeamForPlayer(arena.getMatch(), player);\n        if (team == null || team.isSpectator()) {\n            sender.sendMessage(ChatColor.RED + \"You must join a team to have a score.\");\n            return;\n        }\n        PlayerScore playerScore = team.getPlayerScore(player);\n\n        LinkedHashMap<String, Integer> values = new LinkedHashMap<String, Integer>();\n        values.put(\"Points\", playerScore.getPoints());\n        values.put(\"Kills\", playerScore.getKills());\n        values.put(\"Deaths\", playerScore.getDeaths());\n        try {\n            values.put(\"KDR\", (playerScore.getKills() / playerScore.getDeaths()));\n        } catch(ArithmeticException ex) {\n            if (playerScore.getKills() > 0) {\n                values.put(\"KDR\", playerScore.getKills());\n            } else {\n                values.put(\"KDR\", 0);\n            }\n        }\n\n        StringBuilder sb = new StringBuilder(ChatColor.DARK_AQUA + \"Personal score: \");\n        for (Map.Entry<String, Integer> pair : values.entrySet()) {\n            sb.append(String.format(\"%s%s: %s%d\", ChatColor.AQUA, pair.getKey(), ChatColor.GREEN, pair.getValue()));\n            sb.append(\" \");\n        }\n        sender.sendMessage(sb.toString());\n\n    }\n\n\n    private void printPlayersList(CommandSender sender) {\n\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't join a team.\");\n            return;\n        }\n\n        Player player = (Player) sender;\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(player);\n\n        if (arena == null) {\n            sender.sendMessage(ChatColor.RED + \"You must join an arena first.\");\n            return;\n        }\n\n        for (Team team : arena.getMatch().getTeams().values()) {\n\n            if (team.getPlayers().size() < 1) continue;\n\n            TreeMap<Integer, PlayerScore> ranking = new TreeMap<Integer, PlayerScore>();\n            for (Player p : team.getPlayers()) {\n                PlayerScore ps = team.getPlayerScore(p);\n                ranking.put(ps.getOverallScore(), ps);\n            }\n\n            StringBuilder sb = new StringBuilder(team.getColoredName() + ChatColor.RESET + \": \");\n            for (PlayerScore ps : ranking.values()) {\n                sb.append(String.format(\"%s %s(%d)%s\", ps.getPlayer().getName(), ChatColor.GRAY, ps.getOverallScore(), ChatColor.RESET));\n                if (ranking.lastEntry().getValue() != ps) {\n                    sb.append(\", \");\n                }\n            }\n            sender.sendMessage(sb.toString());\n\n        }\n\n    }\n\n\n    private void timeLeft(CommandSender sender, String[] args) {\n\n        Arena arena = null;\n\n        if (!(sender instanceof Player) && args.length < 1) {\n            sender.sendMessage(ChatColor.RED + \"Specify an arena name to see the time left in the match. (/timeleft <arena>)\");\n            return;\n        }\n\n        if (args.length == 1) {\n            for (Arena a : plugin.getArenaHandler().getArenas()) {\n                if (a.getId().equalsIgnoreCase(args[0])) {\n                    arena = a;\n                    break;\n                }\n            }\n        } else {\n            Player player = (Player) sender;\n            arena = plugin.getArenaHandler().getArenaForPlayer(player);\n        }\n\n        if (arena != null) {\n            String secString = \"00\";\n            String minString = \"00\";\n            if (arena.getMatch().getTimer() != null) {\n                long secondsLeft = arena.getMatch().getTimer().timeLeftInSeconds();\n                long sec = secondsLeft % 60;\n                long min = (secondsLeft / 60) % 60;\n                secString = String.format(\"%02d\", sec);\n                minString = String.format(\"%02d\", min);\n            }\n            sender.sendMessage(String.format(\"%s%s:%s\", ChatColor.DARK_AQUA, minString, secString));\n        } else {\n            sender.sendMessage(ChatColor.RED + \"You must join an arena first, or use /timeleft <arena>\");\n        }\n\n    }\n\n\n    private void teamChat(CommandSender sender, String[] args) {\n\n        if (!(sender instanceof Player) || args.length < 1) {\n            sender.sendMessage(ChatColor.RED + \"Send a message to your team: /t <msg>\");\n            return;\n        } else {\n            ChatModule cm = (ChatModule) plugin.getModule(\"chat\");\n            boolean success = cm.sendTeamMessage((Player) sender, StringUtil.joinArray(\" \", args));\n            if (!success) {\n                sender.sendMessage(ChatColor.RED + \"You must be on a team to do that.\");\n            }\n        }\n\n    }\n\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/hub/Hub.java\npublic class Hub {\n\n\n    private AthenaGM plugin;\n    private HubListener listener;\n    private HubConfiguration config;\n    private WeakReference<World> world;\n    private ItemStack helpBookItem;\n\n\n    public Hub(AthenaGM plugin) {\n\n        this.plugin = plugin;\n        this.world = null;\n        this.listener = new HubListener(plugin, this);\n        this.helpBookItem = loadHelpBookItem();\n\n        try {\n            config = new HubConfiguration(this, new File(plugin.getDataFolder(), \"hub.yml\"));\n        } catch (IOException ex) {\n            plugin.getLogger().warning(ex.getMessage());\n        }\n\n        Bukkit.getScheduler().runTask(this.plugin, new Runnable() {\n            public void run() {\n                loadWorld();\n                loadPortalRegions();\n                updatePortalSigns();\n            }\n        });\n\n    }\n\n\n    /**\n     * Loads the world from disk and prepares it for use\n     */\n    private void loadWorld() {\n        if (config.getWorldName() == null || config.getWorldName().equalsIgnoreCase(\"\")) return;\n        File file = new File(Bukkit.getWorldContainer(), config.getWorldName());\n        if (file.exists()) {\n            try {\n                WorldCreator creator = new WorldCreator(config.getWorldName());\n                creator.generator(new VoidGenerator());\n                creator.environment(World.Environment.NORMAL);\n                creator.generateStructures(false);\n                World world = creator.createWorld();\n                world.setPVP(false);\n                world.setSpawnFlags(false, false); //no mobs\n                world.setKeepSpawnInMemory(false);\n                this.world = new WeakReference<World>(world);\n            } catch (Exception ex) {\n                plugin.getLogger().warning(\"Error loading hub world: \" + ex.getMessage());\n                if (plugin.config.DEBUG) {\n                    ex.printStackTrace();\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Set up the Hub portals.\n     * Creates new Regions for the Hub world, and applies a StringFlag with the value of the arena ID, which\n     * the Region system's PlayerMovementListener can watch for.\n     */\n    private void loadPortalRegions() {\n        if (getWorld() == null || config.getPortals() == null) return;\n        for (HubPortal portal : config.getPortals()) {\n            CuboidRegion region = new CuboidRegion(portal.getArena().getId(), getWorld(), portal.getStart(), portal.getEnd());\n            StringFlag portalFlag = new StringFlag(\"join_arena\");\n            portalFlag.setValue(portal.getArena().getId());\n            region.setFlag(portalFlag);\n            plugin.getRegionHandler().addRegion(region);\n        }\n    }\n\n\n    /**\n     * Update the arena information on Hub signs every couple of seconds\n     */\n    private void updatePortalSigns() {\n        if (config.getSigns() == null || config.getSigns().size() < 1 || getWorld() == null) return;\n        Bukkit.getScheduler().runTaskTimer(this.plugin, new Runnable() {\n            public void run() {\n                for (HubSign sign : config.getSigns()) {\n                    sign.update();\n                }\n            }\n        }, 40L, 40L);\n    }\n\n\n    /**\n     * Handle player spawning on join. Ensures a player rejoining will always go to the Hub and not a stale Match.\n     * Order of priority:\n     * 1. If dedicated mode is on, put the player directly in the specified arena if it exists. Fall back to defaul world.\n     * 2. If the world specified in hub.yml exists and is loaded, spawn the player there.\n     * 3. If all else fails, teleport them to the default world.\n     */\n    public void spawnPlayer(Player player) {\n        playerSetUp(player);\n        if (plugin.config.DEDICATED_ARENA != null) {\n            // If dedicated mode is on, put the player directly in an arena, as a hub is not desired\n            for (Arena arena : plugin.getArenaHandler().getArenas()) {\n                if (arena.getId().equalsIgnoreCase(plugin.config.DEDICATED_ARENA)) {\n                    player.teleport(arena.getWorld().getSpawnLocation());\n                    return;\n                }\n            }\n            player.teleport(Bukkit.getWorld(\"world\").getSpawnLocation());\n        } else if (getWorld() != null) {\n            // Spawn the player in the loaded hub world if the world specified in hub.yml exists\n            player.teleport(getWorld().getSpawnLocation());\n        } else {\n            // Spawn the player in the default world if all else fails\n            player.teleport(Bukkit.getWorld(\"world\").getSpawnLocation());\n        }\n    }\n\n\n    /**\n     * Reset player attributes and visibility\n     */\n    public void playerSetUp(Player player) {\n        PlayerUtil.resetPlayer(player);\n        player.setGameMode(GameMode.ADVENTURE);\n        player.spigot().setCollidesWithEntities(false);\n        player.setScoreboard(Bukkit.getScoreboardManager().getNewScoreboard());\n        for (Player p : Bukkit.getServer().getOnlinePlayers()) p.showPlayer(player);\n        for (Player p : Bukkit.getServer().getOnlinePlayers()) player.showPlayer(p);\n        if (config.isHelpBook()) {\n            player.getInventory().addItem(helpBookItem);\n        }\n    }\n\n\n    /**\n     * Load the help book for the Hub\n     */\n    private ItemStack loadHelpBookItem() {\n        File file = new File(plugin.getDataFolder(), \"helpbook.txt\");\n        BookBuilder bookBuilder = new BookBuilder(\"Help\");\n        bookBuilder.setDefaultContents(\"This book will be populated with the contents of a &lhelpbook.txt&0 file in the plugin directory.\");\n        bookBuilder.setPagesFromFile(file);\n        this.helpBookItem = bookBuilder.getBook(); //cache to avoid hitting the disk all the time\n        return bookBuilder.getBook();\n    }\n\n\n    /**\n     * Get an instance of the Hub world\n     * @return Returns the World if applicable or null if a World is not loaded\n     */\n    public World getWorld() {\n        if (world != null) {\n            return world.get();\n        } else {\n            return null;\n        }\n    }\n\n\n    /**\n     * Convenience method to check if a player is in the Hub world\n     * @param player Player to check\n     * @return True if the player is in the Hub world\n     */\n    public boolean hasPlayer(Player player) {\n        return getWorld() != null && player.getWorld().equals(getWorld());\n    }\n\n\n    /**\n     * Get the plugin instance\n     */\n    public AthenaGM getPlugin() {\n        return this.plugin;\n    }\n\n\n    /**\n     * Get the HubConfiguration instance\n     */\n    public HubConfiguration getConfig() {\n        return config;\n    }\n\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/modules/Module.java\npublic interface Module extends Listener {\n\n\n    /**\n     * A string identifier for the module, to be used for getting instances with\n     * the getModule() method.\n     * @see ModuleLoader\n     */\n    String getModuleName();\n\n\n    /**\n     * Called when the plugin unloads. This is a good place to clean up database connections, etc.\n     */\n    void unload();\n\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/commands/AdminCommands.java\npublic class AdminCommands implements CommandExecutor {\n\n\n    private AthenaGM plugin;\n\n\n    public AdminCommands(AthenaGM plugin) {\n        this.plugin = plugin;\n        plugin.getCommand(\"athena\").setExecutor(this);\n        plugin.getCommand(\"region\").setExecutor(this);\n    }\n\n\n    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n\n        if (cmd.getName().equalsIgnoreCase(\"athena\")) {\n            if (args.length == 0) {\n                sender.sendMessage(ChatColor.RED + \"Valid subcommands: reload, forcestart, changemap, checkperms\");\n            }\n            else if (args[0].equalsIgnoreCase(\"reload\")) {\n                reloadCommand(sender, args);\n            }\n            else if (args[0].equalsIgnoreCase(\"forcestart\")) {\n                forceStartCommand(sender, args);\n            }\n            else if (args[0].equalsIgnoreCase(\"changemap\")) {\n                changeMapCommand(sender, args);\n            }\n            else if (args[0].equalsIgnoreCase(\"checkperms\")) {\n                checkPerms(sender, args);\n            }\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"region\")) {\n            if (args.length == 0) {\n                sender.sendMessage(ChatColor.RED + \"Valid subcommands: info, select\");\n            }\n            else if (args[0].equalsIgnoreCase(\"info\")) {\n                regionInfoCommand(sender, args);\n            }\n            else if (args[0].equalsIgnoreCase(\"select\")) {\n                regionSelectCommand(sender, args);\n            }\n            return true;\n        }\n\n        return false;\n\n    }\n\n\n    private void reloadCommand(CommandSender sender, String[] args) {\n\n        if (args.length < 2) {\n            sender.sendMessage(ChatColor.RED + \"Usage: /athena reload <what>\");\n            sender.sendMessage(ChatColor.RED + \"What: permissions, helpbook\");\n            return;\n        }\n\n        String what = args[1];\n\n        if (what.equalsIgnoreCase(\"permissions\")) {\n            PermissionsModule module = (PermissionsModule) plugin.getModule(\"permissions\");\n            module.reloadPermissions();\n            sender.sendMessage(ChatColor.LIGHT_PURPLE + \"Permissions reloaded.\");\n        }\n\n        if (what.equalsIgnoreCase(\"helpbook\")) {\n            SpectatorModule module = (SpectatorModule) plugin.getModule(\"spectator\");\n            module.getHelpBookItem();\n            sender.sendMessage(ChatColor.LIGHT_PURPLE + \"Spectator help book reloaded.\");\n        }\n\n    }\n\n\n    private void forceStartCommand(CommandSender sender, String[] args) {\n\n        if (args.length < 2) {\n            sender.sendMessage(ChatColor.RED + \"Usage: /athena forcestart <arena>\");\n            return;\n        }\n\n        for (Arena arena : plugin.getArenaHandler().getArenas()) {\n            if (arena.getId().equalsIgnoreCase(args[1])) {\n                sender.sendMessage(ChatColor.DARK_AQUA + \"Forcing match start.\");\n                arena.getMatch().startCountdown();\n                break;\n            }\n        }\n\n    }\n\n\n    private void changeMapCommand(CommandSender sender, String[] args) {\n\n        if (args.length < 2) {\n            sender.sendMessage(ChatColor.RED + \"Usage: /athena changemap <arena> <map>\");\n            return;\n        }\n\n        for (Arena arena : plugin.getArenaHandler().getArenas()) {\n            if (arena.getId().equalsIgnoreCase(args[1])) {\n                boolean success = arena.forceMapChange(args[2]);\n                if (!success) {\n                    sender.sendMessage(ChatColor.RED + \"There is no configured map by that name.\");\n                }\n                break;\n            }\n        }\n\n    }\n\n\n    private void checkPerms(CommandSender sender, String[] args) {\n\n        if (args.length < 2) {\n            sender.sendMessage(ChatColor.RED + \"Usage: /athena checkperms <player>\");\n        }\n\n        Player player = plugin.getServer().getPlayer(args[1]);\n        if (player != null) {\n            PermissionsModule module = (PermissionsModule) plugin.getModule(\"permissions\");\n            sender.sendMessage(\"Results printed to console.\");\n            plugin.getServer().getLogger().info(String.format(\"--- Permission Check for %s ---\", player.getName()));\n            plugin.getServer().getLogger().info(\"UUID: \" + player.getUniqueId());\n            if (module.getUsers().containsKey(player.getUniqueId())) {\n                String group = module.getUsers().get(player.getUniqueId()).getGroup();\n                plugin.getServer().getLogger().info(\"Group: \" + group);\n            }\n            for (PermissionAttachmentInfo info : player.getEffectivePermissions()) {\n                plugin.getServer().getLogger().info(\"* \" + info.getPermission());\n            }\n            plugin.getServer().getLogger().info(\"--- End Permission Check ---\");\n        } else {\n            sender.sendMessage(ChatColor.RED + \"Could not find online player.\");\n        }\n\n    }\n\n\n    private void regionInfoCommand(CommandSender sender, String[] args) {\n\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't run this command.\");\n            return;\n        }\n\n        Player player = (Player) sender;\n\n        Location loc = player.getLocation();\n        CuboidRegion rg = plugin.getRegionHandler().getApplicableRegion(loc.getWorld(), loc.toVector());\n        if (rg != null) {\n            StringBuilder inherited = new StringBuilder();\n            List<CuboidRegion> all = plugin.getRegionHandler().getAllApplicableRegions(loc);\n            for (CuboidRegion ir : all) {\n                inherited.append(ir.getName());\n                if (all.indexOf(ir) < all.size() - 1) inherited.append(\", \");\n            }\n            sender.sendMessage(String.format(\"%sYou are standing in '%s'\", ChatColor.DARK_AQUA, rg.getName()));\n            sender.sendMessage(String.format(\"%sInherits from: %s\", ChatColor.DARK_AQUA, inherited.toString()));\n            sender.sendMessage(String.format(\"%sStart: %s, End: %s\", ChatColor.DARK_AQUA, rg.getStart().toString(), rg.getEnd().toString()));\n        }\n\n    }\n\n\n    private void regionSelectCommand(CommandSender sender, String[] args) {\n\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't run this command.\");\n            return;\n        }\n\n        Player player = (Player) sender;\n\n        if (args.length < 2) {\n            sender.sendMessage(ChatColor.RED + \"Usage: /region select <name>\");\n            return;\n        }\n\n        CuboidRegion rg = plugin.getRegionHandler().getRegion(player.getWorld(), args[1]);\n        if (rg == null) {\n            sender.sendMessage(String.format(\"%sCould not find region \\\"%s\\\"\", ChatColor.RED, args[1]));\n            return;\n        }\n\n        if (plugin.getWE() == null) {\n            sender.sendMessage(ChatColor.RED + \"WorldEdit does not appear to be installed.\");\n        } else {\n            WorldEditUtil.setPlayerSelection(player, rg.getWorld(), rg.getMin(), rg.getMax());\n            sender.sendMessage(String.format(\"%sSelected region \\\"%s\\\"\", ChatColor.DARK_AQUA, rg.getName()));\n        }\n\n    }\n\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/arenas/ArenaHandler.java\npublic class ArenaHandler {\n\n\n    private AthenaGM plugin;\n    private Map<String, Arena> arenas;\n\n\n    public ArenaHandler(AthenaGM plugin) {\n        this.plugin = plugin;\n        this.arenas = new HashMap<>();\n        MapLoader.cleanUpWorldInstances(plugin.getMatchesDirectory());\n        loadArenas();\n        plugin.getServer().getPluginManager().registerEvents(new ArenaListener(this), plugin);\n    }\n\n\n    private void loadArenas() {\n        for (ConfiguredArena ca : plugin.config.ARENAS.values()) {\n            Arena arena = new Arena(this, ca);\n            this.arenas.put(arena.getId(), arena);\n        }\n    }\n\n\n    public AthenaGM getPluginInstance() {\n        return this.plugin;\n    }\n\n\n    public Set<Arena> getArenas() {\n        return new HashSet<>(this.arenas.values());\n    }\n\n\n    public Arena getArenaForPlayer(Player player) {\n        for (Arena arena : this.arenas.values()) {\n            if (player.getWorld().equals(arena.getWorld())) {\n                return arena;\n            }\n        }\n        return null;\n    }\n\n\n    public Arena getArenaById(String id) {\n        if (this.arenas.containsKey(id)) {\n            return this.arenas.get(id);\n        }\n        return null;\n    }\n\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/commands/ArenaCommands.java\npublic class ArenaCommands implements CommandExecutor {\n\n\n    private AthenaGM plugin;\n\n\n    public ArenaCommands(AthenaGM plugin) {\n        this.plugin = plugin;\n        plugin.getCommand(\"hub\").setExecutor(this);\n        plugin.getCommand(\"arenas\").setExecutor(this);\n        plugin.getCommand(\"join\").setExecutor(this);\n        plugin.getCommand(\"votemap\").setExecutor(this);\n        plugin.getCommand(\"votenext\").setExecutor(this);\n        plugin.getCommand(\"vote\").setExecutor(this);\n    }\n\n\n    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n\n        if (cmd.getName().equalsIgnoreCase(\"hub\")) {\n            if (sender instanceof Player) {\n                plugin.getHub().spawnPlayer((Player) sender);\n            }\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"arenas\")) {\n            listArenas(sender);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"join\")) {\n            if (args.length == 1) {\n                joinArena(sender, args[0]);\n            } else {\n                sender.sendMessage(ChatColor.RED + \"Usage: /join <arena id>\");\n            }\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"votemap\")) {\n            voteMap(sender, args);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"votenext\")) {\n            voteNext(sender);\n            return true;\n        }\n\n        if (cmd.getName().equalsIgnoreCase(\"vote\")) {\n            if (args.length == 1) {\n                vote(sender, args[0]);\n            } else {\n                sender.sendMessage(ChatColor.RED + \"Usage: /vote <choice>\");\n            }\n            return true;\n        }\n\n        return false;\n\n    }\n\n\n    private void listArenas(CommandSender sender) {\n        for (Arena arena : plugin.getArenaHandler().getArenas()) {\n            int players = arena.getMatch().getTotalPlayers();\n            StringBuilder head = new StringBuilder(\"\" + ChatColor.STRIKETHROUGH);\n            head.append(\"--- \");\n            head.append(ChatColor.GRAY);\n            head.append(ChatColor.BOLD);\n            head.append(arena.getName());\n            head.append(ChatColor.RESET);\n            head.append(ChatColor.STRIKETHROUGH);\n            head.append(\" ---\");\n            String id = String.format(\"%sID: %s%s\", ChatColor.GRAY, ChatColor.WHITE, arena.getId());\n            String map = String.format(\"%sMap: %s%s\", ChatColor.GRAY, ChatColor.WHITE, arena.getMatch().getMap().getName());\n            String pl = String.format(\"%sPlayers: %s%d/%d\", ChatColor.GRAY, ChatColor.WHITE, players, arena.getMaxPlayers());\n            sender.sendMessage(head.toString());\n            sender.sendMessage(id + \" \" + map + \" \" + pl);\n        }\n        sender.sendMessage(ChatColor.DARK_AQUA + String.format(\"Use %s/join <id>%s to join an arena.\", ChatColor.GREEN, ChatColor.DARK_AQUA));\n    }\n\n\n    private void joinArena(CommandSender sender, String id) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't join an arena.\");\n            return;\n        }\n        for (Arena arena : plugin.getArenaHandler().getArenas()) {\n            if (arena.getId().equals(id)) {\n                Player player = (Player) sender;\n                Location loc = arena.getMatch().getSpawnPoint(player);\n                player.teleport(loc);\n                return;\n            }\n        }\n        sender.sendMessage(ChatColor.RED + String.format(\"Could not find arena '%s'\", id));\n    }\n\n\n    private void voteMap(CommandSender sender, String[] args) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't vote.\");\n            return;\n        }\n        Player player = (Player) sender;\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(player);\n        String map = (args.length == 1) ? args[0] : \"\";\n        VotingModule module = (VotingModule) plugin.getModule(\"voting\");\n        if (arena != null) {\n            module.createMapVote(arena, player, map);\n        }\n    }\n\n\n    private void voteNext(CommandSender sender) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't vote.\");\n            return;\n        }\n        Player player = (Player) sender;\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(player);\n        VotingModule module = (VotingModule) plugin.getModule(\"voting\");\n        if (arena != null) {\n            module.createNextMapVote(arena, player);\n        }\n    }\n\n\n    private void vote(CommandSender sender, String choice) {\n        if (!(sender instanceof Player)) {\n            sender.sendMessage(ChatColor.RED + \"Console can't vote.\");\n            return;\n        }\n        Player player = (Player) sender;\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(player);\n        VotingModule module = (VotingModule) plugin.getModule(\"voting\");\n        if (arena != null) {\n            module.vote(arena, player, choice);\n        }\n    }\n\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/regions/RegionHandler.java\npublic class RegionHandler {\n\n\n    private AthenaGM plugin;\n    private HashMap<UUID, LinkedHashMap<String, CuboidRegion>> regions;\n\n\n    public RegionHandler(AthenaGM plugin) {\n        this.plugin = plugin;\n        this.regions = new HashMap<UUID, LinkedHashMap<String, CuboidRegion>>();\n        listen();\n    }\n\n\n    private void listen() {\n        new BlockPlaceListener(this);\n        new BlockBreakListener(this);\n        new PlayerMovementListener(this);\n        new PlayerInteractListener(this);\n        new EnvironmentalListener(this);\n        new PistonListener(this);\n    }\n\n\n    /**\n     * Add a region to the map of currently loaded regions\n     */\n    public void addRegion(CuboidRegion region) {\n        UUID worldId = region.getWorld().getUID();\n        if (!regions.containsKey(worldId)) regions.put(worldId, new LinkedHashMap<String, CuboidRegion>());\n        regions.get(worldId).put(region.getName(), region);\n    }\n\n\n    /**\n     * Remove a region from the map of currently loaded regions\n     */\n    public void removeRegion(CuboidRegion region) {\n        UUID worldId = region.getWorld().getUID();\n        if (regions.containsKey(worldId)) {\n            regions.get(worldId).remove(region.getName());\n            if (regions.get(worldId).size() < 1) regions.remove(worldId);\n        }\n    }\n\n\n    /**\n     * Get a region by its name\n     */\n    public CuboidRegion getRegion(World world, String name) {\n        if (regions.containsKey(world.getUID())) {\n            return regions.get(world.getUID()).get(name);\n        } else {\n            return null;\n        }\n    }\n\n\n    /**\n     * Returns a list of all regions that intersect a given vector point in a world.\n     * @param world The world the vector is in\n     * @param vector The point to check for applicable regions\n     * @return A list of region objects\n     */\n    public List<CuboidRegion> getAllApplicableRegions(World world, Vector vector) {\n        List<CuboidRegion> inRegions = new ArrayList<CuboidRegion>();\n        if (regions.containsKey(world.getUID())) {\n            for (CuboidRegion region : regions.get(world.getUID()).values()) {\n                if (region.contains(world, vector)) inRegions.add(region);\n            }\n        }\n        return inRegions;\n    }\n\n\n    /**\n     * Alternate getAllApplicableRegions() method that takes a Location instead of a Vector.\n     * Returns a list of all regions that intersect a given vector point in a world.\n     * @param location A Location to check for applicable regions.\n     * @return A list of region objects\n     */\n    public List<CuboidRegion> getAllApplicableRegions(Location location) {\n        return getAllApplicableRegions(location.getWorld(), location.toVector());\n    }\n\n\n    /**\n     * Returns the region with the highest priority that intersects a given vector point.\n     * Priority is determined by the priority value in the YAML. If a priority is not specified,\n     * it will try to fall back to the configured ordinal index.\n     * Regions with a positive priority will take priority over all that don't specify one.\n     * @param world The world the vector is in\n     * @param vector The point to check for an applicable region\n     * @return A region object, or null if one does not exist at the vector's location\n     */\n    public CuboidRegion getApplicableRegion(World world, Vector vector) {\n\n        // Get the highest priority region\n        List<CuboidRegion> applicableRegions = getAllApplicableRegions(world, vector);\n        TreeMap<Integer, CuboidRegion> regionMap = new TreeMap<Integer, CuboidRegion>();\n        int i = 0;\n        for (CuboidRegion rg : applicableRegions) {\n            if (rg.getPriority() > 0) {\n                regionMap.put(rg.getPriority()+applicableRegions.size()+1, rg);\n            } else {\n                regionMap.put(i, rg);\n            }\n            i++;\n        }\n        if (regionMap.size() < 1) return null;\n        CuboidRegion r = regionMap.lastEntry().getValue();\n\n        // Create and return a compound region that inherits flags from lower regions\n        CuboidRegion compound = new CuboidRegion(r.getName(), r.getWorld(), r.getStart(), r.getEnd());\n        for (CuboidRegion rg : regionMap.values()) {\n            for (Map.Entry<String, Flag<?>> flag : rg.getFlags().entrySet()) {\n                compound.setFlag(flag.getValue());\n            }\n        }\n        return compound;\n\n    }\n\n\n    /**\n     * Alternate getApplicableRegion method that takes a Location instead of a Vector.\n     * Returns the region with the highest priority that intersects a given vector point.\n     * If the regions have equal priority, their ordinal index will be used instead, with\n     * later regions superseding previous ones.\n     * @param location A Location to check for an applicable region.\n     * @return A region object, or null if one does not exist at the vector's location\n     */\n    public CuboidRegion getApplicableRegion(Location location) {\n        return getApplicableRegion(location.getWorld(), location.toVector());\n    }\n\n\n    /**\n     * Load configured regions for a map. This is called when a new match starts.\n     */\n    public void loadRegions(World world, GameMap map) {\n        for (MapInfoRegion mir : map.getRegions().values()) {\n            CuboidRegion region = new CuboidRegion(mir.getName(), world, mir.getStart(), mir.getEnd());\n            region.setFlags(mir.getFlags());\n            region.setPriority(mir.getPriority());\n            addRegion(region);\n        }\n    }\n\n\n    /**\n     * Unload regions belonging to a world. Called when a match world is destructed.\n     */\n    public void unloadRegions(World world) {\n        if (regions.containsKey(world.getUID())) {\n            Iterator<CuboidRegion> iterator = regions.get(world.getUID()).values().iterator();\n            while (iterator.hasNext()) {\n                CuboidRegion region = iterator.next();\n                if (region.getWorld().getUID() == world.getUID()) {\n                    iterator.remove();\n                }\n            }\n            if (regions.get(world.getUID()).size() < 1) regions.remove(world.getUID());\n        }\n    }\n\n\n    /**\n     * Get the plugin reference\n     */\n    public AthenaGM getPlugin() {\n        return plugin;\n    }\n\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/maps/VoidGenerator.java\npublic class VoidGenerator extends ChunkGenerator {\n\n    @Override\n    public byte[][] generateBlockSections(World world, Random random, int x, int z, BiomeGrid biomes) {\n        return new byte[16][];\n    }\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/modules/ModuleLoader.java\npublic class ModuleLoader {\n\n\n    /**\n     * List of module classes to load\n     */\n    private static Class[] moduleClasses = {\n            PermissionsModule.class,\n            SpectatorModule.class,\n            KitsModule.class,\n            ScoreboardModule.class,\n            FriendlyFireModule.class,\n            BroadcastsModule.class,\n            PlayerFreezeModule.class,\n            DeathMessageModule.class,\n            WorldBorderModule.class,\n            ChatModule.class,\n            VotingModule.class\n    };\n\n\n    private AthenaGM plugin;\n    private HashMap<String, Module> modules;\n\n\n    public ModuleLoader(AthenaGM plugin) {\n        this.plugin = plugin;\n        this.modules = new HashMap<String, Module>();\n        load();\n    }\n\n\n    /**\n     * Build and load modules, registering their events and stashing references for later use.\n     * Modules are cast to their Module interface to make this sorcery work, but can be\n     * recast to their original class later in order to access methods.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void load() {\n        for (Class c : moduleClasses) {\n            try {\n                plugin.getLogger().info(String.format(\"Loading module: %s\", c.getName()));\n                Module module = (Module) c.getConstructor(AthenaGM.class).newInstance(plugin); //evil sorcery\n                plugin.getServer().getPluginManager().registerEvents(module, plugin);\n                modules.put(module.getModuleName(), module);\n            } catch (Exception ex) {\n                plugin.getLogger().warning(String.format(\"Error loading module '%s\", c.getName()));\n                ex.printStackTrace();\n            }\n        }\n    }\n\n\n    /**\n     * Iterate the loaded modules and call the unload() method each one implements.\n     */\n    public void unload() {\n        for (Module module : modules.values()) {\n            module.unload();\n        }\n    }\n\n\n    /**\n     * Get the module with a specified name.\n     * The returned object will be a Module, but you can recast it to the module's original class\n     * in order to access its methods. e.g. casting the module found by getting \"permissions\"\n     * to be a PermissionsModule will allow you to access its member methods.\n     * @param name Name of the module, as returned by its getModuleName() method\n     */\n    public Module getModule(String name) {\n        return modules.get(name);\n    }\n\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/configuration/Configuration.java\npublic class Configuration {\n\n    private final AthenaGM plugin;\n    public boolean DEBUG;\n    public String NETWORK_NAME;\n    public String DEDICATED_ARENA;\n    public boolean VOTING;\n    public HashMap<String, ConfiguredArena> ARENAS;\n\n    public Configuration(AthenaGM instance) {\n        plugin = instance;\n        plugin.saveDefaultConfig();\n        this.load();\n    }\n\n    /**\n     * Save the config out to disk\n     */\n    public void save() {\n        plugin.saveConfig();\n    }\n\n    /**\n     * Load the configuration from disk and set the simple keys to public properties\n     */\n    public void load() {\n        plugin.reloadConfig();\n        DEBUG = plugin.getConfig().getBoolean(\"debug\", false);\n        NETWORK_NAME = plugin.getConfig().getString(\"network_name\", \"Server\");\n        DEDICATED_ARENA = plugin.getConfig().getString(\"dedicated_arena\", null);\n        VOTING = plugin.getConfig().getBoolean(\"voting\", true);\n        getArenas();\n    }\n\n    /**\n     * Handle the loading of arena configuration blocks, creating ConfiguredArena objects\n     */\n    private void getArenas() {\n        this.ARENAS = new HashMap<String, ConfiguredArena>();\n        Set<String> ids = plugin.getConfig().getConfigurationSection(\"arenas\").getKeys(false);\n        if (ids.size() > 0) {\n            for (String id : ids) {\n                String name = plugin.getConfig().getString(String.format(\"arenas.%s.name\", id), \"Default Arena\");\n                String gameMode = plugin.getConfig().getString(String.format(\"arenas.%s.gamemode\", id), \"deathmatch\");\n                Integer timeLimit = plugin.getConfig().getInt(String.format(\"arenas.%s.time_limit\", id), 600);\n                List<String> mapList = plugin.getConfig().getStringList(String.format(\"arenas.%s.maps\", id));\n                ConfiguredArena arena = new ConfiguredArena(id, name, gameMode, timeLimit, mapList);\n                this.ARENAS.put(id, arena);\n            }\n        }\n    }\n\n}\nsrc/main/java/io/github/redwallhp/athenagm/tracker/Tracker.java\npublic class Tracker implements Listener {\n\n\n    private AthenaGM plugin;\n    private HashMap<UUID, PlayerDamagePlayerEvent> lastDamage;\n\n\n    public Tracker(AthenaGM plugin) {\n        this.plugin = plugin;\n        this.lastDamage = new HashMap<UUID, PlayerDamagePlayerEvent>();\n        plugin.getServer().getPluginManager().registerEvents(this, plugin);\n    }\n\n\n    /**\n     * Fire PlayerDamagePlayerEvent when a player attacks another player\n     * while in an ongoing match.\n     * @see PlayerDamagePlayerEvent\n     */\n    @EventHandler(priority = EventPriority.LOW)\n    public void triggerPlayerDamagePlayerEvent(EntityDamageByEntityEvent event) {\n\n        Player victim = null;\n        Player attacker = null;\n        boolean ranged = false;\n\n        // Melee\n        if (event.getEntityType().equals(EntityType.PLAYER) && event.getDamager().getType().equals(EntityType.PLAYER)) {\n            victim = (Player) event.getEntity();\n            attacker = (Player) event.getDamager();\n        }\n\n        // Projectile\n        if (event.getEntityType().equals(EntityType.PLAYER) && event.getCause().equals(EntityDamageEvent.DamageCause.PROJECTILE)) {\n            Projectile a = (Projectile) event.getDamager();\n            if (a.getShooter() instanceof Player) {\n                victim = (Player) event.getEntity();\n                attacker = (Player) a.getShooter();\n                ranged = true;\n            }\n        }\n\n        // Potion\n        if (event.getEntityType().equals(EntityType.PLAYER) && event.getCause().equals(EntityDamageEvent.DamageCause.MAGIC)) {\n            ThrownPotion potion = (ThrownPotion) event.getDamager();\n            if (potion.getShooter() instanceof Player) {\n                victim = (Player) event.getEntity();\n                attacker = (Player) potion.getShooter();\n                ranged = true;\n            }\n        }\n\n        if (attacker == null || victim == null) return;\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(victim);\n        if (arena == null) return;\n\n        PlayerDamagePlayerEvent e = new PlayerDamagePlayerEvent(arena.getMatch(), attacker, victim, ranged, event);\n        Bukkit.getPluginManager().callEvent(e);\n        if (e.isCancelled()) {\n            event.setCancelled(true);\n        } else {\n            lastDamage.put(victim.getUniqueId(), e);\n        }\n\n    }\n\n\n    /**\n     * Fire AthenaDeathEvent when a player dies during a match.\n     * @see AthenaDeathEvent\n     */\n    @EventHandler(priority = EventPriority.LOW)\n    public void triggerAthenaDeathEvent(PlayerDeathEvent event) {\n\n        Player player = event.getEntity();\n        Arena arena = plugin.getArenaHandler().getArenaForPlayer(player);\n        if (arena == null) return;\n        AthenaDeathEvent e;\n\n        PlayerDamagePlayerEvent damage = lastDamage.get(player.getUniqueId());\n        boolean wasPlayer = damage != null && System.currentTimeMillis() - damage.getTime() <= 7500;\n        if (wasPlayer) {\n            e = new AthenaDeathEvent(arena.getMatch(), damage.getVictim(), damage.getDamager(), damage, event);\n        } else {\n            e = new AthenaDeathEvent(arena.getMatch(), player, event);\n        }\n\n        Bukkit.getPluginManager().callEvent(e);\n\n    }\n\n\n}\n", "answers": ["    private ArenaHandler arenaHandler;"], "length": 3929, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "557d3ab70793b587bdf62fa00270e094d9787de7fba71c44"}
{"input": "package nami.beitrag.gui;\nimport java.awt.Component;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ItemEvent;\nimport java.awt.event.ItemListener;\nimport java.text.DateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.TreeSet;\nimport javax.swing.ButtonGroup;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JRadioButton;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextField;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.border.EmptyBorder;\nimport javax.swing.border.TitledBorder;\nimport javax.swing.event.TreeSelectionEvent;\nimport javax.swing.event.TreeSelectionListener;\nimport javax.swing.tree.TreePath;\nimport nami.beitrag.db.BeitragLastschrift;\nimport nami.beitrag.db.BeitragMitglied;\nimport nami.beitrag.db.BeitragRechnung;\nimport nami.beitrag.db.BeitragSammelLastschrift;\nimport nami.beitrag.db.BeitragSepaMandat;\nimport nami.beitrag.db.LastschriftenMapper;\nimport nami.beitrag.db.LastschriftenMapper.DataMandateRechnungen;\nimport nami.beitrag.db.LastschriftenMapper.DataRechnungMitglied;\nimport nami.beitrag.db.LastschriftenMapper.FilterSettings;\nimport nami.beitrag.gui.utils.Colors;\nimport nami.beitrag.gui.utils.DisabledCellRenderer;\nimport nami.beitrag.gui.utils.MyStringUtils;\nimport net.miginfocom.swing.MigLayout;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.jdesktop.swingx.JXTreeTable;\nimport org.jdesktop.swingx.decorator.ColorHighlighter;\nimport org.jdesktop.swingx.decorator.ComponentAdapter;\nimport org.jdesktop.swingx.decorator.HighlightPredicate;\nimport org.jdesktop.swingx.decorator.Highlighter;\nimport org.jdesktop.swingx.treetable.AbstractTreeTableModel;\nimport com.toedter.calendar.JDateChooser;\n\n\n\n\n\n\n/**\n * Stellt ein Fenster dar, in dem Sammellastschriften zusammengestellt werden\n * können. Dazu werden nach bestimmten Kriterien offene Rechnungen aus der\n * Datenbank geholt und angezeigt. Der Benutzer kann manuell Rechnungen\n * deaktivieren und lässt anschließend die Sammellastschrift erstellen.\n * \n * @author Fabian Lipp\n * \n */\npublic class LastschriftErstellenWindow extends JFrame {\n    private static final long serialVersionUID = 7409328875312329467L;\n\n    private final SqlSessionFactory sqlSessionFactory;\n\n    // Komponenten für Suche\n    private JCheckBox chckbxRechnungsdatum;\n    private JDateChooser inputRechnungsdatum;\n    private JCheckBox chckbxBereitsErstellt;\n\n    // Komponenten für Tabelle\n    private JXTreeTable treeTable;\n    // Model der Tabelle\n    private LastschriftTreeTableModel treeTableModel;\n    // Mandat, dessen Zeile momentan in der Tabelle ausgewählt ist (null, falls\n    // keine Zeile oder kein Mandat ausgewählt ist)\n    private MandatNode selectedMandat;\n\n    // Komponenten für \"Lastschrift erstellen\"\n    private JDateChooser inputFaelligkeit;\n    private JTextField inputBezeichnung;\n    private JRadioButton rdbtnMitgliedernamen;\n    private JRadioButton rdbtnRechnungsnummer;\n\n    /**\n     * Erzeugt ein neues Rechnungs-Fenster.\n     * \n     * @param sqlSessionFactory\n     *            Zugriff auf die Datenbank\n     */\n    public LastschriftErstellenWindow(SqlSessionFactory sqlSessionFactory) {\n        super(\"Sammellastschrift erstellen\");\n        this.sqlSessionFactory = sqlSessionFactory;\n        buildFrame();\n    }\n\n    private void buildFrame() {\n        JPanel contentPane = new JPanel();\n        contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));\n        setContentPane(contentPane);\n        contentPane.setLayout(new MigLayout(\"\", \"[grow]\", \"[][grow][][]\"));\n\n        /*** Rechnungs-Suche ***/\n        contentPane.add(createSearchPanel(), \"cell 0 0,grow\");\n\n        /*** Tabelle vorbereiten ***/\n        JScrollPane scrollPane = new JScrollPane();\n        contentPane.add(scrollPane, \"cell 0 1,grow\");\n        treeTable = new JXTreeTable(new LastschriftTreeTableModel());\n        // Model initialisieren\n        treeTableModel = new LastschriftTreeTableModel();\n        treeTable.setTreeTableModel(treeTableModel);\n        // Verhindert, dass die Spalten neu initialisiert werden, wenn sich das\n        // Model verändert (dabei gehen der TableCellRenderer und die\n        // Spaltenbreiten verloren)\n        treeTable.setAutoCreateColumnsFromModel(false);\n        // Setzt den Renderer, der dafür sorgt, dass Checkboxen, die nicht\n        // bearbeitet werden können, disabled werden\n        treeTable.getColumn(LastschriftTreeTableModel.CHECK_COLUMN_INDEX)\n                .setCellRenderer(new DisabledCellRenderer());\n        // Reagiert auf die Auswahl einer Zeile durch den Benutzer\n        treeTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        treeTable.addTreeSelectionListener(new SelectMandatListener());\n        scrollPane.setViewportView(treeTable);\n\n        Highlighter high;\n        // Färbt den Hintergrund aller Rechnungen ein\n        high = new ColorHighlighter(new RechnungHighlightPredicate(),\n                Colors.TT_CHILD_BG, null);\n        treeTable.addHighlighter(high);\n        // Färbt den Hintergrund der Rechnungen, die zum aktuell ausgewählten\n        // Mandat gehören, ein\n        high = new ColorHighlighter(new RechnungSelectedPredicate(),\n                Colors.TT_SEL_BG, null);\n        treeTable.addHighlighter(high);\n        // Färbt den Text der abgewählten Mandate und Rechnungen ein\n        high = new ColorHighlighter(new RowDeactivatedPredicate(), null,\n                Colors.TT_DEACTIV_FG, null, Colors.TT_DEACTIV_FG);\n        treeTable.addHighlighter(high);\n\n        /*** Buttons unter der Tabelle ***/\n        JPanel btnsBelow = new JPanel();\n        btnsBelow.setBorder(new TitledBorder(null, \"Alle Mandate\",\n                TitledBorder.LEADING, TitledBorder.TOP, null, null));\n        contentPane.add(btnsBelow, \"cell 0 2,growx\");\n        btnsBelow.setLayout(new MigLayout(\"\", \"[][grow]\", \"[]\"));\n\n        JButton btnAlleAusklappen = new JButton(\"Ausklappen\");\n        btnsBelow.add(btnAlleAusklappen, \"cell 0 0,alignx left\");\n        btnAlleAusklappen.addActionListener(new AlleAusklappenListener());\n\n        JButton btnAlleEinklappen = new JButton(\"Einklappen\");\n        btnsBelow.add(btnAlleEinklappen, \"cell 0 0,alignx left\");\n        btnAlleEinklappen.addActionListener(new AlleEinklappenListener());\n\n        JButton btnAuswaehlen = new JButton(\"Auswählen\");\n        btnsBelow.add(btnAuswaehlen, \"cell 1 0,span,alignx right\");\n        btnAuswaehlen.addActionListener(new MandateSelectListener(true));\n\n        JButton btnAbwaehlen = new JButton(\"Abwählen\");\n        btnsBelow.add(btnAbwaehlen, \"cell 1 0,span,alignx right\");\n        btnAbwaehlen.addActionListener(new MandateSelectListener(false));\n\n        /*** Lastschrift-Erstellungs-Einstellungen und -Button ***/\n        contentPane.add(createErstellenPanel(), \"cell 0 3,growx\");\n\n        pack();\n    }\n\n    private JPanel createSearchPanel() {\n        JPanel searchPanel = new JPanel();\n        searchPanel.setBorder(new TitledBorder(null, \"Rechnungen suchen\",\n                TitledBorder.LEADING, TitledBorder.TOP, null, null));\n        searchPanel.setLayout(new MigLayout(\"\", \"[][grow]\", \"[][grow][]\"));\n\n        JLabel lblEsWerdenNur = new JLabel(\n                \"<html>Es werden nur Rechnungen von Mitgliedern angezeigt, für die ein \"\n                        + \"gültiges, aktives SEPA-Mandat vorhanden ist.\");\n        searchPanel.add(lblEsWerdenNur, \"cell 0 0 2 1,wmax 100%\");\n\n        /*** Rechnungsdatum ***/\n        chckbxRechnungsdatum = new JCheckBox(\"Rechnungsdatum:\");\n        chckbxRechnungsdatum\n                .addItemListener(new RechnungsdatumCheckboxListener());\n        searchPanel.add(chckbxRechnungsdatum, \"flowx,cell 0 1\");\n\n        inputRechnungsdatum = new JDateChooser();\n        inputRechnungsdatum.setEnabled(false);\n        searchPanel.add(inputRechnungsdatum, \"cell 1 1,growy,w 100::\");\n\n        /*** Untere Zeile ***/\n        JPanel sucheBottomPanel = new JPanel();\n        searchPanel.add(sucheBottomPanel, \"cell 0 2 2 1,growx\");\n        sucheBottomPanel.setLayout(new MigLayout(\"insets 0\", \"[][grow]\", \"[]\"));\n\n        chckbxBereitsErstellt = new JCheckBox(\n                \"Rechnungen, für die bereits eine Lastschrift erstellt wurde\");\n        sucheBottomPanel.add(chckbxBereitsErstellt,\n                \"cell 0 0,alignx left,growy\");\n\n        JButton btnSuchen = new JButton(\"Suchen\");\n        btnSuchen.addActionListener(new MandateSucheListener());\n        sucheBottomPanel.add(btnSuchen, \"cell 1 0,alignx right,aligny top\");\n\n        return searchPanel;\n    }\n\n    /**\n     * Aktiviert das Eingabefeld für das Rechnungsdatum nur, wenn auch die\n     * Checkbox aktiviert ist.\n     */\n    private class RechnungsdatumCheckboxListener implements ItemListener {\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n            inputRechnungsdatum.setEnabled(chckbxRechnungsdatum.isSelected());\n        }\n    }\n\n    private JPanel createErstellenPanel() {\n        JPanel erstellenPanel = new JPanel();\n        erstellenPanel.setBorder(new TitledBorder(null,\n                \"Sammellastschrift erstellen\", TitledBorder.LEADING,\n                TitledBorder.TOP, null, null));\n        erstellenPanel.setLayout(new MigLayout(\"\", \"[][grow]\", \"[][][][]\"));\n\n        // Fälligkeit\n        JLabel lblFaelligkeit = new JLabel(\"Fälligkeit:\");\n        erstellenPanel.add(lblFaelligkeit, \"cell 0 0\");\n\n        inputFaelligkeit = new JDateChooser();\n        inputFaelligkeit.setDate(new Date());\n        erstellenPanel.add(inputFaelligkeit, \"cell 1 0,alignx left,w 100::\");\n\n        // Bezeichnung\n        JLabel lblBezeichnung = new JLabel(\"Bezeichnung:\");\n        erstellenPanel.add(lblBezeichnung, \"cell 0 1,alignx left\");\n\n        inputBezeichnung = new JTextField();\n        erstellenPanel.add(inputBezeichnung, \"cell 1 1,growx\");\n        inputBezeichnung.setColumns(10);\n\n        // Verwendungszweck\n        JLabel lblVerwendungszweck = new JLabel(\"Verwendungszweck:\");\n        erstellenPanel.add(lblVerwendungszweck, \"cell 0 2\");\n\n        rdbtnMitgliedernamen = new JRadioButton(\"Mitgliedernamen\");\n        rdbtnMitgliedernamen.setSelected(true);\n        erstellenPanel.add(rdbtnMitgliedernamen, \"flowx,cell 1 2\");\n\n        rdbtnRechnungsnummer = new JRadioButton(\"Rechnungsnummer\");\n        erstellenPanel.add(rdbtnRechnungsnummer, \"cell 1 2\");\n\n        ButtonGroup verwendungszweckGrp = new ButtonGroup();\n        verwendungszweckGrp.add(rdbtnMitgliedernamen);\n        verwendungszweckGrp.add(rdbtnRechnungsnummer);\n\n        // Button\n        JButton btnLastschriftErzeugen = new JButton(\n                \"Sammellastschrift erstellen\");\n        btnLastschriftErzeugen\n                .addActionListener(new LastschriftErzeugenListener());\n        erstellenPanel.add(btnLastschriftErzeugen,\n                \"cell 0 3 2 1,alignx right,aligny top\");\n\n        return erstellenPanel;\n    }\n\n    /**\n     * Listet alle Mandate und mögliche Rechnungen in der Tabelle auf, die die\n     * eingegeben Kriterien erfüllen.\n     */\n    private class MandateSucheListener implements ActionListener {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            FilterSettings filterSettings = new FilterSettings();\n\n            if (chckbxRechnungsdatum.isSelected()) {\n                filterSettings.setRechnungsdatum(inputRechnungsdatum.getDate());\n            }\n\n            filterSettings.setBereitsErstellt(chckbxBereitsErstellt\n                    .isSelected());\n\n            treeTableModel.reloadMandate(filterSettings);\n        }\n    }\n\n    /**\n     * Zeigt die Buchungen für alle Personen in der Tabelle an.\n     */\n    private class AlleAusklappenListener implements ActionListener {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            treeTable.expandAll();\n        }\n    }\n\n    /**\n     * Blendet die Buchungen für alle Personen in der Tabelle aus.\n     */\n    private class AlleEinklappenListener implements ActionListener {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            treeTable.collapseAll();\n        }\n    }\n\n    /**\n     * (De-)Selektiert alle Personen in der Tabelle.\n     */\n    private final class MandateSelectListener implements ActionListener {\n        private final boolean desiredState;\n\n        private MandateSelectListener(boolean desiredState) {\n            this.desiredState = desiredState;\n        }\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            if (treeTableModel.root == null) {\n                // es stehen keine Personen in der Tabelle\n                return;\n            }\n\n            for (MandatNode mNode : treeTableModel.root.mandate) {\n                mNode.checked = desiredState;\n            }\n\n            treeTable.repaint();\n        }\n    }\n\n    /**\n     * Erzeugt eine Sammellastschrift für die ausgewählten Personen und\n     * Buchungen.\n     */\n    private class LastschriftErzeugenListener implements ActionListener {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n\n            if (treeTableModel.root == null) {\n                // es stehen keine Mandate in der Tabelle\n                return;\n            }\n\n            // Gibt an, ob schon eine (Einzel-)Lastschrift in die Datenbank\n            // eingefügt wurde (andernfalls wird am Ende der Funktion die\n            // Transaktion rückgängig gemacht, also auch keine\n            // Sammellastschrift in der Datenbank gespeichert)\n            boolean lastschriftEingefuegt = false;\n\n            try (SqlSession session = sqlSessionFactory.openSession()) {\n                LastschriftenMapper mapper = session\n                        .getMapper(LastschriftenMapper.class);\n\n                // Sammellastschrift einfügen", "context": "src/nami/beitrag/db/BeitragMitglied.java\n@Data\n@NoArgsConstructor\npublic class BeitragMitglied {\n    private int mitgliedId;\n    private int mitgliedsnummer;\n    private String nachname;\n    private String vorname;\n    private MitgliedStatus status;\n    private Mitgliedstyp mitgliedstyp;\n    private Beitragsart beitragsart;\n    private Date eintrittsdatum;\n    private String strasse;\n    private String plz;\n    private String ort;\n    private String email;\n    private String emailVertretungsber;\n    private int version;\n    private Integer aktivesMandat;\n    private boolean deleted;\n\n    /**\n     * Aktualisiert die Felder mit einem übergebenen Mitglieds-Datensatz aus\n     * NaMi. Die Mitglieds-ID wird dabei nicht aktualisiert.\n     * \n     * @param namiMgl\n     *            der Mitglieds-Datensatz aus NaMi.\n     */\n    public void updateFromNami(NamiMitglied namiMgl) {\n        if (mitgliedId != namiMgl.getId()) {\n            throw new IllegalArgumentException(\"MitgliedIds are not equal\");\n        }\n        mitgliedsnummer = namiMgl.getMitgliedsnummer();\n        nachname = namiMgl.getNachname();\n        vorname = namiMgl.getVorname();\n        status = namiMgl.getStatus();\n        mitgliedstyp = namiMgl.getMitgliedstyp();\n        beitragsart = namiMgl.getBeitragsart();\n        eintrittsdatum = namiMgl.getEintrittsdatum();\n        strasse = namiMgl.getStrasse();\n        plz = namiMgl.getPlz();\n        ort = namiMgl.getOrt();\n        email = namiMgl.getEmail();\n        emailVertretungsber = Objects.requireNonNullElse(namiMgl.getEmailVertretungsberechtigter(), \"\");\n        version = namiMgl.getVersion();\n    }\n\n    /**\n     * Erzeugt ein neues Mitglied aus einem übergebenen Mitglieds-Datensatz aus\n     * NaMi. Die Felder, die in NaMi nicht vorhanden sind, werden mit ihren\n     * Standardwerten initialisiert.\n     * \n     * @param namiMgl\n     *            der Mitglieds-Datensatz aus NaMi\n     */\n    public BeitragMitglied(NamiMitglied namiMgl) {\n        mitgliedId = namiMgl.getId();\n        updateFromNami(namiMgl);\n        deleted = false;\n    }\n}\nsrc/nami/beitrag/gui/utils/Colors.java\npublic final class Colors {\n\n    // Farben für die Hervorhebung von Zeilen in einer TreeTable\n    private static final UIDefaults UIDEFAULTS = javax.swing.UIManager\n            .getDefaults();\n    /**\n     * Farbe, die für den Hintergrund der Kindeinträge in einer TreeTable der\n     * Tiefe 2 verwendet wird.\n     */\n    public static final Color TT_CHILD_BG = UIDEFAULTS\n            .getColor(\"Label.background\");\n\n    /**\n     * Farbe die zum Kennzeichnen von selektierten Einträgen in einer Tabelle\n     * verwendet wird.\n     */\n    public static final Color TT_SEL_BG = UIDEFAULTS\n            .getColor(\"List.selectionBackground\");\n\n    /**\n     * Schriftfarbe zum Kennzeichnen von deaktivierten Einträgen in Tabellen.\n     */\n    public static final Color TT_DEACTIV_FG = UIDEFAULTS\n            .getColor(\"Label.disabledForeground\");\n\n    private Colors() {\n    }\n}\nsrc/nami/beitrag/db/BeitragSepaMandat.java\n@Data\npublic class BeitragSepaMandat {\n    private int mandatId;\n    private String iban;\n    private String bic;\n    private Date datum;\n    private String kontoinhaber;\n    private String strasse;\n    private String plz;\n    private String ort;\n    private String email;\n    private boolean gueltig;\n}\nsrc/nami/beitrag/gui/utils/MyStringUtils.java\npublic final class MyStringUtils {\n\n    private static final String[] REPLACE_UML_FROM = { \"ä\", \"ö\", \"ü\", \"Ä\", \"Ö\",\n            \"Ü\", \"ß\", \"ë\" };\n    private static final String[] REPLACE_UML_TO = { \"ae\", \"oe\", \"ue\", \"Ae\",\n            \"Oe\", \"Ue\", \"ss\", \"e\" };\n\n    private MyStringUtils() {\n    }\n\n    /**\n     * Ersetzt alle Umlaute im übergebenen String durch ihre Umschreibung.\n     * \n     * @param text\n     *            der zu bearbeitende String\n     * @return String mit ersetzen Umlauten\n     */\n    public static String replaceUmlauts(String text) {\n        return StringUtils.replaceEach(text, REPLACE_UML_FROM, REPLACE_UML_TO);\n    }\n\n    public static int parseIntDefaultMinusOne(String value) {\n        try {\n            return Integer.parseInt(value);\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    }\n}\nsrc/nami/beitrag/db/BeitragRechnung.java\n@Data\npublic class BeitragRechnung {\n    private int rechnungId;\n    private int mitgliedId;\n    private int rechnungsNummer;\n    private Date datum;\n    private Date frist;\n    private Rechnungsstatus status;\n\n    /**\n     * Rechnungsbetrag (d. h. Summe der enthaltenen Posten).\n     * \n     * Dieses Feld steht nicht in der Datenbank, sondern wird in der SQL-Abfrage\n     * aus den verknüpften Posten berechnet.\n     */\n    @Setter(AccessLevel.NONE)\n    private BigDecimal betrag;\n\n    /**\n     * Liefert die vollständige Rechnungsnummer.\n     * \n     * @return Rechnungsnummer inklusive Jahreszahl\n     */\n    public String getCompleteRechnungsNummer() {\n        String jahreszahl = new SimpleDateFormat(\"y\").format(datum);\n        return jahreszahl + \"/\" + rechnungsNummer;\n    }\n}\nsrc/nami/beitrag/gui/utils/DisabledCellRenderer.java\npublic class DisabledCellRenderer extends DefaultTableCellRenderer {\n    private static final long serialVersionUID = -4317607684491411756L;\n\n    @Override\n    public Component getTableCellRendererComponent(JTable table,\n            Object value, boolean isSelected, boolean hasFocus, int row,\n            int column) {\n\n        TableCellRenderer renderer = table.getDefaultRenderer(table\n                .getColumnClass(column));\n        Component c = renderer.getTableCellRendererComponent(table, value,\n                isSelected, hasFocus, row, column);\n\n        // Deaktiviert die Komponente, falls das Feld nicht bearbeitbar ist\n        if (!table.isCellEditable(row, column)) {\n            c.setEnabled(false);\n        }\n\n        return c;\n    }\n}\nsrc/nami/beitrag/db/BeitragSammelLastschrift.java\n@Data\npublic class BeitragSammelLastschrift {\n    private int sammelLastschriftId;\n    private Date faelligkeit;\n    private boolean ausgefuehrt;\n    private String bezeichnung;\n\n    // Die folgenden Felder sind nicht direkt in der Datenbank gespeichert\n    @Setter(AccessLevel.NONE)\n    private int anzahlLastschriften;\n    @Setter(AccessLevel.NONE)\n    private BigDecimal betrag;\n    @Setter(AccessLevel.NONE)\n    private boolean alleGueltig;\n}\nsrc/nami/beitrag/db/BeitragLastschrift.java\n@Data\npublic class BeitragLastschrift {\n    private int lastschriftId;\n    private int sammelLastschriftId;\n    private int mandatId;\n    private String verwendungszweck;\n\n    // Die folgenden Felder sind nicht direkt in der Datenbank gespeichert,\n    // sondern werden bei der Abfrage berechnet.\n    @Setter(AccessLevel.NONE)\n    private BigDecimal betrag;\n}\nsrc/nami/beitrag/db/LastschriftenMapper.java\n@Data\npublic static class FilterSettings {\n    /**\n     * Dieser Parameter filtert die Rechnungen nach dem Erstellungsdatum.\n     * Wenn dieser Parameter <tt>null</tt> ist, wird nicht nach dem\n     * Rechnungsdatum gefiltert.\n     */\n    private Date rechnungsdatum = null;\n\n    /**\n     * Gibt an, ob auch Rechnungen selektiert werden, für die bereits eine\n     * Lastschrift erstellt wurde.\n     */\n    private boolean bereitsErstellt;\n}\nsrc/nami/beitrag/db/LastschriftenMapper.java\n@Getter\npublic static class DataMandateRechnungen {\n    private BeitragSepaMandat mandat;\n    private List<DataRechnungMitglied> rechnungen;\n}\nsrc/nami/beitrag/db/LastschriftenMapper.java\npublic interface LastschriftenMapper {\n\n    /**\n     * Beschreibt Filterkriterien für die Suche nach Mandaten und Buchungen.\n     */\n    @Data\n    public static class FilterSettings {\n        /**\n         * Dieser Parameter filtert die Rechnungen nach dem Erstellungsdatum.\n         * Wenn dieser Parameter <tt>null</tt> ist, wird nicht nach dem\n         * Rechnungsdatum gefiltert.\n         */\n        private Date rechnungsdatum = null;\n\n        /**\n         * Gibt an, ob auch Rechnungen selektiert werden, für die bereits eine\n         * Lastschrift erstellt wurde.\n         */\n        private boolean bereitsErstellt;\n    }\n\n    /**\n     * Ergebnis-Datentyp bei der Suche nach Mandaten und Rechnungen, die vom\n     * jeweiligen Mandat eingezogen werden können.\n     */\n    @Getter\n    public static class DataMandateRechnungen {\n        private BeitragSepaMandat mandat;\n        private List<DataRechnungMitglied> rechnungen;\n    }\n\n    /**\n     * Fasst ein Mitglied und eine Rechnung zusammen.\n     */\n    @Getter\n    public static class DataRechnungMitglied {\n        private BeitragMitglied mitglied;\n        private BeitragRechnung rechnung;\n    }\n\n    /**\n     * Liefert alle offenen Rechnungen und die zugehörigen aktiven, gültigen\n     * Mandate, die die übergebenen Filterkriterien erfüllen.\n     * \n     * @param filterSettings\n     *            Kriterien nach denen gefiltert wird\n     * @return Mandate und jeweils offene Rechnungen\n     */\n    Collection<DataMandateRechnungen> mandateOffeneRechnungen(\n            @Param(\"filterSettings\") FilterSettings filterSettings);\n\n    /**\n     * Fügt eine Lastschrift in die Datenbank ein. Die <tt>lastschriftId</tt>\n     * der neu eingefügten Lastschrift ist anschließend im Objekt gespeichert,\n     * das als Parameter übergeben wurde.\n     * \n     * @param lastschrift\n     *            Daten der einzufügenden Lastschrift\n     */\n    void insertLastschrift(BeitragLastschrift lastschrift);\n\n    /**\n     * Löscht eine Lastschrift aus der Datenbank. Die enthaltenen Rechnungen\n     * sollten vorher schon gelöscht worden seien (siehe\n     * {@link #deleteAllRechnungenFromLastschrift(int)}).\n     * \n     * @param lastschriftId\n     *            ID der Lastschrift, die gelöscht werden soll\n     */\n    void deleteLastschrift(int lastschriftId);\n\n    /**\n     * Fügt eine Rechnung zu einer Lastschrift hinzu, d. h. diese Rechnung wird\n     * mit der jeweiligen Lastschrift eingezogen.\n     * \n     * @param lastschriftId\n     *            ID der Lastschrift\n     * @param rechnungId\n     *            ID der Rechnung\n     */\n    void addRechnungToLastschrift(@Param(\"lastschriftId\") int lastschriftId,\n            @Param(\"rechnungId\") int rechnungId);\n\n    /**\n     * Löscht alle Rechnungen aus einer Lastschrift. Die Rechnungen werden dabei\n     * in der Datenbank belassen, nur ihre Verbindungen zur Lastschrift werden\n     * entfernt.\n     * \n     * @param lastschriftId\n     *            ID der Lastschrift\n     */\n    void deleteAllRechnungenFromLastschrift(int lastschriftId);\n\n    /**\n     * Fügt eine Sammellastschrift in die Datenbank ein. Die\n     * <tt>sammelLastschriftId</tt> der neu eingefügten Lastschrift ist\n     * anschließend im Objekt gespeichert, das als Parameter übergeben wurde.\n     * \n     * @param sammelLastschrift\n     *            Daten der einzufügenden Sammellastschrift\n     */\n    void insertSammelLastschrift(BeitragSammelLastschrift sammelLastschrift);\n\n    /**\n     * Aktualisiert den Datensatz einer Sammellastschrift.\n     * \n     * @param sammelLastschrift\n     *            Objekt, dessen geänderte Felder in die Datenbank gespeichert\n     *            werden sollen\n     */\n    void updateSammelLastschrift(BeitragSammelLastschrift sammelLastschrift);\n\n    /**\n     * Löscht eine Sammellastschrift aus der Datenbank. Die enthaltenen\n     * Lastschriften sollten vorher schon gelöscht worden seien.\n     * \n     * @param sammelLastschriftId\n     *            ID der Sammellastschrift\n     */\n    void deleteSammelLastschrift(int sammelLastschriftId);\n\n    /**\n     * Fragt alle Sammellastschriften (inkl. der Anzahl der enthaltenen\n     * Einzellastschriften und des Gesamtbetrages) aus der Datenbank ab, die dem\n     * übergebenen Filterkriterium entsprechen.\n     * \n     * @param ausgefuehrt\n     *            Gibt an, ob ausgeführte Sammellastschriften angezeigt werden\n     *            sollen.\n     *            <ul>\n     *            <li><tt>True</tt>: nur ausgeführte werden angezeigt</li>\n     *            <li><tt>False</tt>: nur <em>nicht</em> ausgeführte werden\n     *            angezeigt</li>\n     *            <li><tt>null</tt>: Filterkriterium wird ignoriert</li>\n     *            </ul>\n     * @return Sammellastschriften, die dem angegebenen Filterkriterium\n     *         entsprechen\n     */\n    ArrayList<BeitragSammelLastschrift> findSammelLastschriften(\n            @Param(\"ausgefuehrt\") Boolean ausgefuehrt);\n\n    /**\n     * Liefert alle Lastschriften (inkl. der zugehörigen Mandate), die in einer\n     * Sammellastschrift enthalten sind.\n     * \n     * @param sammelLastschriftId\n     *            ID der Sammellastschrift\n     * @return enthaltenen (Einzel-)Lastschriften\n     */\n    ArrayList<DataLastschriftMandat> getLastschriften(int sammelLastschriftId);\n\n    /**\n     * Liefert alle Rechnungen, die in einer Sammellastschrift enthalten sind.\n     * Das heißt es werden die zugeordneten Rechnungen aller enthaltenen\n     * Einzellastschriften vereinigt.\n     * \n     * @param sammelLastschriftId\n     *            ID der Sammellastschrift\n     * @return zugeordnete Rechnungen\n     */\n    List<BeitragRechnung> getRechnungenInSammelLastschrift(\n            int sammelLastschriftId);\n\n    /**\n     * Fügt eine Prenotification in die Datenbank ein. Die\n     * <tt>prenotificationId</tt> der neu eingefügten Prenotification ist\n     * anschließend im Objekt gespeichert, das als Parameter übergeben wurde.\n     * \n     * @param pre\n     *            Daten der einzufügenden Prenotification\n     */\n    void insertPrenotification(BeitragPrenotification pre);\n\n    /**\n     * Überprüft, ob die aktuellste (nach Ausstellungsdatum), als regelmäßig\n     * gekennzeichnete Prenotification im Betrag mit den Parametern\n     * übereinstimmt. In diesem Fall muss also keine neue erstellt werden.\n     * \n     * @param mandatId\n     *            ID des Mandats\n     * @param betrag\n     *            benötigter Lastschriftbetrag\n     * @return <tt>true</tt>, falls die aktuellste Prenotification den passenden\n     *         Betrag enthält\n     */\n    boolean existsValidPrenotification(@Param(\"mandatId\") int mandatId,\n            @Param(\"betrag\") BigDecimal betrag);\n\n    /**\n     * Fasst eine Prenotification und das dazugehörige Mandat zusammen.\n     */\n    @Getter\n    public class DataPrenotificationMandat {\n        private BeitragPrenotification prenotification;\n        private BeitragSepaMandat mandat;\n    }\n\n    /**\n     * Liefert eine Prenotification und das dazugehörige Mandat.\n     * \n     * @param prenotificationId\n     *            ID der Prenotification\n     * @return Prenotification mit Mandat\n     */\n    DataPrenotificationMandat getPrenotificationMitMandat(int prenotificationId);\n}\nsrc/nami/beitrag/db/LastschriftenMapper.java\n@Getter\npublic static class DataRechnungMitglied {\n    private BeitragMitglied mitglied;\n    private BeitragRechnung rechnung;\n}\n", "answers": ["                BeitragSammelLastschrift sammelLastschrift;"], "length": 2526, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "baa8de84ab065678542bc7eba856ad8688646323f9d230bd"}
{"input": "import kademlia.message.Receiver;\nimport java.io.IOException;\nimport kademlia.JKademliaNode;\nimport kademlia.KadConfiguration;\nimport kademlia.KadServer;\nimport kademlia.KademliaNode;\nimport kademlia.exceptions.RoutingException;\nimport kademlia.message.AcknowledgeMessage;\nimport kademlia.message.ConnectMessage;\nimport kademlia.message.Message;\nimport kademlia.node.Node;\n/**\n * @author Joshua Kissoon\n * @created 20140218\n * @desc Operation that handles connecting to an existing Kademlia network using a bootstrap node\n */\npackage kademlia.operation;\n\n\npublic class ConnectOperation implements Operation, Receiver\n{\n\n    public static final int MAX_CONNECT_ATTEMPTS = 5;       // Try 5 times to connect to a node\n\n    private final KadServer server;\n    private final KademliaNode localNode;", "context": "src/kademlia/KadConfiguration.java\npublic interface KadConfiguration\n{\n\n    /**\n     * @return Interval in milliseconds between execution of RestoreOperations.\n     */\n    public long restoreInterval();\n\n    /**\n     * If no reply received from a node in this period (in milliseconds)\n     * consider the node unresponsive.\n     *\n     * @return The time it takes to consider a node unresponsive\n     */\n    public long responseTimeout();\n\n    /**\n     * @return Maximum number of milliseconds for performing an operation.\n     */\n    public long operationTimeout();\n\n    /**\n     * @return Maximum number of concurrent messages in transit.\n     */\n    public int maxConcurrentMessagesTransiting();\n\n    /**\n     * @return K-Value used throughout Kademlia\n     */\n    public int k();\n\n    /**\n     * @return Size of replacement cache.\n     */\n    public int replacementCacheSize();\n\n    /**\n     * @return # of times a node can be marked as stale before it is actually removed.\n     */\n    public int stale();\n\n    /**\n     * Creates the folder in which this node data is to be stored.\n     *\n     * @param ownerId\n     *\n     * @return The folder path\n     */\n    public String getNodeDataFolder(String ownerId);\n\n    /**\n     * @return Whether we're in a testing or production system.\n     */\n    public boolean isTesting();\n}\nsrc/kademlia/JKademliaNode.java\npublic class JKademliaNode implements KademliaNode\n{\n\n    /* Kademlia Attributes */\n    private final String ownerId;\n\n    /* Objects to be used */\n    private final transient Node localNode;\n    private final transient KadServer server;\n    private final transient KademliaDHT dht;\n    private transient KademliaRoutingTable routingTable;\n    private final int udpPort;\n    private transient KadConfiguration config;\n\n    /* Timer used to execute refresh operations */\n    private transient Timer refreshOperationTimer;\n    private transient TimerTask refreshOperationTTask;\n\n    /* Factories */\n    private final transient MessageFactory messageFactory;\n\n    /* Statistics */\n    private final transient KadStatistician statistician;\n\n    \n    {\n        statistician = new Statistician();\n    }\n\n    /**\n     * Creates a Kademlia DistributedMap using the specified name as filename base.\n     * If the id cannot be read from disk the specified defaultId is used.\n     * The instance is bootstraped to an existing network by specifying the\n     * address of a bootstrap node in the network.\n     *\n     * @param ownerId      The Name of this node used for storage\n     * @param localNode    The Local Node for this Kad instance\n     * @param udpPort      The UDP port to use for routing messages\n     * @param dht          The DHT for this instance\n     * @param config\n     * @param routingTable\n     *\n     * @throws IOException If an error occurred while reading id or local map\n     *                     from disk <i>or</i> a network error occurred while\n     *                     attempting to bootstrap to the network\n     * */\n    public JKademliaNode(String ownerId, Node localNode, int udpPort, KademliaDHT dht, KademliaRoutingTable routingTable, KadConfiguration config) throws IOException\n    {\n        this.ownerId = ownerId;\n        this.udpPort = udpPort;\n        this.localNode = localNode;\n        this.dht = dht;\n        this.config = config;\n        this.routingTable = routingTable;\n        this.messageFactory = new MessageFactory(this, this.dht, this.config);\n        this.server = new KadServer(udpPort, this.messageFactory, this.localNode, this.config, this.statistician);\n        this.startRefreshOperation();\n    }\n\n    @Override\n    public final void startRefreshOperation()\n    {\n        this.refreshOperationTimer = new Timer(true);\n        refreshOperationTTask = new TimerTask()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    /* Runs a DHT RefreshOperation  */\n                    JKademliaNode.this.refresh();\n                }\n                catch (IOException e)\n                {\n                    System.err.println(\"KademliaNode: Refresh Operation Failed; Message: \" + e.getMessage());\n                }\n            }\n        };\n        refreshOperationTimer.schedule(refreshOperationTTask, this.config.restoreInterval(), this.config.restoreInterval());\n    }\n\n    @Override\n    public final void stopRefreshOperation()\n    {\n        /* Close off the timer tasks */\n        this.refreshOperationTTask.cancel();\n        this.refreshOperationTimer.cancel();\n        this.refreshOperationTimer.purge();\n    }\n\n    public JKademliaNode(String ownerId, Node node, int udpPort, KademliaRoutingTable routingTable, KadConfiguration config) throws IOException\n    {\n        this(\n                ownerId,\n                node,\n                udpPort,\n                new DHT(ownerId, config),\n                routingTable,\n                config\n        );\n    }\n\n    public JKademliaNode(String ownerId, Node node, int udpPort, KadConfiguration config) throws IOException\n    {\n        this(\n                ownerId,\n                node,\n                udpPort,\n                new JKademliaRoutingTable(node, config),\n                config\n        );\n    }\n\n    public JKademliaNode(String ownerId, KademliaId defaultId, int udpPort) throws IOException\n    {\n        this(\n                ownerId,\n                new Node(defaultId, InetAddress.getLocalHost(), udpPort),\n                udpPort,\n                new DefaultConfiguration()\n        );\n    }\n\n    /**\n     * Load Stored state using default configuration\n     *\n     * @param ownerId The ID of the owner for the stored state\n     *\n     * @return A Kademlia instance loaded from a stored state in a file\n     *\n     * @throws java.io.FileNotFoundException\n     * @throws java.lang.ClassNotFoundException\n     */\n    public static JKademliaNode loadFromFile(String ownerId) throws FileNotFoundException, IOException, ClassNotFoundException\n    {\n        return JKademliaNode.loadFromFile(ownerId, new DefaultConfiguration());\n    }\n\n    /**\n     * Load Stored state\n     *\n     * @param ownerId The ID of the owner for the stored state\n     * @param iconfig Configuration information to work with\n     *\n     * @return A Kademlia instance loaded from a stored state in a file\n     *\n     * @throws java.io.FileNotFoundException\n     * @throws java.lang.ClassNotFoundException\n     */\n    public static JKademliaNode loadFromFile(String ownerId, KadConfiguration iconfig) throws FileNotFoundException, IOException, ClassNotFoundException\n    {\n        DataInputStream din;\n\n        /**\n         * @section Read Basic Kad data\n         */\n        din = new DataInputStream(new FileInputStream(getStateStorageFolderName(ownerId, iconfig) + File.separator + \"kad.kns\"));\n        JKademliaNode ikad = new JsonSerializer<JKademliaNode>().read(din);\n\n        /**\n         * @section Read the routing table\n         */\n        din = new DataInputStream(new FileInputStream(getStateStorageFolderName(ownerId, iconfig) + File.separator + \"routingtable.kns\"));\n        KademliaRoutingTable irtbl = new JsonRoutingTableSerializer(iconfig).read(din);\n\n        /**\n         * @section Read the node state\n         */\n        din = new DataInputStream(new FileInputStream(getStateStorageFolderName(ownerId, iconfig) + File.separator + \"node.kns\"));\n        Node inode = new JsonSerializer<Node>().read(din);\n\n        /**\n         * @section Read the DHT\n         */\n        din = new DataInputStream(new FileInputStream(getStateStorageFolderName(ownerId, iconfig) + File.separator + \"dht.kns\"));\n        KademliaDHT idht = new JsonDHTSerializer().read(din);\n        idht.setConfiguration(iconfig);\n\n        return new JKademliaNode(ownerId, inode, ikad.getPort(), idht, irtbl, iconfig);\n    }\n\n    @Override\n    public Node getNode()\n    {\n        return this.localNode;\n    }\n\n    @Override\n    public KadServer getServer()\n    {\n        return this.server;\n    }\n\n    @Override\n    public KademliaDHT getDHT()\n    {\n        return this.dht;\n    }\n\n    @Override\n    public KadConfiguration getCurrentConfiguration()\n    {\n        return this.config;\n    }\n\n    @Override\n    public synchronized final void bootstrap(Node n) throws IOException, RoutingException\n    {\n        long startTime = System.nanoTime();\n        Operation op = new ConnectOperation(this.server, this, n, this.config);\n        op.execute();\n        long endTime = System.nanoTime();\n        this.statistician.setBootstrapTime(endTime - startTime);\n    }\n\n    @Override\n    public int put(KadContent content) throws IOException\n    {\n        return this.put(new JKademliaStorageEntry(content));\n    }\n\n    @Override\n    public int put(JKademliaStorageEntry entry) throws IOException\n    {\n        StoreOperation sop = new StoreOperation(this.server, this, entry, this.dht, this.config);\n        sop.execute();\n\n        /* Return how many nodes the content was stored on */\n        return sop.numNodesStoredAt();\n    }\n\n    @Override\n    public void putLocally(KadContent content) throws IOException\n    {\n        this.dht.store(new JKademliaStorageEntry(content));\n    }\n\n    @Override\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException, ContentNotFoundException\n    {\n        if (this.dht.contains(param))\n        {\n            /* If the content exist in our own DHT, then return it. */\n            return this.dht.get(param);\n        }\n\n        /* Seems like it doesn't exist in our DHT, get it from other Nodes */\n        long startTime = System.nanoTime();\n        ContentLookupOperation clo = new ContentLookupOperation(server, this, param, this.config);\n        clo.execute();\n        long endTime = System.nanoTime();\n        this.statistician.addContentLookup(endTime - startTime, clo.routeLength(), clo.isContentFound());\n        return clo.getContentFound();\n    }\n\n    @Override\n    public void refresh() throws IOException\n    {\n        new KadRefreshOperation(this.server, this, this.dht, this.config).execute();\n    }\n\n    @Override\n    public String getOwnerId()\n    {\n        return this.ownerId;\n    }\n\n    @Override\n    public int getPort()\n    {\n        return this.udpPort;\n    }\n\n    @Override\n    public void shutdown(final boolean saveState) throws IOException\n    {\n        /* Shut down the server */\n        this.server.shutdown();\n\n        this.stopRefreshOperation();\n\n        /* Save this Kademlia instance's state if required */\n        if (saveState)\n        {\n            /* Save the system state */\n            this.saveKadState();\n        }\n    }\n\n    @Override\n    public void saveKadState() throws IOException\n    {\n        DataOutputStream dout;\n\n        /**\n         * @section Store Basic Kad data\n         */\n        dout = new DataOutputStream(new FileOutputStream(getStateStorageFolderName(this.ownerId, this.config) + File.separator + \"kad.kns\"));\n        new JsonSerializer<JKademliaNode>().write(this, dout);\n\n        /**\n         * @section Save the node state\n         */\n        dout = new DataOutputStream(new FileOutputStream(getStateStorageFolderName(this.ownerId, this.config) + File.separator + \"node.kns\"));\n        new JsonSerializer<Node>().write(this.localNode, dout);\n\n        /**\n         * @section Save the routing table\n         * We need to save the routing table separate from the node since the routing table will contain the node and the node will contain the routing table\n         * This will cause a serialization recursion, and in turn a Stack Overflow\n         */\n        dout = new DataOutputStream(new FileOutputStream(getStateStorageFolderName(this.ownerId, this.config) + File.separator + \"routingtable.kns\"));\n        new JsonRoutingTableSerializer(this.config).write(this.getRoutingTable(), dout);\n\n        /**\n         * @section Save the DHT\n         */\n        dout = new DataOutputStream(new FileOutputStream(getStateStorageFolderName(this.ownerId, this.config) + File.separator + \"dht.kns\"));\n        new JsonDHTSerializer().write(this.dht, dout);\n\n    }\n\n    /**\n     * Get the name of the folder for which a content should be stored\n     *\n     * @return String The name of the folder to store node states\n     */\n    private static String getStateStorageFolderName(String ownerId, KadConfiguration iconfig)\n    {\n        /* Setup the nodes storage folder if it doesn't exist */\n        String path = iconfig.getNodeDataFolder(ownerId) + File.separator + \"nodeState\";\n        File nodeStateFolder = new File(path);\n        if (!nodeStateFolder.isDirectory())\n        {\n            nodeStateFolder.mkdir();\n        }\n        return nodeStateFolder.toString();\n    }\n\n    @Override\n    public KademliaRoutingTable getRoutingTable()\n    {\n        return this.routingTable;\n    }\n\n    @Override\n    public KadStatistician getStatistician()\n    {\n        return this.statistician;\n    }\n\n    /**\n     * Creates a string containing all data about this Kademlia instance\n     *\n     * @return The string representation of this Kad instance\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"\\n\\nPrinting Kad State for instance with owner: \");\n        sb.append(this.ownerId);\n        sb.append(\"\\n\\n\");\n\n        sb.append(\"\\n\");\n        sb.append(\"Local Node\");\n        sb.append(this.localNode);\n        sb.append(\"\\n\");\n\n        sb.append(\"\\n\");\n        sb.append(\"Routing Table: \");\n        sb.append(this.getRoutingTable());\n        sb.append(\"\\n\");\n\n        sb.append(\"\\n\");\n        sb.append(\"DHT: \");\n        sb.append(this.dht);\n        sb.append(\"\\n\");\n\n        sb.append(\"\\n\\n\\n\");\n\n        return sb.toString();\n    }\n}\nsrc/kademlia/message/AcknowledgeMessage.java\npublic class AcknowledgeMessage implements Message\n{\n\n    private Node origin;\n    public static final byte CODE = 0x01;\n\n    public AcknowledgeMessage(Node origin)\n    {\n        this.origin = origin;\n    }\n\n    public AcknowledgeMessage(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        this.origin = new Node(in);\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        origin.toStream(out);\n    }\n\n    public Node getOrigin()\n    {\n        return this.origin;\n    }\n\n    @Override\n    public byte code()\n    {\n        return CODE;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"AcknowledgeMessage[origin=\" + origin.getNodeId() + \"]\";\n    }\n}\nsrc/kademlia/message/Receiver.java\npublic interface Receiver\n{\n\n    /**\n     * Message is received, now handle it\n     *\n     * @param conversationId The ID of this conversation, used for further conversations\n     * @param incoming       The incoming\n     *\n     * @throws java.io.IOException\n     */\n    public void receive(Message incoming, int conversationId) throws IOException;\n\n    /**\n     * If no reply is received in <code>MessageServer.TIMEOUT</code> seconds for the\n     * message with communication id <code>comm</code>, the MessageServer calls this method\n     *\n     * @param conversationId The conversation ID of this communication\n     *\n     * @throws IOException if an I/O error occurs\n     * */\n    public void timeout(int conversationId) throws IOException;\n}\nsrc/kademlia/KadServer.java\npublic class KadServer\n{\n\n    /* Maximum size of a Datagram Packet */\n    private static final int DATAGRAM_BUFFER_SIZE = 64 * 1024;      // 64KB\n\n    /* Basic Kad Objects */\n    private final transient KadConfiguration config;\n\n    /* Server Objects */\n    private final DatagramSocket socket;\n    private transient boolean isRunning;\n    private final Map<Integer, Receiver> receivers;\n    private final Timer timer;      // Schedule future tasks\n    private final Map<Integer, TimerTask> tasks;    // Keep track of scheduled tasks\n\n    private final Node localNode;\n\n    /* Factories */\n    private final KademliaMessageFactory messageFactory;\n\n    private final KadStatistician statistician;\n\n    \n    {\n        isRunning = true;\n        this.tasks = new HashMap<>();\n        this.receivers = new HashMap<>();\n        this.timer = new Timer(true);\n    }\n\n    /**\n     * Initialize our KadServer\n     *\n     * @param udpPort      The port to listen on\n     * @param mFactory     Factory used to create messages\n     * @param localNode    Local node on which this server runs on\n     * @param config\n     * @param statistician A statistician to manage the server statistics\n     *\n     * @throws java.net.SocketException\n     */\n    public KadServer(int udpPort, KademliaMessageFactory mFactory, Node localNode, KadConfiguration config, KadStatistician statistician) throws SocketException\n    {\n        this.config = config;\n        this.socket = new DatagramSocket(udpPort);\n        this.localNode = localNode;\n        this.messageFactory = mFactory;\n        this.statistician = statistician;\n\n        /* Start listening for incoming requests in a new thread */\n        this.startListener();\n    }\n\n    /**\n     * Starts the listener to listen for incoming messages\n     */\n    private void startListener()\n    {\n        new Thread()\n        {\n            @Override\n            public void run()\n            {\n                listen();\n            }\n        }.start();\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param msg  The message to send\n     * @param to   The node to send the message to\n     * @param recv The receiver to handle the response message\n     *\n     * @return Integer The communication ID of this message\n     *\n     * @throws IOException\n     * @throws kademlia.exceptions.KadServerDownException\n     */\n    public synchronized int sendMessage(Node to, Message msg, Receiver recv) throws IOException, KadServerDownException\n    {\n        if (!isRunning)\n        {\n            throw new KadServerDownException(this.localNode + \" - Kad Server is not running.\");\n        }\n\n        /* Generate a random communication ID */\n        int comm = new Random().nextInt();\n\n        /* If we have a receiver */\n        if (recv != null)\n        {\n            try\n            {\n                /* Setup the receiver to handle message response */\n                receivers.put(comm, recv);\n                TimerTask task = new TimeoutTask(comm, recv);\n                timer.schedule(task, this.config.responseTimeout());\n                tasks.put(comm, task);\n            }\n            catch (IllegalStateException ex)\n            {\n                /* The timer is already cancelled so we cannot do anything here really */\n            }\n        }\n\n        /* Send the message */\n        sendMessage(to, msg, comm);\n\n        return comm;\n    }\n\n    /**\n     * Method called to reply to a message received\n     *\n     * @param to   The Node to send the reply to\n     * @param msg  The reply message\n     * @param comm The communication ID - the one received\n     *\n     * @throws java.io.IOException\n     */\n    public synchronized void reply(Node to, Message msg, int comm) throws IOException\n    {\n        if (!isRunning)\n        {\n            throw new IllegalStateException(\"Kad Server is not running.\");\n        }\n        sendMessage(to, msg, comm);\n    }\n\n    /**\n     * Internal sendMessage method called by the public sendMessage method after a communicationId is generated\n     */\n    private void sendMessage(Node to, Message msg, int comm) throws IOException\n    {\n        /* Use a try-with resource to auto-close streams after usage */\n        try (ByteArrayOutputStream bout = new ByteArrayOutputStream(); DataOutputStream dout = new DataOutputStream(bout);)\n        {\n            /* Setup the message for transmission */\n            dout.writeInt(comm);\n            dout.writeByte(msg.code());\n            msg.toStream(dout);\n            dout.close();\n\n            byte[] data = bout.toByteArray();\n\n            if (data.length > DATAGRAM_BUFFER_SIZE)\n            {\n                throw new IOException(\"Message is too big\");\n            }\n\n            /* Everything is good, now create the packet and send it */\n            DatagramPacket pkt = new DatagramPacket(data, 0, data.length);\n            pkt.setSocketAddress(to.getSocketAddress());\n            socket.send(pkt);\n\n            /* Lets inform the statistician that we've sent some data */\n            this.statistician.sentData(data.length);\n        }\n    }\n\n    /**\n     * Listen for incoming messages in a separate thread\n     */\n    private void listen()\n    {\n        try\n        {\n            while (isRunning)\n            {\n                try\n                {\n                    /* Wait for a packet */\n                    byte[] buffer = new byte[DATAGRAM_BUFFER_SIZE];\n                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                    socket.receive(packet);\n\n                    /* Lets inform the statistician that we've received some data */\n                    this.statistician.receivedData(packet.getLength());\n\n                    if (this.config.isTesting())\n                    {\n                        /**\n                         * Simulating network latency\n                         * We pause for 1 millisecond/100 bytes\n                         */\n                        int pause = packet.getLength() / 100;\n                        try\n                        {\n                            Thread.sleep(pause);\n                        }\n                        catch (InterruptedException ex)\n                        {\n\n                        }\n                    }\n\n                    /* We've received a packet, now handle it */\n                    try (ByteArrayInputStream bin = new ByteArrayInputStream(packet.getData(), packet.getOffset(), packet.getLength());\n                            DataInputStream din = new DataInputStream(bin);)\n                    {\n\n                        /* Read in the conversation Id to know which handler to handle this response */\n                        int comm = din.readInt();\n                        byte messCode = din.readByte();\n\n                        Message msg = messageFactory.createMessage(messCode, din);\n                        din.close();\n\n                        /* Get a receiver for this message */\n                        Receiver receiver;\n                        if (this.receivers.containsKey(comm))\n                        {\n                            /* If there is a reciever in the receivers to handle this */\n                            synchronized (this)\n                            {\n                                receiver = this.receivers.remove(comm);\n                                TimerTask task = (TimerTask) tasks.remove(comm);\n                                if (task != null)\n                                {\n                                    task.cancel();\n                                }\n                            }\n                        }\n                        else\n                        {\n                            /* There is currently no receivers, try to get one */\n                            receiver = messageFactory.createReceiver(messCode, this);\n                        }\n\n                        /* Invoke the receiver */\n                        if (receiver != null)\n                        {\n                            receiver.receive(msg, comm);\n                        }\n                    }\n                }\n                catch (IOException e)\n                {\n                    //this.isRunning = false;\n                    System.err.println(\"Server ran into a problem in listener method. Message: \" + e.getMessage());\n                }\n            }\n        }\n        finally\n        {\n            if (!socket.isClosed())\n            {\n                socket.close();\n            }\n            this.isRunning = false;\n        }\n    }\n\n    /**\n     * Remove a conversation receiver\n     *\n     * @param comm The id of this conversation\n     */\n    private synchronized void unregister(int comm)\n    {\n        receivers.remove(comm);\n        this.tasks.remove(comm);\n    }\n\n    /**\n     * Stops listening and shuts down the server\n     */\n    public synchronized void shutdown()\n    {\n        this.isRunning = false;\n        this.socket.close();\n        timer.cancel();\n    }\n\n    /**\n     * Task that gets called by a separate thread if a timeout for a receiver occurs.\n     * When a reply arrives this task must be canceled using the <code>cancel()</code>\n     * method inherited from <code>TimerTask</code>. In this case the caller is\n     * responsible for removing the task from the <code>tasks</code> map.\n     * */\n    class TimeoutTask extends TimerTask\n    {\n\n        private final int comm;\n        private final Receiver recv;\n\n        public TimeoutTask(int comm, Receiver recv)\n        {\n            this.comm = comm;\n            this.recv = recv;\n        }\n\n        @Override\n        public void run()\n        {\n            if (!KadServer.this.isRunning)\n            {\n                return;\n            }\n\n            try\n            {\n                unregister(comm);\n                recv.timeout(comm);\n            }\n            catch (IOException e)\n            {\n                System.err.println(\"Cannot unregister a receiver. Message: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void printReceivers()\n    {\n        for (Integer r : this.receivers.keySet())\n        {\n            System.out.println(\"Receiver for comm: \" + r + \"; Receiver: \" + this.receivers.get(r));\n        }\n    }\n\n    public boolean isRunning()\n    {\n        return this.isRunning;\n    }\n\n}\nsrc/kademlia/KademliaNode.java\npublic interface KademliaNode\n{\n\n    /**\n     * Schedule the recurring refresh operation\n     */\n    public void startRefreshOperation();\n\n    /**\n     * Stop the recurring refresh operation\n     */\n    public void stopRefreshOperation();\n\n    /**\n     * @return Node The local node for this system\n     */\n    public Node getNode();\n\n    /**\n     * @return The KadServer used to send/receive messages\n     */\n    public KadServer getServer();\n\n    /**\n     * @return The DHT for this kad instance\n     */\n    public KademliaDHT getDHT();\n\n    /**\n     * @return The current KadConfiguration object being used\n     */\n    public KadConfiguration getCurrentConfiguration();\n\n    /**\n     * Connect to an existing peer-to-peer network.\n     *\n     * @param n The known node in the peer-to-peer network\n     *\n     * @throws RoutingException      If the bootstrap node could not be contacted\n     * @throws IOException           If a network error occurred\n     * @throws IllegalStateException If this object is closed\n     * */\n    public void bootstrap(Node n) throws IOException, RoutingException;\n\n    /**\n     * Stores the specified value under the given key\n     * This value is stored on K nodes on the network, or all nodes if there are > K total nodes in the network\n     *\n     * @param content The content to put onto the DHT\n     *\n     * @return Integer How many nodes the content was stored on\n     *\n     * @throws java.io.IOException\n     *\n     */\n    public int put(KadContent content) throws IOException;\n\n    /**\n     * Stores the specified value under the given key\n     * This value is stored on K nodes on the network, or all nodes if there are > K total nodes in the network\n     *\n     * @param entry The StorageEntry with the content to put onto the DHT\n     *\n     * @return Integer How many nodes the content was stored on\n     *\n     * @throws java.io.IOException\n     *\n     */\n    public int put(JKademliaStorageEntry entry) throws IOException;\n\n    /**\n     * Store a content on the local node's DHT\n     *\n     * @param content The content to put on the DHT\n     *\n     * @throws java.io.IOException\n     */\n    public void putLocally(KadContent content) throws IOException;\n\n    /**\n     * Get some content stored on the DHT\n     *\n     * @param param The parameters used to search for the content\n     *\n     * @return DHTContent The content\n     *\n     * @throws java.io.IOException\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException, ContentNotFoundException;\n\n    /**\n     * Allow the user of the System to call refresh even out of the normal Kad refresh timing\n     *\n     * @throws java.io.IOException\n     */\n    public void refresh() throws IOException;\n\n    /**\n     * @return String The ID of the owner of this local network\n     */\n    public String getOwnerId();\n\n    /**\n     * @return Integer The port on which this kad instance is running\n     */\n    public int getPort();\n\n    /**\n     * Here we handle properly shutting down the Kademlia instance\n     *\n     * @param saveState Whether to save the application state or not\n     *\n     * @throws java.io.FileNotFoundException\n     */\n    public void shutdown(final boolean saveState) throws IOException;\n\n    /**\n     * Saves the node state to a text file\n     *\n     * @throws java.io.FileNotFoundException\n     */\n    public void saveKadState() throws IOException;\n\n    /**\n     * @return The routing table for this node.\n     */\n    public KademliaRoutingTable getRoutingTable();\n\n    /**\n     * @return The statistician that manages all statistics\n     */\n    public KadStatistician getStatistician();\n}\nsrc/kademlia/message/Message.java\npublic interface Message extends Streamable\n{\n\n    /**\n     * The unique code for the message type, used to differentiate all messages\n     * from each other. Since this is of <code>byte</code> type there can\n     * be at most 256 different message types.\n     *\n     * @return byte A unique code representing the message type\n     * */\n    public byte code();\n}\nsrc/kademlia/node/Node.java\npublic class Node implements Streamable, Serializable\n{\n\n    private KademliaId nodeId;\n    private InetAddress inetAddress;\n    private int port;\n    private final String strRep;\n\n    public Node(KademliaId nid, InetAddress ip, int port)\n    {\n        this.nodeId = nid;\n        this.inetAddress = ip;\n        this.port = port;\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Load the Node's data from a DataInput stream\n     *\n     * @param in\n     *\n     * @throws IOException\n     */\n    public Node(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Set the InetAddress of this node\n     *\n     * @param addr The new InetAddress of this node\n     */\n    public void setInetAddress(InetAddress addr)\n    {\n        this.inetAddress = addr;\n    }\n\n    /**\n     * @return The NodeId object of this node\n     */\n    public KademliaId getNodeId()\n    {\n        return this.nodeId;\n    }\n\n    /**\n     * Creates a SocketAddress for this node\n     *\n     * @return\n     */\n    public InetSocketAddress getSocketAddress()\n    {\n        return new InetSocketAddress(this.inetAddress, this.port);\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        this.nodeId.toStream(out);\n\n        /* Add the Node's IP address to the stream */\n        byte[] a = inetAddress.getAddress();\n        if (a.length != 4)\n        {\n            throw new RuntimeException(\"Expected InetAddress of 4 bytes, got \" + a.length);\n        }\n        out.write(a);\n\n        /* Add the port to the stream */\n        out.writeInt(port);\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        /* Load the NodeId */\n        this.nodeId = new KademliaId(in);\n\n        /* Load the IP Address */\n        byte[] ip = new byte[4];\n        in.readFully(ip);\n        this.inetAddress = InetAddress.getByAddress(ip);\n\n        /* Read in the port */\n        this.port = in.readInt();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof Node)\n        {\n            Node n = (Node) o;\n            if (n == this)\n            {\n                return true;\n            }\n            return this.getNodeId().equals(n.getNodeId());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.getNodeId().hashCode();\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.getNodeId().toString();\n    }\n}\nsrc/kademlia/message/ConnectMessage.java\npublic class ConnectMessage implements Message\n{\n\n    private Node origin;\n    public static final byte CODE = 0x02;\n\n    public ConnectMessage(Node origin)\n    {\n        this.origin = origin;\n    }\n\n    public ConnectMessage(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        this.origin = new Node(in);\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        origin.toStream(out);\n    }\n\n    public Node getOrigin()\n    {\n        return this.origin;\n    }\n\n    @Override\n    public byte code()\n    {\n        return CODE;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"ConnectMessage[origin NodeId=\" + origin.getNodeId() + \"]\";\n    }\n}\nsrc/kademlia/exceptions/RoutingException.java\npublic class RoutingException extends IOException\n{\n\n    public RoutingException()\n    {\n        super();\n    }\n\n    public RoutingException(String message)\n    {\n        super(message);\n    }\n}\n", "answers": ["    private final Node bootstrapNode;"], "length": 3536, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "26eec314bf72b6e3629b958f58e6dae01e8b6d3c3515566c"}
{"input": "package com.cosium.openapi.annotation_processor;\nimport static java.util.Objects.requireNonNull;\nimport com.cosium.logging.annotation_processor.AbstractLoggingProcessor;\nimport com.cosium.openapi.annotation_processor.code.CodeGenerator;\nimport com.cosium.openapi.annotation_processor.code.CodeGeneratorFactory;\nimport com.cosium.openapi.annotation_processor.file.FileManager;\nimport com.cosium.openapi.annotation_processor.file.FileManagerFactory;\nimport com.cosium.openapi.annotation_processor.loader.DefaultServiceLoader;\nimport com.cosium.openapi.annotation_processor.loader.ServiceLoader;\nimport com.cosium.openapi.annotation_processor.model.ParsedPath;\nimport com.cosium.openapi.annotation_processor.option.IOptions;\nimport com.cosium.openapi.annotation_processor.option.OptionsBuilder;\nimport com.cosium.openapi.annotation_processor.parser.PathParser;\nimport com.cosium.openapi.annotation_processor.parser.PathParserFactory;\nimport com.cosium.openapi.annotation_processor.parser.spring.SpringParserFactory;\nimport com.cosium.openapi.annotation_processor.specification.SpecificationGenerator;\nimport com.cosium.openapi.annotation_processor.specification.SpecificationGeneratorFactory;\nimport com.google.auto.service.AutoService;\nimport io.swagger.models.Swagger;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Collectors;\nimport javax.annotation.processing.Messager;\nimport javax.annotation.processing.ProcessingEnvironment;\nimport javax.annotation.processing.Processor;\nimport javax.annotation.processing.RoundEnvironment;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\nimport javax.tools.Diagnostic;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n\n/**\n * Created on 12/07/17.\n *\n * @author Reda.Housni-Alaoui\n */\n@AutoService(Processor.class)\npublic class OpenAPIProcessor extends AbstractLoggingProcessor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(OpenAPIProcessor.class);\n\n    private final AtomicInteger roundNumber = new AtomicInteger();\n    private final List<PathParserFactory> parserFactories = new ArrayList<>();\n    private final OptionsBuilder optionsBuilder = new OptionsBuilder();", "context": "src/main/java/com/cosium/openapi/annotation_processor/parser/spring/SpringParserFactory.java\npublic class SpringParserFactory implements PathParserFactory {\n\n    @Override\n    public String getSupportedAnnotation() {\n        return RequestMapping.class.getCanonicalName();\n    }\n\n    @Override\n    public PathParser build(Types typeUtils, Elements elementUtils) {\n        return new SpringParser(new PropertyUtils(typeUtils, elementUtils), new AnnotationUtils(typeUtils));\n    }\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/option/IOptions.java\n@Value.Immutable\npublic interface IOptions {\n\n    /**\n     * @return The base package that will be used to generate all resources\n     */\n    String baseGenerationPackage();\n\n    /**\n     * @return The specification generator options\n     */\n    ISpecificationGeneratorOptions specificationGenerator();\n\n    /**\n     * @return The code generator options\n     */\n    ICodeGeneratorOptions codeGenerator();\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/loader/ServiceLoader.java\npublic interface ServiceLoader {\n\n    /**\n     * @param serviceType The service type\n     * @param <T> The service type\n     * @return All the available instances for the service type\n     */\n    <T> List<T> load(Class<T> serviceType);\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/parser/PathParser.java\npublic interface PathParser {\n\n    /**\n     * @param annotatedElement The element from which to parse the paths.\n     *                         This element is annoted with {@link PathParserFactory#getSupportedAnnotation()}.\n     * @return A list of parsed paths\n     */\n    List<ParsedPath> parse(Element annotatedElement);\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/specification/SpecificationGenerator.java\npublic interface SpecificationGenerator {\n\n    /**\n     * Generate specification for given paths\n     *\n     * @param parsedPaths The parsed paths\n     * @param roundDescriptor The descriptor of the current round\n     * @return The generated specification\n     */\n    Swagger generate(List<ParsedPath> parsedPaths, RoundDescriptor roundDescriptor);\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/loader/DefaultServiceLoader.java\npublic class DefaultServiceLoader implements ServiceLoader {\n\n    private final Map<Class<?>, List<?>> servicesByType = Collections.synchronizedMap(new HashMap<>());\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> List<T> load(Class<T> serviceType) {\n        servicesByType.computeIfAbsent(serviceType, this::doLoad);\n        return (List<T>) servicesByType.get(serviceType);\n    }\n\n    private <T> List<T> doLoad(Class<T> serviceType) {\n        try (InputStream inputStream = getClass().getResourceAsStream(\"/META-INF/services/\" + serviceType.getCanonicalName())) {\n            return readLines(inputStream)\n                    .stream()\n                    .map(this::classForName)\n                    .map(this::newInstance)\n                    .map(serviceType::cast)\n                    .collect(Collectors.toList());\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List<String> readLines(InputStream inputStream) throws IOException {\n        return IOUtils.readLines(inputStream);\n    }\n\n    private Class<?> classForName(String name) {\n        try {\n            return Class.forName(name);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private <T> T newInstance(Class<T> type) {\n        try {\n            return type.newInstance();\n        } catch (InstantiationException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/file/FileManager.java\npublic interface FileManager {\n\n    FileObject getResource(CharSequence relativeName) throws NoSuchFileException;\n\n    FileObject getResource(CharSequence pkg, CharSequence relativeName) throws NoSuchFileException;\n\n    FileObject createResource(CharSequence relativeName);\n\n    FileObject createResource(CharSequence pkg, CharSequence relativeName);\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/model/ParsedPath.java\npublic class ParsedPath {\n\n    private final String pathTemplate;\n    private final Path path;\n\n    @JsonCreator\n    public ParsedPath(@JsonProperty(\"pathTemplate\") String pathTemplate, @JsonProperty(\"path\") Path path) {\n        requireNonNull(pathTemplate);\n        requireNonNull(path);\n\n        this.pathTemplate = pathTemplate;\n        this.path = path;\n    }\n\n    public String getPathTemplate() {\n        return pathTemplate;\n    }\n\n    public Path getPath() {\n        return path;\n    }\n\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this)\n                .append(\"pathTemplate\", pathTemplate)\n                .toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        ParsedPath that = (ParsedPath) o;\n\n        return pathTemplate.equals(that.pathTemplate);\n    }\n\n    @Override\n    public int hashCode() {\n        return pathTemplate.hashCode();\n    }\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/code/CodeGenerator.java\npublic interface CodeGenerator {\n\n    /**\n     * Generates code from specification\n     * @param swagger The specification to generate code from\n     */\n    void generate(Swagger swagger);\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/option/OptionsBuilder.java\npublic class OptionsBuilder {\n\n    private static final String PREFIX = \"com.cosium.openapi.\";\n\n    private static final String BASE_GENERATION_PACKAGE = PREFIX + \"generation_package\";\n\n    private static final String SPECIFICATION_GENERATOR_PREFIX = PREFIX + \"specification_generator.\";\n\n    private static final String SPECIFICATION_GENERATOR_TITLE_OPTION = SPECIFICATION_GENERATOR_PREFIX + \"title\";\n    private static final String SPECIFICATION_GENERATOR_BASE_PATH_OPTION = SPECIFICATION_GENERATOR_PREFIX + \"base_path\";\n    private static final String SPECIFICATION_GENERATOR_PRODUCES_OPTION = SPECIFICATION_GENERATOR_PREFIX + \"produces\";\n    private static final String SPECIFICATION_GENERATOR_CONSUMES_OPTION = SPECIFICATION_GENERATOR_PREFIX + \"consumes\";\n\n    private static final String CODE_GENERATOR_PREFIX = PREFIX + \"code_generator.\";\n\n    private static final String CODE_GENERATOR_LANGUAGES_OPTIONS = CODE_GENERATOR_PREFIX + \"languages\";\n    private static final String CODE_GENERATOR_ONE_GENERATION_FOLDER_PER_LANGUAGE_OPTIONS = CODE_GENERATOR_PREFIX + \"one_generation_folder_per_language\";\n\n    private static final String APPLICATION_JSON = \"application/json\";\n\n    public Set<String> getSupportedOptions() {\n        return new LinkedHashSet<>(Arrays.asList(\n                BASE_GENERATION_PACKAGE,\n                SPECIFICATION_GENERATOR_TITLE_OPTION,\n                SPECIFICATION_GENERATOR_BASE_PATH_OPTION,\n                SPECIFICATION_GENERATOR_PRODUCES_OPTION,\n                SPECIFICATION_GENERATOR_CONSUMES_OPTION,\n                CODE_GENERATOR_LANGUAGES_OPTIONS,\n                CODE_GENERATOR_ONE_GENERATION_FOLDER_PER_LANGUAGE_OPTIONS\n        ));\n    }\n\n    public IOptions build(Map<String, String> options) {\n        return Options\n                .builder()\n                .baseGenerationPackage(options.getOrDefault(BASE_GENERATION_PACKAGE, \"com.cosium.openapi.generated\"))\n                .specificationGenerator(buildSpecificationGenerator(options))\n                .codeGenerator(buildCodeGenerator(options))\n                .build();\n    }\n\n    private ISpecificationGeneratorOptions buildSpecificationGenerator(Map<String, String> options) {\n        SpecificationGeneratorOptions.BuildFinal documentatorOptionsBuilder = SpecificationGeneratorOptions\n                .builder()\n                .title(options.getOrDefault(SPECIFICATION_GENERATOR_TITLE_OPTION, StringUtils.EMPTY))\n                .basePath(options.getOrDefault(SPECIFICATION_GENERATOR_BASE_PATH_OPTION, \"/\"));\n\n        Stream.of(StringUtils\n                .split(StringUtils.defaultIfBlank(options.get(SPECIFICATION_GENERATOR_CONSUMES_OPTION), APPLICATION_JSON), \",\"))\n                .forEach(documentatorOptionsBuilder::addConsumes);\n        Stream.of(StringUtils\n                .split(StringUtils.defaultIfBlank(options.get(SPECIFICATION_GENERATOR_PRODUCES_OPTION), APPLICATION_JSON), \",\"))\n                .forEach(documentatorOptionsBuilder::addProduces);\n        return documentatorOptionsBuilder.build();\n    }\n\n    private ICodeGeneratorOptions buildCodeGenerator(Map<String, String> options) {\n        CodeGeneratorOptions.BuildFinal builder = CodeGeneratorOptions.builder()\n                .oneGenerationFolderPerLanguage(Boolean.valueOf(\n                        options.getOrDefault(CODE_GENERATOR_ONE_GENERATION_FOLDER_PER_LANGUAGE_OPTIONS, String.valueOf(true))\n                ));\n\n        ofNullable(options.get(CODE_GENERATOR_LANGUAGES_OPTIONS))\n                .filter(StringUtils::isNotBlank)\n                .map(s -> StringUtils.split(s, \",\"))\n                .ifPresent(builder::addLanguages);\n\n        return builder.build();\n    }\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/specification/SpecificationGeneratorFactory.java\npublic class SpecificationGeneratorFactory {\n\n    private final AtomicReference<Swagger> runtimeCache = new AtomicReference<>();\n    private final ISpecificationGeneratorOptions options;\n\n    public SpecificationGeneratorFactory(ISpecificationGeneratorOptions options) {\n        requireNonNull(options);\n        this.options = options;\n    }\n\n\n    public SpecificationGenerator build(FileManager fileManager) {\n        return new WriterSpecificationGenerator(\n                new IncrementalSpecificationGenerator(\n                        new BasicSpecificationGenerator(\n                                runtimeCache,\n                                options\n                        ), fileManager\n                ), fileManager\n        );\n    }\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/code/CodeGeneratorFactory.java\npublic class CodeGeneratorFactory {\n\n    private final ICodeGeneratorOptions options;\n    private final ServiceLoader serviceLoader;\n\n    public CodeGeneratorFactory(ICodeGeneratorOptions options, ServiceLoader serviceLoader) {\n        requireNonNull(options);\n        requireNonNull(serviceLoader);\n        this.options = options;\n        this.serviceLoader = serviceLoader;\n    }\n\n    public CodeGenerator build(FileManager fileManager) {\n        return new DefaultCodeGenerator(\n                options,\n                serviceLoader,\n                fileManager\n        );\n    }\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/file/FileManagerFactory.java\npublic class FileManagerFactory {\n\n    private final Filer filer;\n    private final String baseGenerationPackage;\n\n    public FileManagerFactory(Filer filer, String baseGenerationPackage) {\n        requireNonNull(filer);\n        requireNonNull(baseGenerationPackage);\n        this.filer = filer;\n        this.baseGenerationPackage = baseGenerationPackage;\n    }\n\n    public FileManager build(String packageName, Collection<Element> originatingElements) {\n        return new DefaultFileManager(baseGenerationPackage + \".\" + packageName, filer, originatingElements);\n    }\n\n}\nsrc/main/java/com/cosium/openapi/annotation_processor/parser/PathParserFactory.java\npublic interface PathParserFactory {\n\n    /**\n     * @return The supported annotation qualified name\n     */\n    String getSupportedAnnotation();\n\n    /**\n     * @return A new parser\n     */\n    PathParser build(Types typeUtils, Elements elementUtils);\n\n}\n", "answers": ["    private final ServiceLoader serviceLoader = new DefaultServiceLoader();"], "length": 925, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "169dde6aa6a69a92950ca0529c356ab33884183329f88574"}
{"input": "from struct import (pack, unpack)\nfrom thrift.protocol.TBinaryProtocol import TBinaryProtocolAcceleratedFactory\nfrom ..asynchronous import (\n  AsyncResult,\n  NoopTimeout\n)\nfrom ..compat import BytesIO\nfrom ..constants import (\n  ChannelState,\n  SinkProperties,\n  SinkRole\n)\nfrom ..message import (\n  ChannelConcurrencyError,\n  ClientError,\n  Deadline,\n  MethodCallMessage,\n  MethodReturnMessage,\n  TimeoutError\n)\nfrom ..sink import (\n  SinkProvider,\n  SocketTransportSinkProvider,\n  ClientMessageSink,\n)\nfrom ..varz import (\n  AggregateTimer,\n  AverageTimer,\n  Rate,\n  Source,\n  VarzBase,\n)\nfrom .serializer import MessageSerializer\nimport time\nimport gevent\n\n\nclass SocketTransportSink(ClientMessageSink):\n  \"\"\"A sink to transport thrift method calls over a socket.\n\n  This sink does not support processing multiple messages in parallel and will\n  raise an exception if it detects it is about to.\n  \"\"\"\n  class Varz(VarzBase):\n    \"\"\"\n    messages_sent - The number of messages sent over this sink.\n    messages_recv - The number of messages received over this sink.\n    send_time - The aggregate amount of time spent sending data.\n    recv_time - The aggregate amount of time spend receiving data.\n    send_latency - The average amount of time taken to send a message.\n    recv_latency - The average amount of time taken to receive a message\n                   (once a response has reached the client).\n    transport_latency - The average amount of time taken to perform a full\n                        method call transaction (send data, wait for response,\n                        read response).\n    \"\"\"\n\n    _VARZ_BASE_NAME = 'scales.thrift.SocketTransportSink'\n    _VARZ = {\n      'messages_sent': Rate,\n      'messages_recv': Rate,\n      'send_time': AggregateTimer,\n      'recv_time': AggregateTimer,\n      'send_latency': AverageTimer,\n      'recv_latency': AverageTimer,\n      'transport_latency': AverageTimer\n    }\n\n  def __init__(self, socket, source):\n    super(SocketTransportSink, self).__init__()\n    self._socket = socket\n    self._state = ChannelState.Idle\n    socket_source = '%s:%d' % (self._socket.host, self._socket.port)\n    self._varz = self.Varz(Source(service=source, endpoint=socket_source))\n    self._processing = None\n    self._open_result = None\n\n  def Open(self):\n    if not self._open_result:\n      self._open_result = AsyncResult()\n      self._open_result.SafeLink(self._OpenImpl)\n    return self._open_result\n\n  def _OpenImpl(self):\n    try:\n      self._socket.open()\n      self._state = ChannelState.Open\n    except Exception:\n      self._Fault('Open failed')\n      raise\n\n  def Close(self):\n    self._state = ChannelState.Closed\n    self._socket.close()\n    self._open_result = None\n    if self._processing:\n      p, self._processing = self._processing, None\n      p.kill(block=False)\n\n  @property\n  def state(self):\n    if self._socket.isOpen():\n      return ChannelState.Open\n    else:\n      return self._state\n\n  def _Fault(self, reason):\n    \"\"\"Shutdown the sink and signal.\n\n    Args:\n      reason - The reason the shutdown occurred.  May be an exception or string.\n    \"\"\"\n    if self.state == ChannelState.Closed:\n      return\n\n    self.Close()\n    if not isinstance(reason, Exception):\n      reason = Exception(str(reason))\n    self._on_faulted.Set(reason)\n\n  def _AsyncProcessTransaction(self, data, sink_stack, deadline):\n    \"\"\"Process a method call/response transaction.\n    When complete the response is dispatched to the sink_stack.\n\n    Args:\n      data - The data to send.\n      sink_stack - The sink_stack for this method call.\n      deadline - The absolute deadline the transaction must complete by.\n    \"\"\"\n    with self._varz.transport_latency.Measure():\n      gtimeout = None\n      try:\n        if deadline:\n          timeout = deadline - time.time()\n          if timeout < 0:\n            raise gevent.Timeout()\n          gtimeout = gevent.Timeout.start_new(timeout)\n        else:\n          gtimeout = NoopTimeout()\n\n        with self._varz.send_time.Measure():\n          with self._varz.send_latency.Measure():\n            self._socket.write(data)\n        self._varz.messages_sent()\n\n        sz, = unpack('!i', self._socket.readAll(4))\n        with self._varz.recv_time.Measure():\n          with self._varz.recv_latency.Measure():\n            buf = BytesIO(self._socket.readAll(sz))\n        self._varz.messages_recv()\n\n        gtimeout.cancel()\n        self._processing = None\n        gevent.spawn(self._ProcessReply, buf, sink_stack)\n      except gevent.Timeout: # pylint: disable=E0712\n", "context": "scales/thrift/serializer.py\nclass MessageSerializer(object):\n  \"\"\"A serializer that can serialize and deserialize thrift method calls.\n\n  This relies on the generated thrift args and return value classes created\n  by the thrift compiler to do the serialization/deserialization.\n  \"\"\"\n  def __init__(\n      self,\n      service_cls,\n      protocol_factory=TBinaryProtocolAcceleratedFactory()):\n    \"\"\"\n    Args:\n      service_cls - The thrift generated interface class.\n      protocol_factory - A class implementing getProtocol(...).  By default,\n       TBinaryProtocolAcceleratedFactory is used.\n    \"\"\"\n    self._protocol_factory = protocol_factory\n    self._seq_id = 0\n    self._service_modules = [sys.modules[c.__module__]\n                             for c in inspect.getmro(service_cls)\n                             if not c is object]\n    if len(self._service_modules) == 1:\n      self._FindClass = self._FindClassNoInheritance\n    else:\n      self._attr_cache = {}\n      self._FindClass = self._FindClassInheritance\n\n  def _FindClassInheritance(self, name):\n    cls = self._attr_cache.get(name)\n    if cls:\n      return cls\n\n    for m in self._service_modules:\n      cls = getattr(m, name, None)\n      if cls:\n        self._attr_cache[name] = cls\n        return cls\n    return None\n\n  def _FindClassNoInheritance(self, name):\n    return getattr(self._service_modules[0], name, None)\n\n  def SerializeThriftCall(self, msg, buf):\n    \"\"\"Serialize a MethodCallMessage to a stream\n\n    Args:\n      msg - The MethodCallMessage to serialize.\n      buf - The buffer to serialize into.\n    \"\"\"\n    thrift_buffer = TMemoryBuffer()\n    thrift_buffer._buffer = buf\n    protocol = self._protocol_factory.getProtocol(thrift_buffer)\n    method, args, kwargs = msg.method, msg.args, msg.kwargs\n    is_one_way = self._FindClass('%s_result' % method) is None\n    args_cls = self._FindClass('%s_args' % method)\n    if not args_cls:\n      raise AttributeError('Unable to find args class for method %s' % method)\n\n    protocol.writeMessageBegin(\n        msg.method,\n        TMessageType.ONEWAY if is_one_way else TMessageType.CALL,\n        self._seq_id)\n    thrift_args = args_cls(*args, **kwargs)\n    thrift_args.write(protocol)\n    protocol.writeMessageEnd()\n\n  def DeserializeThriftCall(self, buf):\n    \"\"\"Deserialize a stream and context to a MethodReturnMessage.\n\n    Args:\n      buf - The buffer.\n      ctx - The context from serialization.\n\n    Returns:\n      A MethodCallMessage.\n    \"\"\"\n\n    thrift_buffer = TMemoryBuffer()\n    thrift_buffer._buffer = buf\n    protocol = self._protocol_factory.getProtocol(thrift_buffer)\n\n    (fn_name, msg_type, seq_id) = protocol.readMessageBegin()\n    if msg_type == TMessageType.EXCEPTION:\n      x = TApplicationException()\n      x.read(protocol)\n      protocol.readMessageEnd()\n      return MethodReturnMessage(error=x)\n\n    result_cls = self._FindClass('%s_result' % fn_name)\n    if result_cls:\n      result = result_cls()\n      result.read(protocol)\n    else:\n      result = None\n    protocol.readMessageEnd()\n\n    if not result:\n      return MethodReturnMessage()\n    if getattr(result, 'success', None) is not None:\n      return MethodReturnMessage(return_value=result.success)\n\n    result_spec = getattr(result_cls, 'thrift_spec', None)\n    if result_spec:\n      exceptions = result_spec[1:]\n      for e in exceptions:\n        attr_val = getattr(result, e[2], None)\n        if attr_val is not None:\n          return MethodReturnMessage(error=attr_val)\n\n    return MethodReturnMessage(TApplicationException(\n      TApplicationException.MISSING_RESULT, \"%s failed: unknown result\" % fn_name))\nscales/message.py\nclass Deadline(object):\r\n  KEY = \"__Deadline\"\r\n  EVENT_KEY = \"__Deadline_Event\"\r\n\r\n  def __init__(self, timeout):\r\n    \"\"\"\r\n    Args:\r\n      timeout - The timeout in seconds\r\n    \"\"\"\r\n    import  time\r\n    self._ts = Long(time.time()) * 1000000000 # Nanoseconds\r\n    self._timeout = Long(timeout * 1000000000)\r\nscales/message.py\nclass MethodReturnMessage(Message):\r\n  \"\"\"A message representing the return value from a service call.\"\"\"\r\n  __slots__ = ('return_value', 'error', 'stack')\r\n\r\n  def __init__(self, return_value=None, error=None):\r\n    \"\"\"\r\n    Args:\r\n      return_value - The return value of the call, or None\r\n      error - The error that occurred during processing, or None.\r\n              If not None, the current stack will be captured and included.\r\n    \"\"\"\r\n    super(MethodReturnMessage, self).__init__()\r\n    self.return_value = return_value\r\n    self.error = error\r\n    if error:\r\n      exc_info = sys.exc_info()\r\n      if len(exc_info) != 3 or exc_info[2] is None:\r\n        try:\r\n          raise ZeroDivisionError\r\n        except ZeroDivisionError:\r\n          tb = sys.exc_info()[2]\r\n          frame = tb.tb_frame.f_back\r\n      else:\r\n        tb = exc_info[2]\r\n        while tb.tb_next is not None:\r\n          tb = tb.tb_next\r\n        frame = tb.tb_frame\r\n\r\n      stack = traceback.format_list(traceback.extract_stack(frame))\r\n      stack = stack + traceback.format_exception_only(error.__class__, error)\r\n      self.stack = stack\r\n      # Prevent circular references\r\n      del frame\r\n      del tb\r\n    else:\r\n      self.stack = None\r\nscales/sink.py\ndef SinkProvider(sink_cls, role=None, **defaults):\n  \"\"\"Factory for creating simple sink providers.\n\n  Args:\n    sink_cls - The type of sink to provide.\n  Returns:\n    A SinkProvider that provides sinks of type 'sink_cls'.\n  \"\"\"\n  field_names = ' '.join(defaults.keys())\n  params_cls = namedtuple('Params', field_names)\n\n  def CreateSink(self, properties):\n    return self.SINK_CLASS(self.next_provider, self.sink_properties, properties)\n\n  def sink_class(self):\n    return self.SINK_CLASS\n\n  provider = type(\n    sink_cls.__name__ + 'Provider',\n    (SinkProviderBase, ),\n    {\n      'SINK_CLASS': sink_cls,\n      'PARAMS_CLASS': params_cls,\n      'Role': role,\n      'CreateSink': CreateSink,\n      'sink_class': property(sink_class),\n      '_defaults': defaults\n    }\n  )\n  return provider\nscales/asynchronous.py\nclass AsyncResult(g_AsyncResult):\n  @staticmethod\n  def WhenAll(ars):\n    \"\"\"Returns an AsyncResult representing the state of all AsyncResults passed.\n\n    Args:\n      ars - An enumerable of AsyncResults.\n    Returns:\n      An AsyncResult representing the completion of all ars passed in.  When all\n      complete, the AsyncResult will be set to an array of the results of each\n      AsyncResult, in the order they were enumerated in.\n      If any AsyncResult fails, the return result will fail.\n    \"\"\"\n\n    ret = AsyncResult()\n    num_ars = len(ars)\n    total = [num_ars]\n    results = [None] * num_ars\n    def complete(_n, _ar):\n      if _ar.exception:\n        ret.set_exception(_ar.exception)\n      elif not ret.ready():\n        total[0] -= 1\n        results[_n] = _ar.value\n        if total[0] == 0:\n          ret.set(results)\n\n    for n, ar in enumerate(ars):\n      ar.rawlink(functools.partial(complete, n))\n    return ret\n\n  @staticmethod\n  def WhenAny(ars):\n    \"\"\"Returns an AsyncResult representing the state of any AsyncResult passed in.\n    The return value represents the state of the first AsyncResult to complete, or,\n    if all fail, the last to fail.\n\n    Args:\n      ars - An enumerable of AsyncResults.\n    Returns:\n      An AsyncResult representing the state of the first AsyncResult to complete.\n      The AsyncResult's value will be set to the value of the first result to\n      complete, or, if all fail, the exception thrown by the last to fail.\n    \"\"\"\n    ready_ars = [ar for ar in ars if ar.ready()]\n    if ready_ars:\n      return ready_ars[0]\n\n    ret = AsyncResult()\n    total = [len(ars)]\n    def complete(_ar):\n      total[0] -= 1\n      if total[0] == 0 and _ar.exception:\n        ret.set_exception(_ar.exception)\n      elif not ret.ready() and _ar.successful():\n        ret.set(_ar.value)\n\n    for ar in ars:\n      ar.rawlink(complete)\n    return ret\n\n  @staticmethod\n  def FromValue(val):\n    if val is None:\n      return AsyncResult.Complete()\n    else:\n      ar = AsyncResult()\n      ar.set(val)\n      return ar\n\n  @staticmethod\n  def Complete():\n    \"\"\"Return an AsyncResult that has completed.\"\"\"\n    return _COMPLETE\n\n  @staticmethod\n  def CompleteIn(n):\n    \"\"\"Returns an AsyncResult that completes in <n> seconds\n\n    Args:\n      n - The number of seconds to wait before completing.\n    \"\"\"\n    ar = AsyncResult()\n    def helper():\n      ar.set()\n    g = Greenlet(helper)\n    g.start_later(float(n))\n    return ar\n\n  def _SafeLinkHelper(self, fn):\n    try:\n      self.set(fn())\n    except:\n      self.set_exception(sys.exc_info()[1])\n\n  def SafeLink(self, fn):\n    \"\"\"Propagate the result of calling fn() on a new greenlet to ar\n\n    Args:\n      ar - An AsyncResult.\n      fn - The function to execute.\n    \"\"\"\n    gevent.spawn(self._SafeLinkHelper, fn)\n\n  def ContinueWith(self, fn, on_hub=True):\n    cw_ar = AsyncResult()\n    def continue_with_callback(_ar):\n      def run():\n        try:\n          val = fn(_ar)\n          cw_ar.set(val)\n        except:\n          cw_ar.set_exception(sys.exc_info()[1])\n      if on_hub:\n        run()\n      else:\n        gevent.spawn(run)\n    self.rawlink(continue_with_callback)\n    return cw_ar\n\n  def Map(self, fn):\n    def mapper(_):\n      if self.exception:\n        return self\n      else:\n        return fn(self.value)\n    return self.ContinueWith(mapper).Unwrap()\n\n  def _UnwrapHelper(self, target):\n    if self.ready():\n      # We're ready, propagate the result\n      if self.exception:\n        target.set_exception(self.exception)\n      else:\n        if isinstance(self.value, AsyncResult):\n          self.value._UnwrapHelper(target)\n        else:\n          target.set(self.value)\n    else:\n      self.rawlink(\n        functools.partial(AsyncResult._UnwrapHelper, target=target))\n\n  def Unwrap(self):\n    unwrapped_ar = AsyncResult()\n    self._UnwrapHelper(unwrapped_ar)\n    return unwrapped_ar\n\n  @staticmethod\n  def TryGet(val):\n    if isinstance(val, AsyncResult):\n      return val.get()\n    else:\n      return val\n\n  @staticmethod\n  def Run(fn):\n    ar = AsyncResult()\n    ar.SafeLink(fn)\n    return ar\n\n  @staticmethod\n  def RunInline(fn):\n    ar = AsyncResult()\n    ar._SafeLinkHelper(fn)\n    return ar\nscales/message.py\nclass TimeoutError(Exception):\r\n  def __init__(self):\r\n    super(TimeoutError, self).__init__(\r\n      'The call did not complete within the specified timeout '\r\n      'and has been aborted.')\r\nscales/message.py\nclass ChannelConcurrencyError(Exception): pass\r\nscales/sink.py\ndef SocketTransportSinkProvider(sink_cls):\n  class _SocketTransportSinkProvider(SinkProviderBase):\n    SINK_CLS = sink_cls\n    Role = SinkRole.Transport\n\n    def CreateSink(self, properties):\n      server = properties[SinkProperties.Endpoint]\n      service = properties[SinkProperties.Label]\n      sock = ScalesSocket(server.host, server.port)\n      healthy_sock = VarzSocketWrapper(sock, service)\n      sink = self.SINK_CLS(healthy_sock, service)\n      return sink\n\n    @property\n    def sink_class(self):\n      return self.SINK_CLS\n\n  return _SocketTransportSinkProvider\nscales/constants.py\nclass ChannelState(object):\r\n  Idle = 1\r\n  Open = 2\r\n  Busy = 3\r\n  Closed = 4\r\nscales/varz.py\nclass VarzType(object):\nclass Source(object):\nclass VarzMetric(object):\nclass Gauge(VarzMetric): VARZ_TYPE = VarzType.Gauge\nclass Rate(VarzMetric): VARZ_TYPE = VarzType.Rate\nclass AverageRate(VarzMetric): VARZ_TYPE = VarzType.AverageRate\nclass Counter(Rate): VARZ_TYPE = VarzType.Counter\nclass VarzTimerBase(VarzMetric):\nclass AverageTimer(VarzTimerBase): VARZ_TYPE = VarzType.AverageTimer\nclass AggregateTimer(VarzTimerBase): VARZ_TYPE = VarzType.AggregateTimer\nclass VarzMeta(type):\nclass _VarzBase(object):\nclass _SampleSet(object):\nclass VarzReceiver(object):\nclass VarzAggregator(object):\n  class _Agg(object):\nclass VarzSocketWrapper(object):\n  class Varz(VarzBase):\nclass MonoClock(object):\nclass Ema(object):\n  def __init__(self, method=None, service=None, endpoint=None, client_id=None):\n  def to_tuple(self):\n  def to_dict(self):\n  def __cmp__(self, other):\n  def __hash__(self):\n  def _Adapt(fn):\n    def __Adapt(metric, source, amount=1):\n  def __init__(self, metric, source):\n  def __call__(self, *args):\n  def ForSource(self, source):\n  def Measure(self, source=None):\n  def __new__(mcs, name, bases, dct):\ndef VerifySource(source):\n  def __init__(self, source):\n  def __getattr__(self, item):\n  def __init__(self, max_size, data=None, p=.1):\n  def Sample(self, value):\n  def RegisterMetric(metric, varz_type):\n  def IncrementVarz(source, metric, amount=1):\n  def SetVarz(source, metric, value):\n  def RecordPercentileSample(cls, source, metric, value):\ndef DefaultKeySelector(k):\n    def __init__(self):\n  def CalculatePercentile(values, pct):\n  def _Downsample(lst, target_size):\n  def Aggregate(varz, metrics, key_selector=None):\n  def __init__(self, socket, varz_tag):\n  def host(self):\n  def port(self):\n  def isOpen(self):\n  def read(self, sz):\n  def recv_into(self, buf, sz):\n  def flush(self):\n  def write(self, buff):\n  def open(self):\n  def close(self):\n  def readAll(self, sz):\n  def __init__(self):\n  def Sample(self):\n  def __init__(self, window):\n  def Update(self, ts, sample):\n  VARZ_TYPE = None\nclass Gauge(VarzMetric): VARZ_TYPE = VarzType.Gauge\nclass Rate(VarzMetric): VARZ_TYPE = VarzType.Rate\nclass AverageRate(VarzMetric): VARZ_TYPE = VarzType.AverageRate\nclass Counter(Rate): VARZ_TYPE = VarzType.Counter\nclass AverageTimer(VarzTimerBase): VARZ_TYPE = VarzType.AverageTimer\nclass AggregateTimer(VarzTimerBase): VARZ_TYPE = VarzType.AggregateTimer\n  _VARZ = {}\n  _VARZ_BASE_NAME = None\n  VARZ_METRICS = {}\n  VARZ_DATA = defaultdict(lambda: defaultdict(int))\n  VARZ_PERCENTILES = [.5, .90, .99, .999, .9999]\n  _MAX_PERCENTILE_SIZE = 1000\n  MAX_AGG_AGE = 5 * 60\n    _VARZ_BASE_NAME = 'scales.socket'\n    _VARZ = {\n      'bytes_recv': Rate,\n      'bytes_sent': Rate,\n      'num_connections': Counter,\n      'tests_failed': Counter,\n      'connects': Rate,\n      'open_latency': AverageTimer\n    }\nscales/message.py\nclass MethodCallMessage(Message):\r\n  \"\"\"A MethodCallMessage represents a method being invoked on a service.\"\"\"\r\n  __slots__ = ('service', 'method', 'args', 'kwargs')\r\n\r\n  def __init__(self, service, method, args, kwargs):\r\n    \"\"\"\r\n    Args:\r\n      service - The service this method call is intended for.\r\n      method - The method on the service.\r\n      args - The args passed to the method call.\r\n      kwargs-  The kwargs passed to the method call.\r\n    \"\"\"\r\n    super(MethodCallMessage, self).__init__()\r\n    self.service = service\r\n    self.method = method\r\n    self.args = args\r\n    self.kwargs = kwargs\r\nscales/sink.py\nclass ClientMessageSink(MessageSink):\n  \"\"\"ClientMessageSinks take a message, stream, and headers and perform\n  processing on them.\n  \"\"\"\n  __slots__ = '_on_faulted',\n  Role = None\n  Builder = None\n\n  def __init__(self):\n    self._on_faulted = Observable()\n    super(ClientMessageSink, self).__init__()\n\n  @property\n  def state(self):\n    return self.next_sink.state\n\n  @property\n  def is_open(self):\n    \"\"\"Returns True if the sink is Idle, Open, or Busy\"\"\"\n    return self.state <= ChannelState.Busy\n\n  @property\n  def is_closed(self):\n    \"\"\"Returns True if the sink is Closed.\"\"\"\n    return self.state == ChannelState.Closed\n\n  @property\n  def is_ready(self):\n    \"\"\"Returns True if the channel is open, eg ready to process messages.\"\"\"\n    return self.state == ChannelState.Open\n\n  @property\n  def on_faulted(self):\n    return self._on_faulted\n\n  def Open(self):\n    if self.next_sink:\n      return self.next_sink.Open()\n    else:\n      return AsyncResult.Complete()\n\n  def Close(self):\n    if self.next_sink:\n      self.next_sink.Close()\n\n  @abstractmethod\n  def AsyncProcessRequest(self, sink_stack, msg, stream, headers):\n    \"\"\"Process a request message, stream, and headers.\n\n    Args:\n      sink_stack - The SinkStack representing the processing state of the message.\n                   Implementors should push their sink onto this stack before\n                   forwarding the message in order to participate in processing\n                   the response.\n      msg - The message being processed.\n      stream - A serialized version of the message.\n      headers - Any additional headers to be sent.\n    \"\"\"\n    raise NotImplementedError()\n\n  @abstractmethod\n  def AsyncProcessResponse(self, sink_stack, context, stream, msg):\n    \"\"\"Process a response stream.\n\n    Args:\n      sink_stack - The SinkStack representing the processing state of the message.\n                   Implementors should call sink_stack.AsyncProcessMessage(...)\n                   to forward the message to the next sink.\n      context - The context that was pushed onto the stack in AsyncProcessRequest.\n      stream - The stream representing the serialized response.\n    \"\"\"\n    raise NotImplementedError()\nscales/compat.py\n\nscales/constants.py\nclass SinkRole(object):\r\n  Transport = 'transport'\r\n  Pool = 'pool'\r\n  LoadBalancer = 'loadbalancer'\r\n  Formatter = 'formatter'\r\nscales/constants.py\nclass SinkProperties(object):\r\n  Endpoint = 'endpoint'\r\n  ServiceInterface = 'service_iface'\r\n  Label = 'label'\r\nscales/asynchronous.py\nclass NoopTimeout(object):\n  def start(self): pass\n  def cancel(self): pass\nscales/message.py\nclass ClientError(Exception): pass\r\n", "answers": ["        err = TimeoutError()"], "length": 2130, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "d6e0fb2ff8a19c243e92b7242fece0adc5425bb8cc6722a6"}
{"input": "import sys\nimport os\nimport glob\nimport datetime\nimport copy\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\n    import argparse\n    import RMS.ConfigReader as cr\nfrom RMS.Astrometry.Conversions import raDec2Vector, vector2RaDec, datetime2JD, jd2Date, raDec2AltAz, \\\n    geocentricToApparentRadiantAndVelocity, EARTH_CONSTANTS\nfrom RMS.Formats.FFfile import filenameToDatetime\nfrom RMS.Formats.FTPdetectinfo import readFTPdetectinfo\nfrom RMS.Formats.Showers import loadShowers, generateActivityDiagram, makeShowerColors\nfrom RMS.Math import vectNorm, angularSeparation, angularSeparationVect, isAngleBetween, \\\n    sphericalPointFromHeadingAndDistance, cartesianToPolar\nfrom RMS.Routines.GreatCircle import fitGreatCircle, greatCircle, greatCirclePhase\nfrom RMS.Routines.SolarLongitude import jd2SolLonSteyaert\nfrom RMS.Routines.AllskyPlot import AllSkyPlot\n    beg_azim, beg_alt = raDec2AltAz(beg_ra, beg_dec, meteor_obj.jdt_ref, meteor_obj.lat, meteor_obj.lon)\n    beg_vect_horiz = raDec2Vector(beg_azim, beg_alt)\n\n    # Compute end point vector in alt/az\n    end_ra, end_dec = vector2RaDec(meteor_obj.end_vect)\n    end_azim, end_alt = raDec2AltAz(end_ra, end_dec, meteor_obj.jdt_ref, meteor_obj.lat, meteor_obj.lon)\n    end_vect_horiz = raDec2Vector(end_azim, end_alt)\n\n    # Compute radiant vector in alt/az\n    radiant_azim, radiant_alt = raDec2AltAz(shower.ra, shower.dec, meteor_obj.jdt_ref, meteor_obj.lat, \\\n        meteor_obj.lon)\n    radiant_vector_horiz = raDec2Vector(radiant_azim, radiant_alt)\n\n\n    # Reject the pairing if the radiant is below the horizon\n    if radiant_alt < 0:\n        return -1\n\n\n    # Get distance from Earth's centre to the position given by geographical coordinates for the \n    #   observer's latitude\n    earth_radius = EARTH.EQUATORIAL_RADIUS/np.sqrt(1.0 - (EARTH.E**2)*np.sin(np.radians(config.latitude))**2)\n\n    # Compute the distance from Earth's centre to the station (including the sea level height of the station)\n    re_dist = earth_radius + config.elevation\n\n    ### ###\n\n\n    # Compute the distance the meteor traversed during its duration (meters)\n    dist = shower.v_init*meteor_obj.duration\n\n    # Compute the angle between the begin and the end point of the meteor (rad)\n    ang_beg_end = np.arccos(np.dot(vectNorm(beg_vect_horiz), vectNorm(end_vect_horiz)))\n\n    # Compute the angle between the radiant vector and the begin point (rad)\n    ang_beg_rad = np.arccos(np.dot(vectNorm(radiant_vector_horiz), -vectNorm(beg_vect_horiz)))\n\n\n    # Compute the distance from the station to the begin point (meters)\n    dist_beg = dist*np.sin(ang_beg_rad)/np.sin(ang_beg_end)\n\n\n    # Compute the height using the law of cosines\n    ht  = np.sqrt(dist_beg**2 + re_dist**2 - 2*dist_beg*re_dist*np.cos(np.radians(90 + meteor_obj.beg_alt)))\n    ht -= earth_radius\n    ht  = abs(ht)\n\n\n    return ht\n\n\n\n\ndef showerAssociation(config, ftpdetectinfo_list, shower_code=None, show_plot=False, save_plot=False, \\\n    plot_activity=False):\n    \"\"\" Do single station shower association based on radiant direction and height. \n    \n    Arguments:\n        config: [Config instance]\n        ftpdetectinfo_list: [list] A list of paths to FTPdetectinfo files.\n\n    Keyword arguments:\n        shower_code: [str] Only use this one shower for association (e.g. ETA, PER, SDA). None by default,\n            in which case all active showers will be associated.\n        show_plot: [bool] Show the plot on the screen. False by default.\n        save_plot: [bool] Save the plot in the folder with FTPdetectinfos. False by default.\n        plot_activity: [bool] Whether to plot the shower activity plot of not. False by default.\n\n    Return:\n        associations, shower_counts: [tuple]\n            - associations: [dict] A dictionary where the FF name and the meteor ordinal number on the FF\n                file are keys, and the associated Shower object are values.\n            - shower_counts: [list] A list of shower code and shower count pairs.\n    \"\"\"\n\n    # Load the list of meteor showers\n    shower_list = loadShowers(config.shower_path, config.shower_file_name)\n\n\n    # Load FTPdetectinfos\n    meteor_data = []\n    for ftpdetectinfo_path in ftpdetectinfo_list:\n\n        if not os.path.isfile(ftpdetectinfo_path):\n            print('No such file:', ftpdetectinfo_path)\n            continue\n\n        meteor_data += readFTPdetectinfo(*os.path.split(ftpdetectinfo_path))\n\n    if not len(meteor_data):\n        return {}, []\n\n\n    # Dictionary which holds FF names as keys and meteor measurements + associated showers as values\n    associations = {}\n\n    for meteor in meteor_data:\n\n        ff_name, cam_code, meteor_No, n_segments, fps, hnr, mle, binn, px_fm, rho, phi, meteor_meas = meteor\n\n        # Skip very short meteors\n        if len(meteor_meas) < 4:\n            continue\n\n        # Check if the data is calibrated\n        if not meteor_meas[0][0]:\n            print('Data is not calibrated! Meteors cannot be associated to showers!')\n            break\n\n\n        # Init container for meteor observation\n        meteor_obj = MeteorSingleStation(cam_code, config.latitude, config.longitude, ff_name)\n\n        # Infill the meteor structure\n        for entry in meteor_meas:\n            \n            calib_status, frame_n, x, y, ra, dec, azim, elev, inten, mag = entry\n\n            # Compute the Julian data of every point\n", "context": "RMS/Math.py\ndef angularSeparationVect(vect1, vect2):\n    \"\"\" Calculates angle between vectors in radians. \"\"\"\n\n    return np.abs(np.arccos(np.dot(vect1, vect2)))\nRMS/Math.py\n@np.vectorize\ndef sphericalPointFromHeadingAndDistance(ra1, dec1, heading, distance):\n    \"\"\" Given RA and Dec, a heading and angular distance, compute coordinates of the point.\n\n    Arguments:\n        ra1: [float] Right Ascension (deg).\n        dec1: [float] Declination (deg).\n        heading: [float] Heading +E of due N in degrees (deg).\n        distance: [float] Distance (deg).\n\n    Return:\n        ra, dec: [float] Coordinates of the new point (deg)\n\n    \"\"\"\n\n    ra1 = np.radians(ra1)\n    dec1 = np.radians(dec1)\n    heading = np.radians(heading)\n    distance = np.radians(distance)\n\n    # Compute the new declination\n    dec = np.arcsin(np.sin(dec1)*np.cos(distance) + np.cos(dec1)*np.sin(distance)*np.cos(heading))\n\n    # Compute the new RA\n    dra = np.arctan2(np.sin(heading)*np.sin(distance)*np.cos(dec1), np.cos(distance) \\\n        - np.sin(dec1)*np.sin(dec))\n    ra = (ra1 - dra + np.pi)%(2*np.pi) - np.pi\n\n\n    return np.degrees(ra)%360, np.degrees(dec)\nRMS/Astrometry/Conversions.py\ndef raDec2AltAz(ra, dec, jd, lat, lon):\n    \"\"\" Calculate the reference azimuth and altitude of the centre of the FOV from the given RA/Dec.\n    Arguments:\n        ra:  [float] Right ascension in degrees.\n        dec: [float] Declination in degrees.\n        jd: [float] Reference Julian date.\n        lat: [float] Latitude +N in degrees.\n        lon: [float] Longitude +E in degrees.\n    Return:\n        (azim, elev): [tuple of float]: Azimuth and elevation (degrees).\n    \"\"\"\n    ra = np.radians(ra)\n    dec = np.radians(dec)\n    lat = np.radians(lat)\n    lon = np.radians(lon)\n\n    # Compute azim and elev using a fast cython function\n    if isinstance(ra, float) or isinstance(ra, int) or isinstance(ra, np.float64):\n        azim, elev = cyraDec2AltAz(ra, dec, jd, lat, lon)\n\n    elif isinstance(ra, np.ndarray):\n        # Compute it for numpy arrays\n        azim, elev = cyraDec2AltAz_vect(ra, dec, jd, lat, lon)\n\n    else:\n        raise TypeError(\"ra must be a number or np.ndarray, given: {}\".format(type(ra)))\n\n    return np.degrees(azim), np.degrees(elev)\nRMS/Math.py\ndef angularSeparation(ra1, dec1, ra2, dec2):\n    \"\"\" Calculates the angle between two points on a sphere. \n    \n    Arguments:\n        ra1: [float] Right ascension 1 (radians).\n        dec1: [float] Declination 1 (radians).\n        ra2: [float] Right ascension 2 (radians).\n        dec2: [float] Declination 2 (radians).\n\n    Return:\n        [float] Angle between two coordinates (radians).\n    \"\"\"\n\n    # Classical method\n    return np.arccos(np.sin(dec1)*np.sin(dec2) + np.cos(dec1)*np.cos(dec2)*np.cos(ra2 - ra1))\n\n    # # Compute the angular separation using the haversine formula\n    # #   Source: https://idlastro.gsfc.nasa.gov/ftp/pro/astro/gcirc.pro\n    # deldec2 = (dec2 - dec1)/2.0\n    # delra2 =  (ra2 - ra1)/2.0\n    # sindis = np.sqrt(np.sin(deldec2)*np.sin(deldec2) \\\n    #     + np.cos(dec1)*np.cos(dec2)*np.sin(delra2)*np.sin(delra2))\n    # dis = 2.0*np.arcsin(sindis) \n\n    # return dis\nRMS/Astrometry/Conversions.py\ndef jd2Date(jd, UT_corr=0, dt_obj=False):\n    \"\"\" Converts the given Julian date to (year, month, day, hour, minute, second, millisecond) tuple.\n    Arguments:\n        jd: [float] Julian date\n    Keyword arguments:\n        UT_corr: [float] UT correction in hours (difference from local time to UT)\n        dt_obj: [bool] returns a datetime object if True. False by default.\n    Return:\n        (year, month, day, hour, minute, second, millisecond)\n    \"\"\"\n\n    dt = timedelta(days=jd)\n\n    try:\n        date = dt + JULIAN_EPOCH - J2000_JD + timedelta(hours=UT_corr)\n\n    # If the date is out of range (i.e. before year 1) use year 1. This is the limitation in the datetime\n    # library. Time handling should be switched to astropy.time\n    except OverflowError:\n        date = datetime(MINYEAR, 1, 1, 0, 0, 0)\n\n    # Return a datetime object if dt_obj == True\n    if dt_obj:\n        return date\n\n    return date.year, date.month, date.day, date.hour, date.minute, date.second, date.microsecond/1000.0\nRMS/Routines/SolarLongitude.py\ndef jd2SolLonSteyaert(jd):\n    \"\"\" Convert the given Julian date to solar longitude, J2000.0 epoch. Chris Steyaert method.\n\n    Reference: Steyaert, C. (1991). Calculating the solar longitude 2000.0. WGN, Journal of the International \n        Meteor Organization, 19, 31-34.\n\n    Arguments:\n        jd: [float] julian date\n\n    Return:\n        [float] solar longitude in radians, J2000.0 epoch\n\n    \"\"\"\n\n    # Define time constants\n    A0 = [334166, 3489, 350, 342, 314, 268, 234, 132, 127, 120, 99, 90, 86, 78, 75, 51, 49, 36, 32, 28, 27, \n        24, 21, 21, 20, 16, 13, 13]\n\n    B0 = [4.669257, 4.6261, 2.744, 2.829, 3.628, 4.418, 6.135, 0.742, 2.037, 1.110, 5.233, 2.045, 3.508, \n        1.179, 2.533, 4.58, 4.21, 2.92, 5.85, 1.90, 0.31, 0.34, 4.81, 1.87, 2.46, 0.83, 3.41, 1.08]\n\n    C0 = [6283.07585, 12566.1517, 5753.385, 3.523, 77713.771, 7860.419, 3930.210, 11506.77, 529.691, 1577.344, \n        5884.927, 26.298, 398.149, 5223.694, 5507.553, 18849.23, 775.52, 0.07, 11790.63, 796.3, 10977.08, \n        5486.78, 2544.31, 5573.14, 6069.78, 213.3, 2942.46, 20.78]\n\n    A1 = [20606, 430, 43]\n    B1 = [2.67823, 2.635, 1.59]\n    C1 = [6283.07585, 12566.152, 3.52]\n\n    A2 = [872, 29]\n    B2 = [1.073, 0.44]\n    C2 = [6283.07585, 12566.15]\n\n    A3 = 29\n    B3 = 5.84\n    C3 = 6283.07585\n\n    # Number of millennia since 2000\n    T = (jd - 2451545.0)/365250.0\n\n    # Mean solar longitude\n    L0 = 4.8950627 + 6283.07585*T - 0.0000099*T**2\n\n    # Wrap L0 to [0, 2pi] range\n    L0 = L0%(2*np.pi)\n\n    # Periodical terms\n    S0 = np.sum([A0[i]*np.cos((B0[i] + C0[i]*T)%(2*np.pi)) for i in range(28)])\n    S1 = np.sum([A1[i]*np.cos((B1[i] + C1[i]*T)%(2*np.pi)) for i in range(3)])\n    S2 = np.sum([A2[i]*np.cos((B2[i] + C2[i]*T)%(2*np.pi)) for i in range(2)])\n    S3 = A3*np.cos((B3 + C3*T)%(2*np.pi))\n\n    # Solar longitude of J2000.0\n    L = L0 + (S0 + S1*T + S2*T**2 + S3*T**3)*1e-7\n\n    # Bound to solar longitude to the [0, 2pi] range\n    L = L%(2*np.pi)\n\n    return L\nRMS/Math.py\ndef vectNorm(vect):\n    \"\"\" Convert a given vector to a unit vector. \"\"\"\n\n    return vect/vectMag(vect)\nRMS/Astrometry/Conversions.py\ndef vector2RaDec(eci):\n    \"\"\" Convert Earth-centered intertial vector to right ascension and declination.\n    Arguments:\n        eci: [3 element ndarray] Vector coordinates in Earth-centered inertial system\n    Return:\n        (ra, dec): [tuple of floats] right ascension and declinaton (degrees)\n    \"\"\"\n\n    # Normalize the ECI coordinates\n    eci = vectNorm(eci)\n\n    # Calculate declination\n    dec = np.arcsin(eci[2])\n\n    # Calculate right ascension\n    ra = np.arctan2(eci[1], eci[0])%(2*np.pi)\n\n    return np.degrees(ra), np.degrees(dec)\nRMS/Math.py\ndef cartesianToPolar(x, y, z):\n    \"\"\" Converts 3D cartesian coordinates to polar coordinates. \n\n    Arguments:\n        x: [float] Px coordinate.\n        y: [float] Py coordinate.\n        z: [float] Pz coordinate.\n\n    Return:\n        (theta, phi): [float] Polar angles in radians (inclination, azimuth).\n\n    \"\"\"\n\n    theta = np.arccos(z)\n    phi = np.arctan2(y, x)\n\n    return theta, phi\nRMS/Astrometry/Conversions.py\ndef raDec2Vector(ra, dec):\n    \"\"\" Convert stellar equatorial coordinates to a vector with X, Y and Z components.\n    @param ra: [float] right ascension in degrees\n    @param dec: [float] declination in degrees\n    @return (x, y, z): [tuple of floats]\n    \"\"\"\n\n    ra_rad = math.radians(ra)\n    dec_rad = math.radians(dec)\n\n    xt = math.cos(dec_rad)*math.cos(ra_rad)\n    yt = math.cos(dec_rad)*math.sin(ra_rad)\n    zt = math.sin(dec_rad)\n\n    return xt, yt, zt\nRMS/Formats/FFfile.py\ndef filenameToDatetime(file_name):\n    \"\"\" Converts FF bin file name to a datetime object.\n\n    Arguments:\n        file_name: [str] Name of a FF file.\n\n    Return:\n        [datetime object] Date and time of the first frame in the FF file.\n\n    \"\"\"\n\n    # e.g.  FF499_20170626_020520_353_0005120.bin\n    # or FF_CA0001_20170626_020520_353_0005120.fits\n\n    file_name = file_name.split('_')\n\n    # Check the number of list elements, and the new fits format has one more underscore\n    i = 0\n    if len(file_name[0]) == 2:\n        i = 1\n\n    date = file_name[i + 1]\n    year = int(date[:4])\n    month = int(date[4:6])\n    day = int(date[6:8])\n\n    time = file_name[i + 2]\n    hour = int(time[:2])\n    minute = int(time[2:4])\n    seconds = int(time[4:6])\n\n    ms = int(file_name[i + 3])\n\n\n    return datetime.datetime(year, month, day, hour, minute, seconds, ms*1000)\nRMS/Astrometry/Conversions.py\ndef datetime2JD(dt, UT_corr=0.0):\n    \"\"\" Converts a datetime object to Julian date.\n    Arguments:\n        dt: [datetime object]\n    Keyword arguments:\n        UT_corr: [float] UT correction in hours (difference from local time to UT)\n    Return:\n        jd: [float] Julian date\n    \"\"\"\n\n    return date2JD(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.microsecond/1000.0,\n                   UT_corr=UT_corr)\nRMS/Astrometry/Conversions.py\ndef geocentricToApparentRadiantAndVelocity(ra_g, dec_g, vg, lat, lon, elev, jd, include_rotation=True):\n    \"\"\" Converts the geocentric into apparent meteor radiant and velocity. The conversion is not perfect\n        as the zenith attraction correction should be done after the radiant has been derotated for Earth's\n        velocity, but it's precise to about 0.1 deg.\n\n    Arguments:\n        ra_g: [float] Geocentric right ascension (deg).\n        dec_g: [float] Declination (deg).\n        vg: [float] Geocentric velocity (m/s).\n        lat: [float] State vector latitude (deg)\n        lon: [float] State vector longitude (deg).\n        ele: [float] State vector elevation (meters).\n        jd: [float] Julian date.\n    Keyword arguments:\n        include_rotation: [bool] Whether the velocity should be corrected for Earth's rotation.\n            True by default.\n    Return:\n        (ra, dec, v_init): Apparent radiant (deg) and velocity (m/s).\n    \"\"\"\n\n    # Compute ECI coordinates of the meteor state vector\n    state_vector = geo2Cartesian(lat, lon, elev, jd)\n\n    eci_x, eci_y, eci_z = state_vector\n\n    # Assume that the velocity at infinity corresponds to the initial velocity\n    v_init = np.sqrt(vg**2 + (2*6.67408*5.9722)*1e13/vectMag(state_vector))\n\n    # Calculate the geocentric latitude (latitude which considers the Earth as an elipsoid) of the reference\n    # trajectory point\n    lat_geocentric = np.degrees(math.atan2(eci_z, math.sqrt(eci_x**2 + eci_y**2)))\n\n    ### Uncorrect for zenith attraction ###\n\n    # Compute the radiant in the local coordinates\n    azim, elev = raDec2AltAz(ra_g, dec_g, jd, lat_geocentric, lon)\n\n    # Compute the zenith angle\n    eta = np.radians(90.0 - elev)\n\n    # Numerically correct for zenith attraction\n    diff = 10e-5\n    zc = eta\n    while diff > 10e-6:\n        # Update the zenith distance\n        zc -= diff\n\n        # Calculate the zenith attraction correction\n        delta_zc = 2*math.atan((v_init - vg)*math.tan(zc/2.0)/(v_init + vg))\n        diff = zc + delta_zc - eta\n\n    # Compute the uncorrected geocentric radiant for zenith attraction\n    ra, dec = altAz2RADec(azim, 90.0 - np.degrees(zc), jd, lat_geocentric, lon)\n\n    ### ###\n\n    # Apply the rotation correction\n    if include_rotation:\n        # Calculate the velocity of the Earth rotation at the position of the reference trajectory point (m/s)\n        v_e = 2*math.pi*vectMag(state_vector)*math.cos(np.radians(lat_geocentric))/86164.09053\n\n        # Calculate the equatorial coordinates of east from the reference position on the trajectory\n        azimuth_east = 90.0\n        altitude_east = 0\n        ra_east, dec_east = altAz2RADec(azimuth_east, altitude_east, jd, lat, lon)\n\n        # Compute the radiant vector in ECI coordinates of the apparent radiant\n        v_ref_vect = v_init*np.array(raDec2Vector(ra, dec))\n\n        v_ref_nocorr = np.zeros(3)\n\n        # Calculate the derotated reference velocity vector/radiant\n        v_ref_nocorr[0] = v_ref_vect[0] + v_e*np.cos(np.radians(ra_east))\n        v_ref_nocorr[1] = v_ref_vect[1] + v_e*np.sin(np.radians(ra_east))\n        v_ref_nocorr[2] = v_ref_vect[2]\n\n        # Compute the radiant without Earth's rotation included\n        ra_norot, dec_norot = vector2RaDec(vectNorm(v_ref_nocorr))\n        v_init_norot = vectMag(v_ref_nocorr)\n\n        ra = ra_norot\n        dec = dec_norot\n        v_init = v_init_norot\n\n    return ra, dec, v_init\nRMS/Math.py\ndef isAngleBetween(left, ang, right):\n    \"\"\" Checks if ang is between the angle on the left and right. \n    \n    Arguments:\n        left: [float] Left (counter-clockwise) angle (radians).\n        ang: [float] Angle to check (radians),\n        right: [float] Right (clockwise) angle (radiant).\n\n    Return:\n        [bool] True if the angle is in between, false otherwise.\n    \"\"\"\n\n    if right - left < 0:\n        right = right - left + 2*np.pi\n    else:\n        right = right - left\n\n\n    if ang - left < 0:\n        ang = ang - left + 2*np.pi\n    else:\n        ang = ang - left\n\n\n    return ang < right\nRMS/Astrometry/Conversions.py\nclass EARTH_CONSTANTS(object):\n    \"\"\" Holds Earth's shape and physical parameters. \"\"\"\n\n    def __init__(self):\n\n        # Earth elipsoid parameters in meters (source: WGS84, the GPS standard)\n        self.EQUATORIAL_RADIUS = 6378137.0\n        self.POLAR_RADIUS = 6356752.314245\n        self.E = math.sqrt(1.0 - self.POLAR_RADIUS**2/self.EQUATORIAL_RADIUS**2)\n        self.RATIO = self.EQUATORIAL_RADIUS/self.POLAR_RADIUS\n        self.SQR_DIFF = self.EQUATORIAL_RADIUS**2 - self.POLAR_RADIUS**2\nRMS/Routines/AllskyPlot.py\nclass AllSkyPlot(object):\n\tdef __init__(self, ax_handle=None):\n\n\t\tself.ra0 = 180.0\n\n\n\t\tif ax_handle is None:\n\t\t\t\n\t\t\tself.fig = plt.figure()\n\t\t\tself.ax = self.fig.add_subplot(1, 1, 1, facecolor='black')\n\n\t\telse:\n\t\t\tself.ax = ax_handle\n\t\t\tself.fig = plt.gcf()\n\n\t\t# Set background color\n\t\tself.fig.patch.set_facecolor('black')\n\n\t\t# Set equal aspect ratio\n\t\tself.ax.set_aspect('equal')\n\n\t\t# # Set tick color\n\t\t# self.ax.tick_params(axis='x', colors='0.5')\n\t\t# self.ax.tick_params(axis='y', colors='0.5')\n\n\t\t# Turn off ticks\n\t\tself.ax.tick_params(labeltop=False, labelright=False, labelbottom=False, labelleft=False)\n\n\t\tself.plotGrid()\n\n\n\tdef raDec2XY(self, ra, dec):\n\n\t\t# Compute projected coordinates\n\t\tx = ((180 - ra)%360 - self.ra0)*np.cos(np.radians(dec))\n\t\ty = dec\n\n\t\treturn x, y\n\n\n\tdef plot(self, ra_array, dec_array, max_break_deg=30, **kwargs):\n\n\t\t# If there are more than one point, check for 0/360 wraparounds in RA\n\t\tif isinstance(ra_array, list) or isinstance(ra_array, np.ndarray):\n\n\t\t\tra_array = np.array(ra_array)\n\t\t\tra_array = (180 - ra_array)%360\n\t\t\tdec_array = np.array(dec_array)\n\n\t\t\tcoord_list = []\n\n\t\t\t# Find large breaks in RA and plot them separately\n\t\t\tra_diff = np.abs(ra_array[:-1] - ra_array[1:])\n\t\t\tbreak_indices = np.where(ra_diff > max_break_deg)[0]\n\n\t\t\tif not len(break_indices):\n\t\t\t\tcoord_list = [[ra_array, dec_array]]\n\n\t\t\telse:\n\t\t\t\tprev_break_idx = 0\n\t\t\t\tfor break_idx in break_indices:\n\t\t\t\t\tra_temp = ra_array[prev_break_idx:break_idx + 1]\n\t\t\t\t\tdec_temp = dec_array[prev_break_idx:break_idx + 1]\n\n\t\t\t\t\tprev_break_idx = break_idx + 1\n\n\t\t\t\t\tcoord_list.append([ra_temp, dec_temp])\n\n\t\t\t\tcoord_list.append([ra_array[break_idx + 1:], dec_array[break_idx + 1:]])\n\n\t\telse:\n\t\t\tcoord_list = [[180 - ra_array, dec_array]]\n\n\n\t\t# Plot all segments\n\t\tfor i, (ra_temp, dec_temp) in enumerate(coord_list):\n\t\t\tx, y = self.raDec2XY(180 - ra_temp, dec_temp)\n\n\t\t\t# Make sure that all plotted lines have the same color\n\t\t\tif i > 0:\n\t\t\t\tcolor = plt_handle[0].get_color()\n\n\t\t\t\t# Add color to kwargs\n\t\t\t\tif 'color' not in kwargs:\n\t\t\t\t\tkwargs['color'] = color\n\t\t\t\n\n\t\t\tplt_handle = self.ax.plot(x, y, **kwargs)\n\n\n\n\tdef scatter(self, ra_array, dec_array, **kwargs):\n\n\t\tx, y = self.raDec2XY(ra_array, dec_array)\n\t\tself.ax.scatter(x, y, **kwargs)\n\n\n\n\n\tdef plotGrid(self, step=15):\n\n\n\t\t# Plot a meridian and parallel grid\n\t\tra_grid = np.sort(np.append(np.arange(0, 360 + step, step), [180.0001]))\n\t\tdec_grid = np.arange(-90, 90 + step, step)\n\n\n\t\t# Plot meridians\n\t\tfor ra in ra_grid[:-1]:\n\n\t\t\t# Increase number of points for meridian plot so they are smoother\n\t\t\tstep_finer = step/5\n\t\t\tdec_arr = np.arange(-90, 90 + step_finer, step_finer)\n\n\t\t\tra_temp = np.zeros_like(dec_arr) + ra\n\n\t\t\tx_grid, y_grid = self.raDec2XY(ra_temp, dec_arr)\n\n\t\t\tself.ax.plot(x_grid, y_grid, linestyle='dotted', alpha=0.5, color='silver')\n\n\n\t\t# Plot parallels\n\t\tfor dec in dec_grid:\n\n\t\t\tdec_temp = np.zeros_like(ra_grid) + dec\n\n\t\t\tself.plot(ra_grid, dec_temp, linestyle='dotted', alpha=0.5, color='silver')\n\n\n\t\t# Plot dec ticks\n\t\tfor dec in dec_grid[::2]:\n\n\t\t\tx, y = self.raDec2XY(0, dec)\n\n\t\t\tif dec > 0:\n\t\t\t\tva = 'bottom'\n\n\t\t\telse:\n\t\t\t\tva = 'top'\n\n\t\t\tself.ax.text(x, y, \"{:+d}$^\\circ$\".format(dec), color='0.5', ha='center', va=va, size=7)\n\n\n\t\t# Plot every other RA tick and skip 0 and 360\n\t\tra_ticks = np.sort(np.append(np.arange(0, 360, 2*step), [180.0001]))\n\t\tfor ra in ra_ticks:\n\n\t\t\t# Offset RA so 0 starts in the middle and increases to the left\n\t\t\t#ra_text = (180 - ra)%360\n\n\t\t\tx, y = self.raDec2XY(ra, 0)\n\t\t\tself.ax.text(x, y, \"{:+d}$^\\circ$\".format(int(ra)), color='0.5', ha='center', va='top', size=7)\n\n\n\n\n\t\n\tdef beautify(self):\n\n\t\tself.ax.set_xlim([-180, 180])\n\t\tself.ax.set_ylim([-90, 90])\n\n\t\tself.fig.tight_layout()\n\n\n\tdef show(self):\n\n\t\tself.beautify()\n\t\tplt.show()\n", "answers": ["            jd = datetime2JD(filenameToDatetime(ff_name) + datetime.timedelta(seconds=float(frame_n)/fps))"], "length": 2640, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "3a25616cb5ea03ff9da80a9e67105c5d33a5d27f5481b048"}
{"input": "from collections import defaultdict\nfrom tqdm import tqdm\nfrom ..utils import (Bunch,\n                     get_excerpts,\n                     chunk_bounds,\n                     data_chunk,\n                     _concatenate,\n                     )\nfrom ..kwik.mea import (_channels_per_group,\n                        _probe_adjacency_list,\n                        )\nfrom .detect import Thresholder, compute_threshold, FloodFillDetector\nfrom .filter import Filter\nfrom .pca import PCA\nfrom .store import SpikeDetektStore\nfrom .waveform import WaveformExtractor\nimport logging\nimport numpy as np\n        # Create the return arrays.\n        groups = np.array(groups, dtype=np.int32)\n        assert groups.shape == (n_spikes,)\n        assert groups.dtype == np.int32\n\n        samples = np.array(samples, dtype=np.float64)\n        assert samples.shape == (n_spikes,)\n        assert samples.dtype == np.float64\n\n        # These are lists of arrays of various shapes (because of various\n        # groups).\n        waveforms = _array_list(waveforms)\n        assert waveforms.shape == (n_spikes,)\n        assert waveforms.dtype == np.object\n\n        masks = _array_list(masks)\n        assert masks.dtype == np.object\n        assert masks.shape == (n_spikes,)\n\n        # Reorder the spikes.\n        idx = np.argsort(samples)\n        groups = groups[idx]\n        samples = samples[idx]\n        waveforms = waveforms[idx]\n        masks = masks[idx]\n\n        # Remove spikes in the overlapping bands.\n        # WARNING: add s_start to spike_samples, because spike_samples\n        # is relative to the start of the chunk.\n        # It is important to add s_start and not keep_start, because of\n        # edge effects between overlapping chunks.\n        s_start = s_start or 0\n        (keep_start, keep_end) = keep_bounds\n        idx = _keep_spikes(samples + s_start, (keep_start, keep_end))\n\n        # Split the data according to the channel groups.\n        split = _split_spikes(groups, idx=idx, spike_samples=samples,\n                              waveforms=waveforms, masks=masks)\n        # split: {group: {'spike_samples': ..., 'waveforms':, 'masks':}}\n\n        # Assert that spike samples are increasing.\n        for group in split:\n            samples = split[group]['spike_samples']\n            if samples is not None:\n                assert np.all(np.diff(samples) >= 0)\n\n        return split\n\n    def waveform_pcs(self, waveforms, masks):\n        \"\"\"Compute waveform principal components.\n\n        Returns\n        -------\n\n        pcs : array\n            An `(n_features, n_samples, n_channels)` array.\n\n        \"\"\"\n        pca = self._create_pca()\n        if waveforms is None or not len(waveforms):\n            return\n        assert (waveforms.shape[0], waveforms.shape[2]) == masks.shape\n        return pca.fit(waveforms, masks)\n\n    def features(self, waveforms, pcs):\n        \"\"\"Extract features from waveforms.\n\n        Returns\n        -------\n\n        features : array\n            An `(n_spikes, n_channels, n_features)` array.\n\n        \"\"\"\n        pca = self._create_pca()\n        out = pca.transform(waveforms, pcs=pcs)\n        assert out.dtype == np.float32\n        return out\n\n    # Chunking\n    # -------------------------------------------------------------------------\n\n    def iter_chunks(self, n_samples):\n        \"\"\"Iterate over chunks.\"\"\"\n        rate = self._kwargs['sample_rate']\n        chunk_size = int(self._kwargs['chunk_size_seconds'] * rate)\n        overlap = int(self._kwargs['chunk_overlap_seconds'] * rate)\n        for chunk_idx, bounds in enumerate(chunk_bounds(n_samples, chunk_size,\n                                                        overlap=overlap)):\n            yield Bunch(bounds=bounds,\n                        s_start=bounds[0],\n                        s_end=bounds[1],\n                        keep_start=bounds[2],\n                        keep_end=bounds[3],\n                        keep_bounds=(bounds[2:4]),\n                        key=bounds[2],\n                        chunk_idx=chunk_idx,\n                        )\n\n    def n_chunks(self, n_samples):\n        \"\"\"Number of chunks.\"\"\"\n        return len(list(self.iter_chunks(n_samples)))\n\n    def chunk_keys(self, n_samples):\n        return [chunk.key for chunk in self.iter_chunks(n_samples)]\n\n    # Output data\n    # -------------------------------------------------------------------------\n\n    def output_data(self):\n        \"\"\"Bunch of values to be returned by the algorithm.\"\"\"\n        sc = self._store.spike_counts\n        chunk_keys = self._store.chunk_keys\n\n        # NOTE: deal with multiple recordings.\n        samples = self._store.spike_samples()\n\n        s = {}\n        r = {}\n        for group in self._groups:\n", "context": "klusta/kwik/mea.py\ndef _probe_adjacency_list(probe):\n    \"\"\"Return an adjacency list of a whole probe.\"\"\"\n    cgs = probe['channel_groups'].values()\n    graphs = [cg['graph'] for cg in cgs]\n    edges = list(itertools.chain(*graphs))\n    adjacency_list = _edges_to_adjacency_list(edges)\n    return adjacency_list\nklusta/utils.py\ndef _concatenate(arrs):\n    if arrs is None:\n        return\n    arrs = [_as_array(arr) for arr in arrs if arr is not None]\n    if not arrs:\n        return\n    return np.concatenate(arrs, axis=0)\nklusta/kwik/mea.py\ndef _channels_per_group(probe):\n    groups = probe['channel_groups'].keys()\n    return {group: probe['channel_groups'][group]['channels']\n            for group in groups}\nklusta/utils.py\ndef data_chunk(data, chunk, with_overlap=False):\n    \"\"\"Get a data chunk.\"\"\"\n    assert isinstance(chunk, tuple)\n    if len(chunk) == 2:\n        i, j = chunk\n    elif len(chunk) == 4:\n        if with_overlap:\n            i, j = chunk[:2]\n        else:\n            i, j = chunk[2:]\n    else:\n        raise ValueError(\"'chunk' should have 2 or 4 elements, \"\n                         \"not {0:d}\".format(len(chunk)))\n    return data[i:j, ...]\nklusta/traces/detect.py\nclass Thresholder(object):\n    \"\"\"Threshold traces to detect spikes.\n\n    Parameters\n    ----------\n\n    mode : str\n        `'positive'`, `'negative'`, or `'both'`.\n    thresholds : dict\n        A `{str: float}` mapping for multiple thresholds (e.g. `weak`\n        and `strong`).\n\n    Example\n    -------\n\n    ```python\n    thres = Thresholder('positive', thresholds=(.1, .2))\n    crossings = thres(traces)\n    ```\n\n    \"\"\"\n    def __init__(self,\n                 mode=None,\n                 thresholds=None,\n                 ):\n        assert mode in ('positive', 'negative', 'both')\n        if isinstance(thresholds, (float, int, np.ndarray)):\n            thresholds = {'default': thresholds}\n        if thresholds is None:\n            thresholds = {}\n        assert isinstance(thresholds, dict)\n        self._mode = mode\n        self._thresholds = thresholds\n\n    def transform(self, data):\n        \"\"\"Return `data`, `-data`, or `abs(data)` depending on the mode.\"\"\"\n        if self._mode == 'positive':\n            return data\n        elif self._mode == 'negative':\n            return -data\n        elif self._mode == 'both':\n            return np.abs(data)\n\n    def detect(self, data_t, threshold=None):\n        \"\"\"Perform the thresholding operation.\"\"\"\n        # Accept dictionary of thresholds.\n        if isinstance(threshold, (list, tuple)):\n            return {name: self(data_t, threshold=name)\n                    for name in threshold}\n        # Use the only threshold by default (if there is only one).\n        if threshold is None:\n            assert len(self._thresholds) == 1\n            threshold = list(self._thresholds.keys())[0]\n        # Fetch the threshold from its name.\n        if isinstance(threshold, string_types):\n            assert threshold in self._thresholds\n            threshold = self._thresholds[threshold]\n        # threshold = float(threshold)\n        # Threshold the data.\n        return data_t > threshold\n\n    def __call__(self, data, threshold=None):\n        # Transform the data according to the mode.\n        data_t = self.transform(data)\n        return self.detect(data_t, threshold=threshold)\nklusta/traces/store.py\nclass SpikeDetektStore(ArrayStore):\n    \"\"\"Store the following items:\n\n    * filtered\n    * components\n    * spike_samples\n    * features\n    * masks\n\n    \"\"\"\n    def __init__(self, root_dir, groups=None, chunk_keys=None):\n        super(SpikeDetektStore, self).__init__(root_dir)\n        self._groups = groups\n        self._chunk_keys = chunk_keys\n        self._spike_counts = SpikeCounts(groups=groups, chunk_keys=chunk_keys)\n\n    def _rel_path(self, name=None, chunk_key=None, group=None):\n        assert chunk_key >= 0\n        assert group is None or group >= 0\n        assert isinstance(name, string_types)\n        group = group if group is not None else 'all'\n        return 'group_{group}/{name}/chunk_{chunk:d}.npy'.format(\n            chunk=chunk_key, name=name, group=group)\n\n    @property\n    def groups(self):\n        return self._groups\n\n    @property\n    def chunk_keys(self):\n        return self._chunk_keys\n\n    def _iter(self, group=None, name=None):\n        for chunk_key in self.chunk_keys:\n            yield self.load(group=group, chunk_key=chunk_key, name=name)\n\n    def spike_samples(self, group=None):\n        if group is None:\n            return {group: self.spike_samples(group) for group in self._groups}\n        return self.concatenate(self._iter(group=group, name='spike_samples'))\n\n    def features(self, group=None):\n        \"\"\"Yield chunk features.\"\"\"\n        if group is None:\n            return {group: self.features(group) for group in self._groups}\n        return self._iter(group=group, name='features')\n\n    def masks(self, group=None):\n        \"\"\"Yield chunk masks.\"\"\"\n        if group is None:\n            return {group: self.masks(group) for group in self._groups}\n        return self._iter(group=group, name='masks')\n\n    @property\n    def spike_counts(self):\n        return self._spike_counts\n\n    def append(self, group=None, chunk_key=None,\n               spike_samples=None, features=None, masks=None,\n               spike_offset=0):\n        if spike_samples is None or len(spike_samples) == 0:\n            return\n        n = len(spike_samples)\n        assert features.shape[0] == n\n        assert masks.shape[0] == n\n        spike_samples = spike_samples + spike_offset\n        assert np.all(np.diff(spike_samples) >= 0)\n\n        self.store(group=group, chunk_key=chunk_key,\n                   name='features', data=features)\n        self.store(group=group, chunk_key=chunk_key,\n                   name='masks', data=masks)\n        self.store(group=group, chunk_key=chunk_key,\n                   name='spike_samples', data=spike_samples)\n        self._spike_counts.append(group=group, chunk_key=chunk_key, count=n)\n\n    def concatenate(self, arrays):\n        return _concatenate(arrays)\n\n    def delete_all(self, name):\n        \"\"\"Delete all files for a given data name.\"\"\"\n        for group in self._groups:\n            for chunk_key in self._chunk_keys:\n                super(SpikeDetektStore, self).delete(name=name, group=group,\n                                                     chunk_key=chunk_key)\nklusta/utils.py\nclass Bunch(dict):\n    \"\"\"A dict with additional dot syntax.\"\"\"\n    def __init__(self, *args, **kwargs):\n        super(Bunch, self).__init__(*args, **kwargs)\n        self.__dict__ = self\n\n    def copy(self):\n        return Bunch(super(Bunch, self).copy())\nklusta/utils.py\ndef chunk_bounds(n_samples, chunk_size, overlap=0):\n    \"\"\"Return chunk bounds.\n    Chunks have the form:\n        [ overlap/2 | chunk_size-overlap | overlap/2 ]\n        s_start   keep_start           keep_end     s_end\n    Except for the first and last chunks which do not have a left/right\n    overlap.\n    This generator yields (s_start, s_end, keep_start, keep_end).\n    \"\"\"\n    s_start = 0\n    s_end = chunk_size\n    keep_start = s_start\n    keep_end = s_end - overlap // 2\n    yield s_start, s_end, keep_start, keep_end\n\n    while s_end - overlap + chunk_size < n_samples:\n        s_start = s_end - overlap\n        s_end = s_start + chunk_size\n        keep_start = keep_end\n        keep_end = s_end - overlap // 2\n        if s_start < s_end:\n            yield s_start, s_end, keep_start, keep_end\n\n    s_start = s_end - overlap\n    s_end = n_samples\n    keep_start = keep_end\n    keep_end = s_end\n    if s_start < s_end:\n        yield s_start, s_end, keep_start, keep_end\nklusta/traces/filter.py\nclass Filter(object):\n    \"\"\"Multichannel bandpass filter.\n\n    The filter is applied on every column of a 2D array.\n\n    Example\n    -------\n\n    ```python\n    fil = Filter(rate=20000., low=5000., high=15000., order=4)\n    traces_f = fil(traces)\n    ```\n\n    \"\"\"\n    def __init__(self, rate=None, low=None, high=None, order=None):\n        self._filter = bandpass_filter(rate=rate,\n                                       low=low,\n                                       high=high,\n                                       order=order,\n                                       )\n\n    def __call__(self, data):\n        return apply_filter(data, filter=self._filter)\nklusta/traces/detect.py\ndef compute_threshold(arr, single_threshold=True, std_factor=None):\n    \"\"\"Compute the threshold(s) of filtered traces.\n\n    Parameters\n    ----------\n\n    arr : ndarray\n        Filtered traces, shape `(n_samples, n_channels)`.\n    single_threshold : bool\n        Whether there should be a unique threshold for all channels, or\n        one threshold per channel.\n    std_factor : float or 2-tuple\n        The threshold in unit of signal std. Two values can be specified\n        for multiple thresholds (weak and strong).\n\n    Returns\n    -------\n\n    thresholds : ndarray\n        A `(2,)` or `(2, n_channels)` array with the thresholds.\n\n    \"\"\"\n    assert arr.ndim == 2\n    ns, nc = arr.shape\n\n    assert std_factor is not None\n    if isinstance(std_factor, (int, float)):\n        std_factor = (std_factor, std_factor)\n    assert isinstance(std_factor, (tuple, list))\n    assert len(std_factor) == 2\n    std_factor = np.array(std_factor)\n\n    if not single_threshold:\n        std_factor = std_factor[:, None]\n\n    # Get the median of all samples in all excerpts, on all channels.\n    if single_threshold:\n        median = np.median(np.abs(arr))\n    # Or independently for each channel.\n    else:\n        median = np.median(np.abs(arr), axis=0)\n\n    # Compute the threshold from the median.\n    std = median / .6745\n    threshold = std_factor * std\n    assert isinstance(threshold, np.ndarray)\n\n    if single_threshold:\n        assert threshold.ndim == 1\n        assert len(threshold) == 2\n    else:\n        assert threshold.ndim == 2\n        assert threshold.shape == (2, nc)\n    return threshold\nklusta/traces/waveform.py\nclass WaveformExtractor(object):\n    \"\"\"Extract waveforms after data filtering and spike detection.\"\"\"\n    def __init__(self,\n                 extract_before=None,\n                 extract_after=None,\n                 weight_power=None,\n                 thresholds=None,\n                 channels_per_group=None,\n                 ):\n        self._extract_before = extract_before\n        self._extract_after = extract_after\n        self._weight_power = weight_power if weight_power is not None else 1.\n        self._thresholds = thresholds or {}\n        self._channels_per_group = channels_per_group\n        # mapping channel => channels in the shank\n        self._dep_channels = {i: channels\n                              for channels in channels_per_group.values()\n                              for i in channels}\n        self._channel_groups = {i: g\n                                for g, channels in channels_per_group.items()\n                                for i in channels}\n\n    def _component(self, component, data=None, n_samples=None):\n        comp_s = component[:, 0]  # shape: (component_size,)\n        comp_ch = component[:, 1]  # shape: (component_size,)\n        channel = comp_ch[0]\n        if channel not in self._dep_channels:\n            raise RuntimeError(\"Channel `{}` appears to be dead and should \"\n                               \"have been excluded from the threshold \"\n                               \"crossings.\".format(channel))\n        channels = self._dep_channels[channel]\n        group = self._channel_groups[comp_ch[0]]\n\n        # Get the temporal window around the waveform.\n        s_min, s_max = (comp_s.min() - 3), (comp_s.max() + 4)\n        s_min = max(s_min, 0)\n        s_max = min(s_max, n_samples)\n        assert s_min < s_max\n\n        return Bunch(comp_s=comp_s,\n                     comp_ch=comp_ch,\n                     s_min=s_min,\n                     s_max=s_max,\n                     channels=channels,\n                     group=group,\n                     )\n\n    def _normalize(self, x):\n        x = np.asarray(x)\n        tw = self._thresholds['weak']\n        ts = self._thresholds['strong']\n        return np.clip((x - tw) / (ts - tw), 0, 1)\n\n    def _comp_wave(self, data_t, comp):\n        comp_s, comp_ch = comp.comp_s, comp.comp_ch\n        s_min, s_max = comp.s_min, comp.s_max\n        nc = data_t.shape[1]\n        # Data on weak threshold crossings. shape: (some_length, nc)\n        wave = np.zeros((s_max - s_min, nc), dtype=data_t.dtype)\n        # The sample where the peak is reached, on each channel.\n        wave[comp_s - s_min, comp_ch] = data_t[comp_s, comp_ch]\n        return wave\n\n    def masks(self, data_t, wave, comp):\n        nc = data_t.shape[1]\n        channels = comp.channels\n        comp_ch = comp.comp_ch\n        s_min = comp.s_min\n\n        # Binary mask. shape: (nc,)\n        masks_bin = np.zeros(nc, dtype=np.bool)\n        masks_bin[np.unique(comp_ch)] = 1\n\n        # Find the peaks (relative to the start of the chunk). shape: (nc,)\n        peaks = np.argmax(wave, axis=0) + s_min\n        # Peak values on each channel. shape: (nc,)\n        peaks_values = data_t[peaks, np.arange(0, nc)] * masks_bin\n\n        # Compute the float masks.\n        masks_float = self._normalize(peaks_values)\n        # Keep shank channels.\n        masks_float = masks_float[channels]\n        return masks_float\n\n    def spike_sample_aligned(self, wave, comp):\n        s_min, s_max = comp.s_min, comp.s_max\n        # Compute the fractional peak.\n        wave_n = self._normalize(wave)\n        wave_n_p = np.power(wave_n, self._weight_power)\n        u = np.arange(s_max - s_min)[:, np.newaxis]\n        # Spike aligned time relative to the start of the chunk.\n        s_aligned = np.sum(wave_n_p * u) / np.sum(wave_n_p) + s_min\n        return s_aligned\n\n    def extract(self, data, s_aligned, channels=None):\n        s = int(s_aligned)\n        # Get block of given size around peak sample.\n        waveform = _get_padded(data,\n                               s - self._extract_before - 1,\n                               s + self._extract_after + 2)\n        return waveform[:, channels]  # Keep shank channels.\n\n    def align(self, waveform, s_aligned):\n        s = int(s_aligned)\n        sb, sa = self._extract_before, self._extract_after\n        # Perform interpolation around the fractional peak.\n        old_s = np.arange(s - sb - 1, s + sa + 2)\n        new_s = np.arange(s - sb + 0, s + sa + 0) + (s_aligned - s)\n        try:\n            f = interp1d(old_s, waveform, bounds_error=True,\n                         kind='cubic', axis=0)\n        except ValueError:\n            logger.warn(\"Interpolation error at time {0:d}\".format(s))\n            return waveform\n        return f(new_s)\n\n    def set_thresholds(self, **kwargs):\n        self._thresholds.update(kwargs)\n\n    def __call__(self, component=None, data=None, data_t=None):\n        assert data.shape == data_t.shape\n        comp = self._component(component,\n                               data=data,\n                               n_samples=data_t.shape[0],\n                               )\n        channels = comp.channels\n\n        wave = self._comp_wave(data_t, comp)\n        masks = self.masks(data_t, wave, comp)\n        s_aligned = self.spike_sample_aligned(wave, comp)\n\n        waveform_unaligned = self.extract(data, s_aligned, channels=channels)\n        waveform_aligned = self.align(waveform_unaligned, s_aligned)\n\n        assert waveform_aligned.ndim == 2\n        assert masks.ndim == 1\n        assert waveform_aligned.shape[1] == masks.shape[0]\n\n        return comp.group, s_aligned, waveform_aligned, masks\nklusta/utils.py\ndef get_excerpts(data, n_excerpts=None, excerpt_size=None):\n    assert n_excerpts is not None\n    assert excerpt_size is not None\n    if len(data) < n_excerpts * excerpt_size:\n        return data\n    elif n_excerpts == 0:\n        return data[:0]\n    elif n_excerpts == 1:\n        return data[:excerpt_size]\n    out = np.concatenate([data_chunk(data, chunk)\n                          for chunk in excerpts(len(data),\n                                                n_excerpts=n_excerpts,\n                                                excerpt_size=excerpt_size)])\n    assert len(out) <= n_excerpts * excerpt_size\n    return out\nklusta/traces/pca.py\nclass PCA(object):\n    \"\"\"Apply PCA to waveforms.\"\"\"\n    def __init__(self, n_pcs=None):\n        self._n_pcs = n_pcs\n        self._pcs = None\n\n    def fit(self, waveforms, masks=None):\n        \"\"\"Compute the PCs of waveforms.\n\n        Parameters\n        ----------\n\n        waveforms : ndarray\n            Shape: `(n_spikes, n_samples, n_channels)`\n        masks : ndarray\n            Shape: `(n_spikes, n_channels)`\n\n        \"\"\"\n        self._pcs = _compute_pcs(waveforms, n_pcs=self._n_pcs, masks=masks)\n        return self._pcs\n\n    def transform(self, waveforms, pcs=None):\n        \"\"\"Project waveforms on the PCs.\n\n        Parameters\n        ----------\n\n        waveforms : ndarray\n            Shape: `(n_spikes, n_samples, n_channels)`\n\n        \"\"\"\n        if pcs is None:\n            pcs = self._pcs\n        # Need to call fit() if the pcs are None here.\n        if pcs is not None:\n            return _project_pcs(waveforms, pcs)\nklusta/traces/detect.py\nclass FloodFillDetector(object):\n    \"\"\"Detect spikes in weak and strong threshold crossings.\n\n    Parameters\n    ----------\n\n    probe_adjacency_list : dict\n        A dict `{channel: [neighbors]}`.\n    join_size : int\n        The number of samples defining the tolerance in time for\n        finding connected components\n\n    Example\n    -------\n\n    ```python\n    det = FloodFillDetector(probe_adjacency_list=...,\n                            join_size=...)\n    components = det(weak_crossings, strong_crossings)\n    ```\n\n    `components` is a list of `(n, 2)` int arrays with the sample and channel\n    for every sample in the component.\n\n    \"\"\"\n    def __init__(self, probe_adjacency_list=None, join_size=None,\n                 channels_per_group=None):\n        self._adjacency_list = probe_adjacency_list\n        self._join_size = join_size\n        self._channels_per_group = channels_per_group\n\n    def __call__(self, weak_crossings=None, strong_crossings=None):\n        weak_crossings = np.asarray(weak_crossings, np.bool)\n        strong_crossings = np.asarray(strong_crossings, np.bool)\n        all_channels = sorted([item for sublist\n                              in self._channels_per_group.values()\n                              for item in sublist])\n\n        cc = connected_components(weak_crossings=weak_crossings,\n                                  strong_crossings=strong_crossings,\n                                  probe_adjacency_list=self._adjacency_list,\n                                  channels=all_channels,\n                                  join_size=self._join_size,\n                                  )\n        # cc is a list of list of pairs (sample, channel)\n        return [np.array(c) for c in cc]\n", "answers": ["            spikes = _concatenate(samples[group])"], "length": 2166, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "e8ad768522188255a99ba4610f9077423b54dc653a1b122c"}
{"input": "import numpy as np\nimport nibabel as nib\nimport argparse as ap\nimport matplotlib.pyplot as plt\nfrom tfce_mediation.pyfunc import convert_mni_object, convert_fs, convert_gifti, convert_ply, convert_fslabel, save_waveform, save_stl, save_fs, save_ply, convert_redtoyellow, convert_bluetolightblue, convert_mpl_colormaps, convert_fsannot, convert_voxel\nfrom tfce_mediation.tm_io import savemgh_v2\n\t\thelp=\"Input a gifti surface file (e.g., --i_gifti average.surf.gii)\", \n\t\tnargs=1, \n\t\tmetavar=('*.surf.gii'))\n\tigroup.add_argument(\"-i_mni\", \"--inputmniobj\",\n\t\thelp=\"Input a MNI object file (e.g., --i_mni l_hemi.obj)\", \n\t\tnargs=1, \n\t\tmetavar=('*.obj'))\n\tigroup.add_argument(\"-i_ply\", \"--inputply\",\n\t\thelp=\"Input a MNI object file (e.g., --i_ply l_hemi.ply). Note, vertex colors will be stripped.\", \n\t\tnargs=1, \n\t\tmetavar=('*.ply'))\n\t# voxel to surface conversion\n\tigroup.add_argument(\"-i_voxel\", \"--inputvoxel\",\n\t\thelp=\"Input a voxel (nifti, minc, mgh). e.g. -i_voxel tstat_pFWER_corr.nii.gz\", \n\t\tnargs=1)\n\tap.add_argument(\"-vol\", \"--specifyvolume\",\n\t\thelp=\"Specify volume if -i_voxel is 4D (the first volume is 0)\", \n\t\tnargs=1)\n\tap.add_argument(\"-vt\", \"--voxelthreshold\",\n\t\thelp=\"Apply a threshold to -i_voxel image (zeros everything below value). e.g. -vt 0.95\", \n\t\tnargs=1)\n\tap.add_argument(\"-vb\", \"--voxelbackbone\",\n\t\thelp=\"Add binary mask backbone to the voxel image. e.g. -vb binary_mask_skeleton.nii.gz\", \n\t\tnargs=1)\n\tap.add_argument(\"-vp\", \"--paintvoxelsurface\",\n\t\thelp=\"Must be used with -i_voxel and -o_ply options. Input the sigificance threshold (low and high), and either: red-yellow (r_y), blue-lightblue (b_lb) or any matplotlib colorschemes (https://matplotlib.org/examples/color/colormaps_reference.html). Note, thresholds must be postive. e.g., -vp 0.95 1 r_y\", \n\t\tnargs=3, \n\t\tmetavar=('float','float', 'colormap'))\n\tap.add_argument(\"-ov_mgh\", \"--outputvoxelsurfmgh\",\n\t\thelp=\"Output a mgh file of the surface. This is only useful for visualization purposes.\", \n\t\tnargs=1)\n\n\togroup = ap.add_mutually_exclusive_group(required=True)\n\togroup.add_argument(\"-o_fs\", \"--outputfreesurfer\",\n\t\thelp=\"Output file name for freesurfer surface (e.g., -o_fs lh.32k.midthickness)\", \n\t\tnargs=1, \n\t\tmetavar=('*'))\n\togroup.add_argument(\"-o_obj\", \"--outputwaveform\",\n\t\thelp=\"Output file name for waveform object file for visualization with blender (or any other 3D viewer). This is NOT an MNI object file.\", \n\t\tnargs=1, \n\t\tmetavar=('*'))\n\togroup.add_argument(\"-o_stl\", \"--outputstl\",\n\t\thelp=\"Output file name for STereoLithography (STL) object file for visualization with blender (or any other 3D viewer).\", \n\t\tnargs=1, \n\t\tmetavar=('*'))\n\togroup.add_argument(\"-o_ply\", \"--outputply\",\n\t\thelp=\"Output file name for Polygon File Format (PYL) object file for visualization with blender (or any other 3D viewer).\", \n\t\tnargs=1, \n\t\tmetavar=('*'))\n\n\tap.add_argument(\"-p\", \"--paintsurface\",\n\t\thelp=\"Projects surface file onto a ply mesh for visualization of results using a 3D viewer. Must be used with -o_ply option. Input the surface file (*.mgh), the sigificance threshold (low and high), and either: red-yellow (r_y), blue-lightblue (b_lb) or any matplotlib colorschemes (https://matplotlib.org/examples/color/colormaps_reference.html). Note, thresholds must be postive. e.g., -p image.mgh 0.95 1 r_y\", \n\t\tnargs=4, \n\t\tmetavar=('*.mgh','float','float', 'colormap'))\n\tap.add_argument(\"-s\", \"--paintsecondsurface\",\n\t\thelp=\"Projects a second surface file onto a ply mesh for visualization of resutls using a 3D viewer. Must be used with -o_ply and -p options. Input the surface file (*.mgh), the sigificance threshold (low and high), and either: red-yellow (r_y), blue-lightblue (b_lb) or any matplotlib colorschemes (https://matplotlib.org/examples/color/colormaps_reference.html). Note, thresholds must be postive. e.g., -s negimage.mgh 0.95 1 b_lb\", \n\t\tnargs=4, \n\t\tmetavar=('*.mgh','float','float', 'colormap'))\n\n\tap.add_argument(\"-l\", \"--paintfslabel\",\n\t\thelp=\"Projects freesurface label file onto a ply mesh for visualization of resutls using a 3D viewer. Must be used with -o_ply option. Input the label (*.label or *.label-????) and either: red-yellow (r_y), blue-lightblue (b_lb) or any matplotlib colorschemes (https://matplotlib.org/examples/color/colormaps_reference.html). More than one label can be included. e.g. -l label1.label rainbow label2.label Reds\", \n\t\tnargs='+', \n\t\tmetavar=('*.label colormap'))\n\tap.add_argument(\"-a\", \"--paintfsannot\",\n\t\thelp=\"Projects freesurface annotation file onto a ply mesh for visualization of resutls using a 3D viewer. Must be used with -o_ply option. The legend is outputed\", \n\t\tnargs=1, \n\t\tmetavar=('*.annot'))\n\n\n\treturn ap\n\ndef run(opts):\n\t#input\n\tif opts.inputfreesurfer:\n\t\tv,f = convert_fs(str(opts.inputfreesurfer[0]))\n\tif opts.inputgifti:\n\t\tv,f = convert_gifti(str(opts.inputgifti[0]))\n\tif opts.inputmniobj:\n\t\tv,f = convert_mni_object(str(opts.inputmniobj[0]))\n\tif opts.inputply:\n\t\tv,f,_ = convert_ply(str(opts.inputply[0]))\n\tif opts.inputvoxel:\n\t\timg = nib.load(opts.inputvoxel[0])\n\t\timg_data = img.get_data()\n\t\tif img_data.ndim > 3:\n\t\t\tif opts.specifyvolume:\n\t\t\t\timg_data = img_data[:,:,:,int(opts.specifyvolume[0])]\n\t\t\telse:\n\t\t\t\tprint(\"Error: -i_voxel is a 4D image. Use -vol to specify the volume of interest.\")\n\t\t\t\tquit()\n\t\tif opts.voxelthreshold and opts.voxelbackbone:\n\t\t\tmask = nib.load(opts.voxelbackbone[0]).get_data()\n\t\t\tv,f,values = convert_voxel(img_data, affine = img.affine, threshold = float(opts.voxelthreshold[0]), data_mask = mask)\n\t\telif opts.voxelthreshold:\n\t\t\tv,f,values = convert_voxel(img_data, affine = img.affine, threshold = float(opts.voxelthreshold[0]))\n\t\telif opts.voxelbackbone: \n\t\t\tmask = nib.load(opts.voxelbackbone[0]).get_data()\n\t\t\tv,f,values = convert_voxel(img_data, affine = img.affine, data_mask = mask)\n\t\telse:\n\t\t\tv,f,values = convert_voxel(img_data, affine = img.affine)\n\t#output\n\tif opts.outputfreesurfer:\n\t\tsave_fs(v,f, opts.outputfreesurfer[0])\n\tif opts.outputwaveform:\n\t\tsave_waveform(v,f, opts.outputwaveform[0])\n\tif opts.outputstl:\n\t\tsave_stl(v,f, opts.outputstl[0])\n\tif opts.outputply:\n\t\t# get the matplotlib colormaps\n\t\tcolormaps = np.array(plt.colormaps(),dtype=np.str)\n\t\tif opts.paintsurface:\n\t\t\timg = nib.load(opts.paintsurface[0])\n\t\t\timg_data = img.get_data()\n\t\t\tif img_data.ndim > 3:\n\t\t\t\tprint(\"Error: input file can only contain one subject\")\n\t\t\t\tquit()\n\t\t\timg_data = img_data[:,0,0]\n\t\t\tif (str(opts.paintsurface[3]) == 'r_y') or (str(opts.paintsurface[3]) == 'red-yellow'):\n\t\t\t\tout_color_array = convert_redtoyellow(np.array(( float(opts.paintsurface[1]),float(opts.paintsurface[2]) )), img_data)\n\t\t\telif (str(opts.paintsurface[3]) == 'b_lb') or (str(opts.paintsurface[3]) == 'blue-lightblue'):\n", "context": "tfce_mediation/pyfunc.py\ndef convert_bluetolightblue(threshold, img_data, baseColour=[227,218,201], save_colorbar = True):\n\tcolor_array = np.zeros((img_data.shape[0],3))\n\tcolor_cutoffs = np.linspace(threshold[0],threshold[1],256)\n\tcolored_img_data = np.zeros_like(img_data)\n\tcV=0\n\tfor k in img_data:\n\t\tcolored_img_data[cV] = np.searchsorted(color_cutoffs, k, side=\"left\")\n\t\tcV+=1\n\tcolor_array[:,1]=np.copy(colored_img_data)\n\tcolor_array[:,2]=255\n\tcolor_array[img_data<threshold[0]] = baseColour\n\tcolor_array[img_data>threshold[1]] = [0,255,255]\n\n\tcmap_name = 'blue_lightblue'\n\tcmap_array = np.array(( np.zeros(256), np.linspace(0,255,256), (np.ones(256)*255))).T\n\tblb_cmap = colors.ListedColormap(cmap_array/255)\n\tif save_colorbar:\n\t\twrite_colorbar(threshold, blb_cmap, cmap_name, 'png')\n\t\tplt.clf()\n\treturn color_array\ntfce_mediation/pyfunc.py\ndef save_waveform(v,f, outname):\n\tif not outname.endswith('obj'):\n\t\toutname += '.obj'\n\toutname=check_outname(outname)\n\twith open(outname, \"a\") as o:\n\t\tfor i in range(len(v)):\n\t\t\to.write(\"v %1.6f %1.6f %1.6f\\n\" % (v[i,0],v[i,1], v[i,2]) )\n\t\tfor j in range(len(f)):\n\t\t\to.write(\"f %d %d %d\\n\" % (f[j,0],f[j,1], f[j,2]) )\n\t\to.close()\ntfce_mediation/pyfunc.py\ndef convert_ply(name_ply):\n\telement = []\n\tsize = []\n\tvertex_info = []\n\tvertex_dtype = []\n\tface_dtype = []\n\tface_info = []\n\tvertex_property = 0\n\tface_property = 0\n\tply_ascii = False\n\n\tobj = open(name_ply)\n\treader = obj.readline().strip().split()\n\tfirstword = reader[0]\n\n\t# READ HEADER\n\twhile firstword != 'end_header':\n\t\treader = obj.readline().strip().split()\n\t\tfirstword = reader[0]\n\t\tif firstword == 'format':\n\t\t\tply_format = reader[1]\n\t\t\tif ply_format == 'binary_little_endian':\n\t\t\t\tply_format = '<'\n\t\t\telif ply_format == 'binary_big_endian':\n\t\t\t\tply_format = '>'\n\t\t\telse:\n\t\t\t\tply_ascii = True\n\t\tif firstword == 'element':\n\t\t\telement.append((reader[1]))\n\t\t\tsize.append((reader[2]))\n\t\t\tif reader[1] == 'vertex':\n\t\t\t\tvertex_property = 1\n\t\t\telse:\n\t\t\t\tvertex_property = 0\n\t\t\tif reader[1] == 'face':\n\t\t\t\tface_property = 1\n\t\t\telse:\n\t\t\t\tface_property = 0\n\t\tif reader[0] == 'property':\n\t\t\tif vertex_property == 1:\n\t\t\t\tvertex_dtype.append((reader[1]))\n\t\t\t\tvertex_info.append((reader[2]))\n\t\t\telif face_property == 1:\n\t\t\t\tface_dtype.append((reader[2]))\n\t\t\t\tface_dtype.append((reader[3]))\n\t\t\t\tface_info.append((reader[4]))\n\t\t\telse:\n\t\t\t\tprint(\"Unknown property\")\n\n\t# READ ELEMENTS\n\tfor e in range(len(element)):\n\t\t# VERTEX DATA\n\t\tif element[e] == 'vertex':\n\t\t\tv = np.zeros((int(size[e]), 3), dtype=np.float32)\n\t\t\tc = np.zeros((int(size[e]), 3), dtype=np.uint8)\n\t\t\tif ply_ascii:\n\t\t\t\tfor i in range(int(size[e])):\n\t\t\t\t\treader = obj.readline().strip().split()\n\t\t\t\t\tv[i, 0] = np.array(reader[0]).astype(np.float)\n\t\t\t\t\tv[i, 1] = np.array(reader[1]).astype(np.float)\n\t\t\t\t\tv[i, 2] = np.array(reader[2]).astype(np.float)\n\t\t\t\t\tif len(vertex_info) == 6:\n\t\t\t\t\t\tc[i, 0] = np.array(reader[3]).astype(np.uint8)\n\t\t\t\t\t\tc[i, 1] = np.array(reader[4]).astype(np.uint8)\n\t\t\t\t\t\tc[i, 2] = np.array(reader[5]).astype(np.uint8)\n\t\t\telse:\n\t\t\t\tstruct_fmt = ply_format\n\t\t\t\tfor i in range(len(vertex_dtype)):\n\t\t\t\t\tif vertex_dtype[i] == 'float':\n\t\t\t\t\t\tstruct_fmt += 'f'\n\t\t\t\t\tif vertex_dtype[i] == 'uchar':\n\t\t\t\t\t\tstruct_fmt += 'B'\n\t\t\t\t\tif vertex_dtype[i] == 'int':\n\t\t\t\t\t\tstruct_fmt += 'i'\n\t\t\t\tstruct_len = struct.calcsize(struct_fmt)\n\t\t\t\tstruct_unpack = struct.Struct(struct_fmt).unpack_from\n\t\t\t\tvcounter = 0\n\t\t\t\twhile vcounter != int(size[e]):\n\t\t\t\t\tif len(vertex_dtype) > 3:\n\t\t\t\t\t\ts = struct_unpack(obj.read(struct_len))\n\t\t\t\t\t\tv[vcounter] = s[:3]\n\t\t\t\t\t\tc[vcounter] = s[3:]\n\t\t\t\t\t\tvcounter += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\ts = struct_unpack(obj.read(struct_len))\n\t\t\t\t\t\tv[vcounter] = s[:3]\n\t\t\t\t\t\tvcounter += 1\n\t\t# FACE DATA\n\t\tif element[e] == 'face':\n\t\t\tif ply_ascii:\n\t\t\t\treader = obj.readline().strip().split()\n\t\t\t\tnumf = int(reader[0])\n\t\t\t\tf = np.zeros((int(size[e]), numf), dtype=np.int32)\n\t\t\t\tf[0] = reader[1:]\n\t\t\t\tfcounter = 1\n\t\t\t\twhile fcounter != int(size[e]):\n\t\t\t\t\treader = obj.readline().strip().split()\n\t\t\t\t\tf[fcounter] = reader[1:]\n\t\t\t\t\tfcounter += 1\n\t\t\telse:\n\t\t\t\tif face_dtype[0] == 'uchar':\n\t\t\t\t\tfcounter = 0\n\t\t\t\t\twhile fcounter != int(size[e]):\n\t\t\t\t\t\tstruct_unpack = struct.Struct(ply_format + 'B').unpack_from\n\t\t\t\t\t\tnumf = struct_unpack(obj.read(1))[0]\n\t\t\t\t\t\t# creates empty face array if it doesn't exists\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tf\n\t\t\t\t\t\texcept NameError:\n\t\t\t\t\t\t\tf = np.zeros((int(size[e]), numf), dtype=np.int32)\n\t\t\t\t\t\tstruct_fmt = ply_format\n\t\t\t\t\t\tfor i in range(int(numf)):\n\t\t\t\t\t\t\tstruct_fmt += 'i'\n\t\t\t\t\t\tstruct_len = struct.calcsize(struct_fmt)\n\t\t\t\t\t\tstruct_unpack = struct.Struct(struct_fmt).unpack_from\n\t\t\t\t\t\ts = struct_unpack(obj.read(struct_len))\n\t\t\t\t\t\tf[fcounter] = s\n\t\t\t\t\t\tfcounter += 1\n\treturn (v, f, c)\ntfce_mediation/pyfunc.py\ndef convert_fsannot(annot_name):\n\tlabels, ctab, names  = nib.freesurfer.read_annot(annot_name)\n\tlabels[labels==-1] = 0 # why is this necessary?????\n\tcolor_array = ctab[labels]\n\tcolor_array = color_array[:,:3]\n\twrite_annot_legend(ctab, names, annot_name)\n\treturn color_array\ntfce_mediation/pyfunc.py\ndef save_stl(v,f, outname):\n\tif not outname.endswith('stl'):\n\t\toutname += '.stl'\n\toutname=check_outname(outname)\n\tv = np.array(v, dtype=np.float32, order = \"C\")\n\tf = np.array(f, dtype=np.int32, order = \"C\")\n\ttris = v[f]\n\tn = np.cross( tris[::,1 ] - tris[::,0]  , tris[::,2 ] - tris[::,0] )\n\tn = normalize_v3(n)\n\twith open(outname, \"a\") as o:\n\t\to.write(\"solid surface\\n\")\n\t\tfor i in range(tris.shape[0]):\n\t\t\to.write(\"facet normal %1.6f %1.6f %1.6f\\n\"% (n[i,0],n[i,0],n[i,0]))\n\t\t\to.write(\"outer loop\\n\")\n\t\t\to.write(\"vertex %1.6f %1.6f %1.6f\\n\" % (tris[i,0,0],tris[i,0,1],tris[i,0,2]))\n\t\t\to.write(\"vertex %1.6f %1.6f %1.6f\\n\" % (tris[i,1,0],tris[i,1,1],tris[i,1,2]))\n\t\t\to.write(\"vertex %1.6f %1.6f %1.6f\\n\" % (tris[i,2,0],tris[i,2,1],tris[i,2,2]))\n\t\t\to.write(\"endloop\\n\")\n\t\t\to.write(\"endfacet\\n\")\n\t\to.write(\"endfacet\\n\")\n\t\to.close()\ntfce_mediation/pyfunc.py\ndef convert_voxel(img_data, affine = None, threshold = None, data_mask = None, absthreshold = None):\n\t\"\"\"\n\tConverts a voxel image to a surface including outputs voxel values to paint vertex surface.\n\t\n\tParameters\n\t----------\n\timg_data : array\n\t\timage array\n\taffine : array\n\t\t affine [4x4] to convert vertices values to native space (Default = None)\n\tdata_mask : array\n\t\tuse a mask to create a surface backbone (Default = None)\n\tthreshold : float\n\t\tthreshold for output of voxels (Default = None)\n\tabsthreshold : float\n\t\tthreshold for output of abs(voxels) (Default = None)\n\t\t\n\tReturns\n\t-------\n\t\tv : array\n\t\t\tvertices\n\t\tf : array\n\t\t\tfaces\n\t\tvalues : array\n\t\t\tscalar values\n\t\n\t\"\"\"\n\ttry:\n\t\tfrom skimage import measure\n\texcept:\n\t\tprint(\"Error skimage is required\")\n\t\tquit()\n\n\tif threshold is not None:\n\t\tprint(\"Zeroing data less than threshold = %1.2f\" % threshold)\n\t\timg_data[img_data<threshold] = 0\n\tif absthreshold is not None:\n\t\tprint(\"Zeroing absolute values less than threshold = %1.2f\" % absthreshold)\n\t\timg_data[np.abs(img_data)<absthreshold] = 0\n\tif data_mask is not None:\n\t\tprint(\"Including mask\")\n\t\tdata_mask *= .1\n\t\tdata_mask[img_data!=0] = img_data[img_data!=0]\n\t\tdel img_data\n\t\timg_data = np.copy(data_mask)\n\ttry:\n\t\tv, f, _, values = measure.marching_cubes_lewiner(img_data)\n\t\tif affine is not None:\n\t\t\tprint(\"Applying affine transformation\")\n\t\t\tv = nib.affines.apply_affine(affine,v)\n\texcept:\n\t\tprint(\"No voxels above threshold\")\n\t\tv = f = values = []\n\treturn v, f, values\ntfce_mediation/pyfunc.py\ndef convert_gifti(gifti_surface):\n\timg = nib.load(gifti_surface)\n\tv, f = img.darrays[0].data, img.darrays[1].data\n\treturn v, f\ntfce_mediation/pyfunc.py\ndef convert_fslabel(name_fslabel):\n\tobj = open(name_fslabel)\n\treader = obj.readline().strip().split()\n\treader = np.array(obj.readline().strip().split())\n\tif reader.ndim == 1:\n\t\tnum_vertex = reader[0].astype(np.int)\n\telse:\n\t\tprint('Error reading header')\n\tv_id = np.zeros((num_vertex)).astype(np.int)\n\tv_ras = np.zeros((num_vertex,3)).astype(np.float)\n\tv_value = np.zeros((num_vertex)).astype(np.float)\n\tfor i in range(num_vertex):\n\t\treader = obj.readline().strip().split()\n\t\tv_id[i] = np.array(reader[0]).astype(np.int)\n\t\tv_ras[i] = np.array(reader[1:4]).astype(np.float)\n\t\tv_value[i] = np.array(reader[4]).astype(np.float)\n\treturn (v_id, v_ras, v_value)\ntfce_mediation/pyfunc.py\ndef save_ply(v, f, outname, color_array=None, output_binary=True):\n\t# check file extension\n\tif not outname.endswith('ply'):\n\t\tif output_binary:\n\t\t\toutname += '.ply'\n\t\telse:\n\t\t\toutname += '.ascii.ply'\n\toutname=check_outname(outname)\n\n\t# write header \n\theader = (\"ply\\n\")\n\tif output_binary:\n\t\theader += (\"format binary_%s_endian 1.0\\n\" % (sys.byteorder))\n\t\tif sys.byteorder == 'little':\n\t\t\toutput_fmt = '<'\n\t\telse:\n\t\t\toutput_fmt = '>'\n\telse:\n\t\theader += (\"format ascii 1.0\\n\")\n\theader += (\"comment made with TFCE_mediation\\n\")\n\theader += (\"element vertex %d\\n\" % len(v))\n\theader += (\"property float x\\n\")\n\theader += (\"property float y\\n\")\n\theader += (\"property float z\\n\")\n\tif color_array is not None:\n\t\theader += (\"property uchar red\\n\")\n\t\theader += (\"property uchar green\\n\")\n\t\theader += (\"property uchar blue\\n\")\n\theader += (\"element face %d\\n\" % len(f))\n\theader += (\"property list uchar int vertex_index\\n\")\n\theader += (\"end_header\\n\")\n\n\t# write to file\n\twith open(outname, \"a\") as o:\n\t\to.write(header)\n\t\tfor i in range(len(v)):\n\t\t\tif output_binary:\n\t\t\t\tif color_array is not None:\n\t\t\t\t\to.write(\n\t\t\t\t\t\tstruct.pack(output_fmt + 'fffBBB', v[i, 0], v[i, 1], v[i, 2], color_array[i, 0], color_array[i, 1], color_array[i, 2]))\n\t\t\t\telse:\n\t\t\t\t\to.write(struct.pack(output_fmt + 'fff', v[i, 0], v[i, 1], v[i, 2]))\n\t\t\telse:\n\t\t\t\tif color_array is not None:\n\t\t\t\t\to.write(\"%1.6f %1.6f %1.6f %d %d %d\\n\" % (v[i, 0], v[i, 1], v[i, 2], color_array[i, 0], color_array[i, 1], color_array[i, 2]))\n\t\t\t\telse:\n\t\t\t\t\to.write(\"%1.6f %1.6f %1.6f\\n\" % (v[i, 0], v[i, 1], v[i, 2]))\n\t\tfor j in range(len(f)):\n\t\t\tif output_binary:\n\t\t\t\to.write(struct.pack('<Biii', 3, f[j, 0], f[j, 1], f[j, 2]))\n\t\t\telse:\n\t\t\t\to.write(\"3 %d %d %d\\n\" % (f[j, 0], f[j, 1], f[j, 2]))\ntfce_mediation/pyfunc.py\ndef convert_fs(fs_surface):\n\tv, f = nib.freesurfer.read_geometry(fs_surface)\n\treturn v, f\ntfce_mediation/pyfunc.py\ndef convert_mpl_colormaps(threshold,img_data, cmapName, baseColour=[227,218,201], save_colorbar = True):\n\tcmapFunc = plt.get_cmap(str(cmapName))\n\tcolor_array = np.zeros((img_data.shape[0],3))\n\tcolor_cutoffs = np.linspace(threshold[0],threshold[1],256)\n\tcV=0\n\tfor k in img_data:\n\t\ttemp_ = np.array(cmapFunc(np.searchsorted(color_cutoffs, k, side=\"left\")))*255\n\t\tcolor_array[cV,:] = ((np.around(temp_[0]), np.around(temp_[1]), np.around(temp_[2])))\n\t\tcV+=1\n\tcolor_array[img_data<threshold[0]] = baseColour\n\ttemp_ = np.array(cmapFunc(np.searchsorted(color_cutoffs, color_cutoffs[255], side=\"left\")))*255 # safer\n\tcolor_array[img_data>=threshold[1]] = ((int(temp_[0]), int(temp_[1]), int(temp_[2])))\n\tif save_colorbar:\n\t\twrite_colorbar(threshold, cmapFunc, cmapName, 'png')\n\t\tplt.clf()\n\treturn color_array\ntfce_mediation/tm_io.py\ndef savemgh_v2(image_array, index, imagename, affine=None):\n\tif not imagename.endswith('mgh'):\n\t\timagename += '.mgh'\n\toutdata = image_array.astype(np.float32, order = \"C\")\n\tif image_array.ndim == 1:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2]))\n\t\timgout[index]=outdata\n\telif image_array.shape[1] > 1:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2],image_array.shape[1]))\n\t\timgout[index]=outdata\n\telse:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2]))\n\t\timgout[index]=outdata[:,0]\n\tnib.save(nib.freesurfer.mghformat.MGHImage(imgout.astype(np.float32, order = \"C\"),affine=affine),imagename)\ntfce_mediation/pyfunc.py\ndef convert_redtoyellow(threshold,img_data, baseColour=[227,218,201], save_colorbar = True):\n\tcolor_array = np.zeros((img_data.shape[0],3))\n\tcolor_cutoffs = np.linspace(threshold[0],threshold[1],256)\n\tcolored_img_data = np.zeros_like(img_data)\n\tcV=0\n\tfor k in img_data:\n\t\tcolored_img_data[cV] = np.searchsorted(color_cutoffs, k, side=\"left\")\n\t\tcV+=1\n\tcolor_array[:,0]=255\n\tcolor_array[:,1]=np.copy(colored_img_data)\n\tcolor_array[img_data<threshold[0]] = baseColour\n\tcolor_array[img_data>threshold[1]] = [255,255,0]\n\n\tcmap_name = 'red_yellow'\n\tcmap_array = np.array(( (np.ones(256)*255), np.linspace(0,255,256), np.zeros(256))).T\n\trl_cmap = colors.ListedColormap(cmap_array/255)\n\tif save_colorbar:\n\t\twrite_colorbar(threshold, rl_cmap, cmap_name, 'png')\n\t\tplt.clf()\n\treturn color_array\ntfce_mediation/pyfunc.py\ndef convert_mni_object(obj_file):\n\t# adapted from Jon Pipitone's script https://gist.github.com/pipitone/8687804\n\tobj = open(obj_file)\n\t_, _, _, _, _, _, numpoints = obj.readline().strip().split()\n\tnumpoints = int(numpoints)\n\tvertices=[]\n\tnormals=[]\n\ttriangles=[]\n\n\tfor i in range(numpoints):\n\t\tx, y, z = list(map(float,obj.readline().strip().split())) \n\t\tvertices.append((x, y, z))\n\tassert obj.readline().strip() == \"\"\n\t# numpoints normals as (x,y,z)\n\tfor i in range(numpoints):\n\t\tnormals.append(tuple(map(float,obj.readline().strip().split())))\n\n\tassert obj.readline().strip() == \"\"\n\tnt=int(obj.readline().strip().split()[0]) # number of triangles\n\t_, _, _, _, _ = obj.readline().strip().split()\n\tassert obj.readline().strip() == \"\"\n\t# rest of the file is a list of numbers\n\tpoints = list(map(int, \"\".join(obj.readlines()).strip().split()))\n\tpoints = points[nt:]\t# ignore these.. (whatever they are)\n\tfor i in range(nt): \n\t\ttriangles.append((points.pop(0), points.pop(0), points.pop(0)))\n\treturn np.array(vertices), np.array(triangles)\ntfce_mediation/pyfunc.py\ndef save_fs(v,f, outname):\n\tif not outname.endswith('srf'):\n\t\toutname += '.srf'\n\toutname=check_outname(outname)\n\tnib.freesurfer.io.write_geometry(outname, v, f)\n", "answers": ["\t\t\t\tout_color_array = convert_bluetolightblue(np.array(( float(opts.paintsurface[1]),float(opts.paintsurface[2]) )), img_data)"], "length": 2032, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "131139402cad5bfc8744b35012d307b9976737a536cf7a0c"}
{"input": "import os.path\nimport time\nimport logging\nfrom shutil import copyfileobj\nfrom requests.structures import CaseInsensitiveDict\nfrom dateutil.parser import parse\nfrom slugify import slugify\nfrom blinkpy import api\nfrom blinkpy.sync_module import BlinkSyncModule, BlinkOwl, BlinkLotus\nfrom blinkpy.helpers import util\nfrom blinkpy.helpers.constants import (\n    DEFAULT_MOTION_INTERVAL,\n    DEFAULT_REFRESH,\n    MIN_THROTTLE_TIME,\n    TIMEOUT_MEDIA,\n)\nfrom blinkpy.helpers.constants import __version__\nfrom blinkpy.auth import Auth, TokenRefreshFailed, LoginError\n# -*- coding: utf-8 -*-\n\"\"\"\nblinkpy is an unofficial api for the Blink security camera system.\n\nrepo url: https://github.com/fronzbot/blinkpy\n\nOriginal protocol hacking by MattTW :\nhttps://github.com/MattTW/BlinkMonitorProtocol\n\nPublished under the MIT license - See LICENSE file for more details.\n\"Blink Wire-Free HS Home Monitoring & Alert Systems\" is a trademark\nowned by Immedia Inc., see www.blinkforhome.com for more information.\nblinkpy is in no way affiliated with Blink, nor Immedia Inc.\n\"\"\"\n\n\n\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass Blink:\n    \"\"\"Class to initialize communication.\"\"\"\n\n    def __init__(\n        self,\n        refresh_rate=DEFAULT_REFRESH,\n        motion_interval=DEFAULT_MOTION_INTERVAL,\n        no_owls=False,\n    ):\n        \"\"\"\n        Initialize Blink system.\n\n        :param refresh_rate: Refresh rate of blink information.\n                             Defaults to 15 (seconds)\n        :param motion_interval: How far back to register motion in minutes.\n                                Defaults to last refresh time.\n                                Useful for preventing motion_detected property\n                                from de-asserting too quickly.\n        :param no_owls: Disable searching for owl entries (blink mini cameras only known entity).  Prevents an uneccessary API call if you don't have these in your network.\n        \"\"\"\n", "context": "blinkpy/auth.py\nclass TokenRefreshFailed(Exception):\n    \"\"\"Class to throw failed refresh exception.\"\"\"\nblinkpy/helpers/constants.py\nDEFAULT_MOTION_INTERVAL = 1\nblinkpy/auth.py\nclass LoginError(Exception):\n    \"\"\"Class to throw failed login exception.\"\"\"\nblinkpy/helpers/constants.py\nMIN_THROTTLE_TIME = 2\nblinkpy/helpers/util.py\n_LOGGER = logging.getLogger(__name__)\ndef json_load(file_name):\ndef json_save(data, file_name):\ndef gen_uid(size, uid_format=False):\ndef time_to_seconds(timestamp):\ndef get_time(time_to_convert=None):\ndef merge_dicts(dict_a, dict_b):\ndef prompt_login_data(data):\ndef validate_login_data(data):\n    def __init__(self, errcode):\n    def __init__(self, region_id):\n    def __init__(self, seconds=10):\n    def __call__(self, method):\n        def throttle_method():\n        def wrapper(*args, **kwargs):\nclass BlinkException(Exception):\nclass BlinkAuthenticationException(BlinkException):\nclass BlinkURLHandler:\nclass Throttle:\nblinkpy/helpers/constants.py\nDEFAULT_REFRESH = 30\nblinkpy/helpers/constants.py\nTIMEOUT_MEDIA = 90\nblinkpy/sync_module.py\nclass BlinkSyncModule:\n    \"\"\"Class to initialize sync module.\"\"\"\n\n    def __init__(self, blink, network_name, network_id, camera_list):\n        \"\"\"\n        Initialize Blink sync module.\n\n        :param blink: Blink class instantiation\n        \"\"\"\n        self.blink = blink\n        self.network_id = network_id\n        self.region_id = blink.auth.region_id\n        self.name = network_name\n        self.serial = None\n        self.status = \"offline\"\n        self.sync_id = None\n        self.host = None\n        self.summary = None\n        self.network_info = None\n        self.events = []\n        self.cameras = CaseInsensitiveDict({})\n        self.motion_interval = blink.motion_interval\n        self.motion = {}\n        self.last_record = {}\n        self.camera_list = camera_list\n        self.available = False\n\n    @property\n    def attributes(self):\n        \"\"\"Return sync attributes.\"\"\"\n        attr = {\n            \"name\": self.name,\n            \"id\": self.sync_id,\n            \"network_id\": self.network_id,\n            \"serial\": self.serial,\n            \"status\": self.status,\n            \"region_id\": self.region_id,\n        }\n        return attr\n\n    @property\n    def urls(self):\n        \"\"\"Return device urls.\"\"\"\n        return self.blink.urls\n\n    @property\n    def online(self):\n        \"\"\"Return boolean system online status.\"\"\"\n        try:\n            return ONLINE[self.status]\n        except KeyError:\n            _LOGGER.error(\"Unknown sync module status %s\", self.status)\n            self.available = False\n            return False\n\n    @property\n    def arm(self):\n        \"\"\"Return status of sync module: armed/disarmed.\"\"\"\n        try:\n            return self.network_info[\"network\"][\"armed\"]\n        except (KeyError, TypeError):\n            self.available = False\n            return None\n\n    @arm.setter\n    def arm(self, value):\n        \"\"\"Arm or disarm camera.\"\"\"\n        if value:\n            return api.request_system_arm(self.blink, self.network_id)\n        return api.request_system_disarm(self.blink, self.network_id)\n\n    def start(self):\n        \"\"\"Initialize the system.\"\"\"\n        response = self.sync_initialize()\n        if not response:\n            return False\n\n        try:\n            self.sync_id = self.summary[\"id\"]\n            self.serial = self.summary[\"serial\"]\n            self.status = self.summary[\"status\"]\n        except KeyError:\n            _LOGGER.error(\"Could not extract some sync module info: %s\", response)\n\n        is_ok = self.get_network_info()\n        self.check_new_videos()\n\n        if not is_ok or not self.update_cameras():\n            return False\n        self.available = True\n        return True\n\n    def sync_initialize(self):\n        \"\"\"Initialize a sync module.\"\"\"\n        response = api.request_syncmodule(self.blink, self.network_id)\n        try:\n            self.summary = response[\"syncmodule\"]\n            self.network_id = self.summary[\"network_id\"]\n        except (TypeError, KeyError):\n            _LOGGER.error(\n                \"Could not retrieve sync module information with response: %s\", response\n            )\n            return False\n        return response\n\n    def update_cameras(self, camera_type=BlinkCamera):\n        \"\"\"Update cameras from server.\"\"\"\n        try:\n            for camera_config in self.camera_list:\n                if \"name\" not in camera_config:\n                    break\n                blink_camera_type = camera_config.get(\"type\", \"\")\n                name = camera_config[\"name\"]\n                self.motion[name] = False\n                owl_info = self.get_owl_info(name)\n                lotus_info = self.get_lotus_info(name)\n                if blink_camera_type == \"mini\":\n                    camera_type = BlinkCameraMini\n                if blink_camera_type == \"lotus\":\n                    camera_type = BlinkDoorbell\n                self.cameras[name] = camera_type(self)\n                camera_info = self.get_camera_info(\n                    camera_config[\"id\"], owl_info=owl_info, lotus_info=lotus_info\n                )\n                self.cameras[name].update(camera_info, force_cache=True, force=True)\n\n        except KeyError:\n            _LOGGER.error(\"Could not create camera instances for %s\", self.name)\n            return False\n        return True\n\n    def get_owl_info(self, name):\n        \"\"\"Extract owl information.\"\"\"\n        try:\n            for owl in self.blink.homescreen[\"owls\"]:\n                if owl[\"name\"] == name:\n                    return owl\n        except (TypeError, KeyError):\n            pass\n        return None\n\n    def get_lotus_info(self, name):\n        \"\"\"Extract lotus information.\"\"\"\n        try:\n            for doorbell in self.blink.homescreen[\"doorbells\"]:\n                if doorbell[\"name\"] == name:\n                    return doorbell\n        except (TypeError, KeyError):\n            pass\n        return None\n\n    def get_events(self, **kwargs):\n        \"\"\"Retrieve events from server.\"\"\"\n        force = kwargs.pop(\"force\", False)\n        response = api.request_sync_events(self.blink, self.network_id, force=force)\n        try:\n            return response[\"event\"]\n        except (TypeError, KeyError):\n            _LOGGER.error(\"Could not extract events: %s\", response)\n            return False\n\n    def get_camera_info(self, camera_id, **kwargs):\n        \"\"\"Retrieve camera information.\"\"\"\n        owl = kwargs.get(\"owl_info\", None)\n        if owl is not None:\n            return owl\n        lotus = kwargs.get(\"lotus_info\", None)\n        if lotus is not None:\n            return lotus\n        response = api.request_camera_info(self.blink, self.network_id, camera_id)\n        try:\n            return response[\"camera\"][0]\n        except (TypeError, KeyError):\n            _LOGGER.error(\"Could not extract camera info: %s\", response)\n            return {}\n\n    def get_network_info(self):\n        \"\"\"Retrieve network status.\"\"\"\n        self.network_info = api.request_network_update(self.blink, self.network_id)\n        try:\n            if self.network_info[\"network\"][\"sync_module_error\"]:\n                raise KeyError\n        except (TypeError, KeyError):\n            self.available = False\n            return False\n        return True\n\n    def refresh(self, force_cache=False):\n        \"\"\"Get all blink cameras and pulls their most recent status.\"\"\"\n        if not self.get_network_info():\n            return\n        self.check_new_videos()\n        for camera_name in self.cameras.keys():\n            camera_id = self.cameras[camera_name].camera_id\n            camera_info = self.get_camera_info(\n                camera_id,\n                owl_info=self.get_owl_info(camera_name),\n                lotus_info=self.get_lotus_info(camera_name),\n            )\n            self.cameras[camera_name].update(camera_info, force_cache=force_cache)\n        self.available = True\n\n    def check_new_videos(self):\n        \"\"\"Check if new videos since last refresh.\"\"\"\n        try:\n            interval = self.blink.last_refresh - self.motion_interval * 60\n        except TypeError:\n            # This is the first start, so refresh hasn't happened yet.\n            # No need to check for motion.\n            return False\n\n        resp = api.request_videos(self.blink, time=interval, page=1)\n\n        for camera in self.cameras.keys():\n            self.motion[camera] = False\n\n        try:\n            info = resp[\"media\"]\n        except (KeyError, TypeError):\n            _LOGGER.warning(\"Could not check for motion. Response: %s\", resp)\n            return False\n\n        for entry in info:\n            try:\n                name = entry[\"device_name\"]\n                clip = entry[\"media\"]\n                timestamp = entry[\"created_at\"]\n                if self.check_new_video_time(timestamp):\n                    self.motion[name] = True and self.arm\n                    self.last_record[name] = {\"clip\": clip, \"time\": timestamp}\n            except KeyError:\n                _LOGGER.debug(\"No new videos since last refresh.\")\n\n        return True\n\n    def check_new_video_time(self, timestamp):\n        \"\"\"Check if video has timestamp since last refresh.\"\"\"\n        return time_to_seconds(timestamp) > self.blink.last_refresh\nblinkpy/api.py\n_LOGGER = logging.getLogger(__name__)\nMIN_THROTTLE_TIME = 5\ndef request_login(\n    auth, url, login_data, is_retry=False,\n):\ndef request_verify(auth, blink, verify_key):\ndef request_logout(blink):\ndef request_networks(blink):\ndef request_network_update(blink, network):\ndef request_user(blink):\ndef request_network_status(blink, network):\ndef request_syncmodule(blink, network):\ndef request_system_arm(blink, network):\ndef request_system_disarm(blink, network):\ndef request_command_status(blink, network, command_id):\ndef request_homescreen(blink):\ndef request_sync_events(blink, network):\ndef request_new_image(blink, network, camera_id):\ndef request_new_video(blink, network, camera_id):\ndef request_video_count(blink):\ndef request_videos(blink, time=None, page=0):\ndef request_cameras(blink, network):\ndef request_camera_info(blink, network, camera_id):\ndef request_camera_usage(blink):\ndef request_camera_liveview(blink, network, camera_id):\ndef request_camera_sensors(blink, network, camera_id):\ndef request_motion_detection_enable(blink, network, camera_id):\ndef request_motion_detection_disable(blink, network, camera_id):\ndef http_get(blink, url, stream=False, json=True, is_retry=False, timeout=TIMEOUT):\ndef http_post(blink, url, is_retry=False, data=None, json=True, timeout=TIMEOUT):\nblinkpy/auth.py\nclass Auth:\n    \"\"\"Class to handle login communication.\"\"\"\n\n    def __init__(self, login_data=None, no_prompt=False):\n        \"\"\"\n        Initialize auth handler.\n\n        :param login_data: dictionary for login data\n                           must contain the following:\n                             - username\n                             - password\n        :param no_prompt: Should any user input prompts\n                          be supressed? True/FALSE\n        \"\"\"\n        if login_data is None:\n            login_data = {}\n        self.data = login_data\n        self.token = login_data.get(\"token\", None)\n        self.host = login_data.get(\"host\", None)\n        self.region_id = login_data.get(\"region_id\", None)\n        self.client_id = login_data.get(\"client_id\", None)\n        self.account_id = login_data.get(\"account_id\", None)\n        self.login_response = None\n        self.is_errored = False\n        self.no_prompt = no_prompt\n        self.session = self.create_session()\n\n    @property\n    def login_attributes(self):\n        \"\"\"Return a dictionary of login attributes.\"\"\"\n        self.data[\"token\"] = self.token\n        self.data[\"host\"] = self.host\n        self.data[\"region_id\"] = self.region_id\n        self.data[\"client_id\"] = self.client_id\n        self.data[\"account_id\"] = self.account_id\n        return self.data\n\n    @property\n    def header(self):\n        \"\"\"Return authorization header.\"\"\"\n        if self.token is None:\n            return None\n        return {\n            \"TOKEN_AUTH\": self.token,\n            \"user-agent\": DEFAULT_USER_AGENT,\n            \"content-type\": \"application/json\",\n        }\n\n    def create_session(self, opts=None):\n        \"\"\"Create a session for blink communication.\"\"\"\n        if opts is None:\n            opts = {}\n        backoff = opts.get(\"backoff\", 1)\n        retries = opts.get(\"retries\", 3)\n        retry_list = opts.get(\"retry_list\", [429, 500, 502, 503, 504])\n        sess = Session()\n        assert_status_hook = [\n            lambda response, *args, **kwargs: response.raise_for_status()\n        ]\n        sess.hooks[\"response\"] = assert_status_hook\n        retry = Retry(\n            total=retries, backoff_factor=backoff, status_forcelist=retry_list\n        )\n        adapter = HTTPAdapter(max_retries=retry)\n        sess.mount(\"https://\", adapter)\n        sess.mount(\"http://\", adapter)\n        sess.get = partial(sess.get, timeout=TIMEOUT)\n        return sess\n\n    def prepare_request(self, url, headers, data, reqtype):\n        \"\"\"Prepare a request.\"\"\"\n        req = Request(reqtype.upper(), url, headers=headers, data=data)\n        return req.prepare()\n\n    def validate_login(self):\n        \"\"\"Check login information and prompt if not available.\"\"\"\n        self.data[\"username\"] = self.data.get(\"username\", None)\n        self.data[\"password\"] = self.data.get(\"password\", None)\n        if not self.no_prompt:\n            self.data = util.prompt_login_data(self.data)\n\n        self.data = util.validate_login_data(self.data)\n\n    def login(self, login_url=LOGIN_ENDPOINT):\n        \"\"\"Attempt login to blink servers.\"\"\"\n        self.validate_login()\n        _LOGGER.info(\"Attempting login with %s\", login_url)\n        response = api.request_login(self, login_url, self.data, is_retry=False,)\n        try:\n            if response.status_code == 200:\n                return response.json()\n            raise LoginError\n        except AttributeError as error:\n            raise LoginError from error\n\n    def logout(self, blink):\n        \"\"\"Log out.\"\"\"\n        return api.request_logout(blink)\n\n    def refresh_token(self):\n        \"\"\"Refresh auth token.\"\"\"\n        self.is_errored = True\n        try:\n            _LOGGER.info(\"Token expired, attempting automatic refresh.\")\n            self.login_response = self.login()\n            self.extract_login_info()\n            self.is_errored = False\n        except LoginError as error:\n            _LOGGER.error(\"Login endpoint failed. Try again later.\")\n            raise TokenRefreshFailed from error\n        except (TypeError, KeyError) as error:\n            _LOGGER.error(\"Malformed login response: %s\", self.login_response)\n            raise TokenRefreshFailed from error\n        return True\n\n    def extract_login_info(self):\n        \"\"\"Extract login info from login response.\"\"\"\n        self.region_id = self.login_response[\"account\"][\"tier\"]\n        self.host = f\"{self.region_id}.{BLINK_URL}\"\n        self.token = self.login_response[\"auth\"][\"token\"]\n        self.client_id = self.login_response[\"account\"][\"client_id\"]\n        self.account_id = self.login_response[\"account\"][\"account_id\"]\n\n    def startup(self):\n        \"\"\"Initialize tokens for communication.\"\"\"\n        self.validate_login()\n        if None in self.login_attributes.values():\n            self.refresh_token()\n\n    def validate_response(self, response, json_resp):\n        \"\"\"Check for valid response.\"\"\"\n        if not json_resp:\n            self.is_errored = False\n            return response\n        self.is_errored = True\n        try:\n            if response.status_code in [101, 401]:\n                raise UnauthorizedError\n            if response.status_code == 404:\n                raise exceptions.ConnectionError\n            json_data = response.json()\n        except KeyError:\n            pass\n        except (AttributeError, ValueError) as error:\n            raise BlinkBadResponse from error\n\n        self.is_errored = False\n        return json_data\n\n    def query(\n        self,\n        url=None,\n        data=None,\n        headers=None,\n        reqtype=\"get\",\n        stream=False,\n        json_resp=True,\n        is_retry=False,\n        timeout=TIMEOUT,\n    ):\n        \"\"\"\n        Perform server requests.\n\n        :param url: URL to perform request\n        :param data: Data to send\n        :param headers: Headers to send\n        :param reqtype: Can be 'get' or 'post' (default: 'get')\n        :param stream: Stream response? True/FALSE\n        :param json_resp: Return JSON response? TRUE/False\n        :param is_retry: Is this part of a re-auth attempt? True/FALSE\n        \"\"\"\n        req = self.prepare_request(url, headers, data, reqtype)\n        try:\n            response = self.session.send(req, stream=stream, timeout=timeout)\n            return self.validate_response(response, json_resp)\n        except (exceptions.ConnectionError, exceptions.Timeout):\n            _LOGGER.error(\n                \"Connection error. Endpoint %s possibly down or throttled.\", url,\n            )\n        except BlinkBadResponse:\n            code = None\n            reason = None\n            try:\n                code = response.status_code\n                reason = response.reason\n            except AttributeError:\n                pass\n            _LOGGER.error(\n                \"Expected json response from %s, but received: %s: %s\",\n                url,\n                code,\n                reason,\n            )\n        except UnauthorizedError:\n            try:\n                if not is_retry:\n                    self.refresh_token()\n                    return self.query(\n                        url=url,\n                        data=data,\n                        headers=self.header,\n                        reqtype=reqtype,\n                        stream=stream,\n                        json_resp=json_resp,\n                        is_retry=True,\n                        timeout=timeout,\n                    )\n                _LOGGER.error(\"Unable to access %s after token refresh.\", url)\n            except TokenRefreshFailed:\n                _LOGGER.error(\"Unable to refresh token.\")\n        return None\n\n    def send_auth_key(self, blink, key):\n        \"\"\"Send 2FA key to blink servers.\"\"\"\n        if key is not None:\n            response = api.request_verify(self, blink, key)\n            try:\n                json_resp = response.json()\n                blink.available = json_resp[\"valid\"]\n                if not json_resp[\"valid\"]:\n                    _LOGGER.error(\"%s\", json_resp[\"message\"])\n                    return False\n            except (KeyError, TypeError):\n                _LOGGER.error(\"Did not receive valid response from server.\")\n                return False\n        return True\n\n    def check_key_required(self):\n        \"\"\"Check if 2FA key is required.\"\"\"\n        try:\n            if self.login_response[\"account\"][\"client_verification_required\"]:\n                return True\n        except (KeyError, TypeError):\n            pass\n        return False\nblinkpy/sync_module.py\nclass BlinkOwl(BlinkSyncModule):\n    \"\"\"Representation of a sync-less device.\"\"\"\n\n    def __init__(self, blink, name, network_id, response):\n        \"\"\"Initialize a sync-less object.\"\"\"\n        cameras = [{\"name\": name, \"id\": response[\"id\"]}]\n        super().__init__(blink, name, network_id, cameras)\n        self.sync_id = response[\"id\"]\n        self.serial = response[\"serial\"]\n        self.status = response[\"enabled\"]\n        if not self.serial:\n            self.serial = f\"{network_id}-{self.sync_id}\"\n\n    def sync_initialize(self):\n        \"\"\"Initialize a sync-less module.\"\"\"\n        self.summary = {\n            \"id\": self.sync_id,\n            \"name\": self.name,\n            \"serial\": self.serial,\n            \"status\": self.status,\n            \"onboarded\": True,\n            \"account_id\": self.blink.account_id,\n            \"network_id\": self.network_id,\n        }\n        return self.summary\n\n    def update_cameras(self, camera_type=BlinkCameraMini):\n        \"\"\"Update sync-less cameras.\"\"\"\n        return super().update_cameras(camera_type=BlinkCameraMini)\n\n    def get_camera_info(self, camera_id, **kwargs):\n        \"\"\"Retrieve camera information.\"\"\"\n        try:\n            for owl in self.blink.homescreen[\"owls\"]:\n                if owl[\"name\"] == self.name:\n                    self.status = owl[\"enabled\"]\n                    return owl\n        except (TypeError, KeyError):\n            pass\n        return None\n\n    def get_network_info(self):\n        \"\"\"Get network info for sync-less module.\"\"\"\n        return True\n\n    @property\n    def network_info(self):\n        \"\"\"Format owl response to resemble sync module.\"\"\"\n        return {\n            \"network\": {\n                \"id\": self.network_id,\n                \"name\": self.name,\n                \"armed\": self.status,\n                \"sync_module_error\": False,\n                \"account_id\": self.blink.account_id,\n            }\n        }\n\n    @network_info.setter\n    def network_info(self, value):\n        \"\"\"Set network_info property.\"\"\"\nblinkpy/helpers/constants.py\nMAJOR_VERSION = 0\nMINOR_VERSION = 19\nPATCH_VERSION = \"0.rc0\"\nREQUIRED_PYTHON_VER = (3, 6, 0)\nPROJECT_NAME = \"blinkpy\"\nPROJECT_PACKAGE_NAME = \"blinkpy\"\nPROJECT_LICENSE = \"MIT\"\nPROJECT_AUTHOR = \"Kevin Fronczak\"\nPROJECT_COPYRIGHT = f\" 2017, {PROJECT_AUTHOR}\"\nPROJECT_URL = \"https://github.com/fronzbot/blinkpy\"\nPROJECT_EMAIL = \"kfronczak@gmail.com\"\nPROJECT_DESCRIPTION = \"A Blink camera Python library \" \"running on Python 3.\"\nPROJECT_LONG_DESCRIPTION = (\n    \"blinkpy is an open-source \"\n    \"unofficial API for the Blink Camera \"\n    \"system with the intention for easy \"\n    \"integration into various home \"\n    \"automation platforms.\"\n)\n    PROJECT_LONG_DESCRIPTION = open(\"README.rst\").read()\nPROJECT_CLASSIFIERS = [\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n    \"Programming Language :: Python :: 3.6\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Topic :: Home Automation\",\n]\nPROJECT_GITHUB_USERNAME = \"fronzbot\"\nPROJECT_GITHUB_REPOSITORY = \"blinkpy\"\nPYPI_URL = f\"https://pypi.python.org/pypi/{PROJECT_PACKAGE_NAME}\"\nBLINK_URL = \"immedia-semi.com\"\nDEFAULT_URL = f\"rest-prod.{BLINK_URL}\"\nBASE_URL = f\"https://{DEFAULT_URL}\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/v5/account/login\"\nONLINE = {\"online\": True, \"offline\": False}\nDEFAULT_USER_AGENT = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"\nDEVICE_ID = \"Blinkpy\"\nTIMESTAMP_FORMAT = \"%Y-%m-%dT%H:%M:%S%z\"\nDEFAULT_MOTION_INTERVAL = 1\nDEFAULT_REFRESH = 30\nMIN_THROTTLE_TIME = 2\nSIZE_NOTIFICATION_KEY = 152\nSIZE_UID = 16\nTIMEOUT = 10\nTIMEOUT_MEDIA = 90\nblinkpy/sync_module.py\nclass BlinkLotus(BlinkSyncModule):\n    \"\"\"Representation of a sync-less device.\"\"\"\n\n    def __init__(self, blink, name, network_id, response):\n        \"\"\"Initialize a sync-less object.\"\"\"\n        cameras = [{\"name\": name, \"id\": response[\"id\"]}]\n        super().__init__(blink, name, network_id, cameras)\n        self.sync_id = response[\"id\"]\n        self.serial = response[\"serial\"]\n        self.status = response[\"enabled\"]\n        if not self.serial:\n            self.serial = f\"{network_id}-{self.sync_id}\"\n\n    def sync_initialize(self):\n        \"\"\"Initialize a sync-less module.\"\"\"\n        self.summary = {\n            \"id\": self.sync_id,\n            \"name\": self.name,\n            \"serial\": self.serial,\n            \"status\": self.status,\n            \"onboarded\": True,\n            \"account_id\": self.blink.account_id,\n            \"network_id\": self.network_id,\n        }\n        return self.summary\n\n    def update_cameras(self, camera_type=BlinkDoorbell):\n        \"\"\"Update sync-less cameras.\"\"\"\n        return super().update_cameras(camera_type=BlinkDoorbell)\n\n    def get_camera_info(self, camera_id, **kwargs):\n        \"\"\"Retrieve camera information.\"\"\"\n        try:\n            for doorbell in self.blink.homescreen[\"doorbells\"]:\n                if doorbell[\"name\"] == self.name:\n                    self.status = doorbell[\"enabled\"]\n                    return doorbell\n        except (TypeError, KeyError):\n            pass\n        return None\n\n    def get_network_info(self):\n        \"\"\"Get network info for sync-less module.\"\"\"\n        return True\n\n    @property\n    def network_info(self):\n        \"\"\"Format lotus response to resemble sync module.\"\"\"\n        return {\n            \"network\": {\n                \"id\": self.network_id,\n                \"name\": self.name,\n                \"armed\": self.status,\n                \"sync_module_error\": False,\n                \"account_id\": self.blink.account_id,\n            }\n        }\n\n    @network_info.setter\n    def network_info(self, value):\n        \"\"\"Set network_info property.\"\"\"\n", "answers": ["        self.auth = Auth()"], "length": 2174, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "b974e05782cc4c69c850e9554fcfe817a8cc14530563f3b4"}
{"input": "from itertools import chain\nfrom contextlib import contextmanager\nfrom collections import namedtuple, deque, defaultdict\nfrom .refs import ArgRef, FieldRef, ItemRef, Reference, is_from_arg, CtxRef\nfrom .nodes import Tuple, Number, Keyword, String, List, Symbol, Placeholder\nfrom .nodes import NodeVisitor, NodeTransformer\nfrom .types import IntType, NamedArgMeta, StringType, ListType, VarArgsMeta\nfrom .types import TypeVarMeta, TypeVar, Func, NamedArg, Record, TypeRefMeta\nfrom .types import RecordMeta, BoolType, Union, ListTypeMeta, DictTypeMeta\nfrom .types import TypingMeta, UnionMeta, Nothing, Option, VarArgs, FuncMeta\nfrom .types import TypeTransformer, Markup, VarNamedArgs, VarNamedArgsMeta\nfrom .types import MarkupMeta\nfrom .utils import VarsGen\nfrom .errors import Errors, UserError\nfrom .compat import zip_longest\nfrom .constant import HTML_ELEMENTS\n\n\n\nclass SyntaxError(UserError):\n    pass\n\n\nclass TypeCheckError(UserError):\n    pass\n\n\nclass SignatureMismatch(UserError):\n    pass\n\n\nclass Environ(object):\n\n    def __init__(self, defs=None, errors=None):\n        self.defs = defs or {}\n        self.vars = deque([{}])\n", "context": "kinko/refs.py\nclass ArgRef(Reference):\n\n    def __init__(self, name):\n        super(ArgRef, self).__init__(None)\n        self.name = name\n\n    def __repr__(self):\n        return \"#{}\".format(self.name)\nkinko/errors.py\nclass UserError(Exception):\n    pass\nkinko/refs.py\nclass CtxRef(Reference):\n\n    def __init__(self, name):\n        super(CtxRef, self).__init__(None)\n        self.name = name\n\n    def __repr__(self):\n        return 'ctx[{!r}]'.format(self.name)\nkinko/nodes.py\nclass Number(Node):\n\n    def __init__(self, value, **kw):\n        self.value = value\n        super(Number, self).__init__(**kw)\n\n    def __repr__(self):\n        return repr(self.value)\n\n    def accept(self, visitor):\n        return visitor.visit_number(self)\nkinko/types.py\nclass TypeVar(with_metaclass(TypeVarMeta, object)):\n    pass\nkinko/utils.py\nclass VarsGen(object):\n\n    def __init__(self):\n        self.vars = {}\n\n    def __getattr__(self, name):\n        if name not in self.vars:\n            self.vars[name] = TypeVar[None]\n        return self.vars[name]\nkinko/types.py\nclass StringType(with_metaclass(StringTypeMeta, object)):\n    pass\nkinko/types.py\nclass RecordMeta(TypingMeta):\n\n    def __cls_init__(cls, items):\n        cls.__items__ = dict(items)\n\n    def __repr__(cls):\n        return '{}{{{}}}'.format(\n            cls.__name__,\n            ' '.join(':{} {!r}'.format(*i) for i in cls.__items__.items()),\n        )\n\n    def accept(cls, visitor):\n        return visitor.visit_record(cls)\nkinko/types.py\nclass DictTypeMeta(TypingMeta):\n\n    def __cls_init__(cls, params):\n        cls.__key_type__, cls.__value_type__ = params\n\n    def __repr__(cls):\n        return '{{:{!r} {!r}}}'.format(cls.__key_type__, cls.__value_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_dict(cls)\nkinko/types.py\nclass MarkupMeta(GenericMeta):\n\n    def __repr__(cls):\n        return 'markup'\n\n    def accept(cls, visitor):\n        return visitor.visit_markup(cls)\nkinko/refs.py\ndef is_from_arg(ref):\n    return isinstance(get_origin(ref), ArgRef)\nkinko/types.py\nclass NamedArgMeta(TypingMeta):\n\n    def __cls_init__(cls, params):\n        cls.__arg_name__, cls.__arg_type__ = params\n\n    def __repr__(cls):\n        return ':{} {!r}'.format(cls.__arg_name__, cls.__arg_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_namedarg(cls)\nkinko/types.py\nclass NamedArg(with_metaclass(NamedArgMeta, object)):\n    pass\nkinko/types.py\nclass TypeTransformer(object):\n\n    def visit(self, type_):\n        return type_.accept(self)\n\n    def visit_bool(self, type_):\n        return type_\n\n    def visit_nothing(self, type_):\n        return type_\n\n    def visit_string(self, type_):\n        return type_\n\n    def visit_int(self, type_):\n        return type_\n\n    def visit_markup(self, type_):\n        return type_\n\n    def visit_typevar(self, type_):\n        return TypeVar[self.visit(type_.__instance__)\n                       if type_.__instance__ is not None else None]\n\n    def visit_typeref(self, type_):\n        return TypeRef[type_.__ref_name__]\n\n    def visit_union(self, type_):\n        return Union[(self.visit(t) for t in type_.__types__)]\n\n    def visit_option(self, type_):\n        t = (type_.__types__ - {Nothing}).pop()\n        return Option[self.visit(t)]\n\n    def visit_func(self, type_):\n        return Func[[self.visit(t) for t in type_.__args__],\n                    self.visit(type_.__result__)]\n\n    def visit_varargs(self, type_):\n        return VarArgs[self.visit(type_.__arg_type__)]\n\n    def visit_namedarg(self, type_):\n        return NamedArg[type_.__arg_name__, self.visit(type_.__arg_type__)]\n\n    def visit_varnamedargs(self, type_):\n        return VarNamedArgs[self.visit(type_.__arg_type__)]\n\n    def visit_list(self, type_):\n        return ListType[self.visit(type_.__item_type__)]\n\n    def visit_dict(self, type_):\n        return DictType[self.visit(type_.__key_type__),\n                        self.visit(type_.__value_type__)]\n\n    def visit_record(self, type_):\n        return Record[{key: self.visit(value)\n                       for key, value in type_.__items__.items()}]\nkinko/refs.py\nclass ItemRef(Reference):\n\n    def __repr__(self):\n        return '{!r} > []'.format(self.backref)\nkinko/compat.py\nPY3 = sys.version_info[0] == 3\nPY35 = sys.version_info >= (3, 5)\ndef with_metaclass(meta, *bases):\n        def __new__(cls, name, this_bases, d):\n    def _exec_in(source, globals_dict):\n    def _exec_in(source, globals_dict):\n    class metaclass(meta):\nkinko/types.py\nclass VarArgs(with_metaclass(VarArgsMeta, object)):\n    pass\nkinko/constant.py\nHTML_ELEMENTS = frozenset((\n    # root\n    'html',\n\n    # metadata\n    'head', 'title', 'base', 'link', 'meta', 'style',\n\n    # sections\n    'body', 'article', 'section', 'nav', 'aside', 'h1', 'h2', 'h3', 'h4', 'h5',\n    'h6', 'hgroup', 'headers', 'footer', 'address',\n\n    # grouping content\n    'p', 'hr', 'pre', 'blockquote', 'ol', 'ul', 'li', 'dl', 'dt', 'dd',\n    'figure', 'figcaption', 'main', 'div',\n\n    # text-level semantics\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'ruby', 'rt',\n    'rp', 'data', 'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b',\n    'u', 'mark', 'bdi', 'bdo', 'span', 'br', 'wbr',\n\n    # links\n    'a', 'area',\n\n    # edits\n    'ins', 'del',\n\n    # embedded content\n    'picture', 'source', 'img', 'iframe', 'embed', 'object', 'param', 'video',\n    'audio', 'track', 'map',\n\n    # tabular data\n    'table', 'caption', 'colgroup', 'col', 'tbody', 'thead', 'tfoot', 'tr',\n    'td', 'th',\n\n    # forms\n    'form', 'label', 'input', 'button', 'select', 'datalist', 'optgroup',\n    'option', 'textarea', 'keygen', 'output', 'progress', 'meter', 'fieldset',\n    'legend',\n\n    # interactive elements\n    'details', 'summary', 'menu', 'menuitem', 'dialog',\n\n    # scripting\n    'script', 'noscript', 'template', 'canvas',\n))\nkinko/types.py\nclass TypingMeta(GenericMeta):\n\n    def __cls_init__(cls, *args):\n        raise NotImplementedError\n\n    def __getitem__(cls, parameters):\n        type_ = cls.__class__(cls.__name__, cls.__bases__, dict(cls.__dict__))\n        type_.__cls_init__(parameters)\n        return type_\nkinko/types.py\nclass VarArgsMeta(TypingMeta):\n\n    def __cls_init__(cls, arg_type):\n        cls.__arg_type__ = arg_type\n\n    def __repr__(cls):\n        return '*{!r}'.format(cls.__arg_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_varargs(cls)\nkinko/types.py\nclass Nothing(with_metaclass(NothingMeta, object)):\n    pass\nkinko/types.py\nclass UnionMeta(TypingMeta):\n\n    def __cls_init__(cls, types):\n        cls.__types__ = set(types)\n\n    def __repr__(cls):\n        return '|'.join(map(repr, cls.__types__))\n\n    def accept(cls, visitor):\n        return visitor.visit_union(cls)\nkinko/types.py\nclass ListTypeMeta(TypingMeta):\n\n    def __cls_init__(cls, item_type):\n        cls.__item_type__ = item_type\n\n    def __repr__(cls):\n        return '[{!r}]'.format(cls.__item_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_list(cls)\nkinko/nodes.py\nclass Placeholder(Node):\n\n    def __init__(self, name, **kw):\n        self.name = name\n        super(Placeholder, self).__init__(**kw)\n\n    def __repr__(self):\n        return '#{}'.format(self.name)\n\n    def accept(self, visitor):\n        return visitor.visit_placeholder(self)\nkinko/types.py\nclass TypeRefMeta(TypingMeta):\n    __ref__ = None\n\n    def __cls_init__(cls, name):\n        cls.__ref_name__ = name\n\n    def __repr__(cls):\n        if cls.__ref__ is None:\n            return '<{}[-]>'.format(cls.__ref_name__)\n        else:\n            return '<{}[*]>'.format(cls.__ref_name__)\n\n    def accept(cls, visitor):\n        return visitor.visit_typeref(cls)\nkinko/types.py\nclass Record(with_metaclass(RecordMeta, object)):\n    pass\nkinko/nodes.py\nclass NodeVisitor(object):\n\n    def visit(self, node):\n        node.accept(self)\n\n    def visit_tuple(self, node):\n        for value in node.values:\n            self.visit(value)\n\n    def visit_list(self, node):\n        for value in node.values:\n            self.visit(value)\n\n    def visit_dict(self, node):\n        for value in node.values:\n            self.visit(value)\n\n    def visit_symbol(self, node):\n        pass\n\n    def visit_keyword(self, node):\n        pass\n\n    def visit_placeholder(self, node):\n        pass\n\n    def visit_number(self, node):\n        pass\n\n    def visit_string(self, node):\n        pass\nkinko/types.py\nclass Union(with_metaclass(UnionMeta, object)):\n    pass\nkinko/types.py\nclass IntType(with_metaclass(IntTypeMeta, object)):\n    pass\nkinko/types.py\nclass Markup(with_metaclass(MarkupMeta, object)):\n    pass\nkinko/types.py\nclass BoolType(with_metaclass(BoolTypeMeta, object)):\n    pass\nkinko/types.py\nclass ListType(with_metaclass(ListTypeMeta, object)):\n    pass\nkinko/errors.py\nclass Errors(object):\n\n    def __init__(self):\n        self.list = []\n        self._stack = [None]\n\n    @contextmanager\n    def module_ctx(self, module):\n        self._stack.append(Func(module, None))\n        try:\n            yield\n        finally:\n            self._stack.pop()\n\n    @contextmanager\n    def func_ctx(self, module, name):\n        self._stack.append(Func(module, name))\n        try:\n            yield\n        finally:\n            self._stack.pop()\n\n    @contextmanager\n    def location(self, location):\n        try:\n            yield\n        except UserError as e:\n            self.error(location, text_type(e))\n            raise\n\n    def warn(self, location, message):\n        self.list.append(Error(self._stack[-1], location, message, WARNING))\n\n    def error(self, location, message):\n        self.list.append(Error(self._stack[-1], location, message, ERROR))\nkinko/nodes.py\nclass NodeTransformer(object):\n\n    def visit(self, node):\n        return node.accept(self)\n\n    def visit_tuple(self, node):\n        return node.clone_with(self.visit(i) for i in node.values)\n\n    def visit_list(self, node):\n        return node.clone_with(self.visit(i) for i in node.values)\n\n    def visit_dict(self, node):\n        return node.clone_with(self.visit(i) for i in node.values)\n\n    def visit_symbol(self, node):\n        return node.clone()\n\n    def visit_keyword(self, node):\n        return node.clone()\n\n    def visit_placeholder(self, node):\n        return node.clone()\n\n    def visit_number(self, node):\n        return node.clone()\n\n    def visit_string(self, node):\n        return node.clone()\nkinko/types.py\nclass VarNamedArgs(with_metaclass(VarNamedArgsMeta, object)):\n    pass\nkinko/types.py\nclass VarNamedArgsMeta(TypingMeta):\n\n    def __cls_init__(cls, arg_type):\n        cls.__arg_type__ = arg_type\n\n    def __repr__(cls):\n        return '**{!r}'.format(cls.__arg_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_varnamedargs(cls)\nkinko/types.py\nclass TypeVarMeta(TypingMeta):\n    __backref__ = None\n\n    def __cls_init__(cls, instance):\n        cls.__instance__ = instance\n\n    def __repr__(cls):\n        return '<{}:{}>'.format(\n            hex(id(cls))[-3:].upper(),\n            repr(cls.__instance__) if cls.__instance__ is not None else '?',\n        )\n\n    def accept(cls, visitor):\n        return visitor.visit_typevar(cls)\nkinko/types.py\nclass FuncMeta(TypingMeta):\n\n    def __cls_init__(cls, params):\n        cls.__args__, cls.__result__ = params\n\n    def __repr__(cls):\n        return '({} -> {!r})'.format(\n            ' '.join(map(repr, cls.__args__)),\n            cls.__result__,\n        )\n\n    def accept(cls, visitor):\n        return visitor.visit_func(cls)\nkinko/nodes.py\nclass String(Node):\n\n    def __init__(self, value, **kw):\n        self.value = text_type(value)\n        super(String, self).__init__(**kw)\n\n    def __repr__(self):\n        return encode_basestring_ascii(self.value)\n\n    def accept(self, visitor):\n        return visitor.visit_string(self)\nkinko/nodes.py\nclass List(Node):\n\n    def __init__(self, values, **kw):\n        self.values = tuple(values)\n        super(List, self).__init__(**kw)\n\n    def __repr__(self):\n        return '[{}]'.format(' '.join(map(repr, self.values)))\n\n    def accept(self, visitor):\n        return visitor.visit_list(self)\nkinko/refs.py\nclass FieldRef(Reference):\n\n    def __init__(self, backref, name):\n        super(FieldRef, self).__init__(backref)\n        self.name = name\n\n    def __repr__(self):\n        return '{!r} > [{!r}]'.format(self.backref, self.name)\nkinko/nodes.py\nclass Tuple(Node):\n\n    def __init__(self, values, **kw):\n        self.values = tuple(values)\n        super(Tuple, self).__init__(**kw)\n\n    def __repr__(self):\n        return '({})'.format(' '.join(map(repr, self.values)))\n\n    def accept(self, visitor):\n        return visitor.visit_tuple(self)\nkinko/nodes.py\nclass Symbol(Node):\n\n    def __init__(self, name, **kw):\n        self.name = name\n        head, sep, tail = name.partition('/')\n        if sep:\n            self.ns, self.rel = head, tail\n        else:\n            self.ns, self.rel = None, name\n        super(Symbol, self).__init__(**kw)\n\n    def __repr__(self):\n        return self.name\n\n    def accept(self, visitor):\n        return visitor.visit_symbol(self)\nkinko/types.py\nclass Option(with_metaclass(OptionMeta, object)):\n    pass\nkinko/nodes.py\nclass Keyword(Node):\n\n    def __init__(self, name, **kw):\n        self.name = name\n        super(Keyword, self).__init__(**kw)\n\n    def __repr__(self):\n        return ':{}'.format(self.name)\n\n    def accept(self, visitor):\n        return visitor.visit_keyword(self)\nkinko/types.py\nclass Func(with_metaclass(FuncMeta, object)):\n    pass\nkinko/refs.py\nclass Reference(object):\n\n    def __init__(self, backref):\n        self.backref = backref\n", "answers": ["        self._root = TypeVar[None]"], "length": 1186, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "96d3a6a8d00b1872187fb51f60ee407ddf78fa068d259332"}
{"input": "import static org.junit.Assert.assertThrows;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Lists;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\nimport java.security.KeyFactory;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.spec.EncodedKeySpec;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport junit.framework.TestCase;\nimport net.oauth.jsontoken.crypto.HmacSHA256Verifier;\nimport net.oauth.jsontoken.crypto.SignatureAlgorithm;\nimport net.oauth.jsontoken.crypto.Verifier;\nimport net.oauth.jsontoken.discovery.DefaultPublicKeyLocator;\nimport net.oauth.jsontoken.discovery.IdentityServerDescriptorProvider;\nimport net.oauth.jsontoken.discovery.JsonServerInfo;\nimport net.oauth.jsontoken.discovery.VerifierProvider;\nimport net.oauth.jsontoken.discovery.VerifierProviders;\nimport net.oauth.jsontoken.exceptions.ErrorCode;\nimport net.oauth.jsontoken.exceptions.InvalidJsonTokenException;\nimport org.apache.commons.codec.binary.Base64;\nimport org.junit.function.ThrowingRunnable;\n/*\n * Copyright 2010 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.oauth.jsontoken;\n\n\n\npublic abstract class JsonTokenTestBase extends TestCase {\n\n  protected static final byte[] SYMMETRIC_KEY = \"kjdhasdkjhaskdjhaskdjhaskdjh\".getBytes();\n\n  protected static final String PRIVATE_KEY =\n      \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC6nMEXFuxTnM5+yM4Afngybf5Z\"\n          + \"89JxlchBA3Ni//Gm1/25MetzfId2Jg8NkthmRDzH6sFaoNS7n6Z6JyNJFszb2PXKBkZdem219F5k\"\n          + \"jawoHrfA1Lu8fBmGQYG/aG70aPft2eEZbY+XqW5WUlMk7vFW7BDikwBXyv/5rrFasBfPWd13xozQ\"\n          + \"9612IErWGlGMgxmB64jcTbGWMzDgzE/scSmyeQ0vQQMW8J+Nnb/yDpY7loXrVrAgZx8IBv1f9Fv3\"\n          + \"p7tirTD/vFgzxE2rIAauM/aU8zBHEyXL1NSNq0I62OAF4DLiDlcEFOvYjqoiCPQIh0NXnQy8Dcs5\"\n          + \"xHCj0e1b3X/LAgMBAAECggEBAJ9G5iQQA7xF7ZYXTITtbSgV6+/ZBTi/kEG1cUoBjL9MQZpNOlrC\"\n          + \"4lf8mgKK4LtA6OP1wfzZo1lVJeHDAAIFPOs0nm1Ft89XjMauAdcveM5xkYM7z9VL0vlddiHqQDHK\"\n          + \"WjsgKVnrwpC/I5b4A1FVxJXdPXg14igM8zioW2Y9QMVPxeUmRJxeGfvlotRlD1At1KNKg7Q2bPoi\"\n          + \"1IlRzdae6ky18x/o6FRbTo2WGRehqIAjqmwqNib3u4k/1QfEbKGShVjMtraxdlFBM7kXb/pTfhhU\"\n          + \"xlsf4xraVy2LWBLen+BAOYScd0P7vD+5oET+e4YVqILoz/WQqI9BYmTHkzj+LLECgYEA9bVjRrXq\"\n          + \"5NtO94w0T2BI9yGnZNRFbCcSocUlc6lgX7lFa6N5JvaoWF5p9CmUPPm7lxGOeSzvLKB4qv3uP/Px\"\n          + \"RQzWvAT/isKnSJ2FuKcFYGA527uJ5BlOJAtTKViYhQdYlE2g9KsjLkxJ27aF49jrkhKWqueIdJpF\"\n          + \"VfF9w+KYvVkCgYEAwm205fCRH3WEBzii2TrHqm/nVRWZ7Kxis4JppwxUslLKp33bzbHn9uOKFGfN\"\n          + \"rtXpSq9hvAcnJlJAEyVFtVNFcazE/+GbUfnrKaC3UeomjYxBk45Lcutt441gOO2SFcra7GHiNgVv\"\n          + \"fELNMo/Rr7tk8djcUcYXuDk4Kz/T2AttzcMCgYBg/Z8YtIrqmB+N3Exx4OIsm55GUPyueqYCMZ5d\"\n          + \"D8k5QBtFKByU4t0FNQ/CD/+yKiqAsa956eDnztiTNvWrTRI6XZ0OTzLIhZofMf8tKtEWgCWWtWrz\"\n          + \"HYIY/FdxhMWADaxLrnEQ49VZW0f0cRJdJK2o1amgARF+Zb9k85TflD0S0QKBgBYFlQrCT72vcs/a\"\n          + \"k19lb/4XBK23b6LF97v7VnosRF+aTwffkoje0LY/GYGsLDjUU8M40Coa6U1G3akNfLLIBsKUXg/Z\"\n          + \"ft0vIHqrkHf/vHQl4buTz2npzp2Kgs6P4g8D1f4WLCgQP4tkiZdjgM2VvR5DgNjmRgOAv6LubNE4\"\n          + \"oiw/AoGAXKfOSrbgx8JQUE7Lt6mhGvP9oTj3uiV16GgxjOtkpP3TfjsdRcmivAuekKMMKufQvGxh\"\n          + \"nX9eCYvLqJqZZwPy/002H7So3Yd1/d9ORkKetDKGjXHPDYyEPQQ+ss9OGm53XlViklXb+i9wsdDz\"\n          + \"R7tAFexSjyVKnWSDBh52t6lBtHo=\";\n\n  private static final String SERVER_INFO_DOCUMENT =\n      \"{ \\\"verification_keys\\\": {\"\n          +\n          // this is the public key that goes with the above private key\n          \"\\\"key1\\\":\\\"RSA.ALqcwRcW7FOczn7IzgB-eDJt_lnz0nGVyEEDc2L_8abX_bkx63N8h3YmDw2S2GZEPMfqwVqg1LufpnonI0kWzNvY9coGRl16bbX0XmSNrCget8DUu7x8GYZBgb9obvRo9-3Z4Rltj5epblZSUyTu8VbsEOKTAFfK__musVqwF89Z3XfGjND3rXYgStYaUYyDGYHriNxNsZYzMODMT-xxKbJ5DS9BAxbwn42dv_IOljuWhetWsCBnHwgG_V_0W_enu2KtMP-8WDPETasgBq4z9pTzMEcTJcvU1I2rQjrY4AXgMuIOVwQU69iOqiII9AiHQ1edDLwNyznEcKPR7Vvdf8s.AQAB\\\"},\"\n        + \" \"\n          +\n          // some other information that might be in the server info document.\n          \"\\\"foo\\\": \\\"bar\\\"}\";\n\n  protected VerifierProviders locators;\n  protected VerifierProviders locatorsFromRuby;\n  protected RSAPrivateKey privateKey;\n\n  protected static final String TOKEN_STRING =\n      \"eyJhbGciOiJIUzI1NiIsImtpZCI6ImtleTIifQ.eyJpc3MiOiJnb29nbGUuY29tIiwiYmFyIjoxNSwiZm9vIjoic29tZSB2YWx1ZSIsImF1ZCI6Imh0dHA6Ly93d3cuZ29vZ2xlLmNvbSIsImlhdCI6MTI3NjY2OTcyMiwiZXhwIjoxMjc2NjY5NzIzfQ.Xugb4nb5kLV3NTpOLaz9er5PhAI5mFehHst_33EUFHs\";\n  protected static final String TOKEN_STRING_BAD_SIG =\n      \"eyJhbGciOiJIUzI1NiIsImtpZCI6ImtleTIifQ.eyJpc3MiOiJnb29nbGUuY29tIiwiYmFyIjoxNSwiZm9vIjoic29tZSB2YWx1ZSIsImF1ZCI6Imh0dHA6Ly93d3cuZ29vZ2xlLmNvbSIsImlhdCI6MTI3NjY2OTcyMiwiZXhwIjoxMjc2NjY5NzIzfQ.Wugb4nb5kLV3NTpOLaz9er5PhAI5mFehHst_33EUFHs\";\n  protected static final String TOKEN_STRING_2PARTS =\n      \"eyJhbGciOiJIUzI1NiIsImtpZCI6ImtleTIifQ.eyJpc3MiOiJnb29nbGUuY29tIiwiYmFyIjoxNSwiZm9vIjoic29tZSB2YWx1ZSIsImF1ZCI6Imh0dHA6Ly93d3cuZ29vZ2xlLmNvbSIsImlhdCI6MTI3NjY2OTcyMiwiZXhwIjoxMjc2NjY5NzIzfQ\";\n  protected static final String TOKEN_STRING_UNSUPPORTED_SIGNATURE_ALGORITHM =\n      \"eyJhbGciOiJIUzUxMiIsImtpZCI6ImtleTIifQ.eyJpc3MiOiJnb29nbGUuY29tIiwiYmFyIjoxNSwiZm9vIjoic29tZSB2YWx1ZSIsImF1ZCI6Imh0dHA6Ly93d3cuZ29vZ2xlLmNvbSIsImlhdCI6MTI3NjY2OTcyMiwiZXhwIjoxMjc2NjY5NzIzfQ.44qsiZg1Hnf95N-2wNqd1htgDlE7X0BSUMMkboMcZ5QLKbmVATozMuzdoE0MAhU-IdWUuICFbzu_wcDEXDTLug\";\n  protected static final String TOKEN_STRING_CORRUPT_HEADER =\n      \"fyJhbGciOiJIUzI1NiIsImtpZCI6ImtleTIifQ.eyJpc3MiOiJnb29nbGUuY29tIiwiYmFyIjoxNSwiZm9vIjoic29tZSB2YWx1ZSIsImF1ZCI6Imh0dHA6Ly93d3cuZ29vZ2xlLmNvbSIsImlhdCI6MTI3NjY2OTcyMiwiZXhwIjoxMjc2NjY5NzIzfQ.Xugb4nb5kLV3NTpOLaz9er5PhAI5mFehHst_33EUFHs\";\n  protected static final String TOKEN_STRING_HEADER_MISSING_ALG =\n      \"eyJ3cm9uZ1BhcmFtIjoiSFMyNTYifQ.eyJpc3MiOiJnb29nbGUuY29tIiwiYmFyIjoxNSwiZm9vIjoic29tZSB2YWx1ZSIsImF1ZCI6Imh0dHA6Ly93d3cuZ29vZ2xlLmNvbSIsImlhdCI6MTI3NjY2OTcyMiwiZXhwIjoxMjc2NjY5NzIzfQ.mBtVwsgT2uZJqu2zyUzbCXF4tfo8jSSlOeRI0Tv222o\";\n  protected static final String TOKEN_FROM_RUBY =\n      \"eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJoZWxsbyI6ICJ3b3JsZCJ9.tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8\";\n\n  protected static final Duration SKEW = Duration.ofMinutes(1);\n  protected FakeClock clock = new FakeClock(SKEW);\n\n  /**\n   * Convert encoded tokens into a more human-readable form without verifying. Useful for logging.\n   */\n  protected static String decodeTokenForHumans(String encodedToken) {\n    String[] pieces = encodedToken.split(Pattern.quote(\".\"));\n    if (pieces.length != 3) {\n      return \"invalid token (3 segments expected): \" + encodedToken;\n    }\n    for (int i = 0; i < 3; i++) {\n      pieces[i] = new String(Base64.decodeBase64(pieces[i].getBytes()));\n    }\n    return pieces[0] + \".\" + pieces[1] + \".\" + pieces[2];\n  }\n\n  @Override\n  protected void setUp() throws Exception {", "context": "src/main/java/net/oauth/jsontoken/exceptions/InvalidJsonTokenException.java\npublic final class InvalidJsonTokenException extends Exception {\n  private final ErrorCode errorCode;\n\n  public InvalidJsonTokenException(ErrorCode errorCode) {\n    this.errorCode = errorCode;\n  }\n\n  public InvalidJsonTokenException(ErrorCode errorCode, String message) {\n    super(message);\n    this.errorCode = errorCode;\n  }\n\n  public InvalidJsonTokenException(ErrorCode errorCode, Throwable cause) {\n    super(cause);\n    this.errorCode = errorCode;\n  }\n\n  public ErrorCode getErrorCode() {\n    return errorCode;\n  }\n}\nsrc/main/java/net/oauth/jsontoken/discovery/IdentityServerDescriptorProvider.java\npublic class IdentityServerDescriptorProvider implements ServerDescriptorProvider {\n\n  /*\n   * (non-Javadoc)\n   * @see net.oauth.jsontoken.discovery.ServerDescriptorProvider#getServerDescriptor(java.lang.String)\n   */\n  @Override\n  public URI getServerDescriptor(String issuer) {\n    return URI.create(issuer);\n  }\n}\nsrc/main/java/net/oauth/jsontoken/discovery/DefaultPublicKeyLocator.java\npublic class DefaultPublicKeyLocator implements VerifierProvider {\n\n  private final ServerDescriptorProvider descriptorProvider;\n  private final ServerInfoResolver descriptorResolver;\n\n  /**\n   * Public constructor.\n   *\n   * @param descriptorProvider A {@link ServerDescriptorProvider} that maps issuer ids to server\n   *     descriptors (URLs).\n   * @param resolver A {@link ServerInfoResolver}, i.e., an object that can fetch and parse a server\n   *     info document, given a server descriptor.\n   */\n  public DefaultPublicKeyLocator(\n      ServerDescriptorProvider descriptorProvider, ServerInfoResolver resolver) {\n    this.descriptorProvider = descriptorProvider;\n    this.descriptorResolver = resolver;\n  }\n\n  /*\n   * (non-Javadoc)\n   * @see net.oauth.jsontoken.discovery.VerifierProvider#findVerifier(java.lang.String, java.lang.String)\n   */\n  @Override\n  public List<Verifier> findVerifier(String issuer, String keyId) {\n    URI serverDescriptor = descriptorProvider.getServerDescriptor(issuer);\n    Verifier rsaVerifier =\n        new RsaSHA256Verifier(\n            descriptorResolver.resolve(serverDescriptor).getVerificationKey(keyId));\n    return Lists.newArrayList(rsaVerifier);\n  }\n}\nsrc/main/java/net/oauth/jsontoken/discovery/VerifierProviders.java\npublic class VerifierProviders {\n\n  private final Map<SignatureAlgorithm, VerifierProvider> map = Maps.newHashMap();\n\n  /** Sets a new {@link VerifierProvider} for the given {@link SignatureAlgorithm}. */\n  public void setVerifierProvider(SignatureAlgorithm alg, VerifierProvider provider) {\n    map.put(alg, provider);\n  }\n\n  /** Returns the {@link VerifierProvider} for the given {@link SignatureAlgorithm}. */\n  @Nullable\n  public VerifierProvider getVerifierProvider(SignatureAlgorithm alg) {\n    return map.get(alg);\n  }\n}\nsrc/main/java/net/oauth/jsontoken/crypto/SignatureAlgorithm.java\npublic enum SignatureAlgorithm {\n  HS256(\"SHA256\"),\n  HS1(\"SHA1\"),\n  RS256(\"SHA256\"),\n  RS1(\"SHA1\");\n\n  private final String hashAlg;\n\n  private SignatureAlgorithm(String hashAlg) {\n    this.hashAlg = hashAlg;\n  }\n\n  /** What the signature algorithm is named in the \"alg\" parameter in a JSON Token's envelope. */\n  public String getNameForJson() {\n    return name();\n  }\n\n  /**\n   * Returns the hash algorithm that should be used when hashing data. When large pieces of data are\n   * to be included in a JSON Token's payload, it sometimes might make sense to include the hash of\n   * the data instead. If an issuer wants to do that, they should use this hash algorithm to hash\n   * the data.\n   */\n  public String getHashAlgorithm() {\n    return hashAlg;\n  }\n\n  /** Given the name of the algorithm in the envelope, returns the corresponding enum instance. */\n  public static SignatureAlgorithm getFromJsonName(String name) {\n    return SignatureAlgorithm.valueOf(name);\n  }\n}\nsrc/main/java/net/oauth/jsontoken/exceptions/ErrorCode.java\npublic enum ErrorCode {\n\n  /** The header is missing required parameters. */\n  BAD_HEADER,\n\n  /** Signature failed verification. */\n  BAD_SIGNATURE,\n\n  /** IAT is after EXP or IAT is in the future */\n  BAD_TIME_RANGE,\n\n  /** IAT and EXP are both in the past. */\n  EXPIRED_TOKEN,\n\n  /**\n   * The token is in an illegal state because of incorrect use of the library. If this error code\n   * appears, immediately rethrow as an {@link IllegalStateException}.\n   */\n  ILLEGAL_STATE,\n\n  /** Token string is corrupted and/or does not contain three components. */\n  MALFORMED_TOKEN_STRING,\n\n  /** There are no verifiers available for a given issuer and keyId. */\n  NO_VERIFIER,\n\n  /** Generic catch-all for exceptions with scenarios that are not pre-defined. */\n  UNKNOWN,\n\n  /** The signature algorithm is not supported or is unknown. */\n  UNSUPPORTED_ALGORITHM\n}\nsrc/main/java/net/oauth/jsontoken/discovery/JsonServerInfo.java\npublic class JsonServerInfo implements ServerInfo {\n\n  @SerializedName(\"verification_keys\")\n  private final Map<String, String> verificationKeys = Maps.newHashMap();\n\n  /**\n   * Parses a JSON-formatted server info document and returns it as a {@link JsonServerInfo} object.\n   *\n   * @param json the contents of the JSON-formatted server info document.\n   */\n  public static JsonServerInfo getDocument(String json) {\n    return new Gson().fromJson(json, JsonServerInfo.class);\n  }\n\n  /*\n   * (non-Javadoc)\n   * @see net.oauth.jsontoken.discovery.ServerInfo#getVerificationKey(java.lang.String)\n   */\n  @Override\n  public PublicKey getVerificationKey(String keyId) {\n    String magicKey = verificationKeys.get(keyId);\n    if (magicKey == null) {\n      return null;\n    } else {\n      return new MagicRsaPublicKey(magicKey).getKey();\n    }\n  }\n}\nsrc/main/java/net/oauth/jsontoken/crypto/HmacSHA256Verifier.java\npublic class HmacSHA256Verifier implements Verifier {\n\n  private final HmacSHA256Signer signer;\n\n  /**\n   * Public constructor.\n   *\n   * @param verificationKey the HMAC verification key to be used for signature verification.\n   * @throws InvalidKeyException if the verificationKey cannot be used as an HMAC key.\n   */\n  public HmacSHA256Verifier(byte[] verificationKey) throws InvalidKeyException {\n    signer = new HmacSHA256Signer(\"verifier\", null, verificationKey);\n  }\n\n  /*\n   * (non-Javadoc)\n   * @see net.oauth.jsontoken.crypto.Verifier#verifySignature(byte[], byte[])\n   */\n  @Override\n  public void verifySignature(byte[] source, byte[] signature) throws SignatureException {\n    byte[] comparison = signer.sign(source);\n    if (!compareBytes(signature, comparison)) {\n      throw new SignatureException(\"signature did not verify\");\n    }\n  }\n\n  /**\n   * Performs a byte-by-byte comparison of {@code first} and {@code second} parameters. This method\n   * will \"NOT\" short-circuit the comparison once it has detected a byte difference in order to\n   * defend against a \"timing attack\".\n   *\n   * @param first the first byte array used in the comparison\n   * @param second the second byte array used in the comparison\n   * @return {@code true} if the {@code first} and {@code second} byte arrays are equal otherwise\n   *     {@code false}\n   */\n  private boolean compareBytes(byte[] first, byte[] second) {\n    if (first == null || second == null) {\n      return (first == second);\n    } else if (first.length != second.length) {\n      return false;\n    } else {\n      byte result = 0;\n      for (int i = 0; i < first.length; i++) {\n        result |= first[i] ^ second[i];\n      }\n      return (result == 0);\n    }\n  }\n}\nsrc/main/java/net/oauth/jsontoken/crypto/Verifier.java\npublic interface Verifier {\n\n  /**\n   * Verifies a signature on an array of bytes.\n   *\n   * @param source The bytes that were signed.\n   * @param signature The signature on the bytes.\n   * @throws SignatureException If the signature doesn't match, or if some other error occurred.\n   */\n  void verifySignature(byte[] source, byte[] signature) throws SignatureException;\n}\nsrc/main/java/net/oauth/jsontoken/discovery/VerifierProvider.java\npublic interface VerifierProvider {\n\n  /**\n   * Returns the {@code List<Verifier>} that represents a certain verification key, given the key's\n   * id and its issuer.\n   *\n   * @param issuer the id of the issuer that's using the key.\n   * @param keyId the id of the key, if keyId mismatches, return a list of possible verification\n   *     keys.\n   * @return a {@code List<Verifier>} object that represents the verification key.\n   */\n  List<Verifier> findVerifier(String issuer, String keyId);\n}\n", "answers": ["    final Verifier hmacVerifier = new HmacSHA256Verifier(SYMMETRIC_KEY);"], "length": 1353, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "f81c4342fdf64aab3c695157e30a0a0879ff2586d042f718"}
{"input": "package io.github.duckasteroid.progress.slf4j;\nimport io.github.duckasteroid.progress.Configuration;\nimport io.github.duckasteroid.progress.ProgressMonitor;\nimport io.github.duckasteroid.progress.base.BaseProgressMonitor;\nimport io.github.duckasteroid.progress.base.event.ProgressMonitorListener;\nimport io.github.duckasteroid.progress.base.event.ProgressMonitorListenerFactory;\nimport io.github.duckasteroid.progress.base.event.ProgressUpdateType;\nimport io.github.duckasteroid.progress.base.format.CompoundFormat;\nimport io.github.duckasteroid.progress.base.format.ProgressFormat;\nimport io.github.duckasteroid.progress.base.format.SimpleProgressFormat;\nimport io.github.duckasteroid.progress.slf4j.util.LruCache;\nimport io.github.duckasteroid.progress.slf4j.util.SingleLevelMap;\nimport java.util.Collections;\nimport java.util.Map;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/**\n * Factory for monitors that route updates to SLF4J logger instances.\n * The factory uses the following configuration parameters:\n * <ul>\n *   <li><pre>io.github.duckasteroid.progress.slf4j.root.logger.name</pre>The name of the root SLF4J\n *   logger used to receive messages when monitor name begins with <pre>#</pre>. Default is\n *   <pre>io.github.duckasteroid.progress.ProgressMonitor</pre></li>\n *   <li><pre>io.github.duckasteroid.progress.slf4j.cacheSize</pre>. How may instances of listeners\n *   to cache (rather than re-create when requested). Default 100.</li>\n *   <li><pre>io.github.duckasteroid.progress.slf4j.format</pre>A format string that is parsed to\n *   create a {@link ProgressFormat} instance used to format monitor updates being sent to loggers.\n *   Default is {@link SimpleProgressFormat#DEFAULT}</li>\n * </ul>\n */\npublic class Slf4jFactory implements ProgressMonitorListenerFactory {\n  private static final Logger LOG = LoggerFactory.getLogger(Slf4jFactory.class);\n\n  private static final String NS = \"io.github.duckasteroid.progress.slf4j.\";\n  public static final String ROOT_LOGGER_NAME = NS + \"root.logger.name\";\n  public static final String CACHE_SIZE = NS + \".cacheSize\";\n  public static final String FORMAT = NS + \".format\"; //NOPMD - case is different\n  private static final int DEFAULT_CACHE_SIZE = 100;", "context": "api/src/main/java/io/github/duckasteroid/progress/ProgressMonitor.java\npublic interface ProgressMonitor extends Comparable<ProgressMonitor>, Closeable {\n  /**\n   * The parent monitor of this monitor (if any).\n   * @return the parent monitor or <code>null</code> if this is the root\n   */\n  ProgressMonitor getParent();\n\n  /**\n   * The path from this monitor to the root through all parent contexts in order leaf to root.\n   * @return a list of parent contexts (all the way to the root); an empty list if this is the\n   *         root.\n   */\n  List<ProgressMonitor> getContext();\n\n  /**\n   * The name of this task set by the {@link #getParent() parent} (if any).\n   * @return the task name (or empty String)\n   */\n  String getTaskName();\n\n  /**\n   * The last {@link #setStatus(String) notified} status.\n   * @return the task status (or empty String)\n   */\n  String getStatus();\n\n  /**\n   * Notify users (if possible) of the status of this task (without changing the fraction done).\n   * @param status The task status notification message\n   */\n  void setStatus(String status);\n\n  /**\n   * The \"size\" of this task - by default this is <code>1</code>.\n   * @return the \"relative\" size of this task\n   */\n  long getSize();\n\n  /**\n   * Modify the overall size of this task. If the current {@link #getWorkDone()} is already more\n   * than this then the monitor will also be marked {@link #isDone() done}.\n   * Changing the size of a \"done\" monitor has no effect, it remains done...\n   * The size cannot be modified to less than 1; the value defaults to this if out of range.\n   * Note: modifying the size of a subtask - does not influence the work it contributes to the\n   * parent task\n   * @param size the new size of this task\n   */\n  void setSize(long size);\n\n  /**\n   * The unit of work in this monitor (default empty).\n   * Sub tasks will inherit this unit.\n   * @return the unit as set in {@link #setUnit(String)}\n   */\n  String getUnit();\n\n  /**\n   * Modify the unit of this task, only new subtasks will pick up this unit.\n   * @param unit the new unit\n   */\n  void setUnit(String unit);\n\n  /**\n   * The current amount of work done. This is always a positive number or zero.\n   * It may be more than the size of this task (which simply means the task is done)\n   * @return the current amount of work done\n   */\n  long getWorkDone();\n\n  /**\n   * Log an amount of work and (optionally) update the status in a single operation.\n   * This operation has no effect if the monitor is {@linkplain #isDone() done} or\n   * {@linkplain #isCancelled() cancelled}.\n   * If this work takes the {@linkplain #getWorkDone() total work done} past the {@linkplain\n   * #getSize() size} then the monitor will be marked done.\n   * If the amount of work is less than zero, it will default to zero\n   * @param amount the amount of work done\n   * @param status a status message to set (if not <code>null</code>)\n   * @return the value of {@link #getWorkDone()} as a result of this new work\n   */\n  long worked(long amount, String status);\n\n  /**\n   * Log an amount of work with no (null) corresponding status update.\n   * This is the same as calling <code>worked(amount, null)</code>\n   * @see #worked(long, String)\n   * @param amount the amount of work done\n   * @return the value of {@link #getWorkDone()} as a result of this new work\n   */\n  long worked(long amount);\n\n  /**\n   * Called to set the work done to the size of the task (at this point in time).\n   * Subsequent modifications to {@link #getSize()} may alter this, but the progress will only be\n   * done once\n   */\n  void done();\n\n  /**\n   * Has the work reported completed (i.e. {@link #getWorkDone()} &gt;= {@link #getSize()}} )\n   * NOTE: This is a one time event, if the work done is ever &gt;= the size - subsequent\n   * increases in the size don't \"undo\" the monitor, it remains done.\n   * @return true if the work was complete/done\n   */\n  boolean isDone();\n\n  @Override\n  default void close() {\n    done();\n  }\n\n  /**\n   * Has the task being reported been cancelled. This is used as a signal between the class doing\n   * progress and the outside world that may wish it to stop before it is complete.\n   * The cancelled state has no appreciable impact on the rest of the workings of the monitor -\n   * it's for the receiver and the publisher of the progress to decide what to do with it.\n   * @return true if cancelled\n   */\n  boolean isCancelled();\n\n  /**\n   * Change the cancelled state of the task being monitored (and that of all sub-tasks).\n   * @see #isCancelled()\n   * @param cancelled the new cancelled state\n   */\n  void setCancelled(boolean cancelled);\n\n  /**\n   * Create a sub task of this - which when {@linkplain #isDone() done} equates to the given\n   * amount of work in this monitor.\n   * NOTE: The progress of the subtask is not reflected in this monitor until it is\n   * {@link #done()}, only then is the total work posted on this monitor.\n   * @param name the name of the sub task\n   * @param work the amount of work the new sub task will contribute to this monitor when done\n   * @return a new progress monitor for the sub task\n   * @throws IllegalStateException If this task is already {@link #isDone() done} or is\n   *                 {@link #isCancelled() cancelled}\n   */\n  ProgressMonitor newSubTask(String name, long work);\n\n  /**\n   * Create a sub task of this - which when {@link #isDone()} equates to a single (1) unit of work\n   * in this task.\n   * Equivalent to calling {@link #newSubTask(String, long)} with the given <code>name</code> and\n   * a <code>size = 1</code>\n   * @param name the name of the sub task\n   * @return a new progress monitor for the sub task\n   * @throws IllegalStateException If this task is already {@link #isDone() done} or is\n   *                 {@link #isCancelled() cancelled}\n   */\n  ProgressMonitor newSubTask(String name);\n\n  /**\n   * The {@link #getWorkDone()} as a fraction of the {@link #getSize()} for this task in the range\n   * 0 to 1.\n   * NOTE: This value can never be less than 0 or more than 1\n   * @return the fraction done\n   */\n  double getFractionDone();\n\n\n}\nclient/src/main/java/io/github/duckasteroid/progress/Configuration.java\npublic class Configuration {\n  private static final Configuration singleton = load();\n  private final transient Properties source;\n\n  public Configuration(Properties source) {\n    this.source = source;\n  }\n\n  private static Configuration load() {\n    // FIXME Attempt to load config files from classpath a la logging frameworks\n    return new Configuration(System.getProperties());\n  }\n\n  public static Configuration getInstance() {\n    return singleton;\n  }\n\n  public Optional<String> getStringValue(String prop) {\n    return Optional.ofNullable(source.getProperty(prop));\n  }\n\n  public boolean hasValueFor(String name) {\n    return getStringValue(name).isPresent();\n  }\n\n  public <T> T getValue(String name, Function<String, T> parser, T defaultValue) {\n    return getStringValue(name).map(parser::apply).orElse(defaultValue);\n  }\n\n  public Integer getInteger(String name, Integer defaultValue) {\n    return getValue(name, Integer::parseInt, defaultValue);\n  }\n\n  public Long getLong(String name, Long defaultValue) {\n    return getValue(name, Long::parseLong, defaultValue);\n  }\n\n  public Boolean getBoolean(String name, Boolean defaultValue) {\n    return getValue(name, Boolean::parseBoolean, defaultValue);\n  }\n\n  public String getString(String name, String defaultValue) {\n    return getValue(name, Function.identity(), defaultValue);\n  }\n\n}\nslf4j/src/main/java/io/github/duckasteroid/progress/slf4j/util/SingleLevelMap.java\npublic class SingleLevelMap implements Map<ProgressUpdateType, Slf4JProgress.Level> {\n  private final transient Slf4JProgress.Level value;\n\n  public SingleLevelMap(Slf4JProgress.Level value) {\n    this.value = value;\n  }\n\n  @Override\n  public int size() {\n    return ProgressUpdateType.values().length;\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return false;\n  }\n\n  @Override\n  public boolean containsKey(Object key) {\n    return key != null && key instanceof ProgressUpdateType;\n  }\n\n  @Override\n  public boolean containsValue(Object value) {\n    return this.value.equals(value);\n  }\n\n  @Override\n  public Slf4JProgress.Level get(Object key) {\n    return value;\n  }\n\n  @Override\n  public Slf4JProgress.Level put(ProgressUpdateType key, Slf4JProgress.Level value) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public Slf4JProgress.Level remove(Object key) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public void putAll(Map<? extends ProgressUpdateType, ? extends Slf4JProgress.Level> m) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public void clear() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public Set<ProgressUpdateType> keySet() {\n    return Set.of(ProgressUpdateType.values());\n  }\n\n  @Override\n  public Collection<Slf4JProgress.Level> values() {\n    return Collections.singleton(value);\n  }\n\n  @Override\n  public Set<Entry<ProgressUpdateType, Slf4JProgress.Level>> entrySet() {\n    return keySet().stream().map(k -> new Entry<ProgressUpdateType, Slf4JProgress.Level>() {\n      @Override\n      public ProgressUpdateType getKey() {\n        return k;\n      }\n\n      @Override\n      public Slf4JProgress.Level getValue() {\n        return value;\n      }\n\n      @Override\n      public Slf4JProgress.Level setValue(Slf4JProgress.Level value) {\n        throw new UnsupportedOperationException();\n      }\n    }).collect(Collectors.toSet());\n  }\n}\nclient/src/main/java/io/github/duckasteroid/progress/base/BaseProgressMonitor.java\npublic final class BaseProgressMonitor extends AbstractProgressMonitor implements ProgressMonitor {\n\n  /**\n   * A set of listeners.\n   */\n  protected final transient List<ProgressMonitorListener> listeners = new CopyOnWriteArrayList<>();\n  /**\n   * Has cancellation been requested.\n   */\n  protected AtomicBoolean cancelled = new AtomicBoolean(false);\n\n  public BaseProgressMonitor() {\n    this(\"\");\n  }\n\n  public BaseProgressMonitor(final String name) {\n    super(0, name);\n  }\n\n  public BaseProgressMonitor(final String name, final long size) {\n    this(name);\n    this.setSize(size);\n  }\n\n  /**\n   * Create a new progress monitor.\n   * @param name the name of the monitor\n   * @param size the size (units of work)\n   * @param listeners any listeners for the monitor\n   */\n  public BaseProgressMonitor(final String name, final long size,\n                             Collection<ProgressMonitorListener> listeners) {\n    this(name);\n    this.setSize(size);\n    this.listeners.addAll(listeners);\n  }\n\n  public BaseProgressMonitor(final long size) {\n    this();\n    this.setSize(size);\n  }\n\n  public void addProgressMonitorListener(ProgressMonitorListener listener) {\n    listeners.add(listener);\n  }\n\n  public void removeProgressMonitorListener(ProgressMonitorListener listener) {\n    listeners.remove(listener);\n  }\n\n  @Override\n  @SuppressWarnings(\"PMD.DataflowAnomalyAnalysis\")\n  public void notifyListeners(final ProgressMonitor source, final ProgressUpdateType updateType) {\n    final ProgressMonitorEvent event = new ProgressMonitorEvent(this, source, updateType);\n    // iterate the listeners (if any)\n    for (ProgressMonitorListener listener : listeners) {\n      listener.logUpdate(event);\n    }\n  }\n\n  @Override\n  protected void onDone() {\n    // nothing to do!\n  }\n\n  /**\n   * A list of all the active monitors in this monitor and all children that are active.\n   * As soon as a monitor is marked done - all children are removed from this list.\n   *\n   * @return the list of all active monitors (in the order they were created - with their children\n   *         after them)\n   */\n  public List<ProgressMonitor> getAllActive() {\n    ArrayList<ProgressMonitor> active = new ArrayList<>(children.size() + 1);\n    appendActive(active);\n    return active;\n  }\n\n  /**\n   * Always returns <code>null</code>.\n   */\n  public ProgressMonitor getParent() {\n    return null;\n  }\n\n  /**\n   * Always returns an empty list.\n   */\n  public List<ProgressMonitor> getContext() {\n    return Collections.emptyList();\n  }\n\n  public boolean isCancelled() {\n    return cancelled.get();\n  }\n\n  @Override\n  public void setCancelled(boolean cancelled) {\n    this.cancelled.set(cancelled);\n    if (cancelled) {\n      notifyListeners(this, ProgressUpdateType.CANCELLED);\n    }\n  }\n\n\n}\nclient/src/main/java/io/github/duckasteroid/progress/base/event/ProgressMonitorListenerFactory.java\npublic interface ProgressMonitorListenerFactory {\n  /**\n   * Create a {@link ProgressMonitorListener} for the named progress.\n   *\n   * @param name the name of the progress\n   * @return a {@link ProgressMonitorListener} instance for the name\n   */\n  ProgressMonitorListener createProgressMonitorListener(String name);\n}\nslf4j/src/main/java/io/github/duckasteroid/progress/slf4j/util/LruCache.java\npublic class LruCache extends LinkedHashMap<String, ProgressMonitorListener> {\n  private static final long serialVersionUID = 71308712074L;\n\n  private final transient int cacheSize;\n\n  public LruCache(int size) {\n    super(size, 0.75f, true);\n    this.cacheSize = size;\n  }\n\n  @Override\n  protected boolean removeEldestEntry(Map.Entry<String, ProgressMonitorListener> eldest) {\n    return size() >= cacheSize;\n  }\n}\nformat/src/main/java/io/github/duckasteroid/progress/base/format/ProgressFormat.java\npublic interface ProgressFormat {\n  /**\n   * Given the monitor produce a string form.\n   *\n   * @param monitor the monitor to format\n   * @return the string format\n   */\n  String format(ProgressMonitor monitor);\n}\nclient/src/main/java/io/github/duckasteroid/progress/base/event/ProgressUpdateType.java\npublic enum ProgressUpdateType {\n  /**\n   * A status change.\n   */\n  STATUS,\n  /**\n   * Work done (the most common event).\n   */\n  WORK,\n  /**\n   * Progress cancelled.\n   */\n  CANCELLED,\n  /**\n   * Progress done.\n   */\n  DONE;\n\n  /**\n   * Parse the string form into an enum.\n   *\n   * @param s the string form\n   * @return corresponding enum or null\n   * @see #name()\n   */\n  public static ProgressUpdateType parse(String s) {\n    for (ProgressUpdateType type : values()) {\n      if (type.name().equals(s)) {\n        return type;\n      }\n    }\n    return null;\n  }\n}\nformat/src/main/java/io/github/duckasteroid/progress/base/format/SimpleProgressFormat.java\npublic class SimpleProgressFormat implements ProgressFormat {\n  /**\n   * A default (everything on) format for monitors.\n   */\n  public static final ProgressFormat DEFAULT =\n      createSimpleProgressFormat(true, true, true, true, true, true);\n\n  /**\n   * include a <code>&gt;</code> separated list of parents.\n   */\n  private final transient boolean showParents;\n\n  private final transient ProgressFormat format; //NOPMD\n\n  private SimpleProgressFormat(boolean showParents, ProgressFormat format) {\n    this.showParents = showParents;\n    this.format = format;\n  }\n\n  /**\n   * Create a simple progress format.\n   * @param showParents show parent monitors\n   * @param showTask show task name\n   * @param showWork show work done absolute\n   * @param showUnit show work unit\n   * @param showPercent show percent work done\n   * @param showStatus show status message\n   * @return a new {@link SimpleProgressFormat}\n   */\n  public static SimpleProgressFormat createSimpleProgressFormat(boolean showParents,\n                                                                boolean showTask, boolean showWork,\n                                                                boolean showUnit,\n                                                                boolean showPercent,\n                                                                boolean showStatus) {\n    ArrayList<FormatElement> elements = new ArrayList<>(8);\n    if (showTask) {\n      elements.add(new TaskName());\n    }\n    if (showWork) {\n      if (!elements.isEmpty()) {\n        elements.add(StaticString.CONDITIONAL_WHITESPACE);\n      }\n      elements.add(new StringWrapper(\"[\", new Fraction(), \"]\"));\n    }\n    if (showUnit) {\n      if (!elements.isEmpty()) {\n        elements.add(StaticString.CONDITIONAL_WHITESPACE);\n      }\n      elements.add(new Unit());\n    }\n    if (showPercent) {\n      if (!elements.isEmpty()) {\n        elements.add(StaticString.CONDITIONAL_WHITESPACE);\n      }\n      elements.add(new StringWrapper(\"(\", new Percentage(), \")\"));\n    }\n    if (showStatus) {\n      if (!elements.isEmpty()) {\n        elements.add(new StaticString(\" - \", false));\n      }\n      elements.add(new Status());\n    }\n    return new SimpleProgressFormat(showParents, new CompoundFormat(elements));\n  }\n\n  @Override\n  public String format(ProgressMonitor monitor) {\n    final StringBuilder sb = new StringBuilder();\n\n    if (showParents && monitor.getParent() != null) {\n      // reurse\n      String parent = format(monitor.getParent());\n      sb.append(parent).append(\"> \");\n    }\n\n    sb.append(format.format(monitor));\n\n    return sb.toString();\n  }\n}\nformat/src/main/java/io/github/duckasteroid/progress/base/format/CompoundFormat.java\npublic class CompoundFormat implements ProgressFormat {\n\n  public static CompoundFormat MAXIMAL = new CompoundFormat(new FormatElement[] {\n      new TaskName(), StaticString.CONDITIONAL_WHITESPACE,\n      new Spinner(Spinner.SPINNER_SLASHES), StaticString.WHITESPACE,\n      new Percentage(), StaticString.WHITESPACE,\n      StringWrapper.wrap(\"[\", new ProgressBar(50, BAR_EQUALS), \"]\"), StaticString.WHITESPACE,\n      new Fraction(), StaticString.WHITESPACE,\n      StringWrapper.prefix(\"- \", new Status())\n  });\n  private final List<FormatElement> elements = new ArrayList<>(7); //NOPMD - method clash\n\n  public CompoundFormat(FormatElement... elements) {\n    this(Arrays.asList(elements));\n  }\n\n  public CompoundFormat(Collection<FormatElement> elements) {\n    this.elements.addAll(elements);\n  }\n\n  @SuppressWarnings(\"PMD.DataflowAnomalyAnalysis\")\n  static List<FormatElement> parse(String config,\n                                   Map<String, Function<String, FormatElement>> helpers) {\n    LinkedList<FormatElement> result = new LinkedList<>();\n    StringTokenizer segments = new StringTokenizer(config, \"%\", true);\n\n    ParseState state = ParseState.TEXT;\n    int pos = 0;\n    while (segments.hasMoreTokens()) {\n      String s = segments.nextToken();\n      pos += s.length();\n      if (\"%\".equals(s)) {\n        if (state == ParseState.TEXT) {\n          state = ParseState.ENTITY;\n        } else {\n          state = ParseState.TEXT;\n        }\n        continue; // skip...\n      }\n\n      switch (state) {\n        default:\n        case TEXT:\n          FormatElement string = new StaticString(s);\n          add(string, result);\n          break;\n        case ENTITY:\n          String[] split = s.split(\":\");\n          Function<String, FormatElement> elementBuilder = helpers.get(split[0]);\n          FormatElement formatElement = elementBuilder.apply(split.length > 1 ? split[1] : \"\");\n          add(formatElement, result);\n          break;\n      }\n    }\n    return result;\n  }\n\n  public static CompoundFormat parse(String s) {\n    return new CompoundFormat(parse(s, FormatParser.loadParsers()));\n  }\n\n  private static void add(FormatElement formatElement, LinkedList<FormatElement> result) {\n    if (formatElement != null) {\n      if (result.size() > 0) {\n        FormatElement previous = result.getLast();\n        if (previous instanceof FormatElement.Wrapping) {\n          // already wrapping?\n          if (!((FormatElement.Wrapping) previous).isWrapping()) {\n            ((FormatElement.Wrapping) previous).setWrapped(formatElement);\n            return;\n          }\n        }\n      }\n      // add the\n      result.add(formatElement);\n    }\n  }\n\n  @Override\n  public String format(ProgressMonitor source) {\n    StringBuilder string = new StringBuilder();\n    for (FormatElement fe : elements) {\n      fe.appendTo(string, source);\n    }\n    return string.toString();\n  }\n\n  public List<FormatElement> elements() {\n    return Collections.unmodifiableList(elements);\n  }\n\n  private enum ParseState {\n    TEXT, ENTITY\n  }\n\n}\nclient/src/main/java/io/github/duckasteroid/progress/base/event/ProgressMonitorListener.java\npublic interface ProgressMonitorListener {\n  /**\n   * Called when the supplied progress monitor has an update.\n   *\n   * @param event The event object\n   */\n  default void logUpdate(ProgressMonitorEvent event) {\n  }\n\n  ;\n}\n", "answers": ["  private final transient Map<String, ProgressMonitorListener> cache = new LruCache(getCacheSize());"], "length": 2514, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "b17456c5d586663c22b6d7f85f55ea076645fbc26390d24f"}
{"input": "import logging\nimport operator\nimport pytest\nfrom bloop.conditions import ConditionRenderer\nfrom bloop.exceptions import InvalidModel, InvalidStream\nfrom bloop.models import (\n    BaseModel,\n    Column,\n    GlobalSecondaryIndex,\n    IMeta,\n    Index,\n    LocalSecondaryIndex,\n    bind_column,\n    bind_index,\n    model_created,\n    object_modified,\n    unbind,\n    unpack_from_dynamodb,\n)\nfrom bloop.types import (\n    UUID,\n    Boolean,\n    DateTime,\n    Integer,\n    String,\n    Timestamp,\n    Type,\n)\nfrom ..helpers.models import User, VectorModel\n    (operator.ne, \"!=\"),\n    (operator.eq, \"==\"),\n    (operator.lt, \"<\"),\n    (operator.le, \"<=\"),\n    (operator.gt, \">\"),\n    (operator.ge, \">=\")\n]\n\n\n@pytest.fixture\ndef unpack_kwargs(engine):\n    return {\n        \"attrs\": {\"name\": {\"S\": \"numberoverzero\"}},\n        \"expected\": {User.name, User.joined},\n        \"model\": User,\n        \"engine\": engine,\n        \"context\": {\"engine\": engine, \"extra\": \"foo\"},\n    }\n\n\n# BASE MODEL =============================================================================================== BASE MODEL\n\n\ndef test_default_model_init():\n    \"\"\"Missing attributes are set to `None`\"\"\"\n    user = User(id=\"user_id\", email=\"user@domain.com\")\n    assert user.id == \"user_id\"\n    assert user.email == \"user@domain.com\"\n    assert not hasattr(user, \"name\")\n\n\ndef test_load_default_init(engine):\n    \"\"\"The default model loader uses cls.__new__(cls) method\"\"\"\n    init_called = False\n\n    class Blob(BaseModel):\n        def __init__(self, *args, **kwargs):\n            nonlocal init_called\n            # No args, kwargs provided to custom init function\n            assert not args\n            assert not kwargs\n            init_called = True\n            super().__init__(**kwargs)\n        id = Column(String, hash_key=True)\n        data = Column(String)\n    engine.bind(Blob)\n\n    assert isinstance(Blob.Meta.init(), Blob)\n\n    blob = {\n        \"id\": {\"S\": \"foo\"},\n        \"data\": {\"S\": \"data\"},\n        \"extra_field\": {\"N\": \"0.125\"}\n    }\n\n    unpack_from_dynamodb(attrs=blob, expected=Blob.Meta.columns, model=Blob, engine=engine)\n\n    assert init_called is False\n\n\ndef test_meta_read_write_units():\n    \"\"\"If `read_units` or `write_units` is missing from a model's Meta, it defaults to None until bound\"\"\"\n    class Model(BaseModel):\n        id = Column(UUID, hash_key=True)\n\n    assert Model.Meta.write_units is None\n    assert Model.Meta.read_units is None\n\n    class Other(BaseModel):\n        class Meta:\n            read_units = 2\n            write_units = 3\n        id = Column(UUID, hash_key=True)\n\n    assert Other.Meta.write_units == 3\n    assert Other.Meta.read_units == 2\n\n\ndef test_meta_indexes_columns():\n    \"\"\"An index should not be considered a Column, even if it subclasses\"\"\"\n    assert User.by_email not in set(User.Meta.columns)\n    assert User.by_email in set(User.Meta.indexes)\n\n\ndef test_invalid_model_keys():\n    with pytest.raises(InvalidModel):\n        class DoubleHash(BaseModel):\n            hash1 = Column(UUID, hash_key=True)\n            hash2 = Column(UUID, hash_key=True)\n\n    with pytest.raises(InvalidModel):\n        class DoubleRange(BaseModel):\n            id = Column(UUID, hash_key=True)\n            range1 = Column(UUID, range_key=True)\n            range2 = Column(UUID, range_key=True)\n\n    with pytest.raises(InvalidModel):\n        class NoHash(BaseModel):\n            other = Column(UUID, range_key=True)\n\n    with pytest.raises(InvalidModel):\n        class SharedHashRange(BaseModel):\n            both = Column(UUID, hash_key=True, range_key=True)\n\n\ndef test_invalid_model_duplicate_dynamo_name():\n    \"\"\"Two columns have the same dynamo_name, which is ambiguous\"\"\"\n    with pytest.raises(InvalidModel):\n        class SharedDynamoName(BaseModel):\n            class Meta:\n                abstract = True\n            id = Column(UUID, hash_key=True)\n            first = Column(String, dynamo_name=\"shared\")\n            second = Column(Integer, dynamo_name=\"shared\")\n\n\ndef test_invalid_local_index():\n    with pytest.raises(InvalidModel):\n        class InvalidLSI(BaseModel):\n            id = Column(UUID, hash_key=True)\n", "context": "tests/helpers/models.py\nclass User(BaseModel):\n    id = Column(String, hash_key=True)\n    age = Column(Integer)\n    name = Column(String)\n    email = Column(String)\n    joined = Column(DateTime, dynamo_name=\"j\")\n    by_email = GlobalSecondaryIndex(hash_key=\"email\", projection=\"all\")\nbloop/types.py\nclass UUID(String):\n    python_type = uuid.UUID\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return uuid.UUID(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return str(value)\nbloop/exceptions.py\nclass InvalidModel(BloopException, ValueError):\n    \"\"\"This is not a valid Model.\"\"\"\nbloop/types.py\nclass Type:\n    \"\"\"Abstract base type.\"\"\"\n\n    python_type = None\n    backing_type = None\n\n    def supports_operation(self, operation: str) -> bool:\n        \"\"\"\n        Used to ensure a conditional operation is supported by this type.\n\n        By default, uses a hardcoded table of operations that maps to each backing DynamoDB type.\n\n        You can override this method to implement your own conditional operators, or to dynamically\n        adjust which operations your type supports.\n        \"\"\"\n        return operation in OPERATION_SUPPORT_BY_TYPE[self.backing_type]\n\n    def __init__(self):\n        if not hasattr(self, \"inner_typedef\"):\n            self.inner_typedef = self\n        super().__init__()\n\n    def __getitem__(self, key):\n        raise RuntimeError(f\"{self!r} does not support document paths\")\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        \"\"\"Converts a local value into a DynamoDB value.\n\n        For example, to store a string enum as an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors.index(value.lower())\n        \"\"\"\n        raise NotImplementedError\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        \"\"\"Converts a DynamoDB value into a local value.\n\n        For example, to load a string enum from an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors[value]\n        \"\"\"\n        raise NotImplementedError\n\n    def _dump(self, value, **kwargs):\n        \"\"\"Entry point for serializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_dump`.\n\n        This wraps the return value of :func:`~bloop.types.Type.dynamo_dump` in DynamoDB's wire format.\n        For example, serializing a string enum to an int:\n\n        .. code-block:: python\n\n            value = \"green\"\n            # dynamo_dump(\"green\") = 2\n            _dump(value) == {\"N\": 2}\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_dump`.  This can happen when dumping eg. a sparse\n        :class:`~.bloop.types.Map`, or a missing (not set) value.\n        \"\"\"\n        wrapped = actions.wrap(value)\n        value = self.dynamo_dump(wrapped.value, **kwargs)\n        if value is None:\n            return actions.wrap(None)\n        else:\n            value = {self.backing_type: value}\n            return wrapped.type.new_action(value)\n\n    def _load(self, value, **kwargs):\n        \"\"\"Entry point for deserializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_load`.\n\n        This unpacks DynamoDB's wire format and calls :func:`~bloop.types.Type.dynamo_load` on the inner value.\n        For example, deserializing an int to a string enum:\n\n        .. code-block:: python\n\n            value = {\"N\": 2}\n            # dynamo_load(2) = \"green\"\n            _load(value) == \"green\"\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_load`.  This can happen when loading eg. a sparse :class:`~bloop.types.Map`.\n        \"\"\"\n        if value is not None:\n            value = next(iter(value.values()))\n        return self.dynamo_load(value, **kwargs)\n\n    def __repr__(self):\n        # Render class python types by name\n        python_type = self.python_type\n        if isinstance(python_type, type):\n            python_type = python_type.__name__\n\n        return \"<{}[{}:{}]>\".format(\n            self.__class__.__name__,\n            self.backing_type, python_type\n        )\nbloop/types.py\nclass DateTime(String):\n    \"\"\"Always stored in DynamoDB using the :data:`~bloop.types.FIXED_ISO8601_FORMAT` format.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(DateTime)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import DateTime  # becomes:\n            from bloop.ext.pendulum import DateTime\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        dt = datetime.datetime.strptime(value, FIXED_ISO8601_FORMAT)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return dt.replace(tzinfo=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        dt = value.astimezone(tz=datetime.timezone.utc)\n        return dt.strftime(FIXED_ISO8601_FORMAT)\nbloop/conditions.py\nclass ConditionRenderer:\n    # noinspection PyUnresolvedReferences\n    \"\"\"Renders collections of :class:`~bloop.conditions.BaseCondition` into DynamoDB's wire format for expressions,\n    including:\n\n    * ``\"ConditionExpression\"`` -- used in conditional operations\n    * ``\"FilterExpression\"`` -- used in queries and scans to ignore results that don't match the filter\n    * ``\"KeyConditionExpressions\"`` -- used to describe a query's hash (and range) key(s)\n    * ``\"ProjectionExpression\"`` -- used to include a subset of possible columns in the results of a query or scan\n    * ``\"UpdateExpression\"`` -- used to save objects\n\n    Normally, you will only need to call :func:`~bloop.conditions.ConditionRenderer.render` to handle any combination\n    of conditions.  You can also call each individual ``render_*`` function to control how multiple conditions of\n    each type are applied.\n\n    You can collect the rendered condition at any time through :attr:`~bloop.conditions.ConditionRenderer.rendered`.\n\n    .. code-block:: python\n\n        >>> renderer.render(obj=user, atomic=True)\n        >>> renderer.output\n        {'ConditionExpression': '((#n0 = :v1) AND (attribute_not_exists(#n2)) AND (#n4 = :v5))',\n         'ExpressionAttributeNames': {'#n0': 'age', '#n2': 'email', '#n4': 'id'},\n         'ExpressionAttributeValues': {':v1': {'N': '3'}, ':v5': {'S': 'some-user-id'}}}\n\n\n    :param engine: Used to dump values in conditions into the appropriate wire format.\n    :type engine: :class:`~bloop.engine.Engine`\n    \"\"\"\n    def __init__(self, engine):\n        self.refs = ReferenceTracker(engine)\n        self.engine = engine\n        self.expressions = {}\n\n    def render(self, obj=None, condition=None, update=False, filter=None, projection=None, key=None):\n        \"\"\"Main entry point for rendering multiple expressions.  All parameters are optional, except obj when\n        atomic or update are True.\n\n        :param obj: *(Optional)* An object to render an atomic condition or update expression for.  Required if\n            update or atomic are true.  Default is False.\n        :param condition: *(Optional)* Rendered as a \"ConditionExpression\" for a conditional operation.\n            If atomic is True, the two are rendered in an AND condition.  Default is None.\n        :type condition: :class:`~bloop.conditions.BaseCondition`\n        :param bool update: *(Optional)*  True if an \"UpdateExpression\" should be rendered for ``obj``.\n            Default is False.\n        :param filter: *(Optional)* A filter condition for a query or scan, rendered as a \"FilterExpression\".\n            Default is None.\n        :type filter: :class:`~bloop.conditions.BaseCondition`\n        :param projection: *(Optional)* A set of Columns to include in a query or scan, rendered as a\n            \"ProjectionExpression\".  Default is None.\n        :type projection: set :class:`~bloop.models.Column`\n        :param key: *(Optional)* A key condition for queries, rendered as a \"KeyConditionExpression\".  Default is None.\n        :type key: :class:`~bloop.conditions.BaseCondition`\n        \"\"\"\n        if update and not obj:\n            raise InvalidCondition(\"An object is required to render updates.\")\n\n        if filter:\n            self.filter_expression(filter)\n\n        if projection:\n            self.projection_expression(projection)\n\n        if key:\n            self.key_expression(key)\n\n        # Condition requires a bit of work, because either one can be empty/false\n        if condition:\n            self.condition_expression(condition)\n\n        if update:\n            self.update_expression(obj)\n\n    def condition_expression(self, condition):\n        self.expressions[\"ConditionExpression\"] = condition.render(self)\n\n    def filter_expression(self, condition):\n        self.expressions[\"FilterExpression\"] = condition.render(self)\n\n    def key_expression(self, condition):\n        self.expressions[\"KeyConditionExpression\"] = condition.render(self)\n\n    def projection_expression(self, columns):\n        included = set()\n        ref_names = []\n        for column in columns:\n            if column in included:\n                continue\n            included.add(column)\n            ref = self.refs.any_ref(column=column)\n            ref_names.append(ref.name)\n        self.expressions[\"ProjectionExpression\"] = \", \".join(ref_names)\n\n    def update_expression(self, obj):\n        updates = {\n            ActionType.Add: [],\n            ActionType.Delete: [],\n            ActionType.Remove: [],\n            ActionType.Set: [],\n        }\n        for column in sorted(\n                # Don't include key columns in an UpdateExpression\n                filter(lambda c: c not in obj.Meta.keys, global_tracking[obj]),\n                key=lambda c: c.dynamo_name):\n            name_ref = self.refs.any_ref(column=column)\n            value_ref = self.refs.any_ref(column=column, value=getattr(obj, column.name, None))\n            update_type = value_ref.action.type\n            # Can't set to an empty value, force to a Remove\n            if is_empty(value_ref) or update_type is ActionType.Remove:\n                self.refs.pop_refs(value_ref)\n                update_type = ActionType.Remove\n                value_ref = None\n            updates[update_type].append((name_ref, value_ref))\n\n        expressions = []\n        for update_type, refs in updates.items():\n            if not refs:\n                continue\n            k = update_type.wire_key.upper()\n            r = update_type.render\n            expressions.append(f\"{k} \" + \", \".join(r(*ref) for ref in refs))\n        if expressions:\n            self.expressions[\"UpdateExpression\"] = \" \".join(e.strip() for e in expressions)\n\n    @property\n    def output(self):\n        \"\"\"The wire format for all conditions that have been rendered.\n        A new :class:`~bloop.conditions.ConditionRenderer` should be used for each operation.\"\"\"\n        expressions = {k: v for (k, v) in self.expressions.items() if v is not None}\n        if self.refs.attr_names:\n            expressions[\"ExpressionAttributeNames\"] = self.refs.attr_names\n        if self.refs.attr_values:\n            expressions[\"ExpressionAttributeValues\"] = self.refs.attr_values\n        return expressions\nbloop/types.py\nclass Boolean(Type):\n    python_type = bool\n    backing_type = BOOLEAN\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\nbloop/types.py\nclass Timestamp(Integer):\n    \"\"\"Stores the unix (epoch) time in seconds.  Milliseconds are truncated to 0 on load and save.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(Timestamp)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import Timestamp  # becomes:\n            from bloop.ext.pendulum import Timestamp\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = super().dynamo_load(value, context=context, **kwargs)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return datetime.datetime.fromtimestamp(value, tz=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        value = value.timestamp()\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/types.py\nclass Integer(Number):\n    \"\"\"Truncates values when loading or dumping.\n\n    For example, ``3.14`` in DynamoDB is loaded as ``3``. If a value is ``7.5``\n    locally, it's stored in DynamoDB as ``7``.\n    \"\"\"\n    python_type = int\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        number = super().dynamo_load(value, context=context, **kwargs)\n        return int(number)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = int(value)\n        return super().dynamo_dump(value, context=context, **kwargs)\ntests/helpers/models.py\nclass VectorModel(BaseModel):\n    name = Column(String, hash_key=True)\n    list_str = Column(List(String))\n    set_str = Column(Set(String))\n    map_nested = Column(Map(**{\n        \"bytes\": Binary,\n        \"str\": String,\n        \"map\": Map(**{\n            \"int\": Integer,\n            \"str\": String\n        })\n    }))\n    some_int = Column(Integer)\n    some_bytes = Column(Binary)\nbloop/exceptions.py\nclass InvalidStream(BloopException, ValueError):\n    \"\"\"This is not a valid stream definition.\"\"\"\nbloop/types.py\nclass String(Type):\n    python_type = str\n    backing_type = STRING\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if not value:\n            return \"\"\n        return value\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if not value:\n            return None\n        return value\nbloop/models.py\nclass IMeta:\nclass BaseModel:\n    class Meta(IMeta):\nclass Index:\nclass GlobalSecondaryIndex(Index):\nclass LocalSecondaryIndex(Index):\nclass Column(ComparisonMixin):\n    class UNBOUND:\n        class Meta(IMeta):\n    def __init__(self, **attrs):\n    def __init_subclass__(cls: type, **kwargs):\n    def __repr__(self):\n    def __init__(self, *, projection, hash_key=None, range_key=None, dynamo_name=None, **kwargs):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\n    def hash_key(self):\n    def range_key(self):\n    def keys(self):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __init__(\n            self, *, projection,\n            hash_key, range_key=None,\n            read_units=None, write_units=None,\n            dynamo_name=None, **kwargs):\n    def __init__(self, *, projection, range_key, dynamo_name=None, strict=True, **kwargs):\n    def hash_key(self):\n    def read_units(self):\n    def read_units(self, value):\n    def write_units(self):\n    def write_units(self, value):\n    def __init__(self, typedef, hash_key=False, range_key=False, dynamo_name=None, default=missing):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\ndef subclassof(obj, classinfo):\ndef instanceof(obj, classinfo):\ndef loaded_columns(obj: BaseModel):\ndef unpack_from_dynamodb(*, attrs, expected, model=None, obj=None, engine=None, context=None, **kwargs):\ndef validate_projection(projection):\ndef validate_stream(meta):\ndef validate_encryption(meta):\ndef validate_backups(meta):\ndef validate_billing(meta):\ndef validate_ttl(meta):\ndef unbound_repr(obj):\ndef setdefault(obj, field, default):\ndef ensure_hash(cls) -> None:\ndef initialize_meta(cls: type):\ndef bind_column(model, name, column, force=False, recursive=False, copy=False) -> Column:\ndef bind_index(model, name, index, force=False, recursive=True, copy=False) -> Index:\ndef refresh_index(meta, index) -> None:\ndef unbind(meta, name=None, dynamo_name=None) -> None:\n", "answers": ["            index = LocalSecondaryIndex(range_key=\"id\", projection=\"keys\")"], "length": 2269, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "1dc911da7eb7c3c6b8336d06b4112a69343babb1b98f436a"}
{"input": "import csv\nimport logging\nimport multiprocessing as mp\nimport os\nimport time\nimport tqdm\nfrom abc import abstractmethod\nfrom queue import Empty\nfrom typing import TYPE_CHECKING, Dict, List\nfrom montreal_forced_aligner.alignment.multiprocessing import (\n    AlignArguments,\n    AlignFunction,\n    CompileInformationArguments,\n    CompileTrainGraphsArguments,\n    CompileTrainGraphsFunction,\n    compile_information_func,\n)\nfrom montreal_forced_aligner.dictionary.mixins import DictionaryMixin\nfrom montreal_forced_aligner.utils import KaldiProcessWorker, Stopped, run_mp, run_non_mp\n    from montreal_forced_aligner.abc import MetaDict\n    from montreal_forced_aligner.corpus.multiprocessing import Job\n                                break\n                        else:\n                            break\n                        continue\n                    pbar.update(done + errors)\n                    error_sum += errors\n                for p in procs:\n                    p.join()\n                if error_dict:\n                    for v in error_dict.values():\n                        raise v\n            else:\n                self.logger.debug(\"Not using multiprocessing...\")\n                for args in arguments:\n                    function = CompileTrainGraphsFunction(args)\n                    for done, errors in function.run():\n                        pbar.update(done + errors)\n                        error_sum += errors\n        if error_sum:\n            self.logger.warning(\n                f\"Compilation of training graphs failed for {error_sum} utterances.\"\n            )\n        self.logger.debug(f\"Compiling training graphs took {time.time() - begin}\")\n\n    def align_utterances(self) -> None:\n        \"\"\"\n        Multiprocessing function that aligns based on the current model.\n\n        See Also\n        --------\n        :class:`~montreal_forced_aligner.alignment.multiprocessing.AlignFunction`\n            Multiprocessing helper function for each job\n        :meth:`.AlignMixin.align_arguments`\n            Job method for generating arguments for the helper function\n        :kaldi_steps:`align_si`\n            Reference Kaldi script\n        :kaldi_steps:`align_fmllr`\n            Reference Kaldi script\n        \"\"\"\n        begin = time.time()\n        self.unaligned_files = set()\n        self.logger.info(\"Generating alignments...\")\n        with tqdm.tqdm(total=self.num_utterances) as pbar:\n            if self.use_mp:\n                manager = mp.Manager()\n                error_dict = manager.dict()\n                return_queue = manager.Queue()\n                stopped = Stopped()\n                procs = []\n                for i, args in enumerate(self.align_arguments()):\n                    function = AlignFunction(args)\n                    p = KaldiProcessWorker(i, return_queue, function, error_dict, stopped)\n                    procs.append(p)\n                    p.start()\n                while True:\n                    try:\n                        utterance, log_likelihood = return_queue.get(timeout=1)\n                        if stopped.stop_check():\n                            continue\n                    except Empty:\n                        for proc in procs:\n                            if not proc.finished.stop_check():\n                                break\n                        else:\n                            break\n                        continue\n                    if hasattr(self, \"utterances\"):\n                        if hasattr(self, \"frame_shift\"):\n                            num_frames = int(\n                                self.utterances[utterance].duration * self.frame_shift\n                            )\n                        else:\n                            num_frames = self.utterances[utterance].duration\n                        self.utterances[utterance].alignment_log_likelihood = (\n                            log_likelihood / num_frames\n                        )\n                    pbar.update(1)\n                for p in procs:\n                    p.join()\n                if error_dict:\n                    for v in error_dict.values():\n                        raise v\n            else:\n                self.logger.debug(\"Not using multiprocessing...\")\n                for args in self.align_arguments():\n                    function = AlignFunction(args)\n                    for utterance, log_likelihood in function.run():\n                        if hasattr(self, \"utterances\"):\n                            if hasattr(self, \"frame_shift\"):\n                                num_frames = int(\n                                    self.utterances[utterance].duration * self.frame_shift\n                                )\n                            else:\n                                num_frames = self.utterances[utterance].duration\n                            self.utterances[utterance].alignment_log_likelihood = (\n                                log_likelihood / num_frames\n                            )\n                        pbar.update(1)\n\n        self.compile_information()\n        self.logger.debug(f\"Alignment round took {time.time() - begin}\")\n\n    def compile_information(self):\n        \"\"\"\n        Compiles information about alignment, namely what the overall log-likelihood was\n        and how many files were unaligned.\n\n        See Also\n        --------\n        :func:`~montreal_forced_aligner.alignment.multiprocessing.compile_information_func`\n            Multiprocessing helper function for each job\n        :meth:`.AlignMixin.compile_information_arguments`\n            Job method for generating arguments for the helper function\n        \"\"\"\n        compile_info_begin = time.time()\n\n        jobs = self.compile_information_arguments()\n\n        if self.use_mp:\n            alignment_info = run_mp(\n", "context": "montreal_forced_aligner/alignment/multiprocessing.py\nclass AlignFunction(KaldiFunction):\n    \"\"\"\n    Multiprocessing function for alignment.\n\n    See Also\n    --------\n    :meth:`.AlignMixin.align_utterances`\n        Main function that calls this function in parallel\n    :meth:`.AlignMixin.align_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`align-equal-compiled`\n        Relevant Kaldi binary\n    :kaldi_src:`gmm-boost-silence`\n        Relevant Kaldi binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.alignment.multiprocessing.AlignArguments`\n        Arguments for the function\n    \"\"\"\n\n    def __init__(self, args: AlignArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.fst_scp_paths = args.fst_scp_paths\n        self.feature_strings = args.feature_strings\n        self.model_path = args.model_path\n        self.ali_paths = args.ali_paths\n        self.align_options = args.align_options\n\n    def run(self):\n        \"\"\"Run the function\"\"\"\n        with open(self.log_path, \"w\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                feature_string = self.feature_strings[dict_name]\n                fst_path = self.fst_scp_paths[dict_name]\n                ali_path = self.ali_paths[dict_name]\n                com = [\n                    thirdparty_binary(\"gmm-align-compiled\"),\n                    f\"--transition-scale={self.align_options['transition_scale']}\",\n                    f\"--acoustic-scale={self.align_options['acoustic_scale']}\",\n                    f\"--self-loop-scale={self.align_options['self_loop_scale']}\",\n                    f\"--beam={self.align_options['beam']}\",\n                    f\"--retry-beam={self.align_options['retry_beam']}\",\n                    \"--careful=false\",\n                    \"-\",\n                    f\"scp:{fst_path}\",\n                    feature_string,\n                    f\"ark:{ali_path}\",\n                    \"ark,t:-\",\n                ]\n\n                boost_proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"gmm-boost-silence\"),\n                        f\"--boost={self.align_options['boost_silence']}\",\n                        self.align_options[\"optional_silence_csl\"],\n                        self.model_path,\n                        \"-\",\n                    ],\n                    stderr=log_file,\n                    stdout=subprocess.PIPE,\n                    env=os.environ,\n                )\n                align_proc = subprocess.Popen(\n                    com,\n                    stdout=subprocess.PIPE,\n                    stderr=log_file,\n                    encoding=\"utf8\",\n                    stdin=boost_proc.stdout,\n                    env=os.environ,\n                )\n                for line in align_proc.stdout:\n                    line = line.strip()\n                    utterance, log_likelihood = line.split()\n                    yield utterance, float(log_likelihood)\nmontreal_forced_aligner/dictionary/mixins.py\nclass DictionaryMixin:\n    \"\"\"\n    Abstract class for MFA classes that use acoustic models\n\n    Parameters\n    ----------\n    oov_code : str\n        What to label words not in the dictionary, defaults to ``'<unk>'``\n    position_dependent_phones : bool\n        Specifies whether phones should be represented as dependent on their\n        position in the word (beginning, middle or end), defaults to True\n    num_silence_states : int\n        Number of states to use for silence phones, defaults to 5\n    num_non_silence_states : int\n        Number of states to use for non-silence phones, defaults to 3\n    shared_silence_phones : bool\n        Specify whether to share states across all silence phones, defaults\n        to True\n    silence_probability : float\n        Probability of optional silences following words, defaults to 0.5\n    punctuation: str, optional\n        Punctuation to use when parsing text\n    clitic_markers: str, optional\n        Clitic markers to use when parsing text\n    compound_markers: str, optional\n        Compound markers to use when parsing text\n    brackets: list[tuple[str, str], optional\n        Character tuples to treat as full brackets around words\n    clitic_set: set[str]\n        Set of clitic words\n    disambiguation_symbols: set[str]\n        Set of disambiguation symbols\n    max_disambiguation_symbol: int\n        Maximum number of disambiguation symbols required, defaults to 0\n    \"\"\"\n\n    positions: List[str] = [\"_B\", \"_E\", \"_I\", \"_S\"]\n\n    def __init__(\n        self,\n        oov_word: str = \"<unk>\",\n        silence_word: str = \"<sil>\",\n        noise_word: str = \"<noise>\",\n        optional_silence_phone: str = \"sil\",\n        oov_phone: str = \"spn\",\n        other_noise_phone: str = \"noi\",\n        position_dependent_phones: bool = True,\n        num_silence_states: int = 5,\n        num_noise_states: int = 5,\n        num_non_silence_states: int = 3,\n        shared_silence_phones: bool = False,\n        ignore_case: bool = True,\n        silence_probability: float = 0.5,\n        punctuation: List[str] = None,\n        clitic_markers: List[str] = None,\n        compound_markers: List[str] = None,\n        brackets: List[Tuple[str, str]] = None,\n        non_silence_phones: Set[str] = None,\n        disambiguation_symbols: Set[str] = None,\n        clitic_set: Set[str] = None,\n        max_disambiguation_symbol: int = 0,\n        phone_set_type: typing.Union[str, PhoneSetType] = \"UNKNOWN\",\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.punctuation = DEFAULT_PUNCTUATION\n        self.clitic_markers = DEFAULT_CLITIC_MARKERS\n        self.compound_markers = DEFAULT_COMPOUND_MARKERS\n        self.brackets = DEFAULT_BRACKETS\n        if punctuation is not None:\n            self.punctuation = punctuation\n        if clitic_markers is not None:\n            self.clitic_markers = clitic_markers\n        if compound_markers is not None:\n            self.compound_markers = compound_markers\n        if brackets is not None:\n            self.brackets = brackets\n\n        self.num_silence_states = num_silence_states\n        self.num_noise_states = num_noise_states\n        self.num_non_silence_states = num_non_silence_states\n        self.shared_silence_phones = shared_silence_phones\n        self.silence_probability = silence_probability\n        self.ignore_case = ignore_case\n        self.oov_word = oov_word\n        self.silence_word = silence_word\n        self.noise_word = noise_word\n        self.position_dependent_phones = position_dependent_phones\n        self.optional_silence_phone = optional_silence_phone\n        self.oov_phone = oov_phone\n        self.oovs_found = Counter()\n        self.other_noise_phone = other_noise_phone\n        if non_silence_phones is None:\n            non_silence_phones = set()\n        self.non_silence_phones = non_silence_phones\n        self.excluded_phones = set()\n        self.excluded_pronunciation_count = 0\n        self.max_disambiguation_symbol = max_disambiguation_symbol\n        if disambiguation_symbols is None:\n            disambiguation_symbols = set()\n        self.disambiguation_symbols = disambiguation_symbols\n        if clitic_set is None:\n            clitic_set = set()\n        self.clitic_set = clitic_set\n        if not isinstance(phone_set_type, PhoneSetType):\n            phone_set_type = PhoneSetType[phone_set_type]\n        self.phone_set_type = phone_set_type\n\n    @property\n    def base_phones(self) -> Dict[str, Set[str]]:\n        base_phones = {}\n        for p in self.non_silence_phones:\n            b = self.phone_set_type.get_base_phone(p)\n            if b not in base_phones:\n                base_phones[b] = set()\n            base_phones[b].add(p)\n\n        return base_phones\n\n    @property\n    def split_regex(self) -> re.Pattern:\n        \"\"\"Pattern for splitting arbitrary text\"\"\"\n        markers = self.compound_markers\n        if \"-\" in markers:\n            markers = [\"-\"] + [x for x in self.compound_markers if x != \"-\"]\n        return re.compile(rf'[{\"\".join(markers)} ]')\n\n    @property\n    def extra_questions_mapping(self) -> Dict[str, List[str]]:\n        \"\"\"Mapping of extra questions for the given phone set type\"\"\"\n        mapping = {}\n        mapping[\"silence_question\"] = []\n        for p in sorted(self.silence_phones):\n            mapping[\"silence_question\"].append(p)\n            if self.position_dependent_phones:\n                mapping[\"silence_question\"].extend([p + x for x in self.positions])\n        for k, v in self.phone_set_type.extra_questions.items():\n            if k not in mapping:\n                mapping[k] = []\n            if self.phone_set_type is PhoneSetType.ARPA:\n                if self.position_dependent_phones:\n                    for x in sorted(v):\n                        mapping[k].extend([x + pos for pos in self.positions])\n                else:\n                    mapping[k] = sorted(v)\n            elif self.phone_set_type == PhoneSetType.IPA:\n                filtered_v = set()\n                for x in self.non_silence_phones:\n                    base_phone = self.phone_set_type.get_base_phone(x)\n                    if base_phone in v:\n                        filtered_v.add(x)\n                if len(filtered_v) < 2:\n                    del mapping[k]\n                    continue\n                if self.position_dependent_phones:\n                    for x in sorted(filtered_v):\n                        mapping[k].extend([x + pos for pos in self.positions])\n                else:\n                    mapping[k] = sorted(filtered_v)\n            elif self.phone_set_type is PhoneSetType.PINYIN:\n                filtered_v = set()\n                for x in self.non_silence_phones:\n                    base_phone = self.phone_set_type.get_base_phone(x)\n                    if base_phone in v or x in v:\n                        filtered_v.add(x)\n                    elif x in v:\n                        filtered_v.add(x)\n                if len(filtered_v) < 2:\n                    del mapping[k]\n                    continue\n                if self.position_dependent_phones:\n                    for x in sorted(filtered_v):\n                        mapping[k].extend([x + pos for pos in self.positions])\n                else:\n                    mapping[k] = sorted(filtered_v)\n        if self.position_dependent_phones:\n            phones = sorted(self.non_silence_phones)\n            for pos in self.positions:\n                mapping[f\"non_silence{pos}\"] = [x + pos for x in phones]\n            silence_phones = sorted(self.silence_phones)\n            for pos in [\"\"] + self.positions:\n                mapping[f\"silence{pos}\"] = [x + pos for x in silence_phones]\n        return mapping\n\n    @property\n    def dictionary_options(self) -> MetaDict:\n        \"\"\"Dictionary options\"\"\"\n        return {\n            \"punctuation\": self.punctuation,\n            \"clitic_markers\": self.clitic_markers,\n            \"clitic_set\": self.clitic_set,\n            \"compound_markers\": self.compound_markers,\n            \"brackets\": self.brackets,\n            \"num_silence_states\": self.num_silence_states,\n            \"num_non_silence_states\": self.num_non_silence_states,\n            \"shared_silence_phones\": self.shared_silence_phones,\n            \"silence_probability\": self.silence_probability,\n            \"oov_word\": self.oov_word,\n            \"silence_word\": self.silence_word,\n            \"position_dependent_phones\": self.position_dependent_phones,\n            \"optional_silence_phone\": self.optional_silence_phone,\n            \"oov_phone\": self.oov_phone,\n            \"other_noise_phone\": self.other_noise_phone,\n            \"non_silence_phones\": self.non_silence_phones,\n            \"max_disambiguation_symbol\": self.max_disambiguation_symbol,\n            \"disambiguation_symbols\": self.disambiguation_symbols,\n            \"phone_set_type\": str(self.phone_set_type),\n        }\n\n    @property\n    def silence_phones(self):\n        \"\"\"Silence phones\"\"\"\n        return {\n            self.optional_silence_phone,\n            self.oov_phone,\n            self.other_noise_phone,\n        }\n\n    @property\n    def context_independent_csl(self):\n        \"\"\"Context independent colon-separated list\"\"\"\n        return \":\".join(str(self.phone_mapping[x]) for x in self.silence_phones)\n\n    @property\n    def specials_set(self):\n        \"\"\"Special words, like the ``oov_word`` ``silence_word``, ``<eps>``, ``<s>``, and ``</s>``\"\"\"\n        return {self.oov_word, self.silence_word, self.noise_word, \"<eps>\", \"<s>\", \"</s>\"}\n\n    @property\n    def phone_mapping(self) -> Dict[str, int]:\n        \"\"\"Mapping of phones to integer IDs\"\"\"\n        phone_mapping = {}\n        i = 0\n        phone_mapping[\"<eps>\"] = i\n        for p in self.kaldi_silence_phones:\n            i += 1\n            phone_mapping[p] = i\n        for p in self.kaldi_non_silence_phones:\n            i += 1\n            phone_mapping[p] = i\n        i = max(phone_mapping.values())\n        for x in range(self.max_disambiguation_symbol + 2):\n            p = f\"#{x}\"\n            self.disambiguation_symbols.add(p)\n            i += 1\n            phone_mapping[p] = i\n        return phone_mapping\n\n    @property\n    def reversed_phone_mapping(self) -> ReversedMappingType:\n        \"\"\"\n        A mapping of integer ids to phones\n        \"\"\"\n        mapping = {}\n        for k, v in self.phone_mapping.items():\n            mapping[v] = k\n        return mapping\n\n    @property\n    def positional_silence_phones(self) -> List[str]:\n        \"\"\"\n        List of silence phones with positions\n        \"\"\"\n        silence_phones = []\n        for p in sorted(self.silence_phones):\n            silence_phones.append(p)\n            for pos in self.positions:\n                silence_phones.append(p + pos)\n        return silence_phones\n\n    def _generate_positional_list(self, phones: Set[str]) -> List[str]:\n        \"\"\"\n        Helper function to generate positional list for phones along with any base phones for the phone set\n\n        Parameters\n        ----------\n        phones: set[str]\n            Set of phones\n\n        Returns\n        -------\n        list[str]\n            List of positional phones, sorted by base phone\n        \"\"\"\n        positional_phones = []\n        for p in sorted(phones):\n            if p not in self.non_silence_phones:\n                continue\n            base_phone = self.phone_set_type.get_base_phone(p)\n            for pos in self.positions:\n                pos_p = base_phone + pos\n                if pos_p not in positional_phones:\n                    positional_phones.append(pos_p)\n            for pos in self.positions:\n                pos_p = p + pos\n                if pos_p not in positional_phones:\n                    positional_phones.append(pos_p)\n        return positional_phones\n\n    def _generate_non_positional_list(self, phones: Set[str]) -> List[str]:\n        \"\"\"\n        Helper function to generate non-positional list for phones with any base phones for the phone set\n\n        Parameters\n        ----------\n        phones: set[str]\n            Set of phones\n\n        Returns\n        -------\n        list[str]\n            List of non-positional phones, sorted by base phone\n        \"\"\"\n        base_phones = set()\n        for p in phones:\n            base_phone = self.phone_set_type.get_base_phone(p)\n            base_phones.add(base_phone)\n\n        return sorted(phones | base_phones)\n\n    def _generate_phone_list(self, phones: Set[str]) -> List[str]:\n        \"\"\"\n        Helper function to generate phone list\n\n        Parameters\n        ----------\n        phones: set[str]\n            Set of phones\n\n        Returns\n        -------\n        list[str]\n            List of positional or non-positional phones, sorted by base phone\n        \"\"\"\n        if self.position_dependent_phones:\n            return self._generate_positional_list(phones)\n        return self._generate_non_positional_list(phones)\n\n    @property\n    def positional_non_silence_phones(self) -> List[str]:\n        \"\"\"\n        List of non-silence phones with positions\n        \"\"\"\n        return self._generate_positional_list(self.non_silence_phones)\n\n    @property\n    def kaldi_non_silence_phones(self):\n        \"\"\"Non silence phones in Kaldi format\"\"\"\n        if self.position_dependent_phones:\n            return self.positional_non_silence_phones\n        return self._generate_non_positional_list(self.non_silence_phones)\n\n    @property\n    def kaldi_phones_for_topo(self):\n        \"\"\"Mappings of phones for generating topo file\"\"\"\n        mapping = {}\n        for p in sorted(self.non_silence_phones):\n            base_phone = self.phone_set_type.get_base_phone(p)\n            query_set = {p, base_phone}\n            if any(x in self.phone_set_type.extra_short_phones for x in query_set):\n                num_states = 1  # One state for extra short sounds\n            elif any(x in self.phone_set_type.diphthong_phones for x in query_set):\n                num_states = 5  # 5 states for diphthongs (onset of first target, steady state,\n                # transition to next target, steady state, offset of second target)\n            elif any(x in self.phone_set_type.triphthong_phones for x in query_set):\n                num_states = 6  # 5 states for diphthongs (onset of first target, steady state,\n                # transition to next target, steady state, offset of second target)\n            elif any(x in self.phone_set_type.affricate_phones for x in query_set):\n                num_states = 4  # 4 states for affricates (closure, burst, onset of frication, offset of frication)\n            elif any(x in self.phone_set_type.stop_phones for x in query_set):\n                num_states = 2  # Two states for stops (closure, burst), extra states added below for aspirated, ejectives\n            else:\n                num_states = self.num_non_silence_states\n            if self.phone_set_type is PhoneSetType.IPA:\n                if re.match(r\"^.*[ʱʼʰʲʷⁿˠ][ː]?$\", p):\n                    num_states += 1\n                if re.match(r\"^.*̚$\", p) and p not in self.phone_set_type.extra_short_phones:\n                    num_states -= 1\n            elif self.phone_set_type is PhoneSetType.PINYIN:\n                if p in {\"c\", \"ch\", \"q\"}:\n                    num_states += 1\n            if num_states not in mapping:\n                mapping[num_states] = []\n            mapping[num_states].extend(\n                [x for x in self._generate_phone_list({p}) if x not in mapping[num_states]]\n            )\n        if self.phone_set_type is PhoneSetType.ARPA:\n            mapping[1] = [x for x in mapping[1] if \"0\" in x]\n        return mapping\n\n    @property\n    def kaldi_grouped_phones(self) -> Dict[str, List[str]]:\n        \"\"\"Non silence phones in Kaldi format\"\"\"\n        groups = {}\n        for p in sorted(self.non_silence_phones):\n\n            base_phone = self.phone_set_type.get_base_phone(p)\n            if base_phone not in groups:\n                if self.position_dependent_phones:\n                    groups[base_phone] = [base_phone + pos for pos in self.positions]\n                else:\n                    groups[base_phone] = [base_phone]\n            if self.position_dependent_phones:\n                groups[base_phone].extend(\n                    [p + pos for pos in self.positions if p + pos not in groups[base_phone]]\n                )\n            else:\n                if p not in groups[base_phone]:\n                    groups[base_phone].append(p)\n        return groups\n\n    @property\n    def kaldi_silence_phones(self):\n        \"\"\"Silence phones in Kaldi format\"\"\"\n        if self.position_dependent_phones:\n            return self.positional_silence_phones\n        return sorted(self.silence_phones)\n\n    def save_oovs_found(self, directory: str) -> None:\n        \"\"\"\n        Save all out of vocabulary items to a file in the specified directory\n\n        Parameters\n        ----------\n        directory : str\n            Path to directory to save ``oovs_found.txt``\n        \"\"\"\n        with open(os.path.join(directory, \"oovs_found.txt\"), \"w\", encoding=\"utf8\") as f, open(\n            os.path.join(directory, \"oov_counts.txt\"), \"w\", encoding=\"utf8\"\n        ) as cf:\n            for oov in sorted(self.oovs_found.keys(), key=lambda x: (-self.oovs_found[x], x)):\n                f.write(oov + \"\\n\")\n                cf.write(f\"{oov}\\t{self.oovs_found[oov]}\\n\")\n\n    @property\n    def optional_silence_csl(self) -> str:\n        \"\"\"\n        Phone ID of the optional silence phone\n        \"\"\"\n        return str(self.phone_mapping[self.optional_silence_phone])\n\n    @property\n    def silence_csl(self) -> str:\n        \"\"\"\n        A colon-separated string of silence phone ids\n        \"\"\"\n        return \":\".join(map(str, (self.phone_mapping[x] for x in self.kaldi_silence_phones)))\n\n    @property\n    def non_silence_csl(self) -> str:\n        \"\"\"\n        A colon-separated string of non-silence phone ids\n        \"\"\"\n        return \":\".join(map(str, (self.phone_mapping[x] for x in self.kaldi_non_silence_phones)))\n\n    @property\n    def phones(self) -> set:\n        \"\"\"\n        The set of all phones (silence and non-silence)\n        \"\"\"\n        return self.silence_phones | self.non_silence_phones\n\n    def check_bracketed(self, word: str) -> bool:\n        \"\"\"\n        Checks whether a given string is surrounded by brackets.\n\n        Parameters\n        ----------\n        word : str\n            Text to check for final brackets\n\n        Returns\n        -------\n        bool\n            True if the word is fully bracketed, false otherwise\n        \"\"\"\n        for b in self.brackets:\n            if re.match(rf\"^{re.escape(b[0])}.*{re.escape(b[1])}$\", word):\n                return True\n        return False\n\n    def construct_sanitize_function(self) -> SanitizeFunction:\n        \"\"\"\n        Construct a :class:`~montreal_forced_aligner.dictionary.mixins.SanitizeFunction` to use in multiprocessing jobs\n\n        Returns\n        -------\n        :class:`~montreal_forced_aligner.dictionary.mixins.SanitizeFunction`\n            Function for sanitizing text\n        \"\"\"\n        f = SanitizeFunction(\n            self.punctuation, self.clitic_markers, self.compound_markers, self.brackets\n        )\n\n        return f\n\n    def sanitize(self, item: str) -> str:\n        \"\"\"\n        Sanitize an item according to punctuation and clitic markers\n\n        Parameters\n        ----------\n        item: str\n            Word to sanitize\n\n        Returns\n        -------\n        str\n            Sanitized form\n        \"\"\"\n        return self.construct_sanitize_function()(item)\nmontreal_forced_aligner/alignment/multiprocessing.py\nclass CompileTrainGraphsFunction(KaldiFunction):\n    \"\"\"\n    Multiprocessing function to compile training graphs\n\n    See Also\n    --------\n    :meth:`.AlignMixin.compile_train_graphs`\n        Main function that calls this function in parallel\n    :meth:`.AlignMixin.compile_train_graphs_arguments`\n        Job method for generating arguments for this function\n    :kaldi_src:`compile-train-graphs`\n        Relevant Kaldi binary\n\n    Parameters\n    ----------\n    args: :class:`~montreal_forced_aligner.alignment.multiprocessing.CompileTrainGraphsArguments`\n        Arguments for the function\n    \"\"\"\n\n    progress_pattern = re.compile(\n        r\"^LOG.*succeeded for (?P<succeeded>\\d+) graphs, failed for (?P<failed>\\d+)\"\n    )\n\n    def __init__(self, args: CompileTrainGraphsArguments):\n        self.log_path = args.log_path\n        self.dictionaries = args.dictionaries\n        self.tree_path = args.tree_path\n        self.model_path = args.model_path\n        self.text_int_paths = args.text_int_paths\n        self.disambig_path = args.disambig_path\n        self.lexicon_fst_paths = args.lexicon_fst_paths\n        self.fst_scp_paths = args.fst_scp_paths\n\n    def run(self):\n        with open(self.log_path, \"w\", encoding=\"utf8\") as log_file:\n            for dict_name in self.dictionaries:\n                fst_scp_path = self.fst_scp_paths[dict_name]\n                fst_ark_path = fst_scp_path.replace(\".scp\", \".ark\")\n                text_path = self.text_int_paths[dict_name]\n                proc = subprocess.Popen(\n                    [\n                        thirdparty_binary(\"compile-train-graphs\"),\n                        f\"--read-disambig-syms={self.disambig_path}\",\n                        self.tree_path,\n                        self.model_path,\n                        self.lexicon_fst_paths[dict_name],\n                        f\"ark:{text_path}\",\n                        f\"ark,scp:{fst_ark_path},{fst_scp_path}\",\n                    ],\n                    stderr=subprocess.PIPE,\n                    encoding=\"utf8\",\n                    env=os.environ,\n                )\n                for line in proc.stderr:\n                    log_file.write(line)\n                    m = self.progress_pattern.match(line.strip())\n                    if m:\n                        yield int(m.group(\"succeeded\")), int(m.group(\"failed\"))\nmontreal_forced_aligner/alignment/multiprocessing.py\nclass AlignArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.alignment.multiprocessing.AlignFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    fst_scp_paths: Dict[str, str]\n    feature_strings: Dict[str, str]\n    model_path: str\n    ali_paths: Dict[str, str]\n    align_options: MetaDict\nmontreal_forced_aligner/alignment/multiprocessing.py\nclass CompileTrainGraphsArguments(NamedTuple):\n    \"\"\"Arguments for :class:`~montreal_forced_aligner.alignment.multiprocessing.CompileTrainGraphsFunction`\"\"\"\n\n    log_path: str\n    dictionaries: List[str]\n    tree_path: str\n    model_path: str\n    text_int_paths: Dict[str, str]\n    disambig_path: str\n    lexicon_fst_paths: Dict[str, str]\n    fst_scp_paths: Dict[str, str]\nmontreal_forced_aligner/utils.py\ndef run_mp(\n    function: Callable,\n    argument_list: List[Tuple[Any, ...]],\n    log_directory: str,\n    return_info: bool = False,\n) -> Optional[Dict[int, Any]]:\n    \"\"\"\n    Apply a function for each job in parallel\n\n    Parameters\n    ----------\n    function: Callable\n        Multiprocessing function to apply\n    argument_list: list\n        List of arguments for each job\n    log_directory: str\n        Directory that all log information from the processes goes to\n    return_info: dict, optional\n        If the function returns information, supply the return dict to populate\n    \"\"\"\n    from .config import BLAS_THREADS\n\n    os.environ[\"OPENBLAS_NUM_THREADS\"] = f\"{BLAS_THREADS}\"\n    os.environ[\"MKL_NUM_THREADS\"] = f\"{BLAS_THREADS}\"\n    stopped = Stopped()\n    manager = mp.Manager()\n    job_queue = manager.Queue()\n    return_dict = manager.dict()\n    info = None\n    if return_info:\n        info = manager.dict()\n    for a in argument_list:\n        job_queue.put(a)\n    procs = []\n    for i in range(len(argument_list)):\n        p = ProcessWorker(i, job_queue, function, return_dict, stopped, info)\n        procs.append(p)\n        p.start()\n\n    for p in procs:\n        p.join()\n    if \"error\" in return_dict:\n        _, exc = return_dict[\"error\"]\n        raise exc\n\n    parse_logs(log_directory)\n    if return_info:\n        return info\nmontreal_forced_aligner/alignment/multiprocessing.py\nclass CompileInformationArguments(NamedTuple):\n    \"\"\"Arguments for :func:`~montreal_forced_aligner.alignment.multiprocessing.compile_information_func`\"\"\"\n\n    align_log_paths: str\nmontreal_forced_aligner/utils.py\nclass Stopped(object):\n    \"\"\"\n    Multiprocessing class for detecting whether processes should stop processing and exit ASAP\n\n    Attributes\n    ----------\n    val: :func:`~multiprocessing.Value`\n        0 if not stopped, 1 if stopped\n    lock: :class:`~multiprocessing.Lock`\n        Lock for process safety\n    _source: multiprocessing.Value\n        1 if it was a Ctrl+C event that stopped it, 0 otherwise\n    \"\"\"\n\n    def __init__(self, initval: Union[bool, int] = False):\n        self.val = mp.Value(\"i\", initval)\n        self.lock = mp.Lock()\n        self._source = mp.Value(\"i\", 0)\n\n    def stop(self) -> None:\n        \"\"\"Signal that work should stop asap\"\"\"\n        with self.lock:\n            self.val.value = True\n\n    def stop_check(self) -> int:\n        \"\"\"Check whether a process should stop\"\"\"\n        with self.lock:\n            return self.val.value\n\n    def set_sigint_source(self) -> None:\n        \"\"\"Set the source as a ctrl+c\"\"\"\n        with self.lock:\n            self._source.value = True\n\n    def source(self) -> int:\n        \"\"\"Get the source value\"\"\"\n        with self.lock:\n            return self._source.value\nmontreal_forced_aligner/utils.py\ndef run_non_mp(\n    function: Callable,\n    argument_list: List[Tuple[Any, ...]],\n    log_directory: str,\n    return_info: bool = False,\n) -> Optional[Dict[Any, Any]]:\n    \"\"\"\n    Similar to :func:`run_mp`, but no additional processes are used and the jobs are evaluated in sequential order\n\n    Parameters\n    ----------\n    function: Callable\n        Multiprocessing function to evaluate\n    argument_list: list\n        List of arguments to process\n    log_directory: str\n        Directory that all log information from the processes goes to\n    return_info: dict, optional\n        If the function returns information, supply the return dict to populate\n\n    Returns\n    -------\n    dict, optional\n        If the function returns information, returns the dictionary it was supplied with\n    \"\"\"\n    if return_info:\n        info = {}\n        for i, args in enumerate(argument_list):\n            info[i] = function(*args)\n        parse_logs(log_directory)\n        return info\n\n    for args in argument_list:\n        function(*args)\n    parse_logs(log_directory)\nmontreal_forced_aligner/alignment/multiprocessing.py\ndef compile_information_func(align_log_path: str) -> Dict[str, Union[List[str], float, int]]:\n    \"\"\"\n    Multiprocessing function for compiling information about alignment\n\n    See Also\n    --------\n    :meth:`.AlignMixin.compile_information`\n        Main function that calls this function in parallel\n\n    Parameters\n    ----------\n    align_log_path: str\n        Log path for alignment\n\n    Returns\n    -------\n    dict[str, Union[list[str], float, int]]\n        Information about log-likelihood and number of unaligned files\n    \"\"\"\n    average_logdet_pattern = re.compile(\n        r\"Overall average logdet is (?P<logdet>[-.,\\d]+) over (?P<frames>[.\\d+e]+) frames\"\n    )\n    log_like_pattern = re.compile(\n        r\"^LOG .* Overall log-likelihood per frame is (?P<log_like>[-0-9.]+) over (?P<frames>\\d+) frames.*$\"\n    )\n\n    decode_error_pattern = re.compile(\n        r\"^WARNING .* Did not successfully decode file (?P<utt>.*?), .*$\"\n    )\n\n    data = {\"unaligned\": [], \"too_short\": [], \"log_like\": 0, \"total_frames\": 0}\n    with open(align_log_path, \"r\", encoding=\"utf8\") as f:\n        for line in f:\n            decode_error_match = re.match(decode_error_pattern, line)\n            if decode_error_match:\n                data[\"unaligned\"].append(decode_error_match.group(\"utt\"))\n                continue\n            log_like_match = re.match(log_like_pattern, line)\n            if log_like_match:\n                log_like = log_like_match.group(\"log_like\")\n                frames = log_like_match.group(\"frames\")\n                data[\"log_like\"] = float(log_like)\n                data[\"total_frames\"] = int(frames)\n            m = re.search(average_logdet_pattern, line)\n            if m:\n                logdet = float(m.group(\"logdet\"))\n                frames = float(m.group(\"frames\"))\n                data[\"logdet\"] = logdet\n                data[\"logdet_frames\"] = frames\n    return data\nmontreal_forced_aligner/utils.py\nclass KaldiProcessWorker(mp.Process):\n    \"\"\"\n    Multiprocessing function work\n\n    Parameters\n    ----------\n    job_name: int\n        Integer number of job\n    job_q: :class:`~multiprocessing.Queue`\n        Job queue to pull arguments from\n    function: KaldiFunction\n        Multiprocessing function to call on arguments from job_q\n    return_dict: dict\n        Dictionary for collecting errors\n    stopped: :class:`~montreal_forced_aligner.utils.Stopped`\n        Stop check\n    return_info: dict[int, Any], optional\n        Optional dictionary to fill if the function should return information to main thread\n    \"\"\"\n\n    def __init__(\n        self,\n        job_name: int,\n        return_q: mp.Queue,\n        function: KaldiFunction,\n        error_dict: dict,\n        stopped: Stopped,\n    ):\n        mp.Process.__init__(self)\n        self.job_name = job_name\n        self.function = function\n        self.return_q = return_q\n        self.error_dict = error_dict\n        self.stopped = stopped\n        self.finished = Stopped()\n\n    def run(self) -> None:\n        \"\"\"\n        Run through the arguments in the queue apply the function to them\n        \"\"\"\n        try:\n            for result in self.function.run():\n                self.return_q.put(result)\n        except Exception:\n            self.stopped.stop()\n            self.error_dict[self.job_name] = Exception(traceback.format_exception(*sys.exc_info()))\n        finally:\n            self.finished.stop()\n", "answers": ["                compile_information_func, jobs, self.working_log_directory, True"], "length": 3046, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "0c717f4722b891e7a785825ab5c74a953f360b5849e9620b"}
{"input": "import logging\nimport abc\nimport functools\nfrom collections import namedtuple\nfrom six.moves import range, zip\nfrom pybufrkit.constants import (DEFAULT_TABLES_DIR,\n                                 UNITS_CODE_TABLE,\n                                 UNITS_FLAG_TABLE,\n                                 UNITS_STRING)\nfrom pybufrkit.errors import PyBufrKitError, UnknownDescriptor\nfrom pybufrkit.bufr import SectionConfigurer\nfrom pybufrkit.descriptors import (ElementDescriptor,\n                                   FixedReplicationDescriptor,\n                                   DelayedReplicationDescriptor,\n                                   OperatorDescriptor,\n                                   SequenceDescriptor,\n                                   AssociatedDescriptor,\n                                   MarkerDescriptor,\n                                   SkippedLocalDescriptor)\n        # Lastly, get all the descriptors that has a corresponding Zero bit value\n        self.bitmapped_descriptors = [\n            (idx, d) for bit, (idx, d) in zip(\n                bitmap,\n                self.back_referenced_descriptors\n            ) if bit == 0\n        ]\n        self.next_bitmapped_descriptor = functools.partial(next, iter(self.bitmapped_descriptors))\n\n    def _assert_equal_values_of_index(self, idx):\n        \"\"\"\n        Assert that the values of the specified index are identical for all\n        subsets. It is only used for compressed data. For an example, to ensure\n        the delayed replication factors are the same for all subsets.\n        \"\"\"\n        minv, maxv = CoderState.minmax([values[idx] for values in self.decoded_values_all_subsets])\n        assert minv == maxv, 'Values from all subsets are NOT identical'\n\n    @staticmethod\n    def minmax(values):\n        \"\"\"\n        Give a list of values, find out the minimum and maximum, ignore any Nones.\n        \"\"\"\n        mn, mx = None, None\n        for v in values:\n            if v is not None:\n                if mn is None or mn > v:\n                    mn = v\n                if mx is None or mx < v:\n                    mx = v\n        return mn, mx\n\n\nclass Coder(object):\n    \"\"\"\n    This class is an abstract superclass for Decoder and Encoder. By itself it\n    cannot do anything. But it provides common operations for subclasses.\n\n    :param definitions_dir: Where to find the BPCL definition files.\n    :param tables_root_dir: Where to find the BUFR table files.\n    \"\"\"\n\n    def __init__(self,\n                 definitions_dir=None,\n                 tables_root_dir=None):\n\n        self.section_configurer = SectionConfigurer(definitions_dir=definitions_dir)\n        self.tables_root_dir = tables_root_dir or DEFAULT_TABLES_DIR\n\n    @abc.abstractmethod\n    def process(self, *args, **kwargs):\n        \"\"\"Entry point of the class\"\"\"\n\n    @abc.abstractmethod\n    def process_section(self, bufr_message, bit_operator, section):\n        \"\"\"\n        Process the given section of a BUFR message\n\n        :param bufr_message: The BufrMessage object to process\n        :param bit_operator: The bit operator (reader or writer)\n        :param section:\n        \"\"\"\n\n    def process_template(self, state, bit_operator, template):\n        \"\"\"\n        Process the top level BUFR Template\n\n        :param state: The state of the processing.\n        :param bit_operator: The bit operator for read/write bits.\n        :param template: The BUFR Template of the message.\n        \"\"\"\n        self.process_members(state, bit_operator, template.members)\n\n    def process_members(self, state, bit_operator, members):\n        \"\"\"\n        Process a list of descriptors that are members of a composite descriptor.\n\n        :param state: The state of the processing.\n        :param bit_operator: The bit operator for read/write bits.\n        :param members: A list of descriptors.\n        \"\"\"\n        for member in members:\n            member_type = type(member)\n\n            log.debug('Processing {} {}'.format(member, member.name if hasattr(member, 'name') else ''))\n\n            # TODO: NOT using if-elif for following checks because they may co-exist???\n            #      It is highly unlikely if not impossible\n\n            # 221 YYY data not present for following YYY descriptors except class 0-9 and 31\n            if state.data_not_present_count:\n                state.data_not_present_count -= 1\n                log.debug('Data not present: {} to go'.format(state.data_not_present_count))\n\n                if member_type is ElementDescriptor:\n                    X = member.X\n                    if not (1 <= X <= 9 or X == 31):  # skipping\n                        continue\n                        # TODO: maybe the descriptor should still be kept and set its value to None?\n                        #       So it helps to keep the structure intact??\n\n            # Currently defining new reference values\n            # For ElementDescriptor only. This makes sense though not explicitly stated in the manual\n            if state.nbits_of_new_refval and member_type is ElementDescriptor:\n                self.process_define_new_refval(state, bit_operator, member)\n                continue\n\n            # 206 YYY signify data width for local descriptor\n            if state.nbits_of_skipped_local_descriptor:\n                self.process_skipped_local_descriptor(state, bit_operator, member)\n                continue\n\n            # Currently defining new bitmap\n            if state.bitmap_definition_state != BITMAP_NA:\n                self.process_bitmap_definition(state, bit_operator, member)\n\n            # Now process normally\n            if member_type is ElementDescriptor:\n                self.process_element_descriptor(state, bit_operator, member)\n\n", "context": "pybufrkit/descriptors.py\nclass ElementDescriptor(Descriptor):\n    \"\"\"\n    Element Descriptor 0XXYYY\n\n    :param int id_: The descriptor ID\n    :param str name: Name of the descriptor\n    :param str unit: Units of the descriptor\n    :param int scale: Scale factor of the descriptor value\n    :param int refval: Reference value of the descriptor value\n    :param int nbits: The number of bits used by the descriptor\n    :param str crex_unit: Units of the descriptor for CREX spec\n    :param int crex_scale: Scale factor of the descriptor value for CREX Spec\n    :param int crex_nchars: Number of characters used by the descriptor for CREX Spec\n    \"\"\"\n\n    def __init__(self, id_, name, unit, scale, refval, nbits,\n                 crex_unit, crex_scale, crex_nchars):\n        super(ElementDescriptor, self).__init__(id_)\n        self.name, self.unit, self.scale, self.refval, self.nbits = (\n            name, unit, scale, refval, nbits\n        )\n        self.crex_unit, self.crex_scale, self.crex_nchars = crex_unit, crex_scale, crex_nchars\n\n    def as_list(self):\n        return [self.id, self.name, self.unit, self.scale, self.refval, self.nbits]\n\n    def as_dict(self):\n        return {self.id: (self.name, self.unit, self.scale, self.refval, self.nbits)}\n\n    def accept(self, visitor):\n        visitor.visit_element_descriptor(self)\npybufrkit/descriptors.py\nclass FixedReplicationDescriptor(ReplicationDescriptor):\n    \"\"\"\n    Fixed replication Descriptor 1XXYYY\n    \"\"\"\n\n    def __init__(self, id_, members=None):\n        super(FixedReplicationDescriptor, self).__init__(id_, members)\n\n    @property\n    def n_repeats(self):\n        \"\"\"\n        Number of times to perform the replication. This value is decoded\n        directly from the descriptor ID.\n        \"\"\"\n        return self.id % 1000\n\n    def accept(self, visitor):\n        visitor.visit_replication_descriptor(self)\n        if not self.members:\n            visitor.visit_replication_descriptor_end(self)\n            return\n        for member in self.members:\n            member.accept(visitor)\n        visitor.visit_replication_descriptor_end(self)\npybufrkit/constants.py\nUNITS_CODE_TABLE = 'CODE TABLE'\npybufrkit/constants.py\nDEFAULT_TABLES_DIR = os.path.join(BASE_DIR, 'tables')\npybufrkit/descriptors.py\nclass SkippedLocalDescriptor(Descriptor):\n    \"\"\"\n    The skipped local descriptor is a placeholder for any descriptors followed by\n    operator descriptor 206YYY.\n    \"\"\"\n\n    def __init__(self, id_, nbits):\n        # TODO: If a local descriptor does not exist in tables, it will be\n        # created as an undefined descriptor. So how it should be converted\n        # later to SkippedLocalDescriptor if it has a preceding 206YYY? During\n        # template lint?\n        super(SkippedLocalDescriptor, self).__init__(id_)\n        self.nbits = nbits\n        # Dummy unit so it does not fail on unit checking in other functions\n        self.unit = 'SKIPPED'\n\n    def __str__(self):\n        return 'S{:05d}'.format(self.id)\npybufrkit/descriptors.py\nclass OperatorDescriptor(Descriptor):\n    \"\"\"\n    Operator Descriptor 2XXYYY\n    \"\"\"\n\n    def __init__(self, id_):\n        super(OperatorDescriptor, self).__init__(id_)\n\n    @property\n    def operator_code(self):\n        return self.id // 1000\n\n    @property\n    def operand_value(self):\n        return self.id % 1000\npybufrkit/descriptors.py\nclass DelayedReplicationDescriptor(ReplicationDescriptor):\n    \"\"\"\n    Delayed replication Descriptor 1XX000\n    \"\"\"\n\n    def __init__(self, id_, members=None, factor=None):\n        super(DelayedReplicationDescriptor, self).__init__(id_, members)\n        self.factor = factor\n\n    @property\n    def n_repeats(self):\n        raise PyBufrKitError('Cannot access n_repeats for Delayed Replication')\n\n    def accept(self, visitor):\n        visitor.visit_replication_descriptor(self)\n        visitor.visit_replication_factor(self.factor)\n        if not self.members:\n            visitor.visit_replication_descriptor_end(self)\n            return\n        for member in self.members:\n            member.accept(visitor)\n        visitor.visit_replication_descriptor_end(self)\npybufrkit/bufr.py\nclass SectionConfigurer(object):\n    \"\"\"\n    This class is responsible for loading the section config JSON files. It also\n    initialise and configure a requested Section.\n    \"\"\"\n\n    def __init__(self, definitions_dir=None):\n        definitions_dir = definitions_dir or os.path.join(BASE_DIR, 'definitions')\n        fnames = [fname for fname in os.listdir(definitions_dir)\n                  if fname.startswith('section') and fname.endswith('.json')]\n\n        log.debug(\"Reading definition json files from {}\".format(definitions_dir))\n\n        self.configurations = {}\n        for fname in fnames:\n            with open(os.path.join(definitions_dir, fname)) as ins:\n                index, edition = self.get_section_index_and_edition(fname)\n                data = json.load(ins)\n                if index not in self.configurations:\n                    self.configurations[index] = {}\n                config = self.configurations[index]\n                edition_key = DEFAULT_SECTION_EDITION if edition is None else edition\n                config[edition_key] = data\n                # If this config is default, also add it for the default key\n                if data.get('default', False) and edition_key != DEFAULT_SECTION_EDITION:\n                    config[DEFAULT_SECTION_EDITION] = data\n\n    def configure_section(self, bufr_message, section_index, configuration_transformers=()):\n        \"\"\"\n        Initialise and Configure a section for the give section index and\n        version.\n\n        :param BufrMessage bufr_message: The Bufr Message object to configure\n        :param int section_index: (Zero-based) index of the section\n        :param collection configuration_transformers: A collection of configuration\n            transformation functions. These functions make it possible to use\n            the same set of JSON files while still dynamically providing\n            different coder behaviours.\n        :return: The configured section or ``None`` if not present\n        \"\"\"\n\n        config = self.get_configuration(bufr_message, section_index)\n\n        for configuration_transformer in configuration_transformers:\n            config = configuration_transformer(config)\n\n        section = BufrSection()\n        section.set_metadata('index', config['index'])\n        section.set_metadata('description', config.get('description', ''))\n        section.set_metadata('optional', config.get('optional', False))\n        section.set_metadata('end_of_message', config.get('end_of_message', False))\n\n        for parameter in config['parameters']:\n            data_type = parameter['type']\n            nbits = parameter['nbits']\n            if data_type == 'bytes':\n                assert nbits % NBITS_PER_BYTE == 0, \\\n                    'nbits for bytes type must be integer multiple of 8: {}'.format(nbits)\n            section_parameter = SectionParameter(\n                parameter['name'],\n                nbits,\n                data_type,\n                parameter.get('expected', None),\n                parameter.get('as_property', False)\n            )\n            section.add_parameter(section_parameter)\n\n        # Check whether this section is optional. If it is optional, check whether it exists in the\n        # current message.\n        is_section_presents = (\n            not section.optional or\n            getattr(bufr_message, 'is_section{}_presents'.format(section_index)).value\n        )\n\n        # If the section exists, add the section for process other wise ignore it\n        if is_section_presents:\n            bufr_message.add_section(section)\n            return section\n        else:\n            log.info(\"Section {} is not present\".format(section_index))\n            return None\n\n    def get_configuration(self, bufr_message, section_index):\n        # When the bufr_message is first created, it has no edition information.\n        # So the default edition is used.\n        if bufr_message.edition is not None:\n            section_edition = bufr_message.edition.value or DEFAULT_SECTION_EDITION\n        else:\n            section_edition = DEFAULT_SECTION_EDITION\n\n        log.info(\"Configure Section {} of edition {}\".format(\n            section_index, section_edition if section_edition != DEFAULT_SECTION_EDITION else 'default'))\n\n        section_configs = self.configurations[section_index]\n\n        # Get the default config for the section if specific edition is not found\n        return section_configs.get(section_edition, section_configs[DEFAULT_SECTION_EDITION])\n\n    def configure_section_with_values(self, bufr_message, section_index, values, overrides=None):\n        \"\"\"\n        Initialise and Configure a section for the give section index and version\n        and also populate the value of each section parameter with the given list\n        of values. Used by the encoder.\n\n        :param BufrMessage bufr_message: The BUFR message object to configure\n        :param int section_index: The zero-based section index\n        :param list values: A list of values for the parameters.\n        :return: The configured section or ``None`` if the section is not present\n        \"\"\"\n        section = self.configure_section(bufr_message, section_index)\n        if section is not None:\n            assert len(section) == len(values), \\\n                'Number of Section parameters ({}) not equal to number of values to be encoded ({})'.format(\n                    len(section), len(values))\n            for idx, parameter in enumerate(section):\n                parameter.value = values[idx] if overrides is None else overrides.get(parameter.name, values[idx])\n\n        return section\n\n    @staticmethod\n    def get_section_index_and_edition(fname):\n        \"\"\"\n        Get Section Index and version from file name of a configuration file.\n\n        :param str fname: The base file name\n        :return: The index and edition numbers.\n        \"\"\"\n        expr = os.path.splitext(fname)[0][7:]\n        if '-' in expr:\n            fields = expr.split('-')\n            return int(fields[0]), int(fields[1])\n        else:\n            return int(expr), None\n\n    @staticmethod\n    def info_configuration(config):\n        \"\"\"\n        This is a configuration transformation function to make the decoder work\n        only for the part of message before the template data.\n\n        :param dict config: The config JSON object loaded from a configuration file.\n        \"\"\"\n        parameter_types = [parameter['type'] for parameter in config['parameters']]\n        if PARAMETER_TYPE_TEMPLATE_DATA in parameter_types:\n            new_config = deepcopy(config)\n            new_config['end_of_message'] = True\n            new_config['parameters'] = config['parameters'][:parameter_types.index(PARAMETER_TYPE_TEMPLATE_DATA)]\n            return new_config\n        else:\n            return config\n\n    @staticmethod\n    def ignore_value_expectation(config):\n        \"\"\"\n        Remove any expectation value check.\n\n        :param dict config: The config JSON object loaded from a configuration file.\n        \"\"\"\n        new_config = deepcopy(config)\n        for parameter in new_config['parameters']:\n            parameter['expected'] = None\n        return new_config\npybufrkit/constants.py\nUNITS_STRING = 'CCITT IA5'\npybufrkit/errors.py\nclass PyBufrKitError(Exception):\n    \"\"\"\n    This is the root exception object of the package.\n    \"\"\"\n\n    def __init__(self, message=''):\n        self.message = message\n\n    def __str__(self):\n        return 'Error: {}'.format(self.message)\npybufrkit/constants.py\nUNITS_FLAG_TABLE = 'FLAG TABLE'\npybufrkit/descriptors.py\nclass SequenceDescriptor(Descriptor):\n    \"\"\"\n    Sequence Descriptor 3XXYYY\n    \"\"\"\n\n    def __init__(self, id_, name, members=None):\n        super(SequenceDescriptor, self).__init__(id_)\n        self.members = members\n        self.name = name\n\n    def __iter__(self):\n        return iter(self.members)\n\n    def __getitem__(self, item):\n        return self.members.__getitem__(item)\n\n    def accept(self, visitor):\n        visitor.visit_sequence_descriptor(self)\n        if not self.members:\n            return\n        for member in self.members:\n            member.accept(visitor)\n        visitor.visit_sequence_descriptor_end(self)\npybufrkit/errors.py\nclass UnknownDescriptor(PyBufrKitError):\n    \"\"\"\n    An unknown, i.e. not found in BUFR tables, BUFR descriptor.\n    \"\"\"\npybufrkit/descriptors.py\nclass MarkerDescriptor(ElementDescriptor):\n    \"\"\"\n    A marker descriptor is useful in the case when marker operator descriptors\n    are used to signify a statistical value of an element descriptor. For an\n    example, 224255 and 225255.\n    \"\"\"\n\n    def __str__(self):\n        return '{}{:05d}'.format(\n            marker_descriptor_prefix.get(self.marker_id, 'M'),\n            self.id\n        )\n\n    @staticmethod\n    def from_element_descriptor(ed, marker_id,\n                                scale=None, refval=None, nbits=None):\n        \"\"\"\n        Create from a given element descriptor with the option to override its\n        scale, refval and nbits.\n\n        :param ElementDescriptor ed: The element descriptor\n        :param int marker_id: The marker operator ID\n        :param int scale: Overridden value for scale.\n        :param int refval: Overridden value for reference.\n        :param int nbits: Overridden value for number of bits.\n        :rtype: MarkerDescriptor\n        \"\"\"\n        md = MarkerDescriptor(\n            ed.id, ed.name, ed.unit,\n            ed.scale if scale is None else scale,\n            ed.refval if refval is None else refval,\n            ed.nbits if nbits is None else nbits,\n            ed.crex_unit, ed.crex_scale, ed.crex_nchars\n        )\n        md.marker_id = marker_id\n        return md\npybufrkit/descriptors.py\nclass AssociatedDescriptor(Descriptor):\n    \"\"\"\n    Associated field for element descriptor\n\n    :param int nbits: Number of bits used by this descriptor.\n    \"\"\"\n\n    def __init__(self, id_, nbits):\n        super(AssociatedDescriptor, self).__init__(id_)\n        self.nbits = nbits\n        # Dummy unit so it does not fail on unit checking in other functions\n        self.unit = 'ASSOCIATED'\n\n    def __str__(self):\n        return 'A{:05d}'.format(self.id)\n", "answers": ["            elif member_type is FixedReplicationDescriptor:"], "length": 1868, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "5342b06bc9ef391b79807b10296251b1b02924ec256969ac"}
{"input": "import java.io.IOException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.KeyPair;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Stopwatch;\nimport com.kryptnostic.api.v1.KryptnosticConnection;\nimport com.kryptnostic.api.v1.KryptnosticCryptoManager;\nimport com.kryptnostic.api.v1.client.DefaultKryptnosticClient;\nimport com.kryptnostic.api.v1.client.DefaultKryptnosticCryptoManager;\nimport com.kryptnostic.api.v1.client.KryptnosticRestAdapter;\nimport com.kryptnostic.api.v1.security.loaders.rsa.FreshRsaKeyLoader;\nimport com.kryptnostic.api.v1.security.loaders.rsa.LocalRsaKeyLoader;\nimport com.kryptnostic.api.v1.security.loaders.rsa.NetworkRsaKeyLoader;\nimport com.kryptnostic.directory.v1.http.UserDirectoryApi;\nimport com.kryptnostic.kodex.v1.authentication.CredentialFactory;\nimport com.kryptnostic.kodex.v1.client.KryptnosticClient;\nimport com.kryptnostic.kodex.v1.crypto.ciphers.AesCryptoService;\nimport com.kryptnostic.kodex.v1.crypto.ciphers.BlockCiphertext;\nimport com.kryptnostic.kodex.v1.crypto.ciphers.CryptoService;\nimport com.kryptnostic.kodex.v1.crypto.ciphers.Cypher;\nimport com.kryptnostic.kodex.v1.crypto.ciphers.PasswordCryptoService;\nimport com.kryptnostic.kodex.v1.exceptions.types.IrisException;\nimport com.kryptnostic.kodex.v1.exceptions.types.KodexException;\nimport com.kryptnostic.kodex.v1.exceptions.types.ResourceNotFoundException;\nimport com.kryptnostic.kodex.v1.exceptions.types.SecurityConfigurationException;\nimport com.kryptnostic.kodex.v1.marshalling.DeflatingJacksonMarshaller;\nimport com.kryptnostic.kodex.v1.serialization.jackson.KodexObjectMapperFactory;\nimport com.kryptnostic.kodex.v1.storage.DataStore;\nimport com.kryptnostic.krypto.engine.KryptnosticEngine;\nimport com.kryptnostic.v2.constants.Names;\nimport com.kryptnostic.v2.crypto.CryptoServiceLoader;\nimport com.kryptnostic.v2.crypto.KryptnosticCryptoServiceLoader;\nimport com.kryptnostic.v2.search.SearchApi;\nimport com.kryptnostic.v2.sharing.api.SharingApi;\nimport com.kryptnostic.v2.storage.api.KeyStorageApi;\nimport com.kryptnostic.v2.storage.api.ObjectListingApi;\nimport com.kryptnostic.v2.storage.api.ObjectStorageApi;\nimport com.kryptnostic.v2.storage.api.TypesApi;\nimport retrofit.RestAdapter;\nimport retrofit.client.Client;\n            Optional<byte[]> maybePrivateKeyBytes = Optional.fromNullable( dataStore\n                    .get( Names.FHE_PRIVATE_KEY ) );\n            Optional<byte[]> maybeSearchPrivateKeyBytes = Optional.fromNullable( dataStore\n                    .get( Names.FHE_SEARCH_PRIVATE_KEY ) );\n            Optional<byte[]> maybeClientHashFunction = Optional.fromNullable( dataStore\n                    .get( Names.CLIENT_HASH_FUNCTION ) );\n            boolean privateKeyPresent = maybePrivateKeyBytes.isPresent();\n            boolean searchPrivateKeyPresent = maybeSearchPrivateKeyBytes.isPresent();\n            boolean clientHashPresent = maybeClientHashFunction.isPresent();\n            if ( !privateKeyPresent || !searchPrivateKeyPresent || !clientHashPresent ) {\n                // If some keys are absent locally let's try and pull from the network.\n                throw new IOException( \"Unable to load kryptnostic engine keys.\" );\n            }\n            privateKey = privateKeyCryptoService.decryptBytes( mapper.readValue( maybePrivateKeyBytes.get(),\n                    BlockCiphertext.class ) );\n            searchPrivateKey = privateKeyCryptoService.decryptBytes( mapper.readValue( maybeSearchPrivateKeyBytes\n                    .get(),\n                    BlockCiphertext.class ) );\n            engine.initClient( privateKey, searchPrivateKey );\n            holder.clientHashFunction = maybeClientHashFunction.get();\n            return holder;\n        } catch ( SecurityConfigurationException | IOException e ) {\n            try {\n                Optional<BlockCiphertext> maybeEncryptedPrivateKey = keyStorageApi\n                        .getFHEPrivateKeyForCurrentUser();\n                Optional<BlockCiphertext> maybeEncryptedSearchPrivateKey = keyStorageApi\n                        .getFHESearchPrivateKeyForUser();\n                byte[] maybeClientHashFunction = keyStorageApi.getHashFunctionForCurrentUser();\n                // TODO: Check that the length matches the expected length for the client hash function.\n                if ( maybeEncryptedPrivateKey.isPresent() && maybeEncryptedSearchPrivateKey.isPresent()\n                        && ( maybeClientHashFunction.length > 0 ) ) {\n                    encryptedPrivateKey = maybeEncryptedPrivateKey.get();\n                    encryptedSearchPrivateKey = maybeEncryptedSearchPrivateKey.get();\n                    privateKey = privateKeyCryptoService.decryptBytes( encryptedPrivateKey );\n                    searchPrivateKey = privateKeyCryptoService.decryptBytes( encryptedSearchPrivateKey );\n\n                    engine.initClient( privateKey, searchPrivateKey );\n                    holder.clientHashFunction = maybeClientHashFunction;\n                } else {\n                    throw new SecurityConfigurationException( \"Unable to load FHE keys from server.\", e );\n                }\n            } catch ( SecurityConfigurationException e1 ) {\n                // If have a problem retrieving data from the serve or decrypting keys, we regenerate.\n                engine.initClient();\n                privateKey = Preconditions.checkNotNull( engine.getPrivateKey(),\n                        \"Private key from engine cannot be null.\" );\n                searchPrivateKey = Preconditions.checkNotNull( engine.getSearchPrivateKey(),\n                        \"Search private key cannot be null.\" );\n                holder.clientHashFunction = engine.getClientHashFunction();\n                /*\n                 * Need to flush to network since we just generated.\n                 */\n                try {\n                    encryptedPrivateKey = privateKeyCryptoService.encrypt( privateKey );\n                    encryptedSearchPrivateKey = privateKeyCryptoService.encrypt( searchPrivateKey );\n                    keyStorageApi.setHashFunctionForCurrentUser( holder.clientHashFunction );\n                    keyStorageApi.setFHEPrivateKeyForCurrentUser( encryptedPrivateKey );\n                    keyStorageApi.setFHESearchPrivateKeyForCurrentUser( encryptedSearchPrivateKey );\n                } catch ( SecurityConfigurationException e2 ) {\n                    throw new IrisException( e2 );\n                }\n            }\n\n            /*\n             * If we got here then keys came from network or were freshly created and need to be flushed to disk.\n             */\n            try {\n                dataStore.put( Names.FHE_PRIVATE_KEY,\n                        mapper.writeValueAsBytes( encryptedPrivateKey ) );\n                dataStore.put( Names.FHE_SEARCH_PRIVATE_KEY,\n                        mapper.writeValueAsBytes( encryptedSearchPrivateKey ) );\n                dataStore.put( Names.CLIENT_HASH_FUNCTION,\n                        mapper.writeValueAsBytes( holder.clientHashFunction ) );\n\n            } catch ( IOException e1 ) {\n                logger.error( \"Unable to configure FHE keys.\", e1 );\n                throw new Error( \"Sad times.Freeze? I'm a robot. I'm not a refrigerator. \", e1 );\n            }\n\n        }\n\n        return holder;\n    }\n\n    @Override\n    public byte[] getClientHashFunction() {\n        return clientHashFunction;\n    }\n\n    @Override\n    public ObjectStorageApi getObjectStorageApi() {\n        return objectStorageApi;\n    }\n\n    @Override\n    public ObjectListingApi getObjectListingApi() {\n        return objectListingApi;\n    }\n\n    @Override\n    public SearchApi getSearchApi() {\n        return searchApi;\n    }\n\n    @Override\n    public SharingApi getSharingApi() {\n        return sharingApi;\n    }\n\n    @Override\n    public UserDirectoryApi getDirectoryApi() {\n        return userDirectoryApi;\n    }\n\n    @Override\n    public KeyStorageApi getKeyStorageApi() {\n        return keyStorageApi;\n    }\n\n    @Override", "context": "src/main/java/com/kryptnostic/api/v1/client/KryptnosticRestAdapter.java\npublic final class KryptnosticRestAdapter {\n    private KryptnosticRestAdapter() {}\n\n    private static final Logger logger = LoggerFactory.getLogger( KryptnosticRestAdapter.class );\n\n    public static RestAdapter create( Client client, KryptnosticConnection connection ) {\n        return builder( connection, new KryptnosticConverter() ).setClient( client )\n                .build();\n    }\n\n    public static RestAdapter create( KryptnosticConnection connection ) {\n        return createWithDefaultClient( connection );\n    }\n\n    public static RestAdapter createWithDefaultClient( KryptnosticConnection connection ) {\n        return builder( connection, new KryptnosticConverter() ).build();\n    }\n\n    public static RestAdapter createWithDefaultJacksonConverter( KryptnosticConnection connection ) {\n        return builder( connection, new KryptnosticConverter() ).build();\n    }\n\n    public static RestAdapter createWithDefaultJacksonConverter( String url, UUID user, String userCredential ) {\n        return builder( url, user, userCredential, new KryptnosticConverter() ).build();\n    }\n\n    public static RestAdapter createWithByteArrayJacksonConverter(\n            String url,\n            UUID user,\n            String userCredential,\n            Client client ) {\n        return builder( url, user, userCredential, new ByteArrayConverter() ).setClient( client ).build();\n    }\n\n    public static RestAdapter createWithDefaultJacksonConverter(\n            String url,\n            UUID user,\n            String userCredential,\n            Client client ) {\n        return builder( url, user, userCredential, new KryptnosticConverter() ).setClient( client ).build();\n    }\n\n    public static RestAdapter createWithNoAuthAndDefaultJacksonConverter( String url, Client client ) {\n        return new RestAdapter.Builder().setConverter( new KryptnosticConverter() ).setEndpoint( url )\n                .setErrorHandler( new DefaultErrorHandler() ).setLogLevel( LogLevel.FULL ).setClient( client )\n                .setLog( new RestAdapter.Log() {\n                    @Override\n                    public void log( String msg ) {\n                        logger.debug( msg.replaceAll( \"%\", \"[percent]\" ) );\n                    }\n                } ).build();\n    }\n\n    public static RestAdapter.Builder builder( KryptnosticConnection connection, Converter converter ) {\n        return builder( connection.getUrl(), connection.getUserId(), connection.getUserCredential(), converter );\n    }\n\n    public static RestAdapter.Builder builder( String url, UUID user, String userCredential, Converter converter ) {\n        return new RestAdapter.Builder().setConverter( converter ).setEndpoint( url )\n                .setRequestInterceptor( new PreauthenticationRequestInterceptor( user, userCredential ) )\n                .setErrorHandler( new DefaultErrorHandler() ).setLogLevel( LogLevel.FULL )\n                .setLog( new RestAdapter.Log() {\n                    @Override\n                    public void log( String msg ) {\n                        logger.debug( msg.replaceAll( \"%\", \"[percent]\" ) );\n                    }\n                } );\n    }\n}\nsrc/main/java/com/kryptnostic/api/v1/security/loaders/rsa/LocalRsaKeyLoader.java\npublic final class LocalRsaKeyLoader extends RsaKeyLoader {\n    private final ObjectMapper  mapper = KodexObjectMapperFactory.getObjectMapper();\n    private final CryptoService crypto;\n    private final DataStore     dataStore;\n    private final KeyStorageApi keyClient;\n    // private final DirectoryApi directoryClient;\n\n    public LocalRsaKeyLoader( CryptoService crypto, KeyStorageApi keyClient, DataStore dataStore )\n            throws KodexException {\n        if ( crypto == null || dataStore == null || keyClient == null ) {\n            throw new KodexException(\n                    \"Crypto service, key network client, and data store are required to load from disk\" );\n        }\n        this.keyClient = keyClient;\n        this.crypto = crypto;\n        this.dataStore = dataStore;\n    }\n\n    @Override\n    protected KeyPair tryLoading() throws KodexException {\n        try {\n            byte[] encryptedPrivateKeyBytes = Preconditions.checkNotNull(\n                    dataStore.get( PrivateKey.class.getCanonicalName() ),\n                    \"Couldn't load private key from data store.\" );\n            BlockCiphertext privateKeyCiphertext = mapper.readValue( encryptedPrivateKeyBytes, BlockCiphertext.class );\n\n            // need to check if local privateKey is synced with the server and user is authenticated\n\n            BlockCiphertext networkPrivateKey = null;\n            networkPrivateKey = keyClient.getRSAPrivateKey();\n            if ( networkPrivateKey == null ) {\n                throw new KodexException( \"User not recognized\" );\n            }\n\n            byte[] decryptedPrivateKeyBytes = crypto.decryptBytes( privateKeyCiphertext );\n\n            byte[] decryptedPublicKeyBytes = Preconditions.checkNotNull(\n                    dataStore.get( PublicKey.class.getCanonicalName() ),\n                    \"Couldn't load public key from data store.\" );\n\n            PrivateKey rsaPrivateKey = Keys.privateKeyFromBytes( PublicKeyAlgorithm.RSA, decryptedPrivateKeyBytes );\n            PublicKey rsaPublicKey = Keys.publicKeyFromBytes( PublicKeyAlgorithm.RSA, decryptedPublicKeyBytes );\n\n            return new KeyPair( rsaPublicKey, rsaPrivateKey );\n        } catch (\n                InvalidKeySpecException\n                | NoSuchAlgorithmException\n                | SecurityConfigurationException\n                | IOException\n                | NullPointerException e ) {\n            throw new KodexException( e );\n        }\n\n    }\n}\nsrc/main/java/com/kryptnostic/v2/crypto/KryptnosticCryptoServiceLoader.java\npublic class KryptnosticCryptoServiceLoader implements CryptoServiceLoader {\n    private static final Logger                                   logger = LoggerFactory\n                                                                                 .getLogger( KryptnosticCryptoServiceLoader.class );\n\n    private final LoadingCache<VersionedObjectKey, CryptoService> keyCache;\n    private KeyStorageApi                                         keyStorageApi;\n    private ObjectStorageApi                                      objectStorageApi;\n    private KryptnosticConnection                                 connection;\n    private Cypher                                                cypher;\n\n    public KryptnosticCryptoServiceLoader(\n            final KryptnosticConnection connection,\n            final KeyStorageApi keyApi,\n            ObjectStorageApi objectStorageApi,\n            Cypher cypher ) {\n        this.keyStorageApi = keyApi;\n        this.objectStorageApi = objectStorageApi;\n        this.connection = connection;\n        this.cypher = cypher;\n        keyCache = CacheBuilder.newBuilder().maximumSize( 1000 ).expireAfterWrite( 10, TimeUnit.MINUTES )\n                // TODO: make this a separate class\n                .build( new CacheLoader<VersionedObjectKey, CryptoService>() {\n                    @Override\n                    public Map<VersionedObjectKey, CryptoService> loadAll( Iterable<? extends VersionedObjectKey> keys )\n                            throws IOException,\n                            SecurityConfigurationException {\n                        VersionedObjectKeySet ids = new VersionedObjectKeySet();\n\n                        for ( VersionedObjectKey key : keys ) {\n                            ids.add( key );\n                        }\n\n                        Map<VersionedObjectKey, BlockCiphertext> data = keyApi.getAesEncryptedCryptoServices( ids );\n                        if ( data.size() != ids.size() ) {\n                            throw new InvalidCacheLoadException( \"Unable to retrieve all keys.\" );\n                        }\n                        Map<VersionedObjectKey, CryptoService> processedData = Maps.newHashMap();\n\n                        for ( Entry<VersionedObjectKey, BlockCiphertext> entry : data.entrySet() ) {\n                            BlockCiphertext crypto = entry.getValue();\n                            if ( crypto != null ) {\n                                CryptoService service = connection.newCryptoManager().getRsaCryptoService().decrypt(\n                                        crypto.getContents(), // TODO: is this chrrect????\n                                        AesCryptoService.class );\n                                processedData.put( entry.getKey(), service );\n                            }\n                        }\n                        return processedData;\n                    }\n\n                    @Override\n                    public CryptoService load( VersionedObjectKey key ) throws IOException,\n                            SecurityConfigurationException {\n                        BlockCiphertext crypto = keyApi.getAesEncryptedObjectCryptoService( key.getObjectId(),\n                                key.getVersion() );\n                        if ( crypto == null ) {\n                            try {\n                                CryptoService cs = new AesCryptoService( KryptnosticCryptoServiceLoader.this.cypher );\n                                put( key, cs );\n                                return cs;\n                            } catch (\n                                    NoSuchAlgorithmException\n                                    | InvalidAlgorithmParameterException\n                                    | ExecutionException e ) {\n                                logger.error( \"Failed while trying to create new crypto service for object id: {} \",\n                                        key, e );\n                            }\n                        }\n                        return connection\n                                .newCryptoManager()\n                                .getRsaCryptoService()\n                                .decrypt( crypto.getContents(), AesCryptoService.class );// TODO isthis correct???\n                    }\n                } );\n    }\n\n    @Override\n    public Optional<CryptoService> get( VersionedObjectKey id ) throws ExecutionException {\n        if ( id == null ) {\n            return Optional.absent();\n        }\n        return Optional.fromNullable( keyCache.get( id ) );\n    }\n\n    @Override\n    public void put( VersionedObjectKey id, CryptoService service ) throws ExecutionException {\n        keyCache.put( id, service );\n        try {\n            byte[] cs = connection.newCryptoManager().getRsaCryptoService().encrypt( service );\n            keyStorageApi.setObjectCryptoService( id.getObjectId(), cs ); // TODO: is this correct???\n        } catch ( SecurityConfigurationException | IOException e ) {\n            throw new ExecutionException( e );\n        }\n    }\n\n    @Override\n    public Map<VersionedObjectKey, CryptoService> getAll( Set<VersionedObjectKey> ids ) throws ExecutionException {\n        return keyCache.getAllPresent( ids );\n    }\n\n    @Override\n    public void clear() {\n        keyCache.invalidateAll();\n        keyCache.cleanUp();\n    }\n\n    @Override\n    public Cypher getCypher() {\n        return cypher;\n    }\n\n    @Override\n    public Optional<CryptoService> getLatest( UUID id ) throws ExecutionException {\n        return get( VersionedObjectKey.fromObjectMetadata( objectStorageApi.getObjectMetadata( id ) ) );\n    }\n}\nsrc/main/java/com/kryptnostic/api/v1/security/loaders/rsa/NetworkRsaKeyLoader.java\npublic final class NetworkRsaKeyLoader extends RsaKeyLoader {\n    private static final Logger         logger = LoggerFactory.getLogger( NetworkRsaKeyLoader.class );\n    private final PasswordCryptoService crypto;\n    private final KeyStorageApi         keyApi;\n    private final UUID                  userKey;\n\n    public NetworkRsaKeyLoader( PasswordCryptoService crypto, KeyStorageApi keyApi, UUID userKey ) throws KodexException {\n        if ( crypto == null || keyApi == null || userKey == null ) {\n            throw new KodexException( \"null values\" );\n        }\n        this.crypto = crypto;\n        this.keyApi = keyApi;\n        this.userKey = userKey;\n    }\n\n    @Override\n    protected KeyPair tryLoading() throws KodexException {\n        BlockCiphertext rsaPrivateKeyCiphertext = null;\n        byte[] pubKey = null;\n        rsaPrivateKeyCiphertext = keyApi.getRSAPrivateKey();\n        pubKey = keyApi.getRSAPublicKey( userKey );\n        if ( rsaPrivateKeyCiphertext == null || pubKey == null ) {\n            throw new KodexException( \"Encryption keys could not be retrieved from the network\" );\n        }\n\n        try {\n            byte[] decryptedPrivateKeyBytes = crypto.decryptBytes( rsaPrivateKeyCiphertext );\n            byte[] publicKeyBytes = pubKey;\n\n            PrivateKey rsaPrivateKey = Keys.privateKeyFromBytes( PublicKeyAlgorithm.RSA, decryptedPrivateKeyBytes );\n            PublicKey rsaPublicKey = Keys.publicKeyFromBytes( PublicKeyAlgorithm.RSA, publicKeyBytes );\n\n            return new KeyPair( rsaPublicKey, rsaPrivateKey );\n\n        } catch ( SecurityConfigurationException | InvalidKeySpecException | NoSuchAlgorithmException e ) {\n            throw new KodexException( e );\n        }\n    }\n}\nsrc/main/java/com/kryptnostic/api/v1/client/DefaultKryptnosticClient.java\npublic class DefaultKryptnosticClient implements KryptnosticClient {\n    private final SearchClient    searchClient;\n    private final StorageClient   storageClient;\n    private final SharingClient   sharingClient;\n    private final DirectoryClient directoryClient;\n\n    public DefaultKryptnosticClient( KryptnosticConnection connection ) throws IrisException,\n            ResourceNotFoundException, ClassNotFoundException, IOException, ExecutionException, SecurityConfigurationException {\n        this(\n                new DefaultSearchClient( connection ),\n                new KryptnosticStorageClient( connection ),\n                new SharingManager( connection ),\n                new DefaultDirectoryClient( connection ) );\n    }\n\n    public DefaultKryptnosticClient(\n            SearchClient searchClient,\n            StorageClient storageClient,\n            SharingClient sharingClient,\n            DirectoryClient directoryClient ) {\n        this.searchClient = searchClient;\n        this.storageClient = storageClient;\n        this.sharingClient = sharingClient;\n        this.directoryClient = directoryClient;\n    }\n\n    @Override\n    public SharingClient getSharingClient() {\n        return sharingClient;\n    }\n\n    @Override\n    public DirectoryClient getDirectoryClient() {\n        return this.directoryClient;\n    }\n\n    @Override\n    public SearchClient getSearchClient() {\n        return this.searchClient;\n    }\n\n    @Override\n    public StorageClient getStorageClient() {\n        return this.storageClient;\n    }\n}\nsrc/main/java/com/kryptnostic/api/v1/security/loaders/rsa/FreshRsaKeyLoader.java\npublic final class FreshRsaKeyLoader extends RsaKeyLoader {\n    @Override\n    protected KeyPair tryLoading() throws KodexException {\n        KeyPair keyPair;\n        try {\n            keyPair = Keys.generateRsaKeyPair( KEY_SIZE );\n\n            return keyPair;\n        } catch ( NoSuchAlgorithmException e ) {\n            throw new KodexException( e );\n        }\n    }\n}\nsrc/main/java/com/kryptnostic/api/v1/KryptnosticConnection.java\npublic interface KryptnosticConnection {\n    //TODO: Move this somewhere else.\n    String MASTER_CRYPTO_SERVICE = \"master-crypto-service\";\n    /**\n     * Retrieves the security principal for this connection.\n     *\n     * @return The UUID of the security principal for this connection.\n     */\n    UUID getUserId();\n\n    /**\n     * Retrieves the authenticator for this connection.\n     *\n     * @return A string representation of the authenticator for this connection.\n     */\n    // TODO: Is this base64 or Hex?\n    String getUserCredential();\n\n    PrivateKey getPrivateKey();\n\n    PublicKey getPublicKey();\n    \n    CryptoService getMasterCryptoService();\n\n    KryptnosticEngine getKryptnosticEngine();\n\n    byte[] getClientHashFunction();\n\n    String getUrl();\n\n    CryptoServiceLoader getCryptoServiceLoader();\n\n    KeyStorageApi getCryptoKeyStorageApi();\n\n    ObjectStorageApi getObjectStorageApi();\n\n    ObjectListingApi getObjectListingApi();\n\n    SearchApi getSearchApi();\n\n    SharingApi getSharingApi();\n\n    UserDirectoryApi getDirectoryApi();\n\n    KeyStorageApi getKeyStorageApi();\n    \n    TypesApi getTypesApi();\n\n    DataStore getLocalDataStore();\n\n    /**\n     * Retrieves the higher level client API.\n     *\n     * @return An instance of {@link KryptnosticClient}\n     * @throws ResourceNotFoundException\n     * @throws IrisException\n     * @throws ClassNotFoundException\n     * @throws SecurityConfigurationException \n     * @throws ExecutionException \n     * @throws IOException \n     */\n    KryptnosticClient newClient() throws ClassNotFoundException, IrisException, ResourceNotFoundException, IOException, ExecutionException, SecurityConfigurationException;\n\n    KryptnosticCryptoManager newCryptoManager();\n\n}\nsrc/main/java/com/kryptnostic/api/v1/client/DefaultKryptnosticCryptoManager.java\npublic class DefaultKryptnosticCryptoManager implements KryptnosticCryptoManager {\n    private final SharingApi            sharingApi;\n    private final KeyStorageApi         keyStorageApi;\n    private final SearchApi             searchApi;\n    private final KryptnosticConnection connection;\n    private final Mac                   hmac;\n\n    private static final Logger         logger = LoggerFactory\n                                                       .getLogger( DefaultKryptnosticCryptoManager.class );\n\n    public DefaultKryptnosticCryptoManager(\n            KryptnosticConnection connection ) {\n        this.sharingApi = connection.getSharingApi();\n        this.keyStorageApi = connection.getKeyStorageApi();\n        this.searchApi = connection.getSearchApi();\n        this.connection = connection;\n        hmac = HmacUtils.getHmacSha256( connection.getMasterCryptoService().getSecretKey() );\n    }\n\n    @Override\n    public void registerObjectSearchPair( VersionedObjectKey objectId, ObjectSearchPair indexPair ) {\n        sharingApi.addSearchPairs( ImmutableSet.of( new VersionedObjectSearchPair( objectId, indexPair ) ) );\n    }\n\n    @Override\n    public void registerObjectSearchPairs( Set<VersionedObjectSearchPair> indexPairs ) {\n        sharingApi.addSearchPairs( indexPairs );\n    }\n\n    @Override\n    public byte[] generateIndexForToken( String token, byte[] objectIndexPair ) {\n        byte[] searchHash = getHashedToken( token );\n        byte[] indexForTerm = connection.getKryptnosticEngine().clientGetMetadatumAddress( objectIndexPair,\n                searchHash );\n        return indexForTerm;\n    }\n\n    public static byte[] getHashedToken( String token ) {\n        return foldByteArray( Hashing.sha256().hashBytes( token.getBytes( Charsets.UTF_16 ) ).asBytes() );\n    }\n\n    public static byte[] foldByteArray( byte[] input ) {\n        Preconditions.checkState( ( input.length & 1 ) == 0, \"Length of input must be divisible by 2.\" );\n        byte[] folded = new byte[ input.length >>> 1 ];\n        for ( int i = 0; i < folded.length; ++i ) {\n            folded[ i ] = (byte) ( input[ i ] ^ input[ i + folded.length ] );\n        }\n        if ( folded.length != 16 ) {\n            logger.warn( \"Unexpected hash lenght: {}\", folded.length );\n        }\n        return folded;\n    }\n\n    @Override\n    public byte[] prepareSearchToken( String term ) {\n        return connection.getKryptnosticEngine().getEncryptedSearchToken( getHashedToken( term ) );\n    }\n\n    @Override\n    public byte[] rsaDecrypt( byte[] ciphertext ) throws SecurityConfigurationException {\n        return Cyphers.decrypt( RsaKeyLoader.CIPHER, connection.getPrivateKey(), ciphertext );\n    }\n\n    @Override\n    public byte[] rsaEncrypt( byte[] plaintext ) throws SecurityConfigurationException {\n        return Cyphers.encrypt( RsaKeyLoader.CIPHER, connection.getPublicKey(), plaintext );\n    }\n\n    @Override\n    public Map<UUID, RsaCompressingEncryptionService> getEncryptionServiceForUsers( Set<UUID> users ) {\n        return Maps.asMap( users, new Function<UUID, RsaCompressingEncryptionService>() {\n\n            @Override\n            public RsaCompressingEncryptionService apply( UUID input ) {\n                try {\n                    return new RsaCompressingEncryptionService( RsaKeyLoader.CIPHER, new PublicKeyEnvelope(\n                            keyStorageApi.getRSAPublicKey(\n                                    input ) ).asRsaPublicKey() );\n                } catch (\n                        InvalidKeySpecException\n                        | NoSuchAlgorithmException\n                        | SecurityConfigurationException e ) {\n                    return null;\n                }\n            }\n        } );\n    }\n\n    @Override\n    public RsaCompressingCryptoService getRsaCryptoService() throws SecurityConfigurationException {\n        return new RsaCompressingCryptoService(\n                RsaKeyLoader.CIPHER,\n                connection.getPrivateKey(),\n                connection.getPublicKey() );\n    }\n\n    @Override\n    public byte[] computeSearchToken( String term ) {\n        return hmac.doFinal( StringUtils.getBytesUtf16( term ) );\n    }\n\n    @Override\n    public int getIndexBucketSize( VersionedObjectKey objectKey ) {\n        return 0;\n    }\n}\nsrc/main/java/com/kryptnostic/kodex/v1/client/KryptnosticClient.java\npublic interface KryptnosticClient {\n    DirectoryClient getDirectoryClient();\n\n    SharingClient getSharingClient();\n\n    SearchClient getSearchClient();\n\n    StorageClient getStorageClient();\n}\nsrc/main/java/com/kryptnostic/api/v1/KryptnosticCryptoManager.java\npublic interface KryptnosticCryptoManager {\n\n    byte[] rsaDecrypt( byte[] ciphertext ) throws SecurityConfigurationException;\n\n    byte[] rsaEncrypt( byte[] plaintext ) throws SecurityConfigurationException;\n\n    void registerObjectSearchPair( VersionedObjectKey objectKey, ObjectSearchPair objectSearchPair );\n\n    byte[] prepareSearchToken( String token );\n\n    Map<UUID, RsaCompressingEncryptionService> getEncryptionServiceForUsers( Set<UUID> users );\n\n    RsaCompressingCryptoService getRsaCryptoService() throws SecurityConfigurationException;\n\n    byte[] generateIndexForToken( String token, byte[] objectIndexPair );\n\n    void registerObjectSearchPairs( Set<VersionedObjectSearchPair> indexPairs );\n\n    byte[] computeSearchToken( String token );\n    \n    int getIndexBucketSize( VersionedObjectKey objectKey );\n}\n", "answers": ["    public KryptnosticClient newClient() throws ClassNotFoundException, IrisException, ResourceNotFoundException,"], "length": 2334, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "f665afe71c506cbe15d8afc63ccfea2ed597744f019d0580"}
{"input": "import sys\nimport math\nimport decimal\nfrom ..datatypes import Duration, DayTimeDuration, YearMonthDuration, \\\n    StringProxy, AnyURI, Float10\nfrom ..namespaces import XML_ID, XML_LANG, get_prefixed_name\nfrom ..xpath_nodes import TextNode, is_xpath_node, is_document_node, \\\n    is_element_node, is_comment_node, is_processing_instruction_node, node_name\nfrom ..xpath_token import XPathFunction\nfrom ._xpath1_operators import XPath1Parser\n#\n# Copyright (c), 2018-2021, SISSA (International School for Advanced Studies).\n# All rights reserved.\n# This file is distributed under the terms of the MIT License.\n# See the file 'LICENSE' in the root directory of the present\n# distribution, or http://opensource.org/licenses/MIT.\n#\n# @author Davide Brunato <brunato@sissa.it>\n#\n# type: ignore\n\"\"\"\nXPath 1.0 implementation - part 3 (functions)\n\"\"\"\n\n\nmethod = XPath1Parser.method\nfunction = XPath1Parser.function\n\n\n###\n# Kind tests (for matching of node types in XPath 1.0 or sequence types in XPath 2.0)\n@method(function('node', nargs=0, label='kind test'))\ndef select_node_kind_test(self, context=None):\n    if context is None:\n        raise self.missing_context()\n\n    for item in context.iter_children_or_self():\n        if item is None:\n            yield context.root\n        elif is_xpath_node(item):\n            yield item\n\n\n@method('node')\ndef nud_item_sequence_type(self):\n", "context": "elementpath/xpath_token.py\nclass XPathFunction(XPathToken):\n    \"\"\"\n    A token for processing XPath functions.\n    \"\"\"\n    _name: Optional[QName] = None\n    pattern = r'(?<!\\$)\\b[^\\d\\W][\\w.\\-\\xb7\\u0300-\\u036F\\u203F\\u2040]*' \\\n              r'(?=\\s*(?:\\(\\:.*\\:\\))?\\s*\\((?!\\:))'\n\n    sequence_types: Tuple[str, ...] = ()\n    \"Sequence types of arguments and of the return value of the function.\"\n\n    nargs: NargsType = None\n    \"Number of arguments: a single value or a couple with None that means unbounded.\"\n\n    body: Optional[XPathToken] = None\n    \"Body of anonymous inline function.\"\n\n    variables: Optional[Dict[str, Any]] = None\n    \"Optional variables linked by let and for expressions.\"\n\n    def __init__(self, parser: 'XPath1Parser', nargs: Optional[int] = None) -> None:\n        super().__init__(parser)\n        if isinstance(nargs, int) and nargs != self.nargs:\n            if nargs < 0:\n                raise self.error('XPST0017', 'number of arguments must be non negative')\n            elif self.nargs is None:\n                self.nargs = nargs\n            elif isinstance(self.nargs, int):\n                raise self.error('XPST0017', 'incongruent number of arguments')\n            elif self.nargs[0] > nargs or self.nargs[1] is not None and self.nargs[1] < nargs:\n                raise self.error('XPST0017', 'incongruent number of arguments')\n            else:\n                self.nargs = nargs\n\n    def __call__(self, context: Optional[XPathContext] = None,\n                 argument_list: Optional[Union[\n                     XPathToken,\n                     List[Union[XPathToken, AtomicValueType]],\n                     Tuple[Union[XPathToken, AtomicValueType], ...]\n                 ]] = None) -> Any:\n\n        args: List[Any] = []\n        if isinstance(argument_list, (list, tuple)):\n            args.extend(argument_list)\n        elif isinstance(argument_list, XPathToken):\n            tk = argument_list\n            while True:\n                if tk.symbol == ',':\n                    args.append(tk[1].evaluate(context))\n                    tk = tk[0]\n                else:\n                    args.append(tk.evaluate(context))\n                    break\n            args.reverse()\n\n        # Check provided argument with arity\n        if self.nargs is None or self.nargs == len(args):\n            pass\n        elif isinstance(self.nargs, tuple):\n            if len(args) < self.nargs[0]:\n                raise self.error('XPTY0004', \"missing required arguments\")\n            elif self.nargs[1] is not None and len(args) > self.nargs[1]:\n                raise self.error('XPTY0004', \"too many arguments\")\n        elif self.nargs > len(args):\n            raise self.error('XPTY0004', \"missing required arguments\")\n        else:\n            raise self.error('XPTY0004', \"too many arguments\")\n\n        context = copy(context)\n        if self.variables is not None and context is not None:\n            context.variables.update(self.variables)\n\n        if self.symbol == 'function':\n            if context is None:\n                raise self.missing_context()\n            elif not args and self:\n                if context.item is None:\n                    if is_document_node(context.root):\n                        context.item = cast(DocumentProtocol, context.root).getroot()\n                    else:\n                        context.item = context.root\n\n                args.append(context.item)\n\n            partial_function = False\n            if self.variables is None:\n                self.variables = {}\n\n            for variable, sequence_type, value in zip(self, self.sequence_types, args):\n                varname = cast(str, variable[0].value)\n\n                if isinstance(value, XPathToken) and value.symbol == '?':\n                    partial_function = True\n                    continue\n                elif isinstance(value, XPathFunction) and sequence_type.startswith('function('):\n                    if not value.match_function_test(sequence_type, as_argument=True):\n                        msg = \"argument {!r}: {} does not match sequence type {}\"\n                        raise self.error('XPTY0004', msg.format(varname, value, sequence_type))\n\n                elif not self.parser.match_sequence_type(value, sequence_type):\n                    value = self.cast_to_primitive_type(value, sequence_type)\n                    if not self.parser.match_sequence_type(value, sequence_type):\n                        msg = \"argument {!r}: {} does not match sequence type {}\"\n                        raise self.error('XPTY0004', msg.format(varname, value, sequence_type))\n\n                context.variables[varname] = self.variables[varname] = value\n\n            if partial_function:\n                return self\n\n        elif self.label == 'partial function':\n            for value, tk in zip(args, filter(lambda x: x.symbol == '?', self)):\n                if isinstance(value, XPathToken):\n                    tk.value = value.evaluate(context)\n                else:\n                    assert not isinstance(value, Token), \"An atomic value or None expected\"\n                    tk.value = value\n        else:\n            self.clear()\n            for value in args:\n                if isinstance(value, XPathToken):\n                    self.append(value)\n                else:\n                    assert not isinstance(value, Token), \"An atomic value or None expected\"\n                    self.append(ValueToken(self.parser, value=value))\n\n            if any(tk.symbol == '?' for tk in self._items):\n                self._partial_function()\n                return self\n\n        if isinstance(self.label, MultiLabel):\n            # Disambiguate multi-label tokens\n            if self.namespace == XSD_NAMESPACE and \\\n                    'constructor function' in self.label.values:\n                self.label = 'constructor function'\n            else:\n                for label in self.label.values:\n                    if label.endswith('function'):\n                        self.label = label\n                        break\n\n        if self.label == 'partial function':\n            result = self._partial_evaluate(context)\n        elif self.body is not None:\n            assert self.label == 'inline function'\n            result = self.body.evaluate(context)\n        else:\n            result = self.evaluate(context)\n\n        if isinstance(result, XPathToken) and result.symbol == '?':\n            pass\n        elif not self.parser.match_sequence_type(result, self.sequence_types[-1]):\n            result = self.cast_to_primitive_type(result, self.sequence_types[-1])\n            if not self.parser.match_sequence_type(result, self.sequence_types[-1]):\n                msg = \"{!r} does not match sequence type {}\"\n                self.parser.match_sequence_type(result, self.sequence_types[-1])\n                raise self.error('XPTY0004', msg.format(result, self.sequence_types[-1]))\n\n        return result\n\n    @property\n    def source(self) -> str:\n        if self.label == 'function test':\n            if len(self.sequence_types) == 1 and self.sequence_types[0] == '*':\n                return 'function(*)'\n            else:\n                return 'function(%s) as %s' % (\n                    ', '.join(self.sequence_types[:-1]), self.sequence_types[-1]\n                )\n        elif self.label in ('sequence type', 'kind test', ''):\n            return '%s(%s)%s' % (\n                self.symbol, ', '.join(item.source for item in self), self.occurrence or ''\n            )\n        return '%s(%s)' % (self.symbol, ', '.join(item.source for item in self))\n\n    @property\n    def name(self) -> Optional[QName]:\n        if self._name is not None:\n            return self._name\n        elif self.symbol == 'function':\n            return None\n        elif self.label == 'partial function':\n            return None\n        elif not self.namespace or self.namespace == XPATH_FUNCTIONS_NAMESPACE:\n            self._name = QName(XPATH_FUNCTIONS_NAMESPACE, 'fn:%s' % self.symbol)\n        elif self.namespace == XSD_NAMESPACE:\n            self._name = QName(XSD_NAMESPACE, 'xs:%s' % self.symbol)\n        elif self.namespace == XPATH_MATH_FUNCTIONS_NAMESPACE:\n            self._name = QName(XPATH_MATH_FUNCTIONS_NAMESPACE, 'math:%s' % self.symbol)\n        else:\n            for pfx, uri in self.parser.namespaces.items():\n                if uri == self.namespace:\n                    self._name = QName(uri, f'{pfx}:{self.symbol}')\n                    break\n            else:\n                self._name = QName(self.namespace, self.symbol)\n\n        return self._name\n\n    @property\n    def arity(self) -> int:\n        if isinstance(self.nargs, int):\n            return self.nargs\n        return len(self._items)\n\n    def nud(self) -> 'XPathFunction':\n        code = 'XPST0017' if self.label == 'function' else 'XPST0003'\n        self.value = None\n        self.parser.advance('(')\n        if self.nargs is None:\n            del self._items[:]\n            if self.parser.next_token.symbol in (')', '(end)'):\n                raise self.error(code, 'at least an argument is required')\n            while True:\n                self.append(self.parser.expression(5))\n                if self.parser.next_token.symbol != ',':\n                    break\n                self.parser.advance()\n        elif self.nargs == 0:\n            if self.parser.next_token.symbol != ')':\n                if self.parser.next_token.symbol != '(end)':\n                    raise self.error(code, '%s has no arguments' % str(self))\n                raise self.parser.next_token.wrong_syntax()\n            self.parser.advance()\n            return self\n        else:\n            if isinstance(self.nargs, (tuple, list)):\n                min_args, max_args = self.nargs\n            else:\n                min_args = max_args = self.nargs\n\n            k = 0\n            while k < min_args:\n                if self.parser.next_token.symbol in (')', '(end)'):\n                    msg = 'Too few arguments: expected at least %s arguments' % min_args\n                    raise self.wrong_nargs(msg if min_args > 1 else msg[:-1])\n\n                self._items[k:] = self.parser.expression(5),\n                k += 1\n                if k < min_args:\n                    if self.parser.next_token.symbol == ')':\n                        msg = 'Too few arguments: expected at least %s arguments' % min_args\n                        raise self.error(code, msg if min_args > 1 else msg[:-1])\n                    self.parser.advance(',')\n\n            while max_args is None or k < max_args:\n                if self.parser.next_token.symbol == ',':\n                    self.parser.advance(',')\n                    self._items[k:] = self.parser.expression(5),\n                elif k == 0 and self.parser.next_token.symbol != ')':\n                    self._items[k:] = self.parser.expression(5),\n                else:\n                    break  # pragma: no cover\n                k += 1\n\n            if self.parser.next_token.symbol == ',':\n                msg = 'Too many arguments: expected at most %s arguments' % max_args\n                raise self.error(code, msg if max_args != 1 else msg[:-1])\n\n        self.parser.advance(')')\n        if any(tk.symbol == '?' for tk in self._items):\n            self._partial_function()\n\n        return self\n\n    def match_function_test(self, function_test: str, as_argument: bool = False) -> bool:\n        \"\"\"\n        Match if function signature is a subtype of provided *function_test*.\n        For default return type is covariant and arguments are contravariant.\n        If *as_argument* is `True` the match is inverted and also the return\n        type is considered contravariant.\n\n        References:\n          https://www.w3.org/TR/xpath-31/#id-function-test\n          https://www.w3.org/TR/xpath-31/#id-sequencetype-subtype\n        \"\"\"\n        if not function_test.startswith('function('):\n            return False\n        elif function_test == 'function(*)':\n            return True\n\n        parts = function_test[9:].partition(') as ')\n        if not parts[1] or not parts[2]:\n            return False\n\n        sequence_types = parts[0].split(', ')\n        sequence_types.append(parts[2])\n\n        signature = [x for x in self.sequence_types[:self.arity]]\n        signature.append(self.sequence_types[-1])\n\n        if len(sequence_types) != len(signature):\n            return False\n\n        if as_argument:\n            iterator = zip(sequence_types, signature)\n        else:\n            iterator = zip(signature, sequence_types)\n\n        k = 0\n        for fst, st in iterator:\n            k += 1\n            if not as_argument and k == len(sequence_types):\n                st, fst = fst, st\n\n            if st[-1] in '*+?':\n                st_occurs = st[-1]\n                st = st[:-1]\n            else:\n                st_occurs = ''\n\n            if fst[-1] in '*+?':\n                fst_occurs = fst[-1]\n                fst = fst[:-1]\n            else:\n                fst_occurs = ''\n\n            if st_occurs == fst_occurs or fst_occurs == '*':\n                pass\n            elif not fst_occurs:\n                if st_occurs not in '?*':\n                    return False\n            elif fst_occurs == '+':\n                if st_occurs:\n                    return False\n            elif st_occurs:\n                return False\n\n            if st == fst:\n                continue\n            elif fst == 'item()':\n                continue\n            elif st == 'item()':\n                return False\n            elif fst.startswith('xs:') ^ st.startswith('xs:'):\n                return False\n            elif fst.startswith('xs:'):\n                if not issubclass(xsd11_atomic_types[st[3:]],\n                                  xsd11_atomic_types[fst[3:]]):\n                    return False\n            elif fst != 'node()':\n                return False\n\n        return True\n\n    def _partial_function(self) -> None:\n        \"\"\"Convert a named function to an anonymous partial function.\"\"\"\n        def evaluate(context: Optional[XPathContext] = None) -> Any:\n            return self\n\n        def select(context: Optional[XPathContext] = None) -> Any:\n            yield self\n\n        if self.__class__.evaluate is not XPathToken.evaluate:\n            setattr(self, '_partial_evaluate', self.evaluate)\n        if self.__class__.select is not XPathToken.select:\n            setattr(self, '_partial_select', self.select)\n\n        setattr(self, 'evaluate', evaluate)\n        setattr(self, 'select', select)\n\n        self._name = None\n        self.label = 'partial function'\n        self.nargs = len([tk for tk in self._items if tk.symbol == '?'])\n\n    def _partial_evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        return [x for x in self._partial_select(context)]\n\n    def _partial_select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        item = self._partial_evaluate(context)\n        if item is not None:\n            if isinstance(item, list):\n                yield from item\n            else:\n                if context is not None:\n                    context.item = item\n                yield item\nelementpath/xpath_nodes.py\ndef is_document_node(obj: Any) -> bool:\n    return hasattr(obj, 'getroot') and hasattr(obj, 'parse') and hasattr(obj, 'iter')\nelementpath/datatypes/datetime.py\nclass Duration(AnyAtomicType):\n    \"\"\"\n    Base class for the XSD duration types.\n\n    :param months: an integer value that represents years and months.\n    :param seconds: a decimal or an integer instance that represents \\\n    days, hours, minutes, seconds and fractions of seconds.\n    \"\"\"\n    name = 'duration'\n    pattern = re.compile(\n        r'^(-)?P(?=[0-9]|T)(?:([0-9]+)Y)?(?:([0-9]+)M)?(?:([0-9]+)D)?'\n        r'(?:T(?=[0-9])(?:([0-9]+)H)?(?:([0-9]+)M)?(?:([0-9]+(?:\\.[0-9]+)?)S)?)?$'\n    )\n\n    def __init__(self, months: int = 0, seconds: Union[Decimal, int] = 0) -> None:\n        if seconds < 0 < months or months < 0 < seconds:\n            raise ValueError('signs differ: (months=%d, seconds=%d)' % (months, seconds))\n        elif abs(months) > 2 ** 31:\n            raise OverflowError(\"months duration overflow\")\n        elif abs(seconds) > 2 ** 63:  # type: ignore[operator]\n            raise OverflowError(\"seconds duration overflow\")\n\n        self.months = months\n        self.seconds = Decimal(seconds).quantize(Decimal('1.000000'))\n\n    def __repr__(self) -> str:\n        return '{}(months={!r}, seconds={})'.format(\n            self.__class__.__name__, self.months, normalized_seconds(self.seconds)\n        )\n\n    def __str__(self) -> str:\n        m = abs(self.months)\n        years, months = m // 12, m % 12\n        s = self.seconds.copy_abs()\n        days = int(s // 86400)\n        hours = int(s // 3600 % 24)\n        minutes = int(s // 60 % 60)\n        seconds = s % 60\n\n        value = '-P' if self.sign else 'P'\n        if years or months or days:\n            if years:\n                value += '%dY' % years\n            if months:\n                value += '%dM' % months\n            if days:\n                value += '%dD' % days\n\n        if hours or minutes or seconds:\n            value += 'T'\n            if hours:\n                value += '%dH' % hours\n            if minutes:\n                value += '%dM' % minutes\n            if seconds:\n                value += '%sS' % normalized_seconds(seconds)\n\n        elif value[-1] == 'P':\n            value += 'T0S'\n        return value\n\n    @classmethod\n    def fromstring(cls, text: str) -> 'Duration':\n        \"\"\"\n        Creates a Duration instance from a formatted XSD duration string.\n\n        :param text: an ISO 8601 representation without week fragment and an optional decimal part \\\n        only for seconds fragment.\n        \"\"\"\n        if not isinstance(text, str):\n            msg = 'argument has an invalid type {!r}'\n            raise TypeError(msg.format(type(text)))\n\n        match = cls.pattern.match(text.strip())\n        if match is None:\n            raise ValueError('%r is not an xs:duration value' % text)\n\n        sign, y, mo, d, h, mi, s = match.groups()\n        seconds = Decimal(s or 0)\n        minutes = int(mi or 0) + int(seconds // 60)\n        seconds = seconds % 60\n        hours = int(h or 0) + minutes // 60\n        minutes = minutes % 60\n        days = int(d or 0) + hours // 24\n        hours = hours % 24\n        months = int(mo or 0) + 12 * int(y or 0)\n\n        if sign is None:\n            seconds = seconds + (days * 24 + hours) * 3600 + minutes * 60\n        else:\n            months = -months\n            seconds = -seconds - (days * 24 + hours) * 3600 - minutes * 60\n\n        if cls is DayTimeDuration:\n            if months:\n                raise ValueError('months must be 0 for %r' % cls.__name__)\n            return cls(seconds=seconds)\n        elif cls is YearMonthDuration:\n            if seconds:\n                raise ValueError('seconds must be 0 for %r' % cls.__name__)\n            return cls(months=months)\n        return cls(months=months, seconds=seconds)\n\n    @property\n    def sign(self) -> str:\n        return '-' if self.months < 0 or self.seconds < 0 else ''\n\n    def _compare_durations(self, other: object, op: Callable[[Any, Any], Any]) -> bool:\n        \"\"\"\n        Ordering is defined through comparison of four datetime.datetime values.\n\n        Ref: https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#duration\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise TypeError(\"wrong type %r for operand %r\" % (type(other), other))\n\n        m1, s1 = self.months, int(self.seconds)\n        m2, s2 = other.months, int(other.seconds)\n        ms1, ms2 = int((self.seconds - s1) * 1000000), int((other.seconds - s2) * 1000000)\n        return all([\n            op(datetime.timedelta(months2days(1696, 9, m1), s1, ms1),\n               datetime.timedelta(months2days(1696, 9, m2), s2, ms2)),\n            op(datetime.timedelta(months2days(1697, 2, m1), s1, ms1),\n               datetime.timedelta(months2days(1697, 2, m2), s2, ms2)),\n            op(datetime.timedelta(months2days(1903, 3, m1), s1, ms1),\n               datetime.timedelta(months2days(1903, 3, m2), s2, ms2)),\n            op(datetime.timedelta(months2days(1903, 7, m1), s1, ms1),\n               datetime.timedelta(months2days(1903, 7, m2), s2, ms2)),\n        ])\n\n    def __hash__(self) -> int:\n        return hash((self.months, self.seconds))\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, self.__class__):\n            return self.months == other.months and self.seconds == other.seconds\n        elif isinstance(other, UntypedAtomic):\n            return self.__eq__(self.fromstring(other.value))\n        else:\n            return other == (self.months, self.seconds)\n\n    def __ne__(self, other: object) -> bool:\n        if isinstance(other, self.__class__):\n            return self.months != other.months or self.seconds != other.seconds\n        elif isinstance(other, UntypedAtomic):\n            return self.__ne__(self.fromstring(other.value))\n        else:\n            return other != (self.months, self.seconds)\n\n    def __lt__(self, other: object) -> bool:\n        return self._compare_durations(other, operator.lt)\n\n    def __le__(self, other: object) -> bool:\n        return self == other or self._compare_durations(other, operator.le)\n\n    def __gt__(self, other: object) -> bool:\n        return self._compare_durations(other, operator.gt)\n\n    def __ge__(self, other: object) -> bool:\n        return self == other or self._compare_durations(other, operator.ge)\nelementpath/datatypes/datetime.py\nclass YearMonthDuration(Duration):\n\n    name = 'yearMonthDuration'\n\n    def __init__(self, months: int = 0) -> None:\n        super(YearMonthDuration, self).__init__(months, 0)\n\n    def __repr__(self) -> str:\n        return '%s(months=%r)' % (self.__class__.__name__, self.months)\n\n    def __str__(self) -> str:\n        m = abs(self.months)\n        years, months = m // 12, m % 12\n\n        if not years:\n            return '-P%dM' % months if self.months < 0 else 'P%dM' % months\n        elif not months:\n            return '-P%dY' % years if self.months < 0 else 'P%dY' % years\n        elif self.months < 0:\n            return '-P%dY%dM' % (years, months)\n        else:\n            return 'P%dY%dM' % (years, months)\n\n    def __add__(self, other: object) \\\n            -> Union['YearMonthDuration', 'DayTimeDuration', 'OrderedDateTime']:\n        if isinstance(other, self.__class__):\n            return YearMonthDuration(months=self.months + other.months)\n        elif isinstance(other, (DateTime10, Date10)):\n            return other + self\n        raise TypeError(\"cannot add %r to %r\" % (type(other), type(self)))\n\n    def __sub__(self, other: object) -> 'YearMonthDuration':\n        if not isinstance(other, self.__class__):\n            raise TypeError(\"cannot subtract %r from %r\" % (type(other), type(self)))\n        return YearMonthDuration(months=self.months - other.months)\n\n    def __mul__(self, other: object) -> 'YearMonthDuration':\n        if not isinstance(other, (float, int, Decimal)):\n            raise TypeError(\"cannot multiply a %r by %r\" % (type(self), type(other)))\n        return YearMonthDuration(months=int(round_number(self.months * other)))\n\n    def __truediv__(self, other: object) -> Union[float, 'YearMonthDuration']:\n        if isinstance(other, self.__class__):\n            return self.months / other.months\n        elif isinstance(other, (float, int, Decimal)):\n            return YearMonthDuration(months=int(round_number(self.months / other)))\n        else:\n            raise TypeError(\"cannot divide a %r by %r\" % (type(self), type(other)))\nelementpath/xpath_nodes.py\ndef is_comment_node(obj: Any) -> bool:\n    return hasattr(obj, 'tag') and callable(obj.tag) and obj.tag.__name__ == 'Comment'\nelementpath/datatypes/datetime.py\nclass DayTimeDuration(Duration):\n\n    name = 'dayTimeDuration'\n\n    def __init__(self, seconds: Union[Decimal, int] = 0) -> None:\n        super(DayTimeDuration, self).__init__(0, seconds)\n\n    @classmethod\n    def fromtimedelta(cls, td: datetime.timedelta) -> 'DayTimeDuration':\n        return cls(seconds=Decimal(\n            '{}.{:06}'.format(td.days * 86400 + td.seconds, td.microseconds)\n        ))\n\n    def get_timedelta(self) -> datetime.timedelta:\n        return datetime.timedelta(\n            seconds=int(self.seconds), microseconds=int(self.seconds % 1 * 1000000)\n        )\n\n    def __repr__(self) -> str:\n        return '%s(seconds=%s)' % (self.__class__.__name__, normalized_seconds(self.seconds))\n\n    def __add__(self, other: object) -> Union['DayTimeDuration', Time, OrderedDateTime]:\n        if isinstance(other, (Time, Date10)):\n            return other + self\n        elif isinstance(other, self.__class__):\n            return DayTimeDuration(self.seconds + other.seconds)\n        raise TypeError(\"cannot add %r to %r\" % (type(other), type(self)))\n\n    def __sub__(self, other: object) -> 'DayTimeDuration':\n        if not isinstance(other, self.__class__):\n            raise TypeError(\"cannot subtract %r from %r\" % (type(other), type(self)))\n        return DayTimeDuration(seconds=self.seconds - other.seconds)\n\n    def __mul__(self, other: object) -> 'DayTimeDuration':\n        if isinstance(other, (float, int, Decimal)):\n            if math.isnan(other):\n                raise ValueError(\"cannot multiply a %r by NaN\" % type(self))\n\n            if isinstance(other, (int, Decimal)):\n                seconds = self.seconds * other\n            else:\n                seconds = self.seconds * Decimal.from_float(other)\n\n            return DayTimeDuration(seconds)\n        else:\n            raise TypeError(\"cannot multiply a %r by %r\" % (type(self), type(other)))\n\n    def __truediv__(self, other: object) -> Union[Decimal, 'DayTimeDuration']:\n        if isinstance(other, self.__class__):\n            return self.seconds / other.seconds\n        elif isinstance(other, (float, int, Decimal)):\n            if math.isnan(other):\n                raise ValueError(\"cannot divide a %r by NaN\" % type(self))\n\n            if isinstance(other, (int, Decimal)):\n                seconds = self.seconds / other\n            else:\n                seconds = self.seconds / Decimal.from_float(other)\n\n            return DayTimeDuration(seconds)\n        else:\n            raise TypeError(\"cannot divide a %r by %r\" % (type(self), type(other)))\nelementpath/namespaces.py\ndef get_prefixed_name(\n        qname: str, namespaces: Union[Dict[str, str], Dict[Optional[str], str]]) -> str:\n    \"\"\"\n    Get the prefixed form of a QName, using a namespace map.\n\n    :param qname: an extended QName or a local name or a prefixed QName.\n    :param namespaces: a dictionary with a map from prefixes to namespace URIs.\n    \"\"\"\n    try:\n        if qname[0] == '{':\n            ns_uri, local_name = qname[1:].split('}')\n        elif qname[1] == '{' and qname[0] == 'Q':\n            ns_uri, local_name = qname[2:].split('}')\n        else:\n            return qname\n    except IndexError:\n        return qname\n    except (ValueError, TypeError):\n        raise ValueError(\"{!r} is not a QName\".format(qname))\n\n    for prefix, uri in sorted(namespaces.items(), reverse=True,\n                              key=lambda x: x if x[0] is not None else ('', x[1])):\n        if uri == ns_uri:\n            return '%s:%s' % (prefix, local_name) if prefix else local_name\n    else:\n        return qname\nelementpath/namespaces.py\nXML_LANG = '{%s}lang' % XML_NAMESPACE\nelementpath/xpath_nodes.py\ndef is_element_node(obj: Any) -> bool:\n    return isinstance(obj, TypedElement) or \\\n        hasattr(obj, 'tag') and not callable(obj.tag) and \\\n        hasattr(obj, 'attrib') and hasattr(obj, 'text')\nelementpath/datatypes/proxies.py\nclass StringProxy(metaclass=AtomicTypeMeta):\n    name = 'string'\n\n    def __new__(cls, *args: object, **kwargs: object) -> str:  # type: ignore[misc]\n        return str(*args, **kwargs)\n\n    @classmethod\n    def __subclasshook__(cls, subclass: type) -> bool:\n        return issubclass(subclass, str)\n\n    @classmethod\n    def validate(cls, value: object) -> None:\n        if not isinstance(value, str):\n            raise cls.invalid_type(value)\nelementpath/datatypes/uri.py\nclass AnyURI(AnyAtomicType):\n    \"\"\"\n    Class for xs:anyURI data.\n\n    :param value: a string or an untyped atomic instance.\n    \"\"\"\n    value: str\n    name = 'anyURI'\n\n    def __init__(self, value: Union[str, bytes, UntypedAtomic, 'AnyURI']) -> None:\n        if isinstance(value, str):\n            self.value = collapse_white_spaces(value)\n        elif isinstance(value, bytes):\n            self.value = collapse_white_spaces(value.decode('utf-8'))\n        elif isinstance(value, self.__class__):\n            self.value = value.value\n        elif isinstance(value, UntypedAtomic):\n            self.value = collapse_white_spaces(value.value)\n        else:\n            raise TypeError('the argument has an invalid type %r' % type(value))\n\n        self.validate(self.value)\n\n    def __repr__(self) -> str:\n        return '%s(%r)' % (self.__class__.__name__, self.value)\n\n    def __str__(self) -> str:\n        return self.value\n\n    def __bool__(self) -> bool:\n        return bool(self.value)  # For effective boolean value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n    def __contains__(self, item: str) -> bool:\n        return item in self.value\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value == other.value\n        elif isinstance(other, (bool, float, Decimal, Integer)):\n            raise TypeError(\"cannot compare {} with xs:{}\".format(type(other), self.name))\n        return self.value == other\n\n    def __ne__(self, other: object) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value != other.value\n        elif isinstance(other, (bool, float, Decimal, Integer)):\n            raise TypeError(\"cannot compare {} with xs:{}\".format(type(other), self.name))\n        return self.value != other\n\n    def __lt__(self, other: Union[str, 'AnyURI', UntypedAtomic]) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value < other.value\n        return self.value < other\n\n    def __le__(self, other: Union[str, 'AnyURI', UntypedAtomic]) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value <= other.value\n        return self.value <= other\n\n    def __gt__(self, other: Union[str, 'AnyURI', UntypedAtomic]) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value > other.value\n        return self.value > other\n\n    def __ge__(self, other: Union[str, 'AnyURI', UntypedAtomic]) -> bool:\n        if isinstance(other, (AnyURI, UntypedAtomic)):\n            return self.value >= other.value\n        return self.value >= other\n\n    @classmethod\n    def validate(cls, value: object) -> None:\n        if isinstance(value, cls):\n            return\n        elif isinstance(value, bytes):\n            value = value.decode()\n        elif not isinstance(value, str):\n            raise cls.invalid_type(value)\n\n        try:\n            url_parts = urlparse(value)\n            _ = url_parts.port  # check invalid port!\n        except ValueError as err:\n            msg = 'invalid value {!r} for xs:{} ({})'\n            raise ValueError(msg.format(value, cls.name, str(err))) from None\n        else:\n            if url_parts.path.startswith(':'):\n                raise cls.invalid_value(value)\n            elif value.count('#') > 1:\n                msg = 'invalid value {!r} for xs:{} (too many # characters)'\n                raise ValueError(msg.format(value, cls.name))\n            elif WRONG_ESCAPE_PATTERN.search(value) is not None:\n                msg = 'invalid value {!r} for xs:{} (wrong escaping)'\n                raise ValueError(msg.format(value, cls.name))\nelementpath/xpath_nodes.py\nclass TextNode(XPathNode):\n    \"\"\"\n    A class for processing XPath text nodes. An Element's property\n    (elem.text or elem.tail) with a `None` value is not a text node.\n\n    :param value: a string value.\n    :param parent: the parent element.\n    :param tail: provide `True` if the text node is the parent Element's tail.\n    \"\"\"\n    text: None\n    _tail = False\n\n    def __init__(self, value: str, parent: Optional[ElementNode] = None,\n                 tail: bool = False) -> None:\n        self.value = value\n        self.parent = parent\n        if tail and parent is not None:\n            self._tail = True\n\n    @property\n    def kind(self) -> str:\n        return 'text'\n\n    def is_tail(self) -> bool:\n        \"\"\"Returns `True` if the node has a parent and represents the tail text.\"\"\"\n        return self._tail\n\n    def __repr__(self) -> str:\n        if self.parent is not None:\n            return '%s(%r, parent=%r, tail=%r)' % (\n                self.__class__.__name__, self.value, self.parent, self._tail\n            )\n        return '%s(%r)' % (self.__class__.__name__, self.value)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.value == other.value and \\\n            self.parent is other.parent and \\\n            self._tail is other._tail\n\n    def __hash__(self) -> int:\n        return hash((self.value, self.parent, self._tail))\nelementpath/xpath_nodes.py\ndef node_name(obj: Any) -> Optional[str]:\n    if isinstance(obj, XPathNode):\n        return cast(Optional[str], obj.name)\n    elif not hasattr(obj, 'tag') or not hasattr(obj, 'text'):\n        return None\n    elif not callable(obj.tag):\n        return cast(str, obj.tag)\n    elif obj.tag.__name__ != 'ProcessingInstruction':\n        return None\n    else:\n        # Return pi target. ElementTree doesn't have a specific attribute\n        # for target but put it before the text, separated by a space.\n        try:\n            return cast(str, obj.target)\n        except AttributeError:\n            return cast(str, obj.text.split(' ', maxsplit=1)[0])\nelementpath/xpath1/_xpath1_operators.py\nOPERATORS_MAP = {\n    '=': operator.eq,\n    '!=': operator.ne,\n    '>': operator.gt,\n    '>=': operator.ge,\n    '<': operator.lt,\n    '<=': operator.le,\n}\ndef nud_name_literal(self):\ndef evaluate_name_literal(self, context=None):\ndef select_name_literal(self, context=None):\ndef led_namespace_prefix(self, left):\ndef evaluate_namespace_prefix(self, context=None):\ndef select_namespace_prefix(self, context=None):\ndef nud_namespace_uri(self):\ndef evaluate_namespace_uri(self, context=None):\ndef select_namespace_uri(self, context=None):\ndef nud_variable_reference(self):\ndef evaluate_variable_reference(self, context=None):\ndef select_wildcard(self, context=None):\ndef select_self_shortcut(self, context=None):\ndef select_parent_shortcut(self, context=None):\ndef evaluate_or_operator(self, context=None):\ndef evaluate_and_operator(self, context=None):\ndef led_comparison_operators(self, left):\ndef evaluate_comparison_operators(self, context=None):\ndef evaluate_plus_operator(self, context=None):\ndef evaluate_minus_operator(self, context=None):\ndef nud_plus_minus_operators(self):\ndef evaluate_multiply_operator(self, context=None):\ndef evaluate_div_operator(self, context=None):\ndef evaluate_mod_operator(self, context=None):\ndef nud_logical_div_mod_operators(self):\ndef led_union_operator(self, left):\ndef select_union_operator(self, context=None):\ndef nud_descendant_path(self):\ndef nud_child_path(self):\ndef led_child_or_descendant_path(self, left):\ndef select_child_path(self, context=None):\ndef select_descendant_path(self, context=None):\ndef led_predicate(self, left):\ndef select_predicate(self, context=None):\ndef nud_parenthesized_expr(self):\ndef evaluate_parenthesized_expr(self, context=None):\ndef select_parenthesized_expr(self, context=None):\nelementpath/xpath_nodes.py\ndef is_xpath_node(obj: Any) -> bool:\n    return isinstance(obj, XPathNode) or \\\n        hasattr(obj, 'tag') and hasattr(obj, 'attrib') and hasattr(obj, 'text') or \\\n        hasattr(obj, 'local_name') and hasattr(obj, 'type') and hasattr(obj, 'name') or \\\n        hasattr(obj, 'getroot') and hasattr(obj, 'parse') and hasattr(obj, 'iter')\nelementpath/datatypes/numeric.py\nclass Float10(float, AnyAtomicType):\n    name = 'float'\n    xsd_version = '1.0'\n    pattern = re.compile(\n        r'^(?:[+-]?(?:[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+)(?:[Ee][+-]?[0-9]+)? |[+-]?INF|NaN)$'\n    )\n\n    def __new__(cls, value: Union[str, SupportsFloat]) -> 'Float10':\n        if isinstance(value, str):\n            value = collapse_white_spaces(value)\n            if value in NUMERIC_INF_OR_NAN or cls.xsd_version != '1.0' and value == '+INF':\n                pass\n            elif value.lower() in INVALID_NUMERIC:\n                raise ValueError('invalid value {!r} for xs:{}'.format(value, cls.name))\n\n        _value = super().__new__(cls, value)\n        if _value > 3.4028235E38:\n            return super().__new__(cls, 'INF')\n        elif _value < -3.4028235E38:\n            return super().__new__(cls, '-INF')\n        elif -1e-37 < _value < 1e-37:\n            return super().__new__(cls, -0.0 if str(_value).startswith('-') else 0.0)\n        return _value\n\n    def __hash__(self) -> int:\n        return super(Float10, self).__hash__()\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, self.__class__):\n            if super(Float10, self).__eq__(other):\n                return True\n            return math.isclose(self, other, rel_tol=1e-7, abs_tol=0.0)\n        return super(Float10, self).__eq__(other)\n\n    def __ne__(self, other: object) -> bool:\n        if isinstance(other, self.__class__):\n            if super(Float10, self).__eq__(other):\n                return False\n            return not math.isclose(self, other, rel_tol=1e-7, abs_tol=0.0)\n        return super(Float10, self).__ne__(other)\n\n    def __add__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__add__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__add__(other)\n        return NotImplemented\n\n    def __radd__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__radd__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__radd__(other)\n        return NotImplemented\n\n    def __sub__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__sub__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__sub__(other)\n        return NotImplemented\n\n    def __rsub__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__rsub__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__rsub__(other)\n        return NotImplemented\n\n    def __mul__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__mul__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__mul__(other)\n        return NotImplemented\n\n    def __rmul__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__rmul__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__rmul__(other)\n        return NotImplemented\n\n    def __truediv__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__truediv__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__truediv__(other)\n        return NotImplemented\n\n    def __rtruediv__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__rtruediv__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__rtruediv__(other)\n        return NotImplemented\n\n    def __mod__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__mod__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__mod__(other)\n        return NotImplemented\n\n    def __rmod__(self, other: object) -> Union[float, 'Float10', 'Float']:\n        if isinstance(other, (self.__class__, int)):\n            return self.__class__(super(Float10, self).__rmod__(other))\n        elif isinstance(other, float):\n            return super(Float10, self).__rmod__(other)\n        return NotImplemented\n\n    def __abs__(self) -> Union['Float10', 'Float']:\n        return self.__class__(super(Float10, self).__abs__())\nelementpath/xpath_nodes.py\ndef is_processing_instruction_node(obj: Any) -> bool:\n    return hasattr(obj, 'tag') and callable(obj.tag) and obj.tag.__name__ == 'ProcessingInstruction'\nelementpath/namespaces.py\nXML_ID = '{%s}id' % XML_NAMESPACE\n", "answers": ["    XPathFunction.nud(self)"], "length": 3894, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "f4b1a640cc8ba965011a362255c3157375b90cdb0f7c4e06"}
{"input": "import struct\nimport sys\nfrom ..exceptions import PyOrientBadMethodCallException, \\\n    PyOrientCommandException, PyOrientNullRecordException\nfrom ..otypes import OrientRecord, OrientRecordLink, OrientNode\nfrom ..hexdump import hexdump\nfrom ..constants import BOOLEAN, BYTE, BYTES, CHAR, FIELD_BOOLEAN, FIELD_BYTE, \\\n    FIELD_INT, FIELD_RECORD, FIELD_SHORT, FIELD_STRING, FIELD_TYPE_LINK, INT, \\\n    LINK, LONG, RECORD, SHORT, STRING, STRINGS\nfrom ..utils import is_debug_active\nfrom ..orient import OrientSocket\nfrom ..serializations import OrientSerialization\n        from .connection import ConnectMessage\n        from .database import DbOpenMessage\n            self.dump_streams()\n        return self._body\n\n    def dump_streams(self):\n        if is_debug_active():\n            if len( self._output_buffer ):\n                print(\"\\nRequest :\")\n                hexdump( self._output_buffer )\n                # print(repr(self._output_buffer))\n            if len( self._input_buffer ):\n                print(\"\\nResponse:\")\n                hexdump( self._input_buffer )\n                # print(repr(self._input_buffer))\n\n    def _append(self, field):\n        \"\"\"\n        @:rtype self: BaseMessage\n        @type field: object\n        \"\"\"\n        self._fields_definition.append( field )\n        return self\n\n    def __str__(self):\n\n        return \"\\n_output_buffer: \\n\" + hexdump( self._output_buffer, 'return' ) \\\n               + \"\\n\\n_input_buffer: \\n\" + hexdump( self._input_buffer, 'return' )\n\n    def send(self):\n        if self._orientSocket.in_transaction is False:\n            self._orientSocket.write( self._output_buffer )\n            self._reset_fields_definition()\n        if is_debug_active():\n            self.dump_streams()\n            # reset output buffer\n            self._output_buffer = b\"\"\n\n        return self\n\n    def close(self):\n        self._orientSocket.close()\n\n    @staticmethod\n    def _encode_field(field):\n\n        # tuple with type\n        t, v = field\n        _content = None\n\n        if t['type'] == INT:\n            _content = struct.pack(\"!i\", v)\n        elif t['type'] == SHORT:\n            _content = struct.pack(\"!h\", v)\n        elif t['type'] == LONG:\n            _content = struct.pack(\"!q\", v)\n        elif t['type'] == BOOLEAN:\n            if sys.version_info[0] < 3:\n                _content = chr(1) if v else chr(0)\n            else:\n                _content = bytes([1]) if v else bytes([0])\n        elif t['type'] == BYTE:\n            if sys.version_info[0] < 3:\n                _content = v\n            else:\n                _content = bytes([ord(v)])\n        elif t['type'] == BYTES:\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRING:\n            if sys.version_info[0] >= 3:\n                if isinstance(v, str):\n                    v = v.encode('utf-8')\n            else:\n                if isinstance(v, unicode):\n                    v = v.encode('utf-8')\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRINGS:\n            _content = b''\n            for s in v:\n                if sys.version_info[0] >= 3:\n                    if isinstance(s, str):\n                        s = s.encode('utf-8')\n                else:\n                    if isinstance(s, unicode):\n                        s = s.encode('utf-8')\n                _content += struct.pack(\"!i\", len(s)) + s\n\n        return _content\n\n    def _decode_field(self, _type):\n        _value = b\"\"\n        # read buffer length and decode value by field definition\n        if _type['bytes'] is not None:\n            _value = self._orientSocket.read( _type['bytes'] )\n        # if it is a string decode first 4 Bytes as INT\n        # and try to read the buffer\n        if _type['type'] == STRING or _type['type'] == BYTES:\n\n            _len = struct.unpack('!i', _value)[0]\n            if _len == -1 or _len == 0:\n                _decoded_string = b''\n            else:\n                _decoded_string = self._orientSocket.read( _len )\n\n            self._input_buffer += _value\n            self._input_buffer += _decoded_string\n\n            return _decoded_string\n\n        elif _type['type'] == RECORD:\n\n            # record_type\n            record_type = self._decode_field( _type['struct'][0] )\n\n            rid = \"#\" + str( self._decode_field( _type['struct'][1] ) )\n            rid += \":\" + str( self._decode_field( _type['struct'][2] ) )\n            \n            version = self._decode_field( _type['struct'][3] )\n            content = self._decode_field( _type['struct'][4] )\n            return {'rid': rid, 'record_type': record_type,\n                    'content': content, 'version': version}\n\n", "context": "pyorient/constants.py\nBYTES   = 6  # Used for binary data.\npyorient/constants.py\nFIELD_BOOLEAN = {\"type\": BOOLEAN, \"bytes\": 1, \"struct\": None}\npyorient/constants.py\nSTRINGS = 9\npyorient/constants.py\nFIELD_STRING = {\"type\": STRING, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nLINK    = 11\npyorient/constants.py\nFIELD_TYPE_LINK = {\"type\": LINK, \"bytes\": None, \"struct\": [\n    FIELD_SHORT,  # record_clusterID\n    FIELD_LONG,   # record_position\n]}\npyorient/constants.py\nFIELD_SHORT = {\"type\": SHORT, \"bytes\": 2, \"struct\": None}\npyorient/exceptions.py\nclass PyOrientBadMethodCallException(PyOrientException):\n    pass\npyorient/constants.py\nRECORD  = 8\npyorient/constants.py\nSHORT   = 3\npyorient/constants.py\nFIELD_BYTE = {\"type\": BYTE, \"bytes\": 1, \"struct\": None}\npyorient/constants.py\nCHAR    = 10\npyorient/constants.py\nFIELD_RECORD = {\"type\": RECORD, \"bytes\": None, \"struct\": [\n    FIELD_CHAR,   # record_type\n    FIELD_SHORT,  # record_clusterID\n    FIELD_LONG,   # record_position\n    FIELD_INT,    # record_version\n    FIELD_BYTES   # record_content\n]}\npyorient/constants.py\nBOOLEAN = 1  # Single byte: 1 = true, 0 = false\npyorient/constants.py\nLONG    = 5\npyorient/orient.py\nclass OrientSocket(object):\n    '''Class representing the binary connection to the database, it does all the low level comunication\n    And holds information on server version and cluster map\n\n    .. DANGER::\n      Should not be used directly\n\n    :param host: hostname of the server to connect\n    :param port: integer port of the server\n\n    '''\n    def __init__(self, host, port, serialization_type=OrientSerialization.CSV ):\n\n        self.connected = False\n        self.host = host\n        self.port = port\n        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.protocol = -1\n        self.session_id = -1\n        self.auth_token = b''\n        self.db_opened = None\n        self.serialization_type = serialization_type\n        self.in_transaction = False\n        self._props = None\n\n    def get_connection(self):\n        if not self.connected:\n            self.connect()\n\n        return self._socket\n\n    def connect(self):\n        '''Connects to the inner socket\n        could raise :class:`PyOrientConnectionPoolException`\n        '''\n        dlog(\"Trying to connect...\")\n        try:\n            self._socket.settimeout( SOCK_CONN_TIMEOUT )  # 30 secs of timeout\n            self._socket.connect( (self.host, self.port) )\n            _value = self._socket.recv( FIELD_SHORT['bytes'] )\n\n            if len(_value) != 2:\n                self._socket.close()\n\n                raise PyOrientConnectionPoolException(\n                    \"Server sent empty string\", []\n                )\n\n            self.protocol = struct.unpack('!h', _value)[0]\n            if self.protocol > SUPPORTED_PROTOCOL:\n                raise PyOrientWrongProtocolVersionException(\n                    \"Protocol version \" + str(self.protocol) +\n                    \" is not supported yet by this client.\", [])\n            self.connected = True\n        except socket.error as e:\n            self.connected = False\n            raise PyOrientConnectionException( \"Socket Error: %s\" % e, [] )\n\n    def close(self):\n        '''Close the inner connection\n        '''\n        self.host = ''\n        self.port = 0\n        self.protocol = -1\n        self.session_id = -1\n        self._socket.close()\n        self.connected = False\n\n    def write(self, buff):\n        # This is a trick to detect server disconnection\n        # or broken line issues because of\n        \"\"\":see: https://docs.python.org/2/howto/sockets.html#when-sockets-die \"\"\"\n\n        try:\n            _, ready_to_write, in_error = select.select(\n                [], [self._socket], [self._socket], 1)\n        except select.error as e:\n            self.connected = False\n            self._socket.close()\n            raise e\n\n        if not in_error and ready_to_write:\n            self._socket.sendall(buff)\n            return len(buff)\n        else:\n            self.connected = False\n            self._socket.close()\n            raise PyOrientConnectionException(\"Socket error\", [])\n\n    # The man page for recv says: The receive calls normally return\n    #   any data available, up to the requested amount, rather than waiting\n    #   for receipt of the full amount requested.\n    #\n    # If you need to read a given number of bytes, you need to call recv\n    #   in a loop and concatenate the returned packets until\n    #   you have read enough.\n    def read(self, _len_to_read):\n\n        while True:\n\n            # This is a trick to detect server disconnection\n            # or broken line issues because of\n            \"\"\":see: https://docs.python.org/2/howto/sockets.html#when-sockets-die \"\"\"\n            try:\n                ready_to_read, _, in_error = \\\n                    select.select( [self._socket, ], [], [self._socket, ], 30 )\n            except select.error as e:\n                self.connected = False\n                self._socket.close()\n                raise e\n\n            if len(ready_to_read) > 0:\n\n                buf = bytearray(_len_to_read)\n                view = memoryview(buf)\n                while _len_to_read:\n                    n_bytes = self._socket.recv_into(view, _len_to_read)\n                    if not n_bytes:\n                        self._socket.close()\n                        # TODO Implement re-connection to another listener\n\n                        raise PyOrientConnectionException(\n                            \"Server seems to have went down\", [])\n\n                    view = view[n_bytes:]  # slicing views is cheap\n                    _len_to_read -= n_bytes\n                return bytes(buf)\n\n            if len(in_error) > 0:\n                self._socket.close()\n                raise PyOrientConnectionException(\n                    \"Socket error\", [])\npyorient/otypes.py\nclass OrientRecord(object):\n    \"\"\"\n    Object that represent an Orient Document / Record\n\n    \"\"\"\n    oRecordData = property(lambda self: self.__o_storage)\n\n    def __str__(self):\n        rep = \"\"\n        if self.__o_storage:\n            rep = str( self.__o_storage )\n        if self.__o_class is not None:\n            rep = \"'@\" + str(self.__o_class) + \"':\" + rep + \"\"\n        if self.__version is not None:\n            rep = rep + \",'version':\" + str(self.__version)\n        if self.__rid is not None:\n            rep = rep + \",'rid':'\" + str(self.__rid) + \"'\"\n        return '{' + rep + '}'\n\n    @staticmethod\n    def addslashes(string):\n        l = [ \"\\\\\", '\"', \"'\", \"\\0\", ]\n        for i in l:\n            if i in string:\n                string = string.replace( i, '\\\\' + i )\n        return string\n\n    def __init__(self, content=None):\n\n        self.__rid = None\n        self.__version = None\n        self.__o_class = None\n        self.__o_storage = {}\n\n        if not content:\n            content = {}\n        for key in content.keys():\n            if key == '__rid':  # Ex: select @rid, field from v_class\n                self.__rid = content[ key ]\n                # self.__rid = OrientRecordLink( content[ key ][ 1: ] )\n            elif key == '__version':  # Ex: select @rid, @version from v_class\n                self.__version = content[key]\n            elif key == '__o_class':\n                self.__o_class = content[ key ]\n            elif key[0:1] == '@':\n                # special case dict\n                # { '@my_class': { 'accommodation': 'hotel' } }\n                self.__o_class = key[1:]\n                for _key, _value in content[key].items():\n                    if isinstance(_value, basestring):\n                        self.__o_storage[_key] = self.addslashes( _value )\n                    else:\n                        self.__o_storage[_key] = _value\n            elif key == '__o_storage':\n                self.__o_storage = content[key]\n            else:\n                self.__o_storage[key] = content[key]\n\n    def _set_keys(self, content=dict):\n        for key in content.keys():\n                self._set_keys( content[key] )\n\n    @property\n    def _in(self):\n        try:\n            return self.__o_storage['in']\n        except KeyError:\n            return None\n\n    @property\n    def _out(self):\n        try:\n            return self.__o_storage['out']\n        except KeyError:\n            return None\n\n    @property\n    def _rid(self):\n        return self.__rid\n\n    @property\n    def _version(self):\n        return self.__version\n\n    @property\n    def _class(self):\n        return self.__o_class\n\n    def update(self, **kwargs):\n        self.__rid = kwargs.get('__rid', None)\n        self.__version = kwargs.get('__version', None)\n        if self.__o_class is None:\n            self.__o_class = kwargs.get('__o_class', None)\n\n    \"\"\" This method is for backward compatibility when someone\n        use 'getattr(record, a_key)' \"\"\"\n    def __getattr__(self, item):\n        \"\"\"\n        :param item: string\n        :return: mixed\n        :raise: AttributeError\n        \"\"\"\n        try:\n            return self.__o_storage[item]\n        except KeyError:\n            raise AttributeError( \"'OrientRecord' object has no attribute \"\n                                  \"'\" + item + \"'\" )\npyorient/constants.py\nSTRING  = 7\npyorient/constants.py\nINT     = 4\npyorient/exceptions.py\nclass PyOrientCommandException(PyOrientException):\n    pass\npyorient/otypes.py\nclass OrientRecordLink(object):\n    def __init__(self, recordlink):\n        cid, rpos = recordlink.split(\":\")\n        self.__link = recordlink\n        self.clusterID = cid\n        self.recordPosition = rpos\n\n    def __str__(self):\n        return self.get_hash()\n\n    def get(self):\n        return self.__link\n\n    def get_hash(self):\n        return \"#%s\" % self.__link\npyorient/constants.py\nFIELD_INT = {\"type\": INT, \"bytes\": 4, \"struct\": None}\npyorient/exceptions.py\nclass PyOrientNullRecordException(PyOrientException):\n    pass\npyorient/serializations.py\nclass OrientSerialization(object):\n    \"\"\"\n    Enum representing the available serialization\n    \"\"\"\n    #: CSV the default serialization\n    CSV = \"ORecordDocument2csv\"\n\n    #: Now unimplemented\n    Binary = \"ORecordSerializerBinary\"\n\n    @classmethod\n    def get_impl(cls, impl, props=None):\n        impl_map = {\n            cls.CSV: OrientSerializationCSV,\n            cls.Binary: OrientSerializationBinary,\n        }\n        implementation = impl_map.get(impl, False)\n        if not implementation:\n            raise PyOrientBadMethodCallException(\n                impl + ' is not an available serialization type', []\n            )\n        if impl == cls.Binary:\n            if not binary_support:\n                raise Exception( \"To support Binary Serialization, pyorient_native must be installed\" )\n            return implementation(props)\n        else:\n            return implementation()\npyorient/constants.py\nBYTE    = 2\npyorient/otypes.py\nclass OrientNode(object):\n    def __init__(self, node_dict=None):\n        \"\"\"\n        Represent a server node in a multi clusered configuration\n\n        TODO: extends this object with different listeners if we're going to support in the driver an abstarction of the HTTP protocol, for now we are not interested in that\n\n        :param node_dict: dict with starting configs (usaully from a db_open, db_reload record response)\n        \"\"\"\n        #: node name\n        self.name = None\n\n        #: node is\n        self.id = None\n\n        #: datetime object the node was started\n        self.started_on = None\n\n        #: binary listener host\n        self.host = None\n\n        #: binary lister port\n        self.port = None\n\n        if node_dict is not None:\n            self._parse_dict(node_dict)\n\n    def _parse_dict(self, node_dict):\n        self.id = node_dict['id']\n        self.name = node_dict['name']\n        self.started_on = node_dict['startedOn']\n        listener = None\n        for l in node_dict['listeners']:\n            if l['protocol'] == 'ONetworkProtocolBinary':\n                listener = l\n                break\n\n        if listener:\n            listen = listener['listen'].split(':')\n            self.host = listen[0]\n            self.port = listen[1]\n\n    def __str__(self):\n        return self.name\npyorient/hexdump.py\ndef hexdump(data, result='print'):\n    \"\"\"\n    Transform binary data to the hex dump text format:\n\n    00000000: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................\n\n      [x] data argument as a binary string\n      [x] data argument as a file like object\n\n    Returns result depending on the `result` argument:\n      'print'     - prints line by line\n      'return'    - returns single string\n      'generator' - returns generator that produces lines\n    \"\"\"\n    if PY3K and type(data) == str:\n        raise TypeError('Abstract unicode data (expected bytes sequence)')\n\n    gen = dumpgen(data)\n    if result == 'generator':\n        return gen\n    elif result == 'return':\n        return '\\n'.join(gen)\n    elif result == 'print':\n        for line in gen:\n            print(line)\n    else:\n        raise ValueError('Unknown value of `result` argument')\n", "answers": ["        elif _type['type'] == LINK:"], "length": 1740, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "f35d58d8b2eedeca1020fb62df444121f7538f16cbf4c6e8"}
{"input": "from base64 import b64encode\nfrom datetime import datetime\nfrom random import choice\nfrom urllib import urlencode, quote\nfrom urlparse import parse_qsl, parse_qs, urlparse, urlunparse\nfrom xml.etree import ElementTree\nfrom django.conf import settings\nfrom django.contrib.auth import login\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.models import User\nfrom django.core.urlresolvers import reverse\nfrom django import forms\nfrom django.http import HttpResponse, HttpResponseRedirect\nfrom django.shortcuts import render_to_response\nfrom django.template import RequestContext\nfrom django.template.loader import render_to_string\nfrom leapfrog.models import Person, Account, UserSetting, Object\nfrom leapfrog.poll.facebook import account_for_facebook_user\nfrom leapfrog.poll.flickr import sign_flickr_query, account_for_flickr_id, call_flickr\nfrom leapfrog.poll.mlkshk import account_for_mlkshk_userinfo, call_mlkshk\nfrom leapfrog.poll.tumblr import account_for_tumblr_userinfo\nfrom leapfrog.poll.typepad import account_for_typepad_user\nfrom leapfrog.poll.vimeo import account_for_vimeo_id, call_vimeo\nimport json\nimport logging\nimport string\nimport httplib2\nimport oauth2 as oauth\nimport typd.objecttypes\n    # But who is it?\n    access_token = oauth.Token(access_token_data['oauth_token'], access_token_data['oauth_token_secret'])\n    userdata = call_vimeo('vimeo.test.login', token=access_token)\n    user_id = userdata['user']['id']\n\n    person = None\n    if not request.user.is_anonymous():\n        person = request.user.person\n    account = account_for_vimeo_id(user_id, person=person)\n    if request.user.is_anonymous():\n        person = account.person\n        if person.user is None:\n            # AGH\n            random_name = ''.join(choice(string.letters + string.digits) for i in range(20))\n            while User.objects.filter(username=random_name).exists():\n                random_name = ''.join(choice(string.letters + string.digits) for i in range(20))\n            person.user = User.objects.create_user(random_name, '%s@example.com' % random_name)\n            person.save()\n\n        person.user.backend = 'django.contrib.auth.backends.ModelBackend'\n        login(request, person.user)\n    else:\n        # If the account already existed (because some other user follows\n        # that account and had imported objects by them, say), \"merge\" it\n        # onto the signed-in user. (This does mean you can intentionally\n        # move an account by signing in as a different django User and re-\n        # associating that account, but that's appropriate.)\n        account.person = person\n\n    account.authinfo = ':'.join((access_token_data['oauth_token'], access_token_data['oauth_token_secret']))\n    account.save()\n\n    return HttpResponseRedirect(reverse('home'))\n\n\ndef signin_tumblr(request, form=None):\n    csr = oauth.Consumer(*settings.TUMBLR_CONSUMER)\n    client = oauth.Client(csr)\n    oauth_callback = quote(request.build_absolute_uri(reverse('complete-tumblr')))\n\n    http_url = 'http://www.tumblr.com/oauth/request_token'\n    oauth_request = oauth.Request.from_consumer_and_token(csr, None,\n        http_method='POST', http_url=http_url)\n    oauth_request['oauth_callback'] = request.build_absolute_uri(reverse('complete-tumblr'))\n    oauth_sign_method = oauth.SignatureMethod_HMAC_SHA1()\n    oauth_request.sign_request(oauth_sign_method, csr, None)\n    oauth_signing_base = oauth_sign_method.signing_base(oauth_request, csr, None)\n    body = oauth_request.to_postdata()\n\n    h = httplib2.Http()\n    h.follow_redirects = 0\n    normal_url = oauth_request.normalized_url\n    log.debug('Making request to URL %r', normal_url)\n    resp, content = h.request(normal_url, method=oauth_request.method, body=body,\n        headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n    if resp.status != 200:\n        raise ValueError('Unexpected response asking for Tumblr request token: %d %s' % (resp.status, resp.reason))\n    if 'content-type' not in resp:\n        raise ValueError(\"Response asking for Tumblr request token unexpectedly had no content type (is Tumblr down?)\")\n\n    request_token = dict(parse_qsl(content))\n    request.session['tumblr_request_token'] = request_token\n\n    return HttpResponseRedirect('http://www.tumblr.com/oauth/authorize?oauth_token=%s&oauth_access_type=write' % (request_token['oauth_token'],))\n\n\ndef complete_tumblr(request):\n    try:\n        request_token = request.session['tumblr_request_token']\n    except KeyError:\n        raise ValueError(\"Can't complete Tumblr authentication without a request token for this session\")\n\n    try:\n        verifier = request.GET['oauth_verifier']\n    except KeyError:\n        # The viewer clicked \"Deny\", which is okay.\n        return HttpResponseRedirect(reverse('home'))\n\n    csr = oauth.Consumer(*settings.TUMBLR_CONSUMER)\n    token = oauth.Token(request_token['oauth_token'], request_token['oauth_token_secret'])\n\n    http_url = 'http://www.tumblr.com/oauth/access_token'\n    oauth_request = oauth.Request.from_consumer_and_token(csr, token,\n        http_method='POST', http_url=http_url)\n    oauth_request['oauth_verifier'] = verifier\n    oauth_sign_method = oauth.SignatureMethod_HMAC_SHA1()\n    oauth_request.sign_request(oauth_sign_method, csr, token)\n    oauth_signing_base = oauth_sign_method.signing_base(oauth_request, csr, token)\n    body = oauth_request.to_postdata()\n\n    h = httplib2.Http()\n    h.follow_redirects = 0\n    normal_url = oauth_request.normalized_url\n    log.debug('Making request to URL %r', normal_url)\n    resp, content = h.request(normal_url, method=oauth_request.method, body=body,\n        headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    if resp.status != 200:\n        raise ValueError(\"Unexpected response exchanging for Tumblr access token: %d %s\" % (resp.status, resp.reason))\n\n    access_token_data = dict(parse_qsl(content))\n    del request.session['tumblr_request_token']\n    #request.session['access_token'] = access_token\n\n    access_token = oauth.Token(access_token_data['oauth_token'], access_token_data['oauth_token_secret'])\n    oauth_request = oauth.Request.from_consumer_and_token(csr, access_token,\n        http_method='POST', http_url='http://api.tumblr.com/v2/user/info')\n    oauth_request.sign_request(oauth_sign_method, csr, access_token)\n\n    resp, cont = h.request(oauth_request.normalized_url, method=oauth_request.method,\n        body=oauth_request.to_postdata(), headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    if resp.status != 200:\n        raise ValueError(\"Unexpected response checking Tumblr access token: %d %s\" % (resp.status, resp.reason))\n\n    data = json.loads(cont)\n    userinfo = data['response']['user']\n\n    person = None\n    if not request.user.is_anonymous():\n        person = request.user.person\n", "context": "leapfrog/poll/flickr.py\ndef account_for_flickr_id(nsid, person=None):\n    try:\n        # TODO: update flickr avatar pictures (but that requires fetching their people info speculatively)\n        return Account.objects.get(service='flickr.com', ident=nsid)\n    except Account.DoesNotExist:\n        pass\n\n    try:\n        result = call_flickr('flickr.people.getInfo', user_id=nsid)\n    except leapfrog.poll.embedlam.RequestError:\n        return\n    persondata = result['person']\n\n    if person is None:\n        if int(persondata['iconfarm']) == 0:\n            avatar = None\n        else:\n            avatar = Media(\n                image_url='http://farm%s.static.flickr.com/%s/buddyicons/%s.jpg'\n                    % (persondata['iconfarm'], persondata['iconserver'], nsid),\n                width=48,\n                height=48,\n            )\n            avatar.save()\n\n        namenode = persondata.get('realname', persondata.get('username'))\n\n        person = Person(\n            display_name=namenode['_content'],\n            permalink_url=persondata['profileurl']['_content'],\n            avatar=avatar,\n        )\n        person.save()\n\n    try:\n        display_name = persondata['realname']['_content']\n    except KeyError:\n        display_name = None\n\n    acc = Account(\n        service='flickr.com',\n        ident=nsid,\n        display_name=display_name or nsid,\n        person=person,\n    )\n    acc.save()\n    return acc\nleapfrog/poll/vimeo.py\ndef account_for_vimeo_id(user_id, person=None):\n    try:\n        # TODO: update vimeo avatar pictures (but that requires fetching their people info speculatively)\n        return Account.objects.get(service='vimeo.com', ident=user_id)\n    except Account.DoesNotExist:\n        pass\n\n    # get vimeo data\n    log.debug('Getting info on user %r', user_id)\n    userdata = call_vimeo('vimeo.people.getInfo', user_id=user_id)\n    persondata = userdata['person']\n\n    if person is None:\n        portraits = persondata.get('portraits', {}).get('portrait')\n        avatar = None\n        if portraits is not None:\n            portraits = sorted([portrait for portrait in portraits if int(portrait['height']) >= 75], key=lambda x: int(x['height']))\n            if portraits:\n                portrait = portraits[0]\n                avatar = Media(\n                    image_url=portrait['_content'],\n                    width=int(portrait['width']),\n                    height=int(portrait['height']),\n                )\n                avatar.save()\n\n        person = Person(\n            display_name=persondata['display_name'],\n            permalink_url=persondata['profileurl'],\n            avatar=avatar,\n        )\n        person.save()\n\n    acc = Account(\n        service='vimeo.com',\n        ident=user_id,\n        display_name=persondata.get('display_name', persondata.get('username', user_id)),\n        person=person,\n    )\n    acc.save()\n\n    return acc\nleapfrog/models.py\nclass Object(models.Model):\n\n    RENDER_MODE_CHOICES = (\n        ('mixed', 'mixed'),\n        ('status', 'status'),\n        ('image', 'image'),\n        ('link', 'link'),\n    )\n\n    service = models.CharField(max_length=20, blank=True)\n    foreign_id = models.CharField(max_length=255, blank=True)\n    public = models.BooleanField(blank=True, default=True)\n\n    title = models.CharField(max_length=255, blank=True, null=True)\n    body = models.TextField(blank=True)\n    image = models.ForeignKey(Media, null=True, blank=True, related_name=\"represented_objects\")\n    author = models.ForeignKey(Account, null=True, blank=True, related_name=\"authored_objects\")\n\n    render_mode = models.CharField(max_length=15, blank=True, default='', choices=RENDER_MODE_CHOICES)\n\n    time = models.DateTimeField(db_index=True, default=datetime.utcnow)\n    permalink_url = models.CharField(max_length=255, blank=True, null=True)\n\n    in_reply_to = models.ForeignKey(\"Object\", related_name='replies', null=True, blank=True)\n\n    def __repr__(self):\n        return '<Object: %s>' % (unicode(self).encode('ascii', 'replace'),)\n\n    def __unicode__(self):\n        if self.title:\n            return self.title\n        return u'%s by %s' % (self.render_mode, unicode(self.author))\n\n    def save(self, **kwargs):\n        if self.body:\n            soup = BeautifulSoup(self.body)\n            for script_node in soup.findAll('script'):\n                script_node.extract()\n            self.body = str(soup).decode('utf8').strip()\n        return super(Object, self).save(**kwargs)\n\n    @property\n    def permalink_host(self):\n        return urlparse(self.permalink_url).netloc\n\n    @property\n    def permalink_root(self):\n        return urljoin(self.permalink_url, '/')\n\n    class Meta:\n        unique_together = (('service', 'foreign_id'),)\n        db_table = 'leapfrog_object'\nleapfrog/models.py\nclass UserSetting(models.Model):\n\n    user = models.ForeignKey(User)\n    key = models.CharField(max_length=50)\n    value = models.CharField(max_length=250)\n\n    class Meta:\n        unique_together = (('user', 'key'),)\n        db_table = 'leapfrog_usersetting'\nleapfrog/poll/typepad.py\ndef account_for_typepad_user(tp_user, person=None):\n    try:\n        account = Account.objects.get(service='typepad.com', ident=tp_user.url_id)\n    except Account.DoesNotExist:\n        if person is None:\n            if tp_user.avatar_link.url_template:\n                avatar = Media(\n                    width=50,\n                    height=50,\n                    image_url=tp_user.avatar_link.url_template.replace('{spec}', '50si'),\n                )\n            else:\n                avatar = Media(\n                    width=tp_user.avatar_link.width,\n                    height=tp_user.avatar_link.height,\n                    image_url=tp_user.avatar_link.url,\n                )\n            avatar.save()\n            person = Person(\n                display_name=tp_user.display_name or tp_user.preferred_username,\n                avatar=avatar,\n                permalink_url=tp_user.profile_page_url,\n            )\n            person.save()\n        account = Account(\n            service='typepad.com',\n            ident=tp_user.url_id,\n            display_name=tp_user.display_name or tp_user.preferred_username,\n            person=person,\n        )\n        account.save()\n    else:\n        person = account.person\n        if not person.avatar_source or person.avatar_source == 'typepad.com':\n            if tp_user.avatar_link.url_template:\n                tp_avatar_url = tp_user.avatar_link.url_template.replace('{spec}', '50si')\n            else:\n                tp_avatar_url = tp_user.avatar_link.url\n\n            if not person.avatar or person.avatar.image_url != tp_avatar_url:\n                if tp_user.avatar_link.url_template:\n                    avatar = Media(\n                        width=50,\n                        height=50,\n                        image_url=tp_avatar_url,\n                    )\n                else:\n                    avatar = Media(\n                        width=tp_user.avatar_link.width,\n                        height=tp_user.avatar_link.height,\n                        image_url=tp_avatar_url,\n                    )\n                avatar.save()\n                person.avatar = avatar\n                person.avatar_source = 'typepad.com'\n                person.save()\n            elif not person.avatar_source:\n                person.avatar_source = 'typepad.com'\n                person.save()\n\n    return account\nleapfrog/poll/mlkshk.py\ndef account_for_mlkshk_userinfo(userinfo, person=None):\n    account_id = str(userinfo['id'])\n    try:\n        return Account.objects.get(service='mlkshk.com', ident=account_id)\n    except Account.DoesNotExist:\n        pass\n\n    username = userinfo['name']\n    if person is None:\n        # TODO: use mlkshk profile images when we get stabler urls for them\n        person = Person(\n            display_name=username,\n            permalink_url='http://mlkshk.com/user/%s' % username,\n        )\n        person.save()\n\n    account = Account(\n        service='mlkshk.com',\n        ident=account_id,\n        display_name=username,\n        person=person,\n    )\n    account.save()\n\n    return account\nleapfrog/models.py\nclass Person(models.Model):\n\n    user = models.OneToOneField(User, null=True, blank=True)\n    display_name = models.CharField(max_length=100)\n    avatar = models.ForeignKey(Media, blank=True, null=True)\n    avatar_source = models.CharField(max_length=20, blank=True)\n    permalink_url = models.CharField(max_length=100, blank=True)\n    last_viewed_home = models.DateTimeField(default=datetime.utcnow)\n\n    def __unicode__(self):\n        return unicode(self.display_name)\n\n    class Meta:\n        db_table = 'leapfrog_person'\nleapfrog/poll/facebook.py\ndef account_for_facebook_user(fb_user, person=None):\n    try:\n        account = Account.objects.get(service='facebook.com', ident=fb_user[\"id\"])\n    except Account.DoesNotExist:\n        if person is None:\n            avatar = Media(\n                width=50,\n                height=50,\n                image_url='http://graph.facebook.com/%s/picture' % fb_user[\"id\"]\n            )\n            avatar.save()\n            person = Person(\n                display_name=fb_user[\"name\"],\n                avatar=avatar,\n                permalink_url=fb_user[\"link\"],\n            )\n            person.save()\n        account = Account(\n            service='facebook.com',\n            ident=fb_user[\"id\"],\n            display_name=fb_user[\"name\"],\n            person=person,\n        )\n        account.save()\n\n    return account\nleapfrog/models.py\nclass Account(models.Model):\n\n    service = models.CharField(max_length=20)\n    ident = models.CharField(max_length=100)\n    display_name = models.CharField(max_length=100)\n    last_updated = models.DateTimeField(default=datetime(year=2000, month=1, day=1))\n    last_success = models.DateTimeField(default=datetime.utcnow)\n    authinfo = models.CharField(max_length=600, blank=True)\n    person = models.ForeignKey(Person, related_name='accounts')\n\n    status_background_color = models.CharField(max_length=6, blank=True)\n    status_background_image_url = models.CharField(max_length=150, blank=True)\n    status_background_tile = models.BooleanField(blank=True)\n\n    def __unicode__(self):\n        return u'%s at %s' % (self.display_name, self.service)\n\n    class Meta:\n        unique_together = (('service', 'ident'),)\n        db_table = 'leapfrog_account'\nleapfrog/poll/flickr.py\ndef call_flickr(method, sign=False, **kwargs):\n    query = dict(kwargs)\n    query['api_key'] = settings.FLICKR_KEY[0]\n    query['method'] = method\n    query['format'] = 'json'\n    query['nojsoncallback'] = 1\n\n    if sign:\n        sign_flickr_query(query)\n\n    url = urlunparse(('http', 'api.flickr.com', 'services/rest/', None, urlencode(query), None))\n\n    h = leapfrog.poll.embedlam.EmbedlamUserAgent()\n    resp, cont = h.request(url)\n    if resp.status != 200:\n        raise ValueError(\"Unexpected response querying Flickr method %s: %d %s\" % (method, resp.status, resp.reason))\n\n    result = json.loads(cont)\n    if result.get('stat') != 'ok':\n        if result.get('message') == 'Photo not found':\n            raise leapfrog.poll.embedlam.RequestError(\"Photo tried to do method %s about doesn't exist\" % (method,))\n        raise ValueError(\"Error making Flickr request with method %s: %s\" % (method, result.get('message')))\n\n    return result\nleapfrog/poll/vimeo.py\ndef call_vimeo(method, token=None, **kwargs):\n    csr = oauth.Consumer(*settings.VIMEO_CONSUMER)\n\n    http_url = 'http://vimeo.com/api/rest/v2?format=json&method=%s' % method\n    if kwargs:\n        http_url = '&'.join((http_url, urlencode(kwargs)))\n    oauth_request = oauth.Request.from_consumer_and_token(csr, token,\n        http_method='GET', http_url=http_url)\n    oauth_sign_method = oauth.SignatureMethod_HMAC_SHA1()\n    oauth_request.sign_request(oauth_sign_method, csr, token)\n    oauth_signing_base = oauth_sign_method.signing_base(oauth_request, csr, token)\n    oauth_header = oauth_request.to_header()\n\n    h = httplib2.Http()\n    h.follow_redirects = 0\n    normal_url = oauth_request.to_url()\n    log.debug('Making request to URL %r', normal_url)\n    try:\n        resp, content = h.request(normal_url, method=oauth_request.method,\n            headers=oauth_header)\n    except socket.error, exc:\n        raise leapfrog.poll.embedlam.RequestError(\"Request to %s could not complete: %s\" % (uri, str(exc)))\n\n    if resp.status == 502:\n        raise leapfrog.poll.embedlam.RequestError(\"502 Bad Gateway making Vimeo request %s\" % normal_url)\n    if resp.status == 503:\n        raise leapfrog.poll.embedlam.RequestError(\"503 Service Unavailable making Vimeo request %s\" % normal_url)\n    if resp.status == 500:\n        raise leapfrog.poll.embedlam.RequestError(\"500 Server Error making Vimeo request %s\" % normal_url)\n    if resp.status == 404:\n        raise leapfrog.poll.embedlam.RequestError(\"404 Not Found making Vimeo request %s, wtf\" % normal_url)\n    if resp.status != 200:\n        raise ValueError(\"Unexpected response making Vimeo request %s: %d %s\" % (normal_url, resp.status, resp.reason))\n\n    data = json.loads(content)\n    if data['stat'] != 'fail':\n        return data\n\n    err = data['err']\n    if method == 'vimeo.videos.getSubscriptions' and err['msg'] == 'Internal error.':\n        raise leapfrog.poll.embedlam.RequestError(\"Internal error getting Vimeo subscriptions (try again later?)\")\n\n    raise ValueError(\"Error retrieving data for %s call: %s: %s\" % (method, err['msg'], err['expl']))\nleapfrog/poll/flickr.py\ndef sign_flickr_query(query):\n    sign_base = ''.join('%s%s' % (k, v) for k, v in sorted(query.items(), key=lambda i: i[0]))\n\n    signer = md5()\n    signer.update(settings.FLICKR_KEY[1])\n    signer.update(sign_base)\n\n    query['api_sig'] = signer.hexdigest()\nleapfrog/poll/mlkshk.py\ndef call_mlkshk(uri, method='GET', body=None, headers=None, authtoken=None, authsecret=None):\n    if headers is None:\n        headers = {}\n\n    if authtoken is not None:\n        headers['Authorization'] = sign(uri, method, authtoken, authsecret)\n        log.debug(\"Mlkshk authentication header: %r\", headers['Authorization'])\n\n    h = httplib2.Http(disable_ssl_certificate_validation=True)\n    try:\n        resp, cont = h.request(uri, method, body, headers)\n    except httplib.BadStatusLine:\n        raise leapfrog.poll.embedlam.RequestError(\"Bad status line requesting %s (is Mlkshk down?)\" % uri)\n    except ssl.SSLError, exc:\n        raise leapfrog.poll.embedlam.RequestError(\"SSL error requesting %s: %s (is Mlkshk down?)\" % (uri, str(exc)))\n    if resp.status == 500:\n        raise leapfrog.poll.embedlam.RequestError(\"500 Server Error requesting %s (is Mlkshk down?)\" % uri)\n    if resp.status == 502:\n        raise leapfrog.poll.embedlam.RequestError(\"502 Bad Gateway requesting %s (is Mlkshk down?)\" % uri)\n    if resp.status == 401:\n        raise leapfrog.poll.embedlam.RequestError(\"401 Unauthorized requesting %s (probably an expired token?)\" % uri)\n    if resp.status != 200:\n        raise ValueError(\"Unexpected HTTP response %d %s requesting %s\" % (resp.status, resp.reason, uri))\n\n    try:\n        return json.loads(cont)\n    except ValueError, exc:\n        raise ValueError(\"Invalid JSON response requesting %s: %s\" % (uri, str(exc)))\nleapfrog/poll/tumblr.py\ndef account_for_tumblr_userinfo(userinfo, person=None):\n    username = userinfo['name']\n    try:\n        account = Account.objects.get(service='tumblr.com', ident=username)\n    except Account.DoesNotExist:\n        pass\n    else:\n        person = account.person\n        if not person.avatar_source or person.avatar_source == 'tumblr.com':\n            (primary_blog,) = [blog for blog in userinfo['blogs'] if blog.get('primary', False)]\n            tumblr_avatar_url = 'http://api.tumblr.com/v2/blog/%s.tumblr.com/avatar/64' % primary_blog['name']\n            if not person.avatar or person.avatar.image_url != tumblr_avatar_url:\n                avatar = Media(\n                    image_url=tumblr_avatar_url,\n                    width=64,\n                    height=64,\n                )\n                avatar.save()\n                person.avatar = avatar\n                person.avatar_source = 'tumblr.com'\n                person.save()\n            elif not person.avatar_source:\n                person.avatar_source = 'tumblr.com'\n                person.save()\n        return account\n\n    (primary_blog,) = [blog for blog in userinfo['blogs'] if blog.get('primary', False)]\n    display_name = primary_blog.get('title', username)\n    if person is None:\n        tumblr_avatar_url = 'http://api.tumblr.com/v2/blog/%s.tumblr.com/avatar/64' % primary_blog['name']\n        avatar = Media(\n            image_url=tumblr_avatar_url,\n            width=64,\n            height=64,\n        )\n        avatar.save()\n\n        person = Person(\n            display_name=display_name,\n            permalink_url=primary_blog['url'],\n            avatar=avatar,\n        )\n        person.save()\n\n    account = Account(\n        service='tumblr.com',\n        ident=account_name,\n        display_name=display_name,\n        person=person,\n    )\n    account.save()\n\n    return account\n", "answers": ["    account = account_for_tumblr_userinfo(userinfo, person=person)"], "length": 1774, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "f2ab2a6c79345e3d81232052faa44fa8cca237e4b7fb8dff"}
{"input": "from packet.Vlan import Vlan\nfrom .baseapi import BaseAPI\nfrom .baseapi import Error as PacketError\nfrom .baseapi import ResponseError\nfrom .Batch import Batch\nfrom .Plan import Plan\nfrom .Device import Device\nfrom .SSHKey import SSHKey\nfrom .Project import Project\nfrom .Facility import Facility\nfrom .Metro import Metro\nfrom .OperatingSystem import OperatingSystem\nfrom .Volume import Volume\nfrom .BGPConfig import BGPConfig\nfrom .BGPSession import BGPSession\nfrom .IPAddress import IPAddress\nfrom .HardwareReservation import HardwareReservation\nfrom .Snapshot import Snapshot\nfrom .Organization import Organization\nfrom .Email import Email\nfrom .Event import Event\nfrom .Provider import Provider\n            \"facility\": facility,\n        }\n\n        if snapshot_count > 0 and snapshot_frequency is not None:\n            params[\"snapshot_policies\"] = {\n                \"snapshot_count\": snapshot_count,\n                \"snapshot_frequency\": snapshot_frequency,\n            }\n\n        data = self.call_api(\n            \"projects/%s/storage?include=facility\" % project_id,\n            type=\"POST\",\n            params=params,\n        )\n\n        return Volume(data, self)\n\n    def get_volume(self, volume_id):\n        params = {\"include\": \"facility,attachments.device\"}\n        data = self.call_api(\"storage/%s\" % volume_id, params=params)\n        return Volume(data, self)\n\n    def get_capacity(self, legacy=None):\n        \"\"\"Get capacity of all facilities.\n\n        :param legacy: Indicate set of server types to include in response\n\n        Validation of `legacy` is left to the packet api to avoid going out\n        of date if any new value is introduced.\n        The currently known values are:\n          - only (current default, will be switched \"soon\")\n          - include\n          - exclude (soon to be default)\n        \"\"\"\n        params = None\n        if legacy:\n            params = {\"legacy\": legacy}\n\n        return self.call_api(\"/capacity\", params=params)[\"capacity\"]\n\n    # servers is a list of tuples of facility, plan, and quantity.\n    def validate_capacity(self, servers):\n        params = {\"servers\": []}\n        for server in servers:\n            params[\"servers\"].append(\n                {\"facility\": server[0], \"plan\": server[1], \"quantity\": server[2]}\n            )\n\n        try:\n            data = self.call_api(\"/capacity\", \"POST\", params)\n            return all(s[\"available\"] for s in data[\"servers\"])\n        except PacketError as e:  # pragma: no cover\n            if e.args[0] == \"Error 503: Service Unavailable\":\n                return False\n            else:\n                raise e\n\n    # servers is a list of tuples of metro, plan, and quantity.\n    def validate_metro_capacity(self, servers):\n        params = {\"servers\": []}\n        for server in servers:\n            params[\"servers\"].append(\n                {\"metro\": server[0], \"plan\": server[1], \"quantity\": server[2]}\n            )\n\n        try:\n            data = self.call_api(\"/capacity/metros\", \"POST\", params)\n            return all(s[\"available\"] for s in data[\"servers\"])\n        except PacketError as e:  # pragma: no cover\n            if e.args[0] == \"Error 503: Service Unavailable\":\n                return False\n            else:\n                raise e\n\n    def get_spot_market_prices(self, params={}):\n        data = self.call_api(\"/market/spot/prices\", params=params)\n        return data[\"spot_market_prices\"]\n\n    # BGP Config\n    def get_bgp_config(self, project_id):\n        data = self.call_api(\"projects/%s/bgp-config\" % project_id)\n        return BGPConfig(data)\n\n    def enable_project_bgp_config(\n        self, project_id, asn, deployment_type, md5=None, use_case=None\n    ):\n        params = {\n            \"deployment_type\": deployment_type,\n            \"asn\": asn,\n            \"md5\": md5,\n            \"use_case\": use_case,\n        }\n        self.call_api(\n            \"/projects/%s/bgp-configs\" % project_id, type=\"POST\", params=params\n        )\n\n    # BGP Session\n    def get_bgp_sessions(self, device_id, params={}):\n        data = self.call_api(\n            \"/devices/%s/bgp/sessions\" % device_id, type=\"GET\", params=params\n        )\n        bgp_sessions = list()\n        for jsoned in data[\"bgp_sessions\"]:\n            bpg_session = BGPSession(jsoned)\n            bgp_sessions.append(bpg_session)\n        return bgp_sessions\n\n    def create_bgp_session(self, device_id, address_family):\n        data = self.call_api(\n            \"/devices/%s/bgp/sessions\" % device_id,\n            type=\"POST\",\n            params={\"address_family\": address_family},\n        )\n        return BGPSession(data)\n\n    # IP operations\n    def list_device_ips(self, device_id):\n        data = self.call_api(\"devices/%s/ips\" % device_id, type=\"GET\")\n        ips = list()\n        for jsoned in data[\"ip_addresses\"]:\n", "context": "packet/HardwareReservation.py\nclass HardwareReservation:\n    def __init__(self, data, manager):\n        self.manager = manager\n\n        self.id = data.get(\"id\")\n        self.created_at = data.get(\"created_at\")\n        self.billing_cycle = data.get(\"billing_cycle\")\n        self.created_at = data.get(\"created_at\")\n        self.short_id = data.get(\"short_id\")\n        self.intervals = data.get(\"intervals\")\n        self.current_period = data.get(\"current_period\")\n        self.started_at = data.get(\"started_at\")\n        self.custom_rate = data.get(\"custom_rate\")\n        self.remove_at = data.get(\"remove_at\")\n        self.project = data.get(\"project\")\n        # self.facility = data.get(\"facility\")\n        self.device = data.get(\"device\")\n        self.provisionable = data.get(\"provisionable\")\n        self.spare = data.get(\"spare\")\n        self.need_of_service = data.get(\"need_of_service\")\n        self.plan = Plan(data.get(\"plan\"))\n        self.switch_uuid = data.get(\"switch_uuid\")\n\n        try:\n            project_data = self.manager.call_api(data[\"project\"][\"href\"], type=\"GET\")\n            self.project = Project(project_data, self.manager)\n        except (KeyError, IndexError):\n            self.attached_to = None\n\n        # endpoint is not working yet\n        # try:\n        #     facility_data = self.manager.call_api(\n        #         data[\"facility\"][\"href\"], type=\"GET\"\n        #     )\n        #     self.project = Facility(facility_data, self.manager)\n        # except (KeyError, IndexError):\n        #     self.attached_to = None\n\n        try:\n            device_data = self.manager.call_api(data[\"device\"][\"href\"], type=\"GET\")\n            self.device = Device(device_data, self.manager)\n        except (KeyError, IndexError, TypeError):\n            self.attached_to = None\n\n    def __str__(self):\n        return \"%s\" % self.id\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\n\n    def __getitem__(self, item):\n        return getattr(self, item)\npacket/SSHKey.py\nclass SSHKey:\n    def __init__(self, data, manager):\n        self.manager = manager\n\n        self.id = data.get(\"id\")\n        self.key = data.get(\"key\")\n        self.label = data.get(\"label\")\n        self.fingerprint = data.get(\"fingerprint\")\n        self.href = data.get(\"href\")\n        self.created_at = data.get(\"created_at\")\n        self.updated_at = data.get(\"updated_at\")\n\n        try:\n            self.owner = data[\"owner\"][\"href\"]\n        except (KeyError, TypeError):\n            self.owner = None\n\n    def update(self):\n        params = {\"label\": self.label, \"key\": self.key}\n\n        return self.manager.call_api(\n            \"ssh-keys/%s\" % self.id, type=\"PATCH\", params=params\n        )\n\n    def delete(self):\n        return self.manager.call_api(\"ssh-keys/%s\" % self.id, type=\"DELETE\")\n\n    def __str__(self):\n        return \"%s %s\" % (self.id, self.label)\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/BGPSession.py\nclass BGPSession:\n    def __init__(self, data):\n        self.id = data.get(\"id\")\n        self.status = data.get(\"status\")\n        self.learned_routes = data.get(\"learned_routes\")\n        self.switch_name = data.get(\"switch_name\")\n        self.default_route = data.get(\"default_route\")\n        self.created_at = data.get(\"created_at\")\n        self.updated_at = data.get(\"updated_at\")\n        self.device = data.get(\"device\")\n        self.address_family = data.get(\"address_family\")\n        self.href = data.get(\"href\")\n\n    def __str__(self):\n        return \"%s\" % self.id\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/Facility.py\nclass Facility:\n    def __init__(self, data):\n        self.id = data.get(\"id\")\n        self.code = data.get(\"code\")\n        self.name = data.get(\"name\")\n        self.features = data.get(\"features\")\n        self.address = data.get(\"address\")\n\n    def __str__(self):\n        return \"%s\" % self.code\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/Provider.py\nclass Provider:\n    def __init__(self, data):\n        self.id = data.get(\"id\")\n        self.name = data.get(\"name\")\n        self.status = data.get(\"status\")\n        self.type = data.get(\"type\")\n        self.public = data.get(\"public\")\n\n    def __str__(self):\n        return \"%s\" % self.id\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/Device.py\nclass Device:\n    def __init__(self, data, manager):\n        self.manager = manager\n\n        self.id = data.get(\"id\")\n        self.short_id = data.get(\"short_id\")\n        self.hostname = data.get(\"hostname\")\n        self.description = data.get(\"description\")\n        self.state = data.get(\"state\")\n        self.tags = data.get(\"tags\")\n        self.image_url = data.get(\"image_url\")\n        self.billing_cycle = data.get(\"billing_cycle\")\n        self.user = data.get(\"user\")\n        self.iqn = data.get(\"iqn\")\n        self.locked = data.get(\"locked\")\n        self.bonding_mode = data.get(\"bonding_mode\")\n        self.created_at = data.get(\"created_at\")\n        self.updated_at = data.get(\"updated_at\")\n        self.ipxe_script_url = data.get(\"ipxe_script_url\")\n        self.always_pxe = data.get(\"always_pxe\", False)\n        self.storage = data.get(\"storage\")\n        self.customdata = data.get(\"customdata\")\n        self.operating_system = OperatingSystem(data[\"operating_system\"])\n        self.facility = data.get(\"facility\")\n        self.metro = data.get(\"metro\")\n        self.project = data.get(\"project\")\n        self.ssh_keys = data.get(\"ssh_keys\")\n        self.project_lite = data.get(\"project_lite\")\n        self.volumes = data.get(\"volumes\")\n        self.ip_addresses = data.get(\"ip_addresses\")\n        self.plan = data.get(\"plan\")\n        self.userdata = data.get(\"userdata\")\n        self.switch_uuid = data.get(\"switch_uuid\")\n        self.network_ports = data.get(\"network_ports\")\n        self.href = data.get(\"href\")\n        self.spot_instance = data.get(\"spot_instance\", False)\n        self.hardware_reservation_id = data.get(\"hardware_reservation_id\")\n        self.spot_price_max = data.get(\"spot_price_max\")\n        self.termination_time = data.get(\"termination_time\")\n        self.root_password = data.get(\"root_password\")\n        self.provisioning_percentage = data.get(\"provisioning_percentage\")\n\n    def update(self):\n        params = {\n            \"hostname\": self.hostname,\n            \"locked\": self.locked,\n            \"tags\": self.tags,\n            \"description\": self.description,\n            \"billing_cycle\": self.billing_cycle,\n            \"userdata\": self.userdata,\n            \"always_pxe\": self.always_pxe,\n            \"ipxe_script_url\": self.ipxe_script_url,\n            \"spot_instance\": self.spot_instance,\n            \"customdata\": self.customdata,\n        }\n\n        return self.manager.call_api(\n            \"devices/%s\" % self.id, type=\"PATCH\", params=params\n        )\n\n    def delete(self):\n        return self.manager.call_api(\"devices/%s\" % self.id, type=\"DELETE\")\n\n    def reinstall(self, operating_system=None, ipxe_script_url=None):\n        params = {\"type\": \"reinstall\"}\n        if operating_system is not None:\n            params[\"operating_system\"] = operating_system\n        if ipxe_script_url is not None:\n            params[\"operating_system\"] = \"custom_ipxe\"\n            params[\"ipxe_script_url\"] = ipxe_script_url\n\n        return self.manager.call_api(\n            \"devices/%s/actions\" % self.id, type=\"POST\", params=params\n        )\n\n    def power_off(self):\n        params = {\"type\": \"power_off\"}\n        return self.manager.call_api(\n            \"devices/%s/actions\" % self.id, type=\"POST\", params=params\n        )\n\n    def power_on(self):\n        params = {\"type\": \"power_on\"}\n        return self.manager.call_api(\n            \"devices/%s/actions\" % self.id, type=\"POST\", params=params\n        )\n\n    def reboot(self):\n        params = {\"type\": \"reboot\"}\n        return self.manager.call_api(\n            \"devices/%s/actions\" % self.id, type=\"POST\", params=params\n        )\n\n    def rescue(self):\n        params = {\"type\": \"rescue\"}\n        return self.manager.call_api(\n            \"devices/%s/actions\" % self.id, type=\"POST\", params=params\n        )\n\n    def ips(self):\n        return self.manager.list_device_ips(self.id)\n\n    def __str__(self):\n        return \"%s\" % self.hostname\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\n\n    def __getitem__(self, item):\n        return getattr(self, item)\npacket/baseapi.py\nclass BaseAPI(object):\n    \"\"\"\n        Basic api class for\n    \"\"\"\n\n    def __init__(self, auth_token, consumer_token, user_agent=\"\"):\n        self.auth_token = auth_token\n        self.consumer_token = consumer_token\n        self.end_point = \"api.packet.net\"\n        self._user_agent_prefix = user_agent\n        self._log = logging.getLogger(__name__)\n\n    @property\n    def user_agent(self):\n        return \"{}packet-python/{} {}\".format(\n            self._user_agent_prefix, __version__, requests.utils.default_user_agent()\n        ).strip()\n\n    def call_api(self, method, type=\"GET\", params=None):  # noqa\n        if params is None:\n            params = {}\n\n        url = \"https://\" + self.end_point + \"/\" + method\n\n        headers = {\n            \"X-Auth-Token\": self.auth_token,\n            \"X-Consumer-Token\": self.consumer_token,\n            \"Content-Type\": \"application/json\",\n            \"User-Agent\": self.user_agent,\n        }\n\n        # remove token from log\n        headers_str = str(headers).replace(self.auth_token.strip(), \"TOKEN\")\n        self._log.debug(\"%s %s %s %s\" % (type, url, params, headers_str))\n        try:\n            if type == \"GET\":\n                url = url + \"%s\" % self._parse_params(params)\n                resp = requests.get(url, headers=headers)\n            elif type == \"POST\":\n                resp = requests.post(\n                    url,\n                    headers=headers,\n                    data=json.dumps(\n                        params, default=lambda o: o.__dict__, sort_keys=True, indent=4\n                    ),\n                )\n            elif type == \"DELETE\":\n                resp = requests.delete(url, headers=headers)\n            elif type == \"PATCH\":\n                resp = requests.patch(url, headers=headers, data=json.dumps(params))\n            else:\n                raise Error(\n                    \"method type not recognized as one of GET, POST, DELETE or PATCH: %s\"\n                    % type\n                )\n        except requests.exceptions.RequestException as e:  # pragma: no cover\n            raise Error(\"Communcations error: %s\" % str(e), e)\n\n        if not resp.content:\n            data = None\n        elif resp.headers.get(\"content-type\", \"\").startswith(\"application/json\"):\n            try:\n                data = resp.json()\n            except ValueError as e:  # pragma: no cover\n                raise JSONReadError(\"Read failed: %s\" % e.message, e)\n        else:\n            data = resp.content  # pragma: no cover\n\n        if not resp.ok:  # pragma: no cover\n            raise ResponseError(resp, data)\n\n        try:\n            resp.raise_for_status()\n        except requests.HTTPError as e:  # pragma: no cover\n            raise ResponseError(resp, data, e)\n\n        self.meta = None\n        try:\n            if data and data[\"meta\"]:\n                self.meta = data[\"meta\"]\n        except (KeyError, IndexError):\n            pass\n\n        return data\n\n    def _parse_params(self, params):\n        vals = list()\n        for k, v in params.items():\n            vals.append(str(\"%s=%s\" % (k, v)))\n        return \"?\" + \"&\".join(vals)\npacket/baseapi.py\nclass Error(Exception):\n    \"\"\"Base exception class for this module\"\"\"\n\n    def __init__(self, msg, cause=None):\n        super(Error, self).__init__(msg)\n        self._cause = cause\n\n    @property\n    def cause(self):\n        \"\"\"The underlying exception causing the error, if any.\"\"\"\n        return self._cause\npacket/Vlan.py\nclass Vlan:\n    def __init__(self, data, manager):\n        self.manager = manager\n        if data is None:\n            return\n\n        self.id = data.get(\"id\")\n        self.description = data.get(\"description\")\n        self.vxlan = data.get(\"vxlan\")\n        self.internet_gateway = data.get(\"internet_gateway\")\n        self.facility_code = data.get(\"facility_code\")\n        self.metro_code = data.get(\"metro_code\")\n        self.created_at = data.get(\"created_at\")\n        facility = data.get(\"facility\")\n        self.facility = Facility(facility) if facility else None\n        metro = data.get(\"metro\")\n        self.metro = Metro(metro) if metro else None\n\n        try:\n            project_data = self.manager.call_api(\n                data[\"assigned_to\"][\"href\"], type=\"GET\"\n            )\n            self.assigned_to = Project(project_data, self.manager)\n        except (KeyError, IndexError):\n            self.attached_to = None\n\n    def get(self):\n        return self.manager.call_api(\"virtual-networks/%s\" % self.id, type=\"GET\")\n\n    def delete(self):\n        return self.manager.call_api(\"virtual-networks/%s\" % self.id, type=\"DELETE\")\n\n    def create_internet_gateway(self, ip_reservation_length):\n        \"\"\":param ip_reservation_length:  (required) number of IP addresses possible 8 or 16\"\"\"\n        params = {\"length\": ip_reservation_length}\n        return self.manager.call_api(\n            \"/virtual-networks/%s/internet-gateways\" % self.id,\n            type=\"POST\",\n            params=params,\n        )\n\n    def assign_native_vlan(self, port_id):\n        params = {\"vnid\": self.id}\n        return self.manager.call_api(\n            \"/ports/%s/native-vlan\" % port_id, type=\"POST\", params=params\n        )\n\n    def remove_native_vlan(self, port_id):\n        return self.manager.call_api(\"/ports/%s/native-vlan\" % port_id, type=\"DELETE\")\n\n    def __str__(self):\n        return \"%s\" % self.id\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/Organization.py\nclass Organization:\n    def __init__(self, data):\n        self.id = data.get(\"id\")\n        self.name = data.get(\"name\")\n        self.description = data.get(\"description\")\n        self.website = data.get(\"website\")\n        self.twitter = data.get(\"twitter\")\n        self.created_at = data.get(\"created_at\")\n        self.updated_at = data.get(\"updated_at\")\n        self.tax_id = data.get(\"tax_id\")\n        self.main_phone = data.get(\"main_phone\")\n        self.billing_phone = data.get(\"billing_phone\")\n        self.credit_amount = data.get(\"credit_amount\")\n        self.personal = data.get(\"personal\")\n        self.customdata = data.get(\"customdata\")\n        self.attn = data.get(\"attn\")\n        self.purchase_order = data.get(\"purchase_order\")\n        self.billing_name = data.get(\"billing_name\")\n        self.enforce_2fa = data.get(\"enforce_2fa\")\n        self.enforce_2fa_at = data.get(\"enforce_2fa_at\")\n        self.short_id = data.get(\"short_id\")\n        self.account_id = data.get(\"account_id\")\n        self.enabled_features = data.get(\"enabled_features\")\n        self.maintenance_email = data.get(\"maintenance_email\")\n        self.abuse_email = data.get(\"abuse_email\")\n        self.address = data.get(\"address\")\n        self.billing_address = data.get(\"billing_address\")\n        self.account_manager = data.get(\"account_manager\")\n        self.logo = data.get(\"logo\")\n        self.logo_thumb = data.get(\"logo_thumb\")\n        self.projects = data.get(\"projects\")\n        self.plan = data.get(\"plan\")\n        self.monthly_spend = data.get(\"monthly_spend\")\n        self.current_user_abilities = data.get(\"current_user_abilities\")\n        self.href = data.get(\"href\")\n\n    def __str__(self):\n        return \"%s\" % self.id\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/OperatingSystem.py\nclass OperatingSystem(object):\n    def __init__(self, data):\n        self.slug = data.get(\"slug\")\n        self.name = data.get(\"name\")\n        self.distro = data.get(\"distro\")\n        self.version = data.get(\"version\")\n        self.provisionable_on = data.get(\"provisionable_on\")\n\n    def __str__(self):\n        return \"%s %s %s %s\" % (self.slug, self.name, self.distro, self.version)\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.slug)\npacket/Batch.py\nclass Batch:\n    def __init__(self, data):\n        self.id = data.get(\"id\")\n        self.error_messages = data.get(\"error_messages\")\n        self.quantity = data.get(\"quantity\")\n        self.state = data.get(\"state\")\n        self.created_at = data.get(\"created_at\")\n        self.updated_at = data.get(\"updated_at\")\n        self.devices = data.get(\"devices\")\n        self.project = data.get(\"project\")\n        self.state = data.get(\"state\")\n        self.error_messages = data.get(\"error_messages\")\n\n    def __str__(self):\n        return \"%s\" % self.id\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/Snapshot.py\nclass Snapshot:\n    def __init__(self, data):\n        self.id = data.get(\"id\")\n        self.status = data.get(\"status\")\n        self.timestamp = data.get(\"timestamp\")\n        self.created_at = data.get(\"created_at\")\n        self.volume = data.get(\"volume\")\n\n    def __str__(self):\n        return \"%s\" % self.name\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/Plan.py\nclass Plan:\n    def __init__(self, data):\n        self.id = data.get(\"id\")\n        self.name = data.get(\"name\")\n        self.slug = data.get(\"slug\")\n        self.line = data.get(\"line\")\n        self.pricing = data.get(\"pricing\")\n        self.specs = data.get(\"specs\")\n        self.description = data.get(\"description\")\n        self.available_in = data.get(\"available_in\")\n\n    def __str__(self):\n        return \"%s\" % self.slug\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/baseapi.py\nclass ResponseError(Error):\n    def __init__(self, resp, data, exception=None):\n        if not data:\n            msg = \"(empty response)\"\n        elif not isinstance(data, dict):\n            msg = str(data)\n        elif \"error\" in data:\n            msg = data[\"error\"]\n        elif \"errors\" in data:\n            msg = \", \".join(data[\"errors\"])\n        super(ResponseError, self).__init__(\n            \"Error {0}: {1}\".format(resp.status_code, msg), exception\n        )\n        self._response = resp\n\n    @property\n    def response(self):\n        \"\"\"The Requests response which failed\"\"\"\n        return self._response\npacket/Event.py\nclass Event:\r\n    def __init__(self, data):\r\n        self.id = data.get(\"id\")\r\n        self.type = data.get(\"type\")\r\n        self.body = data.get(\"body\")\r\n        self.state = data.get(\"state\")\r\n        self.created_at = data.get(\"created_at\")\r\n        self.modified_by = data.get(\"modified_by\")\r\n        self.ip = data.get(\"ip\")\r\n        self.interpolated = data.get(\"interpolated\")\r\n\r\n    def __str__(self):\r\n        return \"%s\" % self.interpolated\r\n\r\n    def __repr__(self):\r\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\r\npacket/IPAddress.py\nclass IPAddress:\n    def __init__(self, data, manager):\n        self.manager = manager\n\n        self.id = data.get(\"id\")\n        self.address_family = data.get(\"address_family\")\n        self.netmask = data.get(\"netmask\")\n        self.created_at = data.get(\"created_at\")\n        self.details = data.get(\"details\")\n        self.tags = data.get(\"tags\")\n        self.public = data.get(\"public\")\n        self.cidr = data.get(\"cidr\")\n        self.management = data.get(\"management\")\n        self.enabled = data.get(\"enabled\")\n        self.global_ip = data.get(\"global_ip\")\n        self.customdata = data.get(\"customdata\")\n        self.project = data.get(\"project\")\n        self.project_lite = data.get(\"project_lite\")\n        self.details = data.get(\"details\")\n        self.assigned_to = data.get(\"assigned_to\")\n        self.interface = data.get(\"interface\")\n        self.network = data.get(\"network\")\n        self.address = data.get(\"address\")\n        self.gateway = data.get(\"gateway\")\n\n        facility = data.get(\"facility\")\n        self.facility = Facility(facility) if facility else None\n        metro = data.get(\"metro\")\n        self.metro = Metro(metro) if metro else None\n\n    def delete(self):\n        return self.manager.call_api(\"ips/%s\" % self.id, type=\"DELETE\")\n\n    def __str__(self):\n        return \"%s\" % self.code\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/Volume.py\nclass Volume:\n    def __init__(self, data, manager):\n        self.manager = manager\n        if data is None:\n            return\n\n        self.id = data.get(\"id\")\n        self.name = data.get(\"name\")\n        self.description = data.get(\"description\")\n        self.size = data.get(\"size\")\n        self.state = data.get(\"state\")\n        self.locked = data.get(\"locked\")\n        self.billing_cycle = data.get(\"billing_cycle\")\n        self.created_at = data.get(\"created_at\")\n        self.updated_at = data.get(\"updated_at\")\n        self.attachments = data.get(\"attachments\")\n\n        self.plan = Plan(data.get(\"plan\"))\n        self.facility = Facility(data.get(\"facility\"))\n        try:\n            self.attached_to = data[\"attachments\"][0][\"device\"][\"id\"]\n        except (KeyError, IndexError):\n            self.attached_to = None\n\n    def update(self):\n        params = {\n            \"description\": self.description,\n            \"size\": self.size,\n            \"plan\": self.plan.slug,\n            \"locked\": self.locked,\n        }\n\n        return self.manager.call_api(\n            \"storage/%s\" % self.id, type=\"PATCH\", params=params\n        )\n\n    def delete(self):\n        return self.manager.call_api(\"storage/%s\" % self.id, type=\"DELETE\")\n\n    def attach(self, device_id):\n        params = {\"device_id\": device_id}\n        return self.manager.call_api(\n            \"storage/%s/attachments\" % self.id, type=\"POST\", params=params\n        )\n\n    def detach(self):\n        for attachment in self.attachments:\n            return self.manager.call_api(attachment[\"href\"], type=\"DELETE\")\n\n    def list_snapshots(self, params={}):\n        data = self.manager.call_api(\"storage/%s/snapshots\" % (self.id))\n        snapshots = list()\n        for jsoned in data[\"snapshots\"]:\n            snapshot = VolumeSnapshot(jsoned, self)\n            snapshots.append(snapshot)\n        return snapshots\n\n    def create_snapshot(self):\n        self.manager.call_api(\"storage/%s/snapshots\" % self.id, type=\"POST\")\n\n    def create_snapshot_policy(self, frequency, count):\n        \"\"\"Creates a new snapshot policy of your volume.\n\n        :param frequency:  (required) Snapshot frequency\n\n        Validation of `frequency` is left to the packet api to avoid going out\n        of date if any new value is introduced.\n        The currently known values are:\n          - 1hour,\n          - 1day\n          - 1week\n          - 1month\n          - 1year\n        \"\"\"\n        data = self.manager.call_api(\n            \"storage/{0}/snapshot-policies?snapshot_frequency={1}&snapshot_count={2}\".format(\n                self.id, frequency, count\n            ),\n            type=\"POST\",\n        )\n        return SnapshotPolicy(data, self)\n\n    def clone(self):\n        return Volume(\n            self.manager.call_api(\"storage/%s/clone\" % self.id, type=\"POST\"),\n            manager=self.manager,\n        )\n\n    def restore(self, restore_point):\n        self.manager.restore_volume(self.id, restore_point=restore_point)\n\n    def __str__(self):\n        return \"%s\" % self.id\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/Project.py\nclass Project:\n    def __init__(self, data, manager):\n        self.manager = manager\n\n        self.id = data.get(\"id\")\n        self.name = data.get(\"name\")\n        self.payment_method = data.get(\"payment_method\", [])\n        self.max_projects = data.get(\"max_devices\")\n        self.created_at = data.get(\"created_at\")\n        self.updated_at = data.get(\"updated_at\")\n        self.devices = data.get(\"devices\")\n        self.invitations = data.get(\"invitations\")\n        self.memberships = data.get(\"memberships\")\n        self.members = data.get(\"members\")\n        self.ssh_keys = data.get(\"ssh_keys\")\n\n    def update(self):\n        params = {\"name\": self.name}\n\n        return self.manager.call_api(\n            \"projects/%s\" % self.id, type=\"PATCH\", params=params\n        )\n\n    def delete(self):\n        return self.manager.call_api(\"projects/%s\" % self.id, type=\"DELETE\")\n\n    def __str__(self):\n        return \"%s\" % self.name\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/BGPConfig.py\nclass BGPConfig:\n    def __init__(self, data):\n        self.id = data.get(\"id\")\n        self.status = data.get(\"status\")\n        self.deployment_type = data.get(\"deployment_type\")\n        self.asn = data.get(\"asn\")\n        self.md5 = data.get(\"md5\")\n        self.route_object = data.get(\"route_object\")\n        self.max_prefix = data.get(\"max_prefix\")\n        self.created_at = data.get(\"created_at\")\n        self.requested_at = data.get(\"requested_at\")\n        self.project = data.get(\"project\")\n        self.sessions = data.get(\"sessions\")\n        self.ranges = data.get(\"ranges\")\n        self.href = data.get(\"href\")\n\n    def __str__(self):\n        return \"%s\" % self.id\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\npacket/Email.py\nclass Email:\r\n    def __init__(self, data, manager):\r\n        self.manager = manager\r\n\r\n        self.id = data.get(\"id\")\r\n        self.address = data.get(\"address\")\r\n        self.default = data.get(\"default\")\r\n        self.verified = data.get(\"verified\")\r\n\r\n    def update(self):\r\n        params = {\"address\": self.address, \"default\": self.default}\r\n\r\n        return self.manager.call_api(\"emails/%s\" % self.id, type=\"PATCH\", params=params)\r\n\r\n    def delete(self):\r\n        return self.manager.call_api(\"emails/%s\" % self.id, type=\"DELETE\")\r\n\r\n    def __str__(self):\r\n        return \"%s\" % self.address\r\n\r\n    def __repr__(self):\r\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\r\npacket/Metro.py\nclass Metro:\n    def __init__(self, data):\n        self.id = data.get(\"id\")\n        self.code = data.get(\"code\")\n        self.name = data.get(\"name\")\n        self.country = data.get(\"country\")\n\n    def __str__(self):\n        return \"%s\" % self.code\n\n    def __repr__(self):\n        return \"{}: {}\".format(self.__class__.__name__, self.id)\n", "answers": ["            ip = IPAddress(jsoned, self)"], "length": 2464, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "f5bb8a22c323dc3c8d8cc24286d5ceeba4148421f6a2a7f4"}
{"input": "import static org.jboss.remotingjmx.protocol.v2.Constants.ADD_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.ATTRIBUTE_LIST;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.BOOLEAN;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.CREATE_MBEAN;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.GET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.GET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.GET_DEFAULT_DOMAIN;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.GET_DOMAINS;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.GET_MBEAN_COUNT;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.GET_MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.GET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.INSTANCE_OF;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.INTEGER;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.INTEGER_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.INVOKE;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.IS_REGISTERED;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.NOTIFICATION_FILTER;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.OBJECT;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.OBJECT_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.QUERY_EXP;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.QUERY_MBEANS;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.QUERY_NAMES;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.REMOVE_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.RESPONSE_MASK;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.SEND_NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.SET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.SET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.SET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.SET_OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.STRING;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.STRING_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.UNREGISTER_MBEAN;\nimport static org.jboss.remotingjmx.protocol.v2.Constants.VOID;\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport javax.management.Attribute;\nimport javax.management.AttributeList;\nimport javax.management.AttributeNotFoundException;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.InstanceNotFoundException;\nimport javax.management.IntrospectionException;\nimport javax.management.InvalidAttributeValueException;\nimport javax.management.JMRuntimeException;\nimport javax.management.ListenerNotFoundException;\nimport javax.management.MBeanException;\nimport javax.management.MBeanInfo;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServerConnection;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.Notification;\nimport javax.management.NotificationFilter;\nimport javax.management.NotificationListener;\nimport javax.management.ObjectInstance;\nimport javax.management.ObjectName;\nimport javax.management.QueryExp;\nimport javax.management.ReflectionException;\nimport javax.security.auth.Subject;\nimport org.jboss.logging.Logger;\nimport org.jboss.marshalling.Marshaller;\nimport org.jboss.marshalling.Unmarshaller;\nimport org.jboss.remoting3.Channel;\nimport org.jboss.remoting3.Connection;\nimport org.jboss.remotingjmx.RemotingMBeanServerConnection;\nimport org.jboss.remotingjmx.VersionedConnection;\nimport org.xnio.IoFuture;\n/*\n * JBoss, Home of Professional Open Source.\n * Copyright 2012, Red Hat, Inc., and individual contributors\n * as indicated by the @author tags. See the copyright.txt file in the\n * distribution for a full listing of individual contributors.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.jboss.remotingjmx.protocol.v2;\n\n\n\n\n\n/**\n * The VersionOne client connection.\n *\n * @author <a href=\"mailto:darran.lofthouse@jboss.com\">Darran Lofthouse</a>\n */\nclass ClientConnection extends ClientCommon implements VersionedConnection {\n\n    private static final Logger log = Logger.getLogger(ClientConnection.class);\n\n    private final Channel channel;\n    // Registry of handlers for the incoming messages.\n    private final Map<Byte, Common.MessageHandler> handlerRegistry;\n\n    private final String connectionId;\n    private TheConnection mbeanServerConnection;\n    private final ClientRequestManager clientRequestManager;\n    private final ClientExecutorManager clientExecutorManager;\n    private LocalNotificationManager localNotificationManager;\n\n    ClientConnection(final Channel channel, final Map<String, ?> environment, final ClientRequestManager clientRequestManager,\n            final ClientExecutorManager clientExecutorManager, final String connectionId) {\n        super(channel, environment);\n        this.channel = channel;\n        this.clientRequestManager = clientRequestManager;\n        this.clientExecutorManager = clientExecutorManager;\n        this.connectionId = connectionId;\n        handlerRegistry = createHandlerRegistry();\n    }\n\n    private Map<Byte, Common.MessageHandler> createHandlerRegistry() {\n        Map<Byte, Common.MessageHandler> registry = new HashMap<Byte, Common.MessageHandler>();\n        registry.put((byte) (ADD_NOTIFICATION_LISTENER ^ RESPONSE_MASK), new MarshalledResponseHandler<Void>(VOID));\n        registry.put((byte) (CREATE_MBEAN ^ RESPONSE_MASK), new MarshalledResponseHandler<ObjectInstance>(OBJECT_INSTANCE));\n        registry.put((byte) (GET_ATTRIBUTE ^ RESPONSE_MASK), new MarshalledResponseHandler<Object>(OBJECT));\n        registry.put((byte) (GET_ATTRIBUTES ^ RESPONSE_MASK), new MarshalledResponseHandler<AttributeList>(ATTRIBUTE_LIST));\n        registry.put((byte) (GET_DEFAULT_DOMAIN ^ RESPONSE_MASK), new StringResponseHandler());", "context": "src/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte RESPONSE_MASK = (byte) 0x80;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte QUERY_MBEANS = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte INTEGER = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte REMOVE_NOTIFICATION_LISTENER = 0x12;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte GET_DEFAULT_DOMAIN = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte STRING = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte SEND_NOTIFICATION = 0x13;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte GET_OBJECT_INSTANCE = 0x03;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte NOTIFICATION_FILTER = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte GET_ATTRIBUTES = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte QUERY_EXP = 0x07;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte SET_OBJECT_INSTANCE = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte QUERY_NAMES = 0x05;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte INVOKE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/RemotingMBeanServerConnection.java\npublic interface RemotingMBeanServerConnection extends MBeanServerConnection {\n\n    Connection getConnection();\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte INTEGER_ARRAY = 0x12;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte VOID = 0x00; // Not actually passed as a parameter but used internally to indicate no parameter expected.\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte GET_DOMAINS = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte OBJECT = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte MBEAN_INFO = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte CREATE_MBEAN = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte SET_ATTRIBUTE = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte OBJECT_INSTANCE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte GET_ATTRIBUTE = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte ATTRIBUTE = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte STRING_ARRAY = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte SET_OBJECT_NAME = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte OBJECT_NAME = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte NOTIFICATION = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte GET_MBEAN_INFO = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte IS_REGISTERED = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte GET_MBEAN_COUNT = 0x07;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte UNREGISTER_MBEAN = 0x02;\nsrc/main/java/org/jboss/remotingjmx/VersionedConnection.java\npublic interface VersionedConnection extends Closeable {\n\n    String getConnectionId();\n\n    MBeanServerConnection getMBeanServerConnection(Subject subject);\n\n    void close();\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte ADD_NOTIFICATION_LISTENER = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte SET_ATTRIBUTES = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte BOOLEAN = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte OBJECT_ARRAY = 0x05;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte INSTANCE_OF = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v2/Constants.java\nstatic final byte ATTRIBUTE_LIST = 0x02;\n", "answers": ["        registry.put((byte) (GET_DOMAINS ^ RESPONSE_MASK), new StringArrayResponseHandler());"], "length": 824, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "4d7181e8ffb8e3cffa637ee6edb7a1f5cad3f2ac4ffcafa7"}
{"input": "package com.matejdro.pebbledialer.modules;\nimport android.app.PendingIntent;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.provider.ContactsContract;\nimport android.provider.MediaStore;\nimport android.service.notification.NotificationListenerService;\nimport android.telephony.TelephonyManager;\nimport android.util.SparseArray;\nimport com.getpebble.android.kit.util.PebbleDictionary;\nimport com.matejdro.pebblecommons.pebble.CommModule;\nimport com.matejdro.pebblecommons.pebble.PebbleCommunication;\nimport com.matejdro.pebblecommons.pebble.PebbleImageToolkit;\nimport com.matejdro.pebblecommons.pebble.PebbleTalkerService;\nimport com.matejdro.pebblecommons.pebble.PebbleUtil;\nimport com.matejdro.pebblecommons.util.ContactUtils;\nimport com.matejdro.pebblecommons.util.Size;\nimport com.matejdro.pebblecommons.util.TextUtil;\nimport com.matejdro.pebblecommons.vibration.PebbleVibrationPattern;\nimport com.matejdro.pebbledialer.callactions.AnswerCallAction;\nimport com.matejdro.pebbledialer.callactions.AnswerCallWithSpeakerAction;\nimport com.matejdro.pebbledialer.callactions.CallAction;\nimport com.matejdro.pebbledialer.callactions.DummyAction;\nimport com.matejdro.pebbledialer.callactions.EndCallAction;\nimport com.matejdro.pebbledialer.callactions.SMSReplyAction;\nimport com.matejdro.pebbledialer.callactions.ToggleMicrophoneAction;\nimport com.matejdro.pebbledialer.callactions.ToggleRingerAction;\nimport com.matejdro.pebbledialer.callactions.ToggleSpeakerAction;\nimport com.matejdro.pebbledialer.callactions.VolumeDownAction;\nimport com.matejdro.pebbledialer.callactions.VolumeUpAction;\nimport com.matejdro.pebbledialer.notifications.JellybeanNotificationListener;\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.List;\nimport timber.log.Timber;\n\n\n\n\n\npublic class CallModule extends CommModule\n{\n    public static final String INTENT_CALL_STATUS = \"CallStatus\";\n    public static final String INTENT_ACTION_FROM_NOTIFICATION = \"ActionFromNotification\";\n\n    public static int MODULE_CALL = 1;\n\n    private SparseArray<CallAction> actions = new SparseArray<CallAction>();\n\n    private boolean updateRequired;\n    private boolean identityUpdateRequired;\n    private boolean callerNameUpdateRequired;\n    private int callerImageNextByte = -1;\n\n    private String number = \"Outgoing Call\";\n    private String name = null;\n    private String type = null;\n    private Bitmap callerImage = null;\n    private byte[] callerImageBytes;\n\n    private CallState callState = CallState.NO_CALL;\n\n    private boolean vibrating;\n    private boolean closeAutomaticallyAfterThisCall = true;\n\n    long callStartTime;\n\n    public CallModule(PebbleTalkerService service)\n    {\n        super(service);\n\n        service.registerIntent(INTENT_CALL_STATUS, this);\n        service.registerIntent(INTENT_ACTION_FROM_NOTIFICATION, this);\n\n        registerCallAction(new AnswerCallAction(this), AnswerCallAction.ANSWER_ACTION_ID);\n        registerCallAction(new EndCallAction(this), EndCallAction.END_CALL_ACTION_ID);\n        registerCallAction(new ToggleRingerAction(this), ToggleRingerAction.TOGGLE_RINGER_ACTION_ID);\n        registerCallAction(new ToggleMicrophoneAction(this), ToggleMicrophoneAction.TOGGLE_MICROPHONE_ACTION_ID);\n        registerCallAction(new SMSReplyAction(this), SMSReplyAction.SMS_REPLY_ACTION_ID);\n\n        registerCallAction(new ToggleSpeakerAction(this), ToggleSpeakerAction.TOGGLE_SPEAKER_ACTION_ID);\n        registerCallAction(new AnswerCallWithSpeakerAction(this), AnswerCallWithSpeakerAction.ANSWER_WITH_SPEAKER_ACTION_ID);\n        registerCallAction(new VolumeDownAction(this), VolumeDownAction.VOLUME_DOWN_ACTION_ID);", "context": "app/src/main/java/com/matejdro/pebbledialer/notifications/JellybeanNotificationListener.java\n@TargetApi(value = Build.VERSION_CODES.JELLY_BEAN_MR2)\npublic class JellybeanNotificationListener extends NotificationListenerService {\n\tprivate static JellybeanNotificationListener instance = null;\n\n\t@Override\n\tpublic void onDestroy() {\n        Timber.d(\"Notification Listener stopped...\");\n\t\tsuper.onDestroy();\n\n\t\tinstance = null;\n\t}\n\n\t@Override\n\tpublic void onCreate() {\n        Timber.d(\"Creating Notification Listener...\");\n        super.onCreate();\n\n\t\tinstance = this;\n\t}\n\n\tpublic static boolean isActive()\n\t{\n\t\treturn instance != null;\n\t}\n\n\t@TargetApi(value = Build.VERSION_CODES.LOLLIPOP)\n\tpublic static boolean isPhoneInDoNotInterrupt()\n\t{\n\t\tif (instance == null)\n\t\t\treturn false;\n\n\t\tint interruptionFilter = instance.getCurrentInterruptionFilter();\n\t\tTimber.d(\"Interrupt filter: %d\", interruptionFilter);\n\t\treturn interruptionFilter != NotificationListenerService.INTERRUPTION_FILTER_ALL && interruptionFilter != 0;\n\t}\n\n\t@Override\n\tpublic void onNotificationPosted(final StatusBarNotification sbn) {\n        Timber.d(\"Got new jellybean notification\");\n        NotificationHandler.newNotification(JellybeanNotificationListener.this, sbn.getPackageName(), sbn.getNotification());\n\n\n\t}\n\n    @Override\n    public void onNotificationRemoved(StatusBarNotification sbn) {\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/SMSReplyAction.java\npublic class SMSReplyAction extends CallAction\n{\n    public static final int SMS_REPLY_ACTION_ID = 6;\n\n    public SMSReplyAction(CallModule callModule)\n    {\n        super(callModule);\n    }\n\n    @Override\n    public void executeAction()\n    {\n        ToggleRingerAction toggleRingerAction = ToggleRingerAction.get(getCallModule());\n        toggleRingerAction.mute();\n\n        SMSReplyModule smsReplyModule = SMSReplyModule.get(getCallModule().getService());\n        smsReplyModule.startSMSProcess(getCallModule().getNumber());\n\n        getCallModule().setCloseAutomaticallyAfterThisCall(false);\n    }\n\n    @Override\n    public void onCallEnd()\n    {\n    }\n\n    @Override\n    public int getIcon()\n    {\n        return CallAction.ICON_BUTTON_END_CALL;\n    }\n\n    public static SMSReplyAction get(CallModule callModule)\n    {\n        return (SMSReplyAction) callModule.getCallAction(SMS_REPLY_ACTION_ID);\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/VolumeDownAction.java\npublic class VolumeDownAction extends CallAction\n{\n    public static final int VOLUME_DOWN_ACTION_ID = 7;\n\n    public VolumeDownAction(CallModule callModule)\n    {\n        super(callModule);\n    }\n\n    @Override\n    public void executeAction()\n    {\n        if (getCallModule().getCallState() != CallModule.CallState.ESTABLISHED)\n            return;\n\n        AudioManager audioManager = (AudioManager) getCallModule().getService().getSystemService(Context.AUDIO_SERVICE);\n        audioManager.adjustStreamVolume(AudioManager.STREAM_VOICE_CALL, AudioManager.ADJUST_LOWER, 0);\n    }\n\n\n\n    @Override\n    public int getIcon()\n    {\n        return CallAction.ICON_BUTTON_VOLUME_DOWN;\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/ToggleMicrophoneAction.java\npublic class ToggleMicrophoneAction extends CallAction\n{\n    public static final int TOGGLE_MICROPHONE_ACTION_ID = 3;\n\n    private boolean microphoneMuted = false;\n\n    public ToggleMicrophoneAction(CallModule callModule)\n    {\n        super(callModule);\n    }\n\n    @Override\n    public void executeAction()\n    {\n        if (getCallModule().getCallState() != CallModule.CallState.ESTABLISHED)\n            return;\n\n        microphoneMuted = !microphoneMuted;\n\n        if (getCallModule().getService().getGlobalSettings().getBoolean(\"rootMode\", false))\n        {\n            String muteCommand;\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n                muteCommand = \"input keyevent 79\";\n            else\n                muteCommand = \"input keyevent 91\";\n            try {\n                Runtime.getRuntime().exec(new String[] {\"su\", \"-c\", muteCommand});\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        else\n        {\n            AudioManager audioManager = (AudioManager) getCallModule().getService().getSystemService(Context.AUDIO_SERVICE);\n            audioManager.setMicrophoneMute(microphoneMuted);\n        }\n\n        getCallModule().updatePebble();\n    }\n\n    @Override\n    public int getIcon()\n    {\n        return microphoneMuted ? CallAction.ICON_BUTTON_MIC_OFF : CallAction.ICON_BUTTON_MIC_ON;\n    }\n\n    public static ToggleMicrophoneAction get(CallModule callModule)\n    {\n        return (ToggleMicrophoneAction) callModule.getCallAction(TOGGLE_MICROPHONE_ACTION_ID);\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/AnswerCallWithSpeakerAction.java\npublic class AnswerCallWithSpeakerAction extends CallAction\n{\n    public static final int ANSWER_WITH_SPEAKER_ACTION_ID = 5;\n\n    private boolean enableSpeakerImmediately = false;\n\n    public AnswerCallWithSpeakerAction(CallModule callModule)\n    {\n        super(callModule);\n    }\n\n\n    @Override\n    public void executeAction()\n    {\n        if (getCallModule().getCallState() != CallModule.CallState.RINGING)\n            return;\n\n        enableSpeakerImmediately = true;\n        AnswerCallAction.get(getCallModule()).executeAction();\n    }\n\n    @Override\n    public void onCallEnd()\n    {\n        enableSpeakerImmediately = false; //Reset intent (there will be new intent at next call)\n    }\n\n    @Override\n    public void onPhoneOffhook()\n    {\n        if (enableSpeakerImmediately)\n        {\n            ToggleSpeakerAction speakerAction = ToggleSpeakerAction.get(getCallModule());\n\n            if (!speakerAction.isSpeakerphoneEnabled())\n                speakerAction.executeAction();\n        }\n    }\n\n    @Override\n    public int getIcon()\n    {\n        return CallAction.ICON_BUTTON_ANSWER;\n    }\n\n    public static AnswerCallWithSpeakerAction get(CallModule callModule)\n    {\n        return (AnswerCallWithSpeakerAction) callModule.getCallAction(ANSWER_WITH_SPEAKER_ACTION_ID);\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/VolumeUpAction.java\npublic class VolumeUpAction extends CallAction\n{\n    public static final int VOLUME_UP_ACTION_ID = 8;\n\n    public VolumeUpAction(CallModule callModule)\n    {\n        super(callModule);\n    }\n\n    @Override\n    public void executeAction()\n    {\n        if (getCallModule().getCallState() != CallModule.CallState.ESTABLISHED)\n            return;\n\n        AudioManager audioManager = (AudioManager) getCallModule().getService().getSystemService(Context.AUDIO_SERVICE);\n        audioManager.adjustStreamVolume(AudioManager.STREAM_VOICE_CALL, AudioManager.ADJUST_RAISE, 0);\n    }\n\n\n\n    @Override\n    public int getIcon()\n    {\n        return CallAction.ICON_BUTTON_VOLUME_UP;\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/EndCallAction.java\npublic class EndCallAction extends CallAction\n{\n    public static final int END_CALL_ACTION_ID = 1;\n\n    private PendingIntent notificationEndCallIntent;\n    private static Method getITelephonyMethod;\n\n    public EndCallAction(CallModule callModule)\n    {\n        super(callModule);\n\n        try {\n            getITelephonyMethod = TelephonyManager.class.getDeclaredMethod(\"getITelephony\", (Class[]) null);\n            getITelephonyMethod.setAccessible(true);\n        } catch (NoSuchMethodException e) {\n            Timber.e(e, \"iTelephony end not supported on your phone!\");\n        } catch (Exception e) {\n            Timber.e(e, \"Error while acquiring iTelephony\");\n            Crashlytics.logException(e);\n        }\n\n    }\n\n    public void registerNotificationEndCallIntent(PendingIntent notificationAnswerIntent)\n    {\n        this.notificationEndCallIntent = notificationAnswerIntent;\n    }\n\n    @Override\n    public void executeAction()\n    {\n        getCallModule().setCloseAutomaticallyAfterThisCall(true);\n\n        if (getCallModule().getService().getGlobalSettings().getBoolean(\"rootMode\", false))\n        {\n            Timber.d(\"Ending call using root method...\");\n            try {\n                Runtime.getRuntime().exec(new String[] {\"su\", \"-c\", \"input keyevent 6\"});\n                return;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (getCallModule().getCallState() == CallModule.CallState.RINGING && notificationEndCallIntent != null)\n        {\n            Timber.d(\"Ending call using notification method...\");\n\n            try {\n                notificationEndCallIntent.send();\n                return;\n            } catch (PendingIntent.CanceledException e) {\n            }\n        }\n\n        if (getITelephonyMethod != null)\n        {\n            Timber.d(\"Ending call using generic iTelephony method...\");\n            try\n            {\n                ITelephony iTelephony = (ITelephony) getITelephonyMethod.invoke(getCallModule().getService().getSystemService(Context.TELEPHONY_SERVICE), (Object[]) null);\n                iTelephony.endCall();\n                return;\n            }\n            catch (SecurityException e)\n            {\n                Timber.e(\"Cannot decline call, no CALL_PHONE permission.\");\n            }\n            catch (Exception e) {\n                Timber.e(e, \"Error while invoking iTelephony.endCall()\");\n                Crashlytics.logException(e);\n            }\n        }\n\n        Timber.e(\"All end call options failed! Nothing is supported.\");\n    }\n\n    @Override\n    public void onCallEnd()\n    {\n        notificationEndCallIntent = null; //Reset intent (there will be new intent at next call)\n    }\n\n    @Override\n    public int getIcon()\n    {\n        return CallAction.ICON_BUTTON_END_CALL;\n    }\n\n    public static EndCallAction get(CallModule callModule)\n    {\n        return (EndCallAction) callModule.getCallAction(END_CALL_ACTION_ID);\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/CallAction.java\npublic abstract class CallAction\n{\n    public static final int ICON_BUTTON_ANSWER = 0;\n    public static final int ICON_BUTTON_END_CALL = 1;\n    public static final int ICON_BUTTON_MIC_ON = 2;\n    public static final int ICON_BUTTON_MIC_OFF = 3;\n    public static final int ICON_BUTTON_SPEKAER_ON = 4;\n    public static final int ICON_BUTTON_SPEAKER_OFF = 5;\n    public static final int ICON_BUTTON_VOLUME_DOWN = 6;\n    public static final int ICON_BUTTON_VOLUME_UP = 7;\n    public static final int ICON_BLANK = 0xFF;\n\n    private CallModule callModule;\n\n    public CallAction(CallModule callModule)\n    {\n        this.callModule = callModule;\n    }\n\n    public CallModule getCallModule()\n    {\n        return callModule;\n    }\n\n    public void onPhoneOffhook()\n    {\n\n    }\n\n    public void onCallRinging()\n    {\n\n    }\n\n    public void onCallEnd()\n    {\n\n    }\n\n    public abstract void executeAction();\n    public abstract int getIcon();\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/ToggleRingerAction.java\npublic class ToggleRingerAction extends CallAction\n{\n    public static final int TOGGLE_RINGER_ACTION_ID = 2;\n\n    private boolean isMutedViaAudioManager = false;\n    private int prevRingerMode = AudioManager.RINGER_MODE_NORMAL;\n\n    public ToggleRingerAction(CallModule callModule)\n    {\n        super(callModule);\n    }\n\n    @Override\n    public void executeAction()\n    {\n        if (getCallModule().getCallState() != CallModule.CallState.RINGING)\n            return;\n\n        AudioManager audioManager = (AudioManager) getCallModule().getService().getSystemService(Context.AUDIO_SERVICE);\n\n        getCallModule().setVibration(false);\n\n        if (!isMutedViaAudioManager)\n        {\n            if (getCallModule().getService().getGlobalSettings().getBoolean(\"rootMode\", false))\n            {\n                Timber.d(\"Muting using root method...\");\n                try {\n                    Runtime.getRuntime().exec(new String[] {\"su\", \"-c\", \"input keyevent \" + KeyEvent.KEYCODE_VOLUME_DOWN});\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n\n            }\n            else if (canMuteRinger(getCallModule().getService()))\n            {\n                isMutedViaAudioManager = true;\n                prevRingerMode = audioManager.getRingerMode();\n\n                audioManager.setStreamSolo(AudioManager.STREAM_MUSIC, true);\n                audioManager.setRingerMode(AudioManager.RINGER_MODE_SILENT);\n            }\n        }\n        else if (canMuteRinger(getCallModule().getService()))\n        {\n            isMutedViaAudioManager = false;\n            audioManager.setStreamSolo(AudioManager.STREAM_MUSIC, false);\n            audioManager.setRingerMode(prevRingerMode);\n        }\n\n        getCallModule().updatePebble();\n    }\n\n    public void mute()\n    {\n        if (!isMutedViaAudioManager)\n            executeAction();\n    }\n\n    public static boolean canMuteRinger(Context context)\n    {\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M)\n            return true;\n\n        NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n        return notificationManager.isNotificationPolicyAccessGranted();\n    }\n\n    @Override\n    public void onCallEnd()\n    {        if (isMutedViaAudioManager && canMuteRinger(getCallModule().getService()))\n        {\n            AudioManager audioManager = (AudioManager) getCallModule().getService().getSystemService(Context.AUDIO_SERVICE);\n            isMutedViaAudioManager = false;\n            audioManager.setStreamSolo(AudioManager.STREAM_MUSIC, false);\n            audioManager.setRingerMode(prevRingerMode);\n        }\n\n        getCallModule().setVibration(true);\n    }\n\n    @Override\n    public int getIcon()\n    {\n        return isMutedViaAudioManager ? CallAction.ICON_BUTTON_SPEAKER_OFF : CallAction.ICON_BUTTON_SPEKAER_ON;\n    }\n\n    public static ToggleRingerAction get(CallModule callModule)\n    {\n        return (ToggleRingerAction) callModule.getCallAction(TOGGLE_RINGER_ACTION_ID);\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/DummyAction.java\npublic class DummyAction extends CallAction\n{\n    public static final int DUMMY_ACTION_ID = 999;\n\n\n    public DummyAction(CallModule callModule)\n    {\n        super(callModule);\n\n    }\n\n    @Override\n    public void executeAction()\n    {\n    }\n\n    @Override\n    public int getIcon()\n    {\n        return CallAction.ICON_BLANK;\n    }\n\n    public static DummyAction get(CallModule callModule)\n    {\n        return (DummyAction) callModule.getCallAction(DUMMY_ACTION_ID);\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/AnswerCallAction.java\npublic class AnswerCallAction extends CallAction\n{\n    public static final int ANSWER_ACTION_ID = 0;\n\n    private PendingIntent notificationAnswerIntent;\n\n    public AnswerCallAction(CallModule callModule)\n    {\n        super(callModule);\n    }\n\n    public void registerNotificationAnswerIntent(PendingIntent notificationAnswerIntent)\n    {\n        this.notificationAnswerIntent = notificationAnswerIntent;\n    }\n\n    @Override\n    public void executeAction()\n    {\n        if (getCallModule().getCallState() != CallModule.CallState.RINGING)\n            return;\n\n        if (getCallModule().getService().getGlobalSettings().getBoolean(\"rootMode\", false))\n        {\n            Timber.d(\"Answering using root method...\");\n            try {\n                Runtime.getRuntime().exec(new String[] {\"su\", \"-c\", \"input keyevent 5\"});\n                return;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n        if (notificationAnswerIntent != null)\n        {\n            Timber.d(\"Answering using notification method...\");\n\n            try {\n                notificationAnswerIntent.send();\n                return;\n            } catch (PendingIntent.CanceledException e) {\n            }\n        }\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)\n        {\n            answerNativelyOreo();\n        }\n        else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n        {\n            answerUsingMediaServer();\n        }\n        else\n        {\n            Timber.d(\"Answering using generic headset hook method...\");\n            Intent buttonUp = new Intent(Intent.ACTION_MEDIA_BUTTON);\n            buttonUp.putExtra(Intent.EXTRA_KEY_EVENT, new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_HEADSETHOOK));\n            getCallModule().getService().sendOrderedBroadcast(buttonUp, \"android.permission.CALL_PRIVILEGED\");\n        }\n\n    }\n\n    @TargetApi(Build.VERSION_CODES.O)\n    private void answerNativelyOreo() {\n        TelecomManager telecomManager\n                = (TelecomManager) getCallModule().getService().getSystemService(Context.TELECOM_SERVICE);\n\n        Timber.d(\"Answering natively with Oreo.\");\n\n        try {\n            telecomManager.acceptRingingCall();\n        } catch (SecurityException e) {\n            Timber.e(\"No accept call permission!\");\n        }\n    }\n\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP)\n    private void answerUsingMediaServer()\n    {\n        Timber.d(\"Answering using media server method...\");\n\n        MediaSessionManager mediaSessionManager =  (MediaSessionManager) getCallModule().getService().getSystemService(Context.MEDIA_SESSION_SERVICE);\n\n        try {\n            List<MediaController> mediaControllerList = mediaSessionManager.getActiveSessions\n                    (new ComponentName(getCallModule().getService(), JellybeanNotificationListener.class));\n\n            for (MediaController m : mediaControllerList) {\n                if (\"com.android.server.telecom\".equals(m.getPackageName())) {\n                    Timber.d(\"Found telephony media controller!\");\n                    m.dispatchMediaButtonEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_HEADSETHOOK));\n                    break;\n                }\n            }\n        } catch (SecurityException e) {\n            Timber.e(\"Notification service not running!\");\n        }\n    }\n\n    @Override\n    public void onCallEnd()\n    {\n        notificationAnswerIntent = null; //Reset intent (there will be new intent at next call)\n    }\n\n    @Override\n    public int getIcon()\n    {\n        return CallAction.ICON_BUTTON_ANSWER;\n    }\n\n    public static AnswerCallAction get(CallModule callModule)\n    {\n        return (AnswerCallAction) callModule.getCallAction(ANSWER_ACTION_ID);\n    }\n}\napp/src/main/java/com/matejdro/pebbledialer/callactions/ToggleSpeakerAction.java\npublic class ToggleSpeakerAction extends CallAction\n{\n    public static final int TOGGLE_SPEAKER_ACTION_ID = 4;\n\n    private boolean speakerphoneEnabled = false;\n\n    public ToggleSpeakerAction(CallModule callModule)\n    {\n        super(callModule);\n    }\n\n    @Override\n    public void executeAction()\n    {\n        if (getCallModule().getCallState() != CallModule.CallState.ESTABLISHED)\n            return;\n\n        AudioManager audioManager = (AudioManager) getCallModule().getService().getSystemService(Context.AUDIO_SERVICE);\n\n        speakerphoneEnabled = !speakerphoneEnabled;\n        audioManager.setSpeakerphoneOn(speakerphoneEnabled);\n\n        getCallModule().updatePebble();\n    }\n\n    public boolean isSpeakerphoneEnabled()\n    {\n        return speakerphoneEnabled;\n    }\n\n    private void updateSpeakerphoneEnabled()\n    {\n        AudioManager audioManager = (AudioManager) getCallModule().getService().getSystemService(Context.AUDIO_SERVICE);\n        speakerphoneEnabled = audioManager.isSpeakerphoneOn();\n    }\n\n    @Override\n    public void onPhoneOffhook()\n    {\n        updateSpeakerphoneEnabled();\n    }\n\n    @Override\n    public int getIcon()\n    {\n        return speakerphoneEnabled ? ICON_BUTTON_SPEKAER_ON : ICON_BUTTON_SPEAKER_OFF;\n    }\n\n    public static ToggleSpeakerAction get(CallModule callModule)\n    {\n        return (ToggleSpeakerAction) callModule.getCallAction(TOGGLE_SPEAKER_ACTION_ID);\n    }\n}\n", "answers": ["        registerCallAction(new VolumeUpAction(this), VolumeUpAction.VOLUME_UP_ACTION_ID);"], "length": 1561, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "540e570d6c2fc76fbe07ffed28b8a4e856ede57ac633d5f7"}
{"input": "package me.bakumon.ugank.module.search;\nimport android.content.pm.ActivityInfo;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.support.design.widget.AppBarLayout;\nimport android.support.v4.widget.SwipeRefreshLayout;\nimport android.support.v7.widget.AppCompatEditText;\nimport android.support.v7.widget.AppCompatImageView;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.Toolbar;\nimport android.text.Editable;\nimport android.text.TextWatcher;\nimport android.view.KeyEvent;\nimport android.view.View;\nimport android.view.inputmethod.EditorInfo;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\nimport com.google.android.flexbox.FlexboxLayoutManager;\nimport com.luolc.emojirain.EmojiRainLayout;\nimport java.util.List;\nimport butterknife.BindView;\nimport butterknife.ButterKnife;\nimport butterknife.OnClick;\nimport es.dmoral.toasty.Toasty;\nimport me.bakumon.ugank.R;\nimport me.bakumon.ugank.base.SwipeBackBaseActivity;\nimport me.bakumon.ugank.entity.History;\nimport me.bakumon.ugank.entity.SearchResult;\nimport me.bakumon.ugank.utills.DisplayUtils;\nimport me.bakumon.ugank.utills.KeyboardUtils;\nimport me.bakumon.ugank.utills.MDTintUtil;\nimport me.bakumon.ugank.utills.StatusBarUtil;\nimport me.bakumon.ugank.widget.RecycleViewDivider;\nimport me.bakumon.ugank.widget.recyclerviewwithfooter.OnLoadMoreListener;\nimport me.bakumon.ugank.widget.recyclerviewwithfooter.RecyclerViewWithFooter;\n\n\n\n\n\npublic class SearchActivity extends SwipeBackBaseActivity implements SearchContract.View, TextWatcher, TextView.OnEditorActionListener, OnLoadMoreListener, HistoryListAdapter.OnItemClickListener {\n\n    @BindView(R.id.toolbar_search)\n    Toolbar mToolbarSearch;\n    @BindView(R.id.ed_search)\n    AppCompatEditText mEdSearch;\n    @BindView(R.id.iv_edit_clear)\n    AppCompatImageView mIvEditClear;\n    @BindView(R.id.iv_search)\n    AppCompatImageView mIvSearch;\n    @BindView(R.id.appbar_search)\n    AppBarLayout mAppbarSearch;\n    @BindView(R.id.recycler_view_search)\n    RecyclerViewWithFooter mRecyclerViewSearch;\n    @BindView(R.id.swipe_refresh_layout_search)\n    SwipeRefreshLayout mSwipeRefreshLayoutSearch;\n    @BindView(R.id.ll_search_history)\n    LinearLayout mLlHistory;\n    @BindView(R.id.recycler_search_history)\n    RecyclerView mRecyclerViewHistory;\n    @BindView(R.id.emoji_rainLayout)\n    EmojiRainLayout mEmojiRainLayout;\n\n    private SearchContract.Presenter mSearchPresenter = new SearchPresenter(this);\n\n    private SearchListAdapter mSearchListAdapter;\n    private HistoryListAdapter mHistoryListAdapter;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n        setContentView(R.layout.activity_search);\n        ButterKnife.bind(this);\n        initView();\n        mSearchPresenter.subscribe();\n        mSearchPresenter.queryHistory();\n    }\n\n    private void initView() {\n", "context": "app/src/main/java/me/bakumon/ugank/entity/History.java\npublic class History extends DataSupport {\n    private long createTimeMill;\n    private String content;\n\n    public long getCreateTimeMill() {\n        return createTimeMill;\n    }\n\n    public void setCreateTimeMill(long createTimeMill) {\n        this.createTimeMill = createTimeMill;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n}\napp/src/main/java/me/bakumon/ugank/utills/KeyboardUtils.java\npublic class KeyboardUtils {\n    /**\n     * 动态隐藏软键盘\n     *\n     * @param activity activity\n     */\n    public static void hideSoftInput(Activity activity) {\n        View view = activity.getCurrentFocus();\n        if (view == null) view = new View(activity);\n        InputMethodManager imm = (InputMethodManager) activity.getSystemService(Activity.INPUT_METHOD_SERVICE);\n        imm.hideSoftInputFromWindow(view.getWindowToken(), 0);\n    }\n\n    /**\n     * 动态显示软键盘\n     *\n     * @param edit 输入框\n     */\n    public static void showSoftInput(Context context, EditText edit) {\n        edit.setFocusable(true);\n        edit.setFocusableInTouchMode(true);\n        edit.requestFocus();\n        InputMethodManager imm = (InputMethodManager) context\n                .getSystemService(Context.INPUT_METHOD_SERVICE);\n        imm.showSoftInput(edit, 0);\n    }\n}\napp/src/main/java/me/bakumon/ugank/widget/recyclerviewwithfooter/RecyclerViewWithFooter.java\npublic class RecyclerViewWithFooter extends RecyclerView {\n\n    private static final String TAG = \"RecyclerViewWithFooter\";\n\n    public static final int STATE_END = 0;\n    public static final int STATE_LOADING = 1;\n    public static final int STATE_EMPTY = 2;\n    public static final int STATE_NONE = 3;\n    public static final int STATE_PULL_TO_LOAD = 4;\n\n    private boolean mIsGetDataForNet = false;\n\n    @State\n    private int mState = STATE_NONE;\n\n    /**\n     * 默认的 FootItem;\n     */\n    private FootItem mFootItem = new DefaultFootItem();\n    private EmptyItem mEmptyItem = new DefaultEmptyItem();\n\n    private AdapterDataObserver mAdapterDataObserver = new AdapterDataObserver() {\n\n        @Override\n        public void onChanged() {\n            super.onChanged();\n            reset();\n        }\n\n        private void reset() {\n            mIsGetDataForNet = false;\n        }\n\n        @Override\n        public void onItemRangeChanged(int positionStart, int itemCount) {\n            super.onItemRangeChanged(positionStart, itemCount);\n            reset();\n\n        }\n\n        @Override\n        public void onItemRangeChanged(int positionStart, int itemCount, Object payload) {\n            super.onItemRangeChanged(positionStart, itemCount, payload);\n            reset();\n\n        }\n\n        @Override\n        public void onItemRangeInserted(int positionStart, int itemCount) {\n            super.onItemRangeInserted(positionStart, itemCount);\n            reset();\n\n        }\n\n        @Override\n        public void onItemRangeRemoved(int positionStart, int itemCount) {\n            super.onItemRangeRemoved(positionStart, itemCount);\n            reset();\n        }\n\n        @Override\n        public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) {\n            super.onItemRangeMoved(fromPosition, toPosition, itemCount);\n            reset();\n        }\n    };\n\n    public RecyclerViewWithFooter(Context context) {\n        super(context);\n        init();\n    }\n\n    public RecyclerViewWithFooter(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public RecyclerViewWithFooter(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init();\n    }\n\n    private void init() {\n        setVerticalLinearLayout();\n    }\n\n    public void setVerticalLinearLayout() {\n        RecyclerViewUtils.setVerticalLinearLayout(this);\n    }\n\n    public void setGridLayout(int span) {\n        RecyclerViewUtils.setGridLayout(this, span);\n    }\n\n    public void setStaggeredGridLayoutManager(int spanCount) {\n        RecyclerViewUtils.setStaggeredGridLayoutManager(this, spanCount);\n    }\n\n    public void setOnLoadMoreListener(OnLoadMoreListener onLoadMoreListener) {\n        mState = STATE_PULL_TO_LOAD;\n\n        final OnLoadMoreListenerWrapper wrapper = new OnLoadMoreListenerWrapper(onLoadMoreListener);\n\n        addOnScrollListener(new RecyclerView.OnScrollListener() {\n            @Override\n            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {\n                super.onScrollStateChanged(recyclerView, newState);\n                if (newState == RecyclerView.SCROLL_STATE_IDLE) {\n                    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();\n                    if (layoutManager instanceof LinearLayoutManager) {\n                        int lastVisiblePosition = ((LinearLayoutManager) layoutManager).findLastVisibleItemPosition();\n                        if (lastVisiblePosition >= recyclerView.getAdapter().getItemCount() - 1) {\n                            if (mState == STATE_PULL_TO_LOAD) {\n                                setLoading();\n                            }\n                            wrapper.onLoadMore();\n                        }\n                    } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n                        StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager) layoutManager;\n                        int last[] = new int[staggeredGridLayoutManager.getSpanCount()];\n                        staggeredGridLayoutManager.findLastVisibleItemPositions(last);\n\n                        for (int aLast : last) {\n                            Log.i(TAG, aLast + \"    \" + recyclerView.getAdapter().getItemCount());\n                            if (aLast >= recyclerView.getAdapter().getItemCount() - 1) {\n                                if (mState == STATE_PULL_TO_LOAD) {\n                                    setLoading();\n                                }\n                                wrapper.onLoadMore();\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    public void setAdapter(Adapter adapter) {\n        LoadMoreAdapter loadMoreAdapter;\n        if (adapter instanceof LoadMoreAdapter) {\n            loadMoreAdapter = (LoadMoreAdapter) adapter;\n            loadMoreAdapter.registerAdapterDataObserver(mAdapterDataObserver);\n            super.setAdapter(adapter);\n        } else {\n            loadMoreAdapter = new LoadMoreAdapter(adapter);\n            loadMoreAdapter.registerAdapterDataObserver(mAdapterDataObserver);\n            super.setAdapter(loadMoreAdapter);\n        }\n    }\n\n    /**\n     * 设置loading提示字符串\n     *\n     * @param loadText 提示字符串\n     * @return {@link RecyclerViewWithFooter}\n     */\n    public RecyclerViewWithFooter applyLoadingText(CharSequence loadText) {\n        mFootItem.loadingText = loadText;\n        return this;\n    }\n\n    public RecyclerViewWithFooter applyPullToLoadText(CharSequence pullToLoadText) {\n        mFootItem.pullToLoadText = pullToLoadText;\n        return this;\n    }\n\n    public RecyclerViewWithFooter applyEndText(CharSequence endText) {\n        mFootItem.endText = endText;\n        return this;\n    }\n\n    public RecyclerViewWithFooter applyEmptyText(CharSequence emptyText, @DrawableRes int drawableId) {\n        mEmptyItem.mEmptyIconRes = drawableId;\n        mEmptyItem.mEmptyText = emptyText;\n        return this;\n    }\n\n    public void setFootItem(FootItem footItem) {\n        if (mFootItem != null) {\n            if (footItem.endText == null) {\n                footItem.endText = mFootItem.endText;\n            }\n            if (footItem.loadingText == null) {\n                footItem.loadingText = mFootItem.loadingText;\n            }\n            if (footItem.pullToLoadText == null) {\n                footItem.pullToLoadText = mFootItem.pullToLoadText;\n            }\n        }\n        mFootItem = footItem;\n    }\n\n    public void setEmptyItem(EmptyItem emptyItem) {\n        if (mEmptyItem != null) {\n            if (emptyItem.mEmptyIconRes == -1) {\n                emptyItem.mEmptyIconRes = mEmptyItem.mEmptyIconRes;\n            }\n            if (emptyItem.mEmptyText == null) {\n                emptyItem.mEmptyText = mEmptyItem.mEmptyText;\n            }\n        }\n        mEmptyItem = emptyItem;\n    }\n\n    /**\n     * 切换为loading状态\n     */\n    public void setLoading() {\n        if (getAdapter() != null) {\n            mState = STATE_LOADING;\n            mIsGetDataForNet = false;\n            getAdapter().notifyItemChanged(getAdapter().getItemCount() - 1);\n        }\n    }\n\n    /**\n     * 切换为没有更多数据状态\n     *\n     * @param end 提示字符串\n     */\n    public void setEnd(CharSequence end) {\n        if (getAdapter() != null) {\n            mIsGetDataForNet = false;\n            mState = STATE_END;\n            mFootItem.endText = end;\n            getAdapter().notifyItemChanged(getAdapter().getItemCount() - 1);\n        }\n    }\n\n    /**\n     * 切换为没有更多数据状态\n     */\n    public void setEnd() {\n        if (getAdapter() != null) {\n            mIsGetDataForNet = false;\n            mState = STATE_END;\n            getAdapter().notifyItemChanged(getAdapter().getItemCount() - 1);\n        }\n    }\n\n    /**\n     * 切换成无数据状态\n     *\n     * @param empty 无数据状态提示消息\n     * @param resId 无数据状态提示图标\n     */\n    public void setEmpty(CharSequence empty, @DrawableRes int resId) {\n        if (getAdapter() != null) {\n            mState = STATE_EMPTY;\n            mEmptyItem.mEmptyText = empty;\n            mEmptyItem.mEmptyIconRes = resId;\n            if (isEmpty()) {\n                getAdapter().notifyDataSetChanged();\n            }\n        }\n    }\n\n    /**\n     * 切换成无数据状态\n     */\n    public void setEmpty() {\n        if (getAdapter() != null) {\n            mState = STATE_EMPTY;\n            if (isEmpty()) {\n                getAdapter().notifyDataSetChanged();\n            }\n        }\n    }\n\n    /**\n     * 数据是否为空\n     */\n    private boolean isEmpty() {\n        return (mState == STATE_NONE && getAdapter().getItemCount() == 0) ||\n                (mState != STATE_NONE && getAdapter().getItemCount() == 1);\n    }\n\n    public boolean isLoadMoreEnable() {\n        return mState != STATE_LOADING;\n    }\n\n    @IntDef({STATE_END, STATE_LOADING, STATE_EMPTY, STATE_NONE, STATE_PULL_TO_LOAD})\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface State {\n    }\n\n    private class OnLoadMoreListenerWrapper implements OnLoadMoreListener {\n\n        private OnLoadMoreListener mOnLoadMoreListener;\n\n        public OnLoadMoreListenerWrapper(OnLoadMoreListener onLoadMoreListener) {\n            mOnLoadMoreListener = onLoadMoreListener;\n        }\n\n        @Override\n        public void onLoadMore() {\n            if (!mIsGetDataForNet && !isLoadMoreEnable()) {\n                mIsGetDataForNet = true;\n                mOnLoadMoreListener.onLoadMore();\n            }\n        }\n    }\n\n    public class LoadMoreAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\n\n        public static final int LOAD_MORE_VIEW_TYPE = -404;\n        public static final int EMPTY_VIEW_TYPE = -403;\n\n        public RecyclerView.Adapter mAdapter;\n\n        public LoadMoreAdapter(Adapter adapter) {\n            mAdapter = adapter;\n        }\n\n        @Override\n        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n            if (viewType == LOAD_MORE_VIEW_TYPE) {\n                return new LoadMoreVH();\n            } else if (viewType == EMPTY_VIEW_TYPE) {\n                return new EmptyVH();\n            }\n            return mAdapter.onCreateViewHolder(parent, viewType);\n        }\n\n        @Override\n        public void registerAdapterDataObserver(AdapterDataObserver observer) {\n            super.registerAdapterDataObserver(observer);\n            mAdapter.registerAdapterDataObserver(observer);\n\n        }\n\n        @Override\n        public void unregisterAdapterDataObserver(AdapterDataObserver observer) {\n            super.unregisterAdapterDataObserver(observer);\n            mAdapter.unregisterAdapterDataObserver(observer);\n        }\n\n        @Override\n        public void onBindViewHolder(ViewHolder holder, int position) {\n            if (!isFootView(position)) {\n                mAdapter.onBindViewHolder(holder, position);\n            } else {\n                if (getLayoutManager() instanceof StaggeredGridLayoutManager) {\n                    ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();\n                    if (layoutParams instanceof StaggeredGridLayoutManager.LayoutParams) {\n                        ((StaggeredGridLayoutManager.LayoutParams) layoutParams).setFullSpan(true);\n                    }\n                } else if (getLayoutManager() instanceof GridLayoutManager) {\n                    final GridLayoutManager layoutManager = (GridLayoutManager) getLayoutManager();\n                    layoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {\n                        @Override\n                        public int getSpanSize(int position) {\n                            int viewType = getAdapter().getItemViewType(position);\n                            if (viewType < 0) {\n                                return layoutManager.getSpanCount();\n                            }\n                            return 1;\n                        }\n                    });\n                }\n                if (holder instanceof VH) {\n                    ((VH) holder).onBindViewHolder();\n                }\n            }\n        }\n\n        private boolean isFootView(int position) {\n            return position == getItemCount() - 1 && mState != STATE_NONE;\n        }\n\n        @Override\n        public int getItemViewType(int position) {\n            if (!isFootView(position)) {\n                return mAdapter.getItemViewType(position);\n            } else {\n                if (mState == STATE_EMPTY && getItemCount() == 1) {\n                    return EMPTY_VIEW_TYPE;\n                } else {\n                    return LOAD_MORE_VIEW_TYPE;\n                }\n            }\n        }\n\n        @Override\n        public int getItemCount() {\n            if (mState == STATE_NONE) {\n                return mAdapter.getItemCount();\n            } else {\n                return mAdapter.getItemCount() + 1;\n            }\n        }\n\n        /**\n         * 加载更多的ViewHolder\n         */\n        private class LoadMoreVH extends VH {\n\n            private View mItemView;\n\n            public LoadMoreVH() {\n                super(mFootItem.onCreateView(RecyclerViewWithFooter.this));\n                mItemView = itemView;\n            }\n\n            @Override\n            public void onBindViewHolder() {\n                super.onBindViewHolder();\n                if (mState == STATE_LOADING || mState == STATE_END || mState == STATE_PULL_TO_LOAD) {\n                    mFootItem.onBindData(mItemView, mState);\n                }\n            }\n        }\n\n        /**\n         * 数据为空时的ViewHolder\n         */\n        private class EmptyVH extends VH {\n\n            public EmptyVH() {\n                super(mEmptyItem.onCreateView(RecyclerViewWithFooter.this));\n            }\n\n            @Override\n            public void onBindViewHolder() {\n                super.onBindViewHolder();\n                mEmptyItem.onBindData(itemView);\n            }\n        }\n\n        class VH extends RecyclerView.ViewHolder {\n\n            public VH(View itemView) {\n                super(itemView);\n            }\n\n            public void onBindViewHolder() {\n\n            }\n        }\n    }\n}\napp/src/main/java/me/bakumon/ugank/utills/DisplayUtils.java\npublic class DisplayUtils {\n    private static DisplayMetrics getMetrics(Context context) {\n        DisplayMetrics metrics = new DisplayMetrics();\n\n        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        wm.getDefaultDisplay().getMetrics(metrics);\n        return metrics;\n    }\n\n    /**\n     * dp 转 px\n     */\n    public static int dp2px(float dp, Context context) {\n        DisplayMetrics metrics = getMetrics(context);\n        return (int) (dp * (metrics.densityDpi / 160f));\n    }\n\n    /**\n     * pxe 转 dp\n     */\n    public static float px2dp(float px, Context context) {\n        DisplayMetrics metrics = getMetrics(context);\n        return px / (metrics.densityDpi / 160f);\n    }\n\n    /**\n     * 获取屏幕宽度 px\n     */\n    public static int getScreenWidth(Context context) {\n        DisplayMetrics dm = getMetrics(context);\n        return dm.widthPixels;\n    }\n\n    /**\n     * 获取屏幕高度 px\n     */\n    public static int getScreenHeight(Context context) {\n        DisplayMetrics dm = getMetrics(context);\n        return dm.heightPixels;\n    }\n\n    /**\n     * 获取状态栏高度\n     */\n    public static int getStatusBarHeight(Context context) {\n        int result = 38;\n        int resourceId = context.getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\");\n        if (resourceId > 0) {\n            result = context.getResources().getDimensionPixelSize(resourceId);\n        }\n        return result;\n    }\n}\napp/src/main/java/me/bakumon/ugank/widget/recyclerviewwithfooter/OnLoadMoreListener.java\npublic interface OnLoadMoreListener {\n    void onLoadMore();\n}\napp/src/main/java/me/bakumon/ugank/widget/RecycleViewDivider.java\npublic class RecycleViewDivider extends RecyclerView.ItemDecoration {\n    private Drawable mDivider;\n    private int mDividerHeight = 2;//分割线高度，默认为1px\n    private int mOrientation;//列表的方向：LinearLayoutManager.VERTICAL或LinearLayoutManager.HORIZONTAL\n    private static final int[] ATTRS = new int[]{android.R.attr.listDivider};\n\n    /**\n     * 默认分割线：高度为2px，颜色为灰色\n     *\n     * @param context     上下文\n     * @param orientation 列表方向\n     */\n    public RecycleViewDivider(Context context, int orientation) {\n        if (orientation != LinearLayoutManager.VERTICAL && orientation != LinearLayoutManager.HORIZONTAL) {\n            throw new IllegalArgumentException(\"请输入正确的参数！LinearLayoutManager.VERTICAL or LinearLayoutManager.HORIZONTAL\");\n        }\n        mOrientation = orientation;\n\n        final TypedArray a = context.obtainStyledAttributes(ATTRS);\n        mDivider = a.getDrawable(0);\n        a.recycle();\n    }\n\n    //获取分割线尺寸\n    @Override\n    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {\n        super.getItemOffsets(outRect, view, parent, state);\n        outRect.set(0, 0, 0, mDividerHeight);\n    }\n\n    //绘制分割线\n    @Override\n    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {\n        super.onDraw(c, parent, state);\n        if (mOrientation == LinearLayoutManager.VERTICAL) {\n            drawVertical(c, parent);\n        } else {\n            drawHorizontal(c, parent);\n        }\n    }\n\n    //绘制横向 item 分割线\n    private void drawHorizontal(Canvas canvas, RecyclerView parent) {\n        final int left = parent.getPaddingLeft();\n        final int right = parent.getMeasuredWidth() - parent.getPaddingRight();\n        final int childSize = parent.getChildCount();\n        for (int i = 0; i < childSize; i++) {\n            final View child = parent.getChildAt(i);\n            RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams();\n            final int top = child.getBottom() + layoutParams.bottomMargin;\n            final int bottom = top + mDividerHeight;\n            if (mDivider != null) {\n                mDivider.setBounds(left, top, right, bottom);\n                mDivider.draw(canvas);\n            }\n        }\n    }\n\n    //绘制纵向 item 分割线\n    private void drawVertical(Canvas canvas, RecyclerView parent) {\n        final int top = parent.getPaddingTop();\n        final int bottom = parent.getMeasuredHeight() - parent.getPaddingBottom();\n        final int childSize = parent.getChildCount();\n        for (int i = 0; i < childSize; i++) {\n            final View child = parent.getChildAt(i);\n            RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams();\n            final int left = child.getRight() + layoutParams.rightMargin;\n            final int right = left + mDividerHeight;\n            if (mDivider != null) {\n                mDivider.setBounds(left, top, right, bottom);\n                mDivider.draw(canvas);\n            }\n        }\n    }\n}\napp/src/main/java/me/bakumon/ugank/utills/StatusBarUtil.java\n@SuppressWarnings(\"unused\")\npublic class StatusBarUtil {\n    public static int DEFAULT_COLOR = 0;\n    public static float DEFAULT_ALPHA = 0;//Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP ? 0.2f : 0.3f;\n\n    //<editor-fold desc=\"沉侵\">\n    public static void immersive(Activity activity) {\n        immersive(activity, DEFAULT_COLOR, DEFAULT_ALPHA);\n    }\n\n    public static void immersive(Activity activity, int color, @FloatRange(from = 0.0, to = 1.0) float alpha) {\n        immersive(activity.getWindow(), color, alpha);\n    }\n\n    public static void immersive(Activity activity, int color) {\n        immersive(activity.getWindow(), color, 1f);\n    }\n\n    public static void immersive(Window window) {\n        immersive(window, DEFAULT_COLOR, DEFAULT_ALPHA);\n    }\n\n    public static void immersive(Window window, int color) {\n        immersive(window, color, 1f);\n    }\n\n    public static void immersive(Window window, int color, @FloatRange(from = 0.0, to = 1.0) float alpha) {\n        if (Build.VERSION.SDK_INT >= 21) {\n            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\n            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n            window.setStatusBarColor(mixtureColor(color, alpha));\n\n            int systemUiVisibility = window.getDecorView().getSystemUiVisibility();\n            systemUiVisibility |= View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;\n            systemUiVisibility |= View.SYSTEM_UI_FLAG_LAYOUT_STABLE;\n            window.getDecorView().setSystemUiVisibility(systemUiVisibility);\n        } else if (Build.VERSION.SDK_INT >= 19) {\n            window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\n            setTranslucentView((ViewGroup) window.getDecorView(), color, alpha);\n        } else if (Build.VERSION.SDK_INT >= 16) {\n            int systemUiVisibility = window.getDecorView().getSystemUiVisibility();\n            systemUiVisibility |= View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;\n            systemUiVisibility |= View.SYSTEM_UI_FLAG_LAYOUT_STABLE;\n            window.getDecorView().setSystemUiVisibility(systemUiVisibility);\n        }\n    }\n    //</editor-fold>\n\n    //<editor-fold desc=\"DarkMode\">\n    public static void darkMode(Activity activity, boolean dark) {\n        if (isFlyme4Later()) {\n            darkModeForFlyme4(activity.getWindow(), dark);\n        } else if (isMIUI6Later()) {\n            darkModeForMIUI6(activity.getWindow(), dark);\n        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            darkModeForM(activity.getWindow(), dark);\n        }\n    }\n\n    /** 设置状态栏darkMode,字体颜色及icon变黑(目前支持MIUI6以上,Flyme4以上,Android M以上) */\n    public static void darkMode(Activity activity) {\n        darkMode(activity.getWindow(), DEFAULT_COLOR, DEFAULT_ALPHA);\n    }\n\n    public static void darkMode(Activity activity, int color, @FloatRange(from = 0.0, to = 1.0) float alpha) {\n        darkMode(activity.getWindow(), color, alpha);\n    }\n\n    /** 设置状态栏darkMode,字体颜色及icon变黑(目前支持MIUI6以上,Flyme4以上,Android M以上) */\n    public static void darkMode(Window window, int color, @FloatRange(from = 0.0, to = 1.0) float alpha) {\n        if (isFlyme4Later()) {\n            immersive(window,color,alpha);\n            darkModeForFlyme4(window, true);\n        } else if (isMIUI6Later()) {\n            immersive(window,color,alpha);\n            darkModeForMIUI6(window, true);\n        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            immersive(window, color, alpha);\n            darkModeForM(window, true);\n        } else if (Build.VERSION.SDK_INT >= 19) {\n            window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\n            setTranslucentView((ViewGroup) window.getDecorView(), color, alpha);\n        }\n//        if (Build.VERSION.SDK_INT >= 21) {\n//            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\n//            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n//            window.setStatusBarColor(Color.TRANSPARENT);\n//        } else if (Build.VERSION.SDK_INT >= 19) {\n//            window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\n//        }\n\n//        setTranslucentView((ViewGroup) window.getDecorView(), color, alpha);\n    }\n\n    //------------------------->\n\n    /** android 6.0设置字体颜色 */\n    private static void darkModeForM(Window window, boolean dark) {\n//        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\n//        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n//        window.setStatusBarColor(Color.TRANSPARENT);\n\n        int systemUiVisibility = window.getDecorView().getSystemUiVisibility();\n        if (dark) {\n            systemUiVisibility |= View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;\n        } else {\n            systemUiVisibility &= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;\n        }\n        window.getDecorView().setSystemUiVisibility(systemUiVisibility);\n    }\n\n    /**\n     * 设置Flyme4+的darkMode,darkMode时候字体颜色及icon变黑\n     * http://open-wiki.flyme.cn/index.php?title=Flyme%E7%B3%BB%E7%BB%9FAPI\n     */\n    public static boolean darkModeForFlyme4(Window window, boolean dark) {\n        boolean result = false;\n        if (window != null) {\n            try {\n                WindowManager.LayoutParams lp = window.getAttributes();\n                Field darkFlag = WindowManager.LayoutParams.class\n                        .getDeclaredField(\"MEIZU_FLAG_DARK_STATUS_BAR_ICON\");\n                Field meizuFlags = WindowManager.LayoutParams.class\n                        .getDeclaredField(\"meizuFlags\");\n                darkFlag.setAccessible(true);\n                meizuFlags.setAccessible(true);\n                int bit = darkFlag.getInt(null);\n                int value = meizuFlags.getInt(lp);\n                if (dark) {\n                    value |= bit;\n                } else {\n                    value &= ~bit;\n                }\n                meizuFlags.setInt(lp, value);\n                window.setAttributes(lp);\n                result = true;\n            } catch (Exception var8) {\n                Log.e(\"StatusBar\", \"darkIcon: failed\");\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * 设置MIUI6+的状态栏是否为darkMode,darkMode时候字体颜色及icon变黑\n     * http://dev.xiaomi.com/doc/p=4769/\n     */\n    public static boolean darkModeForMIUI6(Window window, boolean darkmode) {\n        Class<? extends Window> clazz = window.getClass();\n        try {\n            int darkModeFlag = 0;\n            Class<?> layoutParams = Class.forName(\"android.view.MiuiWindowManager$LayoutParams\");\n            Field field = layoutParams.getField(\"EXTRA_FLAG_STATUS_BAR_DARK_MODE\");\n            darkModeFlag = field.getInt(layoutParams);\n            Method extraFlagField = clazz.getMethod(\"setExtraFlags\", int.class, int.class);\n            extraFlagField.invoke(window, darkmode ? darkModeFlag : 0, darkModeFlag);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /** 判断是否Flyme4以上 */\n    public static boolean isFlyme4Later() {\n        return Build.FINGERPRINT.contains(\"Flyme_OS\")\n                || Build.VERSION.INCREMENTAL.contains(\"Flyme_OS\")\n                || Pattern.compile(\"Flyme OS [4|5]\", Pattern.CASE_INSENSITIVE).matcher(Build.DISPLAY).find()\n                || Pattern.compile(\"Flyme\", Pattern.CASE_INSENSITIVE).matcher(Build.DISPLAY).find()\n                || Build.FINGERPRINT.contains(\"Meizu\");\n    }\n\n    /** 判断是否为MIUI6以上 */\n    public static boolean isMIUI6Later() {\n        try {\n            Class<?> clz = Class.forName(\"android.os.SystemProperties\");\n            Method mtd = clz.getMethod(\"get\", String.class);\n            String val = (String) mtd.invoke(null, \"ro.miui.ui.version.name\");\n            val = val.replaceAll(\"[vV]\", \"\");\n            int version = Integer.parseInt(val);\n            return version >= 6;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    //</editor-fold>\n\n\n    /** 增加View的paddingTop,增加的值为状态栏高度 */\n    public static void setPadding(Context context, View view) {\n        if (Build.VERSION.SDK_INT >= 16) {\n            view.setPadding(view.getPaddingLeft(), view.getPaddingTop() + getStatusBarHeight(context),\n                    view.getPaddingRight(), view.getPaddingBottom());\n        }\n    }\n    /** 增加View的paddingTop,增加的值为状态栏高度 (智能判断，并设置高度)*/\n    public static void setPaddingSmart(Context context, View view) {\n        if (Build.VERSION.SDK_INT >= 16) {\n            ViewGroup.LayoutParams lp = view.getLayoutParams();\n            if (lp != null && lp.height > 0) {\n                lp.height += getStatusBarHeight(context);//增高\n            }\n            view.setPadding(view.getPaddingLeft(), view.getPaddingTop() + getStatusBarHeight(context),\n                    view.getPaddingRight(), view.getPaddingBottom());\n        }\n    }\n\n    /** 增加View的高度以及paddingTop,增加的值为状态栏高度.一般是在沉浸式全屏给ToolBar用的 */\n    public static void setHeightAndPadding(Context context, View view) {\n        if (Build.VERSION.SDK_INT >= 16) {\n            ViewGroup.LayoutParams lp = view.getLayoutParams();\n            lp.height += getStatusBarHeight(context);//增高\n            view.setPadding(view.getPaddingLeft(), view.getPaddingTop() + getStatusBarHeight(context),\n                    view.getPaddingRight(), view.getPaddingBottom());\n        }\n    }\n    /** 增加View上边距（MarginTop）一般是给高度为 WARP_CONTENT 的小控件用的*/\n    public static void setMargin(Context context, View view) {\n        if (Build.VERSION.SDK_INT >= 16) {\n            ViewGroup.LayoutParams lp = view.getLayoutParams();\n            if (lp instanceof ViewGroup.MarginLayoutParams) {\n                ((ViewGroup.MarginLayoutParams) lp).topMargin += getStatusBarHeight(context);//增高\n            }\n            view.setLayoutParams(lp);\n        }\n    }\n    /**\n     * 创建假的透明栏\n     */\n    public static void setTranslucentView(ViewGroup container, int color, @FloatRange(from = 0.0, to = 1.0) float alpha) {\n        if (Build.VERSION.SDK_INT >= 19) {\n            int mixtureColor = mixtureColor(color, alpha);\n            View translucentView = container.findViewById(android.R.id.custom);\n            if (translucentView == null && mixtureColor != 0) {\n                translucentView = new View(container.getContext());\n                translucentView.setId(android.R.id.custom);\n                ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(\n                        ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(container.getContext()));\n                container.addView(translucentView, lp);\n            }\n            if (translucentView != null) {\n                translucentView.setBackgroundColor(mixtureColor);\n            }\n        }\n    }\n\n    public static int mixtureColor(int color, @FloatRange(from = 0.0, to = 1.0) float alpha) {\n        int a = (color & 0xff000000) == 0 ? 0xff : color >>> 24;\n        return (color & 0x00ffffff) | (((int) (a * alpha)) << 24);\n    }\n\n    /** 获取状态栏高度 */\n    public static int getStatusBarHeight(Context context) {\n        int result = 24;\n        int resId = context.getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\");\n        if (resId > 0) {\n            result = context.getResources().getDimensionPixelSize(resId);\n        } else {\n            result = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,\n                    result, Resources.getSystem().getDisplayMetrics());\n        }\n        return result;\n    }\n}\napp/src/main/java/me/bakumon/ugank/entity/SearchResult.java\npublic class SearchResult {\n\n    public int count;\n    public boolean error;\n    public List<ResultsBean> results;\n\n    public static class ResultsBean {\n\n        public String desc;\n        public String ganhuo_id;\n        public String publishedAt;\n        public String readability;\n        public String type;\n        public String url;\n        public String who;\n    }\n}\napp/src/main/java/me/bakumon/ugank/utills/MDTintUtil.java\npublic class MDTintUtil {\n    /**\n     * 改变 EditText 游标的颜色\n     */\n    public static void setCursorTint(@NonNull EditText editText, @ColorInt int color) {\n        try {\n            Field fCursorDrawableRes = TextView.class.getDeclaredField(\"mCursorDrawableRes\");\n            fCursorDrawableRes.setAccessible(true);\n            int mCursorDrawableRes = fCursorDrawableRes.getInt(editText);\n            Field fEditor = TextView.class.getDeclaredField(\"mEditor\");\n            fEditor.setAccessible(true);\n            Object editor = fEditor.get(editText);\n            Class<?> clazz = editor.getClass();\n            Field fCursorDrawable = clazz.getDeclaredField(\"mCursorDrawable\");\n            fCursorDrawable.setAccessible(true);\n            Drawable[] drawables = new Drawable[2];\n            drawables[0] = ContextCompat.getDrawable(editText.getContext(), mCursorDrawableRes);\n            drawables[1] = ContextCompat.getDrawable(editText.getContext(), mCursorDrawableRes);\n            drawables[0].setColorFilter(color, PorterDuff.Mode.SRC_IN);\n            drawables[1].setColorFilter(color, PorterDuff.Mode.SRC_IN);\n            fCursorDrawable.set(editor, drawables);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void setTint(@NonNull FloatingActionButton floatingActionButton, @ColorInt int color) {\n        int[] colors = new int[]{color, color, color, color, color, color};\n        int[][] states = new int[6][];\n        states[0] = new int[]{android.R.attr.state_pressed, android.R.attr.state_enabled};\n        states[1] = new int[]{android.R.attr.state_enabled, android.R.attr.state_focused};\n        states[2] = new int[]{android.R.attr.state_enabled};\n        states[3] = new int[]{android.R.attr.state_focused};\n        states[4] = new int[]{android.R.attr.state_window_focused};\n        states[5] = new int[]{};\n        floatingActionButton.setBackgroundTintList(new ColorStateList(states, colors));\n    }\n\n    public static void setTint(@NonNull SwitchCompat switchCompat, @ColorInt int color) {\n        int[] colors = new int[]{color, Color.rgb(236, 236, 236), Color.rgb(236, 236, 236), Color.rgb(236, 236, 236), Color.rgb(236, 236, 236), Color.rgb(236, 236, 236)};\n        int[][] states = new int[6][];\n        states[0] = new int[]{android.R.attr.state_checked, android.R.attr.state_enabled};\n        states[1] = new int[]{android.R.attr.state_enabled, android.R.attr.state_focused};\n        states[2] = new int[]{android.R.attr.state_enabled};\n        states[3] = new int[]{android.R.attr.state_focused};\n        states[4] = new int[]{android.R.attr.state_window_focused};\n        states[5] = new int[]{};\n        switchCompat.setThumbTintList(new ColorStateList(states, colors));\n    }\n}\napp/src/main/java/me/bakumon/ugank/base/SwipeBackBaseActivity.java\npublic abstract class SwipeBackBaseActivity extends AppCompatActivity implements BGASwipeBackHelper.Delegate {\n    protected BGASwipeBackHelper mSwipeBackHelper;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        // 「必须在 Application 的 onCreate 方法中执行 BGASwipeBackManager.getInstance().init(this) 来初始化滑动返回」\n        // 在 super.onCreate(savedInstanceState) 之前调用该方法\n        initSwipeBackFinish();\n        super.onCreate(savedInstanceState);\n    }\n\n    /**\n     * 初始化滑动返回。在 super.onCreate(savedInstanceState) 之前调用该方法\n     */\n    private void initSwipeBackFinish() {\n        mSwipeBackHelper = new BGASwipeBackHelper(this, this);\n\n        // 「必须在 Application 的 onCreate 方法中执行 BGASwipeBackManager.getInstance().init(this) 来初始化滑动返回」\n        // 下面几项可以不配置，这里只是为了讲述接口用法。\n\n        // 设置滑动返回是否可用。默认值为 true\n        mSwipeBackHelper.setSwipeBackEnable(true);\n        // 设置是否仅仅跟踪左侧边缘的滑动返回。默认值为 true\n        mSwipeBackHelper.setIsOnlyTrackingLeftEdge(true);\n        // 设置是否是微信滑动返回样式。默认值为 true\n        // 选用微信滑动返回样式会有两个问题：\n        // 1.正在滑动时按下返回键 view 显示异常\n        // 2. 界面有明显的抖动\n        mSwipeBackHelper.setIsWeChatStyle(false);\n        // 设置阴影资源 id。默认值为 R.drawable.bga_sbl_shadow\n        mSwipeBackHelper.setShadowResId(R.drawable.bga_sbl_shadow);\n        // 设置是否显示滑动返回的阴影效果。默认值为 true\n        mSwipeBackHelper.setIsNeedShowShadow(true);\n        // 设置阴影区域的透明度是否根据滑动的距离渐变。默认值为 true\n        mSwipeBackHelper.setIsShadowAlphaGradient(true);\n    }\n\n    /**\n     * 是否支持滑动返回。这里在父类中默认返回 true 来支持滑动返回，如果某个界面不想支持滑动返回则重写该方法返回 false 即可\n     *\n     * @return\n     */\n    @Override\n    public boolean isSupportSwipeBack() {\n        return true;\n    }\n\n    /**\n     * 正在滑动返回\n     *\n     * @param slideOffset 从 0 到 1\n     */\n    @Override\n    public void onSwipeBackLayoutSlide(float slideOffset) {\n    }\n\n    /**\n     * 没达到滑动返回的阈值，取消滑动返回动作，回到默认状态\n     */\n    @Override\n    public void onSwipeBackLayoutCancel() {\n    }\n\n    /**\n     * 滑动返回执行完毕，销毁当前 Activity\n     */\n    @Override\n    public void onSwipeBackLayoutExecuted() {\n        mSwipeBackHelper.swipeBackward();\n    }\n\n}\n", "answers": ["        StatusBarUtil.immersive(this);"], "length": 2979, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "200c2fc3a21636526a740d1b20d357aafb5abbb7a9fea050"}
{"input": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.n52.matlab.connector.MatlabException;\nimport org.n52.matlab.connector.MatlabRequest;\nimport org.n52.matlab.connector.MatlabResult;\nimport org.n52.matlab.connector.value.AbstractMatlabValueVisitor;\nimport org.n52.matlab.connector.value.MatlabArray;\nimport org.n52.matlab.connector.value.MatlabBoolean;\nimport org.n52.matlab.connector.value.MatlabCell;\nimport org.n52.matlab.connector.value.MatlabEvalStringVisitor;\nimport org.n52.matlab.connector.value.MatlabFile;\nimport org.n52.matlab.connector.value.MatlabMatrix;\nimport org.n52.matlab.connector.value.MatlabScalar;\nimport org.n52.matlab.connector.value.MatlabString;\nimport org.n52.matlab.connector.value.MatlabStruct;\nimport org.n52.matlab.connector.value.MatlabType;\nimport org.n52.matlab.connector.value.MatlabValue;\nimport org.n52.matlab.control.MatlabConnectionException;\nimport org.n52.matlab.control.MatlabInvocationException;\nimport org.n52.matlab.control.MatlabProxy;\nimport org.n52.matlab.control.MatlabProxyFactory;\nimport org.n52.matlab.control.MatlabProxyFactoryOptions;\nimport org.n52.matlab.control.extensions.MatlabNumericArray;\nimport org.n52.matlab.control.extensions.MatlabTypeConverter;\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.Iterables;\n/*\n * Copyright (C) 2012-2015 by it's authors.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.n52.matlab.connector.instance;\n\n\n\n\n\n\npublic class MatlabInstance {\n    private static final Joiner COMMA_JOINER = Joiner.on(\",\");\n    private static final String CHAR_TYPE = \"char\";\n    private static final String CELL_TYPE = \"cell\";\n    private static final String STRUCT_TYPE = \"struct\";\n    private static final String LOGICAL_TYPE = \"logical\";\n    private final Logger log = LoggerFactory.getLogger(MatlabInstance.class);\n    private final MatlabProxy proxy;\n    private final MatlabTypeConverter processor;\n    private final MatlabInstanceConfiguration config;\n\n    public MatlabInstance() throws MatlabException {\n        this(MatlabInstanceConfiguration.builder().build());\n    }\n\n    public MatlabInstance(MatlabInstanceConfiguration config) throws\n            MatlabException {\n        this.config = Objects.requireNonNull(config);\n        try {\n            proxy = createProxyFactory(config).getProxy();\n            processor = new MatlabTypeConverter(proxy);\n        } catch (MatlabConnectionException e) {\n            throw new MatlabException(\"Unable to connect to MATLAB.\", e);\n        }\n    }\n\n    private MatlabProxyFactory createProxyFactory(\n            MatlabInstanceConfiguration config) {\n        MatlabProxyFactoryOptions.Builder builder\n                = new MatlabProxyFactoryOptions.Builder()\n                .setHidden(config.isHidden())\n                .setPort(config.getPort());\n        if (config.getBaseDir().isPresent()) {\n            builder.setMatlabStartingDirectory(config.getBaseDir().get());\n        }\n        return new MatlabProxyFactory(builder.build());\n    }\n\n    public void destroy() throws MatlabException {\n        try {\n            proxy.exit();\n        } catch (MatlabInvocationException e) {\n            throw new MatlabException(\"Couldn't exit MATLAB.\", e);\n        }\n    }\n\n    private void preHandle() throws MatlabException {\n        try {\n            if (config.getBaseDir().isPresent()) {\n                changeDir(config.getBaseDir().get().getAbsolutePath());\n                proxy.eval(\"addpath('.')\");\n            }\n        } catch (MatlabInvocationException e) {\n            throw new MatlabException(\"Unable to perform pre-request setup.\", e);\n        }\n    }\n\n    private void postHandle() throws MatlabException {\n        try {\n            clearAll();\n        } catch (MatlabInvocationException e) {\n            throw new MatlabException(\"Unable to perform post-request clean.\", e);\n        }\n    }\n\n    protected Map<String, MatlabValue> feval(String function,\n                                             Map<String, MatlabType> results,\n                                             List<MatlabValue> parameters)\n            throws MatlabInvocationException, MatlabException {\n        int length = results.size();\n        final String[] rarray = results.keySet().toArray(new String[length]);\n        final String[] varray = genvarnames(rarray);\n        final String cmd = buildFEval(function, varray, parameters);\n        log.debug(\"Evaluation: {}\", cmd);\n        proxy.eval(cmd);\n        log.info(\"Evaluation complete, parsing results...\");\n        Map<String, MatlabValue> result = new LinkedHashMap<>(rarray.length);\n        for (int i = 0; i < length; ++i) {\n            result.put(rarray[i], parseValue(varray[i], results.get(rarray[i])));\n        }\n        return result;\n    }\n\n    protected String[] genvarnames(String[] rarray) throws\n            MatlabInvocationException {\n        final int length = rarray.length;\n        final String[] varray = new String[length];\n        final MatlabEvalStringVisitor f = MatlabEvalStringVisitor.create();\n        for (int i = 0; i < length; ++i) {", "context": "common/src/main/java/org/n52/matlab/connector/value/MatlabStruct.java\npublic class MatlabStruct extends MatlabValue {\n    private final Map<MatlabString, MatlabValue> fields;\n\n    /**\n     * Creates a new <code>MLStruct</code> instance.\n     *\n     */\n    public MatlabStruct() {\n        this(Maps.<MatlabString, MatlabValue>newTreeMap());\n    }\n\n    public MatlabStruct(Map<MatlabString, MatlabValue> value) {\n        if (checkNotNull(value) instanceof SortedMap) {\n            this.fields = value;\n        } else {\n            TreeMap<MatlabString, MatlabValue> sorted = Maps.newTreeMap();\n            sorted.putAll(value);\n            this.fields = sorted;\n        }\n    }\n\n    public MatlabStruct set(String field, MatlabValue value) {\n        return set(new MatlabString(checkNotNull(field)), value);\n    }\n\n    public MatlabStruct set(MatlabString field, MatlabValue value) {\n        fields.put(checkNotNull(field), checkNotNull(value));\n        return this;\n    }\n\n    public MatlabStruct remove(String field) {\n        return remove(new MatlabString(checkNotNull(field)));\n    }\n\n    public MatlabStruct remove(MatlabString field) {\n        fields.remove(checkNotNull(field));\n        return this;\n    }\n\n    public MatlabValue get(String field) {\n        return get(new MatlabString(checkNotNull(field)));\n    }\n\n    public MatlabValue get(MatlabString field) {\n        return fields.get(checkNotNull(field));\n    }\n\n    public Map<MatlabString, MatlabValue> value() {\n        return Collections.unmodifiableMap(fields);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof MatlabStruct) {\n            MatlabStruct other = (MatlabStruct) o;\n            return Objects.equal(value(), other.value());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(value());\n    }\n\n    @Override\n    public void accept(MatlabValueVisitor visitor) {\n        visitor.visit(this);\n    }\n\n    @Override\n    public <T> T accept(ReturningMatlabValueVisitor<T> visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    public MatlabType getType() {\n        return MatlabType.STRUCT;\n    }\n}\ncommon/src/main/java/org/n52/matlab/connector/MatlabResult.java\npublic class MatlabResult implements Iterable<MatlabValue>, MatlabResponse {\n    private static final MapJoiner JOINER = Joiner.on(\", \")\n            .withKeyValueSeparator(\" = \");\n    private final LinkedHashMap<String, MatlabValue> results;\n    private final long id;\n\n    /**\n     * Creates a new <code>MatlabResult</code> instance.\n     *\n     * @param id the request id\n     */\n    public MatlabResult(long id) {\n        this.results = Maps.newLinkedHashMap();\n        this.id = id;\n    }\n\n    @Override\n    public long getId() {\n        return this.id;\n    }\n\n    /**\n     * Adds a result {@link MatlabValue}.\n     *\n     * @param name   the name of the result\n     * @param result the result <code>MatlabValue</code>\n     *\n     * @return this\n     */\n    public MatlabResult addResult(String name, MatlabValue result) {\n        checkNotNull(name);\n        checkNotNull(result);\n        this.results.put(name, result);\n        return this;\n    }\n\n    public Map<String, MatlabValue> getResults() {\n        return Collections.unmodifiableMap(results);\n    }\n\n    public MatlabValue getResult(String name) {\n        return getResults().get(name);\n    }\n\n    /**\n     * Returns the number of result values.\n     *\n     * @return the number of result values\n     */\n    public int getResultCount() {\n        return getResults().size();\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder().append(\"MatlabResult[\");\n        return JOINER.appendTo(sb, getResults()).append(']').toString();\n    }\n\n    @Override\n    public Iterator<MatlabValue> iterator() {\n        return getResults().values().iterator();\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(getResults());\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof MatlabResult) {\n            MatlabResult other = (MatlabResult) o;\n            return Objects.equal(getResults(), other.getResults());\n        }\n        return false;\n    }\n\n}\ncommon/src/main/java/org/n52/matlab/connector/value/MatlabBoolean.java\npublic class MatlabBoolean extends MatlabValue {\n    private static final MatlabBoolean TRUE = new MatlabBoolean(true, \"1\");\n    private static final MatlabBoolean FALSE = new MatlabBoolean(false, \"0\");\n    private final String string;\n    private final boolean value;\n\n    private MatlabBoolean(boolean value, String string) {\n        this.string = string;\n        this.value = value;\n    }\n\n    public boolean value() {\n        return this.value;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(value());\n    }\n\n    @Override\n    public MatlabType getType() {\n        return MatlabType.BOOLEAN;\n    }\n\n    public static MatlabBoolean yes() {\n        return TRUE;\n    }\n\n    public static MatlabBoolean no() {\n        return FALSE;\n    }\n\n    public static MatlabBoolean fromBoolean(boolean bool) {\n        return bool ? TRUE : FALSE;\n    }\n\n    @Override\n    public void accept(MatlabValueVisitor visitor) {\n        visitor.visit(this);\n    }\n\n    @Override\n    public <T> T accept(ReturningMatlabValueVisitor<T> visitor) {\n        return visitor.visit(this);\n    }\n}\ncommon/src/main/java/org/n52/matlab/connector/value/MatlabType.java\npublic enum MatlabType {\n    ARRAY,\n    BOOLEAN,\n    CELL,\n    FILE,\n    MATRIX,\n    SCALAR,\n    STRING,\n    STRUCT,\n    DATE_TIME;\n\n    @Override\n    public String toString() {\n        return name().toLowerCase();\n    }\n\n    public static MatlabType fromString(String string) {\n        for (MatlabType type : values()) {\n            if (type.toString().equals(string)) {\n                return type;\n            }\n        }\n        throw new IllegalArgumentException();\n    }\n\n}\ncommon/src/main/java/org/n52/matlab/connector/value/MatlabMatrix.java\npublic class MatlabMatrix extends MatlabValue {\n    private final double[][] value;\n\n    /**\n     * Creates a new <code>MLMatrix</code> instance from the given\n     * <code>double</code> value.\n     *\n     * @param matrix the <code>double</code> value\n     */\n    public MatlabMatrix(double[][] matrix) {\n        this.value = checkNotNull(matrix);\n    }\n\n    /**\n     * Creates a new <code>MLMatrix</code> instance from the given\n     * {@link Double} value.\n     *\n     * @param matrix the <code>Double</code> value\n     */\n    public MatlabMatrix(Double[][] matrix) {\n        double[][] values = new double[checkNotNull(matrix).length][];\n        for (int i = 0; i < matrix.length; i++) {\n            values[i] = new double[checkNotNull(matrix[i]).length];\n            for (int j = 0; j < matrix[i].length; j++) {\n                values[i][j] = checkNotNull(matrix[i][j]).doubleValue();\n            }\n        }\n        this.value = values;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return the value\n     */\n    public double[][] value() {\n        return value;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof MatlabMatrix) {\n            MatlabMatrix other = (MatlabMatrix) o;\n            return Arrays.deepEquals(value(), other.value());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return Arrays.deepHashCode(value());\n    }\n\n    @Override\n    public void accept(MatlabValueVisitor visitor) {\n        visitor.visit(this);\n    }\n\n    @Override\n    public <T> T accept(ReturningMatlabValueVisitor<T> visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    public MatlabType getType() {\n        return MatlabType.MATRIX;\n    }\n}\ncommon/src/main/java/org/n52/matlab/connector/value/MatlabFile.java\npublic class MatlabFile extends MatlabValue {\n    private Path file;\n    private byte[] content;\n\n    public MatlabFile(Path file) {\n        this(Objects.requireNonNull(file), null);\n    }\n\n    public MatlabFile(byte[] content) {\n        this(null, Objects.requireNonNull(content));\n    }\n\n    private MatlabFile(Path file, byte[] content) {\n        this.file = file;\n        this.content = content;\n    }\n\n    public boolean isLoaded() {\n        return content != null;\n    }\n\n    public boolean isSaved() {\n        return file != null;\n    }\n\n    public MatlabFile load()\n            throws IOException {\n        checkState(isSaved());\n        this.content = Files.readAllBytes(file);\n        return this;\n    }\n\n    public MatlabFile unload() {\n        checkState(isSaved());\n        this.content = null;\n        return this;\n    }\n\n    public MatlabFile save(Path file)\n            throws IOException {\n        Objects.requireNonNull(file);\n        checkState(isLoaded());\n        Files.write(file, content);\n        this.file = file;\n        return this;\n    }\n\n    public MatlabFile delete()\n            throws IOException {\n        if (file != null) {\n            Files.delete(file);\n            file = null;\n        }\n        return this;\n    }\n\n    @Override\n    public void accept(MatlabValueVisitor visitor) {\n        visitor.visit(this);\n    }\n\n    @Override\n    public <T> T accept(ReturningMatlabValueVisitor<T> visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    public MatlabType getType() {\n        return MatlabType.FILE;\n    }\n\n    public Path getFile() {\n        return file;\n    }\n\n    public byte[] getContent()\n            throws IOException {\n        if (!isLoaded()) {\n            load();\n        }\n        return content;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof MatlabFile) {\n            MatlabFile that = (MatlabFile) o;\n            try {\n                return Arrays.equals(this.getContent(), that.getContent());\n            } catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        try {\n            return Objects.hash(getFile(), getContent());\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    @Override\n    public String toString() {\n        if (isLoaded()) {\n            return String.format(\"%s[length=%s]\",\n                                 getClass().getSimpleName(),\n                                 this.content.length);\n        } else {\n            return String.format(\"%s[location=%s]\",\n                                 getClass().getSimpleName(),\n                                 this.file.toAbsolutePath());\n        }\n    }\n\n    public static MatlabFile load(Path file)\n            throws IOException {\n        return new MatlabFile(file).load();\n    }\n\n    public static MatlabFile save(byte[] content, Path file)\n            throws IOException {\n        return new MatlabFile(content).save(file);\n    }\n\n}\ncommon/src/main/java/org/n52/matlab/connector/value/MatlabScalar.java\npublic class MatlabScalar extends MatlabValue implements Comparable<MatlabScalar>{\n    private final double scalar;\n\n    /**\n     * Creates a new <code>MLScalar</code> instance from a given\n     * <code>double</code> scalar.\n     *\n     * @param scalar the <code>double</code> scalar\n     */\n    public MatlabScalar(double scalar) {\n        this.scalar = scalar;\n    }\n\n    /**\n     * Creates a new <code>MLScalar</code> instance from a given {@link Double}\n     * scalar.\n     *\n     * @param scalar the <code>Double</code> scalar\n     */\n    public MatlabScalar(Double scalar) {\n        this(checkNotNull(scalar).doubleValue());\n    }\n\n    /**\n     * Returns the scalar.\n     *\n     * @return the scalar\n     */\n    public double value() {\n        return scalar;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof MatlabScalar) {\n            MatlabScalar other = (MatlabScalar) o;\n            return Objects.equal(value(), other.value());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(value());\n    }\n\n     @Override\n    public void accept(MatlabValueVisitor visitor) {\n        visitor.visit(this);\n    }\n\n    @Override\n    public <T> T accept(ReturningMatlabValueVisitor<T> visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    public int compareTo(MatlabScalar o) {\n        return Doubles.compare(value(), checkNotNull(o).value());\n    }\n\n    @Override\n    public MatlabScalar asScalar() {\n        return this;\n    }\n\n    @Override\n    public boolean isScalar() {\n        return true;\n    }\n\n    @Override\n    public MatlabType getType() {\n        return MatlabType.SCALAR;\n    }\n\n    public MatlabBoolean toBoolean() {\n        return MatlabBoolean.fromBoolean(value() != 0);\n    }\n\n    public MatlabDateTime toDateTime() {\n        return new MatlabDateTime(new DateTime(((Double) value()).longValue()));\n    }\n}\ncommon/src/main/java/org/n52/matlab/connector/MatlabException.java\npublic class MatlabException extends Exception implements MatlabResponse {\n\n    private static final long serialVersionUID = 1L;\n    private long id = -1;\n\n    /**\n     * Creates a new <code>MLException</code> instance with the given message.\n     *\n     * @param message the exception message\n     */\n    public MatlabException(String message) {\n        super(message);\n    }\n\n    public MatlabException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    @Override\n    public long getId() {\n        return this.id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n}\ncommon/src/main/java/org/n52/matlab/connector/value/MatlabCell.java\npublic class MatlabCell extends MatlabValue implements Iterable<MatlabValue> {\n    private final List<MatlabValue> value;\n\n    /**\n     * Creates a new <code>MLCell</code> instance from the given array of\n     * <code>MatlabValue</code> objects.\n     *\n     * @param cell the value, given as an array of <code>MatlabValue</code>\n     *             objects\n     */\n    public MatlabCell(MatlabValue... cell) {\n        this(Arrays.asList(checkNotNull(cell)));\n    }\n\n    public MatlabCell(Iterable<? extends MatlabValue> values) {\n        this.value = Lists.newArrayList(checkNotNull(values));\n    }\n\n    public MatlabCell add(MatlabValue value) {\n        this.value.add(checkNotNull(value));\n        return this;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return the value, as an array of <code>MatlabValue</code> objects\n     */\n    public List<MatlabValue> value() {\n        return Collections.unmodifiableList(value);\n    }\n\n    public int size() {\n        return value.size();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof MatlabCell) {\n            MatlabCell other = (MatlabCell) o;\n            return Objects.equal(value(), other.value());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(value());\n    }\n\n    @Override\n    public void accept(MatlabValueVisitor visitor) {\n        visitor.visit(this);\n    }\n\n    @Override\n    public <T> T accept(ReturningMatlabValueVisitor<T> visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    public MatlabType getType() {\n        return MatlabType.CELL;\n    }\n\n    @Override\n    public Iterator<MatlabValue> iterator() {\n        return value().iterator();\n    }\n\n    public Stream<MatlabValue> stream() {\n        return value().stream();\n    }\n}\ncommon/src/main/java/org/n52/matlab/connector/value/MatlabString.java\npublic class MatlabString extends MatlabValue implements\n        Comparable<MatlabString> {\n    private final String string;\n\n    /**\n     * Creates a new <code>MLString</code> instance from a given\n     * <code>String</code>.\n     *\n     * @param string the <code>String</code>\n     */\n    public MatlabString(String string) {\n        this.string = checkNotNull(string);\n    }\n\n    /**\n     * Returns the string.\n     *\n     * @return the string\n     */\n    public String value() {\n        return string;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof MatlabString) {\n            MatlabString other = (MatlabString) o;\n            return Objects.equal(value(), other.value());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(value());\n    }\n\n    @Override\n    public void accept(MatlabValueVisitor visitor) {\n        visitor.visit(this);\n    }\n\n    @Override\n    public <T> T accept(ReturningMatlabValueVisitor<T> visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    public int compareTo(MatlabString o) {\n        return value().compareTo(checkNotNull(o).value());\n    }\n\n    @Override\n    public MatlabType getType() {\n        return MatlabType.STRING;\n    }\n\n    public MatlabBoolean toBoolean() {\n        return MatlabBoolean.fromBoolean(Boolean.valueOf(value()));\n    }\n\n    public MatlabDateTime toDateTime() {\n        // FIXME matlab date time parsing\n        throw new UnsupportedOperationException();\n    }\n\n    public MatlabFile toFile(boolean delete) throws IOException {\n        MatlabFile file = new MatlabFile(Paths.get(value()));\n        file.load();\n        if (delete) {\n            file.delete();\n        }\n        return file;\n    }\n\n}\ncommon/src/main/java/org/n52/matlab/connector/value/MatlabEvalStringVisitor.java\npublic class MatlabEvalStringVisitor\n        implements ReturningMatlabValueVisitor<String>,\n                   Function<MatlabValue, String> {\n    private static final String BOOL_FALSE = \"logical(0)\";\n    private static final String BOOL_TRUE = \"logical(1)\";\n    private static final String NaN = \"NaN\";\n    private static final String POSITIVE_INFINITY = \"Inf\";\n    private static final String NEGATIVE_INFINITY = \"-Inf\";\n    private static final Joiner COMMA_JOINER = Joiner.on(\", \");\n    private static final MapJoiner STRUCT_JOINER = COMMA_JOINER\n            .withKeyValueSeparator(\", \");\n    private final MapTransformer mapTransformer = new MapTransformer();\n\n    private MatlabEvalStringVisitor() {\n    }\n\n    @Override\n    public String visit(MatlabArray value) {\n        StringBuilder sb = new StringBuilder(\"[ \");\n        COMMA_JOINER.appendTo(sb, toString(value.value()));\n        return sb.append(\" ]\").toString();\n    }\n\n    @Override\n    public String visit(MatlabBoolean value) {\n        return value.value() ? BOOL_TRUE : BOOL_FALSE;\n    }\n\n    @Override\n    public String visit(MatlabCell value) {\n        StringBuilder sb = new StringBuilder().append(\"{ \");\n        COMMA_JOINER.appendTo(sb, Iterables.transform(value.value(), this));\n        return sb.append(\" }\").toString();\n    }\n\n    @Override\n    public String visit(MatlabMatrix value) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"[ \");\n        double[][] matrix = value.value();\n        for (int i = 0; i < matrix.length; ++i) {\n            COMMA_JOINER.appendTo(builder, toString(matrix[i]));\n            if (i < matrix.length - 1) {\n                builder.append(\"; \");\n            }\n        }\n        builder.append(\" ]\");\n        return builder.toString();\n    }\n\n    private Iterable<String> toString(double[] values) {\n        return Iterables.transform(Doubles.asList(values), this::toString);\n    }\n\n    private String toString(Double v) {\n        if (v.isNaN()) {\n            return NaN;\n        } else if (v.isInfinite()) {\n            return v < 0 ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n        } else {\n            return v.toString();\n        }\n    }\n\n    @Override\n    public String visit(MatlabScalar value) {\n        return toString(value.value());\n    }\n\n    @Override\n    public String visit(MatlabString value) {\n        return toString(value.value());\n    }\n\n    private String toString(String value) {\n        return \"'\" + value.replace(\"'\", \"''\") + \"'\";\n    }\n\n    @Override\n    public String visit(MatlabStruct value) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"struct(\");\n        STRUCT_JOINER.appendTo(builder, Iterables\n                .transform(value.value().entrySet(), mapTransformer()));\n        builder.append(')');\n        return builder.toString();\n    }\n\n    @Override\n    public String apply(MatlabValue input) {\n        return input.accept(this);\n    }\n\n    @Override\n    public String visit(MatlabFile file) {\n        if (file.isLoaded()) {\n            try {\n                return Arrays.toString(file.getContent());\n            } catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n        } else {\n           return file.getFile().toAbsolutePath().toString();\n        }\n    }\n\n    public MapTransformer mapTransformer() {\n        return mapTransformer;\n    }\n\n    @Override\n    public String visit(MatlabDateTime time) {\n        double[] a = time.toArray();\n        int max = a.length - 1;\n        StringBuilder b = new StringBuilder();\n        b.append(\"datenum([\");\n        for (int i = 0; ; i++) {\n            b.append(a[i]);\n            if (i == max) {\n                return b.append(\"])\").toString();\n            }\n            b.append(\", \");\n        }\n    }\n\n    public static MatlabEvalStringVisitor create() {\n        return new MatlabEvalStringVisitor();\n    }\n\n    private class MapTransformer implements Function<Entry<? extends MatlabValue, ? extends MatlabValue>, Entry<String, String>> {\n        @Override\n        public Entry<String, String> apply(\n                Entry<? extends MatlabValue, ? extends MatlabValue> input) {\n            return Maps.immutableEntry(\n                    input.getKey().accept(MatlabEvalStringVisitor.this),\n                    input.getValue().accept(MatlabEvalStringVisitor.this));\n        }\n    }\n}\ncommon/src/main/java/org/n52/matlab/connector/value/MatlabArray.java\npublic class MatlabArray extends MatlabValue {\n\n    private final double[] array;\n\n    /**\n     * Creates a new <code>MLArray</code> instance from the given\n     * <code>double</code> array.\n     *\n     * @param array the <code>double</code> array\n     */\n    public MatlabArray(double[] array) {\n        this.array = checkNotNull(array);\n    }\n\n    /**\n     * Creates a new <code>MLArray</code> instance from the given {@link Double}\n     * array.\n     *\n     * @param array the <code>Double</code> array\n     */\n    public MatlabArray(Double[] array) {\n        checkNotNull(array);\n        double[] values = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            values[i] = checkNotNull(array[i]);\n        }\n        this.array = values;\n    }\n\n    /**\n     * Returns the array.\n     *\n     * @return the array\n     */\n    public double[] value() {\n        return array;\n    }\n\n    public int size() {\n        return array.length;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof MatlabArray) {\n            MatlabArray other = (MatlabArray) o;\n            return Arrays.equals(value(), other.value());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return Arrays.hashCode(value());\n    }\n\n    @Override\n    public void accept(MatlabValueVisitor visitor) {\n        visitor.visit(this);\n    }\n\n    @Override\n    public <T> T accept(ReturningMatlabValueVisitor<T> visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    public MatlabType getType() {\n        return MatlabType.ARRAY;\n    }\n\n    public MatlabDateTime toDateTime() {\n        if (value().length != 6) {\n            throw new UnsupportedOperationException(\"invalid array length\");\n        }\n        int year = (int) array[0];\n        int month = (int) array[1];\n        int day = (int) array[2];\n        int hour = (int) array[3];\n        int minute = (int) array[4];\n        int second = (int) Math.floor(array[5]);\n        int millis = (int) ((array[5] - second) * 1000);\n        return new MatlabDateTime(new DateTime(year, month, day, hour, minute, second, millis));\n    }\n}\n", "answers": ["            String safe = f.apply(new MatlabString(rarray[i]));"], "length": 2714, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "79af7cff189954221087bcc053d4108db366d8742eba6b91"}
{"input": "package anabolicandroids.chanobol.ui.posts;\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.ValueAnimator;\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.Configuration;\nimport android.graphics.Color;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.ColorDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.support.annotation.NonNull;\nimport android.support.v4.view.ViewCompat;\nimport android.support.v7.graphics.Palette;\nimport android.support.v7.widget.CardView;\nimport android.support.v7.widget.PopupMenu;\nimport android.text.Layout;\nimport android.text.Spannable;\nimport android.text.format.DateUtils;\nimport android.text.method.LinkMovementMethod;\nimport android.text.style.ClickableSpan;\nimport android.util.AttributeSet;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.TextView;\nimport com.koushikdutta.async.future.FutureCallback;\nimport com.koushikdutta.ion.ImageViewBitmapInfo;\nimport com.koushikdutta.ion.Ion;\nimport com.koushikdutta.ion.bitmap.BitmapInfo;\nimport com.koushikdutta.ion.builder.AnimateGifMode;\nimport com.koushikdutta.ion.builder.Builders;\nimport java.util.ArrayList;\nimport anabolicandroids.chanobol.App;\nimport anabolicandroids.chanobol.R;\nimport anabolicandroids.chanobol.api.ApiModule;\nimport anabolicandroids.chanobol.api.data.Post;\nimport anabolicandroids.chanobol.ui.posts.parsing.LinkSpan;\nimport anabolicandroids.chanobol.ui.posts.parsing.QuoteSpan;\nimport anabolicandroids.chanobol.ui.posts.parsing.ThreadLink;\nimport anabolicandroids.chanobol.ui.posts.parsing.ThreadSpan;\nimport anabolicandroids.chanobol.ui.scaffolding.Prefs;\nimport anabolicandroids.chanobol.ui.scaffolding.UiActivity;\nimport anabolicandroids.chanobol.util.Util;\nimport butterknife.ButterKnife;\nimport butterknife.InjectView;\n\n\n\n\n\npublic class PostView extends CardView {\n    @InjectView(R.id.number) TextView number;\n    @InjectView(R.id.name) TextView name;\n    @InjectView(R.id.tripCode) TextView tripCode;\n    @InjectView(R.id.mediaContainer) ViewGroup mediaContainer;\n    @InjectView(R.id.imageTouchOverlay) View imageTouchOverlay; // I couldn't get the FrameLayout clickable...\n    @InjectView(R.id.image) ImageView image;\n    @InjectView(R.id.play) ImageView play;\n    @InjectView(R.id.progressbar) ProgressBar progress;\n    @InjectView(R.id.text) TextView text;\n    @InjectView(R.id.footerFlag) ImageView footerFlag;\n    @InjectView(R.id.footerCountryName) TextView footerCountryName;\n    @InjectView(R.id.footerImage) TextView footerImage;\n    @InjectView(R.id.date) TextView date;\n    @InjectView(R.id.replies) TextView replies;\n    @InjectView(R.id.reply) TextView reply;\n    @InjectView(R.id.more) TextView more;\n\n    private PostViewMovementMethod postViewMovementMethod = new PostViewMovementMethod();\n    private static final int W = 0, H = 1;\n    private int maxImgWidth;\n    private int maxImgHeight;\n    private int minImgHeight;\n", "context": "src/main/java/anabolicandroids/chanobol/ui/posts/parsing/LinkSpan.java\npublic class LinkSpan extends PostSpan {\n\n    public final String url;\n\n    public LinkSpan(String url) {\n        this.url = url;\n    }\n\n    @Override public void updateDrawState(@NonNull TextPaint ds) {\n        ds.setColor(ThemeContext.getInstance().linkColor);\n        ds.setUnderlineText(true);\n    }\n}\nsrc/main/java/anabolicandroids/chanobol/api/ApiModule.java\n@SuppressWarnings(\"UnusedDeclaration\")\n@Module(\n        complete = false,\n        library = true\n)\npublic class ApiModule {\n    public static final String endpoint = \"http://a.4cdn.org\";\n    // http://t.4cdn.org/board/1358180697001s.jpg\n    public static final String thumbCdn = \"http://t.4cdn.org\";\n    // http://i.4cdn.org/board/1358180697001.ext\n    public static final String mediaCdn = \"http://i.4cdn.org\";\n\n    public static String thumbUrl(String board, String mediaId) {\n        return thumbCdn + \"/\" + board + \"/\" + mediaId + \"s.jpg\";\n    }\n\n    public static String mediaUrl(String board, String mediaId, String ending) {\n        return mediaCdn + \"/\" + board + \"/\" + mediaId + ending;\n    }\n\n    // http://boards.4chan.org/fit/thread/31627542\n    public static String threadUrl(String board, String number) {\n        return \"http://boards.4chan.org/\" + board + \"/thread/\" + number;\n    }\n\n    @Provides @Singleton\n    Ion provideIon(Application app) {\n        return Ion.getDefault(app);\n    }\n\n    @Provides @Singleton\n    ChanService provideChanService(@ForApplication Context context, Ion ion) {\n        return new ChanService(context, ion);\n    }\n\n    // From Clover\n    private static final long FILE_CACHE_DISK_SIZE = 50 * 1024 * 1024; // 50mb\n    private static final String FILE_CACHE_NAME = \"filecache\";\n\n    @Provides @Singleton\n    FileCache provideFileCache(App app, Ion ion) {\n        File cacheDir = app.getExternalCacheDir() != null ? app.getExternalCacheDir() : app.getCacheDir();\n        return new FileCache(new File(cacheDir, FILE_CACHE_NAME), FILE_CACHE_DISK_SIZE, ion);\n    }\n}\nsrc/main/java/anabolicandroids/chanobol/ui/scaffolding/Prefs.java\n@SuppressWarnings(\"UnusedDeclaration\")\npublic class Prefs {\n\n    private final SharedPreferences p;\n\n    public Prefs(SharedPreferences sharedPrefs) {\n        this.p = sharedPrefs;\n    }\n\n    public static final String THEME = \"pref_theme\";\n    public Theme theme() {\n        String name = p.getString(\"pref_theme\", Theme.LIGHT.name);\n        if (name.equals(Theme.LIGHT.name)) return Theme.LIGHT;\n        if (name.equals(Theme.DARK.name)) return Theme.DARK;\n        if (name.equals(Theme.TEAL.name)) return Theme.TEAL;\n        if (name.equals(Theme.BLUE1.name)) return Theme.BLUE1;\n        if (name.equals(Theme.BLUE2.name)) return Theme.BLUE2;\n        if (name.equals(Theme.GRAY.name)) return Theme.GRAY;\n        return Theme.LIGHT;\n    }\n    public void theme(Theme theme) {\n        p.edit().putString(THEME, theme.name).apply();\n    }\n\n    public static final String HIDABLE_TOOLBAR = \"pref_hidable_toolbar\";\n    public boolean hidableToolbar() {\n        return p.getBoolean(HIDABLE_TOOLBAR, true);\n    }\n    public void hidableToolbar(boolean v) {\n        p.edit().putBoolean(HIDABLE_TOOLBAR, v).apply();\n    }\n\n    public static final String PRELOAD_THUMBNAILS = \"pref_preload_thumbnails\";\n    public boolean preloadThumbnails() {\n        return p.getBoolean(PRELOAD_THUMBNAILS, true);\n    }\n    public void preloadThumbnails(boolean v) {\n        p.edit().putBoolean(PRELOAD_THUMBNAILS, v).apply();\n    }\n\n    public static final String ONLY_THUMBNAILS = \"pref_only_thumbnails_postlist\";\n    public boolean onlyThumbnailsInPostlist() {\n        return p.getBoolean(ONLY_THUMBNAILS, false);\n    }\n    public void onlyThumbnailsInPostlist(boolean v) {\n        p.edit().putBoolean(ONLY_THUMBNAILS, v).apply();\n    }\n\n    public static final String VOLUME_SCROLLING = \"pref_volume_scrolling\";\n    public boolean volumeScrolling() {\n        return p.getBoolean(VOLUME_SCROLLING, false);\n    }\n    public void volumeScrolling(boolean v) {\n        p.edit().putBoolean(VOLUME_SCROLLING, v).apply();\n    }\n\n    public static final String AUTO_REFRESH = \"pref_refresh\";\n    public boolean autoRefresh() {\n        return p.getBoolean(AUTO_REFRESH, true);\n    }\n    public void autoRefresh(boolean v) {\n        p.edit().putBoolean(AUTO_REFRESH, v).apply();\n    }\n\n    public static final String IMAGE_DIR = \"pref_image_dir\";\n    public File imageDir() {\n        String path = p.getString(IMAGE_DIR, null);\n        if (path == null) return new File(Environment.getExternalStorageDirectory() + File.separator + \"Chanobol\");\n        else return new File(path);\n    }\n    public void imageDir(String dir) {\n        p.edit().putString(IMAGE_DIR, dir).apply();\n    }\n\n\n    public static final String THREAD_SORT_ORDER = \"pref_thread_sort_order\";\n    public ThreadSortOrder threadSortOrder() {\n        String s = p.getString(THREAD_SORT_ORDER, ThreadSortOrder.Bump.string);\n        if (s.equals(ThreadSortOrder.Bump.string)) return ThreadSortOrder.Bump;\n        if (s.equals(ThreadSortOrder.Replies.string)) return ThreadSortOrder.Replies;\n        if (s.equals(ThreadSortOrder.Images.string)) return ThreadSortOrder.Images;\n        if (s.equals(ThreadSortOrder.Date.string)) return ThreadSortOrder.Date;\n        return ThreadSortOrder.Bump;\n    }\n    public void threadSortOrder(ThreadSortOrder order) {\n        p.edit().putString(THREAD_SORT_ORDER, order.string).apply();\n    }\n\n    public static final String EXTERNAL_WEBM = \"pref_external_webm\";\n    public boolean externalWebm() {\n        if (Build.VERSION.SDK_INT < 15) return true;\n        return p.getBoolean(EXTERNAL_WEBM, false);\n    }\n    public void externalWebm(boolean v) {\n        p.edit().putBoolean(EXTERNAL_WEBM, v).apply();\n    }\n\n    public static final String IMMERSIVE_MODE = \"pref_immersive_mode\";\n    public boolean immersiveMode() {\n        if (Build.VERSION.SDK_INT < 19) return false;\n        return p.getBoolean(IMMERSIVE_MODE, false);\n    }\n    public void immersiveMode(boolean v) {\n        p.edit().putBoolean(IMMERSIVE_MODE, v).apply();\n    }\n\n    public static final String WATCHTASK_RECENTS = \"pref_watchtask_recents\";\n    public boolean excludeWatchtaskRecents() {\n        return p.getBoolean(WATCHTASK_RECENTS, true);\n    }\n    public void excludeWatchtaskRecents(boolean v) {\n        p.edit().putBoolean(WATCHTASK_RECENTS, v).apply();\n    }\n\n}\nsrc/main/java/anabolicandroids/chanobol/App.java\npublic class App extends Application {\n    // This variable is needed to communicate between the Settings and the Main activity.\n    // Using a static variable is the easiest solution. Note that having a static variable\n    // in the Application class is safe with respect to stale references so it's all good.\n    public static boolean needToProtractToolbar = false;\n    public static boolean firstStart;\n    // As a fallback\n    public static int screenWidth;\n    public static int screenHeight;\n\n    private ObjectGraph appGraph;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Fabric.with(this, new Crashlytics());\n        if (BuildConfig.DEBUG) {\n            Timber.plant(new Timber.DebugTree());\n        }\n        buildAppGraphAndInject();\n\n        firstStart = true;\n        screenWidth = Util.getScreenWidth(this);\n        screenHeight = Util.getScreenHeight(this);\n    }\n\n    public void buildAppGraphAndInject() {\n        appGraph = ObjectGraph.create(Modules.list(this));\n        appGraph.inject(this);\n    }\n\n    public void inject(Object o) { appGraph.inject(o); }\n\n    public ObjectGraph getAppGraph() {\n        return appGraph;\n    }\n\n    public static App get(Context context) {\n        return (App) context.getApplicationContext();\n    }\n}\nsrc/main/java/anabolicandroids/chanobol/ui/posts/parsing/ThreadSpan.java\npublic class ThreadSpan extends PostSpan {\n\n    public final ThreadLink threadLink;\n\n    public ThreadSpan(ThreadLink threadLink) {\n        this.threadLink = threadLink;\n    }\n\n    @Override public void updateDrawState(@NonNull TextPaint ds) {\n        ds.setColor(ThemeContext.getInstance().quoteColor);\n        ds.setUnderlineText(true);\n    }\n}\nsrc/main/java/anabolicandroids/chanobol/util/Util.java\npublic class Util {\n\n    public static int clamp(double min, double val, double max) {\n        return (int) Math.max(min, Math.min(max, val));\n    }\n\n    // http://stackoverflow.com/a/5599842\n    public static String readableFileSize(long size) {\n        if(size <= 0) return \"0\";\n        final String[] units = new String[] { \"B\", \"kB\", \"MB\", \"GB\", \"TB\" };\n        int digitGroups = (int) (Math.log10(size)/Math.log10(1024));\n        return new DecimalFormat(\"#,##0.#\").format(size/Math.pow(1024, digitGroups)) + \" \" + units[digitGroups];\n    }\n\n    public static void showToast(Context context, String msg) {\n        Toast.makeText(context, msg, Toast.LENGTH_SHORT).show();\n    }\n\n    public static void showToast(Context context, int res) {\n        Toast.makeText(context, res, Toast.LENGTH_SHORT).show();\n    }\n\n    @SuppressWarnings(\"UnusedDeclaration\")\n    public static void setAlpha(View view, float alpha) {\n        if (Build.VERSION.SDK_INT < 11) {\n            final AlphaAnimation animation = new AlphaAnimation(alpha, alpha);\n            animation.setDuration(0);\n            animation.setFillAfter(true);\n            view.startAnimation(animation);\n        } else view.setAlpha(alpha);\n    }\n\n    public static String loadJSONFromAsset(Context context, String path) {\n        String json;\n        try {\n            InputStream is = context.getAssets().open(path);\n            int size = is.available();\n            byte[] buffer = new byte[size];\n            //noinspection ResultOfMethodCallIgnored\n            is.read(buffer);\n            is.close();\n            json = new String(buffer, \"UTF-8\");\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            return null;\n        }\n        return json;\n    }\n\n    public static int getScreenHeight(Context context) {\n        android.view.Display display = ((android.view.WindowManager)context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\n        //noinspection deprecation\n        return display.getHeight();\n    }\n\n    public static int getScreenWidth(Context context) {\n        android.view.Display display = ((android.view.WindowManager)context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\n        //noinspection deprecation\n        return display.getWidth();\n    }\n\n    public static int getActionBarHeight(Context context) {\n        TypedValue tv = new TypedValue();\n        if (context.getTheme().resolveAttribute(R.attr.actionBarSize, tv, true)) {\n            return TypedValue.complexToDimensionPixelSize(tv.data, context.getResources().getDisplayMetrics());\n        }\n        return -1;\n    }\n\n    public static float dpToPx(float dp, Context context){\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n        return dp * (metrics.densityDpi / 160f);\n    }\n\n    @SuppressWarnings(\"UnusedDeclaration\")\n    public static float pxToDp(float px, Context context){\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n        return px / (metrics.densityDpi / 160f);\n    }\n\n    // Unsatisfactory compared to GridView but given the current constraint best solution\n    // http://stackoverflow.com/questions/26666143/recyclerview-gridlayoutmanager-how-to-auto-detect-span-count\n    public static void calcDynamicSpanCount(final RecyclerView rv,\n                                            final GridLayoutManager glm,\n                                            final float cardWidth) {\n        rv.getViewTreeObserver().addOnGlobalLayoutListener(\n                new ViewTreeObserver.OnGlobalLayoutListener() {\n                    @Override\n                    public void onGlobalLayout() {\n                        //noinspection deprecation\n                        rv.getViewTreeObserver().removeGlobalOnLayoutListener(this);\n                        int viewWidth = rv.getMeasuredWidth();\n                        int newSpanCount = (int) Math.floor(viewWidth / cardWidth);\n                        glm.setSpanCount(Math.max(1, newSpanCount));\n                        glm.requestLayout();\n                    }\n                });\n    }\n    public static void calcDynamicSpanCountById(final Context cxt,\n                                                final RecyclerView rv,\n                                                final GridLayoutManager glm,\n                                                final int cardWidthId) {\n        float cardWidth = cxt.getResources().getDimension(cardWidthId);\n        calcDynamicSpanCount(rv, glm, cardWidth);\n    }\n\n    public static void updateRecyclerViewGridOnConfigChange(final RecyclerView rv, final int cardWidthId) {\n        rv.postDelayed(new Runnable() {\n            @Override public void run() {\n                GridLayoutManager glm = (GridLayoutManager) rv.getLayoutManager();\n                Util.calcDynamicSpanCountById(rv.getContext(), rv, glm, cardWidthId);\n                rv.requestLayout();\n            }\n        }, 100);\n    }\n\n    public static void animateY(final View view, int from, int to, int duration) {\n        ValueAnimator anim = ValueAnimator.ofInt(from, to);\n        anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator valueAnimator) {\n                int val = (Integer) valueAnimator.getAnimatedValue();\n                ViewHelper.setTranslationY(view, val);\n            }\n        });\n        anim.setDuration(duration);\n        anim.start();\n    }\n\n    public static void setVisibility(View view, boolean show) {\n        if (show) view.setVisibility(View.VISIBLE);\n        else view.setVisibility(View.GONE);\n    }\n\n    // http://stackoverflow.com/a/21051758/283607\n    public static Bitmap blur(Context ctx, Bitmap image, float radius) {\n        int width = Math.round(image.getWidth());\n        int height = Math.round(image.getHeight());\n\n        Bitmap inputBitmap = Bitmap.createScaledBitmap(image, width, height, false);\n        Bitmap outputBitmap = Bitmap.createBitmap(inputBitmap);\n\n        RenderScript rs = RenderScript.create(ctx);\n        ScriptIntrinsicBlur theIntrinsic = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));\n        Allocation tmpIn = Allocation.createFromBitmap(rs, inputBitmap);\n        Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap);\n        theIntrinsic.setRadius(radius);\n        theIntrinsic.setInput(tmpIn);\n        theIntrinsic.forEach(tmpOut);\n        tmpOut.copyTo(outputBitmap);\n\n        return outputBitmap;\n    }\n\n    // http://stackoverflow.com/a/24313590/283607\n    public static Bitmap setHasAlphaCompat(Bitmap bit) {\n        int width =  bit.getWidth();\n        int height = bit.getHeight();\n        Bitmap myBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        int [] allpixels = new int [ myBitmap.getHeight()*myBitmap.getWidth()];\n        bit.getPixels(allpixels, 0, myBitmap.getWidth(), 0, 0, myBitmap.getWidth(),myBitmap.getHeight());\n        myBitmap.setPixels(allpixels, 0, width, 0, 0, width, height);\n        return myBitmap;\n    }\n\n    public static void startWebmActivity(Context context, String url) {\n        Intent intent = new Intent(Intent.ACTION_VIEW).setDataAndType(Uri.parse(url), \"video/webm\");\n        if(intent.resolveActivity(context.getPackageManager()) != null)\n            context.startActivity(intent);\n        else\n            Util.showToast(context, R.string.no_app);\n    }\n\n    public static void openLink(Context context, String link) {\n        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(link));\n        if(intent.resolveActivity(context.getPackageManager()) != null)\n            context.startActivity(intent);\n        else\n            Util.showToast(context, R.string.no_app);\n    }\n\n    public static void restartApp(Application app, Activity activity) {\n        // TODO: Apparently there is a way to recreate the whole back stack: http://stackoverflow.com/a/28799124/283607\n        // From U2020 DebugAppContainer.setEndpointAndRelaunch\n        Intent newApp = new Intent(activity, FavoritesActivity.class);\n        if (Build.VERSION.SDK_INT >= 11) {\n            newApp.setFlags(FLAG_ACTIVITY_CLEAR_TASK | FLAG_ACTIVITY_NEW_TASK);\n        } else {\n            newApp.setFlags(FLAG_ACTIVITY_NEW_TASK);\n        }\n        app.startActivity(newApp);\n        App.get(app).buildAppGraphAndInject();\n    }\n\n    public static void setTheme(Activity activity, Prefs prefs) {\n        Theme theme = prefs.theme();\n        activity.setTheme(theme.resValue);\n        ThemeContext.getInstance().reloadPostViewColors(activity);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            // It isn't loaded from the xml in setTheme for some reason\n            Window window = activity.getWindow();\n            Resources r = activity.getResources();\n            if (theme == Theme.LIGHT)\n                window.setStatusBarColor(r.getColor(R.color.colorPrimaryDark_light));\n            if (theme == Theme.DARK)\n                window.setStatusBarColor(r.getColor(R.color.colorPrimaryDark));\n            if (theme == Theme.TEAL)\n                window.setStatusBarColor(r.getColor(R.color.colorPrimaryDark_teal));\n            if (theme == Theme.BLUE1)\n                window.setStatusBarColor(r.getColor(R.color.colorPrimaryDark_blue1));\n            if (theme == Theme.BLUE2)\n                window.setStatusBarColor(r.getColor(R.color.colorPrimaryDark_blue2));\n            if (theme == Theme.GRAY)\n                window.setStatusBarColor(r.getColor(R.color.colorPrimaryDark_gray));\n        }\n    }\n\n    // http://stackoverflow.com/a/10600736/283607\n    public static Bitmap drawableToBitmap(Drawable drawable) {\n        if (drawable instanceof BitmapDrawable) {\n            return ((BitmapDrawable)drawable).getBitmap();\n        }\n\n        int w = drawable.getIntrinsicWidth();\n        int h = drawable.getIntrinsicHeight();\n        if (w <= 0 || h <= 0) return null;\n\n        Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(bitmap);\n        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\n        drawable.draw(canvas);\n\n        return bitmap;\n    }\n\n    // http://stackoverflow.com/a/23683075/283607\n    public static Bitmap copy(Bitmap b) {\n        return b.copy(b.getConfig(), true);\n    }\n\n    // From Clover\n    public static void runOnUiThread(Runnable runnable) {\n        new Handler(Looper.getMainLooper()).post(runnable);\n    }\n\n    // From Clover and http://stackoverflow.com/a/10965541/283607\n    public static void copyToClipboard(Context context, String text) {\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.HONEYCOMB) {\n            ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n            ClipData clip = ClipData.newPlainText(context.getResources().getString(R.string.clipoard_copy_label), text);\n            clipboard.setPrimaryClip(clip);\n        } else {\n            android.text.ClipboardManager clipboard = (android.text.ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n            clipboard.setText(text);\n        }\n    }\n}\nsrc/main/java/anabolicandroids/chanobol/api/data/Post.java\n@Parcel\npublic class Post extends Common {\n    @SerializedName(\"resto\")\n    public String replyTo;\n\n    public ThreadPreview toThreadPreview() {\n        Gson gson = new Gson();\n        Type type = new TypeToken<ThreadPreview>() {}.getType();\n        ThreadPreview result = gson.fromJson(gson.toJson(this), type);\n        result.generateExcerpt();\n        return result;\n    }\n\n    @SuppressWarnings(\"UnusedDeclaration\")\n    public boolean isOp() { return \"0\".equals(replyTo); }\n\n    @SuppressWarnings(\"UnusedDeclaration\")\n    public boolean isWebm() { return \".webm\".equals(mediaExtension); }\n\n    // Only used internally, no counterpart in 4Chan API\n    public int replyCount;\n\n    // TODO: should be handled by threadmanager...\n    // Transient helper state\n    public int thumbMutedColor = -1;\n\n    // Used internally to speed up rendering by temporary caching\n    // It would be better to persist the parsedText but SpannableString is not parcelable by default\n    @Transient transient private CharSequence parsedText;\n    public void generateParsedTextCache() {\n        if (parsedText == null) {\n            String s = subject; if (s == null) s = \"\"; else s = \"<h5>\" + s + \"</h5>\";\n            String t = text; if (t == null) t = \"\";\n            parsedText = CommentParser.getInstance().parseComment(this, s + t);\n        }\n    }\n    public CharSequence parsedText() {\n        generateParsedTextCache();\n        return parsedText;\n    }\n}\nsrc/main/java/anabolicandroids/chanobol/ui/posts/parsing/ThreadLink.java\npublic class ThreadLink {\n    public String board;\n    public String threadNumber;\n    public String postNumber;\n\n    public ThreadLink(String board, String threadNumber, String postNumber) {\n        this.board = board;\n        this.threadNumber = threadNumber;\n        this.postNumber = postNumber;\n    }\n}\nsrc/main/java/anabolicandroids/chanobol/ui/scaffolding/UiActivity.java\npublic abstract class UiActivity extends BaseActivity {\n\n    // Holy shit, why this error?: https://gist.github.com/eugenkiss/1b4864ad7373ca5ce074\n    // It is impossible for me to remove this static variable even though it is not used anymore\n    // Syncing, cleaning, invalidating, restarting, building on command line, nothing helps.\n    public static int RIPPLE_DELAY = Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP ?\n            250 : 50;\n    // So that the user is even able to see the ripple effect before the next activity launches\n    // Method instead of value because Android might static values\n    public static int RIPPLE_DELAY() {\n        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP ?\n            250 : 50;\n    }\n\n    // Construction ////////////////////////////////////////////////////////////////////////////////\n\n    @Inject @SfwMode boolean sfw;\n    @Inject @Named(\"DebugSettings\") Class debugSettingsClass;\n    @Inject @ForApplication public Context appContext;\n    @Inject public App app;\n    @Inject public Resources resources;\n    @Inject public Prefs prefs;\n    @Inject public PersistentData persistentData;\n    @Inject public ChanService service;\n    @Inject public Ion ion;\n\n    @InjectView(R.id.toolbar) public Toolbar toolbar;\n    @InjectView(R.id.toolbarShadow) public ImageView toolbarShadow;\n    @InjectView(R.id.loadingBar) public ProgressBar loadingBar;\n    @InjectView(R.id.drawerLayout) public DrawerLayout drawerLayout;\n    @InjectView(R.id.drawer) public View drawer;\n    @InjectView(R.id.allBoards) public TextView allBoards;\n    @InjectView(R.id.debugSettings) public TextView debugSettings;\n    @InjectView(R.id.favoriteBoardsHeader) public TextView favoriteBoardsHeader;\n    @InjectView(R.id.favoriteBoards) public ListView favoriteBoardsView;\n    @InjectView(R.id.watchlistHeader) public TextView watchlistHeader;\n    @InjectView(R.id.watchlist) public ListView watchlistView;\n\n    public ActionBarDrawerToggle drawerToggle;\n    public FavoritesAdapter favoriteBoardsAdapter;\n    public WatchlistAdapter watchlistAdapter;\n    // http://stackoverflow.com/q/17702202/283607\n    public boolean taskRoot;\n\n    abstract protected int getLayoutResource();\n\n    protected View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        return inflater.inflate(getLayoutResource(), container, false);\n    }\n\n    protected RecyclerView getRootRecyclerView() { return null; }\n\n    @Override protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Util.setTheme(this, prefs);\n        getWindow().setBackgroundDrawableResource(prefs.theme().isLightTheme ? R.color.bgLight : R.color.bgDark);\n        setContentView(R.layout.activity_ui);\n        ViewGroup container = (ViewGroup) findViewById(R.id.container);\n        container.addView(onCreateView(getLayoutInflater(), container, savedInstanceState));\n        ButterKnife.inject(this);\n\n        if (BuildConfig.DEBUG) debugSettings.setVisibility(View.VISIBLE);\n        if (sfw) allBoards.setVisibility(View.GONE);\n\n        setSupportActionBar(toolbar);\n        setupDrawer();\n        setupFavoritesInDrawer();\n        setupWatchlistInDrawer();\n        RecyclerView rv = getRootRecyclerView(); if (rv != null) setupQuickReturnToolbar(rv);\n        updateUpButtonState();\n    }\n\n    private void setupDrawer() {\n        drawerToggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar,\n                R.string.navigation_drawer_open, R.string.navigation_drawer_close);\n        drawerToggle.setToolbarNavigationClickListener(toolbarNavCallback);\n        drawerLayout.setDrawerListener(drawerToggle);\n    }\n\n    private void setupFavoritesInDrawer() {\n        favoriteBoardsAdapter = new FavoritesAdapter(this, new ArrayList<>(persistentData.getFavorites()));\n        favoriteBoardsView.setAdapter(favoriteBoardsAdapter);\n        favoriteBoardsAdapter.notifyDataSetChanged();\n        persistentData.addFavoritesChangedCallback(favoritesChangedCallback);\n        favoriteBoardsView.setOnItemClickListener(favoriteClickCallback);\n        favoriteBoardsView.setOnItemLongClickListener(favoritesLongClickCallback);\n        setVisibility(favoriteBoardsHeader, persistentData.getFavorites().size() != 0);\n    }\n\n    private void setupWatchlistInDrawer() {\n        watchlistAdapter = new WatchlistAdapter(this, new ArrayList<>(persistentData.getWatchlist()));\n        watchlistView.setAdapter(watchlistAdapter);\n        watchlistAdapter.notifyDataSetChanged();\n        persistentData.addWatchlistChangedCallback(watchlistChangedCallback);\n        watchlistView.setOnItemClickListener(watchlistClickCallback);\n        watchlistView.setOnItemLongClickListener(watchlistLongClickCallback);\n        setVisibility(watchlistHeader, persistentData.getWatchlist().size() != 0);\n    }\n\n    private void updateUpButtonState() {\n        if (!taskRoot) {\n            drawerToggle.setDrawerIndicatorEnabled(false);\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        } else {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(false);\n            drawerToggle.setDrawerIndicatorEnabled(true);\n            drawerToggle.syncState();\n        }\n    }\n\n    // http://www.reddit.com/r/androiddev/comments/2sqcth/play_stores_autohiding_toolbar_hows_it_implemented/\n    private void setupQuickReturnToolbar(RecyclerView rv) {\n        // I'd love to just use `toolbar.getHeight()` but it might not yet be known\n        // at this point. Going the global layout listener route led to jumps.\n        // One could combine both approaches but as long as the toolbar's height is\n        // fixed and known beforehand anyway why go through the trouble...\n        int actionBarHeight = Util.getActionBarHeight(this);\n        rv.setPadding(\n                rv.getPaddingLeft(),\n                rv.getPaddingTop() + actionBarHeight,\n                rv.getPaddingRight(),\n                rv.getPaddingBottom());\n        if (Build.VERSION.SDK_INT >= 11) {\n            rv.setOnScrollListener(new RecyclerView.OnScrollListener() {\n                @TargetApi(Build.VERSION_CODES.HONEYCOMB) @Override\n                public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n                    if (!prefs.hidableToolbar()) return;\n                    float y = Util.clamp(-toolbar.getHeight(), toolbar.getTranslationY() - dy, 0);\n                    toolbar.setTranslationY(y);\n                    toolbarShadow.setTranslationY(y);\n                }\n            });\n        } else {\n            rv.setOnScrollListener(new RecyclerView.OnScrollListener() {\n                @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n                    if (!prefs.hidableToolbar()) return;\n                    float y = Util.clamp(-toolbar.getHeight(), ViewHelper.getTranslationY(toolbar) - dy, 0);\n                    ViewHelper.setTranslationY(toolbar, y);\n                    ViewHelper.setTranslationY(toolbarShadow, y);\n                }\n            });\n        }\n    }\n\n    // Callbacks ///////////////////////////////////////////////////////////////////////////////////\n\n    private View.OnClickListener toolbarNavCallback = new View.OnClickListener() {\n        @Override public void onClick(View v) {\n            if (!drawerToggle.isDrawerIndicatorEnabled()) {\n                onBackPressed();\n            }\n        }\n    };\n\n    private AdapterView.OnItemClickListener favoriteClickCallback = new AdapterView.OnItemClickListener() {\n        @Override public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n            final Board board = favoriteBoardsAdapter.getItem(position);\n            FavoritesActivity.launch(UiActivity.this);\n            ThreadsActivity.launch(UiActivity.this, board);\n        }\n    };\n    private AdapterView.OnItemLongClickListener favoritesLongClickCallback = new AdapterView.OnItemLongClickListener() {\n        @Override public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {\n            final Board board = favoriteBoardsAdapter.getItem(position);\n            new AlertDialog.Builder(UiActivity.this)\n                    .setTitle(R.string.delete_title)\n                    .setNegativeButton(android.R.string.cancel, null)\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n                        public void onClick(DialogInterface dialog, int whichButton) {\n                            persistentData.removeFavorite(board);\n                        }\n                    }).show();\n            return true;\n        }\n    };\n\n    private PersistentData.FavoritesCallback favoritesChangedCallback = new PersistentData.FavoritesCallback() {\n        @Override public void onChanged(Set<Board> newFavorites) {\n            favoriteBoardsAdapter.updateItems(new ArrayList<>(newFavorites));\n            setVisibility(favoriteBoardsHeader, !newFavorites.isEmpty());\n        }\n    };\n\n    private AdapterView.OnItemClickListener watchlistClickCallback = new AdapterView.OnItemClickListener() {\n        @Override public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n            PersistentData.WatchlistEntry entry = watchlistAdapter.getItem(position);\n            final Thread thread = persistentData.getWatchlistThread(entry.id);\n            if (thread == null) {\n                showToast(R.string.corrupted_thread);\n            } else {\n                drawerLayout.closeDrawers();\n                view.postDelayed(new Runnable() {\n                    @Override public void run() {\n                        PostsActivity.launchFromNavbarWatchlist(UiActivity.this, thread, prefs.excludeWatchtaskRecents());\n                    }\n                }, RIPPLE_DELAY());\n            }\n        }\n    };\n    private AdapterView.OnItemLongClickListener watchlistLongClickCallback = new AdapterView.OnItemLongClickListener() {\n        @Override public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {\n            final PersistentData.WatchlistEntry entry = watchlistAdapter.getItem(position);\n            new AlertDialog.Builder(UiActivity.this)\n                    .setTitle(R.string.delete_title)\n                    .setNegativeButton(android.R.string.cancel, null)\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n                        public void onClick(DialogInterface dialog, int whichButton) {\n                            persistentData.removeWatchlistThread(entry);\n                        }\n                    }).show();\n            return true;\n        }\n    };\n\n    private PersistentData.WatchlistCallback watchlistChangedCallback = new PersistentData.WatchlistCallback() {\n        @Override public void onChanged(Set<PersistentData.WatchlistEntry> newWatchlist) {\n            watchlistAdapter.updateItems(new ArrayList<>(newWatchlist));\n            setVisibility(watchlistHeader, !newWatchlist.isEmpty());\n        }\n    };\n\n    @OnClick(R.id.allBoards) void onAllBoards() {\n        BoardsActivity.launch(this);\n    }\n\n    @OnClick(R.id.favoriteBoardsBtn) void onFavoriteBoards() {\n        FavoritesActivity.launch(this);\n    }\n\n    @OnClick(R.id.watchlistBtn) void onWatchlist() {\n        drawerLayout.closeDrawers();\n        favoriteBoardsView.postDelayed(new Runnable() {\n            @Override public void run() {\n                ThreadsActivity.launchForWatchlist(UiActivity.this, prefs.excludeWatchtaskRecents());\n            }\n        }, RIPPLE_DELAY());\n    }\n\n    @OnClick(R.id.settings) void onSettings() {\n        Intent intent = new Intent(this, Settings.class);\n        startActivity(intent);\n    }\n\n    @Optional @OnClick(R.id.debugSettings) void onDebugSettings() {\n        if (debugSettingsClass == null) return; // see https://github.com/eugenkiss/chanobol/issues/137\n        Intent intent = new Intent(this, debugSettingsClass);\n        startActivity(intent);\n    }\n\n    @OnClick(R.id.about) void onAbout() {\n        AlertDialog d = new AlertDialog.Builder(this)\n                .setTitle(R.string.about_app_title)\n                .setMessage(Html.fromHtml(getResources().getString(R.string.about_app)))\n                .setPositiveButton(android.R.string.ok, null)\n                .show();\n\n        ((TextView)d.findViewById(android.R.id.message))\n                .setMovementMethod(LinkMovementMethod.getInstance());\n    }\n\n    @Override public void onBackPressed() {\n        if (drawerLayout.isDrawerOpen(drawer)) {\n            drawerLayout.closeDrawers();\n        } else if (getSupportFragmentManager().getBackStackEntryCount() > 0) {\n            super.onBackPressed();\n        } else if (this instanceof WatchlistThreadsActivity || this instanceof WatchlistPostsActivity) {\n            super.onBackPressed();\n        } else if (isTaskRoot() || taskRoot) {\n            new AlertDialog.Builder(this)\n                    .setMessage(R.string.exit_sure)\n                    .setCancelable(false)\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n                        public void onClick(DialogInterface dialog, int id) {\n                            App.firstStart = true;\n                            finish();\n                        }\n                    })\n                    .setNegativeButton(android.R.string.cancel, null)\n                    .show();\n        } else {\n            super.onBackPressed();\n        }\n    }\n\n    // Data Loading ////////////////////////////////////////////////////////////////////////////////\n\n    protected boolean loading;\n\n    protected void load() {\n        loading = true;\n        loadingBar.setVisibility(View.VISIBLE);\n    }\n\n    protected void loaded() {\n        loading = false;\n        loadingBar.setVisibility(View.GONE);\n    }\n\n    protected void cancelPending() {\n        loading = false;\n        loadingBar.setVisibility(View.GONE);\n    }\n\n    // Lifecycle ///////////////////////////////////////////////////////////////////////////////////\n\n    @Override protected void onResume() {\n        super.onResume();\n        if (App.needToProtractToolbar) {\n            showToolbar();\n            App.needToProtractToolbar = false;\n        }\n    }\n\n    @Override protected void onPostCreate(Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n        drawerToggle.syncState();\n    }\n\n    @Override public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        drawerToggle.onConfigurationChanged(newConfig);\n    }\n\n    @Override public void onDestroy() {\n        cancelPending();\n        // The object `persistentData` is a singleton and on the first start a callback is added\n        // which closes over favoriteBoardsAdapter which itself has a necessary reference to the\n        // activity. If the activity is recreated then that callback keeps a reference to the old\n        // activity and it won't be collected. To prevent this memory leak remove the callback\n        // when the respective activity is destroyed.\n        persistentData.removeFavoritesChangedCallback(favoritesChangedCallback);\n        persistentData.removeWatchlistChangedCallback(watchlistChangedCallback);\n        super.onDestroy();\n    }\n\n    // Toolbar Menu ////////////////////////////////////////////////////////////////////////////////\n\n    @Override public boolean onOptionsItemSelected(MenuItem item) {\n        if (drawerToggle.isDrawerIndicatorEnabled() &&\n                drawerToggle.onOptionsItemSelected(item)) return true;\n        return super.onOptionsItemSelected(item);\n    }\n\n    // Animations //////////////////////////////////////////////////////////////////////////////////\n\n    public static int dur = 120;\n\n    public void showToolbar() {\n        if (Build.VERSION.SDK_INT >= 14) {\n            toolbar.animate().y(0).setDuration(dur);\n            toolbarShadow.animate().y(0).setDuration(dur);\n        }\n        else {\n            Util.animateY(toolbar, toolbar.getTop(), 0, dur);\n            Util.animateY(toolbarShadow, toolbarShadow.getTop(), 0, dur);\n        }\n    }\n\n    @SuppressWarnings(\"UnusedDeclaration\")\n    public void hideToolbar() {\n        if (!prefs.hidableToolbar()) return;\n        if (Build.VERSION.SDK_INT >= 14)\n            toolbar.animate().y(-toolbar.getHeight()).setDuration(dur);\n        else\n            Util.animateY(toolbar, 0, -toolbar.getHeight(), dur);\n    }\n\n    // Utility /////////////////////////////////////////////////////////////////////////////////////\n\n    public void freeMemory() {\n        ion.configure().getResponseCache().clear();\n        ion.getBitmapCache().clear();\n        System.gc();\n    }\n\n    public void setVisibility(View view, boolean show) {\n        Util.setVisibility(view, show);\n    }\n\n    @SuppressWarnings(\"UnusedDeclaration\")\n    protected void showToast(int res) { Util.showToast(appContext, res); }\n    protected void showToast(String msg) { Util.showToast(appContext, msg); }\n\n    // In order to not repeat shared status-, navigation- and toolbar.\n    // http://stackoverflow.com/a/26748694/283607\n    @SuppressWarnings(\"ConstantConditions\") @SafeVarargs\n    public static ActivityOptionsCompat makeSceneTransitionAnimation(Activity activity, Pair<View, String>... shared)  {\n        List<Pair<View, String>> pairs = new ArrayList<>();\n        // Because of the following crash on some devices I need to be extra careful:\n        // \"java.lang.IllegalArgumentException: Shared element must not be null\"\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            View v; String s;\n            v = activity.findViewById(android.R.id.navigationBarBackground);\n            s = Window.NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME;\n            if (v != null && s != null) pairs.add(Pair.create(v, s));\n            v = activity.findViewById(android.R.id.statusBarBackground);\n            s = Window.STATUS_BAR_BACKGROUND_TRANSITION_NAME;\n            if (v != null && s != null) pairs.add(Pair.create(v, s));\n            // Assumed that toolbar in layout has transitionname 'toolbar'\n            v = activity.findViewById(R.id.toolbar);\n            s = \"toolbar\";\n            if (v != null && s != null) pairs.add(Pair.create(v, s));\n            // The custom elements\n            for (Pair<View, String> p : shared) {\n                v = p.first;\n                s = p.second;\n                if (v != null && s != null) pairs.add(Pair.create(v, s));\n            }\n        }\n        //noinspection unchecked\n        return ActivityOptionsCompat.makeSceneTransitionAnimation(activity, pairs.toArray(new Pair[pairs.size()]));\n    }\n\n    // Adapters ////////////////////////////////////////////////////////////////////////////////////\n\n    private static class FavoritesAdapter extends BindableAdapter<Board> {\n        private List<Board> items;\n\n        public FavoritesAdapter(Context context, List<Board> items) {\n            super(context);\n            this.items = items;\n        }\n\n        public void updateItems(List<Board> items) {\n            this.items = items;\n            notifyDataSetChanged();\n        }\n\n        @Override\n        public View newView(LayoutInflater inflater, int position, ViewGroup container) {\n            return inflater.inflate(R.layout.view_favorite, container, false);\n        }\n\n        @Override\n        public void bindView(Board item, int position, View view) {\n            ((FavoriteView) view).bindTo(item);\n        }\n\n        @Override public int getCount() { return items.size(); }\n        @Override public Board getItem(int position) { return items.get(position); }\n        @Override public long getItemId(int position) { return position; }\n    }\n\n    public static class FavoriteView extends LinearLayout {\n        @InjectView(R.id.shortName) TextView shortName;\n        @InjectView(R.id.longName) TextView longName;\n\n        public FavoriteView(Context context, AttributeSet attrs) {\n            super(context, attrs);\n        }\n\n        @Override protected void onFinishInflate() {\n            super.onFinishInflate();\n            ButterKnife.inject(this);\n        }\n\n        public void bindTo(Board board) {\n            shortName.setText(board.name);\n            longName.setText(board.title);\n        }\n    }\n\n    private static class WatchlistAdapter extends BindableAdapter<PersistentData.WatchlistEntry> {\n        private List<PersistentData.WatchlistEntry> items;\n\n        public WatchlistAdapter(Context context, List<PersistentData.WatchlistEntry> items) {\n            super(context);\n            this.items = items;\n        }\n\n        public void updateItems(List<PersistentData.WatchlistEntry> items) {\n            this.items = items;\n            notifyDataSetChanged();\n        }\n\n        @Override\n        public View newView(LayoutInflater inflater, int position, ViewGroup container) {\n            return inflater.inflate(R.layout.view_watchlist_thread, container, false);\n        }\n\n        @Override\n        public void bindView(PersistentData.WatchlistEntry item, int position, View view) {\n            ((WatchlistThreadView) view).bindTo(item);\n        }\n\n        @Override public int getCount() { return items.size(); }\n        @Override public PersistentData.WatchlistEntry getItem(int position) { return items.get(position); }\n        @Override public long getItemId(int position) { return position; }\n    }\n\n    public static class WatchlistThreadView extends LinearLayout {\n        @InjectView(R.id.name) TextView name;\n\n        public WatchlistThreadView(Context context, AttributeSet attrs) {\n            super(context, attrs);\n        }\n\n        @Override protected void onFinishInflate() {\n            super.onFinishInflate();\n            ButterKnife.inject(this);\n        }\n\n        public void bindTo(PersistentData.WatchlistEntry thread) {\n            name.setText(thread.title);\n        }\n    }\n\n    // Workarounds /////////////////////////////////////////////////////////////////////////////////\n\n    // See http://stackoverflow.com/a/27024610/283607\n    @Override public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_MENU && \"LGE\".equalsIgnoreCase(Build.BRAND)) {\n            return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    @Override public boolean onKeyUp(int keyCode, @NonNull KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_MENU && \"LGE\".equalsIgnoreCase(Build.BRAND)) {\n            openOptionsMenu();\n            return true;\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n}\nsrc/main/java/anabolicandroids/chanobol/ui/posts/parsing/QuoteSpan.java\npublic class QuoteSpan extends PostSpan {\n\n    public final String quoterId, quotedId;\n\n    public QuoteSpan(String quoterId, String quotedId) {\n        this.quoterId = quoterId;\n        this.quotedId = quotedId;\n    }\n\n    @Override public void updateDrawState(@NonNull TextPaint ds) {\n        ds.setColor(ThemeContext.getInstance().quoteColor);\n        ds.setUnderlineText(true);\n    }\n}\n", "answers": ["    public Prefs prefs;"], "length": 3533, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "10293155fe04c32cb8085fd71357b5f0ca2693104e6232aa"}
{"input": "import subprocess\nimport os\nimport re\nimport shutil\nimport tarfile\nimport ntpath\nimport io\nimport json\nimport random\nimport time\nimport socket\nimport unicodedata\nimport threading\nimport base64\nimport sqlite3 as sq\nfrom django.shortcuts import render\nfrom django.conf import settings\nfrom django.template.defaulttags import register\nfrom django.http import HttpResponseRedirect, HttpResponse\nfrom django.utils.html import escape\nfrom StaticAnalyzer.models import StaticAnalyzerAndroid\nfrom DynamicAnalyzer.pyWebProxy.pywebproxy import Proxy\nfrom DynamicAnalyzer.views.android.android_avd import (\n    avd_load_wait,\n    refresh_avd,\n    stop_avd\n)\nfrom DynamicAnalyzer.views.android.android_virtualbox_vm import (\n    refresh_vm\n)\nfrom DynamicAnalyzer.views.android.android_dyn_shared import (\n    connect,\n    install_and_run,\n    web_proxy,\n    get_res,\n    get_identifier,\n    wait,\n)\nfrom MobSF.utils import PrintException, is_number, python_list, isBase64, getADB\nfrom MalwareAnalyzer.views import MalwareCheck\n\"\"\"Core Functions of Android Dynamic Analysis\"\"\"\n# -*- coding: utf_8 -*-\n\n\n\n#===========================================\n# Dynamic Analyzer Related Views for Android\n#===========================================\n\n\n'''\nNeed to improve RCE Detection on Framework, audit all subprocess calls\nTCP Connnection to screenshot service needs to be secured.\nGlobals!\n'''\n\nTCP_SERVER_MODE = \"off\"  # ScreenCast TCP Service Status\n\n\n@register.filter\ndef key(d, key_name):\n    \"\"\"To get dict element by key name in template\"\"\"\n    return d.get(key_name)\n\n\ndef android_dynamic_analyzer(request):\n    \"\"\"Android Dynamic Analyzer View\"\"\"\n    print \"\\n[INFO] Dynamic Analysis Started\"\n    try:\n        if request.method == 'POST':\n            md5_hash = request.POST['md5']\n            package = request.POST['pkg']\n            launcher = request.POST['lng']\n            if re.findall(r';|\\$\\(|\\|\\||&&', package) or re.findall(r';|\\$\\(|\\|\\||&&', launcher):\n                print \"[ATTACK] Possible RCE\"\n                return HttpResponseRedirect('/error/')\n            if re.match('^[0-9a-f]{32}$', md5_hash):\n                # Delete ScreenCast Cache\n                screen_file = os.path.join(settings.SCREEN_DIR, 'screen.png')\n                if os.path.exists(screen_file):\n                    os.remove(screen_file)\n                # Delete Contents of Screenshot Dir\n                screen_dir = os.path.join(\n                    settings.UPLD_DIR, md5_hash + '/screenshots-apk/')\n                if os.path.isdir(screen_dir):\n                    shutil.rmtree(screen_dir)\n                else:\n                    os.makedirs(screen_dir)\n                # Start DM\n                Proxy(\"\", \"\", \"\", \"\")\n                toolsdir = os.path.join(\n                    settings.BASE_DIR, 'DynamicAnalyzer/tools/')  # TOOLS DIR\n                adb = getADB(toolsdir)\n                if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n                    print \"\\n[INFO] MobSF will perform Dynamic Analysis on real Android Device\"\n                    is_avd = False\n                elif settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_AVD\":\n                    # adb, avd_path, reference_name, dup_name, emulator\n                    is_avd = True\n                    refresh_avd(adb, settings.AVD_PATH, settings.AVD_REFERENCE_NAME,\n                                settings.AVD_DUP_NAME, settings.AVD_EMULATOR)\n                else:\n                    # Refersh VM\n                    is_avd = False\n                    refresh_vm(settings.UUID, settings.SUUID, settings.VBOX)\n                context = {'md5': md5_hash,\n                           'pkg': package,\n                           'lng': launcher,\n                           'title': 'Start Testing',\n                           'AVD': is_avd, }\n                template = \"dynamic_analysis/start_test.html\"\n                return render(request, template, context)\n            else:\n                return HttpResponseRedirect('/error/')\n        else:\n            return HttpResponseRedirect('/error/')\n    except:\n        PrintException(\"[ERROR] DynamicAnalyzer\")\n        return HttpResponseRedirect('/error/')\n\n# AJAX\n\n\ndef get_env(request):\n    \"\"\"Get Dynamic Analysis Environment for Android\"\"\"\n    print \"\\n[INFO] Setting up Dynamic Analysis Environment\"\n    try:\n        if request.method == 'POST':\n            data = {}\n            md5_hash = request.POST['md5']\n            package = request.POST['pkg']\n            launcher = request.POST['lng']\n            if re.findall(r\";|\\$\\(|\\|\\||&&\", package) or re.findall(r\";|\\$\\(|\\|\\||&&\", launcher):\n                print \"[ATTACK] Possible RCE\"\n                return HttpResponseRedirect('/error/')\n            if re.match('^[0-9a-f]{32}$', md5_hash):\n                base_dir = settings.BASE_DIR\n                app_dir = os.path.join(\n                    settings.UPLD_DIR, md5_hash + '/')  # APP DIRECTORY\n                app_file = md5_hash + '.apk'  # NEW FILENAME\n                app_path = app_dir + app_file  # APP PATH\n                toolsdir = os.path.join(\n                    base_dir, 'DynamicAnalyzer/tools/')  # TOOLS DIR\n                adb = getADB(toolsdir)\n                if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_AVD\":\n                    proxy_ip = '127.0.0.1'\n                else:\n                    proxy_ip = settings.PROXY_IP  # Proxy IP\n                port = str(settings.PORT)  # Proxy Port\n                web_proxy(app_dir, proxy_ip, port)\n                # AVD only needs to wait, vm needs the connect function\n                if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_AVD\":\n                    if not avd_load_wait(adb):\n                        print \"\\n[WARNING] ADB Load Wait Failed\"\n                        return HttpResponseRedirect('/error/')\n                else:\n                    connect(toolsdir)\n                # Change True to support non-activity components\n", "context": "MalwareAnalyzer/views.py\ndef MalwareCheck(urllist):\n    RESULT = {}\n    domainlist = list()\n    try:\n        domainlist = getDomains(urllist)\n        if domainlist:\n            if isInternetAvailable():\n                UpdateDB()\n            else:\n                print \"\\n[WARNING] No Internet Connection. Skipping Malware Database Update.\"\n            DB = os.path.join(MALWARE_DB_DIR, 'malwaredomainlist')\n            with io.open(DB, mode='r', encoding=\"utf8\", errors=\"ignore\") as f:\n                entry_list = f.readlines()\n            for entry in entry_list:\n                enlist = entry.split('\",\"')\n                if len(enlist) > 5:\n                    details_dict = dict()\n                    details_dict[\"domain_or_url\"] = enlist[1]\n                    details_dict[\"ip\"] = enlist[2]\n                    details_dict[\"desc\"] = enlist[4]\n                    details_dict[\"bad\"] = \"yes\"\n                    for domain in domainlist:\n                        if (domain in details_dict[\"domain_or_url\"]) or (domain in details_dict[\"ip\"]):\n                            RESULT[domain] = details_dict\n            for domain in domainlist:\n                if domain not in RESULT:\n                    x = dict()\n                    x[\"bad\"] = \"no\"\n                    RESULT[domain] = x\n    except:\n        PrintException(\"[ERROR] Performing Malware Check\")\n    return RESULT\nMobSF/utils.py\ndef isBase64(str):\n    return re.match('^[A-Za-z0-9+/]+[=]{0,2}$', str)\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef web_proxy(apk_dir, ip_address, port):\n    \"\"\"Run MITM Proxy\"\"\"\n    print \"\\n[INFO] Starting Web Proxy\"\n    try:\n        Proxy(ip_address, port, apk_dir, \"on\")\n    except:\n        PrintException(\"[ERROR] Starting Web Proxy\")\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef get_identifier():\n    \"\"\"Get Device Type\"\"\"\n    try:\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n            return settings.DEVICE_IP + \":\" + str(settings.DEVICE_ADB_PORT)\n        elif settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_AVD\":\n            return 'emulator-' + str(settings.AVD_ADB_PORT)\n        else:\n            return settings.VM_IP + \":\" + str(settings.VM_ADB_PORT)\n    except:\n        PrintException(\n            \"[ERROR] Getting ADB Connection Identifier for Device/VM\")\nDynamicAnalyzer/views/android/android_virtualbox_vm.py\ndef refresh_vm(uuid, snapshot_uuid, vbox_exe):\n    \"\"\"Refresh VirtualBox based VMs\"\"\"\n    print \"\\n[INFO] Refreshing MobSF VM\"\n    try:\n        # Close VM\n        args = [vbox_exe, 'controlvm', uuid, 'poweroff']\n        subprocess.call(args)\n        # changed by davidblus\n        time.sleep(2)\n        print \"\\n[INFO] VM Closed\"\n        # Restore Snapshot\n        args = [vbox_exe, 'snapshot', uuid, 'restore', snapshot_uuid]\n        subprocess.call(args)\n        print \"\\n[INFO] VM Restore Snapshot\"\n        # Start Fresh VM\n        args = [vbox_exe, 'startvm', uuid]\n        subprocess.call(args)\n        print \"\\n[INFO] VM Starting\"\n    except:\n        PrintException(\"[ERROR] Refreshing MobSF VM\")\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef get_res():\n    \"\"\"Get Screen Resolution or Device or VM\"\"\"\n    print \"\\n[INFO] Getting Screen Resolution\"\n    try:\n        toolsdir = os.path.join(\n            settings.BASE_DIR, 'DynamicAnalyzer/tools/')  # TOOLS DIR\n        adb = getADB(toolsdir)\n        resp = subprocess.check_output(\n            [adb, \"-s\", get_identifier(), \"shell\", \"dumpsys\", \"window\"])\n        resp = resp.split(\"\\n\")\n        res = \"\"\n        for line in resp:\n            if \"mUnrestrictedScreen\" in line:\n                res = line\n                break\n        res = res.split(\"(0,0)\")[1]\n        res = res.strip()\n        res = res.split(\"x\")\n        if len(res) == 2:\n            return res[0], res[1]\n            # width, height\n        return \"\", \"\"\n    except:\n        PrintException(\"[ERROR] Getting Screen Resolution\")\n        return \"\", \"\"\nDynamicAnalyzer/pyWebProxy/pywebproxy.py\ndef Proxy(IP, PORT, LOG, STAT):\n    global kill, log\n    if STAT == \"on\":\n        log = LOG\n        kill = False\n        print \"\\n[INFO] Started Web Proxy at \" + IP + \":\" + PORT\n        threading.Thread(target=startTornado, kwargs=dict(\n            IP=IP, PORT=PORT, log=log)).start()\n    else:\n        print \"\\n[INFO] Stopping any running instance of WebProxy\"\n        kill = True\nMobSF/utils.py\ndef getADB(TOOLSDIR):\n    \"\"\"Get ADB binary path\"\"\"\n    try:\n        if len(settings.ADB_BINARY) > 0 and isFileExists(settings.ADB_BINARY):\n            return settings.ADB_BINARY\n        else:\n            adb = 'adb'\n            if platform.system() == \"Darwin\":\n                adb_dir = os.path.join(TOOLSDIR, 'adb/mac/')\n                subprocess.call([\"chmod\", \"777\", adb_dir])\n                adb = os.path.join(TOOLSDIR, 'adb/mac/adb')\n            elif platform.system() == \"Linux\":\n                adb_dir = os.path.join(TOOLSDIR, 'adb/linux/')\n                subprocess.call([\"chmod\", \"777\", adb_dir])\n                adb = os.path.join(TOOLSDIR, 'adb/linux/adb')\n            elif platform.system() == \"Windows\":\n                adb = os.path.join(TOOLSDIR, 'adb/windows/adb.exe')\n            return adb\n    except:\n        PrintException(\"[ERROR] Getting ADB Location\")\n        return \"adb\"\nStaticAnalyzer/models.py\nclass StaticAnalyzerAndroid(models.Model):\n    TITLE = models.TextField()\n    APP_NAME = models.TextField()\n    SIZE = models.CharField(max_length=50)\n    MD5 = models.CharField(max_length=32)\n    SHA1 = models.TextField()\n    SHA256 = models.TextField()\n    PACKAGENAME = models.TextField()\n    MAINACTIVITY = models.TextField()\n    TARGET_SDK = models.CharField(max_length=50)\n    MAX_SDK = models.CharField(max_length=50)\n    MIN_SDK = models.CharField(max_length=50)\n    ANDROVERNAME = models.CharField(max_length=100)\n    ANDROVER = models.CharField(max_length=50)\n    MANIFEST_ANAL = models.TextField()\n    PERMISSIONS = models.TextField()\n    BIN_ANALYSIS = models.TextField()\n    FILES = models.TextField()\n    CERTZ = models.TextField()\n    ACTIVITIES = models.TextField()\n    RECEIVERS = models.TextField()\n    PROVIDERS = models.TextField()\n    SERVICES = models.TextField()\n    LIBRARIES = models.TextField()\n    BROWSABLE = models.TextField()\n    CNT_ACT = models.CharField(max_length=50)\n    CNT_PRO = models.CharField(max_length=50)\n    CNT_SER = models.CharField(max_length=50)\n    CNT_BRO = models.CharField(max_length=50)\n    CERT_INFO = models.TextField()\n    ISSUED = models.CharField(max_length=10)\n    NATIVE = models.CharField(max_length=50)\n    DYNAMIC = models.CharField(max_length=50)\n    REFLECT = models.CharField(max_length=50)\n    CRYPTO = models.CharField(max_length=50)\n    OBFUS = models.CharField(max_length=50)\n    API = models.TextField()\n    DANG = models.TextField()\n    URLS = models.TextField()\n    DOMAINS = models.TextField()\n    EMAILS = models.TextField()\n    STRINGS = models.TextField()\n    ZIPPED = models.TextField()\n    MANI = models.TextField()\n    EXPORTED_ACT = models.TextField()\n    E_ACT = models.CharField(max_length=50)\n    E_SER = models.CharField(max_length=50)\n    E_BRO = models.CharField(max_length=50)\n    E_CNT = models.CharField(max_length=50)\n    APK_ID = models.TextField()\nDynamicAnalyzer/views/android/android_avd.py\ndef stop_avd(adb):\n    \"\"\"Stop AVD\"\"\"\n    print \"\\n[INFO] Stopping MobSF Emulator\"\n    try:\n        # adb -s emulator-xxxx emu kill\n        FNULL = open(os.devnull, 'w')\n        args = [adb, '-s', get_identifier(), 'emu', 'kill']\n        subprocess.call(args, stderr=FNULL)\n    except:\n        PrintException(\"[ERROR] Stopping MobSF Emulator\")\nDynamicAnalyzer/views/android/android_avd.py\ndef refresh_avd(adb, avd_path, reference_name, dup_name, emulator):\n    \"\"\"Refresh AVD\"\"\"\n    print \"\\n[INFO] Refreshing MobSF Emulator\"\n    try:\n        # Stop existing emulator on the spesified port\n        stop_avd(adb)\n\n        # Windows has annoying lock system, it takes time for it to remove the locks after we stopped the emulator\n        if platform.system() == 'Windows':\n            time.sleep(3)\n\n        # Delete old emulator\n        delete_avd(avd_path, dup_name)\n\n        # Copy and replace the contents of the reference machine\n        duplicate_avd(avd_path, reference_name, dup_name)\n\n        # Start emulator\n        start_avd(emulator, dup_name, settings.AVD_ADB_PORT)\n    except:\n        PrintException(\"[ERROR] Refreshing MobSF VM\")\nMobSF/utils.py\ndef is_number(s):\n    try:\n        float(s)\n        return True\n    except ValueError:\n        pass\n    try:\n        unicodedata.numeric(s)\n        return True\n    except (TypeError, ValueError):\n        pass\n    return False\nDynamicAnalyzer/views/android/android_avd.py\ndef avd_load_wait(adb):\n    \"\"\"Wait for AVD Load\"\"\"\n    try:\n        emulator = get_identifier()\n\n        print \"[INFO] Wait for emulator to load\"\n        args = [adb,\n                \"-s\",\n                emulator,\n                \"wait-for-device\"]\n        subprocess.call(args)\n\n        print \"[INFO] Wait for dev.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"dev.bootcomplete\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"1\":\n                break\n            else:\n                time.sleep(1)\n\n        print \"[INFO] Wait for sys.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"sys.boot_completed\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"1\":\n                break\n            else:\n                time.sleep(1)\n\n        print \"[INFO] Wait for svc.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"init.svc.bootanim\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"stopped\":\n                break\n            else:\n                time.sleep(1)\n        time.sleep(5)\n        # Remount the partitions for RW\n        subprocess.call([adb, \"-s\", emulator, \"remount\"])\n        return True\n    except:\n        PrintException(\"[ERROR] emulator did not boot properly\")\n        return False\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef connect(toolsdir):\n    \"\"\"Connect to VM/Device\"\"\"\n    print \"\\n[INFO] Connecting to VM/Device\"\n    try:\n        adb = getADB(toolsdir)\n        subprocess.call([adb, \"kill-server\"])\n        subprocess.call([adb, \"start-server\"])\n        print \"\\n[INFO] ADB Started\"\n        wait(5)\n        print \"\\n[INFO] Connecting to VM/Device\"\n        result = subprocess.call([adb, \"connect\", get_identifier()])\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\" and result != 0:\n            subprocess.call([adb, \"tcpip\", str(settings.DEVICE_ADB_PORT)])\n            subprocess.call([adb, \"connect\", get_identifier()])\n        subprocess.call([adb, \"-s\", get_identifier(), \"wait-for-device\"])\n        print \"\\n[INFO] Mounting\"\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\",\n                             \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"])\n        else:\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\",\n                             \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"])\n            # This may not work for VMs other than the default MobSF VM\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\", \"mount\",\n                             \"-o\", \"rw,remount\", \"-t\", \"rfs\", \"/dev/block/sda6\", \"/system\"])\n    except:\n        print traceback.format_exc()\n        PrintException(\"[ERROR]  Connecting to VM/Device\")\nMobSF/utils.py\ndef python_list(value):\n    if not value:\n        value = []\n    if isinstance(value, list):\n        return value\n    return ast.literal_eval(value)\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef install_and_run(toolsdir, apk_path, package, launcher, is_activity):\n    \"\"\"Install APK and Run it\"\"\"\n    print \"\\n[INFO] Starting App for Dynamic Analysis\"\n    # try:\n    adb = getADB(toolsdir)\n    print \"\\n[INFO] Installing APK\"\n    install_result = subprocess.check_output([adb, \"-s\", get_identifier(),\n                     \"install\", \"-r\", apk_path])\n    print install_result\n    # 如果是未签名的错误，则对其进行签名并安装，\n    # 签名命令示例：jarsigner -verbose -keystore davidblus_android.keystore -storepass davidblus -signedjar app_signed.apk app.apk davidblus_android.keystore\n    if 'INSTALL_PARSE_FAILED_NO_CERTIFICATES' in install_result:\n        signed_apk_path = sign_apk(apk_path)\n        install_result = subprocess.check_output([adb, \"-s\", get_identifier(),\n                         \"install\", \"-r\", signed_apk_path])\n        print install_result\n    if 'Success' not in install_result:\n        raise Exception('Install Error')\n    if is_activity:\n        run_app = package + \"/\" + launcher\n        print \"\\n[INFO] Launching APK Main Activity\"\n        subprocess.call([adb, \"-s\", get_identifier(),\n                         \"shell\", \"am\", \"start\", \"-n\", run_app])\n    else:\n        print \"\\n[INFO] App Doesn't have a Main Activity\"\n        # Handle Service or Give Choice to Select in Future.\n    print \"[INFO] Testing Environment is Ready!\"\n    # except:\n    #     PrintException(\"[ERROR]  Starting App for Dynamic Analysis\")\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef wait(sec):\n    \"\"\"Wait in Seconds\"\"\"\n    print \"\\n[INFO] Waiting for \" + str(sec) + \" seconds...\"\n    time.sleep(sec)\nMobSF/utils.py\ndef PrintException(msg, web=False):\n    try:\n        LOGPATH = settings.LOG_DIR\n    except:\n        LOGPATH = os.path.join(settings.BASE_DIR, \"logs/\")\n    if not os.path.exists(LOGPATH):\n        os.makedirs(LOGPATH)\n    exc_type, exc_obj, tb = sys.exc_info()\n    f = tb.tb_frame\n    lineno = tb.tb_lineno\n    filename = f.f_code.co_filename\n    linecache.checkcache(filename)\n    line = linecache.getline(filename, lineno, f.f_globals)\n    ts = time.time()\n    st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')\n    dat = '\\n[' + st + ']\\n' + msg + \\\n        ' ({0}, LINE {1} \"{2}\"): {3}'.format(\n            filename, lineno, line.strip(), exc_obj)\n    if platform.system() == \"Windows\":\n        print dat\n    else:\n        if web:\n            print Color.BOLD + Color.ORANGE + dat + Color.END\n        else:\n            print Color.BOLD + Color.RED + dat + Color.END\n    with open(LOGPATH + 'MobSF.log', 'a') as f:\n        f.write(dat)\n", "answers": ["                install_and_run(toolsdir, app_path, package, launcher, True)"], "length": 1743, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "057de216e0e7575eec3457f9e92a67f4bf7157d2b0c6edbe"}
{"input": "package org.ihtsdo.drools.unittest;\nimport org.ihtsdo.drools.RuleExecutor;\nimport org.ihtsdo.drools.RuleExecutorFactory;\nimport org.ihtsdo.drools.domain.Concept;\nimport org.ihtsdo.drools.exception.BadRequestRuleExecutorException;\nimport org.ihtsdo.drools.exception.RuleExecutorException;\nimport org.ihtsdo.drools.response.InvalidContent;\nimport org.ihtsdo.drools.rulestestrig.service.TestConceptService;\nimport org.ihtsdo.drools.rulestestrig.service.TestDescriptionService;\nimport org.ihtsdo.drools.rulestestrig.service.TestRelationshipService;\nimport org.ihtsdo.drools.service.TestResourceProvider;\nimport org.ihtsdo.drools.unittest.domain.ConceptImpl;\nimport org.ihtsdo.drools.unittest.domain.DescriptionImpl;\nimport org.ihtsdo.drools.unittest.domain.RelationshipImpl;\nimport org.ihtsdo.otf.resourcemanager.ManualResourceConfiguration;\nimport org.ihtsdo.otf.resourcemanager.ResourceConfiguration;\nimport org.ihtsdo.otf.resourcemanager.ResourceManager;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.ihtsdo.drools.rulestestrig.domain.Constants;\nimport java.util.*;\n\n\n\npublic class RuleExecutorTest {\n\n\tprivate static final Set<String> RULE_SET_NAMES = Collections.singleton(\"Common\");\n\tprivate RuleExecutor ruleExecutor;", "context": "snomed-drools-engine/src/main/java/org/ihtsdo/drools/RuleExecutor.java\npublic class RuleExecutor {\n\n\n\tprivate final Map<String, KieContainer> assertionGroupContainers;\n\tprivate final Map<String, Integer> assertionGroupRuleCounts;\n\tprivate boolean testResourcesEmpty;\n\tprivate final Logger logger = LoggerFactory.getLogger(getClass());\n\n\tprotected RuleExecutor(Map<String, KieContainer> assertionGroupContainers, Map<String, Integer> assertionGroupRuleCounts) {\n\t\tthis.assertionGroupContainers = assertionGroupContainers;\n\t\tthis.assertionGroupRuleCounts = assertionGroupRuleCounts;\n\t}\n\n\t/**\n\t * TestResourceProvider should be created once and used by other services to load test resources such as the case significant words list.\n\t * Calling this method again will load the resources again so can be useful if the resources change.\n\t * @param resourceManager The resource manager to use to load the test resource files.\n\t * @return A TestResourceProvider which uses the resourceManager.\n\t * @throws RuleExecutorException if there is a problem loading the test resources.\n\t */\n\tpublic TestResourceProvider newTestResourceProvider(ResourceManager resourceManager) throws RuleExecutorException {\n\t\ttry {\n\t\t\tTestResourceProvider testResourceProvider = new TestResourceProvider(resourceManager);\n\t\t\ttestResourcesEmpty = !testResourceProvider.isAnyResourcesLoaded();\n\t\t\treturn testResourceProvider;\n\t\t} catch (IOException e) {\n\t\t\ttestResourcesEmpty = true;\n\t\t\tthrow new RuleExecutorException(\"Failed to load test resources.\", e);\n\t\t}\n\t}\n\n\tpublic TestResourceProvider newTestResourceProvider(String awsKey, String awsSecretKey, String bucket, String path) throws RuleExecutorException {\n\t\ttry {\n\t\t\tAmazonS3 amazonS3 = AmazonS3ClientBuilder.standard()\n\t\t\t\t\t.withRegion(\"us-east-1\")\n\t\t\t\t\t.withCredentials(new AWSStaticCredentialsProvider(new BasicAWSCredentials(awsKey, awsSecretKey)))\n\t\t\t\t\t.build();\n\t\t\tManualResourceConfiguration resourceConfiguration = new ManualResourceConfiguration(true, true, null, new ResourceConfiguration.Cloud(bucket, path));\n\t\t\tResourceManager resourceManager = new ResourceManager(resourceConfiguration, new SimpleStorageResourceLoader(amazonS3));\n\t\t\tTestResourceProvider testResourceProvider = new TestResourceProvider(resourceManager);\n\t\t\ttestResourcesEmpty = !testResourceProvider.isAnyResourcesLoaded();\n\t\t\treturn testResourceProvider;\n\t\t} catch (IOException e) {\n\t\t\ttestResourcesEmpty = true;\n\t\t\tthrow new RuleExecutorException(\"Failed to load test resources.\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Validate a concept using drools rules available to this executor.\n\t * A temporary identifier should be assigned to the concepts or any of it's descriptions and relationships\n\t * if the component is new and does not yet have an SCTID. The identifier of the component is used to identify invalid content.\n\t *\n\t * Passing services in with every invocation of this method allows the implementation to capture content context. For example\n\t * services relevant to the content branch being worked on.\n\t * @param ruleSetNames The rule sets to use during validation.\n\t * @param concepts The concepts to be validated.\n\t * @param conceptService An implementation of the ConceptService class for use in validation rules.\n\t * @param descriptionService An implementation of the DescriptionService class for use in validation rules.\n\t * @param relationshipService An implementation of the RelationshipService class for use in validation rules.\n\t * @param includePublishedComponents Include the published components of the given concept in results if found to be invalid.\n\t *                                   Published content will be used during validation regardless just not returned.\n\t * @param includeInferredRelationships Include the inferred relationships of the given concept during validation and\n\t *                                     in results if found to be invalid.\n\t * @return A list of content found to be invalid is returned.\n\t */\n\tpublic List<InvalidContent> execute(\n\t\t\tSet<String> ruleSetNames,\n\t\t\tCollection<? extends Concept> concepts,\n\t\t\tConceptService conceptService,\n\t\t\tDescriptionService descriptionService,\n\t\t\tRelationshipService relationshipService,\n\t\t\tboolean includePublishedComponents,\n\t\t\tboolean includeInferredRelationships) throws RuleExecutorException {\n\n\t\tfor (Concept concept : concepts) {\n\t\t\tassertComponentIdsPresent(concept);\n\t\t}\n\n\t\tDate start = new Date();\n\n\t\tfinal List<List<InvalidContent>> sessionInvalidContent = new ArrayList<>();\n\t\tfinal List<InvalidContent> exceptionContents = new ArrayList<>();\n\t\tfor (String ruleSetName : ruleSetNames) {\n\t\t\tfinal KieContainer kieContainer = assertionGroupContainers.get(ruleSetName);\n\t\t\tif (kieContainer == null) {\n\t\t\t\tthrow new RuleExecutorException(\"Rule set not found for name '\" + ruleSetName + \"'\");\n\t\t\t}\n\n\t\t\tint threads = concepts.size() == 1 ? 1 : 10;\n\t\t\tExecutorService executorService = Executors.newFixedThreadPool(threads);\n\t\t\tList<StatelessKieSession> sessions = new ArrayList<>();\n\t\t\tfor (int s = 0; s < threads; s++) {\n\t\t\t\tArrayList<InvalidContent> invalidContent = new ArrayList<>();// List per thread to avoid concurrency issues.\n\t\t\t\tsessionInvalidContent.add(invalidContent);\n\t\t\t\tsessions.add(newStatelessKieSession(kieContainer, conceptService, descriptionService, relationshipService, invalidContent));\n\t\t\t}\n\t\t\tList<Concept> conceptList = new ArrayList<>(concepts);\n\t\t\tList<Callable<String>> tasks = new ArrayList<>();\n\t\t\tString total = String.format(\"%,d\", concepts.size());\n\t\t\tint i = 0;\n\t\t\twhile (i < concepts.size()) {\n\t\t\t\tSet<Component> components = new HashSet<>();\n\t\t\t\tConcept concept = conceptList.get(i++);\n\t\t\t\taddConcept(components, concept, includeInferredRelationships);\n\t\t\t\tint sessionIndex = tasks.size();\n\t\t\t\ttasks.add(() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tStatelessKieSession statelessKieSession = sessions.get(sessionIndex);\n\t\t\t\t\t\tstatelessKieSession.execute(components);\n\t\t\t\t\t\tcomponents.clear();\n\t\t\t\t\t\t((StatelessKnowledgeSessionImpl) statelessKieSession).newWorkingMemory();\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\texceptionContents.add(new InvalidContent(concept.getId(),concept, \"An error occurred while running concept validation. Technical detail: \" + e.getMessage(), Severity.ERROR));\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\n\t\t\t\tif (tasks.size() == threads) {\n\t\t\t\t\trunTasks(executorService, tasks);\n\t\t\t\t\ttasks.clear();\n\t\t\t\t}\n\t\t\t\tif (i % 10_000 == 0) {\n\t\t\t\t\tlogger.info(\"Validated {} of {}\", String.format(\"%,d\", i), total);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!tasks.isEmpty()) {\n\t\t\t\trunTasks(executorService, tasks);\n\t\t\t}\n\t\t\texecutorService.shutdown();\n\t\t\tlogger.info(\"Validated {} of {}\", String.format(\"%,d\", i), total);\n\n\t\t\tlogger.info(\"Rule execution took {} seconds\", (new Date().getTime() - start.getTime()) / 1000);\n\t\t}\n\n\t\tList<InvalidContent> invalidContent = sessionInvalidContent.stream().flatMap(Collection::stream).filter(Objects::nonNull).collect(Collectors.toList());\n\t\tinvalidContent.addAll(exceptionContents);\n\t\tinvalidContent = removeDuplicates(invalidContent);\n\n\t\tif (!includePublishedComponents) {\n\t\t\tSet<InvalidContent> publishedInvalidContent = new HashSet<>();\n\t\t\tfor (InvalidContent invalidContentItem : invalidContent) {\n\t\t\t\tlogger.info(\"invalidContentItem : {}, {}, {}, {}, {}\", invalidContentItem.getConceptId(), invalidContentItem.isIgnorePublishedCheck(), invalidContentItem.isPublished(), invalidContentItem.getSeverity(), invalidContentItem.getMessage());\n\t\t\t\tif (!invalidContentItem.isIgnorePublishedCheck() && invalidContentItem.isPublished()) {\n\t\t\t\t\tpublishedInvalidContent.add(invalidContentItem);\n\t\t\t\t}\n\t\t\t}\n\t\t\tinvalidContent.removeAll(publishedInvalidContent);\n\t\t}\n\n\t\tif (testResourcesEmpty) {\n\t\t\tinvalidContent.add(0, InvalidContent.getGeneralWarning(\"Test resources were not available so assertions like case significance and US specific terms \" +\n\t\t\t\t\t\"checks will not have run.\"));\n\t\t}\n\n\t\treturn invalidContent;\n\t}\n\n\tprivate List<InvalidContent> removeDuplicates(List<InvalidContent> invalidContent) {\n\t\tList<InvalidContent> uniqueInvalidContent = new ArrayList<>();\n\t\tMap<String, Map<String, Set<String>>> conceptComponentMessageMap = new HashMap<>();\n\t\tfor (InvalidContent content : invalidContent) {\n\t\t\tMap<String, Set<String>> componentMessages = conceptComponentMessageMap.computeIfAbsent(content.getConceptId(), s -> new HashMap<>());\n\t\t\tSet<String> messages = componentMessages.computeIfAbsent(content.getComponentId(), s -> new HashSet<>());\n\t\t\tif (messages.add(content.getMessage())) {\n\t\t\t\tuniqueInvalidContent.add(content);\n\t\t\t}\n\t\t}\n\t\treturn uniqueInvalidContent;\n\t}\n\n\tprivate void assertComponentIdsPresent(Concept concept) {\n\t\tfinal String conceptId = concept.getId();\n\t\tif (conceptId == null || conceptId.isEmpty()) {\n\t\t\tthrow new BadRequestRuleExecutorException(\"For validation concepts must have an SCTID or some temporary ID. \" +\n\t\t\t\t\t\"This also applies to the descriptions and relationships.\");\n\t\t}\n\t\tfor (Description description : concept.getDescriptions()) {\n\t\t\tif (description.getId() == null || description.getId().isEmpty()) {\n\t\t\t\tthrow new BadRequestRuleExecutorException(\"For validation descriptions must have an SCTID or some temporary ID. \" +\n\t\t\t\t\t\t\"This also applies to the concept and relationships.\");\n\t\t\t}\n\t\t\tif (!conceptId.equals(description.getConceptId())) {\n\t\t\t\tthrow new BadRequestRuleExecutorException(\"For validation description conceptId must be the ID of the concept.\");\n\t\t\t}\n\t\t}\n\t\tfor (Relationship relationship : concept.getRelationships()) {\n\t\t\tif (relationship.getId() == null || relationship.getId().isEmpty()) {\n\t\t\t\tthrow new BadRequestRuleExecutorException(\"For validation relationships must have an SCTID or some temporary ID. \" +\n\t\t\t\t\t\t\"This also applies to the concept and descriptions.\");\n\t\t\t}\n\t\t\tif (!conceptId.equals(relationship.getSourceId())) {\n\t\t\t\tthrow new BadRequestRuleExecutorException(\"For validation relationship sourceId must be the ID of the concept.\");\n\t\t\t}\n\t\t}\n\t\tfor (OntologyAxiom ontologyAxiom : concept.getOntologyAxioms()) {\n\t\t\tif (ontologyAxiom.getId() == null || ontologyAxiom.getId().isEmpty()) {\n\t\t\t\tthrow new BadRequestRuleExecutorException(\"For validation ontology axioms must have an SCTID or some temporary ID.\");\n\t\t\t}\n\t\t\tif (!conceptId.equals(ontologyAxiom.getReferencedComponentId())) {\n\t\t\t\tthrow new BadRequestRuleExecutorException(\"For validation ontology axiom referencedComponentId must be the ID of the concept.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate StatelessKieSession newStatelessKieSession(KieContainer kieContainer, ConceptService conceptService, DescriptionService descriptionService, RelationshipService relationshipService, List<InvalidContent> invalidContent) {\n\t\tfinal StatelessKieSession session = kieContainer.newStatelessKieSession();\n\t\tsession.setGlobal(\"invalidContent\", invalidContent);\n\t\tsession.setGlobal(\"conceptService\", conceptService);\n\t\tsession.setGlobal(\"descriptionService\", descriptionService);\n\t\tsession.setGlobal(\"relationshipService\", relationshipService);\n\t\treturn session;\n\t}\n\n\tprivate void runTasks(ExecutorService executorService, List<Callable<String>> tasks) {\n\t\ttry {\n\t\t\texecutorService.invokeAll(tasks);\n\t\t} catch (InterruptedException e) {\n\t\t\tthrow new RuleExecutorException(\"Validation tasks were interrupted.\", e);\n\t\t}\n\t}\n\n\tprivate static void addConcept(Set<Component> components, Concept concept, boolean includeInferredRelationships) {\n\t\tcomponents.add(concept);\n\t\tcomponents.addAll(concept.getDescriptions());\n\t\tfor (Relationship relationship : concept.getRelationships()) {\n\t\t\tif (includeInferredRelationships || !Constants.INFERRED_RELATIONSHIP.equals(relationship.getCharacteristicTypeId())) {\n\t\t\t\tcomponents.add(relationship);\n\t\t\t}\n\t\t}\n\t\tcomponents.addAll(concept.getOntologyAxioms());\n\t}\n\n\tpublic int getTotalRulesLoaded() {\n\t\treturn assertionGroupRuleCounts.values().stream().mapToInt(Integer::intValue).sum();\n\t}\n\n\tpublic int getAssertionGroupRuleCount(String assertionGroupName) {\n\t\treturn assertionGroupRuleCounts.getOrDefault(assertionGroupName, 0);\n\t}\n\n}\nsnomed-drools-engine/src/test/java/org/ihtsdo/drools/rulestestrig/domain/Constants.java\npublic class Constants {\n\n\tpublic static final Set<String> SEMANTIC_TAGS = new HashSet<>();\n    static {\n        SEMANTIC_TAGS.add(\"administration method\");\n        SEMANTIC_TAGS.add(\"assessment scale\");\n        SEMANTIC_TAGS.add(\"attribute\");\n        SEMANTIC_TAGS.add(\"basic dose form\");\n        SEMANTIC_TAGS.add(\"body structure\");\n        SEMANTIC_TAGS.add(\"cell structure\");\n        SEMANTIC_TAGS.add(\"cell\");\n        SEMANTIC_TAGS.add(\"clinical drug\");\n        SEMANTIC_TAGS.add(\"core metadata concept\");\n        SEMANTIC_TAGS.add(\"disorder\");\n        SEMANTIC_TAGS.add(\"disposition\");\n        SEMANTIC_TAGS.add(\"dose form\");\n        SEMANTIC_TAGS.add(\"environment / location\");\n        SEMANTIC_TAGS.add(\"environment\");\n        SEMANTIC_TAGS.add(\"ethnic group\");\n        SEMANTIC_TAGS.add(\"event\");\n        SEMANTIC_TAGS.add(\"finding\");\n        SEMANTIC_TAGS.add(\"foundation metadata concept\");\n        SEMANTIC_TAGS.add(\"geographic location\");\n        SEMANTIC_TAGS.add(\"inactive concept\");\n        SEMANTIC_TAGS.add(\"intended site\");\n        SEMANTIC_TAGS.add(\"life style\");\n        SEMANTIC_TAGS.add(\"link assertion\");\n        SEMANTIC_TAGS.add(\"linkage concept\");\n        SEMANTIC_TAGS.add(\"medicinal product\");\n        SEMANTIC_TAGS.add(\"medicinal product form\");\n        SEMANTIC_TAGS.add(\"metadata\");\n        SEMANTIC_TAGS.add(\"morphologic abnormality\");\n        SEMANTIC_TAGS.add(\"namespace concept\");\n        SEMANTIC_TAGS.add(\"navigational concept\");\n        SEMANTIC_TAGS.add(\"number\");\n        SEMANTIC_TAGS.add(\"observable entity\");\n        SEMANTIC_TAGS.add(\"occupation\");\n        SEMANTIC_TAGS.add(\"organism\");\n        SEMANTIC_TAGS.add(\"OWL metadata concept\");\n        SEMANTIC_TAGS.add(\"person\");\n        SEMANTIC_TAGS.add(\"physical force\");\n        SEMANTIC_TAGS.add(\"physical object\");\n        SEMANTIC_TAGS.add(\"procedure\");\n        SEMANTIC_TAGS.add(\"product\");\n        SEMANTIC_TAGS.add(\"qualifier value\");\n        SEMANTIC_TAGS.add(\"racial group\");\n        SEMANTIC_TAGS.add(\"record artifact\");\n        SEMANTIC_TAGS.add(\"regime/therapy\");\n        SEMANTIC_TAGS.add(\"religion/philosophy\");\n        SEMANTIC_TAGS.add(\"release characteristic\");\n        SEMANTIC_TAGS.add(\"role\");\n        SEMANTIC_TAGS.add(\"situation\");\n        SEMANTIC_TAGS.add(\"social concept\");\n        SEMANTIC_TAGS.add(\"special concept\");\n        SEMANTIC_TAGS.add(\"specimen\");\n        SEMANTIC_TAGS.add(\"staging scale\");\n        SEMANTIC_TAGS.add(\"state of matter\");\n        SEMANTIC_TAGS.add(\"substance\");\n        SEMANTIC_TAGS.add(\"transformation\");\n        SEMANTIC_TAGS.add(\"tumor staging\");\n        SEMANTIC_TAGS.add(\"unit of presentation\");\n    }\n}\nsnomed-drools-engine/src/test/java/org/ihtsdo/drools/unittest/domain/RelationshipImpl.java\npublic class RelationshipImpl implements Relationship {\n\n\tprivate final String id;\n\tprivate String moduleId;\n\tprivate String sourceId;\n\tprivate String destinationId;\n\tprivate int relationshipGroup;\n\tprivate String typeId;\n\tprivate String characteristicTypeId;\n\tprivate boolean released;\n\tprivate String concreteValue;\n\n\tpublic RelationshipImpl(String id, String typeId) {\n\t\tthis.id = id;\n\t\tthis.typeId = typeId;\n\t}\n\n\t@Override\n\tpublic String getAxiomId() {\n\t\t// We don't have any unit tests using axioms in this module\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isAxiomGCI() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic boolean isActive() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getModuleId() {\n\t\treturn moduleId;\n\t}\n\n\tpublic void setModuleId(String moduleId) {\n\t\tthis.moduleId = moduleId;\n\t}\n\n\t@Override\n\tpublic boolean isPublished() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getSourceId() {\n\t\treturn sourceId;\n\t}\n\n\t@Override\n\tpublic String getDestinationId() {\n\t\treturn destinationId;\n\t}\n\n\t@Override\n\tpublic int getRelationshipGroup() {\n\t\treturn relationshipGroup;\n\t}\n\n\t@Override\n\tpublic String getTypeId() {\n\t\treturn typeId;\n\t}\n\n\t@Override\n\tpublic String getCharacteristicTypeId() {\n\t\treturn characteristicTypeId;\n\t}\n\n\t@Override\n\tpublic boolean isReleased() {\n\t\treturn released;\n\t}\n\n\t@Override\n\tpublic String getConcreteValue() {\n\t\treturn concreteValue;\n\t}\n\n\tpublic void setSourceId(String sourceId) {\n\t\tthis.sourceId = sourceId;\n\t}\n\n\tpublic void setTypeId(String typeId) {\n\t\tthis.typeId = typeId;\n\t}\n\n\tpublic void setDestinationId(String destinationId) {\n\t\tthis.destinationId = destinationId;\n\t}\n\n\tpublic void setRelationshipGroup(int relationshipGroup) {\n\t\tthis.relationshipGroup = relationshipGroup;\n\t}\n\n\tpublic void setCharacteristicTypeId(String characteristicTypeId) {\n\t\tthis.characteristicTypeId = characteristicTypeId;\n\t}\n\n\tpublic void setReleased(boolean released) {\n\t\tthis.released = released;\n\t}\n\n\tpublic void setConcreteValue(String value) {\n\t\tthis.concreteValue = value;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"RelationshipImpl{\" +\n\t\t\t\t\"id='\" + id + '\\'' +\n\t\t\t\t\", sourceId='\" + sourceId + '\\'' +\n\t\t\t\t\", destinationId='\" + destinationId + '\\'' +\n\t\t\t\t\", relationshipGroup='\" + relationshipGroup + '\\'' +\n\t\t\t\t\", typeId='\" + typeId + '\\'' +\n\t\t\t\t\", characteristicTypeId='\" + characteristicTypeId + '\\'' +\n\t\t\t\t'}';\n\t}\n}\nsnomed-drools-engine/src/test/java/org/ihtsdo/drools/rulestestrig/service/TestDescriptionService.java\npublic class TestDescriptionService implements DescriptionService {\n\n\tprivate final Map<String, Concept> concepts;\n\tprivate final TestResourceProvider testResourceProvider;\n\n\tpublic TestDescriptionService(Map<String, Concept> concepts, TestResourceProvider testResourceProvider) {\n\t\tthis.concepts = concepts;\n\t\tthis.testResourceProvider = testResourceProvider;\n\t}\n\n\t@Override\n\tpublic Set<String> getFSNs(Set<String> conceptIds, String... languageRefsetIds) {\n\t\tSet<String> fsns = new HashSet<>();\n\t\tfor (String conceptId : conceptIds) {\n\t\t\tfinal Concept concept = concepts.get(conceptId);\n\t\t\tfor (Description description : concept.getDescriptions()) {\n\t\t\t\tif (description.isActive() && Constants.FSN.equals(description.getTypeId())) {\n\t\t\t\t\tfor (String languageRefsetId : languageRefsetIds) {\n\t\t\t\t\t\tif (Constants.ACCEPTABILITY_PREFERRED.equals(description.getAcceptabilityMap().get(languageRefsetId))) {\n\t\t\t\t\t\t\tfsns.add(description.getTerm());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn fsns;\n\t}\n\n\t@Override\n\tpublic Set<Description> findActiveDescriptionByExactTerm(String exactTerm) {\n\t\tcheckMinSearchLength(exactTerm);\n\n\t\tSet<Description> matches = new HashSet<>();\n\t\tfor (Concept concept : concepts.values()) {\n\t\t\tfor (Description description : concept.getDescriptions()) {\n\t\t\t\tif (description.isActive() && description.getTerm().equals(exactTerm)) {\n\t\t\t\t\tmatches.add(description);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\t@Override\n\tpublic Set<Description> findInactiveDescriptionByExactTerm(String exactTerm) {\n\t\tcheckMinSearchLength(exactTerm);\n\n\t\tSet<Description> matches = new HashSet<>();\n\t\tfor (Concept concept : concepts.values()) {\n\t\t\tfor (Description description : concept.getDescriptions()) {\n\t\t\t\tif (!description.isActive() && description.getTerm().equals(exactTerm)) {\n\t\t\t\t\tmatches.add(description);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\t@Override\n\t/*\n\t * This primitive implementation just uses the direct parents to group given concepts into a 'hierarchy'.\n\t */\n\tpublic Set<Description> findMatchingDescriptionInHierarchy(Concept concept, Description description) {\n\t\tcheckMinSearchLength(description.getTerm());\n\n\t\tSet<Description> matchingDescription = new HashSet<>();\n\t\tSet<String> parents = getParents(concept);\n\t\tfor (Concept otherConcept : concepts.values()) {\n\t\t\tfor (String otherConceptParent : getParents(otherConcept)) {\n\t\t\t\tif (parents.contains(otherConceptParent)) {\n\t\t\t\t\tfor (Description otherDescription : otherConcept.getDescriptions()) {\n\t\t\t\t\t\tif (description.getTerm().equals(otherDescription.getTerm())) {\n\t\t\t\t\t\t\tmatchingDescription.add(otherDescription);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn matchingDescription;\n\t}\n\n\tprivate Set<String> getParents(Concept concept) {\n\t\tfinal Set<String> parents = new HashSet<>();\n\t\tfor (Relationship relationship : concept.getRelationships()) {\n\t\t\tif (Constants.IS_A.equals(relationship.getTypeId())) {\n\t\t\t\tparents.add(relationship.getDestinationId());\n\t\t\t}\n\t\t}\n\t\treturn parents;\n\t}\n\n\tprivate void checkMinSearchLength(String exactTerm) {\n\t\tif (exactTerm.length() < 2) {\n\t\t\tthrow new IllegalArgumentException(\"Term search requires at least two characters\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getCaseSensitiveWordsErrorMessage(Description description) {\n\t\treturn DescriptionHelper.getCaseSensitiveWordsErrorMessage(description, testResourceProvider.getCaseSignificantWords());\n\t}\n\n\t@Override\n\tpublic String getLanguageSpecificErrorMessage(Description description) {\n\t\treturn DescriptionHelper.getLanguageSpecificErrorMessage(description, testResourceProvider.getUsToGbTermMap());\n\t}\n\n\t@Override\n\tpublic Set<String> findParentsNotContainingSemanticTag(Concept concept, String termSemanticTag, String... languageRefsetIds) {\n\t\tSet<String> conceptIds = new HashSet<>();\n\t\tfor (Relationship relationship : concept.getRelationships()) {\n\t\t\tif (Constants.IS_A.equals(relationship.getTypeId()) \n\t\t\t\t&& relationship.isActive() \n\t\t\t\t&& !relationship.isAxiomGCI()\n\t\t\t\t&& Constants.STATED_RELATIONSHIP.equals(relationship.getCharacteristicTypeId())) {\n\t\t\t\tConcept parent = concepts.get(relationship.getDestinationId());\n\t\t\t\tfor (Description description : parent.getDescriptions()) {\n\t\t\t\t\tif (description.isActive() && Constants.FSN.equals(description.getTypeId())) {\n\t\t\t\t\t\tif(!termSemanticTag.equals(DescriptionHelper.getTag(description.getTerm()))) {\n\t\t\t\t\t\t\tconceptIds.add(relationship.getDestinationId());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn conceptIds;\n\t}\n\n\t@Override\n\tpublic boolean isRecognisedSemanticTag(String termSemanticTag) {\n\t\treturn testResourceProvider.getSemanticTags().contains(termSemanticTag);\n\t}\n}\nsnomed-drools-engine/src/main/java/org/ihtsdo/drools/exception/BadRequestRuleExecutorException.java\npublic class BadRequestRuleExecutorException extends RuleExecutorException {\n\tpublic BadRequestRuleExecutorException(String message) {\n\t\tsuper(message);\n\t}\n}\nsnomed-drools-engine/src/test/java/org/ihtsdo/drools/rulestestrig/service/TestConceptService.java\npublic class TestConceptService implements ConceptService {\n\n\tprivate final Map<String, Concept> concepts;\n\n\tpublic TestConceptService(Map<String, Concept> concepts) {\n\t\tthis.concepts = concepts;\n\t}\n\n\t@Override\n\tpublic boolean isActive(String conceptId) {\n\t\tConcept concept = concepts.get(conceptId);\n\t\treturn concept != null && concept.isActive();\n\t}\n\n\t@Override\n\tpublic Concept findById(String conceptId) {\n\t\treturn concepts.get(conceptId);\n\t}\n\n\t@Override\n\tpublic Set<String> getAllTopLevelHierarchies(){\n\t\tSet<String> allTopLevelHierarchies = new HashSet<>();\n\t\tfor (Concept concept : concepts.values()) {\n\t\t\tfor (Relationship relationship : concept.getRelationships()) {\n\t\t\t\tif (relationship.isActive()\n\t\t\t\t\t&& Constants.IS_A.equals(relationship.getTypeId()) \n\t\t\t\t\t&& Constants.ROOT_CONCEPT.equals(relationship.getDestinationId())) {\n\t\t\t\t\tallTopLevelHierarchies.add(concept.getId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn allTopLevelHierarchies;\n\t}\n\t\n\t@Override\n\tpublic Set<String> findStatedAncestorsOfConcept(Concept c){\n\t\tSet<String> directParent = getStatedParents(c);\n\t\tSet<String> statedAncestors = new HashSet<>(directParent);\n\t\t\n\t\tfor (String parentId : directParent) {\n\t\t\tSet<String> parentOfParent = findStatedAncestorsOfConcept(concepts.get(parentId));\n\t\t\tstatedAncestors.addAll(parentOfParent);\n\t\t}\n\t\t\n\t\treturn statedAncestors;\n\t}\n\t\n\t@Override\n\tpublic Set<String> findTopLevelHierarchiesOfConcept(Concept c){\n\t\tSet<String> topLevelConcepts = new HashSet<>();\n\t\tfor (Relationship relationship : c.getRelationships()) {\n\t\t\tif (relationship.isActive()\n\t\t\t\t&& Constants.STATED_RELATIONSHIP.equals(relationship.getCharacteristicTypeId())\t \n\t\t\t\t&& Constants.IS_A.equals(relationship.getTypeId())) {\n\t\t\t\tif (Constants.ROOT_CONCEPT.equals(relationship.getDestinationId())) {\n\t\t\t\t\ttopLevelConcepts.add(relationship.getSourceId());\n\t\t\t\t} else {\n\t\t\t\t\ttopLevelConcepts.addAll(findTopLevelHierarchiesOfConcept(concepts.get(relationship.getDestinationId())));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn topLevelConcepts;\n\t}\n\t\n\tprivate Set<String> getStatedParents(Concept concept) {\n\t\tif(concept == null || concept.getId().equals(Constants.ROOT_CONCEPT)) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tfinal Set<String> parents = new HashSet<>();\n\t\tfor (Relationship relationship : concept.getRelationships()) {\n\t\t\tif (relationship.isActive()\n\t\t\t\t&& !relationship.isAxiomGCI()\n\t\t\t\t&& Constants.IS_A.equals(relationship.getTypeId()) \n\t\t\t\t&& Constants.STATED_RELATIONSHIP.equals(relationship.getCharacteristicTypeId())) {\n\t\t\t\tparents.add(relationship.getDestinationId());\n\t\t\t}\n\t\t}\n\t\treturn parents;\n\t}\n\n\t@Override \n\tpublic Set<String> findStatedAncestorsOfConcepts(List<String> conceptIds) {\n\t\tSet<String> ancestorIds = new HashSet<>();\n\t\tfor (String id : conceptIds) {\n\t\t\tancestorIds.addAll(findStatedAncestorsOfConcept(concepts.get(id)));\n\t\t}\n\t\treturn ancestorIds;\n\t}\n\t\n}\nsnomed-drools-engine/src/test/java/org/ihtsdo/drools/unittest/domain/ConceptImpl.java\npublic class ConceptImpl implements Concept {\n\n\tprivate String id;\n\tprivate String moduleId;\n\tprivate String definitionStatusId;\n\tprivate Collection<Description> descriptions;\n\tprivate Collection<Relationship> relationships;\n\tprivate Collection<OntologyAxiom> ontologyAxioms;\n\tprivate boolean released;\n\n\tpublic ConceptImpl(String id) {\n\t\tthis.id = id;\n\t\tdescriptions = new HashSet<>();\n\t\trelationships = new HashSet<>();\n\t\tontologyAxioms = new HashSet<>();\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic boolean isActive() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getModuleId() {\n\t\treturn moduleId;\n\t}\n\n\tpublic void setModuleId(String moduleId) {\n\t\tthis.moduleId = moduleId;\n\t}\n\n\t@Override\n\tpublic boolean isPublished() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isReleased() {\n\t\treturn released;\n\t}\n\n\tpublic void setReleased(boolean released) {\n\t\tthis.released = released;\n\t}\n\n\tpublic ConceptImpl addDescription(DescriptionImpl description) {\n\t\tdescription.setConceptId(id);\n\t\tdescriptions.add(description);\n\t\treturn this;\n\t}\n\n\tpublic ConceptImpl addRelationship(RelationshipImpl relationship) {\n\t\trelationship.setSourceId(id);\n\t\trelationships.add(relationship);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic String getDefinitionStatusId() {\n\t\treturn definitionStatusId;\n\t}\n\n\tpublic void setDefinitionStatusId(String definitionStatusId) {\n\t\tthis.definitionStatusId = definitionStatusId;\n\t}\n\n\t@Override\n\tpublic Collection<Description> getDescriptions() {\n\t\treturn descriptions;\n\t}\n\n\tpublic void setDescriptions(Collection<Description> descriptions) {\n\t\tthis.descriptions = descriptions;\n\t}\n\n\t@Override\n\tpublic Collection<Relationship> getRelationships() {\n\t\treturn relationships;\n\t}\n\n\t@Override\n\tpublic Collection<? extends OntologyAxiom> getOntologyAxioms() {\n\t\treturn ontologyAxioms;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Concept{\" +\n\t\t\t\t\"id='\" + id + '\\'' +\n\t\t\t\t'}';\n\t}\n}\nsnomed-drools-engine/src/main/java/org/ihtsdo/drools/RuleExecutorFactory.java\npublic class RuleExecutorFactory {\n\n\tprivate static final String RULE_FILENAME_EXTENSION = \".drl\";\n\n\tprivate KieServices kieServices;\n\tprivate final Logger logger = LoggerFactory.getLogger(getClass());\n\tprivate Map<String, KieContainer> assertionGroupContainers;\n\tprivate Map<String, Integer> assertionGroupRuleCounts;\n\tprivate String unitTestGroup;\n\n\n\tpublic RuleExecutor createRuleExecutor(String directoryOfAssertionGroups) {\n\t\treturn createRuleExecutor(directoryOfAssertionGroups, null);\n\t}\n\n\tpublic RuleExecutor createRuleExecutor(String directoryOfAssertionGroups, String unitTestGroup) {\n\t\t// Create a new instance of the factory so we can use instance fields without changing the original factory\n\t\tRuleExecutorFactory ruleExecutorFactory = new RuleExecutorFactory();\n\t\truleExecutorFactory.unitTestGroup = unitTestGroup;\n\t\treturn ruleExecutorFactory.doCreateRuleExecutor(directoryOfAssertionGroups);\n\t}\n\n\tprivate RuleExecutor doCreateRuleExecutor(String directoryOfAssertionGroups) {\n\t\t// Load assertions\n\t\tassertionGroupContainers = new HashMap<>();\n\t\tassertionGroupRuleCounts = new HashMap<>();\n\t\tkieServices = KieServices.Factory.get();\n\n\t\tloadAssertions(directoryOfAssertionGroups);\n\n\t\treturn new RuleExecutor(assertionGroupContainers, assertionGroupRuleCounts);\n\t}\n\n\tprivate void loadAssertions(String directoryOfAssertionGroups) {\n\t\t// Load assertion groups\n\t\tfinal File groupsDir = new File(directoryOfAssertionGroups);\n\t\tFile[] groupDirs = groupsDir.listFiles();\n\t\tif (!groupsDir.isDirectory() || groupDirs == null) {\n\t\t\tString message = String.format(\"Rules directory does not exist: %s\", groupsDir.getAbsolutePath());\n\t\t\tlogger.error(message);\n\t\t\tthrow new RuleExecutorException(message);\n\t\t}\n\t\tif (unitTestGroup != null) {\n\t\t\tattemptLoadAssertionGroup(groupsDir, unitTestGroup);\n\t\t} else {\n\t\t\tfor (File groupDir : groupDirs) {\n\t\t\t\tattemptLoadAssertionGroup(groupDir, groupDir.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void attemptLoadAssertionGroup(File groupDir, String assertionGroupName) {\n\t\tif (groupDir.isDirectory() && !groupDir.isHidden()) {\n\t\t\tlogger.info(\"Loading Drools assertion group {}\", assertionGroupName);\n\t\t\taddAssertionGroup(assertionGroupName, groupDir);\n\t\t}\n\t}\n\n\tprivate void addAssertionGroup(String assertionGroupName, File ruleSetDirectory) throws RuleExecutorException {\n\t\t// Create the in-memory File System and add the resources files  to it\n\t\tKieFileSystem kieFileSystem = kieServices.newKieFileSystem();\n\n\t\ttry {\n\t\t\tfinal RuleLoader ruleLoader = new RuleLoader(kieFileSystem);\n\t\t\tFiles.walkFileTree(ruleSetDirectory.toPath(), ruleLoader);\n\t\t\tint rulesLoadedForGroup = ruleLoader.getRulesLoaded();\n\t\t\tif (rulesLoadedForGroup == 0) {\n\t\t\t\tlogger.warn(\"No rules loaded for group {}. Rules directory: {}\", assertionGroupName, ruleSetDirectory.getAbsolutePath());\n\t\t\t} else {\n\t\t\t\tlogger.info(\"{} rules loaded for group {}.\", rulesLoadedForGroup, assertionGroupName);\n\t\t\t}\n\t\t\tassertionGroupRuleCounts.put(assertionGroupName, rulesLoadedForGroup);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuleExecutorException(\"Failed to load rule set \" + assertionGroupName, e);\n\t\t}\n\n\t\t// Create the builder for the resources of the File System\n\t\tKieBuilder kieBuilder = kieServices.newKieBuilder(kieFileSystem);\n\n\t\t// Build the KieBases\n\t\tkieBuilder.buildAll();\n\n\t\t// Check for errors\n\t\tif (kieBuilder.getResults().hasMessages(Message.Level.ERROR)) {\n\t\t\tthrow new RuleExecutorException(kieBuilder.getResults().toString());\n\t\t}\n\n\t\t// Get the Release ID (mvn style: groupId, artifactId,version)\n\t\tReleaseId relId = kieBuilder.getKieModule().getReleaseId();\n\n\t\t// Create the Container, wrapping the KieModule with the given ReleaseId\n\t\tassertionGroupContainers.put(assertionGroupName, kieServices.newKieContainer(relId));\n\t}\n\n\tprivate static final class RuleLoader extends SimpleFileVisitor<Path> {\n\n\t\tprivate final KieFileSystem kieFileSystem;\n\t\tprivate int rulesLoaded;\n\n\t\tRuleLoader(KieFileSystem kieFileSystem) {\n\t\t\tthis.kieFileSystem = kieFileSystem;\n\t\t}\n\n\t\t@Override\n\t\tpublic FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n\t\t\tFile file = path.toFile();\n\t\t\tif (file.isFile() && file.getName().endsWith(RULE_FILENAME_EXTENSION)) {\n\t\t\t\tkieFileSystem.write(ResourceFactory.newFileResource(file));\n\t\t\t\trulesLoaded++;\n\t\t\t}\n\n\t\t\treturn FileVisitResult.CONTINUE;\n\t\t}\n\n\t\tint getRulesLoaded() {\n\t\t\treturn rulesLoaded;\n\t\t}\n\t}\n\n}\nsnomed-drools-engine/src/main/java/org/ihtsdo/drools/domain/Concept.java\npublic interface Concept extends Component {\n\n\tString getDefinitionStatusId();\n\n\tCollection<? extends Description> getDescriptions();\n\n\tCollection<? extends Relationship> getRelationships();\n\n\t/**\n\t * Most axioms can be transformed into relationships for validation.\n\t * These represent general ontology axioms like property chains which can not be transformed into relationships.\n\t * @return A set of ontology axioms which have this concept as the referencedComponentId.\n\t */\n\tCollection<? extends OntologyAxiom> getOntologyAxioms();\n}\nsnomed-drools-engine/src/main/java/org/ihtsdo/drools/response/InvalidContent.java\npublic class InvalidContent {\n\n\tprivate String ruleId;\n\tprivate String conceptId;\n\tprivate String conceptFsn;\n\tprivate Component component;\n\tprivate String message;\n\tprivate Severity severity;\n\tprivate boolean ignorePublishedCheck;\n\n\tpublic static InvalidContent getGeneralWarning(String message) {\n\t\treturn new InvalidContent(\"setup-issue\", Constants.ROOT_CONCEPT, new DummyComponent(), message, Severity.WARNING);\n\t}\n\n\tpublic InvalidContent(String ruleId, String conceptId, Component component, String message, Severity severity) {\n\t\tthis.ruleId = ruleId;\n\t\tthis.conceptId = conceptId;\n\t\tthis.component = component;\n\t\tthis.message = message;\n\t\tthis.severity = severity;\n\t}\n\n\tpublic InvalidContent(String ruleId, Concept concept, String message, Severity severity) {\n\t\tthis(ruleId, concept.getId(), concept, message, severity);\n\t}\n\n\tpublic InvalidContent(String ruleId, Concept concept, String message) {\n\t\tthis(ruleId, concept, message, Severity.ERROR);\n\t}\n\n\tpublic InvalidContent(String ruleId, Description description, String message, Severity severity) {\n\t\tthis(ruleId, description.getConceptId(), description, message, severity);\n\t}\n\n\tpublic InvalidContent(String ruleId, Description description, String message) {\n\t\tthis(ruleId, description, message, Severity.ERROR);\n\t}\n\n\tpublic InvalidContent(String ruleId, Relationship relationship, String message, Severity severity) {\n\t\tthis(ruleId, relationship.getSourceId(), relationship, message, severity);\n\t}\n\n\tpublic InvalidContent(String ruleId, Relationship relationship, String message) {\n\t\tthis(ruleId, relationship, message, Severity.ERROR);\n\t}\n\n\tpublic InvalidContent(String ruleId, OntologyAxiom ontologyAxiom, String message, Severity severity) {\n\t\tthis(ruleId, ontologyAxiom.getReferencedComponentId(), ontologyAxiom, message, severity);\n\t}\n\n\tpublic InvalidContent(String ruleId, OntologyAxiom ontologyAxiom, String message) {\n\t\tthis(ruleId, ontologyAxiom, message, Severity.ERROR);\n\t}\n\n\t// This method used to return the object instance in the style of the Builder Pattern but this caused strange drools behaviour so have been removed.\n\tpublic void ignorePublishedCheck() {\n\t\tignorePublishedCheck = true;\n\t}\n\n\tpublic String getRuleId() {\n\t\treturn ruleId;\n\t}\n\n\tpublic String getConceptId() {\n\t\treturn conceptId;\n\t}\n\n\tpublic String getComponentId() {\n\t\treturn component.getId();\n\t}\n\n\t/**\n\t * The ignorePublishedCheck field can be set to true by rules which test data\n\t * where the published state cannot be evaluated. For example language reference set members.\n\t * @return\n\t */\n\tpublic boolean isIgnorePublishedCheck() {\n\t\treturn ignorePublishedCheck;\n\t}\n\n\tpublic boolean isPublished() {\n\t\treturn component.isPublished();\n\t}\n\n\tpublic String getMessage() {\n\t\treturn message;\n\t}\n\n\tpublic Severity getSeverity() {\n\t\treturn severity;\n\t}\n\n\tpublic Component getComponent() {\n\t\treturn component;\n\t}\n\n\tpublic void setComponent(Component component) {\n\t\tthis.component = component;\n\t}\n\n\tpublic String getConceptFsn() {\n\t\treturn conceptFsn;\n\t}\n\n\tpublic void setConceptFsn(String conceptFsn) {\n\t\tthis.conceptFsn = conceptFsn;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"InvalidContent{\" +\n\t\t\t\t\"conceptId='\" + conceptId + '\\'' +\n\t\t\t\t\", componentId='\" + getComponentId() + '\\'' +\n\t\t\t\t\", ignorePublishedCheck='\" + isIgnorePublishedCheck() + '\\'' +\n\t\t\t\t\", published='\" + isPublished() + '\\'' +\n\t\t\t\t\", message='\" + message + '\\'' +\n\t\t\t\t'}';\n\t}\n\n\tprivate static final class DummyComponent implements Component {\n\n\t\t@Override\n\t\tpublic String getId() {\n\t\t\treturn Constants.ROOT_CONCEPT;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isActive() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isPublished() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isReleased() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getModuleId() {\n\t\t\treturn Constants.ROOT_CONCEPT;\n\t\t}\n\t}\n}\nsnomed-drools-engine/src/test/java/org/ihtsdo/drools/unittest/domain/DescriptionImpl.java\npublic class DescriptionImpl implements Description {\n\n\tprivate final String id;\n\tprivate String moduleId;\n\tprivate String conceptId;\n\tprivate String term;\n\tprivate Map<String, String> acceptabilityMap;\n\tprivate boolean published;\n\tprivate boolean released;\n\n\tpublic DescriptionImpl(String id, String term) {\n\t\tthis.id = id;\n\t\tthis.term = term;\n\t\tthis.acceptabilityMap = new HashMap<>();\n\t}\n\n\tpublic DescriptionImpl published() {\n\t\tpublished = true;\n\t\treturn this;\n\t}\n\n\tpublic DescriptionImpl addToAcceptability(String key, String value) {\n\t\tacceptabilityMap.put(key, value);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic String getModuleId() {\n\t\treturn moduleId;\n\t}\n\n\tpublic void setModuleId(String moduleId) {\n\t\tthis.moduleId = moduleId;\n\t}\n\n\t@Override\n\tpublic boolean isActive() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isPublished() {\n\t\treturn published;\n\t}\n\n\t@Override\n\tpublic boolean isReleased() {\n\t\treturn released;\n\t}\n\n\t@Override\n\tpublic String getTypeId() {\n\t\treturn \"\";\n\t}\n\n\t@Override\n\tpublic String getLanguageCode() {\n\t\treturn \"\";\n\t}\n\n\t@Override\n\tpublic String getConceptId() {\n\t\treturn conceptId;\n\t}\n\n\t@Override\n\tpublic String getCaseSignificanceId() {\n\t\treturn \"\";\n\t}\n\n\t@Override\n\tpublic String getTerm() {\n\t\treturn term;\n\t}\n\n\t@Override\n\tpublic boolean isTextDefinition() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Map<String, String> getAcceptabilityMap() {\n\t\treturn acceptabilityMap;\n\t}\n\n\tpublic void setConceptId(String conceptId) {\n\t\tthis.conceptId = conceptId;\n\t}\n\n\tpublic void setTerm(String term) {\n\t\tthis.term = term;\n\t}\n\n\tpublic void setReleased(boolean released) {\n\t\tthis.released = released;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Description{\" +\n\t\t\t\t\"term='\" + term + '\\'' +\n\t\t\t\t'}';\n\t}\n}\nsnomed-drools-engine/src/main/java/org/ihtsdo/drools/exception/RuleExecutorException.java\npublic class RuleExecutorException extends RuntimeException {\n\n\tpublic RuleExecutorException(String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic RuleExecutorException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n}\nsnomed-drools-engine/src/test/java/org/ihtsdo/drools/rulestestrig/service/TestRelationshipService.java\npublic class TestRelationshipService implements RelationshipService {\n\n\tprivate final Map<String, Concept> concepts;\n\tprivate final Logger logger = LoggerFactory.getLogger(getClass());\n\n\tpublic TestRelationshipService(Map<String, Concept> concepts) {\n\t\tthis.concepts = concepts;\n\t}\n\n\t@Override\n\tpublic boolean hasActiveInboundStatedRelationship(String conceptId) {\n\t\treturn hasActiveInboundStatedRelationship(conceptId, null);\n\t}\n\n\t@Override\n\tpublic boolean hasActiveInboundStatedRelationship(String conceptId, String relationshipTypeId) {\n\t\tfor (Concept concept : concepts.values()) {\n\t\t\tif (!conceptId.equals(concept.getId())) {\n\t\t\t\tfor (Relationship relationship : concept.getRelationships()) {\n\t\t\t\t\tif (relationship.isActive()\n\t\t\t\t\t\t\t&& conceptId.equals(relationship.getDestinationId())\n\t\t\t\t\t\t\t&& !Constants.INFERRED_RELATIONSHIP.equals(relationship.getCharacteristicTypeId())\n\t\t\t\t\t\t\t&& (relationshipTypeId == null || relationshipTypeId.equals(relationship.getTypeId()))) {\n\t\t\t\t\t\tlogger.info(\"Active inbound relationship sourceId {}\", relationship.getSourceId());\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}\nsnomed-drools-engine/src/main/java/org/ihtsdo/drools/service/TestResourceProvider.java\npublic class TestResourceProvider {\n\n\tprivate static final String SEMANTIC_TAG_FILENAME = \"semantic-tags.txt\";\n\tprivate static final String CASE_SIGNIFICANT_WORDS_FILENAME = \"cs_words.txt\";\n\tprivate static final String US_TO_GB_TERMS_MAP_FILENAME = \"us-to-gb-terms-map.txt\";\n\n\tprivate final ResourceManager resourceManager;\n\tprivate final Logger logger = LoggerFactory.getLogger(getClass());\n\tprivate final Set<String> semanticTags;\n\tprivate final Set<String> caseSignificantWords;\n\tprivate final Map<String, String> usToGbTermMap;\n\n\tpublic TestResourceProvider(ResourceManager resourceManager) throws IOException {\n\t\tthis.resourceManager = resourceManager;\n\t\tsemanticTags = loadSemanticTags();\n\t\tcaseSignificantWords = loadCaseSignificantWords();\n\t\tusToGbTermMap = doGetUsToGbTermMap();\n\t}\n\n\tpublic boolean isAnyResourcesLoaded() {\n\t\treturn (semanticTags != null && !semanticTags.isEmpty())\n\t\t\t\t|| (caseSignificantWords != null && !caseSignificantWords.isEmpty())\n\t\t\t\t|| (usToGbTermMap != null && !usToGbTermMap.isEmpty());\n\t}\n\n\t/**\n\t * Returns cached semantic tags list.\n\t * @return Set of semantic tags.\n\t */\n\tpublic Set<String> getSemanticTags() {\n\t\treturn semanticTags;\n\t}\n\n\t/**\n\t * Returns cached case significant words list.\n\t * @return Set of significant words.\n\t */\n\tpublic Set<String> getCaseSignificantWords() {\n\t\treturn caseSignificantWords;\n\t}\n\n\t/**\n\t * Returns cached US to GB terms map.\n\t * @return US to GB terms map.\n\t */\n\tpublic Map<String, String> getUsToGbTermMap() {\n\t\treturn usToGbTermMap;\n\t}\n\n\tprivate Set<String> loadSemanticTags() throws IOException {\n\t\tSet<String> terms = new HashSet<>();\n\t\ttry (BufferedReader reader = new BufferedReader(new InputStreamReader(resourceManager.readResourceStream(SEMANTIC_TAG_FILENAME)))) {\n\t\t\tString line;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tterms.add(line.trim());\n\t\t\t}\n\t\t}\n\t\tlogger.info(\"{} semantic tags loaded\", terms.size());\n\t\treturn terms;\n\t}\n\n\tprivate Set<String> loadCaseSignificantWords() throws IOException {\n\t\tSet<String> terms = new HashSet<>();\n\t\ttry (BufferedReader reader = new BufferedReader(new InputStreamReader(resourceManager.readResourceStream(CASE_SIGNIFICANT_WORDS_FILENAME)))) {\n\t\t\tString line;\n\t\t\treader.readLine();// Discard header line\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tif (line.endsWith(\"1\")) {\n\t\t\t\t\tterms.add(line.trim());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlogger.info(\"{} case significant words loaded\", terms.size());\n\t\treturn terms;\n\t}\n\n\tprivate Map<String, String> doGetUsToGbTermMap() throws IOException {\n\t\tMap<String, String> usToGbTermMap = new HashMap<>();\n\t\ttry (BufferedReader reader = new BufferedReader(new InputStreamReader(resourceManager.readResourceStream(US_TO_GB_TERMS_MAP_FILENAME)))) {\n\t\t\tString line;\n\t\t\tint lineNum = 0;\n\t\t\treader.readLine();// Discard header line\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tlineNum++;\n\t\t\t\tif (!line.isEmpty()) {\n\t\t\t\t\tString[] split = line.split(\"\\\\t\");\n\t\t\t\t\tif (split.length != 2) {\n\t\t\t\t\t\tlogger.warn(\"Line {} in test resource file {} should contain 2 columns but contains {}\", lineNum, US_TO_GB_TERMS_MAP_FILENAME, split.length);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusToGbTermMap.put(split[0].trim(), split[1].trim());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlogger.info(\"{} US to GB term map entries loaded\", usToGbTermMap.size());\n\t\treturn usToGbTermMap;\n\t}\n\n}\n", "answers": ["\tprivate TestConceptService conceptService;"], "length": 3889, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "1e8551566f7917e7fea1ac7582d10458b2b270ca63b455bf"}
{"input": "from tousix_manager.Administration.actions import generate_routeserver_conf, generate_openflow_rules, generate_faucet_config, get_rules_list, change_hote_status, apply_hote_on_production, get_percentile_hote, download_csv, download_csv_faucet\nfrom tousix_manager.Administration.adminsite import admin_tousix\nfrom django.contrib import admin\nfrom django.contrib.auth.admin import UserAdmin\nfrom django.contrib.auth.models import User\nfrom fsm_admin.mixins import FSMTransitionMixin\nfrom tousix_manager.Administration.forms import HoteForm, SwitchForm, MembreForm, PortForm, UserMembreForm\nfrom tousix_manager.Database.models import Membre, Hote, Port, Pop, Contact, Switch, LogSwitch, Regles, ConnectionType, UserMembre, Switchlink\n    Class for member visibility in admin panel.\n    \"\"\"\n    list_display = [\"nommembre\", \"url\", \"asnumber\", \"approved\", \"login_external\"]\n    inlines = [HoteInLine]\n    list_filter = ['approved']\n    form = MembreForm\n    search_fields = [\"nommembre\", \"asnumber\"]\n    actions = [generate_routeserver_conf, download_csv]\n\n\n@admin.register(Hote)\nclass HoteAdmin(FSMTransitionMixin, admin.ModelAdmin):\n    \"\"\"\n    Class for router visibility in admin panel.\n    \"\"\"\n    list_display = [\"nomhote\", \"ipv4hote\", \"ipv6hote\", \"machote\", \"membre\", \"pop\", \"switch\", \"port\", \"etat\"]\n    exclude = [\"idmembre\"]\n    list_filter = ['valid']\n    search_fields = [\"nomhote\", \"ipv4hote\", \"ipv6hote\", \"machote\"]\n    form = HoteForm\n    actions = [generate_routeserver_conf, change_hote_status, apply_hote_on_production, get_percentile_hote, download_csv_faucet]\n    readonly_fields = ['etat']\n    fsm_field = ['etat']\n\n    def save_model(self, request, obj, form, change):\n        \"\"\"\n        Method used for changing the status when the MAC address was modified.\n        :param request:\n        :param obj:\n        :param form:\n        :param change:\n        :return:\n        \"\"\"\n        previous = self.model.objects.filter(idhote=obj.idhote).first()\n        obj.save()\n        if obj.etat == \"Production\":\n            if obj.machote != previous.machote:\n                obj.Prepare()\n                obj.save()\n\n\n@admin.register(Port)\nclass PortAdmin(admin.ModelAdmin):\n    \"\"\"\n    Class for port visibility in admin panel.\n    \"\"\"\n    list_display = [\"idport\", \"switch\", \"numport\", \"typeport\", \"enabled\", \"backbone\"]\n    inlines = [HoteInLine]\n    form = PortForm\n    list_filter = [\"idswitch__nomswitch\"]\n    search_fields = [\"numport\", 'idswitch__nomswitch']\n\n\n@admin.register(Pop)\nclass PopAdmin(admin.ModelAdmin):\n    \"\"\"\n    Class for POP visibility in admin panel.\n    \"\"\"\n    list_display = [\"nompop\"]\n\n\n@admin.register(Contact)\nclass ContactAdmin(admin.ModelAdmin):\n    \"\"\"\n    Class for contact visibility in admin panel.\n    \"\"\"\n    exclude = [\"idcontact\"]\n    list_display = [\"nomcontact\", \"prenomcontact\", \"telcontact\", \"mailcontact\"]\n    search_fields = [\"nomcontact\", \"prenomcontact\"]\n\n\n@admin.register(Switch)\nclass SwitchAdmin(admin.ModelAdmin):\n    \"\"\"\n    Class for switch visibility in admin panel.\n    \"\"\"\n    list_display = [\"nomswitch\", \"ipswitch\", \"dpid_switch\"]\n    form = SwitchForm\n    search_fields = [\"nomswitch\", \"ipswitch\", \"dpid_switch\"]\n    actions = [generate_openflow_rules, generate_faucet_config, download_csv]\n\n\n@admin.register(LogSwitch)\nclass LogSwitchAdmin(admin.ModelAdmin):\n    \"\"\"\n    Class for log visibility in admin panel.\n    \"\"\"\n    list_display = ['nomswitch', \"time\", \"level\", \"message\"]\n    search_fields = ['idswitch__nomswitch', \"level\", \"time\"]\n    list_filter = ['idswitch__nomswitch', \"level\"]\n    readonly_fields = ['idlog', \"idswitch\", \"time\", \"level\", \"message\", \"json\"]\n\n\n@admin.register(Regles)\nclass ReglesField(FSMTransitionMixin, admin.ModelAdmin):\n    \"\"\"\n    Class for rules visibility in admin panel.\n    \"\"\"\n    readonly_fields = ['idregle', 'typeregle', 'regle', 'idswitch', 'etat']\n    list_display = ['switch', 'regle', 'typeregle', 'etat']\n    search_fields = ['regle']\n    list_filter = ['idswitch__nomswitch', \"typeregle\", \"source__nomhote\", \"destination__nomhote\"]\n    actions = [get_rules_list, download_csv]\n    fsm_field = ['etat']\n\n\n@admin.register(ConnectionType)\nclass ConnectionTypeAdmin(admin.ModelAdmin):\n    \"\"\"\n    Class for ConnectionType visibility in admin panel\n    \"\"\"\n    list_display = [\"connection_type\"]\n\n\n@admin.register(UserMembre)\nclass UserMembreAdmin(admin.ModelAdmin):\n    list_display = ['user', 'nommembre']\n    form = UserMembreForm\n\n\n", "context": "tousix_manager/Administration/actions.py\ndef generate_routeserver_conf(modeladmin, request, queryset):\n    \"\"\"\n    Action for generating BIRD configuration files.\n    :param modeladmin:\n    :param request:\n    :param queryset:\n    :return:\n    \"\"\"\n    # remove keyboard-chair errors\n    if modeladmin.model is Membre:\n        queryset = queryset.exclude(nommembre=\"TouIX\")\n        data = render_conf_members(queryset)\n        return render(request, \"members_list.html\", context=data)\n    elif modeladmin.model is Hote:\n        queryset = queryset.exclude(idmembre__nommembre=\"TouIX\")\n        data = render_conf_hosts(queryset)\n        return render(request, \"members_list.html\", context=data)\ntousix_manager/Database/models.py\nclass Membre(models.Model):\n    \"\"\"\n    The member model contains all the information needed about an entity which is member of the IXP.\n    \"\"\"\n    idmembre = models.AutoField(db_column='idMembre', primary_key=True)\n    nommembre = models.CharField(db_column='NomMembre', max_length=30, blank=True, null=True, verbose_name=\"Nom membre\")\n    url = models.URLField(null=True, verbose_name=\"Lien site web\")\n    statut = models.CharField(db_column='Statut', max_length=12, blank=True, null=True)\n    asnumber = models.PositiveIntegerField(db_column='ASNumber', verbose_name=\"N°AS\")\n    connexion_type = models.ForeignKey(ConnectionType, blank=True, null=True, verbose_name=\"Type de connexion\")\n    fqdn_host = models.CharField(max_length=30, default=\"Undefined\", verbose_name=\"FQDN Routeur\")\n    idpop = models.ForeignKey(Pop, to_field='idpop', db_column='idPoP', null=True)\n    billing = models.OneToOneField(Contact, to_field='idcontact', related_name='billing', parent_link=True, blank=True, null=True, on_delete=models.SET_NULL)\n    noc = models.OneToOneField(Contact, to_field='idcontact', related_name='noc', parent_link=True, blank=True, null=True, on_delete=models.SET_NULL)\n    technical = models.OneToOneField(Contact, to_field='idcontact', related_name='technical', parent_link=True, blank=True, null=True, on_delete=models.SET_NULL)\n    approved = models.BooleanField(default=False)\n    login_external = models.CharField(max_length=35, default=\"guest\")\n\n    class Meta:\n        db_table = 'Membre'\ntousix_manager/Administration/actions.py\ndef download_csv(modeladmin, request, queryset):\n    \"\"\"\n    Snippet from https://djangosnippets.org/snippets/2690/\n    :param modeladmin:\n    :param request:\n    :param queryset:\n    :return:\n    \"\"\"\n    if not request.user.is_staff:\n        raise PermissionDenied\n    opts = queryset.model._meta\n    response = HttpResponse(content_type='text/csv')\n    # force download.\n    response['Content-Disposition'] = 'attachment;filename=export.csv'\n    # the csv writer\n    writer = csv.writer(response)\n    field_names = [field.name for field in opts.fields]\n    # Write a first row with header information\n    writer.writerow(field_names)\n    # Write data rows\n    for obj in queryset:\n        writer.writerow([getattr(obj, field) for field in field_names])\n    return response\ntousix_manager/Database/models.py\nclass Port(models.Model):\n    \"\"\"\n    Model for ports in :model:`Database.Switch`.\n    \"\"\"\n    idport = models.AutoField(db_column='idPort', primary_key=True)\n    numport = models.IntegerField(db_column='numPort', blank=True, null=True)\n    typeport = models.CharField(db_column='TypePort', max_length=10, blank=True, null=True)\n    enabled = models.BooleanField(db_column='Usable')\n    backbone = models.BooleanField(db_column='backbone')\n    idswitch = models.ForeignKey(Switch, to_field='idswitch', db_column='idSwitch')\n\n    def switch(self):\n        \"\"\"\n        Returns the string name of the :model:`Database.Switch` linked to this port.\n        :return: Switch name\n        \"\"\"\n        return self.idswitch.nomswitch\n\n    def string_description(self):\n        \"\"\"\n        Return a complete information about the location of the port.\n        :return: String port information\n        \"\"\"\n        return \"POP \" + self.idswitch.idpop.nompop + \": \" + self.idswitch.nomswitch + \" port \" + str(self.numport)\n\n    class Meta:\n        db_table = 'Port'\ntousix_manager/Administration/forms.py\nclass HoteForm(forms.ModelForm):\n    \"\"\"\n    ModelForm with custom router display.\n    This form handles the link between :model:`Database.Port` and :model:`Database.Hote`.\n    Depending of the context (relationship non-established, initial value), it will\n    create a custom list with complete description all the ports avaliable.\n    \"\"\"\n    idport = PortChoiceField(queryset=Port.objects\n                             .filter(enabled=True), empty_label=None)\n\n    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,\n                 initial=None, error_class=ErrorList, label_suffix=None,\n                 empty_permitted=False, instance=None, use_required_attribute=None):\n        super(HoteForm, self).__init__(data, files, auto_id, prefix,\n                                       initial, error_class, label_suffix,\n                                       empty_permitted, instance, use_required_attribute)\n        if self.instance.idhote is not None:\n            # Set idport editing value for instance\n            self.fields[\"idport\"].queryset = Port.objects.filter(enabled=True)\n            if self.instance.idport is not None:\n                self.fields[\"idport\"].initial = {self.instance.idport_id: self.instance.idport.string_description}\n\n    class Meta:\n        model = Hote\n        exclude = [\"idmembre\"]\ntousix_manager/Database/models.py\nclass UserMembre(models.Model):\n    user = models.OneToOneField(User, unique=True)\n    membre = models.ForeignKey(Membre)\n\n    class Meta:\n        db_table = 'UserMembre'\n\n    def nommembre(self):\n        return self.membre.nommembre\ntousix_manager/Database/models.py\nclass Contact(models.Model):\n    \"\"\"\n    Model for Contact registration.\n    All the fields are optional.\n    \"\"\"\n    idcontact = models.AutoField(db_column='idContact', primary_key=True)\n    nomcontact = models.CharField(db_column='NomContact', max_length=50, blank=True, null=True, verbose_name=\"Nom\")\n    prenomcontact = models.CharField(db_column='PrenomContact', max_length=50, blank=True, null=True, verbose_name=\"Prénom\")\n    adressecontact = models.CharField(db_column='AdresseContact', max_length=300, blank=True, null=True, verbose_name=\"Adresse\")\n    mailcontact = models.EmailField(db_column='MailContact', max_length=100, blank=True, null=True, verbose_name=\"Mail\")\n    telcontact = models.CharField(db_column='TelContact', max_length=14, blank=True, null=True, verbose_name=\"Téléphone\")\n\n    class Meta:\n        db_table = 'Contact'\ntousix_manager/Database/models.py\nclass Switchlink(models.Model):\n    \"\"\"\n    This model is used for representing logical links between two :model:`Database.Switch`.\n    \"\"\"\n    idport1 = models.OneToOneField(Port, to_field='idport', db_column='idPort1', related_name='idport1', unique=True)\n    idport2 = models.OneToOneField(Port, to_field='idport', db_column='idPort2', related_name='idport2', unique=True)\n    name = models.CharField(max_length=25, null=False, default='link')\n\n    class Meta:\n        db_table = 'SwitchLink'\n        unique_together = (('idport1', 'idport2'),)\ntousix_manager/Administration/actions.py\ndef get_rules_list(modeladmin, request, queryset):\n    \"\"\"\n    Action for display plain text rules selected in admin view.\n    \"\"\"\n    text = \"\"\n    for rule in queryset:\n        text += rule.regle + \"\\n\"\n    return render(request, \"switches_list.html\", context={\"rules\": text})\ntousix_manager/Administration/actions.py\ndef generate_openflow_rules(modeladmin, request, queryset):\n    \"\"\"\n    Action for generating openflow rules on switch.\n    :param modeladmin:\n    :param request:\n    :param queryset:\n    :return:\n    \"\"\"\n    manager = RyuManager()\n    manager.create_rules(queryset)\n    modeladmin.message_user(request, \"Les règles ont été mises à jour dans la base de données.\")\n    return redirect('rules_confirm')\ntousix_manager/Administration/actions.py\ndef apply_hote_on_production(modeladmin, request, queryset):\n    \"\"\"\n    Action to apply openflow flow rules from selected hosts into the controller.\n    \"\"\"\n    for hote in queryset:\n        if hote.valid is True:\n            if settings.APPLY_PRODUCTION_METHOD is 'Ryu':\n                manager = RyuManager()\n                manager.create_rules_single(Switch.objects.all(), hote)\n                deployment = RulesDeployment()\n                deployment.send_flowrules_single_host(Switch.objects.all(), hote)\n                modeladmin.message_user(request,\"Les paramètres du router \" + hote.nomhote + \" ont été appliqués sur la production.\")\n            elif settings.APPLY_PRODUCTION_METHOD is 'Faucet':\n                manager = FaucetManager()\n                manager.convert_table()\n                manager.generate_all_peers()\n                manager.dump_config()\n                modeladmin.message_user(request,\"Les paramètres du router \" + hote.nomhote + \" ont été appliqués sur le fichier \"+ settings.FAUCET_SETTINGS['faucet_config_path'] +\". Veuiller relancer faucet pour appliquer la configuration\")\n\n            else:\n                modeladmin.message_user(request, \"Les paramètres n'ont pas pu être appliqués: mauvaise définition de APPLY_PRODUCTION_METHOD\")\n                return None\n        else:\n            raise Exception(\"Not a valid router.\")\ntousix_manager/Database/models.py\nclass Regles(models.Model):\n    \"\"\"\n    Model for saving rules associated with :model:`Database.Switch`.\n    It is recommended to keep up-to-date this model with the production,\n    as the controller could ask to apply the rules in the Database.\n    \"\"\"\n    idregle = models.AutoField(db_column='idRegle', primary_key=True)\n    typeregle = models.CharField(db_column='TypeRegle', max_length=40, blank=True, null=True)\n    regle = models.TextField(db_column='Regle', blank=True, null=True)\n    idswitch = models.ForeignKey(Switch, to_field='idswitch', db_column='idSwitch')\n    source = models.ForeignKey(Hote, related_name=\"source\", verbose_name=\"Source\", null=True)\n    destination = models.ForeignKey(Hote, related_name=\"destination\", verbose_name=\"Destination\", null=True)\n    etat = FSMField(default=\"Production\")\n\n    @transition(field=etat, source=\"Production\", target=\"Deprecated\")\n    def ChangeRulesStatus(self):\n        \"\"\"\n        This transition method does nothing, it needs to be called just to make a transition for the etat field.\n        :return:\n        \"\"\"\n        pass\n\n    def switch(self):\n        \"\"\"\n        Return the name of the :model:`Database.Switch` associated with this rule.\n        :return:\n        \"\"\"\n        return self.idswitch.nomswitch\n\n    class Meta:\n        db_table = 'Règles'\n        verbose_name = \"Règle\"\ntousix_manager/Administration/actions.py\ndef change_hote_status(modeladmin, request, queryset):\n    \"\"\"\n    This action is only present because the change status button\n    of an django application does not seem to work (django-fsm-admin).\n    \"\"\"\n    for hote in queryset:\n        if hote.etat == \"Changing\":\n            hote.Apply()\n            hote.save()\n            modeladmin.message_user(request, \"Le statut du routeur \"+hote.nomhote+\" a été changé.\")\n        elif hote.etat == \"Inactive\":\n            hote.Deploy()\n            hote.save()\n            modeladmin.message_user(request, \"Le statut du routeur \"+hote.nomhote+\" a été changé.\")\ntousix_manager/Database/models.py\nclass Switch(models.Model):\n    \"\"\"\n    Model representing any type of switch (even the legacy ones could be referenced).\n    \"\"\"\n    idswitch = PositiveBigIntegerField(db_column='idSwitch', primary_key=True)\n    dpid_switch = PositiveBigIntegerField(default=1)\n    nomswitch = models.CharField(db_column='nomSwitch', max_length=20, blank=True, null=True)\n    faucet_class = models.CharField(null=False, blank=True, max_length=35)\n    ipswitch = models.CharField(db_column='IPSwitch', max_length=39, blank=True, null=True)\n    idpop = models.ForeignKey(Pop, to_field='idpop', db_column='idPOP', blank=True, null=True)\n\n    class Meta:\n        db_table = 'Switch'\ntousix_manager/Administration/forms.py\nclass PortForm(forms.ModelForm):\n    \"\"\"\n    ModelForm for modify :model:`Database.Port` with custom fields.\n    \"\"\"\n    idswitch = SwitchChoiceField(queryset=Switch.objects.all(), empty_label=None)\n\n    class Meta:\n        model = Port\n        fields = ['idswitch', 'numport', 'typeport', 'enabled', 'backbone']\ntousix_manager/Database/models.py\nclass Pop(models.Model):\n    \"\"\"\n    Model for referencing all the informations of POP.\n    It is advised to use a short name,\n    because the value is often used for logging and display information in a limited space.\n    \"\"\"\n    idpop = models.AutoField(db_column='idPOP', primary_key=True)\n    nompop = models.CharField(db_column='NomPOP', max_length=30, blank=True, null=True)\n    adressepop = models.TextField(db_column='AdressePOP', max_length=300, blank=True, null=True)\n\n    class Meta:\n        db_table = 'POP'\ntousix_manager/Database/models.py\nclass Hote(models.Model):\n    \"\"\"\n    Model for routeurs present in the topology.\n    It is recommended, even if it is optional,\n    to fill all the fields before doing any actions with deployment and rules generation app.\n\n    It is also recommended to avoid to modify the etat field, unless you know what you are doing.\n    This field is linked with side effect methods.\n    \"\"\"\n    idhote = models.AutoField(db_column='IdHote', primary_key=True)\n    nomhote = models.CharField(db_column='NomHote', max_length=30, blank=False, null=False, verbose_name=\"Nom routeur\")\n    machote = MACAddressField(db_column='MACHote', verbose_name=\"Adresse MAC\", blank=False, null=False)\n    ipv4hote = models.GenericIPAddressField(db_column='IPv4Hote', verbose_name=\"Adresse IPv4\", null=True)\n    ipv6hote = models.GenericIPAddressField(db_column='IPv6Hote', verbose_name=\"Adresse IPv6\", null=True)\n    idmembre = models.ForeignKey(Membre, to_field='idmembre', db_column='idMembre')\n    idport = models.ForeignKey(Port, to_field='idport', db_column='idPort', blank=True, null=True)\n    valid = models.BooleanField(default=False)\n    internal_server = models.BooleanField(default=False)\n    etat = FSMField(default=\"Inactive\")\n\n    def membre(self):\n        \"\"\"\n        Returns the member name associated with this router.\n        :return: Member name\n        \"\"\"\n        return self.idmembre.nommembre\n\n    def switch(self):\n        \"\"\"\n        Returns the string name of the :model:`Database.Switch` linked to this router, if it was defined by the administrator.\n        :return: Switch name\n        \"\"\"\n        if self.idport is None:\n            return \"Undefined\"\n        else:\n            return self.idport.idswitch.nomswitch\n\n    def port(self):\n        \"\"\"\n        Returns the string name of the :model:`Database.Port` number linked to this router, if it was defined by the administrator.\n        :return: Port number\n        \"\"\"\n        if self.idport is None:\n            return \"Undefined\"\n        else:\n            return self.idport.numport\n\n    def pop(self):\n        \"\"\"\n        Returns the string name of the :model:`Database.POP` which the router is linked, if it was defined by the administrator.\n        :return: POP name\n        \"\"\"\n        if self.idport is None:\n            return \"Undefined\"\n        else:\n            return self.idport.idswitch.idpop.nompop\n\n    class Meta:\n        db_table = 'Hôte'\n        unique_together = (('idhote', 'idmembre'),)\n\n    @transition(field=etat, source=\"Inactive\", target=\"Production\")\n    def Deploy(self):\n        \"\"\"\n        Transition method for deploy a router in the topology, pushing all the rules necessary.\n        :return:\n        \"\"\"\n        if self.valid is True:\n            if settings.APPLY_PRODUCTION_METHOD is 'Ryu':\n\n                manager = Manager()\n                manager.create_rules(Switch.objects.all())\n                deployment = RulesDeployment()\n                deployment.send_rules(Switch.objects.all())\n        else:\n            raise Exception(\"Not a valid router.\")\n\n    @transition(field=etat, source=\"Production\", target=\"Changing\", custom={\"admin\":False})\n    def Prepare(self):\n        \"\"\"\n        Transition method for moving the rules of the previous configuration into a special state,\n        and applies rules for the new configuration.\n        :return:\n        \"\"\"\n        #TODO write transition state for faucet\n        if settings.APPLY_PRODUCTION_METHOD is 'Ryu':\n\n            regles = Regles.objects.filter(Q(source=self) | Q(destination=self))\n            for regle in regles:\n                regle.ChangeRulesStatus()\n                regle.save()\n            manager = Manager()\n            manager.create_rules(Switch.objects.all())\n            deployment = RulesDeployment()\n            deployment.send_rules(Switch.objects.all())\n\n    @transition(field=etat, source=\"Changing\", target=\"Production\")\n    def Apply(self):\n        \"\"\"\n        Transition method for removing rules applied for the previous configuration of the router.\n        :return:\n        \"\"\"\n        if settings.APPLY_PRODUCTION_METHOD is 'Ryu':\n\n            regles_deprecated = Regles.objects.filter((Q(source=self) | Q(destination=self)) & Q(etat=\"Deprecated\"))\n            regles_production = Regles.objects.filter((Q(source=self) | Q(destination=self)) & Q(etat=\"Production\")).values(\"regle\")\n            regles_invalides = regles_deprecated.exclude(Q(regle__in=regles_production))\n            deployment = RulesDeployment()\n            deployment.remove_rules(regles_invalides)\n            regles_deprecated.delete()\ntousix_manager/Administration/actions.py\ndef get_percentile_hote(modeladmin, request, queryset):\n    billing = BillingView()\n    for hote in queryset:\n        modeladmin.message_user(request, \"Bande passante consommé pour l'hôte \" + hote.nomhote + \": \" + str(billing.show_result(hote.idhote)) + \" bit/s\")\ntousix_manager/Database/models.py\nclass ConnectionType(models.Model):\n    \"\"\"\n    Model used for referencing all the connection types avaliable in the topology.\n    \"\"\"\n    connection_type = models.CharField(max_length=20, null=False)\n\n    class Meta:\n        db_table = 'Connection_type'\ntousix_manager/Administration/actions.py\ndef generate_faucet_config(modeladmin, request, queryset):\n    \"\"\"\n    Action for generating openflow rules on switch.\n    :param modeladmin:\n    :param request:\n    :param queryset:\n    :return:\n    \"\"\"\n    manager = FaucetManager()\n    data = manager.generate_all_peers()\n    manager.dump_config()\n    modeladmin.message_user(request, \"Le fichier de configuration Faucet a été modifié. Veuillez recharger le service afin d'appliquer les modifications\")\n    return render(request, \"config_confirm.html\", context={\"data\": data})\ntousix_manager/Administration/forms.py\nclass MembreForm(forms.ModelForm):\n    \"\"\"\n    ModelForm for modify :model:`Database.Membre` with custom fields.\n    \"\"\"\n    idpop = PopChoiceField(queryset=Pop.objects.all())\n    connexion_type = ConnexionChoiceField(queryset=ConnectionType.objects.all())\n\n    class Meta:\n        model = Membre\n        fields = [\"nommembre\", \"asnumber\", \"connexion_type\", \"fqdn_host\", \"idpop\", \"approved\", \"login_external\"]\ntousix_manager/Administration/forms.py\nclass SwitchForm(forms.ModelForm):\n    \"\"\"\n    ModelForm for modify :model:`Database.Switch` with custom fields.\n    \"\"\"\n    idpop = PopChoiceField(queryset=Pop.objects.all(), empty_label=None)\n\n    class Meta:\n        model = Switch\n        fields = ['nomswitch', 'dpid_switch', 'ipswitch', 'idpop', 'faucet_class']\ntousix_manager/Database/models.py\nclass LogSwitch(models.Model):\n    \"\"\"\n    This model contains all logs delivered by the :model:`Database.Switch` trough the web application.\n    The JSON field is optionnal, but it is recommended to fill it with the other informations when it is possible.\n    Additional methods could extract information from JSON data in the future.\n    \"\"\"\n    idlog = models.AutoField(primary_key=True)\n    idswitch = models.ForeignKey(Switch, to_field='idswitch', db_column='idSwitch', unique=False)\n    time = models.DateTimeField(auto_now_add=True)\n    level = models.CharField(max_length=10)\n    message = models.TextField()\n    json = models.TextField(null=True)\n\n    def nomswitch(self):\n        return self.idswitch.nomswitch\n\n    class Meta:\n        db_table = \"SwitchLog\"\ntousix_manager/Administration/forms.py\nclass UserMembreForm(forms.ModelForm):\n    membre = MemberChoiceField(queryset=Membre.objects.all(), empty_label=None)\n\n    class Meta:\n        model = UserMembre\n        fields = ['user', 'membre']\ntousix_manager/Administration/actions.py\ndef download_csv_faucet(modeladmin, request, queryset):\n    \"\"\"\n    Snippet from https://djangosnippets.org/snippets/2690/\n    :param modeladmin:\n    :param request:\n    :param queryset:\n    :return:\n    \"\"\"\n    if not request.user.is_staff:\n        raise PermissionDenied\n    opts = queryset.model._meta\n    response = HttpResponse(content_type='text/csv')\n    # force download.\n    response['Content-Disposition'] = 'attachment;filename=export.csv'\n    # the csv writer\n    writer = csv.writer(response)\n    field_names = [\"idrtr\", \"hostname\", \"addr_ipv4\", \"addr_ipv6\", \"macaddr\", \"membre\", \"pop\", \"switch\", \"port\", \"status\"]\n    # Write a first row with header information\n    writer.writerow(field_names)\n    # Write data rows\n    for obj in queryset:\n        lookup = Hote.objects.get(idhote=obj.idhote)\n        writer.writerow([obj.idhote, obj.nomhote, obj.ipv4hote, obj.ipv6hote, obj.machote, lookup.membre(), lookup.pop(), lookup.switch(), lookup.port(), obj.etat])\n    return response\n", "answers": ["@admin.register(Switchlink)"], "length": 2184, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "f362d7ca9f6cbc26ea032bb9b7623345c2e5b9c5e87cdd83"}
{"input": "import static org.lwjgl.opengl.GL11.*;\nimport com.melanistics.TickHandler;\nimport com.melanistics.event.PlayerJumpEvent;\nimport com.naronco.cubeshaft.Entity;\nimport com.naronco.cubeshaft.INamedEntity;\nimport com.naronco.cubeshaft.ItemEntity;\nimport com.naronco.cubeshaft.level.Level;\nimport com.naronco.cubeshaft.mob.Mob;\nimport com.naronco.cubeshaft.model.HumanModel;\nimport com.naronco.cubeshaft.phys.HitBox;\nimport com.naronco.cubeshaft.render.TextureLoader;\n/*\n * This file is part of Cubeshaft\n * Copyright Naronco 2013\n * Sharing and using is only allowed with written permission of Naronco\n */\n\npackage com.naronco.cubeshaft.player;\n\n\n\npublic class Player extends Entity implements INamedEntity\n{\n\tpublic static HumanModel PLAYER_MODEL = new HumanModel();\n\tpublic boolean[] keys = new boolean[10];\n\tpublic Inventory inventory;\n\tprivate String name;\n\n\tpublic Player(Level level, String par1) {\n\t\t\n\t\tsuper(level);\n\t\tname = par1;\n\t\tthis.heightOffset = 1.62f;\n\t\tthis.inventory = new Inventory();\n\t\thitbox = HitBox.getHumanModel(bbHeight, bbWidth);\n\t}\n\t\n\t@Override\n\tpublic void collide(Entity e, String part) {\n\t\tif (e instanceof Mob)\n\t\t\tpush(e);\n\t\tif (e instanceof ItemEntity && ((ItemEntity) e).getTimebeforPickup()==0) {\n\t\t\tItemEntity i = (ItemEntity) e;\n\t\t\tif (inventory.items.size() < 13 && !inventory.items.contains(i.getTile())) \n\t\t\t{\n\t\t\t\tinventory.add(i.getTile().id);\n\t\t\t}\n\t\t\te.removed = true;\n\t\t}\n\t}\n\n\tprivate void push(Entity e) {\n\t\tfloat xd = e.x - this.x;\n\t\tfloat zd = e.z - this.z;\n\t\te.xd += xd * 0.1f;\n\t\te.zd += zd * 0.1f;\n\t\tthis.xd -= xd * 0.1f;\n\t\tthis.zd -= zd * 0.1f;\n\t}\n\n\t@Override\n\tpublic void tick() {\n\t\tthis.xo = this.x;\n\t\tthis.yo = this.y;\n\t\tthis.zo = this.z;\n\t\tfloat xa = 0.0f;\n\t\tfloat za = 0.0f;\n\t\tboolean inWater = isInWater();\n\t\tboolean inLava = isInLava();\n\t\tif (this.keys[0])\n\t\t\tza -= 1.0f;\n\t\tif (this.keys[1])\n\t\t\tza += 1.0f;\n\t\tif (this.keys[2])\n\t\t\txa -= 1.0f;\n\t\tif (this.keys[3])\n\t\t\txa += 1.0f;\n\t\tif (this.keys[4]) \n\t\t{\t\t\n\t\t\tfloat jump = yd;\n\t\t\tif (inWater) \t\t\n\t\t\t\tjump += 0.01;\n\t\t\t\n\t\t\telse if (inLava) \t\n\t\t\t\tjump += 0.01;\n\t\t\t\n\t\t\telse if (onGround) \t\n\t\t\t\tjump = 0.23f;\n\t\t\t\n\t\t\tPlayerJumpEvent e = new PlayerJumpEvent(this, jump);", "context": "src/com/naronco/cubeshaft/render/TextureLoader.java\npublic class TextureLoader {\n\tprivate static Map<String, Integer> loadedTextures = new HashMap<String, Integer>();\n\n\tpublic static final int load(String filename, int textureMode) {\n\t\ttry {\n\t\t\tif (loadedTextures.containsKey(filename)) {\n\t\t\t\treturn loadedTextures.get(filename).intValue();\n\t\t\t}\n\t\t\tIntBuffer buffer = (IntBuffer) BufferUtils.createIntBuffer(1)\n\t\t\t\t\t.clear();\n\t\t\tglGenTextures(buffer);\n\n\t\t\tint id = buffer.get(0);\n\t\t\tloadedTextures.put(filename, id);\n\t\t\tglBindTexture(GL_TEXTURE_2D, id);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, textureMode);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, textureMode);\n\n\t\t\tBufferedImage img = ImageIO.read(TextureLoader.class\n\t\t\t\t\t.getResource(filename));\n\t\t\tint width = img.getWidth();\n\t\t\tint height = img.getHeight();\n\t\t\tByteBuffer pixelsByteBuffer = BufferUtils.createByteBuffer(width\n\t\t\t\t\t* height << 2);\n\t\t\tint[] intPixels = new int[width * height];\n\t\t\tbyte[] bytePixels = new byte[width * height << 2];\n\n\t\t\timg.getRGB(0, 0, width, height, intPixels, 0, width);\n\t\t\tfor (int i = 0; i < intPixels.length; i++) {\n\t\t\t\tint a = intPixels[i] >>> 24;\n\t\t\t\tint r = intPixels[i] >> 16 & 0xff;\n\t\t\t\tint g = intPixels[i] >> 8 & 0xff;\n\t\t\t\tint b = intPixels[i] & 0xff;\n\t\t\t\tbytePixels[(i << 2) + 0] = (byte) r;\n\t\t\t\tbytePixels[(i << 2) + 1] = (byte) g;\n\t\t\t\tbytePixels[(i << 2) + 2] = (byte) b;\n\t\t\t\tbytePixels[(i << 2) + 3] = (byte) a;\n\t\t\t}\n\n\t\t\tpixelsByteBuffer.put(bytePixels);\n\t\t\tpixelsByteBuffer.position(0).limit(bytePixels.length);\n\t\t\tgluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA, width, height, GL_RGBA,\n\t\t\t\t\tGL_UNSIGNED_BYTE, pixelsByteBuffer);\n\t\t\treturn id;\n\t\t} catch (Exception e) {\n\t\t}\n\t\tthrow new RuntimeException(\"!!\");\n\t}\n}\nsrc/com/melanistics/TickHandler.java\npublic class TickHandler \n{\t\n\tpublic static EventHandler EVENT_BUS = new EventHandler();\n\t\n\tprivate List<Runnable> run = new ArrayList<>();\n\tprivate List<IInputHandler> input = new ArrayList<>();\n\t\t\n\tpublic void Tick() {\n\t\tfor (int i = 0; i < run.size(); i++) {\n\t\t\trun.get(i).run();\n\t\t}\n\t}\n\n\tpublic void Input(int par1, char par2, boolean par3) {\n\t\tfor (int i = 0; i < input.size(); i++) {\n\t\t\tinput.get(i).onKeyInput(par1, par2, par3);\n\t\t}\n\t}\n\n\tpublic void addRunnable(Runnable par1) {\n\t\trun.add(par1);\n\t}\n\n\tpublic void addInputHandler(IInputHandler par1) {\n\t\tinput.add(par1);\n\t}\n\t\n\t\n\n}\nsrc/com/melanistics/event/PlayerJumpEvent.java\npublic class PlayerJumpEvent extends Event \n{\n\tprivate Player pl;\n\tpublic float jump;\n\t\n\tpublic PlayerJumpEvent(Player p, float f)\n\t{\n\t\tpl = p;\n\t\tjump = f;\n\t}\n\t\n\tpublic Player getPlayer()\n\t{\n\t\treturn pl;\n\t}\n\t\n\t@Override\n\tpublic boolean hasResult() \n\t{\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic Object getResult() \n\t{\n\t\treturn jump;\n\t}\n}\nsrc/com/naronco/cubeshaft/mob/Mob.java\npublic class Mob extends Entity {\n\tpublic int maxHealth, health;\n\tprotected Model model;\n\tpublic float xa, za;\n\tprotected float normalSpeed = 0.2F;\n\tprotected List<AIBase> tasks = new ArrayList<>();\n\tpublic Entity target;\n\tpublic Navigator navigator = new Navigator(this);\n\t\n\tpublic Mob(Level level) \n\t{\n\t\tsuper(level);\n\t\thitbox = HitBox.getHumanModel(bbHeight, bbWidth);\n\t}\n\n\tpublic void hit(Entity e, int dmg) {\n\t}\n\n\tpublic boolean isHeadInWater() {\n\t\treturn this.level.containsLiquid(hitbox.getTotalBox(x, y, z).grow(0.0f, -1.0f, 0.0f), 1);\n\t}\n\n\tpublic void handelAI() {\n\t\tfor (AIBase base : tasks) {\n\t\t\tbase.task(this);\n\t\t}\n\t}\n\n\tpublic float getNormalSpeed() \n\t{\n\t\treturn normalSpeed;\n\t}\n\t\n\t@Override\n\tpublic void tick() {\n\t\tsuper.tick();\n\t\thandelAI();\n\t\tnavigator.navigate();\n\t\tthis.xo = this.x;\n\t\tthis.yo = this.y;\n\t\tthis.zo = this.z;\n\t\tfloat xa = 0.0f;\n\t\tfloat za = 0.0f;\n\t\tboolean inWater = isInWater();\n\t\tboolean inLava = isInLava();\n\n\t\tfloat speed = 0.007f;\n\t\tif (inWater) {\n\t\t\tmoveRel(xa, za, speed);\n\t\t\tmove(this.xd, this.yd, this.zd);\n\t\t\tthis.xd *= 0.8f;\n\t\t\tthis.yd *= 0.8f;\n\t\t\tthis.zd *= 0.8f;\n\t\t\tthis.yd = (float) (this.yd - 0.007);\n\t\t\tif ((this.collision) && (isFree(this.xd, this.yd + 0.6F, this.zd)))\n\t\t\t\tthis.yd = 0.2f;\n\t\t\treturn;\n\t\t}\n\t\tif (inLava) {\n\t\t\tmoveRel(xa, za, speed);\n\t\t\tmove(this.xd, this.yd, this.zd);\n\t\t\tthis.xd *= 0.5f;\n\t\t\tthis.yd *= 0.5f;\n\t\t\tthis.zd *= 0.5f;\n\t\t\tthis.yd = (float) (this.yd - 0.007);\n\t\t\tif ((this.collision) && (isFree(this.xd, this.yd + 0.6F, this.zd)))\n\t\t\t\tthis.yd = 0.2f;\n\t\t\treturn;\n\t\t}\n\t\tmoveRel(xa, za, onGround ? 0.03f : speed);\n\t\tmove(this.xd, this.yd, this.zd);\n\t\tthis.xd *= 0.91f;\n\t\tthis.yd *= 0.98f;\n\t\tthis.zd *= 0.91f;\n\t\tthis.yd -= 0.016f;\n\t\tif (onGround) {\n\t\t\tthis.xd *= 0.6f;\n\t\t\tthis.zd *= 0.6f;\n\t\t}\n\t}\n\n\tpublic void walk(float speed) {\n\t\txd = -(float) (Math.sin(yRot) * speed);\n\t\tzd = -(float) (Math.cos(yRot) * speed);\n\t}\n\n\tpublic void jump() {\n\t\tif (onGround)\n\t\t\tyd = 0.23f;\n\t}\n\n}\nsrc/com/naronco/cubeshaft/Entity.java\npublic class Entity {\n\tpublic Level level;\n\tpublic float xo;\n\tpublic float yo;\n\tpublic float zo;\n\tpublic float x;\n\tpublic float y;\n\tpublic float z;\n\tpublic float xd;\n\tpublic float yd;\n\tpublic float zd;\n\tpublic float xRotO;\n\tpublic float yRotO;\n\tpublic float xRot;\n\tpublic float yRot;\n\t//public AABB aabb;\n\tpublic boolean onGround = false;\n\tpublic boolean collision = false;\n\tpublic boolean removed = false;\n\tpublic float heightOffset = 0.0f;\n\tprotected float bbWidth = 0.6f;\n\tpublic float bbHeight = 1.8f;\n\t\n\tprotected HitBox hitbox;\n\n\tpublic Entity(Level level) \n\t{\n\t\tthis.level = level;\n\t\tresetPos();\n\t\thitbox = new HitBox();\n\t\thitbox.addNamedBox(new AABB(-0.1F, 0, -0.1F, 0.1F, 0.2F, 0.1F), \"body\");\n\t}\n\n\tpublic void resetPos() {\n\t\tfloat xs = (float) Math.random() * (level.width - 2) + 1.0f;\n\t\tfloat ys = level.height + 10;\n\t\tfloat zs = (float) Math.random() * (level.depth - 2) + 1.0f;\n\t\tsetPos(xs, ys, zs);\n\t}\n\n\tpublic void setSize(float width, float height) {\n\t\tthis.bbWidth = width;\n\t\tthis.bbHeight = height;\n\t}\n\n\tpublic void setPos(float x, float y, float z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tfloat wh = bbWidth / 2.0f;\n\t\tfloat hh = bbHeight / 2.0f;\n\t\t//aabb = new AABB(x - wh, y - hh, z - wh, x + wh, y + hh, z + wh);\n\t}\n\n\tpublic void tick() {\n\t\tthis.xo = x;\n\t\tthis.yo = y;\n\t\tthis.zo = z;\n\t}\n\n\tpublic void collide(Entity e, String part) \n\t{\n\t}\n\n\tpublic boolean blocks(Entity e) {\n\t\treturn true;\n\t}\n\n\tpublic boolean isFree(float xd, float yd, float zd) \n\t{\n\t\tAABB aabb = hitbox.getTotalBox(x, y, z);\n\t\tAABB bb = new AABB(aabb.x0 + xd, aabb.y0 + yd, aabb.z0 + zd, aabb.x1\n\t\t\t\t+ xd, aabb.y1 + yd, aabb.z1 + zd);\n\t\treturn level.getCubes(this, bb).size() == 0\n\t\t\t\t&& (!level.containsLiquid(bb, 1) && !level\n\t\t\t\t\t\t.containsLiquid(bb, 2));\n\t}\n\n\tpublic void move(float xd, float yd, float zd) \n\t{\n\t\tfloat xdo = xd;\n\t\tfloat ydo = yd;\n\t\tfloat zdo = zd;\n\t\t\n\t\tAABB aabb = this.getBox();\n\t\t\n\t\tAABB tmpBB = aabb.copie();\n\t\ttmpBB.move(xd, 0.0f, 0.0f);\n\t\tList<AABB> cubes = this.level.getCubes(this, tmpBB);\n\t\tif (cubes.size() > 0) {\n\t\t\tthis.xd = xd = 0.0f;\n\t\t}\n\t\taabb.move(xd, 0.0f, 0.0f);\n\n\t\ttmpBB = aabb.copie();\n\t\ttmpBB.move(0.0f, yd, 0.0f);\n\t\tcubes = this.level.getCubes(this, tmpBB);\n\t\tif (cubes.size() > 0) {\n\t\t\tthis.yd = yd = 0.0f;\n\t\t}\n\t\taabb.move(0.0f, yd, 0.0f);\n\n\t\ttmpBB = aabb.copie();\n\t\ttmpBB.move(0.0f, 0.0f, zd);\n\t\tcubes = this.level.getCubes(this, tmpBB);\n\t\tif (cubes.size() > 0) {\n\t\t\tthis.zd = zd = 0.0f;\n\t\t}\n\t\taabb.move(0.0f, 0.0f, zd);\n\t\t\n\t\tcollision = (xd != xdo) || (zd != zdo);\n\t\tonGround = (ydo != yd && ydo < 0.0f);\n\t\tif (xdo != xd)\n\t\t\tthis.xd = 0.0f;\n\t\tif (ydo != yd)\n\t\t\tthis.yd = 0.0f;\n\t\tif (zdo != zd)\n\t\t\tthis.zd = 0.0f;\n\t\t\n\t\tthis.x = (aabb.x0 + aabb.x1) / 2.0f;\n\t\tthis.y = aabb.y0 + heightOffset;//aabb.y0 + heightOffset;\n\t\tthis.z = (aabb.z0 + aabb.z1) / 2.0f;\n\t\t/*\n\t\tx += this.xd;\n\t\ty += this.yd;\n\t\tz += this.zd;*/\n\n\t\tsynchronized (level.entities) \n\t\t{\n\t\t\tList<Entity> buffer = new ArrayList<Entity>(level.entities);\n\t\t\tfor(Entity e : buffer) \n\t\t\t{\n\t\t\t\tif(this == e || !this.blocks(e))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tAABB bb = e.getBox();\n\t\t\t\tList<AABB> boxs = hitbox.getRealPosition(x, y, z);\n\t\t\t\tfor(AABB aa: boxs)\n\t\t\t\t{\t\n\t\t\t\t\tif(bb.intersects(aa)) \n\t\t\t\t\t{\n\t\t\t\t\t\tthis.collide(e, hitbox.getName(aa));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean isInWater() {\n\t\treturn this.level.containsLiquid(this.getBox().grow(0.0f, -0.4f, 0.0f), 1);\n\t}\n\n\tpublic boolean isInLava() {\n\t\treturn this.level.containsLiquid(this.getBox(), 2);\n\t}\n\n\tpublic void moveRel(float xa, float za, float speed) {\n\t\tfloat dist = xa * xa + za * za;\n\t\tif (dist < 0.01f) {\n\t\t\treturn;\n\t\t}\n\t\tfloat m = speed / (float) Math.sqrt(dist);\n\t\txa *= m;\n\t\tza *= m;\n\t\tfloat sin = (float) Math.sin(this.xRot * Math.PI / 180.0);\n\t\tfloat cos = (float) Math.cos(this.xRot * Math.PI / 180.0);\n\t\tthis.xd += xa * cos - za * sin;\n\t\tthis.zd += za * cos + xa * sin;\n\t}\n\n\tpublic void render(float delta) {\n\t}\n\n\tpublic void hit(Entity e, int dmg) {\n\t}\n\t\n\tpublic HitBox getHitBox()\n\t{\n\t\treturn hitbox;\n\t}\n\t\n\tpublic AABB getBox()\n\t{\n\t\treturn hitbox.getTotalBox(x, y-heightOffset, z);\n\t}\n\t\n}\nsrc/com/naronco/cubeshaft/model/HumanModel.java\npublic class HumanModel extends Model {\n\tpublic Cube head;\n\tpublic Cube body;\n\tpublic Cube rightArm;\n\tpublic Cube leftArm;\n\tpublic Cube rightLeg;\n\tpublic Cube leftLeg;\n\n\tpublic HumanModel() {\n\t\tthis.head = new Cube(0, 0);\n\t\tthis.head.setBounds(-4.0F, -8.0F, -4.0F, 8, 8, 8);\n\t\tthis.body = new Cube(16, 16);\n\t\tthis.body.setBounds(-4.0F, 0.0F, -2.0F, 8, 12, 4);\n\t\tthis.rightArm = new Cube(40, 16);\n\t\tthis.rightArm.setBounds(-3.0F, -2.0F, -2.0F, 4, 12, 4);\n\t\tthis.rightArm.setPos(-5.0F, 2.0F, 0.0F);\n\t\tthis.leftArm = new Cube(40, 16);\n\t\tthis.leftArm.setBounds(-1.0F, -2.0F, -2.0F, 4, 12, 4);\n\t\tthis.leftArm.setPos(5.0F, 2.0F, 0.0F);\n\t\tthis.rightLeg = new Cube(0, 16);\n\t\tthis.rightLeg.setBounds(-2.0F, 0.0F, -2.0F, 4, 12, 4);\n\t\tthis.rightLeg.setPos(-2.0F, 12.0F, 0.0F);\n\t\tthis.leftLeg = new Cube(0, 16);\n\t\tthis.leftLeg.setBounds(-2.0F, 0.0F, -2.0F, 4, 12, 4);\n\t\tthis.leftLeg.setPos(2.0F, 12.0F, 0.0F);\n\t}\n}\nsrc/com/naronco/cubeshaft/phys/HitBox.java\npublic class HitBox \n{\n\tprivate List<AABB> parts = new ArrayList<AABB>();\n\tprivate List<String> names = new ArrayList<String>();\n\t\n\tpublic void addALL(List<AABB> par1, List<String> par2)\n\t{\n\t\tif(par1.size() != par2.size())\n\t\t{\n\t\t\t\tthrow new InvalidParameterException(\"Lists havent same lenght\");\n\t\t}\n\t\tparts.addAll(par1);\n\t\tnames.addAll(par2);\n\t}\n\t\n\t/**\n\t * returns all Boxes at the give Location\n\t */\n\tpublic List<AABB> getRealPosition(float x, float y, float z)\n\t{\t\n\t\tsynchronized (parts) \n\t\t{\n\t\t\tList<AABB> real = new ArrayList<AABB>();\n\t\t\t\n\t\t\tfor(AABB aabb : parts)\n\t\t\t{\n\t\t\t\tAABB bb = new AABB(aabb.x0 + x, aabb.y0 + y, aabb.z0 + z, aabb.x1+ x, aabb.y1 + y, aabb.z1 + z);\n\t\t\t\treal.add(bb);\n\t\t\t}\n\t\t\treturn real;\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Add a Box with Name\n\t */\n\tpublic void addNamedBox(AABB aabb, String name)\n\t{\t\n\t\tparts.add(aabb);\n\t\tnames.add(name);\n\t}\n\t\n\t/**\n\t * Get the Name from a Box\n\t */\n\tpublic String getName(AABB aabb)\n\t{\n\t\tsynchronized (parts) \n\t\t{\n\t\t\tfor(int i=0;i<parts.size();i++)\n\t\t\t{\n\t\t\t\tif(parts.get(i)==aabb)\n\t\t\t\t{\n\t\t\t\t\treturn names.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Get the a Box by its NAme\n\t */\n\tpublic AABB getBox(String name)\n\t{\n\t\tsynchronized (names) \n\t\t{\n\t\t\tfor(int i=0;i<names.size();i++)\n\t\t\t{\n\t\t\t\tif(names.get(i).equals(name))\n\t\t\t\t{\n\t\t\t\t\treturn parts.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Gives the total Box at tthe location (from minimum to maximum)\n\t */\n\tpublic AABB getTotalBox(float x, float y, float z)\n\t{\n\t\tfloat x0=0, y0=0, z0=0, x1=0, y1=0, z1=0;\n\t\tsynchronized (parts) \n\t\t{\n\t\t\tfor(AABB bb : parts)\n\t\t\t{\n\t\t\t\tx0 = Math.min(bb.x0, x0);\n\t\t\t\ty0 = Math.min(bb.y0, y0);\n\t\t\t\tz0 = Math.min(bb.z0, z0);\n\t\t\t\t\n\t\t\t\tx1 = Math.max(bb.x1, x1);\n\t\t\t\ty1 = Math.max(bb.y1, y1);\n\t\t\t\tz1 = Math.max(bb.z1, z1);\n\t\t\t}\n\t\t}\n\t\treturn new AABB(x0 + x, y0 + y, z0 + z, x1 + x, y1 + y, z1 + z);\n\t}\n\t\n\t\n\tpublic static HitBox getHumanModel(float height, float width)\n\t{\n\t\tHitBox box = new HitBox();\n\t\tfloat w = width / 2.0F;\n\t\tbox.addNamedBox(new AABB(-w/2.0F, height/3.0F, -w/2.0F, w/2.0F, height, w/2.0F), \"head\");\n\t\tbox.addNamedBox(new AABB(-w, 0, -w, w, height *2.0F /3.0F, w), \"body\");\n\t\treturn box;\n\t}\n\t\n}\nsrc/com/naronco/cubeshaft/ItemEntity.java\npublic class ItemEntity extends Entity {\n\tprivate int time;\n\tprivate int pickup;\n\tprivate Tile tile;\n\tprivate int value;\n\n\tpublic ItemEntity(Level level, Tile tile, float x, float y, float z) {\n\t\tthis(level, tile, x, y, z, 1);\n\t}\n\n\tpublic ItemEntity(Level level, Tile tile, float x, float y, float z, int val) {\n\t\tsuper(level);\n\t\tthis.tile = tile;\n\t\tsetSize(0.2f, 0.2f);\n\t\tsetPos(x, y, z);\n\t\tvalue = val;\n\t}\n\n\tpublic void tick() {\n\t\ttime++;\n\t\txRot = time * 2 / 3.0f;\n\t\t\n\t\tif(pickup>0)\n\t\t\tpickup--;\n\n\t\tthis.xo = x;\n\t\tthis.yo = y;\n\t\tthis.zo = z;\n\t\tthis.xRotO = xRot;\n\t\tif (this.y < -100.0f) {\n\t\t\tthis.removed = true;\n\t\t}\n\n\t\tmove(xd, yd, zd);\n\t\tthis.yd = (float) (this.yd - 0.016);\n\t\tthis.xd *= 0.91f;\n\t\tthis.yd *= 0.98f;\n\t\tthis.zd *= 0.91f;\n\t\tif (onGround) {\n\t\t\tthis.xd *= 0.7f;\n\t\t\tthis.zd *= 0.7f;\n\t\t}\n\t\tif (!removed) {\n\t\t\tList<Entity> e = level.getEntitysExcludingEntity(\n\t\t\t\t\thitbox.getTotalBox(x, y, z).grow(1, 1, 1), this, new IEntitySelector() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean isValidEntity(Entity e) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(e instanceof Player)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tx = e.x;\n\t\t\t\t\t\t\t\ty = e.y-1;\n\t\t\t\t\t\t\t\tz = e.z;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn e instanceof ItemEntity;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\tfor (Entity en : e) {\n\t\t\t\tif (!en.removed\n\t\t\t\t\t\t&& ((ItemEntity) en).getTile() == this.getTile()) {\n\t\t\t\t\tthis.value += ((ItemEntity) en).value;\n\t\t\t\t\ten.removed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic void setTimebeforPickup(int t)\n\t{\n\t\tpickup = t;\n\t}\n\tpublic int getTimebeforPickup()\n\t{\n\t\treturn pickup;\n\t}\n\n\tpublic void render(float delta) {\n\t\tfloat step = (float) Math.sin(time / 4.0f / 3.0f) * 0.1f;\n\t\tglColor4f(1, 1, 1, 1);\n\t\tglPushMatrix();\n\n\t\tfloat xx = xo + (x - xo) * delta;\n\t\tfloat yy = yo + (y - yo) * delta;\n\t\tfloat zz = zo + (z - zo) * delta;\n\t\tfloat xr = xRotO + (xRot - xRotO) * delta;\n\n\t\tglTranslatef(xx + 0.25f, yy + step, zz + 0.25f);\n\t\tglRotatef(xr, 0, 1, 0);\n\t\tglTranslatef(-0.25f, 0, -0.25f);\n\t\tglScalef(0.5f, 0.5f, 0.5f);\n\t\tTesselator t = Tesselator.instance;\n\t\tt.begin();\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tTileRenderer.instance.renderSide(tile, 0, 0, 0, i);\n\t\t}\n\t\tt.end();\n\t\tglPopMatrix();\n\t}\n\n\tpublic Tile getTile() {\n\t\treturn tile;\n\t}\n}\nsrc/com/naronco/cubeshaft/INamedEntity.java\npublic interface INamedEntity \n{\n\tpublic boolean hasName();\n\t\n\tpublic String getName();\n\t\n\tpublic void setName(String s);\n}\nsrc/com/naronco/cubeshaft/level/Level.java\npublic class Level {\n\tpublic int width, depth, height;\n\tpublic byte[] tiles;\n\tpublic int[] heightMap;\n\tpublic String name;\n\n\tpublic List<LevelRenderer> levelRenderers = new ArrayList<LevelRenderer>();\n\n\tpublic Random random = new Random();\n\tpublic List<Entity> entities = new ArrayList<Entity>();\n\tpublic List<Player> players = new ArrayList<Player>();\n\n\tpublic int skyColor = -1;\n\tpublic Sun sun = new Sun(8.0f);\n\tpublic SkyColor sky = new SkyColor();\n\tpublic int time;\n\n\tpublic void init(String name, int width, int height, int depth, byte[] tiles) {\n\t\tthis.name = name;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.depth = depth;\n\t\tthis.tiles = tiles;\n\t\theightMap = new int[width * depth];\n\t\tcalcLightDepths(0, 0, width, depth);\n\t\tfor (int i = 0; i < levelRenderers.size(); i++) {\n\t\t\tlevelRenderers.get(i).init();\n\t\t}\n\t}\n\n\tpublic void calcLightDepths(int x, int z, int w, int d) {\n\t\tfor (int xx = x; xx < x + w; xx++)\n\t\t\tfor (int zz = z; zz < z + d; zz++) {\n\t\t\t\tint blocker = 0;\n\t\t\t\tfor (int yy = this.height - 1; yy > 0; yy--) {\n\t\t\t\t\tblocker = yy;\n\t\t\t\t\tTile tile = Tile.tiles[getTile(xx, yy, zz)];\n\t\t\t\t\tif (tile == null ? false : tile.isNormalRender()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\theightMap[xx + zz * width] = blocker + 1;\n\t\t\t}\n\t}\n\n\tpublic List<AABB> getCubes(Entity source, AABB aabb) {\n\t\tList<AABB> result = new ArrayList<AABB>();\n\n\t\tint x0 = (int) Math.floor(aabb.x0);\n\t\tint x1 = (int) Math.floor(aabb.x1 + 1);\n\t\tint y0 = (int) Math.floor(aabb.y0);\n\t\tint y1 = (int) Math.floor(aabb.y1 + 1);\n\t\tint z0 = (int) Math.floor(aabb.z0);\n\t\tint z1 = (int) Math.floor(aabb.z1 + 1);\n\n\t\tfor (int x = x0; x < x1; x++)\n\t\t\tfor (int y = y0; y < y1; y++)\n\t\t\t\tfor (int z = z0; z < z1; z++)\n\t\t\t\t\tif (x >= 0 && y >= 0 && z >= 0 && x < this.width\n\t\t\t\t\t\t\t&& z < this.depth && y < this.height) {\n\t\t\t\t\t\tTile tile = Tile.tiles[this.getTile(x, y, z)];\n\t\t\t\t\t\tif (tile != null) {\n\t\t\t\t\t\t\tAABB bb = tile.getAABB(x, y, z);\n\t\t\t\t\t\t\tif (bb != null && bb.intersects(aabb)) {\n\t\t\t\t\t\t\t\tresult.add(bb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic List<Entity> getEntitysExcludingEntity(AABB par1, Entity par2) \n\t{\n\t\treturn getEntitysExcludingEntity(par1, par2, new IEntitySelector() \n\t\t{\n\t\t\t@Override\n\t\t\tpublic boolean isValidEntity(Entity e) \n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic List<Entity> getEntitysExcludingEntity(AABB par1, Entity par2, IEntitySelector par3) {\n\t\tList<Entity> result = new ArrayList<>();\n\t\t\n\t\tsynchronized (entities) \n\t\t{\n\t\t\tfor (Entity e : entities) {\n\t\t\t\tAABB tmpBB = e.getBox().copie();\n\t\t\t\tif (par1.intersects(tmpBB) && par3.isValidEntity(e))\n\t\t\t\t\tresult.add(e);\n\t\t\t}\n\t\t}\n\t\tsynchronized (players) \n\t\t{\n\t\t\tfor (Entity e : players) {\n\t\t\t\tAABB tmpBB = e.getBox().copie();\n\t\t\t\tif (par1.intersects(tmpBB) && par3.isValidEntity(e))\n\t\t\t\t\tresult.add(e);\n\t\t\t}\n\t\t}\n\t\tresult.remove(par2);\n\t\treturn result;\n\t}\n\n\tpublic boolean setTile(int x, int y, int z, int id) {\n\t\tif (x < 0 || y < 0 || z < 0 || x >= width || y >= height || z >= depth)\n\t\t\treturn false;\n\t\tif (id == tiles[(y * width + z) * depth + x])\n\t\t\treturn false;\n\t\ttiles[(y * width + z) * depth + x] = (byte) id;\n\t\tneighborChange(x - 1, y, z, id);\n\t\tneighborChange(x + 1, y, z, id);\n\t\tneighborChange(x, y - 1, z, id);\n\t\tneighborChange(x, y + 1, z, id);\n\t\tneighborChange(x, y, z - 1, id);\n\t\tneighborChange(x, y, z + 1, id);\n\n\t\ttileAdd(x, y, z, id);\n\n\t\tcalcLightDepths(x, z, 1, 1);\n\t\tfor (int i = 0; i < this.levelRenderers.size(); i++) {\n\t\t\tlevelRenderers.get(i).queueChunks(x - 1, y - 1, z - 1, x + 1,\n\t\t\t\t\ty + 1, z + 1);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic boolean setTileNoUpdate(int x, int y, int z, int id) {\n\t\tif (x < 0 || y < 0 || z < 0 || x >= width || y >= height || z >= depth)\n\t\t\treturn false;\n\t\tif (id == tiles[(y * width + z) * depth + x])\n\t\t\treturn false;\n\t\ttiles[(y * width + z) * depth + x] = (byte) id;\n\t\treturn true;\n\t}\n\n\tprivate void neighborChange(int x, int y, int z, int id) {\n\t\tif (x < 0 || y < 0 || z < 0 || x >= width || y >= height || z >= depth)\n\t\t\treturn;\n\t\tTile tile = Tile.tiles[tiles[(y * width + z) * depth + x]];\n\t\tif (tile != null) {\n\t\t\ttile.neighborChange(this, x, y, z, id);\n\t\t}\n\t}\n\n\tprivate void tileAdd(int x, int y, int z, int id) {\n\t\tif (x < 0 || y < 0 || z < 0 || x >= width || y >= height || z >= depth)\n\t\t\treturn;\n\t\tTile tile = Tile.tiles[id];\n\t\tif (tile != null) {\n\t\t\ttile.tileAdd(this, x, y, z);\n\t\t}\n\t}\n\n\tpublic int getTile(int x, int y, int z) {\n\t\tif (x < 0 || y < 0 || z < 0 || x >= width || y >= height || z >= depth)\n\t\t\treturn 0;\n\t\tif(tiles == null)\n\t\t\treturn 0;\n\t\treturn tiles[(y * width + z) * depth + x] & 0xff;\n\t}\n\t\n\tpublic int getHeigh(int x, int z) \n\t{\n\t\tint y = 0;\n\t\twhile(getTile(x, y, z)!=0)\n\t\t{\t\t\n\t\t\ty++;\n\t\t}\n\t\treturn y;\t\t\n\t}\n\t\n\tpublic boolean isDaytime()\n\t{\n\t\treturn time>0 && time <1800;\n\t}\n\t\n\tpublic void addEntity(Entity e) {\n\t\tsynchronized (entities) {\n\t\t\tentities.add(e);\n\t\t}\n\t}\n\n\tpublic boolean maybeGrowTree(int x, int y, int z) {\n\t\tint lowerTile = getTile(x, y - 1, z);\n\t\tif (lowerTile != Tile.grass.id && lowerTile != Tile.dirt.id)\n\t\t\treturn false;\n\t\tfor (int yc = y + 1; yc <= y + 10; yc++)\n\t\t\tif (getTile(x, yc, z) != 0)\n\t\t\t\treturn false;\n\t\tfor (int yc = y; yc <= y + 10; yc++)\n\t\t\tif (getTile(x, yc, z) == Tile.water.id\n\t\t\t\t\t|| getTile(x, yc, z) == Tile.flowingWater.id)\n\t\t\t\treturn false;\n\t\tfor (int xc = x - 2; xc <= x + 2; xc++)\n\t\t\tfor (int yc = y + 3; yc <= y + 10; yc++)\n\t\t\t\tfor (int zc = z - 2; zc <= z + 2; zc++) {\n\t\t\t\t\tint tile = getTile(xc, yc, zc);\n\t\t\t\t\tif (tile != 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\treturn true;\n\t}\n\n\tpublic void growTree(int x, int y, int z) {\n\t\tTreeLevelStruct tree = new TreeLevelStruct();\n\t\ttree.generate(this, x, y, z, random);\n\t}\n\n\tpublic boolean containsLiquid(AABB aabb, int liquidType) {\n\t\tint x0 = (int) Math.floor(aabb.x0);\n\t\tint x1 = (int) Math.floor(aabb.x1 + 1);\n\t\tint y0 = (int) Math.floor(aabb.y0);\n\t\tint y1 = (int) Math.floor(aabb.y1 + 1);\n\t\tint z0 = (int) Math.floor(aabb.z0);\n\t\tint z1 = (int) Math.floor(aabb.z1 + 1);\n\n\t\tfor (int x = x0; x < x1; x++)\n\t\t\tfor (int y = y0; y < y1; y++)\n\t\t\t\tfor (int z = z0; z < z1; z++)\n\t\t\t\t\tif (x >= 0 && y >= 0 && z >= 0 && x < this.width\n\t\t\t\t\t\t\t&& z < this.depth && y < this.height) {\n\t\t\t\t\t\tTile tile = Tile.tiles[this.getTile(x, y, z)];\n\t\t\t\t\t\tif (tile != null && tile.getLiquidType() == liquidType)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic void tick() \n\t{\n\t\ttime = (time + 2) % 3600;\n\t\t// time=900;\n\t\tskyColor = sky.getSkyColor(time);\n\t\t\n\t\tList<Entity> remove = new ArrayList<Entity>();\n\t\tList<Entity> ents = new ArrayList<Entity>(entities);\t\n\t\tfor (Entity e : ents) {\n\t\t\te.tick();\n\t\t\tif (e.y < -50) e.removed = true;\n\t\t\tif (e.removed)\n\t\t\t\tremove.add(e);\n\t\t}\n\t\tentities.removeAll(remove);\n\t\t\n\t\tif(!isDaytime() && random.nextInt(20)==0);\n\t\t{\n\t\t\tPlayer p = Cubeshaft.game.player;\n\t\t\tList l = getEntitysExcludingEntity(p.getBox().copie().grow(64, 64, 64), p, new IEntitySelector() \n\t\t\t{\t\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isValidEntity(Entity e) \n\t\t\t\t{\n\t\t\t\t\treturn e instanceof Mob;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(l.size() < 3)\n\t\t\t{\n\t\t\t\tspawnMobs();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void spawnMobs()\n\t{\n\t\tPlayer p = Cubeshaft.game.player;\n\t\tfloat x = (random.nextInt(32)-random.nextInt(32));\n\t\tfloat z = (random.nextInt(32)-random.nextInt(32));\n\t\t\n\t\tif(Math.sqrt(x*x+z*z)>16)\n\t\t{\t\n\t\t\tint y = getHeigh((int)x, (int)z);\n\t\t\t\n\t\t\tMob m;\n\t\t\tif(getTile((int)x, y-2, (int)z)==Tile.water.id || getTile((int)x, y-2, (int)z)==Tile.flowingWater.id)\n\t\t\t\tm = new MobSkeletonWater(this);\n\t\t\telse\n\t\t\t\tm = new MobSkeleton(this);\n\t\t\t\n\t\t\tm.setPos(p.x + x, y, p.z + z);\n\t\t\n\t\taddEntity(m);\n\t\t}\n\t}\n\tprivate void DespawnMobs()\n\t{\n\t\tfor(Entity e : entities)\n\t\t{\n\t\t\tif(e instanceof Mob)\n\t\t\t{\n\t\t\t\tif(new Waypoint( Cubeshaft.game.player).getDistansTo(new Waypoint(e))>80)\n\t\t\t\t{\n\t\t\t\t\te.removed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n", "answers": ["\t\t\tTickHandler.EVENT_BUS.postEvent(e);"], "length": 3452, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "42112168fb1213c3b53dd4bf6da5239697e148f9aa0a79bc"}
{"input": "package org.codeforamerica.open311.facade;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport org.codeforamerica.open311.facade.data.Endpoint;\nimport org.codeforamerica.open311.facade.data.ServiceDiscoveryInfo;\nimport org.codeforamerica.open311.facade.exceptions.APIWrapperException;\nimport org.codeforamerica.open311.facade.exceptions.APIWrapperException.Error;\nimport org.codeforamerica.open311.facade.exceptions.DataParsingException;\nimport org.codeforamerica.open311.internals.caching.Cache;\nimport org.codeforamerica.open311.internals.logging.LogManager;\nimport org.codeforamerica.open311.internals.network.HTTPNetworkManager;\nimport org.codeforamerica.open311.internals.network.NetworkManager;\nimport org.codeforamerica.open311.internals.parsing.DataParser;\nimport org.codeforamerica.open311.internals.parsing.DataParserFactory;\nimport org.codeforamerica.open311.internals.platform.PlatformManager;\n\n\n\n/**\n * Builds {@link APIWrapper} instances from different aspects specified by the\n * user. To set the optional parameters, use the setter methods and, then, call\n * {@link #build()}.\n * \n * @author Santiago Munin <santimunin@gmail.com>\n * \n */\npublic class APIWrapperFactory {\n\t;\n\t/**\n\t * Used for the first way of building the {@link APIWrapper} (\n\t * {@link #APIWrapperFactory(String, String, Format)}).\n\t * \n\t */\n\tprivate String endpointUrl = null;\n\t/**\n\t * Used for the first way of building the {@link APIWrapper} (\n\t * {@link #APIWrapperFactory(String, String, Format)}).\n\t * \n\t */\n\tprivate String jurisdictionId = null;\n\t/**\n\t * Used for the second way of building the {@link APIWrapper} (\n\t * {@link APIWrapperFactory#APIWrapperFactory(City, EndpointType)}).\n\t * \n\t */\n\tprivate City city = null;\n\t/**\n\t * Used for the second way of building the {@link APIWrapper} (\n\t * {@link APIWrapperFactory#APIWrapperFactory(City, EndpointType)}).\n\t */\n\tprivate EndpointType endpointType = null;\n\t/**\n\t * Used for the second way of building the {@link APIWrapper} (\n\t * {@link APIWrapperFactory#APIWrapperFactory(City, EndpointType)}).\n\t */\n\tprivate Format format = null;\n\tprivate String apiKey = \"\";", "context": "src/main/java/org/codeforamerica/open311/facade/exceptions/APIWrapperException.java\npublic static enum Error {\n\tDATA_PARSING(\"Problem while parsing text data.\"), NETWORK_MANAGER(\n\t\t\t\"Network problem.\"), URL_BUILDER(\n\t\t\t\"Problem while building a valid URL.\"), GEO_REPORT_V2(\n\t\t\t\"GeoReport v2 problem.\"), NOT_SUITABLE_ENDPOINT_FOUND(\n\t\t\t\"Problem finding a suitable endpoint.\"), NOT_CREATED_BY_A_WRAPPER(\n\t\t\t\"The given object wasn't created by any wrapper\");\n\tprivate String description;\n\n\tprivate Error(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic String toString() {\n\t\treturn this.description;\n\t}\n}\nsrc/main/java/org/codeforamerica/open311/facade/data/ServiceDiscoveryInfo.java\npublic class ServiceDiscoveryInfo implements Serializable {\n\n\tprivate static final long serialVersionUID = 5804902138488110319L;\n\tprivate final static String GEO_REPORT_V2_SPECIFICATION_URL = \"http://wiki.open311.org/GeoReport_v2\";\n\tprivate Date changeset;\n\tprivate String contact;\n\tprivate String keyService;\n\tList<Endpoint> endpoints;\n\n\tpublic ServiceDiscoveryInfo(Date changeset, String contact,\n\t\t\tString keyService, List<Endpoint> endpoints) {\n\t\tsuper();\n\t\tthis.changeset = changeset;\n\t\tthis.contact = contact;\n\t\tthis.keyService = keyService;\n\t\tthis.endpoints = endpoints;\n\t}\n\n\tpublic Date getChangeset() {\n\t\treturn changeset;\n\t}\n\n\tpublic String getContact() {\n\t\treturn contact;\n\t}\n\n\tpublic String getKeyService() {\n\t\treturn keyService;\n\t}\n\n\tpublic List<Endpoint> getEndpoints() {\n\t\treturn endpoints;\n\t}\n\n\t/**\n\t * Searches through the list of endpoints and tries to find a valid endpoint\n\t * of the given type. Tries to get the GeoReport latest version (currently\n\t * v2).\n\t * \n\t * @param endpointType\n\t *            Type of the desired endpoint.\n\t * @return <code>null</code> if a suitable endpoint couldn't be found.\n\t */\n\tpublic Endpoint getMoreSuitableEndpoint(EndpointType endpointType) {\n\t\tList<Endpoint> typeFilteredEndpoints = new LinkedList<Endpoint>();\n\t\tfor (Endpoint endpoint : endpoints) {\n\t\t\tif (endpoint.getType() == endpointType) {\n\t\t\t\ttypeFilteredEndpoints.add(endpoint);\n\t\t\t}\n\t\t}\n\t\tEndpoint candidate = null;\n\t\tfor (Endpoint endpoint : typeFilteredEndpoints) {\n\t\t\t// Some endpoints don't follows the specification so it does this\n\t\t\t// \"double check\", which has been proved working.\n\t\t\tif (endpoint.getSpecificationUrl().equals(GEO_REPORT_V2_SPECIFICATION_URL)) {\n\t\t\t\tif (endpoint.getUrl().contains(\"v2\")) {\n\t\t\t\t\treturn endpoint;\n\t\t\t\t}\n\t\t\t\tcandidate = endpoint;\n\t\t\t}\n\t\t}\n\t\treturn candidate;\n\t}\n}\nsrc/main/java/org/codeforamerica/open311/facade/data/Endpoint.java\npublic class Endpoint implements Serializable {\n\tprivate static final long serialVersionUID = -5512681512770606630L;\n\tprivate String specificationUrl;\n\tprivate String url;\n\tprivate Date changeset;\n\tprivate EndpointType type;\n\tprivate List<Format> formats;\n\n\tpublic Endpoint(String specificationUrl, String url, Date changeset,\n\t\t\tEndpointType type, List<Format> formats) {\n\t\tsuper();\n\t\tthis.specificationUrl = specificationUrl;\n\t\tthis.url = url;\n\t\tthis.changeset = changeset;\n\t\tthis.type = type;\n\t\tthis.formats = formats;\n\t}\n\n\tpublic String getSpecificationUrl() {\n\t\treturn specificationUrl;\n\t}\n\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\n\tpublic Date getChangeset() {\n\t\treturn changeset;\n\t}\n\n\tpublic EndpointType getType() {\n\t\treturn type;\n\t}\n\n\t/**\n\t * Returns the more suitable format. Tries JSON before XML.\n\t * \n\t * @return A format allowed by the endpoint.\n\t */\n\tpublic Format getBestFormat() {\n\t\tif (formats.contains(Format.JSON)) {\n\t\t\treturn Format.JSON;\n\t\t}\n\t\tif (formats.contains(Format.XML)) {\n\t\t\treturn Format.XML;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns whether it allows the given format or not.\n\t * \n\t * @param format\n\t *            Desired format.\n\t * @return <code>true</code> if it allows the given format, else\n\t *         <code>false</code>.\n\t */\n\tpublic boolean isCompatibleWithFormat(Format format) {\n\t\treturn formats.contains(format);\n\t}\n}\nsrc/main/java/org/codeforamerica/open311/facade/exceptions/APIWrapperException.java\npublic class APIWrapperException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate Error error;\n\tprivate GeoReportV2Error geoReportError;\n\n\tpublic APIWrapperException(String message, Error error,\n\t\t\tGeoReportV2Error geoReportError) {\n\t\tsuper(message);\n\t\tthis.error = error;\n\t\tthis.geoReportError = geoReportError;\n\t}\n\n\tpublic static long getSerialversionuid() {\n\t\treturn serialVersionUID;\n\t}\n\n\tpublic Error getError() {\n\t\treturn error;\n\t}\n\n\tpublic GeoReportV2Error getGeoReportError() {\n\t\treturn geoReportError;\n\t}\n\n\tpublic String toString() {\n\t\tString result = this.getMessage() + \" (\" + this.error;\n\t\tif (geoReportError != null) {\n\t\t\tresult += \" -- \" + geoReportError.toString();\n\t\t}\n\t\tresult += \")\";\n\t\treturn result;\n\t}\n\n\t/**\n\t * Different types of errors.\n\t */\n\tpublic static enum Error {\n\t\tDATA_PARSING(\"Problem while parsing text data.\"), NETWORK_MANAGER(\n\t\t\t\t\"Network problem.\"), URL_BUILDER(\n\t\t\t\t\"Problem while building a valid URL.\"), GEO_REPORT_V2(\n\t\t\t\t\"GeoReport v2 problem.\"), NOT_SUITABLE_ENDPOINT_FOUND(\n\t\t\t\t\"Problem finding a suitable endpoint.\"), NOT_CREATED_BY_A_WRAPPER(\n\t\t\t\t\"The given object wasn't created by any wrapper\");\n\t\tprivate String description;\n\n\t\tprivate Error(String description) {\n\t\t\tthis.description = description;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn this.description;\n\t\t}\n\t}\n\n}\nsrc/main/java/org/codeforamerica/open311/internals/network/HTTPNetworkManager.java\npublic class HTTPNetworkManager implements NetworkManager {\n\tprivate HttpClient httpClient;\n\tprivate Format format;\n\tprivate static final int TIMEOUT = 5000;\n\tprivate static final String ACCEPT_HEADER = \"Accept\";\n\tprivate static final String CONTENT_TYPE_HEADER = \"Content-Type\";\n\n\tpublic HTTPNetworkManager(Format format) {\n\t\tthis.format = format;\n\t\tthis.httpClient = getNewHttpClient();\n\t}\n\n\t@Override\n\tpublic String doGet(URL url) throws IOException {\n\t\ttry {\n\t\t\tHttpGet httpGet = new HttpGet(url.toURI());\n\t\t\thttpGet.setHeader(ACCEPT_HEADER, format.getHTTPContentType());\n\t\t\thttpGet.setHeader(CONTENT_TYPE_HEADER, format.getHTTPContentType());\n\t\t\tHttpResponse response = httpClient.execute(httpGet);\n\t\t\treturn EntityUtils.toString(response.getEntity(), CHARSET);\n\t\t} catch (Exception e) {\n\t\t\tthrow new IOException(e.getMessage());\n\t\t}\n\t}\n\n\t@Override\n\tpublic String doPost(URL url, Map<String, String> parameters)\n\t\t\tthrows IOException {\n\t\ttry {\n\t\t\tHttpPost httpPost = new HttpPost(url.toURI());\n\t\t\thttpPost.setHeader(ACCEPT_HEADER, format.getHTTPContentType());\n\t\t\thttpPost.setHeader(\"Content-Type\", POST_CONTENT_TYPE);\n\t\t\thttpPost.setEntity(generateHttpEntityFromParameters(parameters));\n\t\t\tHttpResponse response = httpClient.execute(httpPost);\n\t\t\treturn EntityUtils.toString(response.getEntity(), CHARSET);\n\t\t} catch (Exception e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setFormat(Format format) {\n\t\tthis.format = format;\n\t}\n\n\t/**\n\t * Builds an {@link HttpEntity} with all the given parameters.\n\t * \n\t * @param parameters\n\t *            A list of parameters of a POST request.\n\t * @return An {@link UrlEncodedFormEntity} with the given parameters.\n\t * @throws UnsupportedEncodingException\n\t *             if the default encoding isn't supported.\n\t */\n\tprivate HttpEntity generateHttpEntityFromParameters(\n\t\t\tMap<String, String> parameters) throws UnsupportedEncodingException {\n\t\tList<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>();\n\t\tif (parameters != null) {\n\t\t\tfor (Entry<String, String> parameterEntry : parameters.entrySet()) {\n\t\t\t\tnameValuePairs.add(new BasicNameValuePair(parameterEntry\n\t\t\t\t\t\t.getKey(), parameterEntry.getValue()));\n\t\t\t}\n\t\t}\n\t\treturn new UrlEncodedFormEntity(nameValuePairs);\n\t}\n\n\t/**\n\t * Builds a {@link HttpClient} which allows non trusted SSL certificates.\n\t * \n\t * @return {@link HttpClient} which allows non trusted SSL certificates.\n\t */\n\tprivate HttpClient getNewHttpClient() {\n\t\ttry {\n\t\t\tKeyStore trustStore = KeyStore.getInstance(KeyStore\n\t\t\t\t\t.getDefaultType());\n\t\t\ttrustStore.load(null, null);\n\n\t\t\tSSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n\t\t\tsf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n\t\t\tHttpParams params = new BasicHttpParams();\n\t\t\tHttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n\t\t\tHttpProtocolParams.setContentCharset(params, CHARSET);\n\t\t\tHttpConnectionParams.setConnectionTimeout(params, TIMEOUT);\n\n\t\t\tSchemeRegistry registry = new SchemeRegistry();\n\t\t\tregistry.register(new Scheme(\"http\", PlainSocketFactory\n\t\t\t\t\t.getSocketFactory(), 80));\n\t\t\tregistry.register(new Scheme(\"https\", sf, 443));\n\n\t\t\tClientConnectionManager ccm = new ThreadSafeClientConnManager(\n\t\t\t\t\tparams, registry);\n\t\t\treturn new DefaultHttpClient(ccm, params);\n\t\t} catch (Exception e) {\n\t\t\treturn new DefaultHttpClient();\n\t\t}\n\t}\n\n\t/**\n\t * A SSLSocketFactory which allows non trusted SSL certificates.\n\t * \n\t * @author Santiago Munín <santimunin@gmail.com>\n\t * \n\t */\n\tprivate class MySSLSocketFactory extends SSLSocketFactory {\n\t\tSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n\t\tpublic MySSLSocketFactory(KeyStore truststore)\n\t\t\t\tthrows NoSuchAlgorithmException, KeyManagementException,\n\t\t\t\tKeyStoreException, UnrecoverableKeyException {\n\t\t\tsuper(truststore);\n\n\t\t\tTrustManager tm = new X509TrustManager() {\n\t\t\t\tpublic void checkClientTrusted(X509Certificate[] chain,\n\t\t\t\t\t\tString authType) {\n\t\t\t\t}\n\n\t\t\t\tpublic void checkServerTrusted(X509Certificate[] chain,\n\t\t\t\t\t\tString authType) throws CertificateException {\n\t\t\t\t}\n\n\t\t\t\tpublic X509Certificate[] getAcceptedIssuers() {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tsslContext.init(null, new TrustManager[] { tm }, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic Socket createSocket(Socket socket, String host, int port,\n\t\t\t\tboolean autoClose) throws IOException, UnknownHostException {\n\t\t\treturn sslContext.getSocketFactory().createSocket(socket, host,\n\t\t\t\t\tport, autoClose);\n\t\t}\n\n\t\t@Override\n\t\tpublic Socket createSocket() throws IOException {\n\t\t\treturn sslContext.getSocketFactory().createSocket();\n\t\t}\n\t}\n}\nsrc/main/java/org/codeforamerica/open311/internals/platform/PlatformManager.java\npublic class PlatformManager {\n\t/**\n\t * Unique instance.\n\t */\n\tprivate static PlatformManager instance = new PlatformManager();\n\tprivate boolean androidPlatform;\n\n\t/**\n\t * Prevents other objects to instantiate instances of this class.\n\t */\n\tprivate PlatformManager() {\n\t\tandroidPlatform = System.getProperty(\"java.vm.name\").equalsIgnoreCase(\n\t\t\t\t\"Dalvik\");\n\t}\n\n\t/**\n\t * Returns the unique instance of the class.\n\t * \n\t * @return The unique instance of the class.\n\t */\n\tpublic static PlatformManager getInstance() {\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Builds a cache instance taking care of the execution environment.\n\t * \n\t * @return {@link NoCache} under Android, {@link RegularJavaCache}\n\t *         otherwise. {@link AndroidCache} has to be built explicitly.\n\t */\n\tpublic Cache buildCache() {\n\t\treturn androidPlatform ? new NoCache() : RegularJavaCache.getInstance();\n\t}\n\n\t/**\n\t * Builds a logger instance taking care of the execution environment.\n\t * \n\t * @return {@link AndroidLogger} under Android. {@link RegularJavaLogger}\n\t *         otherwise.\n\t */\n\tpublic Logger buildLogger() {\n\t\treturn androidPlatform ? new AndroidLogger() : new RegularJavaLogger();\n\t}\n\n}\nsrc/main/java/org/codeforamerica/open311/internals/logging/LogManager.java\npublic class LogManager {\n\t/**\n\t * Unique instance of the logger.\n\t */\n\tprivate Logger logger = PlatformManager.getInstance().buildLogger();\n\t/**\n\t * Unique instance of the class.\n\t */\n\tprivate static LogManager instance = new LogManager();\n\t/**\n\t * Contains a wrapper if it has to be logged.\n\t */\n\tprivate static Set<Object> loggedObjects = new HashSet<Object>();\n\n\t/**\n\t * Prevents other classes to instantiate this class.\n\t */\n\tprivate LogManager() {\n\t}\n\n\t/**\n\t * Returns the unique instance of the class.\n\t * \n\t * @return unique instance of the class.\n\t */\n\tpublic static LogManager getInstance() {\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Activates the logging for a concrete wrapper.\n\t * \n\t * @param objectToBeLogged\n\t *            Object to be logged.\n\t */\n\tpublic void activate(Object objectToBeLogged) {\n\t\tloggedObjects.add(objectToBeLogged);\n\t}\n\n\t/**\n\t * Disables the logging for a concrete wrapper.\n\t * \n\t * @param loggedObject\n\t *            Object which logging will be disabled.\n\t */\n\tpublic void disable(Object loggedObject) {\n\t\tloggedObjects.remove(loggedObject);\n\t}\n\n\t/**\n\t * Logs a non-critical event.\n\t * \n\t * @param messageCreator\n\t *            origin of the message.\n\t * @param message\n\t *            Event message.\n\t */\n\tpublic void logInfo(Object messageCreator, String message) {\n\t\tif (loggedObjects.contains(messageCreator)) {\n\t\t\tlogger.logInfo(buildMessage(messageCreator, message));\n\t\t}\n\t}\n\n\t/**\n\t * Logs any problem.\n\t * \n\t * @param messageCreator\n\t *            origin of the message.\n\t * @param message\n\t *            Event message.\n\t */\n\tpublic void logError(Object messageCreator, String message) {\n\t\tif (loggedObjects.contains(messageCreator)) {\n\t\t\tlogger.logError(buildMessage(messageCreator, message));\n\t\t}\n\t}\n\n\t/**\n\t * Builds a log message containing the wrapper information.\n\t * \n\t * @param messageCreator\n\t *            origin of the message.\n\t * \n\t * @param message\n\t *            Event message.\n\t * @return\n\t */\n\tprivate static String buildMessage(Object messageCreator, String message) {\n\t\treturn \"(\" + messageCreator + \") --> \" + message;\n\t}\n}\nsrc/main/java/org/codeforamerica/open311/internals/parsing/DataParserFactory.java\npublic class DataParserFactory {\n\n\tprivate static DataParserFactory instance = new DataParserFactory();\n\n\tprivate DataParserFactory() {\n\t}\n\n\tpublic static DataParserFactory getInstance() {\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Builds a data parser taking care of the desired format.\n\t * \n\t * @param format\n\t *            Desired format.\n\t * @return an instance of {@link DataParser} of <code>null</code> if the\n\t *         given format is not supported.\n\t */\n\tpublic DataParser buildDataParser(Format format) {\n\t\tif (format == Format.XML) {\n\t\t\treturn new XMLParser();\n\t\t}\n\t\tif (format == Format.JSON) {\n\t\t\treturn new JSONParser();\n\t\t}\n\t\treturn null;\n\t}\n}\nsrc/main/java/org/codeforamerica/open311/internals/network/NetworkManager.java\npublic interface NetworkManager {\n\n\tpublic static final String POST_CONTENT_TYPE = \"application/x-www-form-urlencoded\";\n\tpublic static final String CHARSET = HTTP.UTF_8;\n\n\t/**\n\t * Sends a GET HTTP request.\n\t * \n\t * @param url\n\t *            Target.\n\t * @return Server response.\n\t * @throws IOException\n\t *             If there was any problem with the connection.\n\t */\n\tpublic String doGet(URL url) throws IOException;\n\n\t/**\n\t * Sends a POST HTTP request.\n\t * \n\t * @param url\n\t *            Target.\n\t * @param parameters\n\t *            Parameters of the POST operation.\n\t * @return Server response.\n\t * @throws IOException\n\t *             If there was any problem with the connection.\n\t */\n\tpublic String doPost(URL url, Map<String, String> parameters)\n\t\t\tthrows IOException;\n\n\t/**\n\t * Sets the desired format of the requests.\n\t * \n\t * @param format\n\t *            A serialization format (XML or JSON).\n\t */\n\tpublic void setFormat(Format format);\n}\nsrc/main/java/org/codeforamerica/open311/facade/exceptions/DataParsingException.java\npublic class DataParsingException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic DataParsingException(String message) {\n\t\tsuper(message);\n\t}\n\n}\nsrc/main/java/org/codeforamerica/open311/internals/caching/Cache.java\npublic interface Cache {\n\t/**\n\t * Saves the endpoints-service discovery relationships.\n\t * \n\t * @param data\n\t *            A JSON list.\n\t */\n\tpublic void saveCitiesInfo(String data);\n\n\t/**\n\t * Looks for the endpoints-service discovery relationships.\n\t * \n\t * @return A JSON list or <code>null</code> if it wasn't found.\n\t */\n\tpublic String retrieveCitiesInfo();\n\n\t/**\n\t * Saves a {@link ServiceDiscoveryInfo object} related to a city.\n\t * \n\t * @param city\n\t *            City related to the requested service discovery.\n\t * @param serviceDiscovery\n\t *            The obtained service discovery.\n\t */\n\tpublic void saveServiceDiscovery(City city,\n\t\t\tServiceDiscoveryInfo serviceDiscovery);\n\n\t/**\n\t * Looks for the service discovery of a given city in the local cache.\n\t * \n\t * @param city\n\t *            City of interest.\n\t * @return The service discovery of the given city of <code>null</code> if\n\t *         it isn't cached.\n\t */\n\tpublic ServiceDiscoveryInfo retrieveCachedServiceDiscoveryInfo(City city);\n\n\t/**\n\t * Saves a list of {@link Service} objects related to an endpoint.\n\t * \n\t * @param endpointUrl\n\t *            Url of the endpoint.\n\t * @param services\n\t *            Obtained services.\n\t */\n\tpublic void saveListOfServices(String endpointUrl, List<Service> services);\n\n\t/**\n\t * Looks for a cached list of services.\n\t * \n\t * @param endpointUrl\n\t *            Url of the endpoint.\n\t * @return The list of services or <code>null</code> if they aren't cached.\n\t */\n\tpublic List<Service> retrieveCachedServiceList(String endpointUrl);\n\n\t/**\n\t * Saves a service definition.\n\t * \n\t * @param endpointUrl\n\t *            Url of the endpoint.\n\t * @param serviceCode\n\t *            Code of the service.\n\t * @param serviceDefinition\n\t *            Obtained definition from the server.\n\t */\n\tpublic void saveServiceDefinition(String endpointUrl, String serviceCode,\n\t\t\tServiceDefinition serviceDefinition);\n\n\t/**\n\t * Looks for a cached service definition.\n\t * \n\t * @param endpointUrl\n\t *            Url of the endpoint.\n\t * @param serviceCode\n\t *            Service code of the desired service.\n\t * @return A service definition or <code>null</code> if it isn't cached.\n\t */\n\tpublic ServiceDefinition retrieveCachedServiceDefinition(\n\t\t\tString endpointUrl, String serviceCode);\n\n\t/**\n\t * Saves a list of service requests.\n\t * \n\t * @param endpointUrl\n\t *            Url of the endpoint.\n\t * @param filter\n\t *            Filter sent to the endpoint.\n\t * @param requests\n\t *            Obtained list of requests.\n\t */\n\tpublic void saveServiceRequestList(String endpointUrl,\n\t\t\tGETServiceRequestsFilter filter, List<ServiceRequest> requests);\n\n\t/**\n\t * Looks for a cached GET service requests response.\n\t * \n\t * @param endpointUrl\n\t *            Url of the endpoint.\n\t * @param filter\n\t *            The desired filter.\n\t * @return A list of ServiceRequest or <code>null</code> if they aren't\n\t *         cached.\n\t */\n\tpublic List<ServiceRequest> retrieveCachedServiceRequests(\n\t\t\tString endpointUrl, GETServiceRequestsFilter filter);\n\n\t/**\n\t * Saves a service request.\n\t * \n\t * @param endpointUrl\n\t *            Url of the endpoint.\n\t * @param serviceRequestId\n\t *            Id of the requested service request.\n\t * @param request\n\t *            Obtained service request.\n\t */\n\tpublic void saveSingleServiceRequest(String endpointUrl,\n\t\t\tString serviceRequestId, ServiceRequest request);\n\n\t/**\n\t * Looks for a cached GET service request response.\n\t * \n\t * @param endpointUrl\n\t *            Url of the endpoint.\n\t * @param serviceRequestId\n\t *            The service request's id.\n\t * @return A ServiceRequest or <code>null</code> if it wasn't cached.\n\t */\n\tpublic ServiceRequest retrieveCachedServiceRequest(String endpointUrl,\n\t\t\tString serviceRequestId);\n\n\t/**\n\t * Deletes the cache.\n\t */\n\tpublic void deleteCache();\n\n\t/**\n\t * Set a custom time to live to a given operation.\n\t * \n\t * @param operation\n\t *            Operation which time to live will be changed.\n\t * @param timeToLiveInHours\n\t *            New time to live (in hours).\n\t */\n\tpublic void setCustomTimeToLive(CacheableOperation operation,\n\t\t\tint timeToLiveInHours);\n\n\t/**\n\t * Set of operations which will be cached.\n\t * \n\t * @author Santiago Munín <santimunin@gmail.com>\n\t * \n\t */\n\tpublic static enum CacheableOperation {\n\t\tGET_SERVICE_DISCOVERY, GET_SERVICE_LIST, GET_SERVICE_DEFINITION, GET_SERVICE_REQUEST_LIST, GET_SINGLE_SERVICE_REQUEST, GET_CITIES_SERVICE_DISCOVERY_URLS;\n\t}\n}\nsrc/main/java/org/codeforamerica/open311/internals/parsing/DataParser.java\npublic interface DataParser {\n\tpublic static final String TEXT_FORMAT = \"utf-8\";\n\tpublic static final String SERVICE_TAG = \"service\";\n\tpublic static final String SERVICE_CODE_TAG = \"service_code\";\n\tpublic static final String SERVICE_NAME_TAG = \"service_name\";\n\tpublic static final String DESCRIPTION_TAG = \"description\";\n\tpublic static final String METADATA_TAG = \"metadata\";\n\tpublic static final String TYPE_TAG = \"type\";\n\tpublic static final String KEYWORDS_TAG = \"keywords\";\n\tpublic static final String KEYWORDS_SEPARATOR = \",\";\n\tpublic static final String SERVICE_GROUP_TAG = \"group\";\n\tpublic static final String SERVICE_DEFINITION_TAG = \"service_definition\";\n\tpublic static final String ATTRIBUTE_TAG = \"attribute\";\n\tpublic static final String ATTRIBUTES_TAG = \"attributes\";\n\tpublic static final String VARIABLE_TAG = \"variable\";\n\tpublic static final String CODE_TAG = \"code\";\n\tpublic static final String DATATYPE_TAG = \"datatype\";\n\tpublic static final String REQUIRED_TAG = \"required\";\n\tpublic static final String DATATYPE_DESCRIPTION_TAG = \"datatype_description\";\n\tpublic static final String ORDER_TAG = \"order\";\n\tpublic static final String VALUE_TAG = \"value\";\n\tpublic static final String VALUES_TAG = \"values\";\n\tpublic static final String KEY_TAG = \"key\";\n\tpublic static final String NAME_TAG = \"name\";\n\tpublic static final String SERVICE_REQUEST_TAG = \"request\";\n\tpublic static final String SERVICE_REQUESTS_TAG = \"service_requests\";\n\tpublic static final String TOKEN_TAG = \"token\";\n\tpublic static final String SERVICE_REQUEST_ID_TAG = \"service_request_id\";\n\tpublic static final String STATUS_TAG = \"status\";\n\tpublic static final String STATUS_NOTES_TAG = \"status_notes\";\n\tpublic static final String AGENCY_RESPONSIBLE_TAG = \"agency_responsible\";\n\tpublic static final String SERVICE_NOTICE_TAG = \"service_notice\";\n\tpublic static final String REQUESTED_DATETIME_TAG = \"requested_datetime\";\n\tpublic static final String UPDATED_DATETIME_TAG = \"updated_datetime\";\n\tpublic static final String EXPECTED_DATETIME_TAG = \"expected_datetime\";\n\tpublic static final String ADDRESS_TAG = \"address\";\n\tpublic static final String ADDRESS_ID_TAG = \"address_id\";\n\tpublic static final String ZIPCODE_TAG = \"zipcode\";\n\tpublic static final String LATITUDE_TAG = \"lat\";\n\tpublic static final String LONGITUDE_TAG = \"long\";\n\tpublic static final String MEDIA_URL_TAG = \"media_url\";\n\tpublic static final String ACCOUNT_ID_TAG = \"account_id\";\n\tpublic static final String ERROR_TAG = \"error\";\n\tpublic static final String DISCOVERY_TAG = \"discovery\";\n\tpublic static final String CHANGESET_TAG = \"changeset\";\n\tpublic static final String CONTACT_TAG = \"contact\";\n\tpublic static final String KEY_SERVICE_TAG = \"key_service\";\n\tpublic static final String SPECIFICATION_TAG = \"specification\";\n\tpublic static final String URL_TAG = \"url\";\n\tpublic static final String FORMAT_TAG = \"format\";\n\tpublic static final String ENDPOINT_TAG = \"endpoint\";\n\tpublic static final String START_DATE_TAG = \"start_date\";\n\tpublic static final String END_DATE_TAG = \"end_date\";\n\tpublic static final String EMAIL_TAG = \"email\";\n\tpublic static final String DEVICE_ID_TAG = \"device_id\";\n\tpublic static final String FIRST_NAME_TAG = \"first_name\";\n\tpublic static final String LAST_NAME_TAG = \"last_name\";\n\tpublic static final String PHONE_TAG = \"phone\";\n\n\t/**\n\t * Parses the response to the GET service list operation.\n\t * \n\t * @param rawData\n\t *            Text data.\n\t * @return A list of {@link Service} objects.\n\t */\n\tpublic List<Service> parseServiceList(String rawData)\n\t\t\tthrows DataParsingException;\n\n\t/**\n\t * Parses a service definition.\n\t * \n\t * @param rawData\n\t *            Text data.\n\t * @throws DataParsingException\n\t *             If there was any problem parsing the data.\n\t * \n\t * @return A service definition object.\n\t */\n\tpublic ServiceDefinition parseServiceDefinition(String rawData)\n\t\t\tthrows DataParsingException;\n\n\t/**\n\t * Parses the response to the GET service request id from a token.\n\t * \n\t * @param rawData\n\t *            Text data.\n\t * @return the given token and the service request id.\n\t * @throws DataParsingException\n\t *             If there was any problem parsing the data.\n\t */\n\tpublic ServiceRequestIdResponse parseServiceRequestIdFromAToken(\n\t\t\tString rawData) throws DataParsingException;\n\n\t/**\n\t * Parses a list of service requests.\n\t * \n\t * @param rawData\n\t *            Text data.\n\t * @return A list of ServiceRequest objects.\n\t * @throws DataParsingException\n\t *             If there was any problem parsing the data.\n\t */\n\tpublic List<ServiceRequest> parseServiceRequests(String rawData)\n\t\t\tthrows DataParsingException;\n\n\t/**\n\t * Parses the response of a POST Service Request operation.\n\t * \n\t * @param rawData\n\t *            Text data.\n\t * @return an object containing the response information.\n\t * @throws DataParsingException\n\t *             If there was any problem parsing the data.\n\t */\n\tpublic POSTServiceRequestResponse parsePostServiceRequestResponse(\n\t\t\tString rawData) throws DataParsingException;\n\n\t/**\n\t * Parses an error and returns an object with its information.\n\t * \n\t * @param rawData\n\t *            Text data.\n\t * @return Error information.\n\t * @throws DataParsingException\n\t *             If there was any problem parsing the data.\n\t */\n\tpublic GeoReportV2Error parseGeoReportV2Errors(String rawData)\n\t\t\tthrows DataParsingException;\n\n\t/**\n\t * Parses a service discovery and returns an object with its information.\n\t * \n\t * @param rawData\n\t *            Text data.\n\t * @return Service discovery information (endpoints and their formats).\n\t * @throws DataParsingException\n\t *             If there was any problem parsing the data.\n\t */\n\tpublic ServiceDiscoveryInfo parseServiceDiscovery(String rawData)\n\t\t\tthrows DataParsingException;\n}\n", "answers": ["\tprivate NetworkManager networkManager = new HTTPNetworkManager(Format.XML);"], "length": 3104, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "5c667f62e932d52dfea55380d5ef3eb5d7ecc614f0535502"}
{"input": "import static org.jboss.remotingjmx.protocol.v1.Constants.ADD_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.ATTRIBUTE_LIST;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.BOOLEAN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.CREATE_MBEAN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.EXCEPTION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.FAILURE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_DEFAULT_DOMAIN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_DOMAINS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_MBEAN_COUNT;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INSTANCE_OF;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INTEGER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INTEGER_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INVOKE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.IS_REGISTERED;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.NOTIFICATION_FILTER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_EXP;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_MBEANS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_NAMES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.REMOVE_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.RESPONSE_MASK;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SEND_NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.STRING;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.STRING_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SUCCESS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.UNREGISTER_MBEAN;\nimport java.io.DataInput;\nimport java.io.DataInputStream;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.security.AccessController;\nimport java.security.PrivilegedExceptionAction;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.Executor;\nimport javax.management.Attribute;\nimport javax.management.AttributeList;\nimport javax.management.AttributeNotFoundException;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.InstanceNotFoundException;\nimport javax.management.IntrospectionException;\nimport javax.management.InvalidAttributeValueException;\nimport javax.management.JMRuntimeException;\nimport javax.management.ListenerNotFoundException;\nimport javax.management.MBeanException;\nimport javax.management.MBeanInfo;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MBeanServerConnection;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.Notification;\nimport javax.management.NotificationFilter;\nimport javax.management.NotificationListener;\nimport javax.management.ObjectInstance;\nimport javax.management.ObjectName;\nimport javax.management.QueryExp;\nimport javax.management.ReflectionException;\nimport org.jboss.logging.Logger;\nimport org.jboss.marshalling.AbstractClassResolver;\nimport org.jboss.marshalling.Marshaller;\nimport org.jboss.marshalling.Unmarshaller;\nimport org.jboss.remoting3.Channel;\nimport org.jboss.remoting3.MessageInputStream;\nimport org.jboss.remotingjmx.ServerMessageInterceptor;\nimport org.jboss.remotingjmx.ServerMessageInterceptor.Event;\nimport org.jboss.remotingjmx.VersionedProxy;\nimport org.jboss.remotingjmx.WrappedMBeanServerConnection;\nimport org.xnio.IoUtils;\n/*\n * JBoss, Home of Professional Open Source.\n * Copyright 2012, Red Hat, Inc., and individual contributors\n * as indicated by the @author tags. See the copyright.txt file in the\n * distribution for a full listing of individual contributors.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.jboss.remotingjmx.protocol.v1;\n\n\n\n\n\n/**\n * The VersionOne server proxy.\n *\n * The ServerProxy is a proxy for a single client connection, any state tracked by a proxy is client connection specific.\n *\n * @author <a href=\"mailto:darran.lofthouse@jboss.com\">Darran Lofthouse</a>\n */\nclass ServerProxy extends Common implements VersionedProxy {\n\n    private static final Logger log = Logger.getLogger(ServerProxy.class);\n\n    private final Channel channel;\n    private final WrappedMBeanServerConnection server;\n    private UUID connectionId;\n    private final Executor executor;\n    private final ServerMessageInterceptor serverMessageInterceptor;\n    // Registry of handlers for the incoming messages.\n    private final Map<Byte, Common.MessageHandler> handlerRegistry;\n    private final RemoteNotificationManager remoteNotificationManager;\n\n    ServerProxy(final Channel channel, final WrappedMBeanServerConnection server, final Executor executor,\n            final ServerMessageInterceptor serverMessageInterceptor) {\n        super(channel);\n        this.channel = channel;\n        this.server = server;\n        this.handlerRegistry = createHandlerRegistry();\n        this.remoteNotificationManager = new RemoteNotificationManager();\n        this.executor = executor;\n        this.serverMessageInterceptor = serverMessageInterceptor;\n    }\n\n    private Map<Byte, Common.MessageHandler> createHandlerRegistry() {\n        Map<Byte, Common.MessageHandler> registry = new HashMap<Byte, Common.MessageHandler>();\n        registry.put(ADD_NOTIFICATION_LISTENER, new AddNotificationListenerHandler());\n        registry.put(CREATE_MBEAN, new CreateMBeanHandler());\n        registry.put(GET_ATTRIBUTE, new GetAttributeHandler());\n        registry.put(GET_ATTRIBUTES, new GetAttributesHandler());\n        registry.put(GET_DEFAULT_DOMAIN, new GetDefaultDomainHandler());\n        registry.put(GET_DOMAINS, new GetDomainsHandler());\n        registry.put(GET_MBEAN_COUNT, new GetMBeanCountHandler());\n        registry.put(GET_MBEAN_INFO, new GetMBeanInfoHandler());\n        registry.put(GET_OBJECT_INSTANCE, new GetObjectInstanceHandler());\n        registry.put(INSTANCE_OF, new InstanceofHandler());\n        registry.put(INVOKE, new InvokeHandler());", "context": "src/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte IS_REGISTERED = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte NOTIFICATION_FILTER = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte STRING_ARRAY = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ATTRIBUTE_LIST = 0x02;\nsrc/main/java/org/jboss/remotingjmx/ServerMessageInterceptor.java\npublic interface ServerMessageInterceptor {\n\n    /**\n     * Called to handle the actual event, gives the Interceptor an opportunity to wrap the call.\n     *\n     * @param event - The event to run.\n     * @throws IOException - If thrown from the event.\n     */\n    void handleEvent(final Event event) throws IOException;\n\n    public interface Event {\n        void run() throws IOException;\n    }\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_DOMAINS = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/ServerMessageInterceptor.java\npublic interface Event {\n    void run() throws IOException;\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_ATTRIBUTES = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_NAME = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ATTRIBUTE = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SEND_NOTIFICATION = 0x13;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_NAMES = 0x05;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_EXP = 0x07;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INTEGER = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_INSTANCE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_MBEANS = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_OBJECT_INSTANCE = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte CREATE_MBEAN = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_ATTRIBUTES = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte UNREGISTER_MBEAN = 0x02;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_OBJECT_INSTANCE = 0x03;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte RESPONSE_MASK = (byte) 0x80;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte NOTIFICATION = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte FAILURE = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_DEFAULT_DOMAIN = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte REMOVE_NOTIFICATION_LISTENER = 0x12;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte EXCEPTION = 0x03;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_ARRAY = 0x05;\nsrc/main/java/org/jboss/remotingjmx/VersionedProxy.java\npublic interface VersionedProxy {\n\n    String getConnectionId();\n\n    void close();\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SUCCESS = 0x00;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INVOKE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_MBEAN_INFO = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_ATTRIBUTE = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_ATTRIBUTE = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_MBEAN_COUNT = 0x07;\nsrc/main/java/org/jboss/remotingjmx/WrappedMBeanServerConnection.java\npublic interface WrappedMBeanServerConnection {\n\n    MBeanServerConnection getMBeanServerConnection();\n\n    void connectionOpened(final VersionedProxy proxy);\n\n    void connectionClosed(final VersionedProxy proxy);\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_OBJECT_NAME = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte BOOLEAN = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INSTANCE_OF = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ADD_NOTIFICATION_LISTENER = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte MBEAN_INFO = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte STRING = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INTEGER_ARRAY = 0x12;\n", "answers": ["        registry.put(IS_REGISTERED, new IsRegisteredHandler());"], "length": 931, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "eb65a3ee4f1ec1c6aff46fab2b3de3dce21df05326bace5d"}
{"input": "import datetime\nimport itertools\nimport logging\nimport os\nimport shutil\nimport sys\nimport configargparse\nimport six\nimport camsa\nfrom collections import defaultdict\nfrom jinja2 import FileSystemLoader\nfrom jinja2.environment import Environment\nfrom camsa.core import io as camsa_io\nfrom camsa.core import merging\nfrom camsa.core.comparative_analysis import compute_and_update_assembly_points_conflicts\nfrom camsa.core.data_structures import Assembly, assign_ids_to_assembly_points, merge_assembly_points, assign_parents_to_children, to_json, Sequence, OrderGraph, AssemblyPoint\nfrom camsa.core.merging import MergingStrategies, update_assembly_points_with_merged_assembly, update_gap_sizes_in_merged_assembly\n    #######################################\n    #           input stage               #\n    #######################################\n    logger.info(\"Processing input\")\n\n    # key is the origin of assembly point; values is the list of all points from that source\n    logger.info(\"Reading assembly points\")\n    assembly_points_by_sources = camsa_io.read_assembly_points_from_input_sources(sources=args.points,\n                                                                                  default_cw_eae=args.c_cw_exact,\n                                                                                  default_cw_cae=args.c_cw_candidate,\n                                                                                  delimiter=args.i_delimiter)\n    or_seqi = defaultdict(list)\n    if args.seqi is not None:\n        args.seqi = os.path.abspath(os.path.expanduser(args.seqi))\n        logger.info(\"Reading sequences' info\")\n        with open(args.seqi, \"rt\") as source:\n            camsa_io.read_seqi_from_input_sources(source=source, delimiter=args.seqi_delimiter, destination=or_seqi)\n    seqi = {}\n    for seq_name in list(or_seqi.keys()):\n        entry_list = or_seqi[seq_name]\n        seqi[seq_name] = entry_list[0]\n    if len(seqi) > 0:\n        sequences_ids_from_assembly_points = set()\n        for source, aps in assembly_points_by_sources.items():\n            for ap in aps:\n                sequences_ids_from_assembly_points.add(ap.seq1)\n                sequences_ids_from_assembly_points.add(ap.seq2)\n        sequences_ids_from_lengths = set(seqi.keys())\n        difference = sequences_ids_from_assembly_points - sequences_ids_from_lengths\n        if len(difference) > 0:\n            logger.warning(\"Some sequences, that participate in assembly points do not have lengths associated with them,\"\n                           \"while others do.\")\n            logger.warning(\"Problematic sequences: {seqs}\".format(seqs=\",\".join(sorted(difference))))\n            if args.seqi_ensure:\n                logger.error(\"A flag \\\"--seqi-ensure-all\\\" was set, so the program terminates\")\n            else:\n                logger.warning(\"Assigning lengths of -1 to all problematic sequences\")\n                for seq_id in difference:\n                    seqi[seq_id] = Sequence(name=seq_id, length=-1)\n\n    #######################################\n    #       extracting reference          #\n    #######################################\n    reference_assembly = None\n    if args.reference and args.reference_name != \"\":\n        try:\n            reference_aps = assembly_points_by_sources.pop(args.reference_name)\n            reference_assembly = Assembly(name=args.reference_name, aps=reference_aps)\n        except KeyError:\n            logger.critical(\"Supplied reference \\\"{reference_name}\\\" was not found among assembly sources [{avail_sources}]\".format(reference_name=args.reference_name, avail_sources=\",\".join(assembly_points_by_sources.keys())))\n            exit(1)\n\n    id_generator = itertools.count()\n    original_assembly_points = [or_ap for aps in assembly_points_by_sources.values() for or_ap in aps]\n    # for assembly_points in assembly_points_by_sources.values():\n    original_assembly_points_by_ids = assign_ids_to_assembly_points(assembly_points=original_assembly_points, id_prefix=\"or_\",\n                                                                    id_generator=id_generator, sort=True)\n\n    #######################################\n    #       assembly points merging       #\n    #######################################\n    logger.info(\"Merging assembly points from different sources into a set of unique ones.\")\n    merged_assembly_points = merge_assembly_points(assembly_points_by_source=assembly_points_by_sources)\n    merged_assembly_points_by_ids = assign_ids_to_assembly_points(assembly_points=merged_assembly_points, id_prefix=\"m_\", sort=True)\n    assign_parents_to_children(children_assembly_points_by_ids=original_assembly_points_by_ids,\n                               parent_assembly_points_by_ids=merged_assembly_points_by_ids)\n\n    #######################################\n    #       assemblies subgroups          #\n    #######################################\n    logger.info(\"Processing assemblies' subgroups\")\n    logger.info(\"Processing assembly points taking both order and orientation into account\")\n    tmp_individual_assemblies = defaultdict(list)\n    for ap in merged_assembly_points:\n        for source_name in ap.sources:\n            tmp_individual_assemblies[source_name].append(ap)\n    individual_assemblies = [Assembly(name=name, aps=aps) for name, aps in tmp_individual_assemblies.items()]\n\n    grouped_assemblies = []\n    for i in range(1, len(individual_assemblies) + 1):\n        for assembly_combination in itertools.combinations(sorted([a.name for a in individual_assemblies]), i):\n            assembly = Assembly(name=assembly_combination, aps=[])\n            for ap in merged_assembly_points:\n                if len(ap.sources) == len(assembly_combination) and all(map(lambda entry: entry in ap.sources, assembly_combination)):\n                    assembly.aps.append(ap)\n            grouped_assemblies.append(assembly)\n    grouped_assemblies = list(filter(lambda a: len(a.aps) > 0, sorted(grouped_assemblies, key=lambda entry: len(entry.aps), reverse=True)))\n    if args.c_subgroups_cntlim >= 0:\n        grouped_assemblies = grouped_assemblies[:args.c_subgroups_cntlim]\n\n    logger.info(\"Processing assembly points, taking just order into account\")\n    order_graph = OrderGraph.from_aps(aps=merged_assembly_points)\n    unoriented_aps = []\n    for (u, v, data) in order_graph.graph.edges(data=True):\n        ap = AssemblyPoint(seq1=u, seq2=v, seq1_or=\"?\", seq2_or=\"?\",\n                           children_ids=set(data[\"ids\"]), sources=sorted(set(data[\"sources\"])))\n        unoriented_aps.append(ap)\n    unoriented_aps_by_ids = assign_ids_to_assembly_points(assembly_points=unoriented_aps, id_prefix=\"unor_\")\n    grouped_unoriented_assemblies = []\n    for i in range(1, len(individual_assemblies) + 1):\n        for assembly_combination in itertools.combinations(sorted([a.name for a in individual_assemblies]), i):\n            assembly = Assembly(name=assembly_combination, aps=[])\n            for ap in unoriented_aps:\n                if len(ap.sources) == len(assembly_combination) and all(map(lambda entry: entry in ap.sources, assembly_combination)):\n                    assembly.aps.append(ap)\n            grouped_unoriented_assemblies.append(assembly)\n    grouped_unoriented_assemblies = list(filter(lambda a: len(a.aps) > 0, sorted(grouped_unoriented_assemblies, key=lambda entry: len(entry.aps), reverse=True)))\n    if args.c_subgroups_uo_cntlim >= 0:\n        grouped_unoriented_assemblies = grouped_unoriented_assemblies[:args.c_subgroups_uo_cntlim]\n\n    #######################################\n    #        reference   analysis         #\n    #######################################\n    # for assembly in individual_assemblies:\n    #     analyze_and_update_assembly_points_based_on_reference(assembly=assembly, ref_assembly=reference_assembly)\n\n    #######################################\n    #        comparative analysis         #\n    #######################################\n    logger.info(\"Computing assembly points conflicts\")\n", "context": "camsa/core/data_structures.py\nclass AssemblyPoint(object):\n    def __init__(self, seq1, seq2, seq1_or, seq2_or, sources, cw=None, parent_id=None, children_ids=None, self_id=None,\n                 gap_size=None):\n        self.seq1 = seq1\n        self.seq2 = seq2\n        self.seq1_or = seq1_or\n        self.seq2_or = seq2_or\n        self.sources = sorted(sources)\n        self.cw = cw\n        self.gap_size = gap_size\n        self.self_id = self_id\n        self.parent_id = parent_id\n        self.children_ids = children_ids if children_ids is not None else []\n        #### comparative metrics\n        self.participates_in_merged = False\n        self.in_conflicted = defaultdict(set)\n        self.in_semi_conflicted = defaultdict(set)\n        self.out_conflicted = defaultdict(set)\n        self.out_semi_conflicted = defaultdict(set)\n        self.seq1_par_or = None\n        self.seq2_par_or = None\n        #### ref metrics\n        self.ref_metrics = RefMetrics()\n        self.extra_data = {}\n\n    @property\n    def orientation_as_word(self):\n        if self.is_unoriented:\n            return \"U\"\n        if self.is_semi_oriented:\n            return \"SO\"\n        return \"O\"\n\n    @property\n    def is_unoriented(self):\n        return [self.seq1_or, self.seq2_or].count(\"?\") == 2\n\n    @property\n    def is_semi_oriented(self):\n        return [self.seq1_or, self.seq2_or].count(\"?\") == 1\n\n    @property\n    def is_oriented(self):\n        return [self.seq1_or, self.seq2_or].count(\"?\") == 0\n\n    def is_in_semi_conflicted_for(self, source_name):\n        return source_name in self.in_semi_conflicted\n\n    def is_in_conflicted_for(self, source_name):\n        return source_name in self.in_conflicted\n\n    def is_out_semi_conflicted_for(self, source_name):\n        return len(self.out_semi_conflicted) > 0\n\n    def is_out_conflicted_for(self, source_name):\n        return len(self.out_conflicted) > 0\n\n    @property\n    def is_out_conflicted(self):\n        return len(self.out_conflicted) > 0\n\n    @property\n    def is_out_semi_conflicted(self):\n        return len(self.out_semi_conflicted) > 0\n\n    @property\n    def is_non_conflicted(self):\n        return len(self.in_conflicted) == 0 and len(self.out_conflicted) == 0 and len(self.in_semi_conflicted) == 0 and len(\n            self.out_semi_conflicted) == 0\n\n    def get_edges(self, weight=False, sort=True):\n        result = []\n        for ap in self.get_all_all_possible_realizations():\n            head = ap.seq1 + (\"h\" if ap.seq1_or == \"+\" else \"t\")\n            tail = ap.seq2 + (\"t\" if ap.seq2_or == \"+\" else \"h\")\n            hv = head\n            tv = tail\n            if sort:\n                hv, tv = (hv, tv) if hv < tv else (tv, hv)\n            if weight:\n                result.append((hv, tv, self.cw))\n            else:\n                result.append((hv, tv))\n        return result\n\n    def get_all_all_possible_realizations(self):\n        result = []\n        if self.seq1_or == \"?\":\n            seq1_choices = [\"+\", \"-\"]\n        else:\n            seq1_choices = [self.seq1_or]\n        if self.seq2_or == \"?\":\n            seq2_choices = [\"+\", \"-\"]\n        else:\n            seq2_choices = [self.seq2_or]\n        for ctg1_or, ctg2_or in itertools.product(seq1_choices, seq2_choices):\n            result.append(AssemblyPoint(seq1=self.seq1, seq2=self.seq2, seq1_or=ctg1_or, seq2_or=ctg2_or,\n                                        sources=self.sources))\n        return result\n\n    @property\n    def is_ambiguous(self):\n        return self.seq1_or == \"?\" or self.seq2_or == \"?\"\ncamsa/core/data_structures.py\nclass Sequence(object):\n    def __init__(self, name, length=None, parent_seq_id=None, start=None, end=None, strand=\"+\", annotation=None, seq_group_id=\"Default\"):\n        self.name = name\n        self._length = length\n        self._parent_seq_id = parent_seq_id\n        self._start = start\n        self._end = end\n        self._seq_group_id = seq_group_id\n        self.strand = strand\n        self._annotation = annotation\n\n    @property\n    def length(self):\n        if self._length is not None:\n            return self._length\n        if self.start is not None and self.end is not None:\n            return self.end - self.start\n        return None\n\n    @property\n    def parent_seq_id(self):\n        if self._parent_seq_id is None:\n            return self.name\n        return self._parent_seq_id\n\n    @property\n    def start(self):\n        if self._start is None:\n            return 0\n        return int(self._start)\n\n    @property\n    def end(self):\n        if self._end is None:\n            return sys.maxsize\n        return int(self._end)\n\n    @property\n    def seq_group_id(self):\n        return str(self._seq_group_id)\n\n    @property\n    def annotation(self):\n        return str(self._annotation)\ncamsa/core/data_structures.py\ndef assign_parents_to_children(children_assembly_points_by_ids, parent_assembly_points_by_ids):\n    for p_assembly_point in parent_assembly_points_by_ids.values():\n        for child_id in p_assembly_point.children_ids:\n            children_assembly_points_by_ids[child_id].parent_id = p_assembly_point.self_id\ncamsa/core/merging.py\ndef update_assembly_points_with_merged_assembly(original_assembly_points_by_ids, merged_assembly_points_by_ids, merged_assembly_graph):\n    for ap in merged_assembly_points_by_ids.values():\n        for u, v in ap.get_edges():\n            if merged_assembly_graph.has_edge(u=u, v=v):\n                par_or_1 = \"+\" if u.endswith(\"h\") else \"-\"\n                par_or_2 = \"+\" if v.endswith(\"t\") else \"-\"\n                forward = u[:-1] == ap.seq1\n                if not forward:\n                    par_or_1, par_or_2 = inverse_orientation(par_or_2), inverse_orientation(par_or_1)\n                ap.seq1_par_or = par_or_1\n                ap.seq2_par_or = par_or_2\n                ap.participates_in_merged = True\n                for child_id in ap.children_ids:\n                    child = original_assembly_points_by_ids[child_id]\n                    child.participates_in_merged = True\n                    child.seq1_par_or = par_or_1\n                    child.seq2_par_or = par_or_2\n                break\ncamsa/core/data_structures.py\ndef to_json(value):\n    if isinstance(value, Sequence):\n        return json.dumps({\"seq_id\": value.name, \"length\": value.length})\n    result = {}\n    for key, values in value.items():\n        if isinstance(values, str):\n            result[key] = values\n        else:\n            result[key] = sorted(values)\n    return json.dumps(result)\ncamsa/core/data_structures.py\nclass Assembly(object):\n    def __init__(self, name, aps):\n        self.name = name\n        self.aps = aps\n        self.total_cnt = 0\n        self.max_non_conflicting_aps = []\n\n    @property\n    def entries_names(self):\n        return self.get_all_entries_names()\n\n    def get_all_entries_names(self):\n        return sorted(set(name for ap in self.aps for name in ap.sources))\n\n    def sort_aps(self):\n        self.aps = sorted(self.aps,\n                          key=lambda ap: (ap.contig_1, ap.contig_1_orientation, ap.contig_2, ap.contig_2_orientation))\n\n    @property\n    def unoriented_ap_cnt(self):\n        return sum(ap.is_unoriented for ap in self.aps)\n\n    @property\n    def semi_oriented_aps_cnt(self):\n        return sum(ap.is_semi_oriented for ap in self.aps)\n\n    @property\n    def oriented_aps_cnt(self):\n        return sum(ap.is_oriented for ap in self.aps)\n\n    @property\n    def in_conflicted_cnt(self):\n        cnt = 0\n        for ap in self.aps:\n            if isinstance(self.name, tuple):\n                to_check = self.name\n            else:\n                to_check = [self.name]\n            for name in to_check:\n                if ap.is_in_conflicted_for(name):\n                    cnt += 1\n                    break\n        return cnt\n\n    @property\n    def in_semi_conflicted_cnt(self):\n        cnt = 0\n        for ap in self.aps:\n            if isinstance(self.name, tuple):\n                to_check = self.name\n            else:\n                to_check = [self.name]\n            for name in to_check:\n                if ap.is_in_semi_conflicted_for(name):\n                    cnt += 1\n                    break\n        return cnt\n\n    @property\n    def out_conflicted_cnt(self):\n        return sum(ap.is_out_conflicted for ap in self.aps)\n\n    @property\n    def out_semi_conflicted_cnt(self):\n        return sum(ap.is_out_semi_conflicted for ap in self.aps)\n\n    @property\n    def non_conflicted_cnt(self):\n        return len([ap for ap in self.aps if ap.is_non_conflicted])\ncamsa/core/comparative_analysis.py\ndef compute_and_update_assembly_points_conflicts(assembly_points_by_ids):\n    \"\"\"\n\n    :param assembly_points_by_ids: a dictionary, where key is the assembly point id, and value is merged assembly points\n    :return:\n    \"\"\"\n    sag = ScaffoldAssemblyGraph.from_assembly_points(assembly_points=assembly_points_by_ids.values(),\n                                                     add_scaffold_edges=False)\n    for ap in assembly_points_by_ids.values():\n        conflicted_assembly_points = get_conflicting_assembly_points(sag=sag, assembly_point=ap,\n                                                                     assembly_points_by_ids=assembly_points_by_ids)\n        for c_ap in conflicted_assembly_points:\n            conflict_type = get_conflict_type(ap1=ap, ap2=c_ap)\n            assert conflict_type != Conflicts.non_conflicted\n            if conflict_type == Conflicts.conflicted:\n                update_assembly_points_as_conflicted(ap1=ap, ap2=c_ap)\n            elif conflict_type == Conflicts.semi_conflicted:\n                update_assembly_points_as_semi_conflicted(ap1=ap, ap2=c_ap)\ncamsa/core/merging.py\ndef update_gap_sizes_in_merged_assembly(original_assembly_points_by_ids, merged_assembly_points_by_ids):\n    aps_in_merged_assembly = [ap for ap in merged_assembly_points_by_ids.values() if ap.participates_in_merged]\n    for ap in aps_in_merged_assembly:\n        children_aps = [original_assembly_points_by_ids[c_id] for c_id in ap.children_ids]\n        cumulative_gap_size = 0.0\n        gap_size_sources_cnt = 0.0\n        for c_ap in children_aps:\n            if isinstance(c_ap.gap_size, numbers.Number):\n                gap_size_sources_cnt += 1\n                cumulative_gap_size += c_ap.gap_size\n        if gap_size_sources_cnt == 0:\n            inferred_gap_size = \"?\"\n        else:\n            inferred_gap_size = cumulative_gap_size / gap_size_sources_cnt\n        ap.gap_size = inferred_gap_size\ncamsa/core/io.py\ndef get_fn_relations_for_column_names(fieldnames, aliases):\ndef extract_nullable_value(field, row, fn_relations, default=\"?\"):\ndef extract_nullable_numerical_value(field, row, fn_relations, default=\"?\"):\ndef read_pairs(source, delimiter=\"\\t\", destination=None, default_cw_eae=1, default_cw_cae=0.9, read_ids=False, read_extra_data=False):\ndef read_assembly_points_from_input_sources(sources, delimiter=\"\\t\", default_cw_eae=1, default_cw_cae=0.75, read_ids=False, read_extra_data=False):\ndef read_lengths(source, delimiter=\"\\t\", destination=None):\ndef get_header_and_extract_list(settings):\ndef write_assembly_points(assembly_points, destination, output_setup, delimiter=\"\\t\"):\ndef write_seqi(sequences, destination, output_setup, delimiter=\"\\t\"):\ndef read_seqi_from_input_sources(source, delimiter=\"\\t\", destination=None):\ndef remove_dir(dir_path):\nPAIRS_COLUMN_ALIASES = {\n    ########################\n    \"species\": \"origin\",\n    \"organisms\": \"origin\",\n    \"origin\": \"origin\",\n    ########################\n    \"ctg1\": \"seq1\",\n    \"contig1\": \"seq1\",\n    \"seq1\": \"seq1\",\n    ########################\n    \"ctg2\": \"seq2\",\n    \"contig2\": \"seq2\",\n    \"seq2\": \"seq2\",\n    ########################\n    \"orientation_ctg1\": \"seq1_or\",\n    \"orientation_contig1\": \"seq1_or\",\n    \"ctg1_orientation\": \"seq1_or\",\n    \"ctg1_or\": \"seq1_or\",\n    \"seq1_or\": \"seq1_or\",\n    ########################\n    \"ctg2_orientation\": \"seq2_or\",\n    \"orientation_ctg2\": \"seq2_or\",\n    \"orientation_contig2\": \"seq2_or\",\n    \"ctg2_or\": \"seq2_or\",\n    \"seq2_or\": \"seq2_or\",\n    ########################\n    \"distance\": \"gap_size\",\n    \"ctg1-ctg2_gap\": \"gap_size\",\n    \"gap_size\": \"gap_size\",\n    ########################\n    \"score\": \"cw\",\n    \"cw\": \"cw\",\n    ########################\n    \"self_id\": \"self_id\",\n}\nLENGTHS_COLUMN_ALIASES = {\n    ########################\n    \"ctg_id\": \"seq_id\",\n    ########################\n    \"ctg_length\": \"seq_length\"\n}\nclass OrientationChoice(Enum):\ncamsa/core/merging.py\nclass MergingStrategies(enum.Enum):\n    greedy_merging = \"greedy\"\n    maximal_matching = \"maximal-matching\"\ncamsa/core/merging.py\nclass MergingStrategies(enum.Enum):\ndef get_un_oriented_assembly_points(assembly_points):\ndef merge_greedily(assembly_points_by_sources, acyclic=True, min_cw=0.0):\n    def get_redundant_edges_from_assembly_points(e, points_by_edges, processed_points):\ndef maximal_matching(assembly_points_by_sources, acyclic=True, min_cw=0.0):\ndef get_edges_from_matching(matching):\ndef update_assembly_points_with_merged_assembly(original_assembly_points_by_ids, merged_assembly_points_by_ids, merged_assembly_graph):\ndef update_gap_sizes_in_merged_assembly(original_assembly_points_by_ids, merged_assembly_points_by_ids):\ncamsa/core/data_structures.py\ndef assign_ids_to_assembly_points(assembly_points, id_prefix=\"\", id_generator=None, skip_existing=True, sort=False):\n    assembly_points_by_ids = {}\n    if id_generator is None:\n        id_generator = itertools.count()\n    existing_ids = set()\n    if not skip_existing:\n        for ap in assembly_points:\n            if ap.self_id is not None and ap.self_id != \"?\":\n                existing_ids.add(ap.self_id)\n    if sort:\n        s_assembly_points = sorted(assembly_points, key=lambda entry: (entry.seq1, entry.seq2, entry.seq1_or, entry.seq2_or, entry.sources))\n    else:\n        s_assembly_points = assembly_points\n    for assembly_point in s_assembly_points:\n        if skip_existing:\n            new_id = id_prefix + str(six.next(id_generator))\n            assembly_point.self_id = new_id\n        elif assembly_point.self_id is None or assembly_point.self_id == \"?\":\n            new_id = id_prefix + str(six.next(id_generator))\n            while new_id in existing_ids:\n                new_id = id_prefix + str(six.next(id_generator))\n            assembly_point.self_id = new_id\n        assembly_points_by_ids[assembly_point.self_id] = assembly_point\n    return assembly_points_by_ids\ncamsa/core/data_structures.py\nclass OrderGraph(object):\n    def __init__(self, graph=None):\n        self.graph = graph if graph is not None else networkx.Graph()\n\n    def add_ap(self, ap):\n        seq1, seq2 = ap.seq1, ap.seq2\n        if self.graph.has_edge(u=seq1, v=seq2):\n            self.graph[seq1][seq2][\"ids\"].append(ap.self_id)\n            self.graph[seq1][seq2][\"sources\"].extend(ap.sources)\n        else:\n            self.graph.add_edge(seq1, seq2, ids=[ap.self_id], sources=[source for source in ap.sources])\n\n    @classmethod\n    def from_aps(cls, aps):\n        result = cls()\n        for ap in aps:\n            result.add_ap(ap=ap)\n        return result\ncamsa/core/data_structures.py\ndef merge_assembly_points(assembly_points_by_source):\n    unique_assembly_points = defaultdict(list)\n\n    for assembly_points in assembly_points_by_source.values():\n        for assembly_point in assembly_points:\n            seq1, seq2 = assembly_point.seq1, assembly_point.seq2\n            seq1_or, seq2_or = assembly_point.seq1_or, assembly_point.seq2_or\n            if seq1 < seq2:\n                entry = (seq1, seq1_or, seq2, seq2_or)\n            else:\n                entry = (seq2, inverse_orientation(seq2_or), seq1, inverse_orientation(seq1_or))\n            unique_assembly_points[entry].append(assembly_point)\n    result = []\n    for (seq1, seq1_or, seq2, seq2_or), children in unique_assembly_points.items():\n        sources = sorted(set(source for ap in children for source in ap.sources))\n        weight = sum(ap.cw for ap in children)\n        children_ids = [ap.self_id for ap in children]\n        merged_assembly_point = AssemblyPoint(seq1=seq1, seq2=seq2, seq1_or=seq1_or, seq2_or=seq2_or,\n                                              sources=sources, cw=weight, children_ids=children_ids)\n        result.append(merged_assembly_point)\n    return result\n", "answers": ["    compute_and_update_assembly_points_conflicts(assembly_points_by_ids=merged_assembly_points_by_ids)"], "length": 1723, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "bcaa9f716f84f9b5980acf0cb06cb64a431557744a2cdcd5"}
{"input": "import static net.amigocraft.mglib.Main.locale;\nimport net.amigocraft.mglib.MGUtil;\nimport net.amigocraft.mglib.Main;\nimport net.amigocraft.mglib.UUIDFetcher;\nimport net.amigocraft.mglib.event.player.MGPlayerSpectateEvent;\nimport net.amigocraft.mglib.exception.NoSuchPlayerException;\nimport net.amigocraft.mglib.exception.PlayerOfflineException;\nimport net.amigocraft.mglib.exception.PlayerPresentException;\nimport net.amigocraft.mglib.exception.RoundFullException;\nimport net.amigocraft.mglib.misc.JoinResult;\nimport net.amigocraft.mglib.misc.Metadatable;\nimport net.amigocraft.mglib.util.NmsUtil;\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Location;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.PlayerInventory;\nimport org.bukkit.potion.PotionEffect;\nimport org.bukkit.potion.PotionEffectType;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Random;\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2015 Maxim Roncacé\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage net.amigocraft.mglib.api;\n\n\n\n\n\n/**\n * Represents a player participating in a minigame.\n *\n * @since 0.1.0\n */\npublic class MGPlayer implements Metadatable {\n\n\tHashMap<String, Object> metadata = new HashMap<String, Object>();\n\n\tprivate String plugin;\n\tprivate String name;\n\tprivate String arena;\n\tprivate boolean spectating = false;\n\tprivate String prefix = \"\";\n\tprivate GameMode prevGameMode;\n\tprivate String team = null;\n\tprivate boolean frozen = false;\n\n\t/**\n\t * Creates a new MGPlayer instance.\n\t *\n\t * @param plugin the plugin to associate the MGPlayer with\n\t * @param name   the username of the player\n\t * @param arena  the arena of the player\n\t * @since 0.1.0\n\t */\n\tpublic MGPlayer(String plugin, String name, String arena) {\n\t\tthis.plugin = plugin;\n\t\tthis.name = name;\n\t\tthis.arena = arena;\n\t}\n\n\t/**\n\t * Gets the minigame plugin associated with this {@link MGPlayer}.\n\t *\n\t * @return the minigame plugin associated with this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic String getPlugin() {\n\t\treturn plugin;\n\t}\n\n\t/**\n\t * Gets the MGLib API instance registered by the minigame plugin associated\n\t * with this {@link MGPlayer}.\n\t *\n\t * @return the MGLib API instance registered by the minigame plugin\n\t * associated with this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic Minigame getMinigame() {\n\t\treturn Minigame.getMinigameInstance(plugin);\n\t}\n\n\t/**\n\t * Gets the username of this {@link MGPlayer}.\n\t *\n\t * @return the username of this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t/**\n\t * Gets the arena associated with this {@link MGPlayer}.\n\t *\n\t * @return the arena associated with this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic String getArena() {\n\t\treturn arena;\n\t}\n\n\t/**\n\t * Retrieves the prefix of this player (used on lobby signs).\n\t *\n\t * @return the prefix of this player\n\t * @since 0.1.0\n\t */\n\tpublic String getPrefix() {\n\t\treturn prefix;\n\t}\n\n\t/**\n\t * Retrieves the name of the team this player is on, or null if they are not\n\t * on a team.\n\t *\n\t * @return the name of the team this player is on, or null if they are not\n\t * on a team\n\t * @since 0.3.0\n\t */\n\tpublic String getTeam() {\n\t\treturn team;\n\t}\n\n\t/**\n\t * Sets the name of the team this player is on.\n\t *\n\t * @param team the name of the team this player is on. Set to null for no\n\t *             team.\n\t * @since 0.3.0\n\t */\n\tpublic void setTeam(String team) {\n\t\tthis.team = team;\n\t}\n\n\t/**\n\t * Sets the arena of this {@link MGPlayer}. Please do not call this method\n\t * unless you understand the implications of doing so.\n\t *\n\t * @param arena the new arena of this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic void setArena(String arena) {\n\t\tthis.arena = arena;\n\t}\n\n\t/**\n\t * Gets the {@link Round} associated with this player.\n\t *\n\t * @return the {@link Round} associated with this player\n\t * @since 0.1.0\n\t */\n\tpublic Round getRound() {\n\t\treturn Minigame.getMinigameInstance(plugin).getRound(arena.toLowerCase());\n\t}\n\n\t/**\n\t * Gets whether this player is spectating their round, as opposed to\n\t * participating in it.\n\t *\n\t * @return whether this player is spectating their round (can return true\n\t * even if {@link Player#isDead()} returns false).\n\t * @since 0.1.0\n\t */\n\tpublic boolean isSpectating() {\n\t\treturn spectating;\n\t}\n\n\t/**\n\t * Sets whether this player is spectating or not.\n\t *\n\t * @param spectating whether the player is spectating\n\t * @since 0.1.0\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void setSpectating(boolean spectating) {\n\t\tthis.spectating = spectating;\n\t\tif (spectating) {\n\t\t\tMGPlayerSpectateEvent event = new MGPlayerSpectateEvent(this.getRound(), this);\n\t\t\tMGUtil.callEvent(event);\n\t\t\tif (event.isCancelled()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tfinal Player p = Bukkit.getPlayer(this.getName());\n\t\t\tif (p != null) { // check that player is online\n\t\t\t\tp.closeInventory(); // close any inventory they have open\n\t\t\t\tif (!Main.isVanillaSpectatingDisabled() &&\n\t\t\t\t\t\tthis.getRound().getConfigManager().isUsingVanillaSpectating() &&\n\t\t\t\t\t\tNmsUtil.SPECTATOR_SUPPORT) {\n\t\t\t\t\tp.setGameMode(org.bukkit.GameMode.SPECTATOR);", "context": "src/main/java/net/amigocraft/mglib/exception/PlayerOfflineException.java\npublic class PlayerOfflineException extends Exception {\n\n\tprivate static final long serialVersionUID = 1477050494550899458L;\n\n}\nsrc/main/java/net/amigocraft/mglib/MGUtil.java\npublic class MGUtil {\n\n\tstatic Main plugin;\n\n\t/**\n\t * Returns the {@link JavaPlugin} instance for MGLib.\n\t *\n\t * <p><strong>This should not be called</strong> from a hooking plugin under\n\t * any circumstance.</p>\n\t *\n\t * @return the {@link JavaPlugin} instance for MGLib.\n\t * @since 0.4.0\n\t */\n\tpublic static Main getPlugin() {\n\t\treturn plugin;\n\t}\n\n\t/**\n\t * Loads and returns the given plugin's arenas.yml file.\n\t *\n\t * @param plugin The plugin to load the YAML file from.\n\t * @return The loaded {@link YamlConfiguration} object.\n\t * @since 0.1.0\n\t */\n\tpublic static MGYamlConfiguration loadArenaYaml(String plugin) {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tJavaPlugin jp = Minigame.getMinigameInstance(plugin).getPlugin();\n\t\tFile f = new File(jp.getDataFolder(), \"arenas.yml\");\n\t\ttry {\n\t\t\tif (!jp.getDataFolder().exists()) {\n\t\t\t\tjp.getDataFolder().mkdirs();\n\t\t\t}\n\t\t\tif (!f.exists()) {\n\t\t\t\tf.createNewFile();\n\t\t\t}\n\t\t\tMGYamlConfiguration y = new MGYamlConfiguration();\n\t\t\ty.load(f);\n\t\t\treturn y;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log.severe(\"An exception occurred while loading arena data for plugin \" + plugin);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Saves the given plugin's arenas.yml file.\n\t *\n\t * @param plugin the plugin to save the given {@link YamlConfiguration} to\n\t * @param y      the {@link YamlConfiguration} to save\n\t */\n\tpublic static void saveArenaYaml(String plugin, YamlConfiguration y) {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tJavaPlugin jp = Minigame.getMinigameInstance(plugin).getPlugin();\n\t\tFile f = new File(jp.getDataFolder(), \"arenas.yml\");\n\t\ttry {\n\t\t\tif (!f.exists()) {\n\t\t\t\tf.createNewFile();\n\t\t\t}\n\t\t\ty.save(f);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log.severe(\"An exception occurred while saving arena data for plugin \" + plugin);\n\t\t}\n\t}\n\n\t/**\n\t * Determines whether the provided string can be parsed to an integer.\n\t *\n\t * @param s the string to check\n\t * @return whether the provided string can be parsed to an integer\n\t */\n\tpublic static boolean isInteger(String s) {\n\t\ttry {\n\t\t\tInteger.parseInt(s);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (NumberFormatException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Logs the given message if verbose logging is enabled.\n\t *\n\t * @param message the message to log\n\t * @param prefix  the prefix to place in front of the message. This will\n\t *                automatically be placed within brackets\n\t * @param level   the {@link LogLevel level} at which to log the message\n\t * @since 0.3.0\n\t */\n\tpublic static void log(String message, String prefix, LogLevel level) {\n\t\tif (Main.LOGGING_LEVEL.compareTo(level) >= 0) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"[\").append(level.toString()).append(\"]\");\n\t\t\tif (prefix != null) {\n\t\t\t\tsb.append(\"[\").append(prefix).append(\"]\");\n\t\t\t}\n\t\t\tsb.append(\" \").append(message);\n\t\t\tif (level == LogLevel.SEVERE) {\n\t\t\t\tSystem.err.println(sb.toString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(sb.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Calls an event, but sends it only to the appropriate plugin.\n\t * <strong>Please do not call this from your pluginv unless you are aware of\n\t * the implications.</strong>\n\t *\n\t * @param event the event to call\n\t * @since 0.3.0\n\t */\n\tpublic static void callEvent(MGLibEvent event) {\n\t\tHandlerList hl = event.getHandlers();\n\t\tfor (RegisteredListener rl : hl.getRegisteredListeners()) {\n\t\t\tif (rl.getPlugin().getName().equals(event.getPlugin()) || rl.getPlugin().getName().equals(\"MGLib\")) {\n\t\t\t\ttry {\n\t\t\t\t\trl.callEvent(event);\n\t\t\t\t}\n\t\t\t\tcatch (EventException ex) {\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves the sign attached to a given block, or null if ones does not\n\t * exist.\n\t *\n\t * @param block the block to check for an attached sign\n\t * @return the sign attached to a given block, or null if ones does not\n\t * exist\n\t */\n\tpublic static Block getAttachedSign(Block block) {\n\t\tBlockFace[] faces = new BlockFace[]{\n\t\t\t\tBlockFace.NORTH, BlockFace.SOUTH, BlockFace.EAST, BlockFace.WEST, BlockFace.UP\n\t\t};\n\t\tfor (BlockFace face : faces) {\n\t\t\tBlock adjBlock = block.getRelative(face);\n\t\t\tif (adjBlock.getState() instanceof Sign) {\n\t\t\t\tif (face != BlockFace.UP) {\n\t\t\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\t\t\tbyte data = adjBlock.getData();\n\t\t\t\t\tbyte north = 0x2;\n\t\t\t\t\tbyte south = 0x3;\n\t\t\t\t\tbyte west = 0x4;\n\t\t\t\t\tbyte east = 0x5;\n\t\t\t\t\tBlockFace attached = null;\n\t\t\t\t\tif (data == east) {\n\t\t\t\t\t\tattached = BlockFace.WEST;\n\t\t\t\t\t}\n\t\t\t\t\telse if (data == west) {\n\t\t\t\t\t\tattached = BlockFace.EAST;\n\t\t\t\t\t}\n\t\t\t\t\telse if (data == north) {\n\t\t\t\t\t\tattached = BlockFace.SOUTH;\n\t\t\t\t\t}\n\t\t\t\t\telse if (data == south) {\n\t\t\t\t\t\tattached = BlockFace.NORTH;\n\t\t\t\t\t}\n\t\t\t\t\tif (adjBlock.getType() == Material.SIGN_POST) {\n\t\t\t\t\t\tattached = BlockFace.DOWN;\n\t\t\t\t\t}\n\t\t\t\t\tif (block.getX() == adjBlock.getRelative(attached).getX() &&\n\t\t\t\t\t\t\tblock.getY() == adjBlock.getRelative(attached).getY() &&\n\t\t\t\t\t\t\tblock.getZ() == adjBlock.getRelative(attached).getZ()) {\n\t\t\t\t\t\treturn adjBlock;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determines the environment of the given world based on its folder\n\t * structure.\n\t *\n\t * @param world the name of the world to determine the environment of\n\t * @return the environment of the given world\n\t * @since 0.3.0\n\t */\n\tpublic static Environment getEnvironment(String world) {\n\t\tFile worldFolder = new File(Bukkit.getWorldContainer(), world);\n\t\tif (worldFolder.exists()) {\n\t\t\tfor (File f : worldFolder.listFiles()) {\n\t\t\t\tif (f.getName().equals(\"region\")) {\n\t\t\t\t\treturn Environment.NORMAL;\n\t\t\t\t}\n\t\t\t\telse if (f.getName().equals(\"DIM1\")) {\n\t\t\t\t\treturn Environment.THE_END;\n\t\t\t\t}\n\t\t\t\telse if (f.getName().equals(\"DIM-1\")) {\n\t\t\t\t\treturn Environment.NETHER;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Deletes a folder recursively.\n\t *\n\t * @param folder the folder to delete\n\t * @since 0.3.0\n\t */\n\tpublic static void deleteFolder(File folder) {\n\t\tfor (File f : folder.listFiles()) {\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tdeleteFolder(f);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf.delete();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Throws an {@link UnsupportedOperationException} if MGLib is not\n\t * disabling.\n\t *\n\t * @throws UnsupportedOperationException if MGLib is not currently\n\t *                                       disabling\n\t * @since 0.4.0\n\t */\n\tpublic static void verifyDisablingStatus() throws UnsupportedOperationException {\n\t\tif (!Main.isDisabling()) {\n\t\t\tthrow new UnsupportedOperationException(Main.locale.getMessage(\"plugin.alert.not-disabling\"));\n\t\t}\n\t}\n\n\t/**\n\t * Converts a Bukkit {@link Location} to a {@link Location3D}.\n\t *\n\t * @param location the {@link Location} to convert\n\t * @return the new {@link Location3D}\n\t * @since 0.4.0\n\t */\n\tpublic static Location3D fromBukkitLocation(Location location) {\n\t\treturn fromBukkitLocation(location, false);\n\t}\n\n\t/**\n\t * Converts a Bukkit {@link Location} to a {@link Location3D}.\n\t *\n\t * @param location the {@link Location} to convert\n\t * @param copyOrientation whether the pitch and yaw of <code>location</code>\n\t *                        will be stored in the new {@link Location3D}\n\t *                        (defaults to <code>false</code> if omitted).\n\t * @return the new {@link Location3D}\n\t * @since 0.4.0\n\t */\n\tpublic static Location3D fromBukkitLocation(Location location, boolean copyOrientation) {\n\t\tif (copyOrientation) {\n\t\t\treturn new Location3D(location.getWorld().getName(),\n\t\t\t\t\t(float)location.getX(), (float)location.getY(), (float)location.getZ(),\n\t\t\t\t\tlocation.getPitch(), location.getYaw());\n\t\t}\n\t\telse {\n\t\t\treturn new Location3D(location.getWorld().getName(),\n\t\t\t\t\t(float)location.getX(), (float)location.getY(), (float)location.getZ());\n\t\t}\n\t}\n\n\t/**\n\t * Converts a {@link Location3D} to a Bukkit {@link org.bukkit.Location}.\n\t *\n\t * @param location the {@link Location3D} to convert\n\t *                        (defaults to <code>false</code> if omitted).\n\t * @return the new {@link org.bukkit.Location}\n\t * @since 0.4.0\n\t */\n\tpublic static Location toBukkitLocation(Location3D location) {\n\t\t\treturn new Location(Bukkit.getWorld(location.getWorld()),\n\t\t\t\t\tlocation.getX(), location.getY(), location.getZ(),\n\t\t\t\t\tlocation.getPitch(), location.getYaw());\n\t}\n}\nsrc/main/java/net/amigocraft/mglib/misc/Metadatable.java\npublic interface Metadatable {\n\n\t/**\n\t * Retrieves a given value from this object's metadata by its key.\n\t *\n\t * @param key the key to retrieve.\n\t * @return the key's mapped value, or null if it is not mapped.\n\t * @since 0.3.0\n\t */\n\tpublic Object getMetadata(String key);\n\n\t/**\n\t * Adds a key-value pair to this object's metadata.\n\t *\n\t * <p><strong>Note:</strong> This method consists of a single call to\n\t * {@link HashMap#put(Object, Object)}, so existing keys will be overwritten.</p>\n\t *\n\t * @param key   the key to store in the round's metadata.\n\t * @param value the value to assign to the given key.\n\t * @since 0.3.0\n\t */\n\tpublic void setMetadata(String key, Object value);\n\n\t/**\n\t * Removes the given key from this object's metadata.\n\t *\n\t * @param key the key to remove from this object's metadata.\n\t * @since 0.3.0\n\t */\n\tpublic void removeMetadata(String key);\n\n\t/**\n\t * Checks whether a given key is present in this object's metadata.\n\t *\n\t * @param key the key to test for.\n\t * @return whether the key is present in this object's metadata.\n\t * @since 0.3.0\n\t */\n\tpublic boolean hasMetadata(String key);\n\n\t/**\n\t * Retrieves a {@link HashMap} representing this object's complete metadata.\n\t *\n\t * @return this object's metadata in the form of a {@link HashMap}.\n\t * @since 0.3.0\n\t */\n\tpublic HashMap<String, Object> getAllMetadata();\n\n}\nsrc/main/java/net/amigocraft/mglib/misc/JoinResult.java\npublic enum JoinResult {\n\n\tSUCCESS,\n\tROUND_FULL, // not used, RoundFullException thrown instead\n\tROUND_PREPARING,\n\tROUND_PLAYING,\n\tINVENTORY_SAVE_ERROR,\n\tCANCELLED,\n\tINTERNAL_ERROR\n\n}\nsrc/main/java/net/amigocraft/mglib/util/NmsUtil.java\npublic class NmsUtil {\n\n\tprivate static final String VERSION_STRING;\n\tprivate static final boolean NMS_SUPPORT;\n\tpublic static final boolean SPECTATOR_SUPPORT;\n\n\t// general classes for sending packets\n\tpublic static Method craftPlayer_getHandle;\n\tpublic static Field playerConnection;\n\tpublic static Method playerConnection_sendPacket;\n\tpublic static Method playerConnection_a_packetPlayInClientCommand;\n\n\t// for respawning players automatically\n\tpublic static Object clientCommandPacketInstance;\n\n\tprivate static Method getOnlinePlayers;\n\tpublic static boolean newOnlinePlayersMethod = false;\n\n\tstatic {\n\t\tboolean ss;\n\t\ttry {\n\t\t\tGameMode.valueOf(\"SPECTATOR\");\n\t\t\tss = true;\n\t\t} catch (IllegalArgumentException ex) {\n\t\t\tss = false;\n\t\t}\n\t\tSPECTATOR_SUPPORT = ss;\n\t\tboolean nmsException = false;\n\t\tString[] array = Bukkit.getServer().getClass().getPackage().getName().split(\"\\\\.\");\n\t\tVERSION_STRING = array.length == 4 ? array[3] + \".\" : \"\";\n\t\ttry {\n\t\t\tgetOnlinePlayers = Bukkit.class.getMethod(\"getOnlinePlayers\");\n\t\t\tif (getOnlinePlayers.getReturnType() == Collection.class) {\n\t\t\t\tnewOnlinePlayersMethod = true;\n\t\t\t}\n\n\t\t\t// get method for recieving CraftPlayer's EntityPlayer\n\t\t\tcraftPlayer_getHandle = getCraftClass(\"entity.CraftPlayer\").getMethod(\"getHandle\");\n\t\t\t// get the PlayerConnection of the EntityPlayer\n\t\t\tplayerConnection = getNmsClass(\"EntityPlayer\").getDeclaredField(\"playerConnection\");\n\t\t\t// method to send the packet\n\t\t\tplayerConnection_sendPacket = getNmsClass(\"PlayerConnection\").getMethod(\"sendPacket\", getNmsClass(\"Packet\"));\n\t\t\tplayerConnection_a_packetPlayInClientCommand = getNmsClass(\"PlayerConnection\")\n\t\t\t\t\t.getMethod(\"a\", getNmsClass(\"PacketPlayInClientCommand\"));\n\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tClass<? extends Enum> enumClass;\n\t\t\t\t\tObject performRespawn;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// this changed at some point in 1.8 to an inner class; I don't really care to figure out exactly when\n\t\t\t\t\t\tenumClass = (Class<? extends Enum>)getNmsClass(\"PacketPlayInClientCommand$EnumClientCommand\");\n\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\t// older 1.8 builds/1.7\n\t\t\t\t\t\tenumClass = (Class<? extends Enum>)getNmsClass(\"EnumClientCommand\");\n\t\t\t\t\t}\n\t\t\t\t\tperformRespawn = Enum.valueOf(\n\t\t\t\t\t\t\tenumClass, \"PERFORM_RESPAWN\"\n\t\t\t\t\t);\n\t\t\t\t\tclientCommandPacketInstance = getNmsClass(\"PacketPlayInClientCommand\")\n\t\t\t\t\t\t\t.getConstructor(performRespawn.getClass())\n\t\t\t\t\t\t\t.newInstance(performRespawn);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\tclientCommandPacketInstance = getNmsClass(\"Packet205ClientCommand\").getConstructor().newInstance();\n\t\t\t\t\tclientCommandPacketInstance.getClass().getDeclaredField(\"a\").set(clientCommandPacketInstance, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t\tMain.log(Main.locale.getMessage(\"plugin.alert.nms.client-command\"), LogLevel.WARNING);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log(Main.locale.getMessage(\"plugin.alert.nms.fail\"), LogLevel.WARNING);\n\t\t\tnmsException = true;\n\t\t}\n\n\t\tNMS_SUPPORT = !nmsException;\n\t}\n\n\t/**\n\t * Retrieves a class by the given name from the package\n\t * <code>net.minecraft.server</code>.\n\t *\n\t * @param name the class to retrieve\n\t * @return the class object from the package\n\t * <code>net.minecraft.server</code>\n\t * @throws ClassNotFoundException if the class does not exist in the\n\t * package\n\t */\n\tpublic static Class<?> getNmsClass(String name) throws ClassNotFoundException {\n\t\tString className = \"net.minecraft.server.\" + VERSION_STRING + name;\n\t\treturn Class.forName(className);\n\t}\n\n\t/**\n\t * Retrieves a class by the given name from the package\n\t * <code>org.bukkit.craftbukkit</code>.\n\t *\n\t * @param name the class to retrieve\n\t * @return the class object from the package\n\t * <code>org.bukkit.craftbukkit</code>\n\t * @throws ClassNotFoundException if the class does not exist in the\n\t * package\n\t */\n\tpublic static Class<?> getCraftClass(String name) throws ClassNotFoundException {\n\t\tString className = \"org.bukkit.craftbukkit.\" + VERSION_STRING + name;\n\t\treturn Class.forName(className);\n\t}\n\n\t/**\n\t * Sends a PlayInClientCommand packet to the given player.\n\t *\n\t * @param player the {@link Player} to send the packet to\n\t * @throws Exception if an exception occurs while sending the packet\n\t */\n\tpublic static void sendRespawnPacket(Player player) throws Exception {\n\t\tif (NMS_SUPPORT) {\n\t\t\tObject nmsPlayer = NmsUtil.craftPlayer_getHandle.invoke(player);\n\t\t\tObject conn = NmsUtil.playerConnection.get(nmsPlayer);\n\t\t\tNmsUtil.playerConnection_a_packetPlayInClientCommand.invoke(conn, NmsUtil.clientCommandPacketInstance);\n\t\t}\n\t}\n\n\t/**\n\t * Version-independent getOnlinePlayers() method.\n\t *\n\t * @return a list of online players\n\t * @since 0.4.0\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static Collection<? extends Player> getOnlinePlayers() {\n\t\ttry {\n\t\t\tif (newOnlinePlayersMethod) {\n\t\t\t\treturn (Collection<? extends Player>)getOnlinePlayers.invoke(null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Arrays.asList((Player[])getOnlinePlayers.invoke(null));\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log(Main.locale.getMessage(\"plugin.alert.nms.online-players\"), LogLevel.SEVERE);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log(Main.locale.getMessage(\"plugin.alert.nms.online-players\"), LogLevel.SEVERE);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Unsets all static objects in this class.\n\t *\n\t * @throws UnsupportedOperationException if MGLib is not currently disabling\n\t *\n\t * @since 0.4.0\n\t */\n\tpublic static void uninitialize() {\n\t\tMGUtil.verifyDisablingStatus();\n\t\tcraftPlayer_getHandle = null;\n\t\tplayerConnection = null;\n\t\tplayerConnection_sendPacket = null;\n\t}\n}\nsrc/main/java/net/amigocraft/mglib/Main.java\npublic static Locale locale;\nsrc/main/java/net/amigocraft/mglib/exception/NoSuchPlayerException.java\npublic class NoSuchPlayerException extends Exception {\n\n\tprivate static final long serialVersionUID = 2117053927855770796L;\n\n}\nsrc/main/java/net/amigocraft/mglib/event/player/MGPlayerSpectateEvent.java\npublic class MGPlayerSpectateEvent extends MGPlayerEvent implements Cancellable {\n\n\tprotected Round round;\n\tprivate boolean cancelled;\n\n\t/**\n\t * Creates a new instance of this event.\n\t *\n\t * @param round  the round the player has joined\n\t * @param player the player involved in this event\n\t * @since 0.2.0\n\t */\n\tpublic MGPlayerSpectateEvent(Round round, MGPlayer player) {\n\t\tsuper(player);\n\t\tthis.round = round;\n\t}\n\n\t/**\n\t * Returns the {@link Round round} involved in this event.\n\t *\n\t * @return the {@link Round round} involved in this event\n\t * @since 0.2.0\n\t */\n\tpublic Round getRound() {\n\t\treturn round;\n\t}\n\n\t@Override\n\tpublic boolean isCancelled() {\n\t\treturn this.cancelled;\n\t}\n\n\t@Override\n\tpublic void setCancelled(boolean cancel) {\n\t\tthis.cancelled = cancel;\n\t}\n\n}\nsrc/main/java/net/amigocraft/mglib/exception/RoundFullException.java\npublic class RoundFullException extends Exception {\n\n\tprivate static final long serialVersionUID = -4824489285215148872L;\n\n}\nsrc/main/java/net/amigocraft/mglib/UUIDFetcher.java\npublic class UUIDFetcher implements Callable<Map<String, UUID>> {\n\n\tstatic HashMap<String, UUID> uuids = new HashMap<String, UUID>();\n\n\tprivate static final double PROFILES_PER_REQUEST = 100;\n\tprivate static final String PROFILE_URL = \"https://api.mojang.com/profiles/minecraft\";\n\tprivate final JSONParser jsonParser = new JSONParser();\n\tprivate final List<String> names;\n\tprivate final boolean rateLimiting;\n\n\tpublic UUIDFetcher(List<String> names, boolean rateLimiting) {\n\t\tthis.names = ImmutableList.copyOf(names);\n\t\tthis.rateLimiting = rateLimiting;\n\t}\n\n\tpublic UUIDFetcher(List<String> names) {\n\t\tthis(names, true);\n\t}\n\n\tpublic Map<String, UUID> call() throws Exception {\n\t\tMap<String, UUID> uuidMap = new HashMap<String, UUID>();\n\t\tint requests = (int)Math.ceil(names.size() / PROFILES_PER_REQUEST);\n\t\tfor (int i = 0; i < requests; i++) {\n\t\t\tHttpURLConnection connection = createConnection();\n\t\t\tString body = JSONArray.toJSONString(names.subList(i * 100, Math.min((i + 1) * 100, names.size())));\n\t\t\twriteBody(connection, body);\n\t\t\tJSONArray array = (JSONArray)jsonParser.parse(new InputStreamReader(connection.getInputStream()));\n\t\t\tfor (Object profile : array) {\n\t\t\t\tJSONObject jsonProfile = (JSONObject)profile;\n\t\t\t\tString id = (String)jsonProfile.get(\"id\");\n\t\t\t\tString name = (String)jsonProfile.get(\"name\");\n\t\t\t\tUUID uuid = UUIDFetcher.getUUID(id);\n\t\t\t\tuuidMap.put(name, uuid);\n\t\t\t}\n\t\t\tif (rateLimiting && i != requests - 1) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\t\t}\n\t\tuuids.putAll(uuidMap);\n\t\treturn uuidMap;\n\t}\n\n\tprivate static void writeBody(HttpURLConnection connection, String body) throws Exception {\n\t\tOutputStream stream = connection.getOutputStream();\n\t\tstream.write(body.getBytes());\n\t\tstream.flush();\n\t\tstream.close();\n\t}\n\n\tprivate static HttpURLConnection createConnection() throws Exception {\n\t\tURL url = new URL(PROFILE_URL);\n\t\tHttpURLConnection connection = (HttpURLConnection)url.openConnection();\n\t\tconnection.setRequestMethod(\"POST\");\n\t\tconnection.setRequestProperty(\"Content-Type\", \"application/json\");\n\t\tconnection.setUseCaches(false);\n\t\tconnection.setDoInput(true);\n\t\tconnection.setDoOutput(true);\n\t\treturn connection;\n\t}\n\n\tprivate static UUID getUUID(String id) {\n\t\treturn UUID.fromString(id.substring(0, 8) + \"-\" + id.substring(8, 12) + \"-\" + id.substring(12, 16) + \"-\" +\n\t\t\t\tid.substring(16, 20) + \"-\" + id.substring(20, 32));\n\t}\n\n\tpublic static byte[] toBytes(UUID uuid) {\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(new byte[16]);\n\t\tbyteBuffer.putLong(uuid.getMostSignificantBits());\n\t\tbyteBuffer.putLong(uuid.getLeastSignificantBits());\n\t\treturn byteBuffer.array();\n\t}\n\n\tpublic static UUID fromBytes(byte[] array) {\n\t\tif (array.length != 16) {\n\t\t\tthrow new IllegalArgumentException(\"Illegal byte array length: \" + array.length);\n\t\t}\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(array);\n\t\tlong mostSignificant = byteBuffer.getLong();\n\t\tlong leastSignificant = byteBuffer.getLong();\n\t\treturn new UUID(mostSignificant, leastSignificant);\n\t}\n\n\tpublic static UUID getUUIDOf(String name) throws Exception {\n\t\tif (uuids.containsKey(name)) {\n\t\t\treturn uuids.get(name);\n\t\t}\n\t\tUUID uuid = new UUIDFetcher(Arrays.asList(name)).call().get(name);\n\t\tUUIDFetcher.addUUID(name, uuid);\n\t\treturn uuid;\n\t}\n\n\tpublic static void addUUID(String name, UUID uuid) {\n\t\tuuids.put(name, uuid);\n\t}\n\n\tpublic static void removeUUID(String name) {\n\t\tuuids.remove(name);\n\t}\n\n\tpublic static void uninitialize() {\n\t\tMGUtil.verifyDisablingStatus();\n\t\tuuids.clear();\n\t\tuuids = null;\n\t}\n}\nsrc/main/java/net/amigocraft/mglib/Main.java\npublic class Main extends JavaPlugin {\n\n\t/**\n\t * MGLib's logger.\n\t *\n\t * <p><strong>This is for use within the library; please do not use this in\n\t * your plugin or you'll confuse the server owner.</strong></p>\n\t *\n\t * @since 0.1.0\n\t */\n\tpublic static Logger log;\n\n\t/**\n\t * Whether block changes should be logged immediately.\n\t */\n\tpublic static boolean IMMEDIATE_LOGGING;\n\n\t/**\n\t * The minimum level at which messages should be logged.\n\t */\n\tpublic static LogLevel LOGGING_LEVEL;\n\n\t/**\n\t * Whether vanilla spectating is globally disabled.\n\t */\n\tprivate static boolean VANILLA_SPECTATING_DISABLED;\n\n\t/**\n\t * The locale for MGLib itself.\n\t */\n\tpublic static Locale locale;\n\n\tprivate static boolean disabling = false;\n\n\t/**\n\t * Standard {@link JavaPlugin#onEnable()} override.\n\t *\n\t * @since 0.1.0\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void onEnable() {\n\n\t\tMGUtil.plugin = this;\n\t\tlog = getLogger();\n\t\tBukkit.getPluginManager().registerEvents(new MGListener(), this);\n\t\tsaveDefaultConfig();\n\t\tIMMEDIATE_LOGGING = getConfig().getBoolean(\"immediate-logging\");\n\t\tLOGGING_LEVEL = LogLevel.valueOf(getConfig().getString(\"logging-level\").toUpperCase());\n\t\tif (LOGGING_LEVEL == null) {\n\t\t\tLOGGING_LEVEL = LogLevel.WARNING;\n\t\t\tMain.log(\"The configured logging level is invalid!\", LogLevel.WARNING);\n\t\t}\n\t\tVANILLA_SPECTATING_DISABLED = getConfig().getBoolean(\"disable-vanilla-spectating\");\n\n\t\tlocale = new Locale(\"MGLib\");\n\t\tlocale.initialize();\n\n\t\t// updater\n\t\tif (getConfig().getBoolean(\"enable-updater\")) {\n\t\t\tnew Updater(this, 74979, this.getFile(), Updater.UpdateType.DEFAULT, true);\n\t\t}\n\n\t\t// submit metrics\n\t\tif (getConfig().getBoolean(\"enable-metrics\")) {\n\t\t\ttry {\n\t\t\t\tMetrics metrics = new Metrics(this);\n\t\t\t\tmetrics.start();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tlog.warning(locale.getMessage(\"plugin.alert.metrics-fail\"));\n\t\t\t}\n\t\t}\n\t\tif (this.getDescription().getVersion().contains(\"dev\")) {\n\t\t\tlog.warning(locale.getMessage(\"plugin.alert.dev-build\"));\n\t\t}\n\n\t\t// store UUIDs of online players\n\t\tList<String> names = new ArrayList<String>();\n\t\tfor (Player pl : NmsUtil.getOnlinePlayers()) {\n\t\t\tnames.add(pl.getName());\n\t\t}\n\t\ttry {\n\t\t\tnew UUIDFetcher(names).call();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log.severe(locale.getMessage(\"plugin.alert.uuid-fail\"));\n\t\t}\n\n\t\tlog.info(locale.getMessage(\"plugin.event.enable\", this.toString()));\n\t}\n\n\t/**\n\t * Standard {@link JavaPlugin#onDisable()} override.\n\t *\n\t * @since 0.1.0\n\t */\n\t@Override\n\tpublic void onDisable() {\n\t\tdisabling = true;\n\t\tBukkit.broadcastMessage(ChatColor.DARK_PURPLE + \"[MGLib] \" + locale.getMessage(\"plugin.event.restart\"));\n\t\tfor (Minigame mg : Minigame.getMinigameInstances()) {\n\t\t\tfor (Round r : mg.getRoundList()) {\n\t\t\t\tr.end(false);\n\t\t\t}\n\t\t}\n\t\tMinigame.uninitialize();\n\t\tMGLibEvent.uninitialize();\n\t\tNmsUtil.uninitialize();\n\t\tUUIDFetcher.uninitialize();\n\t\tlog.info(locale.getMessage(\"plugin.event.disable\", this.toString()));\n\t\tMain.uninitialize();\n\t}\n\n\t/**\n\t * <p>This method should not be called from your plugin. So don't use it.\n\t * Please.</p>\n\t *\n\t * @param plugin the name of the plugin to register worlds for\n\t */\n\tpublic static void registerWorlds(String plugin) {\n\t\tMGListener.addWorlds(plugin);\n\t}\n\n\tprivate static void uninitialize() {\n\t\tlog = null;\n\t\tMGUtil.plugin = null;\n\t}\n\n\t/**\n\t * Internal convenience method for logging. <strong>Please do not call this\n\t * from your plugin.</strong>\n\t *\n\t * @param message the message to log.\n\t * @param level   the {@link LogLevel level} at which to log the message\n\t * @since 0.3.0\n\t */\n\tpublic static void log(String message, LogLevel level) {\n\t\tMGUtil.log(message, \"MGLib\", level);\n\t}\n\n\t@Override\n\tpublic boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n\t\tif (label.equalsIgnoreCase(\"mglib\")) {\n\t\t\tsender.sendMessage(ChatColor.LIGHT_PURPLE +\n\t\t\t\t\tlocale.getMessage(\"plugin.event.info\", getDescription().getVersion(), \"Maxim Roncacé\"));\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Retrieves worlds registered with MGLib's event listener for the given\n\t * plugin.\n\t *\n\t * @param plugin the plugin to retrieve worlds for\n\t * @return worlds registered with MGLib's event listener for the given\n\t * plugin\n\t * @since 0.4.0\n\t */\n\tpublic static List<String> getWorlds(String plugin) {\n\t\treturn MGListener.getWorlds();\n\t}\n\n\t/**\n\t * Retrieves a hashmap mapping the names of online players to their\n\t * respective UUIDs.\n\t *\n\t * @return a hashmap mapping the names of online players to their\n\t * respective UUIDs\n\t * @since 0.3.0\n\t */\n\tpublic static HashMap<String, UUID> getOnlineUUIDs() {\n\t\treturn UUIDFetcher.uuids;\n\t}\n\n\t/**\n\t * Retrieves whether vanilla spectating has been globally disabled by\n\t * MGLib's config.yml file.\n\t *\n\t * @return whether vanilla spectating has been globally disabled by MGLib's\n\t * config.yml file\n\t * @since 0.3.0\n\t */\n\tpublic static boolean isVanillaSpectatingDisabled() {\n\t\treturn VANILLA_SPECTATING_DISABLED;\n\t}\n\n\t/**\n\t * Determines whether MGLib is in the process of disabling.\n\t * This is to provide security when unsetting static objects.\n\t *\n\t * @return whether MGLib is in the process of disabling.\n\t * @since 0.4.0\n\t */\n\tpublic static boolean isDisabling() {\n\t\treturn disabling;\n\t}\n\n}\nsrc/main/java/net/amigocraft/mglib/exception/PlayerPresentException.java\npublic class PlayerPresentException extends Exception {\n\n\tprivate static final long serialVersionUID = -5109025861934945989L;\n\n}\n", "answers": ["\t\t\t\t\tp.sendMessage(ChatColor.DARK_PURPLE + Main.locale.getMessage(\"info.personal.spectating\")); // tell them"], "length": 3710, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "0e17116b140929a4283790fafcf855b10b0dc27fd76c6c21"}
{"input": "import numpy as np\nfrom scipy.optimize import minimize_scalar\nfrom copy import deepcopy\nfrom HARK.frame import Frame, FrameAgentType\nfrom HARK.ConsumptionSaving.ConsPortfolioModel import (\n    init_portfolio,\n    PortfolioConsumerType,\n)\nfrom HARK.distribution import combine_indep_dstns, add_discrete_outcome_constant_mean\nfrom HARK.distribution import (\n    IndexDistribution,\n    Lognormal,\n    MeanOneLogNormal,\n    Bernoulli  # Random draws for simulating agents\n)\nfrom HARK.utilities import (\n    CRRAutility,\n)\n\"\"\"\nThis file contains classes and functions for representing,\nsolving, and simulating agents who must allocate their resources\namong consumption, saving in a risk-free asset (with a low return),\nand saving in a risky asset (with higher average return).\n\nThis file also demonstrates a \"frame\" model architecture.\n\"\"\"\n\n\n", "context": "HARK/distribution.py\nclass MeanOneLogNormal(Lognormal):\n    def __init__(self, sigma=1.0, seed=0):\n        mu = -0.5 * sigma ** 2\n        super().__init__(mu=mu, sigma=sigma, seed=seed)\nHARK/distribution.py\ndef combine_indep_dstns(*distributions, seed=0):\n    \"\"\"\n    Given n lists (or tuples) whose elements represent n independent, discrete\n    probability spaces (probabilities and values), construct a joint pmf over\n    all combinations of these independent points.  Can take multivariate discrete\n    distributions as inputs.\n\n    Parameters\n    ----------\n    distributions : [np.array]\n        Arbitrary number of distributions (pmfs).  Each pmf is a list or tuple.\n        For each pmf, the first vector is probabilities and all subsequent vectors\n        are values.  For each pmf, this should be true:\n        len(X_pmf[0]) == len(X_pmf[j]) for j in range(1,len(distributions))\n\n    Returns\n    -------\n    A DiscreteDistribution, consisting of:\n\n    P_out: np.array\n        Probability associated with each point in X_out.\n\n    X_out: np.array (as many as in *distributions)\n        Discrete points for the joint discrete probability mass function.\n    \"\"\"\n    # Get information on the distributions\n    dist_lengths = ()\n    dist_dims = ()\n    for dist in distributions:\n        dist_lengths += (len(dist.pmf),)\n        dist_dims += (dist.dim(),)\n    number_of_distributions = len(distributions)\n\n    # Initialize lists we will use\n    X_out = []\n    P_temp = []\n\n    # Now loop through the distributions, tiling and flattening as necessary.\n    for dd, dist in enumerate(distributions):\n\n        # The shape we want before we tile\n        dist_newshape = (\n            (1,) * dd + (len(dist.pmf),) + (1,) * (number_of_distributions - dd)\n        )\n\n        # The tiling we want to do\n        dist_tiles = dist_lengths[:dd] + (1,) + dist_lengths[dd + 1 :]\n\n        # Now we are ready to tile.\n        # We don't use the np.meshgrid commands, because they do not\n        # easily support non-symmetric grids.\n\n        # First deal with probabilities\n        Pmesh = np.tile(dist.pmf.reshape(dist_newshape), dist_tiles)  # Tiling\n        flatP = Pmesh.ravel()  # Flatten the tiled arrays\n        P_temp += [\n            flatP,\n        ]  # Add the flattened arrays to the output lists\n\n        # Then loop through each value variable\n        for n in range(dist_dims[dd]):\n            if dist.dim() > 1:\n                Xmesh = np.tile(dist.X[n].reshape(dist_newshape), dist_tiles)\n            else:\n                Xmesh = np.tile(dist.X.reshape(dist_newshape), dist_tiles)\n            flatX = Xmesh.ravel()\n            X_out += [\n                flatX,\n            ]\n\n    # We're done getting the flattened X_out arrays we wanted.\n    # However, we have a bunch of flattened P_temp arrays, and just want one\n    # probability array. So get the probability array, P_out, here.\n    P_out = np.prod(np.array(P_temp), axis=0)\n\n    assert np.isclose(np.sum(P_out), 1), \"Probabilities do not sum to 1!\"\n    return DiscreteDistribution(P_out, X_out, seed=seed)\nHARK/distribution.py\nclass Lognormal(Distribution):\n    \"\"\"\n    A Lognormal distribution\n\n    Parameters\n    ----------\n    mu : float or [float]\n        One or more means of underlying normal distribution.\n        Number of elements T in mu determines number of rows of output.\n    sigma : float or [float]\n        One or more standard deviations of underlying normal distribution.\n        Number of elements T in sigma determines number of rows of output.\n    seed : int\n        Seed for random number generator.\n    \"\"\"\n\n    mu = None\n    sigma = None\n\n    def __init__(self, mu=0.0, sigma=1.0, seed=0):\n        self.mu = np.array(mu)\n        self.sigma = np.array(sigma)\n        # Set up the RNG\n        super().__init__(seed)\n\n        if self.mu.size != self.sigma.size:\n            raise Exception(\n                \"mu and sigma must be of same size, are %s, %s\"\n                % ((self.mu.size), (self.sigma.size))\n            )\n\n    def draw(self, N):\n        \"\"\"\n        Generate arrays of lognormal draws. The sigma parameter can be a number\n        or list-like.  If a number, output is a length N array of draws from the\n        lognormal distribution with standard deviation sigma. If a list, output is\n        a length T list whose t-th entry is a length N array of draws from the\n        lognormal with standard deviation sigma[t].\n\n        Parameters\n        ----------\n        N : int\n            Number of draws in each row.\n\n        Returns:\n        ------------\n        draws : np.array or [np.array]\n            T-length list of arrays of mean one lognormal draws each of size N, or\n            a single array of size N (if sigma is a scalar).\n        \"\"\"\n\n        draws = []\n        for j in range(self.mu.size):\n            draws.append(\n                self.RNG.lognormal(\n                    mean=self.mu.item(j), sigma=self.sigma.item(j), size=N\n                )\n            )\n        # TODO: change return type to np.array?\n        return draws[0] if len(draws) == 1 else draws\n\n    def approx(self, N, tail_N=0, tail_bound=None, tail_order=np.e):\n        \"\"\"\n        Construct a discrete approximation to a lognormal distribution with underlying\n        normal distribution N(mu,sigma).  Makes an equiprobable distribution by\n        default, but user can optionally request augmented tails with exponentially\n        sized point masses.  This can improve solution accuracy in some models.\n\n        Parameters\n        ----------\n        N: int\n            Number of discrete points in the \"main part\" of the approximation.\n        tail_N: int\n            Number of points in each \"tail part\" of the approximation; 0 = no tail.\n        tail_bound: [float]\n            CDF boundaries of the tails vs main portion; tail_bound[0] is the lower\n            tail bound, tail_bound[1] is the upper tail bound.  Inoperative when\n            tail_N = 0.  Can make \"one tailed\" approximations with 0.0 or 1.0.\n        tail_order: float\n            Factor by which consecutive point masses in a \"tail part\" differ in\n            probability.  Should be >= 1 for sensible spacing.\n\n        Returns\n        -------\n        d : DiscreteDistribution\n            Probability associated with each point in array of discrete\n            points for discrete probability mass function.\n        \"\"\"\n        tail_bound = tail_bound if tail_bound is not None else [0.02, 0.98]\n        # Find the CDF boundaries of each segment\n        if self.sigma > 0.0:\n            if tail_N > 0:\n                lo_cut = tail_bound[0]\n                hi_cut = tail_bound[1]\n            else:\n                lo_cut = 0.0\n                hi_cut = 1.0\n            inner_size = hi_cut - lo_cut\n            inner_CDF_vals = [\n                lo_cut + x * N ** (-1.0) * inner_size for x in range(1, N)\n            ]\n            if inner_size < 1.0:\n                scale = 1.0 / tail_order\n                mag = (1.0 - scale ** tail_N) / (1.0 - scale)\n            lower_CDF_vals = [0.0]\n            if lo_cut > 0.0:\n                for x in range(tail_N - 1, -1, -1):\n                    lower_CDF_vals.append(\n                        lower_CDF_vals[-1] + lo_cut * scale ** x / mag\n                    )\n            upper_CDF_vals = [hi_cut]\n            if hi_cut < 1.0:\n                for x in range(tail_N):\n                    upper_CDF_vals.append(\n                        upper_CDF_vals[-1] + (1.0 - hi_cut) * scale ** x / mag\n                    )\n            CDF_vals = lower_CDF_vals + inner_CDF_vals + upper_CDF_vals\n            temp_cutoffs = list(\n                stats.lognorm.ppf(\n                    CDF_vals[1:-1], s=self.sigma, loc=0, scale=np.exp(self.mu)\n                )\n            )\n            cutoffs = [0] + temp_cutoffs + [np.inf]\n            CDF_vals = np.array(CDF_vals)\n\n            K = CDF_vals.size - 1  # number of points in approximation\n            pmf = CDF_vals[1 : (K + 1)] - CDF_vals[0:K]\n            X = np.zeros(K)\n            for i in range(K):\n                zBot = cutoffs[i]\n                zTop = cutoffs[i + 1]\n                # Manual check to avoid the RuntimeWarning generated by \"divide by zero\"\n                # with np.log(zBot).\n                if zBot == 0:\n                    tempBot = np.inf\n                else:\n                    tempBot = (self.mu + self.sigma ** 2 - np.log(zBot)) / (\n                        np.sqrt(2) * self.sigma\n                    )\n                tempTop = (self.mu + self.sigma ** 2 - np.log(zTop)) / (\n                    np.sqrt(2) * self.sigma\n                )\n                if tempBot <= 4:\n                    X[i] = (\n                        -0.5\n                        * np.exp(self.mu + (self.sigma ** 2) * 0.5)\n                        * (erf(tempTop) - erf(tempBot))\n                        / pmf[i]\n                    )\n                else:\n                    X[i] = (\n                        -0.5\n                        * np.exp(self.mu + (self.sigma ** 2) * 0.5)\n                        * (erfc(tempBot) - erfc(tempTop))\n                        / pmf[i]\n                    )\n\n        else:\n            pmf = np.ones(N) / N\n            X = np.exp(self.mu) * np.ones(N)\n        return DiscreteDistribution(\n            pmf, X, seed=self.RNG.randint(0, 2 ** 31 - 1, dtype=\"int32\")\n        )\n\n    @classmethod\n    def from_mean_std(cls, mean, std, seed=0):\n        \"\"\"\n        Construct a LogNormal distribution from its\n        mean and standard deviation.\n\n        This is unlike the normal constructor for the distribution,\n        which takes the mu and sigma for the normal distribution\n        that is the logarithm of the Log Normal distribution.\n\n        Parameters\n        ----------\n        mean : float or [float]\n            One or more means.  Number of elements T in mu determines number\n            of rows of output.\n        std : float or [float]\n            One or more standard deviations. Number of elements T in sigma\n            determines number of rows of output.\n        seed : int\n            Seed for random number generator.\n\n        Returns\n        ---------\n        LogNormal\n\n        \"\"\"\n        mean_squared = mean ** 2\n        variance = std ** 2\n        mu = np.log(mean / (np.sqrt(1.0 + variance / mean_squared)))\n        sigma = np.sqrt(np.log(1.0 + variance / mean_squared))\n\n        return cls(mu=mu, sigma=sigma, seed=seed)\nHARK/distribution.py\ndef add_discrete_outcome_constant_mean(distribution, x, p, sort=False):\n    \"\"\"\n    Adds a discrete outcome of x with probability p to an existing distribution,\n    holding constant the relative probabilities of other outcomes and overall mean.\n\n    Parameters\n    ----------\n    distribution : DiscreteDistribution\n        A DiscreteDistribution\n    x : float\n        The new value to be added to the distribution.\n    p : float\n        The probability of the discrete outcome x occuring.\n    sort: bool\n        Whether or not to sort X before returning it\n\n    Returns\n    -------\n    d : DiscreteDistribution\n        Probability associated with each point in array of discrete\n        points for discrete probability mass function.\n    \"\"\"\n\n    if type(distribution) != TimeVaryingDiscreteDistribution:\n        X = np.append(x, distribution.X * (1 - p * x) / (1 - p))\n        pmf = np.append(p, distribution.pmf * (1 - p))\n\n        if sort:\n            indices = np.argsort(X)\n            X = X[indices]\n            pmf = pmf[indices]\n\n        return DiscreteDistribution(pmf, X)\n    elif type(distribution) == TimeVaryingDiscreteDistribution:\n        # apply recursively on all the internal distributions\n        return TimeVaryingDiscreteDistribution(\n            [\n                add_discrete_outcome_constant_mean(d, x, p)\n                for d in distribution.distributions\n            ],\n            seed=distribution.seed,\n        )\nHARK/utilities.py\ndef CRRAutility(c, gam):\n    \"\"\"\n    Evaluates constant relative risk aversion (CRRA) utility of consumption c\n    given risk aversion parameter gam.\n\n    Parameters\n    ----------\n    c : float\n        Consumption value\n    gam : float\n        Risk aversion\n\n    Returns\n    -------\n    (unnamed) : float\n        Utility\n\n    Tests\n    -----\n    Test a value which should pass:\n    >>> c, gamma = 1.0, 2.0    # Set two values at once with Python syntax\n    >>> utility(c=c, gam=gamma)\n    -1.0\n    \"\"\"\n    \n    if gam == 1:\n        return np.log(c)\n    else:\n        return c ** (1.0 - gam) / (1.0 - gam)\nHARK/ConsumptionSaving/ConsPortfolioModel.py\nclass PortfolioSolution(MetricObject):\nclass PortfolioConsumerType(RiskyAssetConsumerType):\nclass SequentialPortfolioConsumerType(PortfolioConsumerType):\nclass ConsPortfolioSolver(MetricObject):\nclass ConsPortfolioDiscreteSolver(ConsPortfolioSolver):\nclass ConsPortfolioJointDistSolver(ConsPortfolioDiscreteSolver, ConsPortfolioSolver):\nclass ConsSequentialPortfolioSolver(ConsPortfolioSolver):\n    def __init__(\n        self,\n        cFuncAdj=None,\n        ShareFuncAdj=None,\n        vFuncAdj=None,\n        vPfuncAdj=None,\n        cFuncFxd=None,\n        ShareFuncFxd=None,\n        vFuncFxd=None,\n        dvdmFuncFxd=None,\n        dvdsFuncFxd=None,\n        aGrid=None,\n        Share_adj=None,\n        EndOfPrddvda_adj=None,\n        ShareGrid=None,\n        EndOfPrddvda_fxd=None,\n        EndOfPrddvds_fxd=None,\n        AdjPrb=None,\n    ):\n    def __init__(self, verbose=False, quiet=False, **kwds):\n    def pre_solve(self):\n    def update(self):\n    def update_solution_terminal(self):\n    def update_ShareGrid(self):\n    def update_ShareLimit(self):\n    def get_Rfree(self):\n    def initialize_sim(self):\n    def sim_birth(self, which_agents):\n    def get_controls(self):\n    def __init__(self, verbose=False, quiet=False, **kwds):\n    def __init__(\n        self,\n        solution_next,\n        ShockDstn,\n        IncShkDstn,\n        RiskyDstn,\n        LivPrb,\n        DiscFac,\n        CRRA,\n        Rfree,\n        PermGroFac,\n        BoroCnstArt,\n        aXtraGrid,\n        ShareGrid,\n        vFuncBool,\n        AdjustPrb,\n        DiscreteShareBool,\n        ShareLimit,\n        IndepDstnBool,\n    ):\n    def def_utility_funcs(self):\n    def set_and_update_values(self):\n    def prepare_to_solve(self):\n    def prepare_to_calc_EndOfPrdvP(self):\n    def m_nrm_next(self, shocks, b_nrm_next):\n    def calc_EndOfPrdvP(self):\n        def dvdb_dist(shocks, b_nrm, Share_next):\n        def dvds_dist(shocks, b_nrm, Share_next):\n        def EndOfPrddvda_dist(shock, a_nrm, Share_next):\n        def EndOfPrddvds_dist(shock, a_nrm, Share_next):\n    def optimize_share(self):\n    def make_basic_solution(self):\n    def make_ShareFuncAdj(self):\n    def add_save_points(self):\n    def add_vFunc(self):\n    def make_EndOfPrdvFunc(self):\n        def v_intermed_dist(shocks, b_nrm, Share_next):\n        def EndOfPrdv_dist(shock, a_nrm, Share_next):\n    def make_vFunc(self):\n    def make_porfolio_solution(self):\n    def solve(self):\n    def optimize_share(self):\n    def make_ShareFuncAdj(self):\n    def solve(self):\n    def set_and_update_values(self):\n    def prepare_to_calc_EndOfPrdvP(self):\n    def r_port(self, shocks, share):\n    def m_nrm_next(self, shocks, a_nrm, r_port):\n    def calc_EndOfPrdvP(self):\n        def dvdm(m_nrm_next, shares):\n        def dvds(m_nrm_next, shares):\n        def EndOfPrddvda_dists(shocks, a_nrm, shares):\n        def EndOfPrddvds_dist(shocks, a_nrm, shares):\n    def make_EndOfPrdvFunc(self):\n        def v_dist(shocks, a_nrm, shares):\n    def solve(self):\n    def add_SequentialShareFuncAdj(self, solution):\n    def solve(self):\nHARK/frame.py\nclass FrameAgentType(AgentType):\n    \"\"\"\n    A variation of AgentType that uses Frames to organize\n    its simulation steps.\n\n    Frames allow for state, control, and shock resolutions\n    in a specified order, rather than assuming that they\n    are resolved as shocks -> states -> controls -> poststates.\n\n    Attributes\n    ----------\n\n    frames : [Frame]\n        #Keys are tuples of strings corresponding to model variables.\n        #Values are methods.\n        #Each frame method should update the the variables\n        #named in the key.\n        #Frame order is significant here.\n    \"\"\"\n\n    cycles = 0 # for now, only infinite horizon models.\n\n    # frames property\n    frames = [\n        Frame(\n            ('y'),('x'),\n            transition = lambda x: x^2\n        )\n    ]\n\n    def __init__(self, **kwds):\n\n        ## set up relationships between frames\n        for frame in self.frames:\n            frame.children = []\n            frame.parents = []\n\n        for frame in self.frames:\n            if frame.scope is not None:\n                for var in frame.scope:\n                    scope_frames = [frm for frm in self.frames if var in frm.target]\n\n                    for scope_frame in scope_frames:\n                        if self.frames.index(frame) > self.frames.index(scope_frame):\n                            if frame not in scope_frame.children:\n                                scope_frame.children.append(frame)\n\n                            if scope_frame not in frame.parents:\n                                frame.parents.append(scope_frame)\n                        else:\n                            ffr = ForwardFrameReference(frame)\n                            bfr = BackwardFrameReference(frame)\n\n                            # ignoring equivalence checks for now\n                            scope_frame.children.append(ffr)\n                            frame.parents.append(bfr)\n\n        # Initialize a basic AgentType\n        #AgentType.__init__(\n        #    self,\n        #    **kwds\n        #)\n\n    def initialize_sim(self):\n\n        for frame in self.frames:\n            for var in frame.target:\n\n                if frame.aggregate:\n                    val = np.empty(1)\n                    if frame.default is not None and var in frame.default:\n                        val[:] = frame.default[var]\n                else:\n                    val = np.empty(self.AgentCount)\n\n                if frame.control:\n                    self.controls[var] = val\n                elif  isinstance(frame.transition, Distribution):\n                    self.shocks[var] = val\n                else:\n                    self.state_now[var] = val\n    \n        super().initialize_sim()\n\n    def sim_one_period(self):\n        \"\"\"\n        Simulates one period for this type.\n        Calls each frame in order.\n        These should be defined for\n        AgentType subclasses, except getMortality (define\n        its components simDeath and simBirth instead)\n        and readShocks.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if not hasattr(self, \"solution\"):\n            raise Exception(\n                \"Model instance does not have a solution stored. To simulate, it is necessary\"\n                \" to run the `solve()` method of the class first.\"\n            )\n\n        # Mortality adjusts the agent population\n        self.get_mortality()  # Replace some agents with \"newborns\"\n\n        # state_{t-1}\n        for frame in self.frames:\n            for var in frame.target:\n                if var in self.state_now:\n                    self.state_prev[var] = self.state_now[var]\n                \n                    if not frame.aggregate:\n                        self.state_now[var] = np.empty(self.AgentCount)\n                    else:\n                        self.state_now[var] = np.empty(1)\n\n        # transition the variables in the frame\n        for frame in self.frames:\n            self.transition_frame(frame)\n\n        # Advance time for all agents\n        self.t_age = self.t_age + 1  # Age all consumers by one period\n        self.t_cycle = self.t_cycle + 1  # Age all consumers within their cycle\n        self.t_cycle[\n            self.t_cycle == self.T_cycle\n        ] = 0  # Resetting to zero for those who have reached the end\n\n    def sim_birth(self, which_agents):\n        \"\"\"\n        Makes new agents for the simulation.\n        Takes a boolean array as an input, indicating which\n        agent indices are to be \"born\".\n\n        Populates model variable values with value from `init`\n        property\n\n        Parameters\n        ----------\n        which_agents : np.array(Bool)\n            Boolean array of size self.AgentCount indicating which agents should be \"born\".\n\n        Returns\n        -------\n        None\n        \"\"\"\n        which_agents = which_agents.astype(bool)\n\n        for frame in self.frames:\n            if not frame.aggregate:\n                for var in frame.target:\n\n                    N = np.sum(which_agents)\n\n                    if frame.default is not None and var in frame.default:\n                        if callable(frame.default[var]):\n                            value = frame.default[var](self, N)\n                        else:\n                            value = frame.default[var]\n\n                        if var in self.state_now:\n                            ## need to check in case of aggregate variables.. PlvlAgg\n                            if hasattr(self.state_now[var],'__getitem__'):\n                                self.state_now[var][which_agents] = value\n                        elif var in self.controls:\n                            self.controls[var][which_agents] = value\n                        elif var in self.shocks:\n                            ## assuming no aggregate shocks... \n                            self.shocks[var][which_agents] = value\n\n        # from ConsIndShockModel. Needed???\n        self.t_age[which_agents] = 0  # How many periods since each agent was born\n        self.t_cycle[\n            which_agents\n        ] = 0  # Which period of the cycle each agent is currently in\n\n        ## simplest version of this.\n    def transition_frame(self, frame):\n        \"\"\"\n        Updates the model variables in `target`\n        using the `transition` function.\n        The transition function will use current model\n        variable state as arguments.\n        \"\"\"\n        # build a context object based on model state variables\n        # and 'self' reference for 'global' variables\n        context = {} # 'self' : self}\n        context.update(self.shocks)\n        context.update(self.controls)\n        context.update(self.state_prev)\n\n        # use the \"now\" version of variables that have already been targetted.\n        for pre_frame in self.frames[:self.frames.index(frame)]:\n            for var in pre_frame.target:\n                if var in self.state_now:\n                    context.update({var : self.state_now[var]})\n\n        context.update(self.parameters)\n\n        # The \"most recently\" computed value of the variable is used.\n        # This could be the value from the 'previous' time step.\n\n        # limit context to scope of frame\n        local_context = {\n            var : context[var]\n            for var\n            in frame.scope\n        } if frame.scope is not None else context.copy()\n\n        if frame.transition is not None:\n            if isinstance(frame.transition, Distribution):\n                # assume this is an IndexDistribution keyed to age (t_cycle)\n                # for now\n                # later, t_cycle should be included in local context, etc.\n                if frame.aggregate:\n                    new_values = (frame.transition.draw(1),)\n                else:    \n                    new_values = (frame.transition.draw(self.t_cycle),)\n\n            else: # transition is function of state variables not an exogenous shock\n                new_values = frame.transition(\n                    self,\n                    **local_context\n                )\n\n        else:\n            raise Exception(f\"Frame has None for transition: {frame}\")\n\n        # because we want to alter the 'now' not 'prev' table\n        context.update(self.state_now)\n\n        # because the context was a shallow update,\n        # the model values can be modified directly(?)\n        for i,t in enumerate(frame.target):\n            if t in context:\n                context[t][:] = new_values[i]\n            else:\n                raise Exception(f\"From frame {frame.target}, target {t} is not in the context object.\")\nHARK/frame.py\nclass Frame():\n    \"\"\"\n    An object representing a single 'frame' of an optimization problem.\n    A frame defines some variables of a model, including what other variables\n    (if any) they depend on for their values.\n    \"\"\"\n\n    def __init__(\n            self,\n            target,\n            scope,\n            default = None,\n            transition = None,\n            objective = None,\n            aggregate = False,\n            control = False,\n            reward = False\n    ):\n        \"\"\"\n        \"\"\"\n\n        self.target = target if isinstance(target, tuple) else (target,) # tuple of variables\n        self.scope = scope # tuple of variables\n        self.default = default # default value used in simBirth; a dict\n        ## Careful! Transition functions need to return a tuple, even if there is only one state value\n        self.transition = transition # for use in simulation\n        self.objective = objective # for use in solver\n        self.aggregate = aggregate\n        self.control = control\n        self.reward = reward\n\n    def __repr__(self):\n        return f\"<{self.__class__}, target:{self.target}, scope:{self.scope}>\"\n\n    def name(self):\n        target = self.target\n        return str(target[0]) if len(target) == 1 else str(self.target)\nHARK/distribution.py\nclass Bernoulli(Distribution):\n    \"\"\"\n    A Bernoulli distribution.\n\n    Parameters\n    ----------\n    p : float or [float]\n        Probability or probabilities of the event occurring (True).\n\n    seed : int\n        Seed for random number generator.\n    \"\"\"\n\n    p = None\n\n    def __init__(self, p=0.5, seed=0):\n        self.p = np.array(p)\n        # Set up the RNG\n        super().__init__(seed)\n\n    def draw(self, N):\n        \"\"\"\n        Generates arrays of booleans drawn from a simple Bernoulli distribution.\n        The input p can be a float or a list-like of floats; its length T determines\n        the number of entries in the output.  The t-th entry of the output is an\n        array of N booleans which are True with probability p[t] and False otherwise.\n\n        Arguments\n        ---------\n        N : int\n            Number of draws in each row.\n\n        Returns\n        -------\n        draws : np.array or [np.array]\n            T-length list of arrays of Bernoulli draws each of size N, or a single\n        array of size N (if sigma is a scalar).\n        \"\"\"\n        draws = []\n        for j in range(self.p.size):\n            draws.append(self.RNG.uniform(size=N) < self.p.item(j))\n        return draws[0] if len(draws) == 1 else draws\nHARK/distribution.py\nclass IndexDistribution(Distribution):\n    \"\"\"\n    This class provides a way to define a distribution that\n    is conditional on an index.\n\n    The current implementation combines a defined distribution\n    class (such as Bernoulli, LogNormal, etc.) with information\n    about the conditions on the parameters of the distribution.\n\n    For example, an IndexDistribution can be defined as\n    a Bernoulli distribution whose parameter p is a function of\n    a different inpute parameter.\n\n    Parameters\n    ----------\n\n    engine : Distribution class\n        A Distribution subclass.\n\n    conditional: dict\n        Information about the conditional variation\n        on the input parameters of the engine distribution.\n        Keys should match the arguments to the engine class\n        constructor.\n\n    seed : int\n        Seed for random number generator.\n    \"\"\"\n\n    conditional = None\n    engine = None\n\n    def __init__(self, engine, conditional, RNG = None, seed=0):\n        \n        if RNG is None:\n            # Set up the RNG\n            super().__init__(seed)\n        else:\n            # If an RNG is received, use it in whatever state it is in.\n            self.RNG = RNG\n            # The seed will still be set, even if it is not used for the RNG,\n            # for whenever self.reset() is called.\n            # Note that self.reset() will stop using the RNG that was passed\n            # and create a new one.\n            self.seed = seed\n\n        self.conditional = conditional\n        self.engine = engine\n        \n        \n        self.dstns = []\n        \n        # Test one item to determine case handling\n        item0 = list(self.conditional.values())[0]\n        \n        if type(item0) is list:\n            # Create and store all the conditional distributions\n            for y in range(len(item0)):\n                cond = {key: val[y] for (key, val) in self.conditional.items()}\n                self.dstns.append(self.engine(seed=self.RNG.randint(0, 2 ** 31 - 1), **cond))\n                \n        elif type(item0) is float:\n            \n            self.dstns = [self.engine(seed=self.RNG.randint(0, 2 ** 31 - 1), **conditional)]\n\n        else:\n            raise (\n                Exception(\n                    f\"IndexDistribution: Unhandled case for __getitem__ access. y: {y}; conditional: {self.conditional}\"\n                )\n            )\n            \n    def __getitem__(self, y):\n        \n        return self.dstns[y]\n\n    def approx(self, N, **kwds):\n        \"\"\"\n        Approximation of the distribution.\n\n        Parameters\n        ----------\n        N : init\n            Number of discrete points to approximate\n            continuous distribution into.\n\n        kwds: dict\n            Other keyword arguments passed to engine\n            distribution approx() method.\n\n        Returns:\n        ------------\n        dists : [DiscreteDistribution]\n            A list of DiscreteDistributions that are the\n            approximation of engine distribution under each condition.\n\n            TODO: It would be better if there were a conditional discrete\n            distribution representation. But that integrates with the\n            solution code. This implementation will return the list of\n            distributions representations expected by the solution code.\n        \"\"\"\n\n        # test one item to determine case handling\n        item0 = list(self.conditional.values())[0]\n\n        if type(item0) is float:\n            # degenerate case. Treat the parameterization as constant.\n            return self.dstns[0].approx(N, **kwds)\n\n        if type(item0) is list:\n            return TimeVaryingDiscreteDistribution(\n                [self[i].approx(N, **kwds) for i, _ in enumerate(item0)]\n            )\n\n    def draw(self, condition):\n        \"\"\"\n        Generate arrays of draws.\n        The input is an array containing the conditions.\n        The output is an array of the same length (axis 1 dimension)\n        as the conditions containing random draws of the conditional\n        distribution.\n\n        Parameters\n        ----------\n        condition : np.array\n            The input conditions to the distribution.\n\n        Returns:\n        ------------\n        draws : np.array\n        \"\"\"\n        # for now, assume that all the conditionals\n        # are of the same type.\n        # this matches the HARK 'time-varying' model architecture.\n\n        # test one item to determine case handling\n        item0 = list(self.conditional.values())[0]\n\n        if type(item0) is float:\n            # degenerate case. Treat the parameterization as constant.\n            N = condition.size\n\n            return self.engine(\n                seed=self.RNG.randint(0, 2 ** 31 - 1), **self.conditional\n            ).draw(N)\n\n        if type(item0) is list:\n            # conditions are indices into list\n            # somewhat convoluted sampling strategy retained\n            # for test backwards compatibility\n\n            draws = np.zeros(condition.size)\n\n            for c in np.unique(condition):\n                these = c == condition\n                N = np.sum(these)\n\n                cond = {key: val[c] for (key, val) in self.conditional.items()}\n                draws[these] = self[c].draw(N)\n\n            return draws\n", "answers": ["class PortfolioConsumerFrameType(FrameAgentType, PortfolioConsumerType):"], "length": 3454, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "d5bd0c27f711122cb9cbd09ffdc1eed1cd7eb6ce796320e0"}
{"input": "import subprocess\nimport os\nimport re\nimport shutil\nimport tarfile\nimport ntpath\nimport io\nimport json\nimport random\nimport time\nimport socket\nimport unicodedata\nimport threading\nimport base64\nimport sqlite3 as sq\nfrom django.shortcuts import render\nfrom django.conf import settings\nfrom django.template.defaulttags import register\nfrom django.http import HttpResponseRedirect, HttpResponse\nfrom django.utils.html import escape\nfrom StaticAnalyzer.models import StaticAnalyzerAndroid\nfrom DynamicAnalyzer.pyWebProxy.pywebproxy import Proxy\nfrom DynamicAnalyzer.views.android.android_avd import (\n    avd_load_wait,\n    refresh_avd,\n    stop_avd\n)\nfrom DynamicAnalyzer.views.android.android_virtualbox_vm import (\n    refresh_vm\n)\nfrom DynamicAnalyzer.views.android.android_dyn_shared import (\n    connect,\n    install_and_run,\n    web_proxy,\n    get_res,\n    get_identifier,\n    wait,\n)\nfrom MobSF.utils import PrintException, is_number, python_list, isBase64, getADB\nfrom MalwareAnalyzer.views import MalwareCheck\n\"\"\"Core Functions of Android Dynamic Analysis\"\"\"\n# -*- coding: utf_8 -*-\n\n\n\n#===========================================\n# Dynamic Analyzer Related Views for Android\n#===========================================\n\n\n'''\nNeed to improve RCE Detection on Framework, audit all subprocess calls\nTCP Connnection to screenshot service needs to be secured.\nGlobals!\n'''\n\nTCP_SERVER_MODE = \"off\"  # ScreenCast TCP Service Status\n\n\n@register.filter\ndef key(d, key_name):\n    \"\"\"To get dict element by key name in template\"\"\"\n    return d.get(key_name)\n\n\ndef android_dynamic_analyzer(request):\n    \"\"\"Android Dynamic Analyzer View\"\"\"\n    print \"\\n[INFO] Dynamic Analysis Started\"\n    try:\n        if request.method == 'POST':\n            md5_hash = request.POST['md5']\n            package = request.POST['pkg']\n            launcher = request.POST['lng']\n            if re.findall(r';|\\$\\(|\\|\\||&&', package) or re.findall(r';|\\$\\(|\\|\\||&&', launcher):\n                print \"[ATTACK] Possible RCE\"\n                return HttpResponseRedirect('/error/')\n            if re.match('^[0-9a-f]{32}$', md5_hash):\n                # Delete ScreenCast Cache\n                screen_file = os.path.join(settings.SCREEN_DIR, 'screen.png')\n                if os.path.exists(screen_file):\n                    os.remove(screen_file)\n                # Delete Contents of Screenshot Dir\n                screen_dir = os.path.join(\n                    settings.UPLD_DIR, md5_hash + '/screenshots-apk/')\n                if os.path.isdir(screen_dir):\n                    shutil.rmtree(screen_dir)\n                else:\n                    os.makedirs(screen_dir)\n                # Start DM\n                Proxy(\"\", \"\", \"\", \"\")\n                toolsdir = os.path.join(\n                    settings.BASE_DIR, 'DynamicAnalyzer/tools/')  # TOOLS DIR\n                adb = getADB(toolsdir)\n                if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n                    print \"\\n[INFO] MobSF will perform Dynamic Analysis on real Android Device\"\n                    is_avd = False\n                elif settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_AVD\":\n                    # adb, avd_path, reference_name, dup_name, emulator\n                    is_avd = True\n", "context": "DynamicAnalyzer/views/android/android_dyn_shared.py\ndef get_identifier():\n    \"\"\"Get Device Type\"\"\"\n    try:\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n            return settings.DEVICE_IP + \":\" + str(settings.DEVICE_ADB_PORT)\n        elif settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_AVD\":\n            return 'emulator-' + str(settings.AVD_ADB_PORT)\n        else:\n            return settings.VM_IP + \":\" + str(settings.VM_ADB_PORT)\n    except:\n        PrintException(\n            \"[ERROR] Getting ADB Connection Identifier for Device/VM\")\nMalwareAnalyzer/views.py\ndef MalwareCheck(urllist):\n    RESULT = {}\n    domainlist = list()\n    try:\n        domainlist = getDomains(urllist)\n        if domainlist:\n            if isInternetAvailable():\n                UpdateDB()\n            else:\n                print \"\\n[WARNING] No Internet Connection. Skipping Malware Database Update.\"\n            DB = os.path.join(MALWARE_DB_DIR, 'malwaredomainlist')\n            with io.open(DB, mode='r', encoding=\"utf8\", errors=\"ignore\") as f:\n                entry_list = f.readlines()\n            for entry in entry_list:\n                enlist = entry.split('\",\"')\n                if len(enlist) > 5:\n                    details_dict = dict()\n                    details_dict[\"domain_or_url\"] = enlist[1]\n                    details_dict[\"ip\"] = enlist[2]\n                    details_dict[\"desc\"] = enlist[4]\n                    details_dict[\"bad\"] = \"yes\"\n                    for domain in domainlist:\n                        if (domain in details_dict[\"domain_or_url\"]) or (domain in details_dict[\"ip\"]):\n                            RESULT[domain] = details_dict\n            for domain in domainlist:\n                if domain not in RESULT:\n                    x = dict()\n                    x[\"bad\"] = \"no\"\n                    RESULT[domain] = x\n    except:\n        PrintException(\"[ERROR] Performing Malware Check\")\n    return RESULT\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef connect(toolsdir):\n    \"\"\"Connect to VM/Device\"\"\"\n    print \"\\n[INFO] Connecting to VM/Device\"\n    try:\n        adb = getADB(toolsdir)\n        subprocess.call([adb, \"kill-server\"])\n        subprocess.call([adb, \"start-server\"])\n        print \"\\n[INFO] ADB Started\"\n        wait(5)\n        print \"\\n[INFO] Connecting to VM/Device\"\n        result = subprocess.call([adb, \"connect\", get_identifier()])\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\" and result != 0:\n            subprocess.call([adb, \"tcpip\", str(settings.DEVICE_ADB_PORT)])\n            subprocess.call([adb, \"connect\", get_identifier()])\n        subprocess.call([adb, \"-s\", get_identifier(), \"wait-for-device\"])\n        print \"\\n[INFO] Mounting\"\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\",\n                             \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"])\n        else:\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\",\n                             \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"])\n            # This may not work for VMs other than the default MobSF VM\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\", \"mount\",\n                             \"-o\", \"rw,remount\", \"-t\", \"rfs\", \"/dev/block/sda6\", \"/system\"])\n    except:\n        print traceback.format_exc()\n        PrintException(\"[ERROR]  Connecting to VM/Device\")\nDynamicAnalyzer/views/android/android_avd.py\ndef stop_avd(adb):\n    \"\"\"Stop AVD\"\"\"\n    print \"\\n[INFO] Stopping MobSF Emulator\"\n    try:\n        # adb -s emulator-xxxx emu kill\n        FNULL = open(os.devnull, 'w')\n        args = [adb, '-s', get_identifier(), 'emu', 'kill']\n        subprocess.call(args, stderr=FNULL)\n    except:\n        PrintException(\"[ERROR] Stopping MobSF Emulator\")\nMobSF/utils.py\ndef PrintException(msg, web=False):\n    try:\n        LOGPATH = settings.LOG_DIR\n    except:\n        LOGPATH = os.path.join(settings.BASE_DIR, \"logs/\")\n    if not os.path.exists(LOGPATH):\n        os.makedirs(LOGPATH)\n    exc_type, exc_obj, tb = sys.exc_info()\n    f = tb.tb_frame\n    lineno = tb.tb_lineno\n    filename = f.f_code.co_filename\n    linecache.checkcache(filename)\n    line = linecache.getline(filename, lineno, f.f_globals)\n    ts = time.time()\n    st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')\n    dat = '\\n[' + st + ']\\n' + msg + \\\n        ' ({0}, LINE {1} \"{2}\"): {3}'.format(\n            filename, lineno, line.strip(), exc_obj)\n    if platform.system() == \"Windows\":\n        print dat\n    else:\n        if web:\n            print Color.BOLD + Color.ORANGE + dat + Color.END\n        else:\n            print Color.BOLD + Color.RED + dat + Color.END\n    with open(LOGPATH + 'MobSF.log', 'a') as f:\n        f.write(dat)\nDynamicAnalyzer/pyWebProxy/pywebproxy.py\ndef Proxy(IP, PORT, LOG, STAT):\n    global kill, log\n    if STAT == \"on\":\n        log = LOG\n        kill = False\n        print \"\\n[INFO] Started Web Proxy at \" + IP + \":\" + PORT\n        threading.Thread(target=startTornado, kwargs=dict(\n            IP=IP, PORT=PORT, log=log)).start()\n    else:\n        print \"\\n[INFO] Stopping any running instance of WebProxy\"\n        kill = True\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef get_res():\n    \"\"\"Get Screen Resolution or Device or VM\"\"\"\n    print \"\\n[INFO] Getting Screen Resolution\"\n    try:\n        toolsdir = os.path.join(\n            settings.BASE_DIR, 'DynamicAnalyzer/tools/')  # TOOLS DIR\n        adb = getADB(toolsdir)\n        resp = subprocess.check_output(\n            [adb, \"-s\", get_identifier(), \"shell\", \"dumpsys\", \"window\"])\n        resp = resp.split(\"\\n\")\n        res = \"\"\n        for line in resp:\n            if \"mUnrestrictedScreen\" in line:\n                res = line\n                break\n        res = res.split(\"(0,0)\")[1]\n        res = res.strip()\n        res = res.split(\"x\")\n        if len(res) == 2:\n            return res[0], res[1]\n            # width, height\n        return \"\", \"\"\n    except:\n        PrintException(\"[ERROR] Getting Screen Resolution\")\n        return \"\", \"\"\nDynamicAnalyzer/views/android/android_avd.py\ndef avd_load_wait(adb):\n    \"\"\"Wait for AVD Load\"\"\"\n    try:\n        emulator = get_identifier()\n\n        print \"[INFO] Wait for emulator to load\"\n        args = [adb,\n                \"-s\",\n                emulator,\n                \"wait-for-device\"]\n        subprocess.call(args)\n\n        print \"[INFO] Wait for dev.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"dev.bootcomplete\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"1\":\n                break\n            else:\n                time.sleep(1)\n\n        print \"[INFO] Wait for sys.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"sys.boot_completed\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"1\":\n                break\n            else:\n                time.sleep(1)\n\n        print \"[INFO] Wait for svc.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"init.svc.bootanim\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"stopped\":\n                break\n            else:\n                time.sleep(1)\n        time.sleep(5)\n        # Remount the partitions for RW\n        subprocess.call([adb, \"-s\", emulator, \"remount\"])\n        return True\n    except:\n        PrintException(\"[ERROR] emulator did not boot properly\")\n        return False\nStaticAnalyzer/models.py\nclass StaticAnalyzerAndroid(models.Model):\n    TITLE = models.TextField()\n    APP_NAME = models.TextField()\n    SIZE = models.CharField(max_length=50)\n    MD5 = models.CharField(max_length=32)\n    SHA1 = models.TextField()\n    SHA256 = models.TextField()\n    PACKAGENAME = models.TextField()\n    MAINACTIVITY = models.TextField()\n    TARGET_SDK = models.CharField(max_length=50)\n    MAX_SDK = models.CharField(max_length=50)\n    MIN_SDK = models.CharField(max_length=50)\n    ANDROVERNAME = models.CharField(max_length=100)\n    ANDROVER = models.CharField(max_length=50)\n    MANIFEST_ANAL = models.TextField()\n    PERMISSIONS = models.TextField()\n    BIN_ANALYSIS = models.TextField()\n    FILES = models.TextField()\n    CERTZ = models.TextField()\n    ACTIVITIES = models.TextField()\n    RECEIVERS = models.TextField()\n    PROVIDERS = models.TextField()\n    SERVICES = models.TextField()\n    LIBRARIES = models.TextField()\n    BROWSABLE = models.TextField()\n    CNT_ACT = models.CharField(max_length=50)\n    CNT_PRO = models.CharField(max_length=50)\n    CNT_SER = models.CharField(max_length=50)\n    CNT_BRO = models.CharField(max_length=50)\n    CERT_INFO = models.TextField()\n    ISSUED = models.CharField(max_length=10)\n    NATIVE = models.CharField(max_length=50)\n    DYNAMIC = models.CharField(max_length=50)\n    REFLECT = models.CharField(max_length=50)\n    CRYPTO = models.CharField(max_length=50)\n    OBFUS = models.CharField(max_length=50)\n    API = models.TextField()\n    DANG = models.TextField()\n    URLS = models.TextField()\n    DOMAINS = models.TextField()\n    EMAILS = models.TextField()\n    STRINGS = models.TextField()\n    ZIPPED = models.TextField()\n    MANI = models.TextField()\n    EXPORTED_ACT = models.TextField()\n    E_ACT = models.CharField(max_length=50)\n    E_SER = models.CharField(max_length=50)\n    E_BRO = models.CharField(max_length=50)\n    E_CNT = models.CharField(max_length=50)\n    APK_ID = models.TextField()\nMobSF/utils.py\ndef is_number(s):\n    try:\n        float(s)\n        return True\n    except ValueError:\n        pass\n    try:\n        unicodedata.numeric(s)\n        return True\n    except (TypeError, ValueError):\n        pass\n    return False\nDynamicAnalyzer/views/android/android_avd.py\ndef refresh_avd(adb, avd_path, reference_name, dup_name, emulator):\n    \"\"\"Refresh AVD\"\"\"\n    print \"\\n[INFO] Refreshing MobSF Emulator\"\n    try:\n        # Stop existing emulator on the spesified port\n        stop_avd(adb)\n\n        # Windows has annoying lock system, it takes time for it to remove the locks after we stopped the emulator\n        if platform.system() == 'Windows':\n            time.sleep(3)\n\n        # Delete old emulator\n        delete_avd(avd_path, dup_name)\n\n        # Copy and replace the contents of the reference machine\n        duplicate_avd(avd_path, reference_name, dup_name)\n\n        # Start emulator\n        start_avd(emulator, dup_name, settings.AVD_ADB_PORT)\n    except:\n        PrintException(\"[ERROR] Refreshing MobSF VM\")\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef web_proxy(apk_dir, ip_address, port):\n    \"\"\"Run MITM Proxy\"\"\"\n    print \"\\n[INFO] Starting Web Proxy\"\n    try:\n        Proxy(ip_address, port, apk_dir, \"on\")\n    except:\n        PrintException(\"[ERROR] Starting Web Proxy\")\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef wait(sec):\n    \"\"\"Wait in Seconds\"\"\"\n    print \"\\n[INFO] Waiting for \" + str(sec) + \" seconds...\"\n    time.sleep(sec)\nMobSF/utils.py\ndef isBase64(str):\n    return re.match('^[A-Za-z0-9+/]+[=]{0,2}$', str)\nDynamicAnalyzer/views/android/android_virtualbox_vm.py\ndef refresh_vm(uuid, snapshot_uuid, vbox_exe):\n    \"\"\"Refresh VirtualBox based VMs\"\"\"\n    print \"\\n[INFO] Refreshing MobSF VM\"\n    try:\n        # Close VM\n        args = [vbox_exe, 'controlvm', uuid, 'poweroff']\n        subprocess.call(args)\n        # changed by davidblus\n        time.sleep(2)\n        print \"\\n[INFO] VM Closed\"\n        # Restore Snapshot\n        args = [vbox_exe, 'snapshot', uuid, 'restore', snapshot_uuid]\n        subprocess.call(args)\n        print \"\\n[INFO] VM Restore Snapshot\"\n        # Start Fresh VM\n        args = [vbox_exe, 'startvm', uuid]\n        subprocess.call(args)\n        print \"\\n[INFO] VM Starting\"\n    except:\n        PrintException(\"[ERROR] Refreshing MobSF VM\")\nMobSF/utils.py\ndef python_list(value):\n    if not value:\n        value = []\n    if isinstance(value, list):\n        return value\n    return ast.literal_eval(value)\nMobSF/utils.py\ndef getADB(TOOLSDIR):\n    \"\"\"Get ADB binary path\"\"\"\n    try:\n        if len(settings.ADB_BINARY) > 0 and isFileExists(settings.ADB_BINARY):\n            return settings.ADB_BINARY\n        else:\n            adb = 'adb'\n            if platform.system() == \"Darwin\":\n                adb_dir = os.path.join(TOOLSDIR, 'adb/mac/')\n                subprocess.call([\"chmod\", \"777\", adb_dir])\n                adb = os.path.join(TOOLSDIR, 'adb/mac/adb')\n            elif platform.system() == \"Linux\":\n                adb_dir = os.path.join(TOOLSDIR, 'adb/linux/')\n                subprocess.call([\"chmod\", \"777\", adb_dir])\n                adb = os.path.join(TOOLSDIR, 'adb/linux/adb')\n            elif platform.system() == \"Windows\":\n                adb = os.path.join(TOOLSDIR, 'adb/windows/adb.exe')\n            return adb\n    except:\n        PrintException(\"[ERROR] Getting ADB Location\")\n        return \"adb\"\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef install_and_run(toolsdir, apk_path, package, launcher, is_activity):\n    \"\"\"Install APK and Run it\"\"\"\n    print \"\\n[INFO] Starting App for Dynamic Analysis\"\n    # try:\n    adb = getADB(toolsdir)\n    print \"\\n[INFO] Installing APK\"\n    install_result = subprocess.check_output([adb, \"-s\", get_identifier(),\n                     \"install\", \"-r\", apk_path])\n    print install_result\n    # 如果是未签名的错误，则对其进行签名并安装，\n    # 签名命令示例：jarsigner -verbose -keystore davidblus_android.keystore -storepass davidblus -signedjar app_signed.apk app.apk davidblus_android.keystore\n    if 'INSTALL_PARSE_FAILED_NO_CERTIFICATES' in install_result:\n        signed_apk_path = sign_apk(apk_path)\n        install_result = subprocess.check_output([adb, \"-s\", get_identifier(),\n                         \"install\", \"-r\", signed_apk_path])\n        print install_result\n    if 'Success' not in install_result:\n        raise Exception('Install Error')\n    if is_activity:\n        run_app = package + \"/\" + launcher\n        print \"\\n[INFO] Launching APK Main Activity\"\n        subprocess.call([adb, \"-s\", get_identifier(),\n                         \"shell\", \"am\", \"start\", \"-n\", run_app])\n    else:\n        print \"\\n[INFO] App Doesn't have a Main Activity\"\n        # Handle Service or Give Choice to Select in Future.\n    print \"[INFO] Testing Environment is Ready!\"\n    # except:\n    #     PrintException(\"[ERROR]  Starting App for Dynamic Analysis\")\n", "answers": ["                    refresh_avd(adb, settings.AVD_PATH, settings.AVD_REFERENCE_NAME,"], "length": 1547, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "9fd276bb1833fcb51da9b0a822cac1057449cf3536d0b155"}
{"input": "import argparse\nimport atexit\nimport multiprocessing as mp\nimport sys\nimport time\n                import pynini  # noqa\n    import warnings\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\nfrom montreal_forced_aligner.command_line.adapt import run_adapt_model\nfrom montreal_forced_aligner.command_line.align import run_align_corpus\nfrom montreal_forced_aligner.command_line.anchor import run_anchor\nfrom montreal_forced_aligner.command_line.classify_speakers import run_classify_speakers\nfrom montreal_forced_aligner.command_line.create_segments import run_create_segments\nfrom montreal_forced_aligner.command_line.g2p import run_g2p\nfrom montreal_forced_aligner.command_line.model import run_model\nfrom montreal_forced_aligner.command_line.train_acoustic_model import run_train_acoustic_model\nfrom montreal_forced_aligner.command_line.train_dictionary import run_train_dictionary\nfrom montreal_forced_aligner.command_line.train_g2p import run_train_g2p\nfrom montreal_forced_aligner.command_line.train_ivector_extractor import (\n    run_train_ivector_extractor,\n)\nfrom montreal_forced_aligner.command_line.train_lm import run_train_lm\nfrom montreal_forced_aligner.command_line.transcribe import run_transcribe_corpus\nfrom montreal_forced_aligner.command_line.validate import run_validate_corpus\nfrom montreal_forced_aligner.config import (\n    load_command_history,\n    load_global_config,\n    update_command_history,\n    update_global_config,\n)\nfrom montreal_forced_aligner.exceptions import MFAError\nfrom montreal_forced_aligner.models import MODEL_TYPES\nfrom montreal_forced_aligner.utils import check_third_party\n    from argparse import ArgumentParser\n        from montreal_forced_aligner.utils import get_mfa_version\n    from colorama import init\n            from montreal_forced_aligner.utils import get_mfa_version\n        \"--terminal_width\",\n        help=f\"Set width of terminal output, \"\n        f\"currently set to {GLOBAL_CONFIG['terminal_width']}\",\n        default=GLOBAL_CONFIG[\"terminal_width\"],\n        type=int,\n    )\n    config_parser.add_argument(\n        \"--blas_num_threads\",\n        help=f\"Number of threads to use for BLAS libraries, 1 is recommended \"\n        f\"due to how much MFA relies on multiprocessing. \"\n        f\"Currently set to {GLOBAL_CONFIG['blas_num_threads']}\",\n        default=GLOBAL_CONFIG[\"blas_num_threads\"],\n        type=int,\n    )\n\n    history_parser = subparsers.add_parser(\"history\", help=\"Show previously run mfa commands\")\n    _ = subparsers.add_parser(\"thirdparty\", help=\"DEPRECATED: Please install Kaldi via conda.\")\n    _ = subparsers.add_parser(\n        \"download\", help=\"DEPRECATED: Please use mfa model download instead.\"\n    )\n\n    history_parser.add_argument(\n        \"depth\", type=int, help=\"Number of commands to list\", nargs=\"?\", default=10\n    )\n    history_parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        help=f\"Output debug messages, default is {GLOBAL_CONFIG['verbose']}\",\n        action=\"store_true\",\n    )\n\n    _ = subparsers.add_parser(\n        \"anchor\", aliases=[\"annotator\"], help=\"Launch Anchor Annotator (if installed)\"\n    )\n\n    return parser\n\n\nparser = create_parser()\n\n\ndef print_history(args):\n    depth = args.depth\n    history = load_command_history()[-depth:]\n    if args.verbose:\n        print(\"command\\tDate\\tExecution time\\tVersion\\tExit code\\tException\")\n        for h in history:\n            execution_time = time.strftime(\"%H:%M:%S\", time.gmtime(h[\"execution_time\"]))\n            d = h[\"date\"].isoformat()\n            print(\n                f\"{h['command']}\\t{d}\\t{execution_time}\\t{h['version']}\\t{h['exit_code']}\\t{h['exception']}\"\n            )\n        pass\n    else:\n        for h in history:\n            print(h[\"command\"])\n\n\ndef main() -> None:\n    \"\"\"\n    Main function for the MFA command line interface\n    \"\"\"\n\n    check_third_party()\n\n    hooks = ExitHooks()\n    hooks.hook()\n    atexit.register(hooks.history_save_handler)\n\n    init()\n    parser = create_parser()\n    mp.freeze_support()\n    args, unknown = parser.parse_known_args()\n    for short in [\"-c\", \"-d\"]:\n        if short in unknown:\n            print(\n                f\"Due to the number of options that `{short}` could refer to, it is not accepted. \"\n                \"Please specify the full argument\",\n                file=sys.stderr,\n            )\n            sys.exit(1)\n    try:\n        if args.subcommand in [\"g2p\", \"train_g2p\"]:\n            try:\n            except ImportError:\n                print(\n                    \"There was an issue importing Pynini, please ensure that it is installed. If you are on Windows, \"\n                    \"please use the Windows Subsystem for Linux to use g2p functionality.\",\n                    file=sys.stderr,\n                )\n                sys.exit(1)\n        if args.subcommand == \"align\":\n            run_align_corpus(args, unknown)\n        elif args.subcommand == \"adapt\":\n            run_adapt_model(args, unknown)\n        elif args.subcommand == \"train\":\n            run_train_acoustic_model(args, unknown)\n        elif args.subcommand == \"g2p\":\n            run_g2p(args, unknown)\n        elif args.subcommand == \"train_g2p\":\n            run_train_g2p(args, unknown)\n        elif args.subcommand == \"validate\":\n            run_validate_corpus(args, unknown)\n        elif args.subcommand in [\"model\", \"models\"]:\n            run_model(args)\n        elif args.subcommand == \"train_lm\":\n            run_train_lm(args, unknown)\n        elif args.subcommand == \"train_dictionary\":\n            run_train_dictionary(args, unknown)\n        elif args.subcommand == \"train_ivector\":\n            run_train_ivector_extractor(args, unknown)\n        elif args.subcommand == \"classify_speakers\":  # pragma: no cover\n            run_classify_speakers(args, unknown)\n        elif args.subcommand in [\"annotator\", \"anchor\"]:\n            run_anchor()\n        elif args.subcommand == \"transcribe\":\n            run_transcribe_corpus(args, unknown)\n        elif args.subcommand == \"create_segments\":\n            run_create_segments(args, unknown)\n        elif args.subcommand == \"configure\":\n", "context": "montreal_forced_aligner/command_line/train_ivector_extractor.py\ndef run_train_ivector_extractor(args: Namespace, unknown: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running ivector extraction training\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    train_ivector(args, unknown)\nmontreal_forced_aligner/command_line/train_lm.py\ndef run_train_lm(args: Namespace, unknown: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running language model training\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    train_lm(args, unknown)\nmontreal_forced_aligner/utils.py\ndef check_third_party():\n    \"\"\"\n    Checks whether third party software is available on the path\n\n    Raises\n    -------\n    :class:`~montreal_forced_aligner.exceptions.ThirdpartyError`\n    \"\"\"\n    bin_path = shutil.which(\"sox\")\n    if bin_path is None:\n        raise ThirdpartyError(\"sox\")\n    bin_path = shutil.which(\"fstcompile\")\n    if bin_path is None:\n        raise ThirdpartyError(\"fstcompile\", open_fst=True)\n    bin_path = shutil.which(\"compute-mfcc-feats\")\n    if bin_path is None:\n        raise ThirdpartyError(\"compute-mfcc-feats\")\nmontreal_forced_aligner/command_line/adapt.py\ndef run_adapt_model(args: Namespace, unknown_args: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running acoustic model adaptation\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    adapt_model(args, unknown_args)\nmontreal_forced_aligner/command_line/create_segments.py\ndef run_create_segments(args: Namespace, unknown: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running sound file segmentation\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    create_segments(args, unknown)\nmontreal_forced_aligner/command_line/anchor.py\ndef run_anchor() -> None:  # pragma: no cover\n    \"\"\"\n    Wrapper function for launching Anchor Annotator\n    \"\"\"\n    try:\n        from anchor import Application, MainWindow\n    except ImportError:\n        print(\n            \"Anchor annotator utility is not installed, please install it via pip install anchor-annotator.\"\n        )\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        app = Application(sys.argv)\n        main = MainWindow()\n\n        app.setActiveWindow(main)\n        main.show()\n        sys.exit(app.exec_())\nmontreal_forced_aligner/command_line/model.py\ndef run_model(args: Namespace) -> None:\n    \"\"\"\n    Wrapper function for running model utility commands\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    \"\"\"\n    validate_args(args)\n    if args.action == \"download\":\n        download_model(args.model_type, args.name)\n    elif args.action == \"list\":\n        list_model(args.model_type)\n    elif args.action == \"inspect\":\n        inspect_model(args.name)\n    elif args.action == \"save\":\n        save_model(args.path, args.model_type, args.name)\nmontreal_forced_aligner/command_line/validate.py\ndef run_validate_corpus(args: Namespace, unknown: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running corpus validation\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    validate_corpus(args, unknown)\nmontreal_forced_aligner/command_line/classify_speakers.py\ndef run_classify_speakers(\r\n    args: Namespace, unknown: Optional[List[str]] = None\r\n) -> None:  # pragma: no cover\r\n    \"\"\"\r\n    Wrapper function for running speaker classification\r\n\r\n    Parameters\r\n    ----------\r\n    args: :class:`~argparse.Namespace`\r\n        Parsed command line arguments\r\n    unknown: list[str]\r\n        Parsed command line arguments to be passed to the configuration objects\r\n    \"\"\"\r\n    validate_args(args)\r\n    classify_speakers(args)\r\nmontreal_forced_aligner/config.py\ndef load_global_config() -> Dict[str, Any]:\n    \"\"\"\n    Load the global MFA configuration\n\n    Returns\n    -------\n    dict[str, Any]\n        Global configuration\n    \"\"\"\n    global_configuration_file = generate_config_path()\n    default_config = {\n        \"clean\": False,\n        \"verbose\": False,\n        \"debug\": False,\n        \"overwrite\": False,\n        \"terminal_colors\": True,\n        \"terminal_width\": 120,\n        \"cleanup_textgrids\": True,\n        \"detect_phone_set\": False,\n        \"num_jobs\": 3,\n        \"blas_num_threads\": 1,\n        \"use_mp\": True,\n        \"temporary_directory\": get_temporary_directory(),\n    }\n    if os.path.exists(global_configuration_file):\n        with open(global_configuration_file, \"r\", encoding=\"utf8\") as f:\n            data = yaml.safe_load(f)\n            default_config.update(data)\n    if \"temp_directory\" in default_config:\n        default_config[\"temporary_directory\"] = default_config[\"temp_directory\"]\n    return default_config\nmontreal_forced_aligner/command_line/train_acoustic_model.py\ndef run_train_acoustic_model(args: Namespace, unknown_args: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running acoustic model training\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    train_acoustic_model(args, unknown_args)\nmontreal_forced_aligner/command_line/align.py\ndef run_align_corpus(args: Namespace, unknown_args: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running alignment\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    align_corpus(args, unknown_args)\nmontreal_forced_aligner/config.py\ndef update_command_history(command_data: Dict[str, Any]) -> None:\n    \"\"\"\n    Update command history with most recent command\n\n    Parameters\n    ----------\n    command_data: dict[str, Any]\n        Current command metadata\n    \"\"\"\n    try:\n        if command_data[\"command\"].split(\" \")[1] == \"history\":\n            return\n    except Exception:\n        return\n    history = load_command_history()\n    path = generate_command_history_path()\n    history.append(command_data)\n    history = history[-50:]\n    with open(path, \"w\", encoding=\"utf8\") as f:\n        yaml.safe_dump(history, f)\nmontreal_forced_aligner/command_line/train_g2p.py\ndef run_train_g2p(args: Namespace, unknown: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running G2P model training\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    train_g2p(args, unknown)\nmontreal_forced_aligner/config.py\ndef load_command_history() -> List[Dict[str, Any]]:\n    \"\"\"\n    Load command history for MFA\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        List of commands previously run\n    \"\"\"\n    path = generate_command_history_path()\n    history = []\n    if os.path.exists(path):\n        with open(path, \"r\", encoding=\"utf8\") as f:\n            history = yaml.safe_load(f)\n    for h in history:\n        h[\"command\"] = re.sub(r\"^\\S+.py \", \"mfa \", h[\"command\"])\n    return history\nmontreal_forced_aligner/command_line/train_dictionary.py\ndef run_train_dictionary(args: Namespace, unknown: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running pronunciation probability training\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    train_dictionary(args, unknown)\nmontreal_forced_aligner/command_line/g2p.py\ndef run_g2p(args: Namespace, unknown: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running G2P\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    generate_dictionary(args, unknown)\nmontreal_forced_aligner/command_line/transcribe.py\ndef run_transcribe_corpus(args: Namespace, unknown: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Wrapper function for running corpus transcription\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Parsed command line arguments\n    unknown: list[str]\n        Parsed command line arguments to be passed to the configuration objects\n    \"\"\"\n    validate_args(args)\n    transcribe_corpus(args, unknown)\nmontreal_forced_aligner/config.py\ndef update_global_config(args: Namespace) -> None:\n    \"\"\"\n    Update global configuration of MFA\n\n    Parameters\n    ----------\n    args: :class:`~argparse.Namespace`\n        Arguments to set\n    \"\"\"\n    global_configuration_file = generate_config_path()\n    default_config = {\n        \"clean\": False,\n        \"verbose\": False,\n        \"debug\": False,\n        \"overwrite\": False,\n        \"terminal_colors\": True,\n        \"terminal_width\": 120,\n        \"cleanup_textgrids\": True,\n        \"detect_phone_set\": False,\n        \"num_jobs\": 3,\n        \"blas_num_threads\": 1,\n        \"use_mp\": True,\n        \"temporary_directory\": get_temporary_directory(),\n    }\n    if os.path.exists(global_configuration_file):\n        with open(global_configuration_file, \"r\", encoding=\"utf8\") as f:\n            data = yaml.safe_load(f)\n            default_config.update(data)\n    if args.always_clean:\n        default_config[\"clean\"] = True\n    if args.never_clean:\n        default_config[\"clean\"] = False\n    if args.always_verbose:\n        default_config[\"verbose\"] = True\n    if args.never_verbose:\n        default_config[\"verbose\"] = False\n    if args.always_debug:\n        default_config[\"debug\"] = True\n    if args.never_debug:\n        default_config[\"debug\"] = False\n    if args.always_overwrite:\n        default_config[\"overwrite\"] = True\n    if args.never_overwrite:\n        default_config[\"overwrite\"] = False\n    if args.disable_mp:\n        default_config[\"use_mp\"] = False\n    if args.enable_mp:\n        default_config[\"use_mp\"] = True\n    if args.disable_textgrid_cleanup:\n        default_config[\"cleanup_textgrids\"] = False\n    if args.enable_textgrid_cleanup:\n        default_config[\"cleanup_textgrids\"] = True\n    if args.disable_detect_phone_set:\n        default_config[\"detect_phone_set\"] = False\n    if args.enable_detect_phone_set:\n        default_config[\"detect_phone_set\"] = True\n    if args.disable_terminal_colors:\n        default_config[\"terminal_colors\"] = False\n    if args.enable_terminal_colors:\n        default_config[\"terminal_colors\"] = True\n    if args.num_jobs and args.num_jobs > 0:\n        default_config[\"num_jobs\"] = args.num_jobs\n    if args.terminal_width and args.terminal_width > 0:\n        default_config[\"terminal_width\"] = args.terminal_width\n    if args.blas_num_threads and args.blas_num_threads > 0:\n        default_config[\"blas_num_threads\"] = args.blas_num_threads\n    if args.temporary_directory:\n        default_config[\"temporary_directory\"] = args.temporary_directory\n    with open(global_configuration_file, \"w\", encoding=\"utf8\") as f:\n        yaml.dump(default_config, f)\nmontreal_forced_aligner/exceptions.py\nclass MFAError(Exception):\n    \"\"\"\n    Base exception class\n    \"\"\"\n\n    def __init__(self, base_error_message: str, *args, **kwargs):\n        self.printer = TerminalPrinter()\n        self.message_lines: List[str] = [base_error_message]\n\n    @property\n    def message(self) -> str:\n        return \"\\n\".join(self.printer.format_info_lines(self.message_lines))\n\n    def __str__(self) -> str:\n        \"\"\"Output the error\"\"\"\n        return \"\\n\".join(\n            self.printer.format_info_lines(\n                [self.printer.error_text(type(self).__name__) + f\": {self.message}\"]\n            )\n        )\nmontreal_forced_aligner/models.py\nMODEL_TYPES = {\n    \"acoustic\": AcousticModel,\n    \"g2p\": G2PModel,\n    \"dictionary\": DictionaryModel,\n    \"language_model\": LanguageModel,\n    \"ivector\": IvectorExtractorModel,\n}\n", "answers": ["            update_global_config(args)"], "length": 1540, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "985bfdff7b49656cb85b7bbb0f4f402657b3e14d7b1ec8ae"}
{"input": "import android.app.AlertDialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.Toolbar;\nimport android.text.Editable;\nimport android.text.TextWatcher;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.Toast;\nimport com.codetroopers.betterpickers.calendardatepicker.CalendarDatePickerDialogFragment;\nimport java.math.BigDecimal;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.List;\nimport java.util.Locale;\nimport ve.com.abicelis.creditcardexpensemanager.R;\nimport ve.com.abicelis.creditcardexpensemanager.app.adapters.SelectableCreditCardAdapter;\nimport ve.com.abicelis.creditcardexpensemanager.app.holders.SelectableCreditCardViewHolder;\nimport ve.com.abicelis.creditcardexpensemanager.app.utils.Constants;\nimport ve.com.abicelis.creditcardexpensemanager.app.utils.SharedPreferencesUtils;\nimport ve.com.abicelis.creditcardexpensemanager.database.ExpenseManagerDAO;\nimport ve.com.abicelis.creditcardexpensemanager.enums.CreditCardBackground;\nimport ve.com.abicelis.creditcardexpensemanager.enums.CreditCardType;\nimport ve.com.abicelis.creditcardexpensemanager.enums.Currency;\nimport ve.com.abicelis.creditcardexpensemanager.exceptions.CouldNotInsertDataException;\nimport ve.com.abicelis.creditcardexpensemanager.model.CreditCard;\n        cardAlias.addTextChangedListener(new TextWatcher() {\n            @Override\n            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}\n\n            @Override\n            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}\n\n            @Override\n            public void afterTextChanged(Editable editable) {\n                for (CreditCard c : mCreditCardList) {\n                    c.setCardAlias(cardAlias.getText().toString());\n                }\n                mAdapter.notifyDataSetChanged();\n            }\n        });\n\n        cardNumber.addTextChangedListener(new TextWatcher() {\n            @Override\n            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}\n\n            @Override\n            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}\n\n            @Override\n            public void afterTextChanged(Editable editable) {\n                for (CreditCard c : mCreditCardList) {\n                    c.setCardNumber(cardNumber.getText().toString());\n                }\n                mAdapter.notifyDataSetChanged();\n            }\n        });\n\n        cardExpiration.addTextChangedListener(new TextWatcher() {\n            @Override\n            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}\n\n            @Override\n            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}\n\n            @Override\n            public void afterTextChanged(Editable editable) {\n                if(cardExpirationCal != null) {\n                    for (CreditCard c : mCreditCardList) {\n                        c.setCardExpiration(cardExpirationCal);\n                    }\n                    mAdapter.notifyDataSetChanged();\n                }\n            }\n        });\n\n\n        cardCurrency.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n            @Override\n            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {\n                for (CreditCard c : mCreditCardList) {\n                    c.setCurrency(currencies.get(cardCurrency.getSelectedItemPosition()));\n                }\n                mAdapter.notifyDataSetChanged();\n            }\n\n            @Override\n            public void onNothingSelected(AdapterView<?> adapterView) {}\n        });\n\n        cardType.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n            @Override\n            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {\n                for (CreditCard c : mCreditCardList) {\n                    c.setCardType(cardTypes.get(cardType.getSelectedItemPosition()));\n                }\n                mAdapter.notifyDataSetChanged();\n            }\n\n            @Override\n            public void onNothingSelected(AdapterView<?> adapterView) {}\n        });\n\n    }\n\n\n    private void handleNewCardCreation() {\n        String alias = cardAlias.getText().toString();\n        if(alias.isEmpty()) {\n            Toast.makeText(this, getResources().getString(R.string.activity_add_new_cc_error_bad_alias), Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n        try{\n            Double.parseDouble(creditLimit.getText().toString());\n        }catch (NumberFormatException e) {\n            Toast.makeText(this, getResources().getString(R.string.activity_add_new_cc_error_bad_credit_limit), Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n        if(cardExpirationCal == null) {\n            Toast.makeText(this, getResources().getString(R.string.activity_add_new_cc_error_bad_expiration), Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n        int closing = days.get(cardClosingDay.getSelectedItemPosition());\n        int due = days.get(cardDueDay.getSelectedItemPosition());\n        if(closing == due) {\n            Toast.makeText(this, getResources().getString(R.string.activity_add_new_cc_error_bad_closing_due_days), Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n        if(selectedCreditCardBackground == null) {\n            Toast.makeText(this, getResources().getString(R.string.activity_add_new_cc_error_cc_background_not_selected), Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n        String bankName = cardBankName.getText().toString();\n        String number = cardNumber.getText().toString();\n        BigDecimal firstCreditPeriodLimit = new BigDecimal(creditLimit.getText().toString());\n        firstCreditPeriodLimit = firstCreditPeriodLimit.setScale(2, BigDecimal.ROUND_DOWN);\n\n        Currency currency = currencies.get(cardCurrency.getSelectedItemPosition());\n        CreditCardType type = cardTypes.get(cardType.getSelectedItemPosition());\n\n", "context": "app/src/main/java/ve/com/abicelis/creditcardexpensemanager/app/utils/Constants.java\npublic class Constants {\n    public static final String PREFS_NAME = \"CCManagerPreferences\";\n    public static final String ACTIVE_CC_ID = \"ActiveCCId\";\n\n    public static final int EXPENSE_DETAIL_ACTIVITY_REQUEST_CODE = 283;\n    public static final int RESULT_REFRESH_DATA = 5;\n}\napp/src/main/java/ve/com/abicelis/creditcardexpensemanager/app/utils/SharedPreferencesUtils.java\npublic class SharedPreferencesUtils {\n\n    private static SharedPreferences getSharedPreferences(Context context) {\n        return context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE);\n    }\n\n    private static void checkIfPreferenceExists(Context context, String preferenceName) throws SharedPreferenceNotFoundException {\n        if(!getSharedPreferences(context).contains(preferenceName))\n            throw new SharedPreferenceNotFoundException(preferenceName + \" does not exist\");\n    }\n\n    public static void setString(Context context, String preferenceName, String value) {\n        getSharedPreferences(context).edit().putString(preferenceName, value).commit();\n    }\n    public static void setInt(Context context, String preferenceName, int value) {\n        getSharedPreferences(context).edit().putInt(preferenceName, value).commit();\n    }\n    public static void setBoolean(Context context, String preferenceName, boolean value) {\n        getSharedPreferences(context).edit().putBoolean(preferenceName, value).commit();\n    }\n    public static void setLong(Context context, String preferenceName, long value) {\n        getSharedPreferences(context).edit().putLong(preferenceName, value).commit();\n    }\n    public static void setFloat(Context context, String preferenceName, float value) {\n        getSharedPreferences(context).edit().putFloat(preferenceName, value).commit();\n    }\n\n    public static String getString(Context context, String preferenceName) throws SharedPreferenceNotFoundException {\n        checkIfPreferenceExists(context, preferenceName);\n        return getSharedPreferences(context).getString(preferenceName, \"\");\n    }\n    public static int getInt(Context context, String preferenceName) throws SharedPreferenceNotFoundException {\n        checkIfPreferenceExists(context, preferenceName);\n        return getSharedPreferences(context).getInt(preferenceName, 0);\n    }\n    public static boolean getBoolean(Context context, String preferenceName) throws SharedPreferenceNotFoundException {\n        checkIfPreferenceExists(context, preferenceName);\n        return getSharedPreferences(context).getBoolean(preferenceName, false);\n    }\n    public static long getLong(Context context, String preferenceName) throws SharedPreferenceNotFoundException {\n        checkIfPreferenceExists(context, preferenceName);\n        return getSharedPreferences(context).getLong(preferenceName, 0);\n    }\n    public static float getFloat(Context context, String preferenceName) throws SharedPreferenceNotFoundException {\n        checkIfPreferenceExists(context, preferenceName);\n        return getSharedPreferences(context).getFloat(preferenceName, 0);\n    }\n\n}\napp/src/main/java/ve/com/abicelis/creditcardexpensemanager/enums/Currency.java\npublic enum Currency implements Serializable {\n\n    USD(\"US Dollar\"),\n    CAD(\"Canadian Dollar\"),\n    VEF(\"Venezuelan Bolivar\"),\n    EUR(\"Euro\"),\n    MEX(\"Mexican Peso\"),\n    ARS(\"Argentine Peso\"),\n    BRL(\"Brazilian Real\"),\n    CLP(\"Chilean Peso\"),\n    COL(\"Colombian Peso\"),\n    UYU(\"Uruguayan Peso\"),\n    PEN(\"Peruvian Sol\"),\n    PYG(\"Paraguayan guarani\"),\n    ;\n\n    private String mFriendlyName;\n\n    Currency(String friendlyName) {\n        mFriendlyName = friendlyName;\n    }\n\n    public String getCode(){\n        return this.name();\n    }\n\n    public String getFriendlyName() {\n        return mFriendlyName;\n    }\n\n\n    @Override\n    public String toString() {\n        return mFriendlyName;\n    }\n\n}\napp/src/main/java/ve/com/abicelis/creditcardexpensemanager/app/holders/SelectableCreditCardViewHolder.java\npublic class SelectableCreditCardViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {\n\n    private Context mContext;\n    SelectableCreditCardSelectedListener mListener = null;\n\n    //DATA\n    private CreditCard mCurrent;\n    private int mPosition;\n\n    //UI\n    private RelativeLayout container;\n    private TextView bankName;\n    private TextView alias;\n    private TextView currency;\n    private TextView cardNumber;\n    private TextView creditCardLabel;\n    private TextView cardExpirationLabel;\n    private TextView cardExpiration;\n    private ImageView cardType;\n    private ImageView cardChip;\n\n\n    public SelectableCreditCardViewHolder(View itemView) {\n        super(itemView);\n\n        container = (RelativeLayout) itemView.findViewById(R.id.list_item_credit_card_container);\n        bankName = (TextView) itemView.findViewById(R.id.list_item_credit_card_bank_name);\n        alias = (TextView) itemView.findViewById(R.id.list_item_credit_card_alias);\n        currency = (TextView) itemView.findViewById(R.id.list_item_credit_card_currency);\n        cardNumber = (TextView) itemView.findViewById(R.id.list_item_credit_card_number);\n        creditCardLabel = (TextView) itemView.findViewById(R.id.list_item_credit_card_label);\n        cardExpirationLabel = (TextView) itemView.findViewById(R.id.list_item_credit_card_expiration_label);\n        cardExpiration = (TextView) itemView.findViewById(R.id.list_item_credit_card_expiration);\n        cardType = (ImageView) itemView.findViewById(R.id.list_item_credit_card_type);\n        cardChip = (ImageView) itemView.findViewById(R.id.list_item_credit_card_chip);\n\n        //LAYOUT_DETAILED views\n\n\n    }\n\n\n    public void setData(Context context, CreditCard current, int position) {\n        mContext = context;\n        mCurrent = current;\n        mPosition = position;\n\n        bankName.setText(current.getBankName());\n        alias.setText(current.getCardAlias());\n        cardNumber.setText(current.getCardNumber());\n        currency.setText(current.getCurrency().getCode());\n        cardExpiration.setText(current.getShortCardExpirationString());\n\n        container.setBackground(current.getCreditCardBackground().getBackgroundDrawable(context));\n        bankName.setTextColor(current.getCreditCardBackground().getTextColor(context));\n        alias.setTextColor(current.getCreditCardBackground().getTextColor(context));\n        currency.setTextColor(current.getCreditCardBackground().getTextColor(context));\n        cardNumber.setTextColor(current.getCreditCardBackground().getTextColor(context));\n        cardExpiration.setTextColor(current.getCreditCardBackground().getTextColor(context));\n        creditCardLabel.setTextColor(current.getCreditCardBackground().getTextColor(context));\n        cardExpirationLabel.setTextColor(current.getCreditCardBackground().getTextColor(context));\n\n        switch(current.getCardType()) {\n            case AMEX:\n                cardType.setImageResource(R.drawable.logo_amex);\n                break;\n            case DISCOVER:\n                cardType.setImageResource(R.drawable.logo_discover);\n                break;\n            case MASTERCARD:\n                cardType.setImageResource(R.drawable.logo_mastercard);\n                break;\n            case VISA:\n                cardType.setImageResource(R.drawable.logo_visa);\n                break;\n        }\n\n\n    }\n\n    public void setListeners() {\n        container.setOnClickListener(this);\n    }\n\n    public void setOnCreditCardSelectedListener(SelectableCreditCardSelectedListener listener) {\n        mListener = listener;\n    }\n\n    @Override\n    public void onClick(View view) {\n        int id = view.getId();\n\n        switch(id) {\n            case R.id.list_item_credit_card_container:\n                if(mListener != null)\n                    mListener.OnCreditCardSelected(mCurrent);\n                break;\n        }\n    }\n\n\n    public interface SelectableCreditCardSelectedListener {\n        void OnCreditCardSelected(CreditCard creditCard);\n    }\n\n}\napp/src/main/java/ve/com/abicelis/creditcardexpensemanager/app/adapters/SelectableCreditCardAdapter.java\npublic class SelectableCreditCardAdapter extends RecyclerView.Adapter<SelectableCreditCardViewHolder>  {\n\n    private List<CreditCard> mCreditCards;\n    private LayoutInflater mInflater;\n    private Context mContext;\n    private SelectableCreditCardViewHolder.SelectableCreditCardSelectedListener mCCSelectedListener;\n\n    public SelectableCreditCardAdapter(Context context, List<CreditCard> creditCards) {\n        mContext = context;\n        mCreditCards = creditCards;\n        mInflater = LayoutInflater.from(context);\n    }\n\n    public void setCreditCardSelectedListener(SelectableCreditCardViewHolder.SelectableCreditCardSelectedListener ccSelectedListener) {\n        mCCSelectedListener = ccSelectedListener;\n    }\n\n\n    @Override\n    public SelectableCreditCardViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view = mInflater.inflate(R.layout.list_item_credit_card_selectable, parent, false);\n        return new SelectableCreditCardViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(SelectableCreditCardViewHolder holder, int position) {\n        CreditCard current = mCreditCards.get(position);\n        holder.setData(mContext, current, position);\n\n        if(mCCSelectedListener != null) {\n            holder.setListeners();\n            holder.setOnCreditCardSelectedListener(mCCSelectedListener);\n        }\n        else\n            Toast.makeText(mContext, \"Warning: mCCSelectedListener == null!\", Toast.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public int getItemCount() {\n        return mCreditCards.size();\n    }\n}\napp/src/main/java/ve/com/abicelis/creditcardexpensemanager/enums/CreditCardType.java\npublic enum CreditCardType {\n\n    AMEX(\"American Express\"),\n    DISCOVER(\"Discover\"),\n    MASTERCARD(\"Master-Card\"),\n    VISA(\"Visa\");\n\n    private String mFriendlyName;\n\n    CreditCardType(String friendlyName) {\n        mFriendlyName = friendlyName;\n    }\n\n    public String getCode(){\n        return this.name();\n    }\n\n    public String getFriendlyName() {\n        return mFriendlyName;\n    }\n\n    @Override\n    public String toString() {\n        return mFriendlyName;\n    }\n}\napp/src/main/java/ve/com/abicelis/creditcardexpensemanager/enums/CreditCardBackground.java\npublic enum CreditCardBackground {\n    DARK_RED(R.drawable.cc_background_dark_red, R.color.cc_foreground_red, R.color.cc_text_white),\n    RED(R.drawable.cc_background_red, R.color.cc_foreground_red, R.color.cc_text_white),\n    GREEN(R.drawable.cc_background_dark_green, R.color.cc_foreground_green,  R.color.cc_text_white),\n    GOLD(R.drawable.cc_background_gold, R.color.cc_foreground_gold,  R.color.cc_text_black),\n    ORANGE(R.drawable.cc_background_orange, R.color.cc_foreground_orange,  R.color.cc_text_white),\n    LIGHT_BLUE(R.drawable.cc_background_light_blue, R.color.cc_foreground_light_blue,  R.color.cc_text_white),\n    LIGHT_GRAY(R.drawable.cc_background_light_gray, R.color.cc_foreground_light_gray,  R.color.cc_text_white);\n\n    int backgroundResId;\n    int foregroundColorId;\n    int textColorId;\n\n    CreditCardBackground(@DrawableRes int backgroundResId, @ColorRes int foregroundColorId, @ColorRes int textColorId) {\n        this.backgroundResId = backgroundResId;\n        this.foregroundColorId = foregroundColorId;\n        this.textColorId = textColorId;\n    }\n\n\n    public int getBackgroundResId() {\n        return backgroundResId;\n    }\n\n    public int getForegroundColorId() {\n        return foregroundColorId;\n    }\n\n    public int getTextColorId() {\n        return textColorId;\n    }\n\n    public String getCode(){\n        return this.name();\n    }\n\n\n    public Drawable getBackgroundDrawable(Context context) throws Resources.NotFoundException {\n\n        Drawable backgroundDrawable = ContextCompat.getDrawable(context, backgroundResId);\n        if(foregroundColorId != -1) {\n            LayerDrawable ld = (LayerDrawable) backgroundDrawable;\n            Drawable drawable = ld.getDrawable(1);\n            drawable.mutate().setColorFilter(getForegroundColor(context), PorterDuff.Mode.MULTIPLY);\n        }\n        return backgroundDrawable;\n    }\n\n    public int getForegroundColor(Context context) throws Resources.NotFoundException {\n        return ContextCompat.getColor(context, foregroundColorId);\n    }\n\n    public int getTextColor(Context context) throws Resources.NotFoundException {\n        return ContextCompat.getColor(context, textColorId);\n    }\n}\napp/src/main/java/ve/com/abicelis/creditcardexpensemanager/database/ExpenseManagerDAO.java\npublic class ExpenseManagerDAO {\n\n    private ExpenseManagerDbHelper mDatabaseHelper;\n\n    public ExpenseManagerDAO(Context context) {\n        mDatabaseHelper = new ExpenseManagerDbHelper(context);\n\n    }\n\n    /**\n     * Returns a List of stored Credit Cards.\n     * Note: The Credit Cards will not contain CreditPeriods, Expenses or Payments.\n     */\n    public List<CreditCard> getCreditCardList() {\n\n        List<CreditCard> creditCards = new ArrayList<>();\n        SQLiteDatabase db = mDatabaseHelper.getReadableDatabase();\n\n        Cursor cursor = db.query(ExpenseManagerContract.CreditCardTable.TABLE_NAME, null, null, null, null, null, null);\n\n        try {\n            while (cursor.moveToNext()) {\n                creditCards.add(getCreditCardFromCursor(cursor));\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return creditCards;\n    }\n\n    /**\n     * Returns a List of CreditPeriods associated with ccardId.\n     * Note: The periods will not contain Expenses or Payments.\n     * @param cardId The ID of the Credit Card\n     */\n    public List<CreditPeriod> getCreditPeriodListFromCard(int cardId) {\n        List<CreditPeriod> creditPeriods = new ArrayList<>();\n        SQLiteDatabase db = mDatabaseHelper.getReadableDatabase();\n\n        Cursor cursor =  db.query(ExpenseManagerContract.CreditPeriodTable.TABLE_NAME, null,\n                ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_FOREIGN_KEY_CREDIT_CARD.getName() + \" == \" + cardId, null, null, null,\n                ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_START_DATE.getName() + \" DESC\");\n\n        try {\n            while (cursor.moveToNext()) {\n                creditPeriods.add(getCreditPeriodFromCursor(cursor));\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return creditPeriods;\n    }\n\n\n\n    /**\n     * Finds a CreditCard with the supplied cardId, will not return creditPeriods associated with\n     * the card\n     * @param cardId The ID of the Credit Card\n     */\n    public CreditCard getCreditCard(int cardId) throws CreditCardNotFoundException {\n        String[] selectionArgs = new String[]{String.valueOf(cardId)};\n        SQLiteDatabase db = mDatabaseHelper.getReadableDatabase();\n\n        Cursor cursor =  db.query(ExpenseManagerContract.CreditCardTable.TABLE_NAME, null,\n                ExpenseManagerContract.CreditCardTable._ID + \" =? \", selectionArgs, null, null, null);\n\n        if(cursor.getCount() == 0)\n            throw new CreditCardNotFoundException(\"Specified Credit Card not found in the database. Passed value=\" + cardId);\n        if(cursor.getCount() > 1)\n            throw new CreditCardNotFoundException(\"Database UNIQUE constraint failure, more than one record found. Passed value=\" + cardId);\n\n        cursor.moveToNext();\n        return getCreditCardFromCursor(cursor);\n    }\n\n    /**\n     * Returns a Credit Card with the supplied cardId and the specified periodIndex.\n     * Note: PeriodIndex must be either zero (returns credit period contaning current date) or a\n     * negative value (-1 returns previous credit period, and so on)\n     * @param cardId The ID of the Credit Card\n     * @param periodIndex An integer <= 0\n     */\n    public CreditCard getCreditCardWithCreditPeriod(int cardId, int periodIndex) throws CreditCardNotFoundException, CreditPeriodNotFoundException, InvalidParameterException{\n        if(periodIndex > 0)\n            throw new InvalidParameterException(\"PeriodIndex must be >=0. Passed value=\" + periodIndex);\n\n        CreditCard creditCard = getCreditCard(cardId);\n\n        //Get ordered (DESC) list of credit periods\n        List<CreditPeriod> creditPeriods = getCreditPeriodListFromCard(cardId);\n\n        //Find the creditPeriod according to periodIndex\n        CreditPeriod cp = getCreditPeriodFromPeriodIndex(creditPeriods, periodIndex, creditCard.getClosingDay());\n\n        //Create Map and set it on the Credit Card\n        Map<Integer, CreditPeriod> creditPeriodMap = new HashMap<>();\n        creditPeriodMap.put(periodIndex, cp);\n        creditCard.setCreditPeriods(creditPeriodMap);\n\n        return creditCard;\n    }\n\n\n    /**\n     * Returns a Credit Card with the supplied cardId and as many credit periods as numPeriods\n     * indicates. Counting backwards starting on periodIndex.\n     * Note: PeriodIndex must be either zero (current creditPriod) or a\n     * negative value (-1 refers to the previous credit period, and so on)\n     * Note2: Passing periodIndex=-1, numPeriods=3 will return three periods (Period -1, -2 and -3)\n     * @param cardId The ID of the Credit Card\n     * @param periodIndex An integer <= 0\n     * @param numPeriods An integer >= 1\n     */\n    public CreditCard getCreditCardWithCreditPeriodRange(int cardId, int periodIndex, int numPeriods) throws CreditCardNotFoundException, CreditPeriodNotFoundException, InvalidParameterException {\n        if (periodIndex > 0)\n            throw new InvalidParameterException(\"PeriodIndex must be less or equal than 0. Passed value=\" + periodIndex);\n        if (numPeriods <= 0)\n            throw new InvalidParameterException(\"NumPeriods must be more or equal than 1. Passed value=\" + periodIndex);\n\n        CreditCard creditCard = getCreditCard(cardId);\n\n        //Get ordered (DESC) list of credit periods\n        List<CreditPeriod> creditPeriods = getCreditPeriodListFromCard(cardId);\n\n        Map<Integer, CreditPeriod> creditPeriodMap = new HashMap<>();\n\n        //Find the creditPeriod according to periodIndex\n        for (int i = periodIndex; i > (periodIndex-numPeriods); --i) {\n            CreditPeriod cp = getCreditPeriodFromPeriodIndex(creditPeriods, i, creditCard.getClosingDay());\n            creditPeriodMap.put(i, cp);\n        }\n\n        //Set creditPeriods in creditCard and return\n        creditCard.setCreditPeriods(creditPeriodMap);\n        return creditCard;\n    }\n\n\n    /**\n     * Returns a Credit Period from a List of creditPeriods which complies with the supplied\n     * periodIndex and closingDay.\n     * Note: PeriodIndex must be either zero (returns credit period contaning current date) or a\n     * negative value (-1 returns previous credit period, and so on)\n     * Note2: closingDay must be between 1 and 28.\n     * @param creditPeriods List of Credit Periods to search into\n     * @param periodIndex An integer <= 0\n     * @param closingDay An integer between 1 and 28\n     */\n    private CreditPeriod getCreditPeriodFromPeriodIndex(List<CreditPeriod> creditPeriods, int periodIndex, int closingDay) throws CreditPeriodNotFoundException, InvalidParameterException {\n        if(closingDay < 1 || closingDay > 28)\n            throw new InvalidParameterException(\"ClosingDay must be between 1 and 28. Passed value=\" + closingDay);\n        if(periodIndex > 0)\n            throw new InvalidParameterException(\"PeriodIndex must be >=0. Passed value=\" + periodIndex);\n        if(creditPeriods == null || creditPeriods.size() == 0)\n            throw new InvalidParameterException(\"creditPeriods is null or empty\");\n\n        //Get a day which will be between the starting and ending dates of the wanted creditPeriod\n        Calendar day = Calendar.getInstance();\n        if(periodIndex != 0)\n            day.add(Calendar.MONTH, periodIndex);\n\n        for (CreditPeriod cp : creditPeriods) {\n            if(cp.getStartDate().compareTo(day) <=0 && cp.getEndDate().compareTo(day) >=0) {\n                cp.setExpenses(getExpensesFromCreditPeriod(cp.getId()));\n                cp.setPayments(getPaymentsFromCreditPeriod(cp.getId()));\n                return cp;\n\n            }\n        }\n\n        throw new CreditPeriodNotFoundException(\"Credit period (index \" + periodIndex + \") not found in passed creditPeriods List\");\n    }\n\n    /**\n     * Returns a Credit Period with the supplied periodId, containing its Expenses and Payments\n     * @param periodId The ID of the Credit Period\n     */\n    public CreditPeriod getCreditPeriodFromPeriodId(int periodId) throws CreditPeriodNotFoundException {\n        SQLiteDatabase db = mDatabaseHelper.getReadableDatabase();\n        CreditPeriod creditPeriod;\n\n        Cursor cursor =  db.query(ExpenseManagerContract.CreditPeriodTable.TABLE_NAME, null, ExpenseManagerContract.CreditPeriodTable._ID + \" == \" + periodId, null, null, null, null);\n\n        if(cursor.getCount() == 0)\n            throw new CreditPeriodNotFoundException(\"Specified Credit Period not found in the database. Passed value=\" + periodId);\n        if(cursor.getCount() > 1)\n            throw new CreditPeriodNotFoundException(\"Database UNIQUE constraint failure, more than one record found. Passed Value=\" + periodId);\n\n        try{\n            cursor.moveToNext();\n            creditPeriod = getCreditPeriodFromCursor(cursor);\n            creditPeriod.setExpenses(getExpensesFromCreditPeriod(periodId));\n            creditPeriod.setPayments(getPaymentsFromCreditPeriod(periodId));\n        } finally {\n            cursor.close();\n        }\n\n        return creditPeriod;\n    }\n\n\n    /**\n     * Returns a List of Expenses, given a creditPeriodId\n     * @param periodId the Id of the Credit period\n     */\n    public List<Expense> getExpensesFromCreditPeriod(int periodId) {\n        List<Expense> expenses = new ArrayList<>();\n        SQLiteDatabase db = mDatabaseHelper.getReadableDatabase();\n\n        Cursor cursor =  db.query(ExpenseManagerContract.ExpenseTable.TABLE_NAME, null,\n                ExpenseManagerContract.ExpenseTable.COLUMN_NAME_FOREIGN_KEY_CREDIT_PERIOD.getName() + \" == \" + periodId,\n                null, null, null, ExpenseManagerContract.ExpenseTable.COLUMN_NAME_DATE.getName() + \" DESC\");\n\n\n        try {\n            while (cursor.moveToNext()) {\n                expenses.add(getExpenseFromCursor(cursor));\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return expenses;\n    }\n\n    /**\n     * Returns a List of Payments, given a creditPeriodId\n     * @param periodId the Id of the Credit period\n     */\n    public List<Payment> getPaymentsFromCreditPeriod(int periodId) {\n        List<Payment> payments = new ArrayList<>();\n        SQLiteDatabase db = mDatabaseHelper.getReadableDatabase();\n\n        Cursor cursor =  db.query(ExpenseManagerContract.PaymentTable.TABLE_NAME, null,\n                ExpenseManagerContract.PaymentTable.COLUMN_NAME_FOREIGN_KEY_CREDIT_PERIOD.getName() + \" == \" + periodId,\n                null, null, null, ExpenseManagerContract.PaymentTable.COLUMN_NAME_DATE.getName() + \" DESC\");\n\n        try {\n            while (cursor.moveToNext()) {\n                payments.add(getPaymentFromCursor(cursor));\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return payments;\n    }\n\n\n    /**\n     * Returns an Expenses, given an Expense ID\n     * @param expenseId the Id of the Expense\n     */\n    public Expense getExpense(int expenseId) throws CouldNotGetDataException {\n        SQLiteDatabase db = mDatabaseHelper.getReadableDatabase();\n        String[] selectionArgs = new String[]{String.valueOf(expenseId)};\n\n\n        Cursor cursor =  db.query(ExpenseManagerContract.ExpenseTable.TABLE_NAME, null,\n                ExpenseManagerContract.ExpenseTable._ID + \" =? \",\n                selectionArgs, null, null, null);\n\n\n        if(cursor.getCount() == 0)\n            throw new CouldNotGetDataException(\"Expense not found for ID = \" + expenseId);\n\n\n        cursor.moveToNext();\n        return getExpenseFromCursor(cursor);\n    }\n\n\n\n    /* Delete data from database */\n\n    /**\n     * Deletes a credit card, with its associated credit periods, expenses and payments\n     */\n    public boolean deleteCreditCard(int creditCardId) throws CouldNotDeleteDataException {\n\n        //Fetch all credit periods and delete associated expenses and payments\n        for( CreditPeriod cp : getCreditPeriodListFromCard(creditCardId)) {\n            deleteExpensesFromCreditPeriod(cp.getId());\n            deletePaymentsFromCreditPeriod(cp.getId());\n            deleteCreditPeriod(cp.getId());\n        }\n\n        //Finally, delete the credit card\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n        String[] whereArgs = new String[]{String.valueOf(creditCardId)};\n\n        return db.delete(ExpenseManagerContract.CreditCardTable.TABLE_NAME,\n                ExpenseManagerContract.CreditCardTable._ID + \" =?\",\n                whereArgs) > 0;\n    }\n\n    public boolean deleteCreditPeriod(int creditPeriodId) throws CouldNotDeleteDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n        String[] whereArgs = new String[]{String.valueOf(creditPeriodId)};\n\n        return db.delete(ExpenseManagerContract.CreditPeriodTable.TABLE_NAME,\n                ExpenseManagerContract.CreditPeriodTable._ID + \" =?\",\n                whereArgs) > 0;\n    }\n\n\n    public boolean deleteExpensesFromCreditPeriod(int creditPeriodId) throws CouldNotDeleteDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n        String[] whereArgs = new String[]{String.valueOf(creditPeriodId)};\n\n        return db.delete(ExpenseManagerContract.ExpenseTable.TABLE_NAME,\n                ExpenseManagerContract.ExpenseTable.COLUMN_NAME_FOREIGN_KEY_CREDIT_PERIOD.getName() + \" =?\",\n                whereArgs) > 0;\n    }\n\n    public boolean deleteExpense(int expenseId) throws CouldNotDeleteDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n        String[] whereArgs = new String[]{String.valueOf(expenseId)};\n\n        return db.delete(ExpenseManagerContract.ExpenseTable.TABLE_NAME,\n                ExpenseManagerContract.ExpenseTable._ID + \" =?\",\n                whereArgs) > 0;\n    }\n\n\n\n    public boolean deletePaymentsFromCreditPeriod(int creditPeriodId) throws CouldNotDeleteDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n        String[] whereArgs = new String[]{String.valueOf(creditPeriodId)};\n\n        return db.delete(ExpenseManagerContract.PaymentTable.TABLE_NAME,\n                ExpenseManagerContract.PaymentTable.COLUMN_NAME_FOREIGN_KEY_CREDIT_PERIOD.getName() + \" =?\",\n                whereArgs) > 0;\n    }\n\n    public boolean deletePayment(int paymentId) throws CouldNotDeleteDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n        String[] whereArgs = new String[]{String.valueOf(paymentId)};\n\n        return db.delete(ExpenseManagerContract.PaymentTable.TABLE_NAME,\n                ExpenseManagerContract.PaymentTable._ID + \" =?\",\n                whereArgs) > 0;\n    }\n\n\n\n\n    /* Update data on database */\n    public long updateCreditCard(CreditCard creditCard) throws CouldNotUpdateDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n\n        //Set values\n        ContentValues values = getValuesFromCreditCard(creditCard);\n\n        //Which row to update\n        String selection = ExpenseManagerContract.CreditCardTable._ID + \" =? \";\n        String[] selectionArgs = { String.valueOf(creditCard.getId()) };\n\n        int count = db.update(\n                ExpenseManagerContract.CreditCardTable.TABLE_NAME,\n                values,\n                selection,\n                selectionArgs);\n\n        return count;\n    }\n\n    public long updateExpense(Expense expense) throws CouldNotUpdateDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n\n        //Set values\n        ContentValues values = getValuesFromExpense(expense);\n\n        //Which row to update\n        String selection = ExpenseManagerContract.ExpenseTable._ID + \" =? \";\n        String[] selectionArgs = { String.valueOf(expense.getId()) };\n\n        int count = db.update(\n                ExpenseManagerContract.ExpenseTable.TABLE_NAME,\n                values,\n                selection,\n                selectionArgs);\n\n        return count;\n    }\n\n    public long updateCreditPeriod(int creditCardId, CreditPeriod creditPeriod) throws CouldNotUpdateDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n\n        //Set values\n        ContentValues values = getValuesFromCreditPeriod(creditCardId, creditPeriod);\n\n        //Which row to update\n        String selection = ExpenseManagerContract.CreditPeriodTable._ID + \" =? \";\n        String[] selectionArgs = { String.valueOf(creditPeriod.getId()) };\n\n        int count = db.update(\n                ExpenseManagerContract.CreditPeriodTable.TABLE_NAME,\n                values,\n                selection,\n                selectionArgs);\n\n        return count;\n    }\n\n\n\n    /* Insert data into database */\n\n    public long insertCreditCard(CreditCard creditcard, BigDecimal firstCreditPeriodLimit) throws CouldNotInsertDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n\n        ContentValues values = new ContentValues();\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_ALIAS.getName(), creditcard.getCardAlias());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_BANK_NAME.getName(), creditcard.getBankName());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_NUMBER.getName(), creditcard.getCardNumber());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CURRENCY.getName(), creditcard.getCurrency().getCode());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_TYPE.getName(), creditcard.getCardType().getCode());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CLOSING_DAY.getName(), creditcard.getClosingDay());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_DUE_DAY.getName(), creditcard.getDueDay());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_BACKGROUND.getName(), creditcard.getCreditCardBackground().getCode());\n\n        if(creditcard.getCardExpiration() != null)\n            values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_EXPIRATION.getName(), creditcard.getCardExpiration().getTimeInMillis());\n        else\n            values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_EXPIRATION.getName(), \"\");\n\n        long newRowId;\n        newRowId = db.insert(ExpenseManagerContract.CreditCardTable.TABLE_NAME, null, values);\n\n        if(newRowId == -1)\n            throw new CouldNotInsertDataException(\"There was a problem inserting the Credit Card: \" + creditcard.toString());\n        else {\n            //Insert first creditPeriod\n            insertCurrentCreditPeriod(newRowId, creditcard.getClosingDay(), firstCreditPeriodLimit);\n        }\n\n        return newRowId;\n\n    }\n\n    /**\n     * Inserts a creditPeriod associated to a creditCard, which engulfs the current date (today), given a closing date\n     * @param creditCardId the Id of the CreditCard to associate the CreditPeriod\n     * @param  closingDay the credit card's closing day\n     * @param creditPeriodLimit BigDecimal value of the currency limit of the period\n     */\n    public long insertCurrentCreditPeriod(long creditCardId, int closingDay, BigDecimal creditPeriodLimit) throws CouldNotInsertDataException {\n        //Insert first creditPeriod\n\n        // Set dates to be at midnight (start of day) today.\n        Calendar startDate = Calendar.getInstance();\n        startDate.set(Calendar.HOUR_OF_DAY, 0);\n        startDate.set(Calendar.MINUTE, 0);\n        startDate.set(Calendar.SECOND, 0);\n        startDate.set(Calendar.MILLISECOND, 0);\n        startDate.set(Calendar.DAY_OF_MONTH, closingDay);\n\n        Calendar endDate = Calendar.getInstance();\n        endDate.setTimeInMillis(startDate.getTimeInMillis());\n\n        //Check if closingDay if before or after today\n        if(closingDay <= Calendar.getInstance().get(Calendar.DAY_OF_MONTH))\n            endDate.add(Calendar.MONTH, 1);\n        else\n            startDate.add(Calendar.MONTH, -1);\n\n        endDate.add(Calendar.MILLISECOND, -1);\n\n        CreditPeriod creditPeriod = new CreditPeriod(CreditPeriod.PERIOD_NAME_COMPLETE, startDate, endDate, creditPeriodLimit);\n        return insertCreditPeriod(creditCardId, creditPeriod);\n    }\n\n    public long insertCreditPeriod(long creditCardId, CreditPeriod creditPeriod) throws CouldNotInsertDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n\n        ContentValues values = new ContentValues();\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_FOREIGN_KEY_CREDIT_CARD.getName(), creditCardId);\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_PERIOD_NAME_STYLE.getName(), creditPeriod.getPeriodNameStyle());\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_START_DATE.getName(), creditPeriod.getStartDate().getTimeInMillis());\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_END_DATE.getName(), creditPeriod.getEndDate().getTimeInMillis());\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_CREDIT_LIMIT.getName(), creditPeriod.getCreditLimit().toPlainString());\n\n\n        long newRowId = -1;\n        newRowId = db.insert(ExpenseManagerContract.CreditPeriodTable.TABLE_NAME, null, values);\n\n        if(newRowId == -1)\n            throw new CouldNotInsertDataException(\"There was a problem inserting the Credit Period: \" + creditPeriod.toString());\n\n        return newRowId;\n\n    }\n\n    public long insertExpense(int creditPeriodId, Expense expense) throws CouldNotInsertDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n\n        ContentValues values = getValuesFromExpense(expense);\n        values.put(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_FOREIGN_KEY_CREDIT_PERIOD.getName(), creditPeriodId);\n\n        long newRowId;\n        newRowId = db.insert(ExpenseManagerContract.ExpenseTable.TABLE_NAME, null, values);\n\n        if(newRowId == -1)\n            throw new CouldNotInsertDataException(\"There was a problem inserting the Expense: \" + expense.toString());\n\n        return newRowId;\n    }\n\n\n    public long insertPayment(int creditPeriodId, Payment payment) throws CouldNotInsertDataException {\n        SQLiteDatabase db = mDatabaseHelper.getWritableDatabase();\n\n        ContentValues values = new ContentValues();\n        values.put(ExpenseManagerContract.PaymentTable.COLUMN_NAME_FOREIGN_KEY_CREDIT_PERIOD.getName(), creditPeriodId);\n        values.put(ExpenseManagerContract.PaymentTable.COLUMN_NAME_DESCRIPTION.getName(), payment.getDescription());\n        values.put(ExpenseManagerContract.PaymentTable.COLUMN_NAME_AMOUNT.getName(), payment.getAmount().toPlainString());\n        values.put(ExpenseManagerContract.PaymentTable.COLUMN_NAME_CURRENCY.getName(), payment.getCurrency().getCode());\n        values.put(ExpenseManagerContract.PaymentTable.COLUMN_NAME_DATE.getName(), payment.getDate().getTimeInMillis());\n\n\n        long newRowId;\n        newRowId = db.insert(ExpenseManagerContract.ExpenseTable.TABLE_NAME, null, values);\n\n        if(newRowId == -1)\n            throw new CouldNotInsertDataException(\"There was a problem inserting the Payment: \" + payment.toString());\n\n        return newRowId;\n    }\n\n\n\n    /* Model to ContentValues */\n    private ContentValues getValuesFromExpense(Expense expense) {\n        ContentValues values = new ContentValues();\n        values.put(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_DESCRIPTION.getName(), expense.getDescription());\n        values.put(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_THUMBNAIL.getName(), expense.getThumbnail());\n        values.put(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_FULL_IMAGE_PATH.getName(), expense.getFullImagePath());\n        values.put(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_AMOUNT.getName(), expense.getAmount().toPlainString());\n        values.put(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_CURRENCY.getName(), expense.getCurrency().getCode());\n        values.put(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_DATE.getName(), expense.getDate().getTimeInMillis());\n        values.put(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_EXPENSE_CATEGORY.getName(), expense.getExpenseCategory().getCode());\n        values.put(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_EXPENSE_TYPE.getName(), expense.getExpenseType().getCode());\n        return values;\n    }\n\n    private ContentValues getValuesFromCreditCard(CreditCard creditCard) {\n        ContentValues values = new ContentValues();\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_ALIAS.getName(), creditCard.getCardAlias());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_BANK_NAME.getName(), creditCard.getBankName());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_NUMBER.getName(), creditCard.getCardNumber());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CURRENCY.getName(), creditCard.getCurrency().getCode());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_TYPE.getName(), creditCard.getCardType().getCode());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_EXPIRATION.getName(), creditCard.getCardExpiration().getTimeInMillis());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CLOSING_DAY.getName(), creditCard.getClosingDay());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_DUE_DAY.getName(), creditCard.getDueDay());\n        values.put(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_BACKGROUND.getName(), creditCard.getCreditCardBackground().getCode());\n        return values;\n    }\n\n    private ContentValues getValuesFromCreditPeriod(int creditCardId, CreditPeriod creditPeriod) {\n        ContentValues values = new ContentValues();\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_FOREIGN_KEY_CREDIT_CARD.getName(), creditCardId);\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_PERIOD_NAME_STYLE.getName(), creditPeriod.getPeriodNameStyle());\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_START_DATE.getName(), creditPeriod.getStartDate().getTimeInMillis());\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_END_DATE.getName(), creditPeriod.getEndDate().getTimeInMillis());\n        values.put(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_CREDIT_LIMIT.getName(), creditPeriod.getCreditLimit().toPlainString());\n        return values;\n    }\n\n\n    /* Cursor to Model */\n\n    private CreditCard getCreditCardFromCursor(Cursor cursor) {\n        int id = cursor.getInt(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable._ID));\n        String cardAlias = cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_ALIAS.getName()));\n        String bankName = cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_BANK_NAME.getName()));\n        String cardNumber = cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_NUMBER.getName()));\n        Currency currency = Currency.valueOf(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CURRENCY.getName())));\n        CreditCardType cardType = CreditCardType.valueOf(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_TYPE.getName())));\n        int closingDay = cursor.getInt(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CLOSING_DAY.getName()));\n        int dueDay = cursor.getInt(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_DUE_DAY.getName()));\n        CreditCardBackground creditCardBackground = CreditCardBackground.valueOf(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_BACKGROUND.getName())));\n\n\n        Calendar cardExpiration = null;\n        if(!cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_EXPIRATION.getName())).isEmpty()) {\n            cardExpiration = Calendar.getInstance();\n            cardExpiration.setTimeInMillis(cursor.getLong(cursor.getColumnIndex(ExpenseManagerContract.CreditCardTable.COLUMN_NAME_CARD_EXPIRATION.getName())));\n        }\n\n        return new CreditCard(id, cardAlias, bankName, cardNumber, currency, cardType, cardExpiration, closingDay, dueDay, creditCardBackground);\n    }\n\n\n    private CreditPeriod getCreditPeriodFromCursor(Cursor cursor) {\n        int id = cursor.getInt(cursor.getColumnIndex(ExpenseManagerContract.CreditPeriodTable._ID));\n        int periodNameStyle = cursor.getInt(cursor.getColumnIndex(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_PERIOD_NAME_STYLE.getName()));\n        Calendar startDate = Calendar.getInstance();\n        startDate.setTimeInMillis(cursor.getLong(cursor.getColumnIndex(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_START_DATE.getName())));\n        Calendar endDate = Calendar.getInstance();\n        endDate.setTimeInMillis(cursor.getLong(cursor.getColumnIndex(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_END_DATE.getName())));\n        BigDecimal creditLimit =  new BigDecimal(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.CreditPeriodTable.COLUMN_NAME_CREDIT_LIMIT.getName())));\n\n        return new CreditPeriod(id, periodNameStyle, startDate, endDate, creditLimit);\n    }\n\n\n    private Expense getExpenseFromCursor(Cursor cursor) {\n\n        int id = cursor.getInt(cursor.getColumnIndex(ExpenseManagerContract.ExpenseTable._ID));\n        String description = cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_DESCRIPTION.getName()));\n        byte[] image = cursor.getBlob(cursor.getColumnIndex(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_THUMBNAIL.getName()));\n        String fullImagePath = cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_FULL_IMAGE_PATH.getName()));\n        BigDecimal amount = new BigDecimal(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_AMOUNT.getName())));\n        Currency currency = Currency.valueOf(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_CURRENCY.getName())));\n        Calendar date = Calendar.getInstance();\n        date.setTimeInMillis(cursor.getLong(cursor.getColumnIndex(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_DATE.getName())));\n        ExpenseCategory expenseCategory = ExpenseCategory.valueOf(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_EXPENSE_CATEGORY.getName())));\n        ExpenseType expenseType = ExpenseType.valueOf(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.ExpenseTable.COLUMN_NAME_EXPENSE_TYPE.getName())));\n\n        return new Expense(id, description, image, fullImagePath, amount, currency, date, expenseCategory, expenseType);\n    }\n\n\n    private Payment getPaymentFromCursor(Cursor cursor) {\n\n        int id = cursor.getInt(cursor.getColumnIndex(ExpenseManagerContract.PaymentTable._ID));\n        String description = cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.PaymentTable.COLUMN_NAME_DESCRIPTION.getName()));\n        BigDecimal amount = new BigDecimal(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.PaymentTable.COLUMN_NAME_AMOUNT.getName())));\n        Currency currency = Currency.valueOf(cursor.getString(cursor.getColumnIndex(ExpenseManagerContract.PaymentTable.COLUMN_NAME_CURRENCY.getName())));\n        Calendar date = Calendar.getInstance();\n        date.setTimeInMillis(cursor.getLong(cursor.getColumnIndex(ExpenseManagerContract.PaymentTable.COLUMN_NAME_DATE.getName())));\n\n        return new Payment(id, description, amount, currency, date);\n    }\n}\napp/src/main/java/ve/com/abicelis/creditcardexpensemanager/model/CreditCard.java\npublic class CreditCard implements Serializable {\n\n    private int id;\n    private String cardAlias;\n    private String bankName;\n    private String cardNumber;\n    private Currency currency;\n    private CreditCardType cardType;\n    private Calendar cardExpiration;\n    private int closingDay;         // Fecha de corte: Fecha de cierre de operaciones del mes, para efectos de registros y cobros.\n    private int dueDay;             // Fecha Limite de Pago: Fecha máxima para el próximo pago sin generar incumplimiento e intereses de mora.\n    private CreditCardBackground creditCardBackground;\n\n\n    private Map<Integer, CreditPeriod> creditPeriods;\n\n    public CreditCard(String cardAlias, String bankName, String cardNumber, @NonNull Currency currency, @NonNull CreditCardType cardType, @NonNull Calendar cardExpiration, int closingDay, int dueDay, @NonNull CreditCardBackground creditCardBackground) {\n        this.cardAlias = cardAlias;\n        this.bankName = bankName;\n        this.cardNumber = cardNumber;\n        this.currency = currency;\n        this.cardType = cardType;\n\n        this.cardExpiration = Calendar.getInstance();\n        this.cardExpiration.setTimeZone(cardExpiration.getTimeZone());\n        this.cardExpiration.setTimeInMillis(cardExpiration.getTimeInMillis());\n\n        this.dueDay = dueDay;\n        this.closingDay = closingDay;\n        this.creditCardBackground = creditCardBackground;\n    }\n\n    public CreditCard(int id, String cardAlias, String bankName, String cardNumber, @NonNull Currency currency, @NonNull CreditCardType cardType, @NonNull Calendar cardExpiration, int closingDay, int dueDay, @NonNull CreditCardBackground creditCardBackground) {\n        this(cardAlias, bankName, cardNumber, currency, cardType, cardExpiration, closingDay, dueDay, creditCardBackground);\n        this.id = id;\n    }\n\n    public CreditCard(int id, String cardAlias, String bankName, String cardNumber, @NonNull Currency currency, @NonNull CreditCardType cardType, @NonNull Calendar cardExpiration, int closingDay, int dueDay, @NonNull CreditCardBackground creditCardBackground, @NonNull Map<Integer, CreditPeriod> creditPeriods) {\n        this(id, cardAlias, bankName, cardNumber, currency, cardType, cardExpiration, closingDay, dueDay, creditCardBackground);\n        this.creditPeriods = creditPeriods;\n    }\n\n\n\n    public int getId() {\n        return id;\n    }\n\n\n    public String getCardAlias() {\n        return cardAlias;\n    }\n\n    public void setCardAlias(String cardAlias) {\n        this.cardAlias = cardAlias;\n    }\n\n    public String getBankName() {\n        return bankName;\n    }\n\n    public void setBankName(String bankName) {\n        this.bankName = bankName;\n    }\n\n    public String getCardNumber() {\n        return cardNumber;\n    }\n\n    public void setCardNumber(String cardNumber) {\n        this.cardNumber = cardNumber;\n    }\n\n    public Currency getCurrency() {\n        return currency;\n    }\n\n    public void setCurrency(Currency currency) {\n        this.currency = currency;\n    }\n\n    public CreditCardType getCardType() {\n        return cardType;\n    }\n\n    public void setCardType(CreditCardType cardType) {\n        this.cardType = cardType;\n    }\n\n    public Calendar getCardExpiration() {\n        return cardExpiration;\n    }\n\n    public void setCardExpiration(Calendar cardExpiration) {\n        this.cardExpiration = Calendar.getInstance();\n        this.cardExpiration.setTimeZone(cardExpiration.getTimeZone());\n        this.cardExpiration.setTimeInMillis(cardExpiration.getTimeInMillis());\n    }\n\n    public String getShortCardExpirationString() {\n        if(cardExpiration == null)\n            return \"-/-\";\n\n        SimpleDateFormat formatter = new SimpleDateFormat(\"MM/yy\", Locale.getDefault());\n        return formatter.format(cardExpiration.getTime());\n    }\n\n    public String getLongCardExpirationString() {\n        if(cardExpiration == null)\n            return \"-\";\n\n        SimpleDateFormat formatter = new SimpleDateFormat(\"MMM dd, yyyy\", Locale.getDefault());\n        return formatter.format(cardExpiration.getTime());\n    }\n\n    public int getClosingDay() {\n        return closingDay;\n    }\n\n    public void setClosingDay(int closingDay) {\n        this.closingDay = closingDay;\n    }\n\n    public int getDueDay() {\n        return dueDay;\n    }\n\n    public void setDueDay(int dueDay) {\n        this.dueDay = dueDay;\n    }\n\n    public CreditCardBackground getCreditCardBackground() {\n        return creditCardBackground;\n    }\n\n    public Map<Integer, CreditPeriod> getCreditPeriods() {\n        return creditPeriods;\n    }\n\n    public void setCreditPeriods(Map<Integer, CreditPeriod> creditPeriods) {\n        this.creditPeriods = creditPeriods;\n    }\n\n    /**\n     * Returns a List of Credit Cards based on the number of existing CreditCardBackgrounds, instantiated with default values\n     * @return List<CreditCard>\n     */\n    public static List<CreditCard> getCreditCardBackgroundTypesList(Context context) {\n        List<CreditCard> creditCards = new ArrayList<>();\n\n        String defaultAlias = context.getResources().getString(R.string.activity_add_new_cc_alias);\n        String defaultBankName = context.getResources().getString(R.string.activity_add_new_cc_bank);\n        String defaultCardNumber = context.getResources().getString(R.string.activity_add_new_cc_number);\n        Calendar defaultExpiration = Calendar.getInstance();\n        defaultExpiration.add(Calendar.YEAR, 5);\n\n        for (CreditCardBackground c : CreditCardBackground.values()) {\n            creditCards.add(new CreditCard(defaultAlias, defaultBankName, defaultCardNumber, Currency.USD, CreditCardType.AMEX, defaultExpiration, 0, 0, c));\n        }\n\n        return creditCards;\n    }\n\n    @Override\n    public String toString() {\n        return  \"ID=\" + id + \"\\r\\n\" +\n                \" cardAlias=\" + cardAlias + \"\\r\\n\" +\n                \" cardNumber=\" + cardNumber + \"\\r\\n\" +\n                \" currency=\" + currency + \"\\r\\n\" +\n                \" cardType=\" + cardType + \"\\r\\n\" +\n                \" cardExpiration=\" + cardExpiration + \"\\r\\n\" +\n                \" closingDay=\" + closingDay + \"\\r\\n\" +\n                \" dueDay=\" + dueDay + \"\\r\\n\" +\n                \" creditPeriods=\" + creditPeriods;\n    }\n}\napp/src/main/java/ve/com/abicelis/creditcardexpensemanager/exceptions/CouldNotInsertDataException.java\npublic class CouldNotInsertDataException extends Exception {\n\n    public static final String DEFAULT_MESSAGE = \"There was a problem while inserting data into the database\";\n\n    public CouldNotInsertDataException(String message) {\n        super(message);\n    }\n\n    public CouldNotInsertDataException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n", "answers": ["        ExpenseManagerDAO dao = new ExpenseManagerDAO(this);"], "length": 3790, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "c44a1e83e9fde0b0a74c65a72921c5f8692fe870cbeebb50"}
{"input": "package com.tubitv.media.fsm.state_machine;\nimport android.arch.lifecycle.Lifecycle;\nimport android.support.annotation.NonNull;\nimport com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.Player;\nimport com.google.android.exoplayer2.SimpleExoPlayer;\nimport com.tubitv.media.controller.PlayerAdLogicController;\nimport com.tubitv.media.controller.PlayerUIController;\nimport com.tubitv.media.fsm.Input;\nimport com.tubitv.media.fsm.State;\nimport com.tubitv.media.fsm.callback.AdInterface;\nimport com.tubitv.media.fsm.callback.RetrieveAdCallback;\nimport com.tubitv.media.fsm.concrete.MakingAdCallState;\nimport com.tubitv.media.fsm.concrete.MakingPrerollAdCallState;\nimport com.tubitv.media.fsm.concrete.MoviePlayingState;\nimport com.tubitv.media.fsm.concrete.VpaidState;\nimport com.tubitv.media.fsm.concrete.factory.StateFactory;\nimport com.tubitv.media.helpers.Constants;\nimport com.tubitv.media.models.AdMediaModel;\nimport com.tubitv.media.models.AdRetriever;\nimport com.tubitv.media.models.CuePointsRetriever;\nimport com.tubitv.media.models.MediaModel;\nimport com.tubitv.media.utilities.ExoPlayerLogger;\nimport com.tubitv.media.utilities.PlayerDeviceUtils;\n\n\n/**\n * Created by allensun on 7/27/17.\n */\npublic abstract class FsmPlayer implements Fsm, RetrieveAdCallback, FsmAdController {\n\n    /**\n     * a wrapper class for player logic related component objects.\n     */\n    protected PlayerAdLogicController playerComponentController;\n    /**\n     * a wrapper class for player UI related objects\n     */\n    private PlayerUIController controller;\n    /**\n     * a generic call ad network class\n     */\n    private AdInterface adServerInterface;\n\n    /**\n     * information to use when retrieve ad from server\n     */", "context": "lib/src/main/java/com/tubitv/media/helpers/Constants.java\npublic class Constants {\n    public static final String FSMPLAYER_TESTING = \"FSM_LOGGING\";\n}\nlib/src/main/java/com/tubitv/media/fsm/callback/AdInterface.java\npublic interface AdInterface {\n\n    /**\n     * make call to network server to call ad\n     *\n     * @param retriever information to provide when retrieving ad\n     * @param callback  the callback to be notify\n     */\n    void fetchAd(AdRetriever retriever, RetrieveAdCallback callback);\n\n    void fetchQuePoint(CuePointsRetriever retriever, CuePointCallBack callBack);\n\n}\nlib/src/main/java/com/tubitv/media/utilities/ExoPlayerLogger.java\npublic class ExoPlayerLogger {\n\n    public static Boolean SHOW_LOGGING = true;\n\n    public static void d(String tag, String message) {\n        if (SHOW_LOGGING) {\n            // do something for a debug build\n            Log.d(tag, message);\n        }\n    }\n\n    public static void i(String tag, String message) {\n        if (SHOW_LOGGING) {\n            // do something for a debug build\n            Log.i(tag, message);\n        }\n    }\n\n    public static void w(String tag, String message) {\n        if (SHOW_LOGGING) {\n            // do something for a debug build\n            Log.w(tag, message);\n        }\n    }\n\n    public static void e(String tag, String message) {\n        if (SHOW_LOGGING) {\n            // do something for a debug build\n            Log.e(tag, message);\n        }\n    }\n\n    public static void v(String tag, String message) {\n        if (SHOW_LOGGING) {\n            // do something for a debug build\n            Log.v(tag, message);\n        }\n    }\n}\nlib/src/main/java/com/tubitv/media/fsm/concrete/MakingAdCallState.java\npublic class MakingAdCallState extends BaseState {\n\n    @Override\n    public State transformToState(Input input, StateFactory factory) {\n        switch (input) {\n            case AD_RECEIVED:\n                return factory.createState(ReceiveAdState.class);\n\n            case EMPTY_AD:\n                return null;\n\n            case MAKE_AD_CALL:\n                return factory.createState(MakingAdCallState.class);\n\n            case PRE_ROLL_AD_RECEIVED:\n                return factory.createState(AdPlayingState.class);\n        }\n\n        return null;\n    }\n\n    @Override\n    public void performWorkAndUpdatePlayerUI(@NonNull FsmPlayer fsmPlayer) {\n        super.performWorkAndUpdatePlayerUI(fsmPlayer);\n\n        if (isNull(fsmPlayer)) {\n            return;\n        }\n\n        fetchAd(fsmPlayer.getAdServerInterface(), fsmPlayer.getAdRetriever(), fsmPlayer);\n\n        //in the MadingAdCallState, no UI need to be updated.\n\n    }\n\n    private void fetchAd(AdInterface adInterface, AdRetriever retriever, RetrieveAdCallback callback) {\n        if (adInterface != null && retriever != null && callback != null) {\n            adInterface.fetchAd(retriever, callback);\n        } else {\n            ExoPlayerLogger.e(\"TAG\", \"fetchAd fail, adInterface or AdRetriever is empty\");\n        }\n    }\n}\nlib/src/main/java/com/tubitv/media/fsm/Input.java\npublic enum Input {\n\n    /**\n     * Only expect inputs of {@link com.tubitv.media.fsm.concrete.FetchCuePointState}\n     */\n    HAS_PREROLL_AD,\n    NO_PREROLL_AD,\n\n    /**\n     * Only expect inputs of {@link com.tubitv.media.fsm.concrete.MakingPrerollAdCallState}\n     */\n    PRE_ROLL_AD_RECEIVED,\n\n    /**\n     * Only expect inputs of {@link com.tubitv.media.fsm.concrete.MakingAdCallState}\n     */\n    AD_RECEIVED,\n    EMPTY_AD,\n\n    /**\n     * Only expect inputs of {@link com.tubitv.media.fsm.concrete.ReceiveAdState}\n     */\n    SHOW_ADS,\n\n    /**\n     * Only expect inputs of {@link com.tubitv.media.fsm.concrete.AdPlayingState}\n     */\n    NEXT_AD,\n    AD_CLICK,\n    AD_FINISH,\n    VPAID_MANIFEST,\n\n    /**\n     * Only expect inputs of {@link com.tubitv.media.fsm.concrete.VpaidState}\n     */\n    VPAID_FINISH,\n\n    /**\n     * Only expect inputs of {@link VastAdInteractionSandBoxState}\n     */\n    BACK_TO_PLAYER_FROM_VAST_AD,\n\n    /**\n     * Only expect inputs of {@link com.tubitv.media.fsm.concrete.MoviePlayingState}\n     */\n    MAKE_AD_CALL,\n    MOVIE_FINISH,\n\n    /**\n     * ERROR INPUT\n     */\n    ERROR,\n\n    INITIALIZE,\n}\nlib/src/main/java/com/tubitv/media/models/AdRetriever.java\npublic class AdRetriever {\n\n    private String videoId;\n\n    private String publisherId;\n\n    private long cubPoint;\n\n    public AdRetriever() {\n    }\n\n    public AdRetriever(String videoId, String publisherId, long cubPoint) {\n        this.videoId = videoId;\n        this.publisherId = publisherId;\n        this.cubPoint = cubPoint;\n    }\n\n    public String getVideoId() {\n        return videoId;\n    }\n\n    public void setVideoId(String videoId) {\n        this.videoId = videoId;\n    }\n\n    public String getPublisherId() {\n        return publisherId;\n    }\n\n    public void setPublisherId(String publisherId) {\n        this.publisherId = publisherId;\n    }\n\n    public long getCubPoint() {\n        return cubPoint;\n    }\n\n    public void setCubPoint(long cubPoint) {\n        this.cubPoint = cubPoint;\n    }\n}\nlib/src/main/java/com/tubitv/media/fsm/concrete/MoviePlayingState.java\npublic class MoviePlayingState extends BaseState {\n\n    @Override\n    public State transformToState(Input input, StateFactory factory) {\n\n        switch (input) {\n            case MAKE_AD_CALL:\n                return factory.createState(MakingAdCallState.class);\n\n            case MOVIE_FINISH:\n                return factory.createState(FinishState.class);\n        }\n\n        return null;\n    }\n\n    @Override\n    public void performWorkAndUpdatePlayerUI(@NonNull FsmPlayer fsmPlayer) {\n        super.performWorkAndUpdatePlayerUI(fsmPlayer);\n\n        if (isNull(fsmPlayer)) {\n            return;\n        }\n\n        stopAdandPlayerMovie(controller, componentController, movieMedia);\n    }\n\n    private void stopAdandPlayerMovie(PlayerUIController controller, PlayerAdLogicController componentController,\n            MediaModel movieMedia) {\n\n        SimpleExoPlayer adPlayer = controller.getAdPlayer();\n        SimpleExoPlayer moviePlayer = controller.getContentPlayer();\n\n        boolean shouldReprepareForSinglePlayer = PlayerDeviceUtils.useSinglePlayer() && controller.isPlayingAds;\n\n        //first remove the AdPlayer's listener and pause the player\n        adPlayer.removeAnalyticsListener(componentController.getAdPlayingMonitor());\n\n        if (shouldReprepareForSinglePlayer) {\n            adPlayer.setPlayWhenReady(false);\n        }\n\n        //then update the playerView with SimpleExoPlayer and Movie MediaModel\n        TubiExoPlayerView tubiExoPlayerView = (TubiExoPlayerView) controller.getExoPlayerView();\n        tubiExoPlayerView.setPlayer(moviePlayer, componentController.getTubiPlaybackInterface());\n        tubiExoPlayerView.setMediaModel(movieMedia);\n\n        //prepare the moviePlayer with data source and set it play\n\n        boolean haveResumePosition = controller.getMovieResumePosition() != C.TIME_UNSET;\n\n        boolean isPlayerIdle = moviePlayer.getPlaybackState() == Player.STATE_IDLE;\n\n        if (shouldReprepareForSinglePlayer || isPlayerIdle) {\n            moviePlayer.prepare(movieMedia.getMediaSource(), !haveResumePosition, false);\n            updatePlayerPosition(moviePlayer, controller);\n        }\n\n        moviePlayer.setPlayWhenReady(true);\n\n        controller.isPlayingAds = false;\n\n        hideVpaidNShowPlayer(controller);\n\n        //when return to the movie playing state, show the subtitle if necessary\n        if (shouldShowSubtitle()) {\n            ((TubiExoPlayerView) controller.getExoPlayerView()).getSubtitleView().setVisibility(View.VISIBLE);\n        }\n    }\n\n    private void updatePlayerPosition(SimpleExoPlayer moviePlayer, PlayerUIController controller) {\n\n        // if want to play movie from certain position when first open the movie\n        if (controller.hasHistory()) {\n            moviePlayer.seekTo(moviePlayer.getCurrentWindowIndex(), controller.getHistoryPosition());\n            controller.clearHistoryRecord();\n            return;\n        }\n\n        boolean haveResumePosition = controller.getMovieResumePosition() != C.TIME_UNSET;\n        if (haveResumePosition) {\n            moviePlayer.seekTo(moviePlayer.getCurrentWindowIndex(), controller.getMovieResumePosition());\n        }\n    }\n\n    private void hideVpaidNShowPlayer(final PlayerUIController controller) {\n\n        controller.getExoPlayerView().setVisibility(View.VISIBLE);\n\n        WebView vpaidEWebView = controller.getVpaidWebView();\n        if (vpaidEWebView != null) {\n            vpaidEWebView.setVisibility(View.GONE);\n            vpaidEWebView.loadUrl(VpaidClient.EMPTY_URL);\n            vpaidEWebView.clearHistory();\n        }\n    }\n\n    private boolean shouldShowSubtitle() {\n\n        TubiExoPlayerView view = (TubiExoPlayerView) controller.getExoPlayerView();\n\n        UserController controller = (UserController) view.getPlayerController();\n\n        if (controller.videoHasSubtitle.get() && controller.isSubtitleEnabled.get()) {\n            return true;\n        }\n\n        return false;\n    }\n\n}\nlib/src/main/java/com/tubitv/media/controller/PlayerAdLogicController.java\npublic class PlayerAdLogicController {\n\n    private AdPlayingMonitor adPlayingMonitor;\n\n    private PlaybackActionCallback playbackActionCallback;\n\n    private DoublePlayerInterface doublePlayerInterface;\n\n    private CuePointMonitor cuePointMonitor;\n\n    private VpaidClient vpaidClient;\n\n    public PlayerAdLogicController() {\n    }\n\n    public PlayerAdLogicController(@Nullable AdPlayingMonitor adPlayingMonitor,\n            @Nullable PlaybackActionCallback playbackActionCallback,\n            @Nullable DoublePlayerInterface doublePlayerInterface, @Nullable CuePointMonitor cuePointMonitor) {\n        this.adPlayingMonitor = adPlayingMonitor;\n        this.playbackActionCallback = playbackActionCallback;\n        this.doublePlayerInterface = doublePlayerInterface;\n        this.cuePointMonitor = cuePointMonitor;\n        this.vpaidClient = null;\n    }\n\n    public PlayerAdLogicController(@Nullable AdPlayingMonitor adPlayingMonitor,\n            @Nullable PlaybackActionCallback playbackActionCallback,\n            @Nullable DoublePlayerInterface doublePlayerInterface, @Nullable CuePointMonitor cuePointMonitor,\n            @Nullable VpaidClient vpaidClient) {\n        this.adPlayingMonitor = adPlayingMonitor;\n        this.playbackActionCallback = playbackActionCallback;\n        this.doublePlayerInterface = doublePlayerInterface;\n        this.cuePointMonitor = cuePointMonitor;\n        this.vpaidClient = vpaidClient;\n    }\n\n    public DoublePlayerInterface getDoublePlayerInterface() {\n        return doublePlayerInterface;\n    }\n\n    public void setDoublePlayerInterface(DoublePlayerInterface doublePlayerInterface) {\n        this.doublePlayerInterface = doublePlayerInterface;\n    }\n\n    public AdPlayingMonitor getAdPlayingMonitor() {\n        return adPlayingMonitor;\n    }\n\n    public void setAdPlayingMonitor(AdPlayingMonitor adPlayingMonitor) {\n        this.adPlayingMonitor = adPlayingMonitor;\n    }\n\n    public PlaybackActionCallback getTubiPlaybackInterface() {\n        return playbackActionCallback;\n    }\n\n    public void setTubiPlaybackInterface(PlaybackActionCallback playbackActionCallback) {\n        this.playbackActionCallback = playbackActionCallback;\n    }\n\n    public CuePointMonitor getCuePointMonitor() {\n        return cuePointMonitor;\n    }\n\n    public void setCuePointMonitor(CuePointMonitor cuePointMonitor) {\n        this.cuePointMonitor = cuePointMonitor;\n    }\n\n    @Nullable\n    public VpaidClient getVpaidClient() {\n        return vpaidClient;\n    }\n\n    public void setVpaidClient(@Nullable VpaidClient vpaidClient) {\n        this.vpaidClient = vpaidClient;\n    }\n}\nlib/src/main/java/com/tubitv/media/fsm/concrete/factory/StateFactory.java\npublic final class StateFactory {\n\n    /**\n     * map store singleton instance of every types of {@link State},\n     */\n    private final Map<Class, State> stateInstance = new HashMap<>();\n\n    /**\n     * the key is the default state, and value is the custom state.\n     */\n    private final Map<Class, Class> customStateType = new HashMap<>();\n\n    @Nullable\n    private synchronized State getCacheInstance(@NonNull Class type) {\n        return stateInstance.get(type);\n    }\n\n    private synchronized void setCacheInstance(@NonNull Class type, @NonNull State instance) {\n        stateInstance.put(type, instance);\n    }\n\n    /**\n     * convert the default {@link State} into custom State\n     *\n     * @param cla default state type\n     * @return the custom state type\n     */\n    @Nullable\n    private Class convertToCustomClass(@NonNull Class cla) {\n        return customStateType.get(cla);\n    }\n\n    /**\n     * Method should only be called right after initialization, before {@link #createState} ever been called for max state predictability.\n     *\n     * @param subClass must be the subclass of {@link com.tubitv.media.fsm.BaseState} to swap original to subclass\n     *                 Must be called before any createState method being called.\n     */\n    public void overrideStateCreation(@NonNull Class subClass) {\n\n        if (MakingAdCallState.class.isAssignableFrom(subClass)) {\n            customStateType.put(MakingAdCallState.class, subClass);\n\n        } else if (MoviePlayingState.class.isAssignableFrom(subClass)) {\n            customStateType.put(MoviePlayingState.class, subClass);\n\n        } else if (FinishState.class.isAssignableFrom(subClass)) {\n            customStateType.put(FinishState.class, subClass);\n\n        } else if (ReceiveAdState.class.isAssignableFrom(subClass)) {\n            customStateType.put(ReceiveAdState.class, subClass);\n\n        } else if (AdPlayingState.class.isAssignableFrom(subClass)) {\n            customStateType.put(AdPlayingState.class, subClass);\n\n        } else if (VpaidState.class.isAssignableFrom(subClass)) {\n            customStateType.put(VpaidState.class, subClass);\n\n        } else if (VastAdInteractionSandBoxState.class.isAssignableFrom(subClass)) {\n            customStateType.put(VastAdInteractionSandBoxState.class, subClass);\n\n        } else if (FetchCuePointState.class.isAssignableFrom(subClass)) {\n            customStateType.put(FetchCuePointState.class, subClass);\n\n        } else if (MakingPrerollAdCallState.class.isAssignableFrom(subClass)) {\n            customStateType.put(MakingPrerollAdCallState.class, subClass);\n\n        } else {\n            throw new IllegalStateException(\n                    String.valueOf(subClass.getName() + \"is not a base class of default State class \"));\n        }\n    }\n\n    @NonNull\n    public State createState(@NonNull Class classType) {\n\n        if (!State.class.isAssignableFrom(classType)) {\n            throw new IllegalStateException(\n                    String.valueOf(classType.getName() + \"is not a base class of default State class \"));\n        }\n\n        // null check if there is any custom state class. if there is,\n        Class finalClassType = convertToCustomClass(classType);\n\n        if (finalClassType == null) {\n            finalClassType = classType;\n        }\n\n        State buildState = getCacheInstance(finalClassType);\n\n        if (buildState == null) {\n            try {\n\n                Constructor<?> ctor = finalClassType.getConstructor();\n                buildState = (State) ctor.newInstance();\n\n                setCacheInstance(finalClassType, buildState);\n            } catch (NoSuchMethodException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n        return buildState;\n    }\n}\nlib/src/main/java/com/tubitv/media/models/MediaModel.java\npublic class MediaModel implements Serializable {\n\n    /**\n     * The url of the media\n     */\n    @NonNull\n    private final String videoUrl;\n\n    /**\n     * The title of the media to display\n     */\n    @Nullable\n    private final String mediaName;\n\n    /**\n     * The url of the artwork to display while loading\n     */\n    @Nullable\n    private final String artworkUrl;\n\n    /**\n     * The nullable subtitles that we sideload for the main media source\n     */\n    @Nullable\n    private final String subtitlesUrl;\n\n    /**\n     * The nullable click through url for this media if its an ad\n     *\n     * @see #isAd\n     */\n    @Nullable\n    private final String clickThroughUrl;\n\n    /**\n     * The media source representation of this model\n     */\n    private MediaSource mediaSource;\n\n    /**\n     * Whether this media is an ad or not\n     */\n    private boolean isAd;\n\n    /**\n     * Whether this media is an ad or not\n     */\n    private boolean isVpaid;\n\n    public MediaModel(@Nullable String mediaName, @NonNull String videoUrl, @Nullable String artworkUrl,\n            @Nullable String subtitlesUrl, @Nullable String clickThroughUrl, boolean isAd, boolean isVpaid) {\n        this.mediaName = mediaName;\n        this.videoUrl = videoUrl;\n        this.artworkUrl = artworkUrl;\n        this.subtitlesUrl = subtitlesUrl;\n        this.clickThroughUrl = clickThroughUrl;\n        this.isAd = isAd;\n        this.isVpaid = isVpaid;\n    }\n\n    public static MediaModel video(@NonNull String mediaName, @NonNull String videoUrl, @NonNull String artworkUrl,\n            @Nullable String subtitlesUrl) {\n        return new MediaModel(mediaName, videoUrl, artworkUrl, subtitlesUrl, null, false, false);\n    }\n\n    public static MediaModel ad(@NonNull String videoUrl, @Nullable String clickThroughUrl, boolean isVpaid) {\n        return new MediaModel(null, videoUrl, null, null, clickThroughUrl, true, isVpaid);\n    }\n\n    @Nullable\n    public String getMediaName() {\n        return mediaName;\n    }\n\n    @NonNull\n    public Uri getVideoUrl() {\n        return Uri.parse(videoUrl);\n    }\n\n    @Nullable\n    public Uri getArtworkUrl() {\n        return Uri.parse(artworkUrl);\n    }\n\n    @Nullable\n    public Uri getSubtitlesUrl() {\n        return subtitlesUrl != null ? Uri.parse(subtitlesUrl) : null;\n    }\n\n    @Nullable\n    public String getClickThroughUrl() {\n        return clickThroughUrl;\n    }\n\n    public boolean isAd() {\n        return isAd;\n    }\n\n    public String getMediaExtension() {\n        return \"m3u8\";\n    }\n\n    public MediaSource getMediaSource() {\n        return mediaSource;\n    }\n\n    public void setMediaSource(MediaSource mediaSource) {\n        this.mediaSource = mediaSource;\n    }\n\n    public boolean isVpaid() {\n        return isVpaid;\n    }\n}\nlib/src/main/java/com/tubitv/media/models/CuePointsRetriever.java\npublic class CuePointsRetriever {\n\n    private String videoId;\n\n    private String publisherId;\n\n    public CuePointsRetriever() {\n    }\n\n    public CuePointsRetriever(String videoId, String publisherId) {\n        this.videoId = videoId;\n        this.publisherId = publisherId;\n    }\n\n    public String getVideoId() {\n        return videoId;\n    }\n\n    public void setVideoId(String videoId) {\n        this.videoId = videoId;\n    }\n\n    public String getPublisherId() {\n        return publisherId;\n    }\n\n    public void setPublisherId(String publisherId) {\n        this.publisherId = publisherId;\n    }\n}\nlib/src/main/java/com/tubitv/media/models/AdMediaModel.java\npublic class AdMediaModel {\n\n    private List<MediaModel> listOfAds;\n\n    public AdMediaModel(@NonNull List<MediaModel> listOfAds) {\n        this.listOfAds = listOfAds;\n    }\n\n    @Nullable\n    public MediaModel nextAD() {\n        return listOfAds != null && listOfAds.size() > 0 ? listOfAds.get(0) : null;\n    }\n\n    public List<MediaModel> getListOfAds() {\n        return listOfAds;\n    }\n\n    public void popFirstAd() {\n        if (listOfAds != null && listOfAds.size() > 0) {\n            listOfAds.remove(0);\n        }\n    }\n\n    public int nubmerOfAd() {\n        if (listOfAds == null) {\n            return 0;\n        } else {\n            return listOfAds.size();\n        }\n    }\n\n}\nlib/src/main/java/com/tubitv/media/fsm/concrete/MakingPrerollAdCallState.java\npublic class MakingPrerollAdCallState extends BaseState {\n\n    @Nullable\n    @Override\n    public State transformToState(@NonNull Input input, @NonNull StateFactory factory) {\n\n        switch (input) {\n            case PRE_ROLL_AD_RECEIVED:\n                return factory.createState(AdPlayingState.class);\n        }\n\n        return null;\n    }\n\n    @Override\n    public void performWorkAndUpdatePlayerUI(@NonNull FsmPlayer fsmPlayer) {\n        super.performWorkAndUpdatePlayerUI(fsmPlayer);\n\n        // don't do any UI work.\n        if (isNull(fsmPlayer)) {\n            return;\n        }\n\n        //update the AdRetriever for pre_roll cue point, which is 0.\n        if (controller.hasHistory()) {\n            fsmPlayer.updateCuePointForRetriever(controller.getHistoryPosition());\n        } else {\n            fsmPlayer.updateCuePointForRetriever(0);\n        }\n        fetchAd(fsmPlayer.getAdServerInterface(), fsmPlayer.getAdRetriever(), fsmPlayer);\n    }\n\n    private void fetchAd(AdInterface adInterface, AdRetriever retriever, RetrieveAdCallback callback) {\n        if (adInterface != null && retriever != null && callback != null) {\n            adInterface.fetchAd(retriever, callback);\n        } else {\n            ExoPlayerLogger.e(FSMPLAYER_TESTING, \"fetchAd fail, adInterface or AdRetriever is empty\");\n        }\n    }\n}\nlib/src/main/java/com/tubitv/media/fsm/callback/RetrieveAdCallback.java\npublic interface RetrieveAdCallback {\n\n    void onReceiveAd(AdMediaModel mediaModels);\n\n    void onError();\n\n    void onEmptyAdReceived();\n}\nlib/src/main/java/com/tubitv/media/fsm/State.java\npublic interface State {\n\n    /**\n     * let the state to examine itself in a constant time line to detects any input that can change the state.\n     */\n    @Nullable\n    State transformToState(@NonNull Input input, @NonNull StateFactory factory);\n\n    /**\n     * once the fsm changes states, update player's UI components.\n     *\n     * @param fsmPlayer the state machine itself that contains the UI and Business logic parts.\n     */\n    void performWorkAndUpdatePlayerUI(@NonNull FsmPlayer fsmPlayer);\n\n}\nlib/src/main/java/com/tubitv/media/utilities/PlayerDeviceUtils.java\npublic class PlayerDeviceUtils {\n    private static final String TAG = PlayerDeviceUtils.class.getSimpleName();\n    private static final String XIAOMI_MANUFACTURER = \"Xiaomi\";\n    private static final String MI_BOX_DEVICE = \"once\";\n    private static final String AMAZON_FEATURE_FIRE_TV = \"amazon.hardware.fire_tv\";\n    private static Boolean sIsTVDevice = null;\n\n    public static boolean isTVDevice(final Context context) {\n        if (sIsTVDevice == null) {\n            UiModeManager uiModeManager = (UiModeManager) context.getSystemService(UI_MODE_SERVICE);\n            sIsTVDevice = uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION;\n\n            if (!sIsTVDevice) { // We also check fire tv\n                sIsTVDevice = context.getPackageManager().hasSystemFeature(AMAZON_FEATURE_FIRE_TV);\n            }\n        }\n        return sIsTVDevice;\n    }\n\n    /**\n     * Check if we should use one player instance instead of two to handle video and ads playback\n     * Single player instance will only use content player without initializing ads player\n     * Single player instance will re-buffer every time when we switch between MediaSource\n     */\n    public static boolean useSinglePlayer() {\n        // Turn it on for all TV devices\n        if (sIsTVDevice) {\n            return true;\n        }\n\n        // Use single player instance for Mi Box, since for 2.8.3 exoplayer it doesn't support more than one player instance\n        // When we start second player instance and prepare, we got insufficiant resource error and player stuck\n        if (XIAOMI_MANUFACTURER.equals(Util.MANUFACTURER) && MI_BOX_DEVICE.equals(Util.DEVICE)) {\n            return true;\n        }\n        return false;\n    }\n}\nlib/src/main/java/com/tubitv/media/controller/PlayerUIController.java\npublic class PlayerUIController {\n\n    public boolean isPlayingAds = false;\n\n    private SimpleExoPlayer contentPlayer;\n\n    private SimpleExoPlayer adPlayer;\n\n    private WebView vpaidWebView;\n\n    private View exoPlayerView;\n\n    private int adResumeWindow = C.INDEX_UNSET;\n\n    private long adResumePosition = C.TIME_UNSET;\n\n    private int movieResumeWindow = C.INDEX_UNSET;\n\n    private long movieResumePosition = C.TIME_UNSET;\n\n    private boolean hasHistory = false;\n\n    private long historyPosition = C.TIME_UNSET;\n\n    public PlayerUIController() {\n    }\n\n    public PlayerUIController(@Nullable SimpleExoPlayer contentPlayer, @Nullable SimpleExoPlayer adPlayer,\n            @Nullable WebView vpaidWebView, @Nullable View exoPlayerView) {\n        this.contentPlayer = contentPlayer;\n        this.adPlayer = adPlayer;\n        this.vpaidWebView = vpaidWebView;\n        this.exoPlayerView = exoPlayerView;\n    }\n\n    public SimpleExoPlayer getContentPlayer() {\n        return contentPlayer;\n    }\n\n    public void setContentPlayer(SimpleExoPlayer contentPlayer) {\n        this.contentPlayer = contentPlayer;\n    }\n\n    public SimpleExoPlayer getAdPlayer() {\n        // We'll reuse content player to play ads for single player instance case\n        if (PlayerDeviceUtils.useSinglePlayer()) {\n            return contentPlayer;\n        }\n        return adPlayer;\n    }\n\n    public void setAdPlayer(SimpleExoPlayer adPlayer) {\n        this.adPlayer = adPlayer;\n    }\n\n    public WebView getVpaidWebView() {\n        return vpaidWebView;\n    }\n\n    public void setVpaidWebView(WebView vpaidWebView) {\n        this.vpaidWebView = vpaidWebView;\n    }\n\n    public View getExoPlayerView() {\n        return exoPlayerView;\n    }\n\n    public void setExoPlayerView(View exoPlayerView) {\n        this.exoPlayerView = exoPlayerView;\n    }\n\n    /**\n     * This is set when user want to begin the movie from current position\n     *\n     * @param pos\n     */\n    public void setPlayFromHistory(long pos) {\n        hasHistory = true;\n        historyPosition = pos;\n    }\n\n    public boolean hasHistory() {\n        return hasHistory;\n    }\n\n    public long getHistoryPosition() {\n        return historyPosition;\n    }\n\n    public void clearHistoryRecord() {\n        hasHistory = false;\n        historyPosition = C.TIME_UNSET;\n    }\n\n    public void setAdResumeInfo(int window, long position) {\n        adResumeWindow = window;\n        adResumePosition = position;\n    }\n\n    public void clearAdResumeInfo() {\n        setAdResumeInfo(C.INDEX_UNSET, C.TIME_UNSET);\n    }\n\n    public void setMovieResumeInfo(int window, long position) {\n        movieResumeWindow = window;\n        movieResumePosition = position;\n    }\n\n    public void clearMovieResumeInfo() {\n        setMovieResumeInfo(C.INDEX_UNSET, C.TIME_UNSET);\n    }\n\n    public int getAdResumeWindow() {\n        return adResumeWindow;\n    }\n\n    public long getAdResumePosition() {\n        return adResumePosition;\n    }\n\n    public int getMovieResumeWindow() {\n        return movieResumeWindow;\n    }\n\n    public long getMovieResumePosition() {\n        return movieResumePosition;\n    }\n\n    public static class Builder {\n\n        private SimpleExoPlayer contentPlayer = null;\n\n        private SimpleExoPlayer adPlayer = null;\n\n        private WebView vpaidWebView = null;\n\n        private View exoPlayerView = null;\n\n        public Builder() {\n        }\n\n        public Builder setContentPlayer(SimpleExoPlayer contentPlayer) {\n            this.contentPlayer = contentPlayer;\n            return this;\n        }\n\n        public Builder setAdPlayer(SimpleExoPlayer adPlayer) {\n            this.adPlayer = adPlayer;\n            return this;\n        }\n\n        public Builder setVpaidWebView(WebView vpaidWebView) {\n            this.vpaidWebView = vpaidWebView;\n            return this;\n        }\n\n        public Builder setExoPlayerView(View exoPlayerView) {\n            this.exoPlayerView = exoPlayerView;\n            return this;\n        }\n\n        public PlayerUIController build() {\n\n            return new PlayerUIController(contentPlayer, adPlayer, vpaidWebView, exoPlayerView);\n        }\n    }\n\n}\nlib/src/main/java/com/tubitv/media/fsm/concrete/VpaidState.java\npublic class VpaidState extends BaseState {\n\n    @Override\n    public State transformToState(Input input, StateFactory factory) {\n\n        switch (input) {\n            case VPAID_FINISH:\n                return factory.createState(MoviePlayingState.class);\n\n            case VPAID_MANIFEST:\n                return factory.createState(VpaidState.class);\n\n            case NEXT_AD:\n                return factory.createState(AdPlayingState.class);\n        }\n        return null;\n    }\n\n    //TODO: API level lower that certain, will disable vpaid.\n    @Override\n    public void performWorkAndUpdatePlayerUI(@NonNull FsmPlayer fsmPlayer) {\n        super.performWorkAndUpdatePlayerUI(fsmPlayer);\n\n        if (isNull(fsmPlayer)) {\n            return;\n        }\n\n        pausePlayerAndSHowVpaid(controller, componentController, fsmPlayer, adMedia);\n    }\n\n    private void pausePlayerAndSHowVpaid(PlayerUIController controller, PlayerAdLogicController componentController,\n            FsmPlayer fsmPlayer, AdMediaModel adMedia) {\n\n        ExoPlayer moviePlayer = controller.getContentPlayer();\n\n        if (moviePlayer != null && moviePlayer.getPlayWhenReady()) {\n            moviePlayer.setPlayWhenReady(false);\n        }\n\n        ExoPlayer adPlayer = controller.getAdPlayer();\n        if (adPlayer != null && adPlayer.getPlayWhenReady()) {\n            adPlayer.setPlayWhenReady(false);\n        }\n\n        VpaidClient client = componentController.getVpaidClient();\n\n        if (client != null) {\n\n            MediaModel ad = adMedia.nextAD();\n\n            if (ad == null) {\n                ExoPlayerLogger.w(Constants.FSMPLAYER_TESTING, \"Vpaid ad is null\");\n                return;\n            }\n\n            client.init(ad);\n\n            controller.getExoPlayerView().setVisibility(View.INVISIBLE);\n\n            WebView vpaidWebView = controller.getVpaidWebView();\n\n            vpaidWebView.setVisibility(View.VISIBLE);\n            vpaidWebView.bringToFront();\n            vpaidWebView.invalidate();\n\n            vpaidWebView.addJavascriptInterface(client, \"TubiNativeJSInterface\");\n            vpaidWebView.loadUrl(fsmPlayer.getVPAID_END_POINT());\n\n            //hide the subtitle view when vpaid is playing\n            ((TubiExoPlayerView) controller.getExoPlayerView()).getSubtitleView().setVisibility(View.INVISIBLE);\n        } else {\n            ExoPlayerLogger.w(Constants.FSMPLAYER_TESTING, \"VpaidClient is null\");\n        }\n\n    }\n\n}\n", "answers": ["    private AdRetriever adRetriever;"], "length": 2715, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "cbeeacca7dd3282ff5b99092e6d16314f09ad0f42b1ab069"}
{"input": "import doctest\nimport functools\nimport unittest\nimport arxpy.smt.types\nfrom arxpy.bitvector.core import Constant, Variable\nfrom arxpy.bitvector.operation import (\n    BvNot, BvComp, RotateLeft, RotateRight, Concat, Repeat, ZeroExtend, Ite)\nfrom arxpy.smt.types import bv2pysmt as _bv2pysmt\nfrom pysmt import environment\n\"\"\"Tests for the Types module.\"\"\"\n\n\n\n\n\nclass TestConversion(unittest.TestCase):\n    \"\"\"Tests of the bv2pysmt function.\"\"\"\n\n    def setUp(self):\n        self.env = environment.reset_env()\n\n    def test_bv2pysmt(self):\n        bv2pysmt = functools.partial(_bv2pysmt, env=self.env)\n        fm = self.env.formula_manager\n        tm = self.env.type_manager\n\n        bx, by = Variable(\"x\", 8), Variable(\"y\", 8)\n        b1x, b1y = Variable(\"x1\", 1), Variable(\"y1\", 1)\n        b6x, b6y = Variable(\"x6\", 6), Variable(\"y6\", 6)\n        px, py = bv2pysmt(bx), bv2pysmt(by)\n        p1x, p1y = bv2pysmt(b1x, True), bv2pysmt(b1y, True)\n        p6x, p6y = bv2pysmt(b6x), bv2pysmt(b6y)\n\n        self.assertEqual(bv2pysmt(Constant(0, 8)), fm.BV(0, 8))\n        self.assertEqual(px, fm.Symbol(\"x\", tm.BVType(8)))\n        self.assertEqual(p1x, fm.Symbol(\"x1\", tm.BOOL()))\n\n        self.assertEqual(bv2pysmt(~bx), fm.BVNot(px))\n        self.assertEqual(bv2pysmt(~b1x, True), fm.Not(p1x))\n        self.assertEqual(bv2pysmt(bx & by), fm.BVAnd(px, py))\n        self.assertEqual(bv2pysmt(b1x & b1y, True), fm.And(p1x, p1y))\n        self.assertEqual(bv2pysmt(bx | by), fm.BVOr(px, py))\n        self.assertEqual(bv2pysmt(b1x | b1y, True), fm.Or(p1x, p1y))\n        self.assertEqual(bv2pysmt(bx ^ by), fm.BVXor(px, py))\n        self.assertEqual(bv2pysmt(b1x ^ b1y, True), fm.Xor(p1x, p1y))\n\n        self.assertEqual(bv2pysmt(BvComp(bx, by)), fm.BVComp(px, py))\n        self.assertEqual(bv2pysmt(BvComp(bx, by), True), fm.Equals(px, py))\n        self.assertEqual(bv2pysmt(BvNot(BvComp(bx, by))),\n                         fm.BVNot(fm.BVComp(px, py)))\n        self.assertEqual(bv2pysmt(BvNot(BvComp(bx, by)), True),\n                         fm.Not(fm.Equals(px, py)))\n\n        self.assertEqual(bv2pysmt(bx < by), fm.BVULT(px, py))\n        self.assertEqual(bv2pysmt(bx <= by), fm.BVULE(px, py))\n        self.assertEqual(bv2pysmt(bx > by), fm.BVUGT(px, py))\n        self.assertEqual(bv2pysmt(bx >= by), fm.BVUGE(px, py))\n\n        self.assertEqual(bv2pysmt(bx << by), fm.BVLShl(px, py))\n        self.assertEqual(bv2pysmt(bx >> by), fm.BVLShr(px, py))\n        self.assertEqual(bv2pysmt(RotateLeft(bx, 1)), fm.BVRol(px, 1))\n        self.assertEqual(bv2pysmt(RotateRight(bx, 1)), fm.BVRor(px, 1))\n\n        def zext(pysmt_type, offset):\n            # zero_extend reduces to Concat\n            return fm.BVConcat(fm.BV(0, offset), pysmt_type)\n\n        self.assertEqual(bv2pysmt(b6x << b6y, strict_shift=True),\n                         fm.BVExtract(fm.BVLShl(zext(p6x, 2), zext(p6y, 2)), 0, 5))\n        self.assertEqual(bv2pysmt(RotateRight(b6x, 1), strict_shift=True),\n                         fm.BVConcat(fm.BVExtract(p6x, 0, 0), fm.BVExtract(p6x, 1, 5)))\n\n        self.assertEqual(bv2pysmt(bx[4:2]), fm.BVExtract(px, 2, 4))\n        self.assertEqual(bv2pysmt(Concat(bx, by)), fm.BVConcat(px, py))\n\n", "context": "arxpy/bitvector/operation.py\nclass Repeat(Operation):\n    \"\"\"Concatenate a bit-vector with itself a given number of times.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import Repeat\n        >>> Repeat(Constant(0x1, 4), 4)\n        0x1111\n        >>> Repeat(Variable(\"x\", 8), 4)\n        x :: x :: x :: x\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, i):\n        return i >= 1\n\n    @classmethod\n    def output_width(cls, x, i):\n        return i * x.width\n\n    @classmethod\n    def eval(cls, x, i):\n        if i == 1:\n            return x\n        else:\n            # noinspection PyTypeChecker\n            return functools.reduce(Concat, itertools.repeat(x, i))\narxpy/bitvector/operation.py\nclass Concat(Operation):\n    \"\"\"Concatenation operation.\n\n    Given the bit-vectors :math:`(x_{n-1}, \\dots, x_0)` and\n    :math:`(y_{m-1}, \\dots, y_0)`, ``Concat(x, y)`` returns the bit-vector\n    :math:`(x_{n-1}, \\dots, x_0, y_{m-1}, \\dots, y_0)`.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import Concat\n        >>> Concat(Constant(0x12, 8), Constant(0x345, 12))\n        0x12345\n        >>> Concat(Variable(\"x\", 8), Variable(\"y\", 8))\n        x :: y\n\n    \"\"\"\n\n    arity = [2, 0]\n    is_symmetric = False\n    infix_symbol = \"::\"\n\n    @classmethod\n    def output_width(cls, x, y):\n        return x.width + y.width\n\n    @classmethod\n    def eval(cls, x, y):\n        def doit(x, y):\n            \"\"\"Concatenation when both operands are int.\"\"\"\n            return int(x.bin() + y.bin()[2:], 2)\n\n        if isinstance(x, core.Constant) and isinstance(y, core.Constant):\n            return core.Constant(doit(x, y), cls.output_width(x, y))\n        elif isinstance(x, core.Constant) and isinstance(y, Concat) and \\\n                isinstance(y.args[0], core.Constant):\n            return Concat(Concat(x, y.args[0]), y.args[1])\n        elif isinstance(y, core.Constant) and isinstance(x, Concat) and \\\n                isinstance(x.args[1], core.Constant):\n            return Concat(x.args[0], Concat(x.args[1], y))\n        elif isinstance(x, Extract) and isinstance(y, Extract):\n            # x[5:4] concat x[3:2] = x[5:2]\n            if x.args[0] == y.args[0] and x.args[2] == y.args[1] + 1:\n                return Extract(x.args[0], x.args[1], y.args[2])\narxpy/smt/types.py\ndef bv2pysmt(bv, boolean=False, strict_shift=False, env=None):\n    \"\"\"Convert a bit-vector type to a pySMT type.\n\n    Args:\n        bv: the bit-vector `Term` to convert\n        boolean: if True, boolean pySMT types (e.g., `pysmt.shortcuts.Bool`) are used instead of\n            bit-vector pySMT types (e.g., `pysmt.shortcuts.BV`).\n        strict_shift: if `True`, shifts and rotation by non-power-of-two offsets\n            are power of two are translated to pySMT's shifts and\n            rotation directly.\n        env: a `pysmt.environment.Environment`; if not specified, a new pySMT environment is created.\n    ::\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.smt.types import bv2pysmt\n        >>> s = bv2pysmt(Constant(0b00000001, 8), boolean=False)\n        >>> s, s.get_type()\n        (1_8, BV{8})\n        >>> x, y = Variable(\"x\", 8), Variable(\"y\", 8)\n        >>> s = bv2pysmt(x)\n        >>> s, s.get_type()\n        (x, BV{8})\n        >>> s = bv2pysmt(x +  y)\n        >>> s, s.get_type()\n        ((x + y), BV{8})\n        >>> s = bv2pysmt(x <=  y)\n        >>> s, s.get_type()\n        ((x u<= y), Bool)\n        >>> s = bv2pysmt(x[4: 2])\n        >>> s, s.get_type()\n        (x[2:4], BV{3})\n\n    \"\"\"\n    msg = \"unknown conversion of {} to a pySMT type\".format(type(bv).__name__)\n\n    if env is None:\n        env = environment.reset_env()\n    fm = env.formula_manager\n\n    if isinstance(bv, int):\n        return bv\n\n    pysmt_bv = None\n\n    if isinstance(bv, core.Variable):\n        if boolean:\n            assert bv.width == 1\n            pysmt_bv = fm.Symbol(bv.name, env.type_manager.BOOL())\n        else:\n            pysmt_bv = fm.Symbol(bv.name, env.type_manager.BVType(bv.width))\n\n    elif isinstance(bv, core.Constant):\n        if boolean:\n            assert bv.width == 1\n            pysmt_bv = fm.Bool(bool(bv))\n        else:\n            pysmt_bv = fm.BV(bv.val, bv.width)\n\n    elif isinstance(bv, operation.Operation):\n        # only 1st layer can return a boolean\n        # Equals and Ite work well with BV, the rest don't\n\n        if issubclass(type(bv), extraop.PartialOperation):\n            raise NotImplementedError(\"PartialOperation is not yet supported\")\n\n        if type(bv) == operation.BvNot:\n            if boolean:\n                assert bv.width == 1\n                args = [bv2pysmt(a, True, strict_shift, env) for a in bv.args]\n                pysmt_bv = fm.Not(*args)\n            else:\n                args = [bv2pysmt(a, False, strict_shift, env) for a in bv.args]\n                pysmt_bv = fm.BVNot(*args)\n\n        elif type(bv) == operation.BvAnd:\n            if boolean:\n                assert bv.width == 1\n                args = [bv2pysmt(a, True, strict_shift, env) for a in bv.args]\n                pysmt_bv = fm.And(*args)\n            else:\n                args = [bv2pysmt(a, False, strict_shift, env) for a in bv.args]\n                pysmt_bv = fm.BVAnd(*args)\n\n        elif type(bv) == operation.BvOr:\n            if boolean:\n                assert bv.width == 1\n                args = [bv2pysmt(a, True, strict_shift, env) for a in bv.args]\n                pysmt_bv = fm.Or(*args)\n            else:\n                args = [bv2pysmt(a, False, strict_shift, env) for a in bv.args]\n                pysmt_bv = fm.BVOr(*args)\n        elif type(bv) == operation.BvXor:\n            if boolean:\n                assert bv.width == 1\n                args = [bv2pysmt(a, True, strict_shift, env) for a in bv.args]\n                pysmt_bv = fm.Xor(*args)\n            else:\n                args = [bv2pysmt(a, False, strict_shift, env) for a in bv.args]\n                pysmt_bv = fm.BVXor(*args)\n        elif type(bv) == operation.Ite:\n            args = [None for _ in range(len(bv.args))]\n            # fm.Ite requires a Boolean type for args[0] but\n            # bv2pysmt(bv.args[0], True, ...)  caused an error\n            # (if args[0] is BvComp, it can be further optimized)\n            args[0] = bv2pysmt(bv.args[0], False, strict_shift, env)\n            if args[0].get_type().is_bv_type():\n                args[0] = fm.Equals(args[0], fm.BV(1, 1))\n            if boolean:\n                assert bv.width == 1\n                args[1:] = [bv2pysmt(a, True, strict_shift, env) for a in bv.args[1:]]\n            else:\n                args[1:] = [bv2pysmt(a, False, strict_shift, env) for a in bv.args[1:]]\n            pysmt_bv = fm.Ite(*args)\n        else:\n            args = [bv2pysmt(a, False, strict_shift, env) for a in bv.args]\n\n            if type(bv) == operation.BvComp:\n                if boolean:\n                    pysmt_bv = fm.Equals(*args)\n                else:\n                    pysmt_bv = fm.BVComp(*args)\n\n            elif type(bv) == operation.BvUlt:\n                pysmt_bv = fm.BVULT(*args)\n\n            elif type(bv) == operation.BvUle:\n                pysmt_bv = fm.BVULE(*args)\n\n            elif type(bv) == operation.BvUgt:\n                pysmt_bv = fm.BVUGT(*args)\n\n            elif type(bv) == operation.BvUge:\n                pysmt_bv = fm.BVUGE(*args)\n\n            elif boolean:\n                raise ValueError(\"{} cannot return a boolean type\".format(type(bv).__name__))\n\n            elif type(bv) in [operation.BvShl, operation.BvLshr]:\n                if not strict_shift or _is_power_of_2(args[0].bv_width()):\n                    if type(bv) == operation.BvShl:\n                        pysmt_bv = fm.BVLShl(*args)\n                    elif type(bv) == operation.BvLshr:\n                        pysmt_bv = fm.BVLShr(*args)\n                else:\n                    x, r = bv.args\n                    offset = 0\n                    while not _is_power_of_2(x.width):\n                        x = operation.ZeroExtend(x, 1)\n                        r = operation.ZeroExtend(r, 1)\n                        offset += 1\n\n                    shift = bv2pysmt(type(bv)(x, r), False, strict_shift, env)\n                    pysmt_bv = fm.BVExtract(shift, end=shift.bv_width() - offset - 1)\n\n            elif type(bv) == operation.RotateLeft:\n                if not strict_shift or _is_power_of_2(args[0].bv_width()):\n                    pysmt_bv = fm.BVRol(*args)\n                else:\n                    # Left hand side width must be a power of 2\n                    x, r = bv.args\n                    n = x.width\n                    pysmt_bv = bv2pysmt(operation.Concat(x[n - r - 1:], x[n - 1: n - r]),\n                                    False, strict_shift, env)\n\n            elif type(bv) == operation.RotateRight:\n                if not strict_shift or _is_power_of_2(args[0].bv_width()):\n                    pysmt_bv = fm.BVRor(*args)\n                else:\n                    # Left hand side width must be a power of 2\n                    x, r = bv.args\n                    n = x.width\n                    pysmt_bv = bv2pysmt(operation.Concat(x[r - 1:], x[n - 1: r]),\n                                    False, strict_shift, env)\n\n            elif type(bv) == operation.Extract:\n                # pySMT Extract(bv, start, end)\n                pysmt_bv = fm.BVExtract(args[0], args[2], args[1])\n\n            elif type(bv) == operation.Concat:\n                pysmt_bv = fm.BVConcat(*args)\n\n            elif type(bv) == operation.ZeroExtend:\n                pysmt_bv = fm.BVZExt(*args)\n\n            elif type(bv) == operation.Repeat:\n                pysmt_bv = args[0].BVRepeat(args[1])\n\n            elif type(bv) == operation.BvNeg:\n                pysmt_bv = fm.BVNeg(*args)\n\n            elif type(bv) == operation.BvAdd:\n                pysmt_bv = fm.BVAdd(*args)\n\n            elif type(bv) == operation.BvSub:\n                pysmt_bv = fm.BVSub(*args)\n\n            elif type(bv) == operation.BvMul:\n                pysmt_bv = fm.BVMul(*args)\n\n            elif type(bv) == operation.BvUdiv:\n                pysmt_bv = fm.BVUDiv(*args)\n\n            elif type(bv) == operation.BvUrem:\n                pysmt_bv = fm.BVURem(*args)\n\n            else:\n                bv2 = bv.doit()\n                assert bv.width == bv2.width, \"{} == {}\\n{}\\n{}\".format(bv.width, bv2.width, bv.vrepr(), bv2.vrepr())\n                if bv != bv2:  # avoid cyclic loop\n                    pysmt_bv = bv2pysmt(bv2, boolean=boolean, strict_shift=strict_shift, env=env)\n                else:\n                    raise NotImplementedError(\"(doit) \" + msg)\n\n    elif isinstance(bv, difference.Difference):\n        pysmt_bv = bv2pysmt(bv.val, boolean, strict_shift, env)\n\n    if pysmt_bv is not None:\n        try:\n            pysmt_bv_width = pysmt_bv.bv_width()\n        except (AssertionError, TypeError):\n            pysmt_bv_width = 1  # boolean type\n\n        assert bv.width == pysmt_bv_width\n        return pysmt_bv\n    else:\n        raise NotImplementedError(msg)\narxpy/bitvector/operation.py\nclass ZeroExtend(Operation):\n    \"\"\"Extend with zeroes preserving the unsigned value.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import ZeroExtend\n        >>> ZeroExtend(Constant(0x12, 8), 4)\n        0x012\n        >>> ZeroExtend(Variable(\"x\", 8), 4)\n        0x0 :: x\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    alt_name = \"ext\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, i):\n        return i >= 0\n\n    @classmethod\n    def output_width(cls, x, i):\n        return x.width + i\n\n    @classmethod\n    def eval(cls, x, i):\n        if i == 0:\n            return x\n        else:\n            return Concat(core.Constant(0, i), x)\narxpy/bitvector/core.py\nclass Variable(basic.Atom, Term):\n    \"\"\"Represent bit-vector variables.\n\n    Args:\n        name: the name of the variable.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> Variable(\"x\", 12)\n        x\n        >>> Variable(\"x\", 12).vrepr()\n        \"Variable('x', width=12)\"\n\n    \"\"\"\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute hash.\"\"\"\n        return self.name, self.width\n\n    # def __call__(self, *args):\n    #     from sympy.core.function as function\n    #     return function.UndefinedFunction(self.name, self.width)(*args)\n\n    # end Symbol\n\n    __slots__ = ['_name']\n\n    def __new__(cls, name, width):\n        assert isinstance(name, str)\n        obj = Term.__new__(cls, width=width)\n        obj._name = name\n\n        return obj\n\n    @property\n    def name(self):\n        \"\"\"The name of the variable.\"\"\"\n        return self._name\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the variable.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + bin_enc(self.width)\narxpy/bitvector/operation.py\nclass BvNot(Operation):\n    \"\"\"Bitwise negation operation.\n\n    It overrides the operator ~. See `Operation` for more information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import BvNot\n        >>> BvNot(Constant(0b1010101, 7))\n        0b0101010\n        >>> ~Constant(0b1010101, 7)\n        0b0101010\n        >>> ~Variable(\"x\", 8)\n        ~x\n\n    \"\"\"\n\n    arity = [1, 0]\n    is_symmetric = False\n    unary_symbol = \"~\"\n\n    @classmethod\n    def output_width(cls, x):\n        return x.width\n\n    @classmethod\n    def eval(cls, x):\n        def doit(x, width):\n            \"\"\"NOT operation when the operand is int.\"\"\"\n            return ~x % (2 ** width)\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), x.width), x.width)\n        elif isinstance(x, BvNot):\n            return x.args[0]\n        # # De Morgan's laws (disabled, all op equal precedence)\n        # if isinstance(x, BvAnd):\n        #     return BvOr(BvNot(x.args[0]), BvNot(x.args[1]))\n        # elif isinstance(x, BvOr):\n        #     return BvAnd(BvNot(x.args[0]), BvNot(x.args[1]))\narxpy/bitvector/operation.py\nclass Ite(Operation):\n    \"\"\"If-then-else operator.\n\n    ``Ite(b, x, y)`` returns ``x`` if ``b == 0b1`` and ``y`` otherwise.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import Ite\n        >>> Ite(Constant(0, 1), Constant(0b11, 2), Constant(0b00, 2))\n        0b00\n        >>> Ite(Constant(1, 1), Constant(0x1, 4), Constant(0x0, 4))\n        0x1\n\n    \"\"\"\n\n    arity = [3, 0]\n    is_symmetric = False\n\n    @classmethod\n    def condition(cls, b, x, y):\n        return b.width == 1 and x.width == y.width\n\n    @classmethod\n    def output_width(cls, b, x, y):\n        return x.width\n\n    @classmethod\n    def eval(cls, b, x, y):\n        if b == core.Constant(1, 1):\n            return x\n        elif b == core.Constant(0, 1):\n            return y\narxpy/bitvector/operation.py\nclass BvComp(Operation):\n    \"\"\"Equality operator.\n\n    Provides Automatic Constant Conversion. See `Operation` for more\n    information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import BvComp\n        >>> BvComp(Constant(1, 8), Constant(2, 8))\n        0b0\n        >>> BvComp(Constant(1, 8), 2)\n        0b0\n        >>> BvComp(Constant(1, 8), Variable(\"y\", 8))\n        0x01 == y\n\n    The operator == is used for exact structural equality testing and\n    it returns either True or False. On the other hand, BvComp\n    performs symbolic equality testing and it leaves the relation unevaluated\n    if it cannot prove the objects are equal (or unequal).\n\n        >>> Variable(\"x\", 8) == Variable(\"y\", 8)\n        False\n        >>> BvComp(Variable(\"x\", 8), Variable(\"y\", 8))  # symbolic equality\n        x == y\n\n    \"\"\"\n\n    arity = [2, 0]\n    is_symmetric = True\n    is_simple = True\n    infix_symbol = \"==\"\n\n    @classmethod\n    def condition(cls, x, y):\n        return x.width == y.width\n\n    @classmethod\n    def output_width(cls, x, y):\n        return 1\n\n    @classmethod\n    def eval(cls, x, y):\n        zero = core.Constant(0, 1)\n        one = core.Constant(1, 1)\n\n        if x is y:\n            return one\n        elif isinstance(x, core.Constant) and isinstance(y, core.Constant):\n            return one if x.val == y.val else zero\narxpy/bitvector/operation.py\nclass RotateRight(Operation):\n    \"\"\"Circular right rotation operation.\n\n    It provides Automatic Constant Conversion. See `Operation` for more\n    information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateRight\n        >>> RotateRight(Constant(150, 8), 3)\n        0xd2\n        >>> RotateRight(Variable(\"x\", 8), 3)\n        x >>> 3\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \">>>\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Right cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val & mask) >> r) | (val << (width - r) & mask)\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/bitvector/operation.py\nclass RotateLeft(Operation):\n    \"\"\"Circular left rotation operation.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateLeft\n        >>> RotateLeft(Constant(150, 8), 2)\n        0x5a\n        >>> RotateLeft(Variable(\"x\", 8), 2)\n        x <<< 2\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \"<<<\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Left cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val << r) & mask) | ((val & mask) >> (width - r))\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/bitvector/core.py\nclass Constant(basic.Atom, Term):\n    \"\"\"Represent bit-vector constants.\n\n    Bit-vector constants are interpreted as unsigned integers in base 2,\n    that is, a bit-vector :math:`(x_{n-1}, \\dots, x_1, x_0)` represents\n    the non-negative integer :math:`x_0 + 2 x_1 + \\dots + 2^{n-1} x_{n-1}`.\n\n    Args:\n        val: the integer value.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Constant\n        >>> Constant(3, 12)\n        0x003\n        >>> Constant(0b11, 12)\n        0x003\n        >>> Constant(0x003, 12)\n        0x003\n        >>> Constant(3, 12).vrepr()\n        'Constant(0b000000000011, width=12)'\n\n    \"\"\"\n\n    def __int__(self):\n        return self.val\n\n    def __hash__(self):\n        return super().__hash__()\n\n    def __eq__(self, other):\n        \"\"\"Override == operator.\"\"\"\n        if isinstance(other, int):\n            return self.val == other\n        elif isinstance(other, Constant) and self.width == other.width:\n            return self.val == other.val\n        else:\n            return False\n\n    # def __index__(self):\n    #     \"\"\"Return an int to be used inside a slice [ : : ].\"\"\"\n    #     return self.int\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute its hash.\"\"\"\n        return self.val, self.width\n\n    @classmethod\n    def class_key(cls):\n        \"\"\"Return the key (identifier) of the class for sorting.\"\"\"\n        return 1, 0, cls.__name__\n\n    # end Integer\n\n    __slots__ = [\"_val\"]\n\n    def __new__(cls, val, width):\n        assert isinstance(val, int) and 0 <= val < 2 ** width\n        obj = Term.__new__(cls, width=width)\n        obj._val = val\n        return obj\n\n    def __bool__(self):\n        if self.width == 1:\n            return self == Constant(1, 1)\n        else:\n            raise AttributeError(\"only 1-bit constants implement bool()\")\n\n    @property\n    def val(self):\n        \"\"\"The integer represented by the bit-vector constant.\"\"\"\n        return self._val\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the constant.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + log2(int(self) + 1) + bin_enc(self.width)\n\n    def bin(self):\n        \"\"\"Return the binary representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).bin())\n            0b0011\n            >>> print(Constant(4, 6).bin())\n            0b000100\n\n        \"\"\"\n        width = self.width + 2  # 2 due to '0b'\n        return format(self.val, r'0=#{}b'.format(width))\n\n    def hex(self):\n        \"\"\"Return the hexadecimal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).hex())\n            0x3\n\n        \"\"\"\n        assert self.width % 4 == 0\n        width = (self.width // 4) + 2\n        return format(self.val, '0=#{}x'.format(width))\n\n    def oct(self):\n        \"\"\"Return the octal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(4, 6).oct())\n            0o04\n\n        \"\"\"\n        assert self.width % 3 == 0\n        width = (self.width // 3) + 2\n        return format(self.val, '0=#{}o'.format(width))\n", "answers": ["        self.assertEqual(bv2pysmt(ZeroExtend(bx, 2)), zext(px, 2))"], "length": 2534, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "ffec24014c6eb244b321380e67b69e0c927a2190d241b3c4"}
{"input": "package jme3_ext_xbuf.mergers;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport org.slf4j.Logger;\nimport com.jme3.scene.Node;\nimport jme3_ext_xbuf.Merger;\nimport jme3_ext_xbuf.XbufContext;\nimport jme3_ext_xbuf.mergers.relations.Linker;\nimport jme3_ext_xbuf.mergers.relations.RefData;\nimport jme3_ext_xbuf.mergers.relations.linkers.AnimationToSpatial;\nimport jme3_ext_xbuf.mergers.relations.linkers.CustomParamToMaterial;\nimport jme3_ext_xbuf.mergers.relations.linkers.CustomParamToSpatial;\nimport jme3_ext_xbuf.mergers.relations.linkers.GeometryToNode;\nimport jme3_ext_xbuf.mergers.relations.linkers.LightToGeometry;\nimport jme3_ext_xbuf.mergers.relations.linkers.MaterialToGeometry;\nimport jme3_ext_xbuf.mergers.relations.linkers.NodeToNode;\nimport jme3_ext_xbuf.mergers.relations.linkers.PhysicsToSpatial;\nimport jme3_ext_xbuf.mergers.relations.linkers.SkeletonToSpatial;\nimport lombok.Getter;\nimport xbuf.Datas.Data;\nimport xbuf.Relations.Relation;\n\n\n\n\n\npublic class RelationsMerger implements Merger{\n\tprotected @Getter final MaterialsMerger matMerger;\n\tprotected @Getter final Collection<Linker> linkers;\n\n\tpublic RelationsMerger(MaterialsMerger mm){\n\t\tmatMerger=mm;\n\t\tlinkers=new LinkedList<Linker>();", "context": "jme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/linkers/CustomParamToMaterial.java\n@ExtensionMethod({jme3_ext_xbuf.ext.PrimitiveExt.class})\n@Slf4j\npublic class CustomParamToMaterial implements Linker{\n\n\t@Override\n\tpublic boolean doLink(RelationsMerger loader,RefData data, Logger log) {\n\t\tCustomParamList op1=getRef1(data,CustomParamList.class,log);\n\t\tMaterial op2=getRef2(data,Material.class,log);\n\t\tif(op1==null||op2==null) return false;\n\t\tfor(CustomParam p:op1.getParamsList())merge(loader,p,op2);\n\t\treturn true;\n\t}\n\n\tprotected Material merge(RelationsMerger loader,CustomParam p, Material dst) {\n\t\tString name=p.getName();\n\t\tSystem.err.println(\"set .....\" + name);\n\t\tswitch(p.getValueCase()){\n\t\t\tcase VBOOL:\n\t\t\t\tdst.setBoolean(name,p.getVbool());\n\t\t\t\tbreak;\n\t\t\tcase VCOLOR:\n\t\t\t\tdst.setColor(name,p.getVcolor().toJME());\n\t\t\t\tbreak;\n\t\t\tcase VFLOAT:\n\t\t\t\tdst.setFloat(name,p.getVfloat());\n\t\t\t\tbreak;\n\t\t\tcase VINT:\n\t\t\t\tdst.setInt(name,p.getVint());\n\t\t\t\tbreak;\n\t\t\tcase VMAT4:\n\t\t\t\tdst.setMatrix4(name,p.getVmat4().toJME());\n\t\t\t\tbreak;\n\t\t\tcase VQUAT:\n\t\t\t\tQuaternion q = p.getVquat().toJME();\n\t\t\t\tdst.setVector4(name,new Vector4f(q.getX(), q.getY(), q.getZ(), q.getW()));\n\t\t\t\tbreak;\n\t\t\tcase VTEXTURE:\n\t\t\t\tdst.setTexture(name,loader.getMatMerger().getValue(p.getVtexture()));\n\t\t\t\tbreak;\n\t\t\tcase VVEC2:\n\t\t\t\tdst.setVector2(name,p.getVvec2().toJME());\n\t\t\t\tbreak;\n\t\t\tcase VVEC3:\n\t\t\t\tdst.setVector3(name,p.getVvec3().toJME());\n\t\t\t\tbreak;\n\t\t\tcase VVEC4:\n\t\t\t\tdst.setVector4(name,p.getVvec4().toJME());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog.warn(\"Material doesn't support parameter : {} of type {}\",name,p.getValueCase().name());\n\t\t}\n\t\treturn dst;\n\t}\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/Merger.java\npublic interface Merger{\n\tpublic void apply(Data src, Node root, XbufContext context,Logger log);\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/linkers/CustomParamToSpatial.java\n@ExtensionMethod({jme3_ext_xbuf.ext.PrimitiveExt.class})\n@Slf4j\npublic class CustomParamToSpatial implements Linker{\n\n\t@Override\n\tpublic boolean doLink(RelationsMerger loader,RefData data, Logger log) {\n\t\tCustomParamList op1=getRef1(data,CustomParamList.class,log);\n\t\tSpatial op2=getRef2(data,Spatial.class,log);\n\t\tif(op1==null||op2==null) return false;\n\t\tfor(CustomParam p:op1.getParamsList())merge(loader,p,op2);\n\t\treturn true;\n\t}\n\n\tprotected Spatial merge(RelationsMerger loader,CustomParam p, Spatial dst) {\n\t\tString name=p.getName();\n\t\tswitch(p.getValueCase()){\n\t\t\tcase VALUE_NOT_SET:\n\t\t\t\tdst.setUserData(name,null);\n\t\t\t\tbreak;\n\t\t\tcase VBOOL:\n\t\t\t\tdst.setUserData(name,p.getVbool());\n\t\t\t\tbreak;\n\t\t\tcase VCOLOR:\n\t\t\t\tdst.setUserData(name,p.getVcolor().toJME());\n\t\t\t\tbreak;\n\t\t\tcase VFLOAT:\n\t\t\t\tdst.setUserData(name,p.getVfloat());\n\t\t\t\tbreak;\n\t\t\tcase VINT:\n\t\t\t\tdst.setUserData(name,p.getVint());\n\t\t\t\tbreak;\n\t\t\tcase VMAT4:\n\t\t\t\tdst.setUserData(name,p.getVmat4().toJME());\n\t\t\t\tbreak;\n\t\t\tcase VQUAT:\n\t\t\t\tdst.setUserData(name,p.getVquat().toJME());\n\t\t\t\tbreak;\n\t\t\tcase VSTRING:\n\t\t\t\tdst.setUserData(name,p.getVstring());\n\t\t\t\tbreak;\n\t\t\tcase VTEXTURE:\n\t\t\t\tdst.setUserData(name,loader.getMatMerger().getValue(p.getVtexture()));\n\t\t\t\tbreak;\n\t\t\tcase VVEC2:\n\t\t\t\tdst.setUserData(name,p.getVvec2().toJME());\n\t\t\t\tbreak;\n\t\t\tcase VVEC3:\n\t\t\t\tdst.setUserData(name,p.getVvec3().toJME());\n\t\t\t\tbreak;\n\t\t\tcase VVEC4:\n\t\t\t\tdst.setUserData(name,p.getVvec4().toJME());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog.warn(\"Material doesn't support parameter : {} of type {}\",name,p.getValueCase().name());\n\t\t}\n\t\treturn dst;\n\t}\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/linkers/MaterialToGeometry.java\npublic class MaterialToGeometry  implements Linker {\n\n\t@Override\n\tpublic boolean doLink(RelationsMerger loader, RefData data, Logger log) {\n\t\tMaterial op1=getRef1(data,Material.class,log);\n\t\tGeometry op2=getRef2(data,Geometry.class,log);\n\t\tif(op1==null||op2==null) return false;\n\t\tif(op2.getControl(SkeletonControl.class)!=null){\n\t\t\top1=op1.clone();\n//\t\t\tdata.context.put(\"G~\"+data.ref1+\"~cloned~\"+System.currentTimeMillis(),op1,data.ref1);\n//\t\t}else{\n//\t\t\tString refusage=\"G~usage~\"+data.ref1;\n//\t\t\tint n=(int)Optional.ofNullable(data.context.get(refusage)).orElse(0);\n//\t\t\tdata.context.put(refusage,n++);\n\t\t}\n\t\top2.setMaterial(op1);\n\t\treturn true;\n\t}\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/linkers/AnimationToSpatial.java\npublic class AnimationToSpatial implements Linker{\n\t@Override\n\tpublic boolean doLink(RelationsMerger loader,RefData data, Logger log) {\n\t\tXbufAnimation op1=getRef1(data,XbufAnimation.class,log);\n\t\tSpatial op2=getRef2(data,Spatial.class,log);\n\t\tif(op1==null||op2==null)return false;\n\t\tAnimControl c=op2.getControl(AnimControl.class);\n\t\tif(c==null){\n\t\t\tSkeletonControl sc=op2.getControl(SkeletonControl.class);\n\t\t\tc=sc!=null?new AnimControl(sc.getSkeleton()):new AnimControl();\n\t\t\top2.addControl(c);\n\t\t}\n\t\tc.addAnim(op1.toJME(c.getSkeleton()));\n\t\treturn true;\n\t}\n\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/linkers/NodeToNode.java\npublic class NodeToNode implements Linker{\n\n\t@Override\n\tpublic boolean doLink(RelationsMerger loader, RefData data, Logger log) {\n\t\tNode op1=getRef1(data,Node.class,log);\n\t\tNode op2=getRef2(data,Node.class,log);\n\t\tif(op1==null||op2==null) return false;\n\t\top1.attachChild(op2);\n\t\treturn true;\n\t}\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/linkers/GeometryToNode.java\npublic class GeometryToNode implements Linker{\n\n\t@Override\n\tpublic boolean doLink(RelationsMerger loader, RefData data, Logger log) {\n\t\tGeometry op1=getRef1(data,Geometry.class,log);\n\t\tNode op2=getRef2(data,Node.class,log);\n\t\tif(op1==null||op2==null) return false;\n\n\t\t// If already attached, clone geom, and add it to the context. Create also a link from the original one, this is used for other relations. (material for instance)\n\t\tif(op1.getParent()!=null){\n\t\t\top1=op1.clone(false);\n\t\t\tdata.context.put(\"G~\"+data.ref1+\"~cloned~\"+System.currentTimeMillis(),op1,data.ref1);\n\t\t}\n\t\top2.attachChild(op1);\n\n\t\treturn true;\n\t}\n\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/RefData.java\n@AllArgsConstructor\npublic class RefData {\n\tpublic String ref1,ref2;\n\tpublic Data src;\n\tpublic Node root;\n\tpublic XbufContext context;\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/linkers/SkeletonToSpatial.java\n@ExtensionMethod({jme3_ext_xbuf.ext.AnimControlExt.class})\npublic class SkeletonToSpatial implements Linker{\n\t// see http://hub.jmonkeyengine.org/t/skeletoncontrol-or-animcontrol-to-host-skeleton/31478/4\n\n\t@Override\n\tpublic boolean doLink(RelationsMerger loader, RefData data, Logger log) {\n\t\tObject op1=getRef1(data,Geometry.class,log);\n\t\tObject op2=getRef2(data,Skeleton.class,log);\n\n\t\tif(op1==null||op2==null){\n\t\t\top2=getRef1(data,Skeleton.class,log);\n\t\t\top1=getRef2(data,Node.class,log);\n\t\t}\n\n\t\tif(op1==null||op2==null) return false;\n\t\tSpatial v=(Spatial)op1;\n\t\tSkeleton sk=(Skeleton)op2;\n\n\t\t// TODO: update skel w/o remove\n\t\tv.removeControl(SkeletonControl.class);\n\n\t\tSkeletonControl skc=new SkeletonControl(sk);\n\t\tv.addControl(skc);\n\n\t\tboolean atLeastOne=false;\n\t\tfor(int i=0;i<v.getNumControls();i++){\n\t\t\tControl c=v.getControl(i);\n\t\t\tif( c instanceof AnimControl) {\n\t\t\t\tatLeastOne=true;\n\t\t\t\t((AnimControl)c).setSkeleton(sk);\n\t\t\t}\n\t\t}\n\n\t\t// always add AnimControl else NPE when SkeletonControl.clone\n\t\tif(!atLeastOne)v.addControl(new AnimControl(sk));\n\n\t\tcloneMatWhenNeeded((Spatial)op1,data,log);\n\t\treturn true;\n\t}\n\n\tprivate void cloneMatWhenNeeded(Spatial op2, RefData data, Logger log) {\n\t\top2.depthFirstTraversal(s -> {\n\t\t\tif(s instanceof Geometry){\n\t\t\t\tMaterial m=((Geometry)s).getMaterial();\n\t\t\t\tString matref=data.context.idOf(m);\n\t\t\t\tif(matref==null){ // should never happen!\n\t\t\t\t\tlog.error(\"Mat is not referred?\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n//\t\t\t\tString refusage=\"G~usage~\"+matref;\n//\t\t\t\tint n=(int)Optional.ofNullable(data.context.get(refusage)).orElse(0);\n//\t\t\t\tif(n>1){\n\t\t\t\t\tMaterial clone=m.clone();\n//\t\t\t\t\tdata.context.put(\"G~\"+matref+\"~cloned~\"+System.currentTimeMillis(),clone,matref);\n\t\t\t\t\ts.setMaterial(clone);\n//\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/linkers/LightToGeometry.java\npublic class LightToGeometry implements Linker{\n\n\t@Override\n\tpublic boolean doLink(RelationsMerger loader, RefData data, Logger log) {\n\t\tLight op1=getRef1(data,Light.class,log);\n\t\tSpatial op2=getRef2(data,Spatial.class,log);\n\t\tif(op1==null||op2==null) return false;\n\t\tif(op2 instanceof Geometry)\tlog.warn(\"Do you really want to add this light to a Geometry? [{}]\",data.ref1);\n\n\t\tif(data.context.getSettings().useLightControls()){\n\t\t\tXbufLightControl xbuflc=new XbufLightControl();\n\t\t\txbuflc.setLight(op1);\n\t\t\top2.addControl(xbuflc);\n\t\t\tdata.root.addLight(op1);\n\t\t}else{\n\t\t\top2.addLight(op1);\n\t\t}\n\n\t\treturn true;\n\t}\n\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/linkers/PhysicsToSpatial.java\n@Slf4j\n@ExtensionMethod({jme3_ext_xbuf.ext.PrimitiveExt.class})\npublic class PhysicsToSpatial implements Linker{\n\n\t@Override\n\tpublic boolean doLink(RelationsMerger rloader, RefData data, Logger log) {\n\t\tif(loadRB(rloader,data,log)) return true;\n\t\treturn false;\n\t}\n\n\tprotected boolean loadRB(RelationsMerger rloader, RefData data, Logger log) {\n\t\tRigidBody op1=getRef1(data,RigidBody.class,log);\n\t\tSpatial op2=getRef2(data,Spatial.class,log);\n\t\tif(op1==null||op2==null) return false;\n\t\tPhysicsLoader<?,?> loader=data.context.getSettings().getPhysicsLoader();\n\t\tif(loader!=null){\n\t\t\tSavable pc=loader.load(data.context.getSettings(),op2,op1);\n\t\t\tlog.debug(\"Load rigidbody {}\",data.ref1);\n\t\t\tif(pc!=null&&pc instanceof Control){\n\t\t\t\top2.addControl((Control)pc);\n\t\t\t\tString linkRef=\"G~slink4phy~\"+System.currentTimeMillis()+\"~\"+data.ref1;\n\t\t\t\tdata.context.put(linkRef,op2,data.ref1);\n\t\t\t\tapplyCTs(op2,data.ref1,data.context,data.root);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprotected void applyCTs(Spatial phy1S, String phy1Ref, XbufContext ctx, Node root) {\n\t\tCollection<Constraint> constraints=ctx.get(\"G~constraints\");\n\t\tif(constraints!=null){\n\t\t\tfor(byte i=0;i<2;i++){\n//\t\t\t\tfor(Constraint c:constraints){\n\t\t\t\tfor(Iterator<Constraint> c_i=constraints.iterator();c_i.hasNext();){\n\t\t\t\t\tConstraint c=c_i.next();\n\t\t\t\t\tif(!(i==0?c.getARef():c.getBRef()).equals(phy1Ref)) continue;\n\t\t\t\t\tString phy2Ref=i==1?c.getARef():c.getBRef();\n\t\t\t\t\tif(ctx.get(phy2Ref)==null){\n\t\t\t\t\t\tlog.debug(\"Found constraint element {}, second element is missing... skip...\",phy1Ref);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlog.debug(\"Found constraint elements {} - {}\",phy1Ref,phy2Ref);\n\n\t\t\t\t\tList<String> linked=ctx.linkedRefs(phy2Ref);\n\t\t\t\t\tfor(String l:linked){\n\t\t\t\t\t\tif(l.startsWith(\"G~slink4phy~\")){\n\t\t\t\t\t\t\tSpatial phy2S=ctx.get(l);\n\t\t\t\t\t\t\tSpatial a, b;\n\t\t\t\t\t\t\tif(i==1){// Reorder\n\t\t\t\t\t\t\t\ta=phy2S;\n\t\t\t\t\t\t\t\tb=phy1S;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ta=phy1S;\n\t\t\t\t\t\t\t\tb=phy2S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyCT(c,a,b,ctx,root);\n\t\t\t\t\t\t\t// Remove consumed constraint (Good idea??)\n\t\t\t\t\t\t\tc_i.remove();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tlog.debug(\"Constraints map not found.\");\n\t\t}\n\t}\n\n\tprotected void applyCT(Constraint ct, Spatial a, Spatial b, XbufContext ctx, Node root) {\n\t\t// Parse constraint\n\t\tConstraintData ct_data=null;\n\t\tif(ct.hasGeneric()){\n\t\t\tConstraintGeneric xbuf_generic_ct=ct.getGeneric();\n\n\t\t\tGenericConstraint generic_ct=new GenericConstraint();\n\t\t\tgeneric_ct.pivotA=xbuf_generic_ct.getPivotA().toJME();\n\t\t\tgeneric_ct.pivotB=xbuf_generic_ct.getPivotB().toJME();\n\t\t\tgeneric_ct.pivotA=xbuf_generic_ct.getPivotA().toJME();\n\n\t\t\tgeneric_ct.upperAngularLimit=xbuf_generic_ct.getUpperAngularLimit().toJME();\n\t\t\tgeneric_ct.lowerAngularLimit=xbuf_generic_ct.getLowerAngularLimit().toJME();\n\n\t\t\tgeneric_ct.upperLinearLimit=xbuf_generic_ct.getUpperLinearLimit().toJME();\n\t\t\tgeneric_ct.lowerLinearLimit=xbuf_generic_ct.getLowerLinearLimit().toJME();\n\t\t\tgeneric_ct.disableCollisionsBetweenLinkedNodes=xbuf_generic_ct.getDisableCollisions();\n\t\t\tct_data=generic_ct;\n\t\t} // else if ... [Only one type.]\n\n\n\t\tif(ct_data==null){\n\t\t\tlog.warn(\"Constraint {} not supported\",ct);\n\t\t\treturn;\n\t\t}\n\t\ttry{\n\t\t\tlog.debug(\"Store constraint {} [{}-{}] in scene\",ct_data,a,b);\n\t\t\tSpatial constraint_node=XbufPhysicsLoader.storeConstraintInScene(ctx.getSettings(),a,b,ct_data);\n\t\t\troot.attachChild(constraint_node);\n\t\t}catch(Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/mergers/relations/Linker.java\npublic interface Linker{\n\tpublic boolean doLink(RelationsMerger loader,RefData data, Logger log);\n\n\n}\njme3_xbuf_loader/src/main/java/jme3_ext_xbuf/XbufContext.java\n@SuppressWarnings(\"unchecked\")\npublic class XbufContext {\n//\tpublic Logger log=LoggerFactory.getLogger(\"Xbuf\");\n\tprivate Map<String,Object> storage=new HashMap<String,Object> ();\n\tprivate Map<String,List<String>> links=new HashMap<String,List<String>>();\n\tprivate XbufKey settings=new XbufKey(\"default\");\n\n\tpublic synchronized void setSettings(XbufKey s){\n\t\tsettings=s;\n\t}\n\n\tpublic synchronized XbufKey getSettings(){\n\t\treturn settings;\n\t}\n\n\tpublic synchronized <T> T get(String ref){\n\t\treturn (T)storage.get(ref);\n\t}\n\n\n\tpublic synchronized String idOf(Object val){\n\t\tfor(Entry<String,Object> entry:storage.entrySet()){\n\t\t\tif(entry.getValue()==val)return entry.getKey();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic synchronized <T> T put(String ref,Object val){\n\t\tT t=(T)storage.put(ref,val);\n\t\treturn t;\n\t}\n\n\tpublic synchronized <T> T put(String ref,Object val,String link_to){\n\t\tT out=put(ref,val);\n\t\tlinkedRefs(link_to).add(ref);\n\t\treturn out;\n\t}\n\n\n\tpublic synchronized <T> T removeWithLinks(String ref){\n\t\tList<String> ls=links.get(ref);\n\t\tT out= (T)storage.remove(ref);\n\t\tfor(String l:ls)remove(l);\n\t\treturn out;\n\t}\n\n\tpublic synchronized <T> T remove(String ref){\n\t\tlinks.remove(ref);\n\t\treturn (T) storage.remove(ref);\n\t}\n\n\tpublic synchronized List<String> linkedRefs(String ref) {\n\t\tList<String> linked=links.get(ref);\n\t\tif(linked==null){\n\t\t\tlinked=new LinkedList<String>();\n\t\t\tlinks.put(ref,linked);\n\t\t}\n\t\treturn linked;\n\t}\n\n\n\tpublic synchronized String toString(){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tLinkedList<String> ignore=new LinkedList<String>();\n\t\tstorage.forEach((k,v)->{\n\t\t\tif(!ignore.contains(k)){\n\t\t\t\tsb.append(\"$ \").append(k).append(\" = \").append(v.getClass()).append(\"(\").append(v.hashCode()).append(\")\\n\");\n\t\t\t\tList<String> linked =linkedRefs(k);\n\t\t\t\tfor(String l:linked){\n\t\t\t\t\tv=get(l);\n\t\t\t\t\tsb.append(\"$ ----| \").append(l).append(\" = \").append(v.getClass()).append(\"(\");\n\t\t\t\t\ttry{\n\t\t\t\t\t\tsb.append(v.toString());\n\t\t\t\t\t}catch(Throwable t){\n\t\t\t\t\t\tsb.append(v.hashCode());\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(\")\\n\");\n\t\t\t\t}\n\t\t\t\tignore.addAll(linked);\n\t\t\t}\n\t\t});\n\t\treturn sb.toString();\n\t}\n\n}\n", "answers": ["\t\tlinkers.add(new AnimationToSpatial());"], "length": 1043, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "f949655ebd54e3a718afd2bc502e1b633727db03b86ffd26"}
{"input": "import os\nimport shutil\nimport MobSF.settings as SETTINGS\nimport json\nimport signal\nimport subprocess\nimport threading\nimport time\nimport traceback\nfrom DynamicAnalyzer.pyWebProxy.pywebproxy import Proxy\nfrom DynamicAnalyzer.views.android.android_avd import avd_load_wait\nfrom DynamicAnalyzer.views.android.android_avd import refresh_avd\nfrom DynamicAnalyzer.views.android.android_dyn_shared import connect\nfrom DynamicAnalyzer.views.android.android_dyn_shared import install_and_run\nfrom DynamicAnalyzer.views.android.android_dyn_shared import web_proxy\nfrom DynamicAnalyzer.views.android.android_dyn_shared import get_identifier\nfrom DynamicAnalyzer.views.android.android_virtualbox_vm import refresh_vm\nfrom mass_static_analysis import genMD5\nfrom MobSF.utils import getADB\nfrom StaticAnalyzer.views.android.manifest_analysis import get_manifest\nfrom StaticAnalyzer.views.android.manifest_analysis import manifest_data as get_manifest_data\nfrom StaticAnalyzer.views.shared_func import Unzip\nfrom Analysis_x_logcat.analysis import analysis_x_logcat\n# -*- coding: utf8 -*-\n\nos.environ.update({\"DJANGO_SETTINGS_MODULE\": \"MobSF.settings\"})\n\n\n\nBASE_DIR = '.'\nDEBUGING = False\nDEBUGING_NUMS = 5\nUPLOAD_DIR = os.path.join(BASE_DIR, 'uploads')\nORIGIN_DOWNLOAD_DIR = os.path.join(BASE_DIR, 'downloads')\nDYNAMIC_TOOL_DIR = os.path.join(os.path.join(BASE_DIR, 'DynamicAnalyzer'), 'tools')\nSTATIC_TOOL_DIR = os.path.join(os.path.join(BASE_DIR, 'StaticAnalyzer'), 'tools')\n\n\ndef get_static_info(file_path, file_md5):\n\n    unzip_dir = os.path.join(UPLOAD_DIR, file_md5)\n    unzip_result = Unzip(file_path, unzip_dir)\n    print 'len(unzip_result):', len(unzip_result)\n    \n    apk_path = os.path.join(unzip_dir, 'app.apk')\n    shutil.copy(file_path, apk_path)\n    \n    manifest_xml = get_manifest(unzip_dir, STATIC_TOOL_DIR, '', True)\n    print 'manifest_xml:', manifest_xml\n    \n    manifest_data = get_manifest_data(manifest_xml)\n    print 'manifest_data[\"packagename\"]:', manifest_data['packagename']\n    print 'manifest_data[\"application_name\"]:', manifest_data['application_name']\n    print 'manifest_data[\"mainactivity\"]:', manifest_data['mainactivity']\n    \n    manifest_data['file_md5'] = file_md5\n    manifest_data['apk_path'] = apk_path\n    return manifest_data\n\ndef init_environment(adb):\n", "context": "DynamicAnalyzer/views/android/android_dyn_shared.py\ndef install_and_run(toolsdir, apk_path, package, launcher, is_activity):\n    \"\"\"Install APK and Run it\"\"\"\n    print \"\\n[INFO] Starting App for Dynamic Analysis\"\n    # try:\n    adb = getADB(toolsdir)\n    print \"\\n[INFO] Installing APK\"\n    install_result = subprocess.check_output([adb, \"-s\", get_identifier(),\n                     \"install\", \"-r\", apk_path])\n    print install_result\n    # 如果是未签名的错误，则对其进行签名并安装，\n    # 签名命令示例：jarsigner -verbose -keystore davidblus_android.keystore -storepass davidblus -signedjar app_signed.apk app.apk davidblus_android.keystore\n    if 'INSTALL_PARSE_FAILED_NO_CERTIFICATES' in install_result:\n        signed_apk_path = sign_apk(apk_path)\n        install_result = subprocess.check_output([adb, \"-s\", get_identifier(),\n                         \"install\", \"-r\", signed_apk_path])\n        print install_result\n    if 'Success' not in install_result:\n        raise Exception('Install Error')\n    if is_activity:\n        run_app = package + \"/\" + launcher\n        print \"\\n[INFO] Launching APK Main Activity\"\n        subprocess.call([adb, \"-s\", get_identifier(),\n                         \"shell\", \"am\", \"start\", \"-n\", run_app])\n    else:\n        print \"\\n[INFO] App Doesn't have a Main Activity\"\n        # Handle Service or Give Choice to Select in Future.\n    print \"[INFO] Testing Environment is Ready!\"\n    # except:\n    #     PrintException(\"[ERROR]  Starting App for Dynamic Analysis\")\nDynamicAnalyzer/pyWebProxy/pywebproxy.py\ndef Proxy(IP, PORT, LOG, STAT):\n    global kill, log\n    if STAT == \"on\":\n        log = LOG\n        kill = False\n        print \"\\n[INFO] Started Web Proxy at \" + IP + \":\" + PORT\n        threading.Thread(target=startTornado, kwargs=dict(\n            IP=IP, PORT=PORT, log=log)).start()\n    else:\n        print \"\\n[INFO] Stopping any running instance of WebProxy\"\n        kill = True\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef connect(toolsdir):\n    \"\"\"Connect to VM/Device\"\"\"\n    print \"\\n[INFO] Connecting to VM/Device\"\n    try:\n        adb = getADB(toolsdir)\n        subprocess.call([adb, \"kill-server\"])\n        subprocess.call([adb, \"start-server\"])\n        print \"\\n[INFO] ADB Started\"\n        wait(5)\n        print \"\\n[INFO] Connecting to VM/Device\"\n        result = subprocess.call([adb, \"connect\", get_identifier()])\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\" and result != 0:\n            subprocess.call([adb, \"tcpip\", str(settings.DEVICE_ADB_PORT)])\n            subprocess.call([adb, \"connect\", get_identifier()])\n        subprocess.call([adb, \"-s\", get_identifier(), \"wait-for-device\"])\n        print \"\\n[INFO] Mounting\"\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\",\n                             \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"])\n        else:\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\",\n                             \"su\", \"-c\", \"mount\", \"-o\", \"rw,remount,rw\", \"/system\"])\n            # This may not work for VMs other than the default MobSF VM\n            subprocess.call([adb, \"-s\", get_identifier(), \"shell\", \"mount\",\n                             \"-o\", \"rw,remount\", \"-t\", \"rfs\", \"/dev/block/sda6\", \"/system\"])\n    except:\n        print traceback.format_exc()\n        PrintException(\"[ERROR]  Connecting to VM/Device\")\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef get_identifier():\n    \"\"\"Get Device Type\"\"\"\n    try:\n        if settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_REAL_DEVICE\":\n            return settings.DEVICE_IP + \":\" + str(settings.DEVICE_ADB_PORT)\n        elif settings.ANDROID_DYNAMIC_ANALYZER == \"MobSF_AVD\":\n            return 'emulator-' + str(settings.AVD_ADB_PORT)\n        else:\n            return settings.VM_IP + \":\" + str(settings.VM_ADB_PORT)\n    except:\n        PrintException(\n            \"[ERROR] Getting ADB Connection Identifier for Device/VM\")\nDynamicAnalyzer/views/android/android_avd.py\ndef refresh_avd(adb, avd_path, reference_name, dup_name, emulator):\n    \"\"\"Refresh AVD\"\"\"\n    print \"\\n[INFO] Refreshing MobSF Emulator\"\n    try:\n        # Stop existing emulator on the spesified port\n        stop_avd(adb)\n\n        # Windows has annoying lock system, it takes time for it to remove the locks after we stopped the emulator\n        if platform.system() == 'Windows':\n            time.sleep(3)\n\n        # Delete old emulator\n        delete_avd(avd_path, dup_name)\n\n        # Copy and replace the contents of the reference machine\n        duplicate_avd(avd_path, reference_name, dup_name)\n\n        # Start emulator\n        start_avd(emulator, dup_name, settings.AVD_ADB_PORT)\n    except:\n        PrintException(\"[ERROR] Refreshing MobSF VM\")\nMobSF/utils.py\ndef getADB(TOOLSDIR):\n    \"\"\"Get ADB binary path\"\"\"\n    try:\n        if len(settings.ADB_BINARY) > 0 and isFileExists(settings.ADB_BINARY):\n            return settings.ADB_BINARY\n        else:\n            adb = 'adb'\n            if platform.system() == \"Darwin\":\n                adb_dir = os.path.join(TOOLSDIR, 'adb/mac/')\n                subprocess.call([\"chmod\", \"777\", adb_dir])\n                adb = os.path.join(TOOLSDIR, 'adb/mac/adb')\n            elif platform.system() == \"Linux\":\n                adb_dir = os.path.join(TOOLSDIR, 'adb/linux/')\n                subprocess.call([\"chmod\", \"777\", adb_dir])\n                adb = os.path.join(TOOLSDIR, 'adb/linux/adb')\n            elif platform.system() == \"Windows\":\n                adb = os.path.join(TOOLSDIR, 'adb/windows/adb.exe')\n            return adb\n    except:\n        PrintException(\"[ERROR] Getting ADB Location\")\n        return \"adb\"\nDynamicAnalyzer/views/android/android_avd.py\ndef avd_load_wait(adb):\n    \"\"\"Wait for AVD Load\"\"\"\n    try:\n        emulator = get_identifier()\n\n        print \"[INFO] Wait for emulator to load\"\n        args = [adb,\n                \"-s\",\n                emulator,\n                \"wait-for-device\"]\n        subprocess.call(args)\n\n        print \"[INFO] Wait for dev.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"dev.bootcomplete\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"1\":\n                break\n            else:\n                time.sleep(1)\n\n        print \"[INFO] Wait for sys.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"sys.boot_completed\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"1\":\n                break\n            else:\n                time.sleep(1)\n\n        print \"[INFO] Wait for svc.boot_complete loop\"\n        while True:\n            args = [adb,\n                    \"-s\",\n                    emulator,\n                    \"shell\",\n                    \"getprop\",\n                    \"init.svc.bootanim\"]\n            try:\n                result = subprocess.check_output(args)\n            except:\n                result = None\n            if result is not None and result.strip() == \"stopped\":\n                break\n            else:\n                time.sleep(1)\n        time.sleep(5)\n        # Remount the partitions for RW\n        subprocess.call([adb, \"-s\", emulator, \"remount\"])\n        return True\n    except:\n        PrintException(\"[ERROR] emulator did not boot properly\")\n        return False\nAnalysis_x_logcat/analysis.py\ndef analysis_x_logcat(x_file_name, app_info):\n    package_name = app_info['packagename']\n    \n    # 新的 app_info 包含所有可能的manifest文件中提到的java代码所在的包名\n    app_info = set_java_package_names(app_info)\n    \n    # func_timeflow 表示以时间顺序记录的函数调用列表。 TODO: 供后续制定以时间序列调用api的规则，进而检测分析。\n    func_timeflow = load_x_file(x_file_name, package_name)\n    file_timeflow = x_file_name + '_timeflow_list.json'\n    save_file(file_timeflow, func_timeflow)\n    \n    # 把时间顺序记录的函数调用列表转换为二维特征数据\n    try:\n        timeflow_to_numpy(file_timeflow, FILE_S_JSON)\n    except Exception as e:\n        print u'把时间序列转换为二维特征数据时出异常：', traceback.format_exc()\n    \n    # hook_datas 表示数据处理过程中的中间结果。\n    hook_datas = make_hooks_datas(func_timeflow, package_name, app_info['java_package_names'])\n    #save_file(x_file_name + '_hook_result.json', hook_datas)\n    \n    # func_statistic 表示以api为关键字的函数调用列表。 TODO: 供后续制定以api调用详细信息的规则，进而检测分析。\n    func_statistic = count_function(hook_datas, package_name)\n    file_count_function = x_file_name + '_count_function.json'\n    save_file(file_count_function, func_statistic)\n    \n    # 根据 api调用->敏感行为 规则，查出其具有的敏感行为列表。\n    sensitives = transfer_func_to_sen(func_statistic)\n    sensitives = delete_empty_element(sensitives)\n    save_file(x_file_name + '_sensitives.json', sensitives)\n    \n    # 根据 api调用->漏洞 规则，查出其具有的漏洞列表。\n    vulnerabilities = transfer_func_to_vul(func_statistic, app_info)\n    vulnerabilities = remove_white(vulnerabilities)\n    vulnerabilities = delete_empty_element(vulnerabilities)\n    save_file(x_file_name + '_vulnerabilities.json', vulnerabilities)\n\n    # 由于临时文件比较大，当硬盘空间不足时，则删除临时文件。\n    # os.remove(x_file_name)\n    # os.remove(file_timeflow)\n    os.remove(file_count_function)\n    \n    result = {'sensitives': sensitives, 'vulnerabilities': vulnerabilities}\n    return result\nStaticAnalyzer/views/shared_func.py\ndef Unzip(APP_PATH, EXT_PATH):\n    print \"[INFO] Unzipping\"\n    try:\n        files = []\n        with zipfile.ZipFile(APP_PATH, \"r\") as z:\n            for fileinfo in z.infolist():\n                filename = fileinfo.filename\n                if not isinstance(filename, unicode):\n                    filename = unicode(filename, encoding=\"utf-8\", errors=\"replace\")\n                files.append(filename)\n                z.extract(fileinfo, EXT_PATH)\n        return files\n    except:\n        PrintException(\"[ERROR] Unzipping Error\")\n        if platform.system() == \"Windows\":\n            print \"\\n[INFO] Not yet Implemented.\"\n            return files\n        else:\n            print \"\\n[INFO] Using the Default OS Unzip Utility.\"\n            try:\n                subprocess.call(\n                    ['unzip', '-o', '-q', APP_PATH, '-d', EXT_PATH])\n                dat = subprocess.check_output(['unzip', '-qq', '-l', APP_PATH])\n                dat = dat.split('\\n')\n                x = ['Length   Date   Time   Name']\n                x = x + dat\n                return x\n            except:\n                PrintException(\"[ERROR] Unzipping Error\")\nDynamicAnalyzer/views/android/android_dyn_shared.py\ndef web_proxy(apk_dir, ip_address, port):\n    \"\"\"Run MITM Proxy\"\"\"\n    print \"\\n[INFO] Starting Web Proxy\"\n    try:\n        Proxy(ip_address, port, apk_dir, \"on\")\n    except:\n        PrintException(\"[ERROR] Starting Web Proxy\")\nDynamicAnalyzer/views/android/android_virtualbox_vm.py\ndef refresh_vm(uuid, snapshot_uuid, vbox_exe):\n    \"\"\"Refresh VirtualBox based VMs\"\"\"\n    print \"\\n[INFO] Refreshing MobSF VM\"\n    try:\n        # Close VM\n        args = [vbox_exe, 'controlvm', uuid, 'poweroff']\n        subprocess.call(args)\n        # changed by davidblus\n        time.sleep(2)\n        print \"\\n[INFO] VM Closed\"\n        # Restore Snapshot\n        args = [vbox_exe, 'snapshot', uuid, 'restore', snapshot_uuid]\n        subprocess.call(args)\n        print \"\\n[INFO] VM Restore Snapshot\"\n        # Start Fresh VM\n        args = [vbox_exe, 'startvm', uuid]\n        subprocess.call(args)\n        print \"\\n[INFO] VM Starting\"\n    except:\n        PrintException(\"[ERROR] Refreshing MobSF VM\")\nmass_static_analysis.py\ndef genMD5(app):\n\n    BLOCKSIZE = 65536\n    hasher = hashlib.md5()\n    with open(app, 'rb') as afile:\n        buf = afile.read(BLOCKSIZE)\n        while buf:\n            hasher.update(buf)\n            buf = afile.read(BLOCKSIZE)\n    return (hasher.hexdigest())\nStaticAnalyzer/views/android/manifest_analysis.py\ndef get_manifest(app_dir, tools_dir, typ, binary):\n    \"\"\"Get the manifest file.\"\"\"\n    dat = read_manifest(app_dir, tools_dir, typ, binary).replace(\"\\n\", \"\")\n    # changed by davidblus\n    new_AndroidManifest = os.path.join(app_dir, 'new_AndroidManifest.xml')\n    with open(new_AndroidManifest, 'w') as file:\n        file.write(dat)\n        \n    try:\n        manifest = minidom.parseString(dat)\n    except Exception as err:\n        try:\n            dat_windows = dat.decode('gb2312', 'ignore')\n            manifest = minidom.parseString(dat_windows)\n        except Exception as err:\n            try:\n                apktool = os.path.join(os.path.join(tools_dir, 'apktool2.2.4'), 'apktool')\n                apktool_dir = os.path.join(app_dir, 'apktool')\n                app_apk = os.path.join(app_dir, 'app.apk')\n                cmd_list = [apktool, \"d\", \"-o\", apktool_dir, \"-s\", app_apk]\n                print cmd_list\n                if platform.system() == 'Windows':\n                    temp = subprocess.call(cmd_list, shell=True)\n                else:\n                    temp = subprocess.call(cmd_list)\n                with open(os.path.join(apktool_dir, 'AndroidManifest.xml')) as fp:\n                    dat = fp.read()\n                manifest = minidom.parseString(dat)\n            except Exception as err:\n                print traceback.format_exc()\n                raise Exception('Parsing Manifest Error')\n            \n    return manifest\nStaticAnalyzer/views/android/manifest_analysis.py\ndef manifest_data(mfxml):\n    \"\"\"Extract manifest data.\"\"\"\n    try:\n        print \"[INFO] Extracting Manifest Data\"\n        svc = []\n        act = []\n        brd = []\n        cnp = []\n        lib = []\n        perm = []\n        dvm_perm = {}\n        package = ''\n        minsdk = '1'\n        maxsdk = ''\n        targetsdk = ''\n        mainact = ''\n        androidversioncode = ''\n        androidversionname = ''\n        application_name = ''\n        permissions = mfxml.getElementsByTagName(\"uses-permission\")\n        manifest = mfxml.getElementsByTagName(\"manifest\")\n        activities = mfxml.getElementsByTagName(\"activity\")\n        services = mfxml.getElementsByTagName(\"service\")\n        providers = mfxml.getElementsByTagName(\"provider\")\n        receivers = mfxml.getElementsByTagName(\"receiver\")\n        libs = mfxml.getElementsByTagName(\"uses-library\")\n        sdk = mfxml.getElementsByTagName(\"uses-sdk\")\n        application = mfxml.getElementsByTagName(\"application\")\n        for node in application:\n            application_name = node.getAttribute(\"android:name\")\n        for node in sdk:\n            minsdk = node.getAttribute(\"android:minSdkVersion\")\n            maxsdk = node.getAttribute(\"android:maxSdkVersion\")\n            # Esteve 08.08.2016 - begin - If android:targetSdkVersion is not set, the default value is the one of the android:minSdkVersion\n            # targetsdk=node.getAttribute(\"android:targetSdkVersion\")\n            if node.getAttribute(\"android:targetSdkVersion\"):\n                targetsdk = node.getAttribute(\"android:targetSdkVersion\")\n            else:\n                targetsdk = node.getAttribute(\"android:minSdkVersion\")\n            # End\n        for node in manifest:\n            package = node.getAttribute(\"package\")\n            androidversioncode = node.getAttribute(\"android:versionCode\")\n            androidversionname = node.getAttribute(\"android:versionName\")\n        for activity in activities:\n            act_2 = activity.getAttribute(\"android:name\")\n            act.append(act_2)\n            if len(mainact) < 1:\n                # ^ Fix for Shitty Manifest with more than one MAIN\n                for sitem in activity.getElementsByTagName(\"category\"):\n                    val = sitem.getAttribute(\"android:name\")\n                    if val == \"android.intent.category.LAUNCHER\":\n                        mainact = activity.getAttribute(\"android:name\")\n        for activity in activities:\n            if not mainact:\n                for sitem in activity.getElementsByTagName(\"action\"):\n                    val = sitem.getAttribute(\"android:name\")\n                    if val == \"android.intent.action.MAIN\":\n                        mainact = activity.getAttribute(\"android:name\")\n\n        for service in services:\n            service_name = service.getAttribute(\"android:name\")\n            svc.append(service_name)\n\n        for provider in providers:\n            provider_name = provider.getAttribute(\"android:name\")\n            cnp.append(provider_name)\n\n        for receiver in receivers:\n            rec = receiver.getAttribute(\"android:name\")\n            brd.append(rec)\n\n        for _lib in libs:\n            libary = _lib.getAttribute(\"android:name\")\n            lib.append(libary)\n\n        for permission in permissions:\n            perm.append(permission.getAttribute(\"android:name\"))\n\n        for i in perm:\n            prm = i\n            pos = i.rfind(\".\")\n            if pos != -1:\n                prm = i[pos + 1:]\n            try:\n                dvm_perm[i] = DVM_PERMISSIONS[\"MANIFEST_PERMISSION\"][prm]\n            except KeyError:\n                dvm_perm[i] = [\n                    \"dangerous\",\n                    \"Unknown permission from android reference\",\n                    \"Unknown permission from android reference\"\n                ]\n\n        man_data_dic = {\n            'services': svc,\n            'activities': act,\n            'receivers': brd,\n            'providers': cnp,\n            'libraries': lib,\n            'perm': dvm_perm,\n            'packagename': package,\n            'mainactivity': mainact,\n            'min_sdk': minsdk,\n            'max_sdk': maxsdk,\n            'target_sdk': targetsdk,\n            'androver': androidversioncode,\n            'androvername': androidversionname,\n            'application_name': application_name\n        }\n\n        return man_data_dic\n    except:\n        PrintException(\"[ERROR] Extracting Manifest Data\")\n", "answers": ["    Proxy('', '', '', '')"], "length": 1562, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "3b59dbf771fc39f7e1456064fcacde47bb01e6e192c1d9c3"}
{"input": "import unittest\nfrom apidoc.object.source_raw import Sampleable\nfrom apidoc.object.source_raw import Method\nfrom apidoc.object.source_raw import Parameter, ResponseCode\nfrom apidoc.object.source_raw import Type, TypeFormat\nfrom apidoc.object.source_raw import Object, ObjectObject, ObjectArray\nfrom apidoc.object.source_raw import ObjectNumber, ObjectInteger, ObjectString, ObjectBoolean, ObjectNone\nfrom apidoc.object.source_raw import ObjectDynamic, ObjectReference, ObjectType, ObjectConst, ObjectEnum, EnumValue, Constraint\nfrom apidoc.object.source_raw import Object as ObjectRaw\n        self.assertEqual(\"my_bar\", sampleable.get_sample())\n\n    def test_type_get_sample(self):\n        type = Type()\n        type.item = ObjectString()\n        type.item.name = \"a\"\n\n        self.assertEqual(\"my_a\", type.get_sample())\n\n    def test_method_message(self):\n        method = Method()\n        code = ResponseCode()\n        code.code = 100\n        code.message = \"foo\"\n\n        method.code = 100\n        method.response_codes = [code]\n\n        self.assertEqual(\"foo\", method.message)\n\n    def test_method_message__ok(self):\n        method = Method()\n\n        method.code = 200\n\n        self.assertEqual(\"OK\", method.message)\n\n    def test_method_message__failled_when_no_code_found(self):\n        method = Method()\n        code = ResponseCode()\n        code.code = 100\n        code.message = \"foo\"\n\n        method.code = 300\n        method.response_codes = [code]\n\n        with self.assertRaises(ValueError):\n            method.message\n\n    def test_sampleable_get_default_sample(self):\n        test = Sampleable()\n        test.name = \"foo\"\n\n        self.assertEqual(\"my_foo\", test.get_default_sample())\n\n    def test_parameter_get_default_sample(self):\n        test = Parameter()\n        test.type = \"number\"\n\n        self.assertEqual(\"13.37\", test.get_default_sample())\n\n    def test_parameter_get_default_sample__for_type(self):\n        test = Parameter()\n\n        type = Type()\n        type.item = ObjectString()\n        type.item.name = \"a\"\n\n        test.type = \"b\"\n        test.type_object = type\n\n        self.assertEqual(\"my_a\", test.get_default_sample())\n\n    def test_objectnumber_get_default_sample(self):\n        test = ObjectNumber()\n\n        self.assertEqual('13.37', test.get_default_sample())\n\n    def test_objectinteger_get_default_sample(self):\n        test = ObjectInteger()\n\n        self.assertEqual('42', test.get_default_sample())\n\n    def test_objectboolean_get_default_sample(self):\n        test = ObjectBoolean()\n\n        self.assertEqual('True', str(test.get_default_sample()))\n\n    def test_objectdynamic_get_default_sample(self):\n        test = ObjectDynamic()\n        test.name = \"foo\"\n\n        self.assertEqual({\n            \"key1\": \"my_foo\",\n            \"key2\": \"sample\"\n        }, test.get_default_sample())\n\n    def test_objecttype_get_default_sample(self):\n        test = ObjectType()\n        test.version = \"v1\"\n        test.type_name = \"baz\"\n\n        object = ObjectString()\n        object.sample = \"foo\"\n\n        type = Type()\n        type.format = TypeFormat()\n        type.item = object\n\n        test.type_object = type\n\n        self.assertEqual(\"foo\", test.get_default_sample())\n\n    def test_objectconst_get_default_sample(self):\n        test = ObjectConst()\n        test.value = \"foo\"\n\n        self.assertEqual(\"foo\", test.get_default_sample())\n\n    def test_object_factory(self):\n        ObjectRaw.Types.foo = \"foo\"\n\n        self.assertIsInstance(Object.factory(\"object\", \"v1\"), ObjectObject)\n        self.assertIsInstance(Object.factory(\"array\", \"v1\"), ObjectArray)\n        self.assertIsInstance(Object.factory(\"number\", \"v1\"), ObjectNumber)\n        self.assertIsInstance(Object.factory(\"integer\", \"v1\"), ObjectInteger)\n        self.assertIsInstance(Object.factory(\"string\", \"v1\"), ObjectString)\n        self.assertIsInstance(Object.factory(\"boolean\", \"v1\"), ObjectBoolean)\n        self.assertIsInstance(Object.factory(\"reference\", \"v1\"), ObjectReference)\n        self.assertIsInstance(Object.factory(\"type\", \"v1\"), ObjectType)\n", "context": "apidoc/object/source_raw.py\nclass ObjectDynamic(Object, Constraintable):\n\n    \"\"\"Element ObjectDynamic\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"dynamic\")\n        self.items = None\n\n    def get_default_sample(self):\n        \"\"\"Return default value for the element\n        \"\"\"\n        return {\n            \"key1\": \"my_%s\" % self.name,\n            \"key2\": \"sample\"\n        }\napidoc/object/source_raw.py\nclass ObjectNumber(Object, Constraintable):\n\n    \"\"\"Element ObjectNumber\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"number\")\n\n    def get_default_sample(self):\n        \"\"\"Return default value for the element\n        \"\"\"\n        return '13.37'\napidoc/object/source_raw.py\nclass Parameter(Element, Sampleable):\n\n    \"\"\"Element Parameter\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = None\n        self.optional = False\n        self.generic = False\n        self.type_object = None\n        self.position = 0\n\n    def get_object(self):\n        object = Object.factory(self.type, None)\n        object.name = self.name\n        return object\n\n    def get_default_sample(self):\n        \"\"\"Return default value for the element\n        \"\"\"\n        if self.type not in Object.Types or self.type is Object.Types.type:\n            return self.type_object.get_sample()\n        else:\n            return self.get_object().get_sample()\napidoc/object/source_raw.py\nclass Object(Element, Sampleable):\n\n    \"\"\"Element Object\n    \"\"\"\n\n    class Types(Enum):\n\n        \"\"\"List of availables Types for this element\n        \"\"\"\n        object = 1\n        array = 2\n        number = 3\n        string = 4\n        boolean = 5\n        none = 6\n        reference = 7\n        type = 8\n        dynamic = 9\n        const = 10\n        enum = 11\n        integer = 12\n        any = 13\n\n    @classmethod\n    def factory(cls, str_type, version):\n        \"\"\"Return a proper object\n        \"\"\"\n        type = Object.Types(str_type)\n\n        if type is Object.Types.object:\n            object = ObjectObject()\n        elif type is Object.Types.array:\n            object = ObjectArray()\n        elif type is Object.Types.number:\n            object = ObjectNumber()\n        elif type is Object.Types.integer:\n            object = ObjectInteger()\n        elif type is Object.Types.string:\n            object = ObjectString()\n        elif type is Object.Types.boolean:\n            object = ObjectBoolean()\n        elif type is Object.Types.reference:\n            object = ObjectReference()\n        elif type is Object.Types.type:\n            object = ObjectType()\n        elif type is Object.Types.none:\n            object = ObjectNone()\n        elif type is Object.Types.dynamic:\n            object = ObjectDynamic()\n        elif type is Object.Types.const:\n            object = ObjectConst()\n        elif type is Object.Types.enum:\n            object = ObjectEnum()\n        else:\n            object = Object()\n        object.type = type\n        object.version = version\n        return object\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = None\n        self.optional = False\napidoc/object/source_raw.py\nclass ObjectInteger(Object, Constraintable):\n\n    \"\"\"Element ObjectInteger\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"integer\")\n\n    def get_default_sample(self):\n        \"\"\"Return default value for the element\n        \"\"\"\n        return '42'\napidoc/object/source_raw.py\nclass ObjectString(Object, Constraintable):\n\n    \"\"\"Element ObjectString\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"string\")\napidoc/object/source_raw.py\nclass ObjectConst(Object, Constraintable):\n\n    \"\"\"Element ObjectConst\n    \"\"\"\n\n    class Types(Enum):\n\n        \"\"\"List of availables Primaries for this element\n        \"\"\"\n        string = 1\n        boolean = 2\n        number = 3\n        integer = 4\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"const\")\n        self.const_type = ObjectConst.Types.string\n        self.value = None\n\n    def get_default_sample(self):\n        \"\"\"Return default value for the element\n        \"\"\"\n        return self.value\napidoc/object/source_raw.py\nclass ObjectReference(Object):\n\n    \"\"\"Element ObjectReference\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"reference\")\n        self.reference_name = None\napidoc/object/source_raw.py\nclass Method(Element, Displayable, Comparable):\n\n    \"\"\"Element Method\n    \"\"\"\n\n    class Methods(Enum):\n\n        \"\"\"List of availables Methods for this element\n        \"\"\"\n        get = 1\n        post = 2\n        put = 3\n        delete = 4\n        head = 5\n        option = 6\n        patch = 7\n\n    @property\n    def message(self):\n        \"\"\"Return default message for this element\n        \"\"\"\n        if self.code != 200:\n            for code in self.response_codes:\n                if code.code == self.code:\n                    return code.message\n\n            raise ValueError(\"Unknown response code \\\"%s\\\" in \\\"%s\\\".\" % (self.code, self.name))\n\n        return \"OK\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.code = 200\n        self.uri = None\n        self.absolute_uri = None\n        self.full_uri = None\n        self.category = None\n        self.method = Method.Methods(\"get\")\n        self.request_headers = {}\n        self.request_parameters = {}\n        self.request_body = None\n        self.response_codes = []\n        self.response_body = None\n\n    def get_comparable_values(self):\n        \"\"\"Return a tupple of values representing the unicity of the object\n        \"\"\"\n        return (str(self.name))\napidoc/object/source_raw.py\nclass ResponseCode(Element):\n\n    \"\"\"Element ResponseCode\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.code = 200\n        self.message = None\n        self.generic = False\napidoc/object/source_raw.py\nclass Type(Element, Comparable, Sampleable):\n\n    \"\"\"Element Type\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.format = TypeFormat()\n        self.category = None\n        self.item = None\n\n    def get_sample(self):\n        \"\"\"Return the a sample for the element\n        \"\"\"\n        if self.item is not None:\n            return self.item.get_sample()\n        else:\n            return super().get_sample()\n\n    def get_comparable_values(self):\n        \"\"\"Return a tupple of values representing the unicity of the object\n        \"\"\"\n        return (str(self.name))\napidoc/object/source_raw.py\nclass ObjectType(Object, Constraintable):\n\n    \"\"\"Element ObjectType\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"type\")\n        self.type_name = None\n        self.type_object = None\n\n    def get_default_sample(self):\n        \"\"\"Return default value for the element\n        \"\"\"\n        if self.type_object is None:\n            return super().get_default_sample()\n        return self.type_object.get_sample()\napidoc/object/source_raw.py\nclass Object(Element, Sampleable):\n\n    \"\"\"Element Object\n    \"\"\"\n\n    class Types(Enum):\n\n        \"\"\"List of availables Types for this element\n        \"\"\"\n        object = 1\n        array = 2\n        number = 3\n        string = 4\n        boolean = 5\n        none = 6\n        reference = 7\n        type = 8\n        dynamic = 9\n        const = 10\n        enum = 11\n        integer = 12\n        any = 13\n\n    @classmethod\n    def factory(cls, str_type, version):\n        \"\"\"Return a proper object\n        \"\"\"\n        type = Object.Types(str_type)\n\n        if type is Object.Types.object:\n            object = ObjectObject()\n        elif type is Object.Types.array:\n            object = ObjectArray()\n        elif type is Object.Types.number:\n            object = ObjectNumber()\n        elif type is Object.Types.integer:\n            object = ObjectInteger()\n        elif type is Object.Types.string:\n            object = ObjectString()\n        elif type is Object.Types.boolean:\n            object = ObjectBoolean()\n        elif type is Object.Types.reference:\n            object = ObjectReference()\n        elif type is Object.Types.type:\n            object = ObjectType()\n        elif type is Object.Types.none:\n            object = ObjectNone()\n        elif type is Object.Types.dynamic:\n            object = ObjectDynamic()\n        elif type is Object.Types.const:\n            object = ObjectConst()\n        elif type is Object.Types.enum:\n            object = ObjectEnum()\n        else:\n            object = Object()\n        object.type = type\n        object.version = version\n        return object\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = None\n        self.optional = False\napidoc/object/source_raw.py\nclass TypeFormat():\n\n    \"\"\"Element TypeFormat\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.pretty = None\n        self.advanced = None\napidoc/object/source_raw.py\nclass ObjectNone(Object, Constraintable):\n\n    \"\"\"Element ObjectNone\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"none\")\napidoc/object/source_raw.py\nclass ObjectEnum(Object, Constraintable):\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"enum\")\n        self.values = []\n        self.descriptions = []\n\n    def get_default_sample(self):\n        \"\"\"Return default value for the element\n        \"\"\"\n        if not self.values:\n            return super().get_default_sample()\n        return self.values[0]\napidoc/object/source_raw.py\nclass ObjectBoolean(Object, Constraintable):\n\n    \"\"\"Element ObjectBoolean\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"boolean\")\n\n    def get_default_sample(self):\n        \"\"\"Return default value for the element\n        \"\"\"\n        return True\napidoc/object/source_raw.py\nclass ObjectObject(Object, Constraintable):\n\n    \"\"\"Element ObjectObject\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"object\")\n        self.properties = {}\n        self.pattern_properties = {}\n        self.additional_properties = None\napidoc/object/source_raw.py\nclass Constraint(Comparable):\n\n    \"\"\"An oobject's constraint\n    \"\"\"\n\n    def __init__(self, name, constraint):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.name = name\n        self.constraint = constraint\n\n    def __str__(self):\n        return '%s: %s' % (self.name, str(self.constraint))\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__, self.__dict__)\n\n    def get_comparable_values(self):\n        \"\"\"Return a tupple of values representing the unicity of the object\n        \"\"\"\n        return (str(self.name))\napidoc/object/source_raw.py\nclass EnumValue(Object, Comparable):\n\n    def get_comparable_values(self):\n        \"\"\"Return a tupple of values representing the unicity of the object\n        \"\"\"\n        return (str(self.name), str(self.description))\napidoc/object/source_raw.py\nclass ObjectArray(Object, Constraintable):\n\n    \"\"\"Element ObjectArray\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.type = Object.Types(\"array\")\n        self.items = None\n        self.sample_count = 2\napidoc/object/source_raw.py\nclass Sampleable():\n\n    \"\"\"Element who can provide samples\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class instantiation\n        \"\"\"\n        super().__init__()\n        self.sample = None\n\n    def get_sample(self):\n        \"\"\"Return the a sample for the element\n        \"\"\"\n        if self.sample is None:\n            return self.get_default_sample()\n        return self.sample\n\n    def get_default_sample(self):\n        \"\"\"Return default value for the element\n        \"\"\"\n        return \"my_%s\" % self.name\n", "answers": ["        self.assertIsInstance(Object.factory(\"none\", \"v1\"), ObjectNone)"], "length": 1381, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "3f9e90234859286c74cea178dbf97af76c56e50727e0f49d"}
{"input": "import com.fooock.shodan.model.query.QueryReport;\nimport com.fooock.shodan.model.tag.TagReport;\nimport com.fooock.shodan.model.token.TokenReport;\nimport com.fooock.shodan.model.user.Account;\nimport com.fooock.shodan.model.user.ApiStatus;\nimport com.fooock.shodan.model.user.HttpHeader;\nimport io.reactivex.Observable;\nimport java.util.List;\nimport com.fooock.shodan.model.dns.DnsHostname;\nimport com.fooock.shodan.model.dns.DnsIp;\nimport com.fooock.shodan.model.host.FacetReport;\nimport com.fooock.shodan.model.host.Host;\nimport com.fooock.shodan.model.host.HostReport;\nimport com.fooock.shodan.model.protocol.Protocol;\n     * @param history True if all historical banners should be returned (default false)\n     * @param minify  True to only return the list of ports and the general host information, no\n     *                banners (default false)\n     * @param ip      Host IP address\n     */\n    public Observable<Host> hostByIp(boolean history, boolean minify, String ip) {\n        if (ip == null || ip.isEmpty()) {\n            throw new IllegalArgumentException(\"Ip can't be null or empty\");\n        }\n        return apiService.hostByIp(ip, apiKey, history, minify);\n    }\n\n    /**\n     * This method behaves identical to {@link #hostSearch(String)} with the only difference that this\n     * method does not return any host results, it only returns the total number of results that\n     * matched the query and any facet information that was requested. As a result this method does\n     * not consume query credits.\n     *\n     * @param query Shodan search query. The provided string is used to search the database of banners\n     *              in Shodan, with the additional option to provide filters inside the search query using a\n     *              \"filter:value\" format\n     */\n    public Observable<FacetReport> hostCount(String query) {\n        if (query == null || query.isEmpty()) {\n            throw new IllegalArgumentException(\"Query can't be null or empty\");\n        }\n        return apiService.hostCount(apiKey, query);\n    }\n\n    /**\n     * This method behaves identical to {@link #hostSearch(String)} with the only difference that this\n     * method does not return any host results, it only returns the total number of results that\n     * matched the query and any facet information that was requested. As a result this method does\n     * not consume query credits.\n     *\n     * @param query Shodan search query. The provided string is used to search the database of banners\n     *              in Shodan, with the additional option to provide filters inside the search query using a\n     *              \"filter:value\" format\n     */\n    public Observable<FacetReport> hostCount(String query, String facets) {\n        if (query == null || query.isEmpty()) {\n            throw new IllegalArgumentException(\"Query can't be null or empty\");\n        }\n        return apiService.hostCount(apiKey, query, facets);\n    }\n\n    /**\n     * Search Shodan using the same query syntax as the website and use facets to get summary\n     * information for different properties. This method may use API query credits depending on usage.\n     * If any of the following criteria are met, your account will be deducated 1 query credit: <ul>\n     * <li>The search query contains a filter.</li> <li>Accessing results past the 1st page using the\n     * \"page\". For every 100 results past the 1st page 1 query credit is deducted.</li> </ul>\n     *\n     * @param query Shodan search query. The provided string is used to search the database of banners\n     *              in Shodan, with the additional option to provide filters inside the search query using a\n     *              \"filter:value\" format.\n     */\n    public Observable<HostReport> hostSearch(String query) {\n        if (query == null || query.isEmpty()) {\n            throw new IllegalArgumentException(\"Query can't be null or empty\");\n        }\n        return apiService.hostSearch(apiKey, query);\n    }\n\n    /**\n     * Search Shodan using the same query syntax as the website and use facets to get summary\n     * information for different properties. This method may use API query credits depending on usage.\n     * If any of the following criteria are met, your account will be deducated 1 query credit: <ul>\n     * <li>The search query contains a filter.</li> <li>Accessing results past the 1st page using the\n     * \"page\". For every 100 results past the 1st page 1 query credit is deducted.</li> </ul>\n     *\n     * @param query  Shodan search query. The provided string is used to search the database of banners\n     *               in Shodan, with the additional option to provide filters inside the search query using a\n     *               \"filter:value\" format.\n     * @param facets A comma-separated list of properties to get summary information on. Property\n     *               names can also be in the format of \"property:count\", where \"count\" is the number of facets that\n     *               will be returned for a property\n     */\n    public Observable<HostReport> hostSearch(String query, String facets) {\n        if (query == null || query.isEmpty()) {\n            throw new IllegalArgumentException(\"Query can't be null or empty\");\n        }\n        return apiService.hostSearch(apiKey, query, facets);\n    }\n\n    /**\n     * Search Shodan using the same query syntax as the website and use facets to get summary\n     * information for different properties. This method may use API query credits depending on usage.\n     * If any of the following criteria are met, your account will be deducated 1 query credit: <ul>\n     * <li>The search query contains a filter.</li> <li>Accessing results past the 1st page using the\n     * \"page\". For every 100 results past the 1st page 1 query credit is deducted.</li> </ul>\n     *\n     * @param page   The page number to page through results 100 at a time (default: 1)\n     * @param query  Shodan search query. The provided string is used to search the database of banners\n     *               in Shodan, with the additional option to provide filters inside the search query using a\n     *               \"filter:value\" format.\n     * @param facets A comma-separated list of properties to get summary information on. Property\n     *               names can also be in the format of \"property:count\", where \"count\" is the number of facets that\n     *               will be returned for a property\n     */\n    public Observable<HostReport> hostSearch(int page, String query, String facets) {\n        if (page < 0) {\n            throw new IllegalArgumentException(\"Page can't be < 0\");\n        }\n        if (query == null || query.isEmpty()) {\n            throw new IllegalArgumentException(\"Query can't be null or empty\");\n        }\n        return apiService.hostSearch(apiKey, query, facets, page);\n    }\n\n    /**\n     * Returns information about the Shodan account linked to the api key.\n     */\n    public Observable<Account> account() {\n        return apiService.account(apiKey);\n    }\n\n    /**\n     * Returns information about the API plan belonging to the given API key.\n     */", "context": "src/main/java/com/fooock/shodan/model/protocol/Protocol.java\npublic class Protocol {\n\n    private final String name;\n    private final String description;\n\n    Protocol(String name, String description) {\n        this.name = name;\n        this.description = description;\n    }\n\n    /**\n     * @return Name of the protocol\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @return Basic description of the protocol\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    @Override\n    public String toString() {\n        return \"Protocol{\" +\n                \"name='\" + name + '\\'' +\n                \", description='\" + description + '\\'' +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/host/HostReport.java\npublic class HostReport {\n\n    private final int total;\n\n    @SerializedName(\"matches\")\n    private final List<Banner> banners;\n    private final FacetReport facets;\n\n    public HostReport(int total, List<Banner> hosts, FacetReport facets) {\n        this.total = total;\n        this.banners = hosts;\n        this.facets = facets;\n    }\n\n    public List<Banner> getBanners() {\n        return banners;\n    }\n\n    public FacetReport getFacet() {\n        return facets;\n    }\n\n    public int getTotal() {\n        return total;\n    }\n\n    @Override\n    public String toString() {\n        return \"HostReport{\" +\n                \"total=\" + total +\n                \", banners=\" + banners +\n                \", facets=\" + facets +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/user/HttpHeader.java\npublic class HttpHeader {\n\n    private final List<Value> headers;\n\n    HttpHeader(List<Value> headers) {\n        this.headers = headers;\n    }\n\n    public List<Value> getHeaders() {\n        return headers;\n    }\n}\nsrc/main/java/com/fooock/shodan/model/dns/DnsIp.java\npublic class DnsIp {\n\n    private final String hostname;\n    private final String ip;\n\n    DnsIp(String hostname, String ip) {\n        this.hostname = hostname;\n        this.ip = ip;\n    }\n\n    public String getHostname() {\n        return hostname;\n    }\n\n    public String getIp() {\n        return ip;\n    }\n\n    @Override\n    public String toString() {\n        return \"DnsIp{\" +\n                \"hostname='\" + hostname + '\\'' +\n                \", ip='\" + ip + '\\'' +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/dns/DnsHostname.java\npublic class DnsHostname {\n\n    private final String ip;\n    private final String[] hostnames;\n\n    DnsHostname(String ip, String[] hostnames) {\n        this.ip = ip;\n        this.hostnames = hostnames;\n    }\n\n    public String getIp() {\n        return ip;\n    }\n\n    public String[] getHostnames() {\n        return hostnames;\n    }\n\n    @Override\n    public String toString() {\n        return \"DnsHostname{\" +\n                \"ip='\" + ip + '\\'' +\n                \", hostnames=\" + Arrays.toString(hostnames) +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/host/Host.java\npublic class Host {\n\n    private long ip;\n\n    private double latitude;\n    private double longitude;\n\n    private int[] ports;\n\n    private String[] hostnames;\n    private String[] tags;\n\n    @SerializedName(\"vulns\")\n    private String[] vulnerabilities;\n\n    @SerializedName(\"region_code\")\n    private String regionCode;\n\n    @SerializedName(\"area_code\")\n    private String areaCode;\n\n    @SerializedName(\"postal_code\")\n    private String postalCode;\n\n    @SerializedName(\"dma_code\")\n    private String dmaCode;\n\n    @SerializedName(\"country_code\")\n    private String countryCode;\n\n    @SerializedName(\"org\")\n    private String organization;\n    private String asn;\n    private String city;\n    private String isp;\n\n    @SerializedName(\"last_update\")\n    private String lastUpdate;\n\n    @SerializedName(\"country_code3\")\n    private String countryCode3;\n\n    @SerializedName(\"country_name\")\n    private String countryName;\n\n    @SerializedName(\"ip_str\")\n    private String ipStr;\n    private String os;\n\n    @SerializedName(\"data\")\n    private List<Banner> banners;\n\n    Host() {\n\n    }\n\n    public long getIp() {\n        return ip;\n    }\n\n    public double getLatitude() {\n        return latitude;\n    }\n\n    public double getLongitude() {\n        return longitude;\n    }\n\n    public int[] getPorts() {\n        return ports;\n    }\n\n    public String[] getHostnames() {\n        return hostnames;\n    }\n\n    public String[] getTags() {\n        return tags;\n    }\n\n    public String[] getVulnerabilities() {\n        return vulnerabilities;\n    }\n\n    public String getRegionCode() {\n        return regionCode;\n    }\n\n    public String getAreaCode() {\n        return areaCode;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public String getDmaCode() {\n        return dmaCode;\n    }\n\n    public String getCountryCode() {\n        return countryCode;\n    }\n\n    public String getOrganization() {\n        return organization;\n    }\n\n    public String getAsn() {\n        return asn;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    public String getIsp() {\n        return isp;\n    }\n\n    public String getLastUpdate() {\n        return lastUpdate;\n    }\n\n    public String getCountryCode3() {\n        return countryCode3;\n    }\n\n    public String getCountryName() {\n        return countryName;\n    }\n\n    public String getIpStr() {\n        return ipStr;\n    }\n\n    public String getOs() {\n        return os;\n    }\n\n    public List<Banner> getBanners() {\n        return banners;\n    }\n\n    @Override\n    public String toString() {\n        return \"Host{\" +\n                \"ip=\" + ip +\n                \", latitude=\" + latitude +\n                \", longitude=\" + longitude +\n                \", ports=\" + Arrays.toString(ports) +\n                \", hostnames=\" + Arrays.toString(hostnames) +\n                \", tags=\" + Arrays.toString(tags) +\n                \", vulnerabilities=\" + Arrays.toString(vulnerabilities) +\n                \", regionCode='\" + regionCode + '\\'' +\n                \", areaCode='\" + areaCode + '\\'' +\n                \", postalCode='\" + postalCode + '\\'' +\n                \", dmaCode='\" + dmaCode + '\\'' +\n                \", countryCode='\" + countryCode + '\\'' +\n                \", organization='\" + organization + '\\'' +\n                \", asn='\" + asn + '\\'' +\n                \", city='\" + city + '\\'' +\n                \", isp='\" + isp + '\\'' +\n                \", lastUpdate='\" + lastUpdate + '\\'' +\n                \", countryCode3='\" + countryCode3 + '\\'' +\n                \", countryName='\" + countryName + '\\'' +\n                \", ipStr='\" + ipStr + '\\'' +\n                \", os='\" + os + '\\'' +\n                \", banners=\" + banners +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/tag/TagReport.java\npublic class TagReport {\n\n    private final int total;\n\n    @SerializedName(\"matches\")\n    private final List<Property> tags;\n\n    TagReport(int total, List<Property> tags) {\n        this.total = total;\n        this.tags = tags;\n    }\n\n    public List<Property> getTags() {\n        return tags;\n    }\n\n    public int getTotal() {\n        return total;\n    }\n\n    @Override\n    public String toString() {\n        return \"TagReport{\" +\n                \"total=\" + total +\n                \", tags=\" + tags +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/host/FacetReport.java\npublic class FacetReport {\n\n    private final int total;\n    private final List<Facet> facets;\n\n    FacetReport(int total, List<Facet> facets) {\n        this.total = total;\n        this.facets = facets;\n    }\n\n    public int getTotal() {\n        return total;\n    }\n\n    public List<Facet> getFacets() {\n        return facets;\n    }\n\n    @Override\n    public String toString() {\n        return \"FacetReport{\" +\n                \"total=\" + total +\n                \", facets=\" + facets +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/token/TokenReport.java\npublic class TokenReport {\n\n    @SerializedName(\"string\")\n    private String query;\n\n    private String[] filters;\n    private String[] errors;\n\n    private Attributes attributes;\n\n    TokenReport() {\n\n    }\n\n    public String getQuery() {\n        return query;\n    }\n\n    public String[] getFilters() {\n        return filters;\n    }\n\n    public String[] getErrors() {\n        return errors;\n    }\n\n    public Attributes getAttributes() {\n        return attributes;\n    }\n\n    @Override\n    public String toString() {\n        return \"TokenReport{\" +\n                \"query='\" + query + '\\'' +\n                \", filters=\" + Arrays.toString(filters) +\n                \", errors=\" + Arrays.toString(errors) +\n                \", attributes=\" + attributes +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/user/ApiStatus.java\npublic class ApiStatus {\n\n    private boolean https;\n    private boolean unlocked;\n    private boolean telnet;\n\n    @SerializedName(\"query_credits\")\n    private int queryCredits;\n\n    @SerializedName(\"scan_credits\")\n    private int scanCredits;\n\n    private String plan;\n\n    ApiStatus() {\n\n    }\n\n    public boolean isHttps() {\n        return https;\n    }\n\n    void setHttps(boolean https) {\n        this.https = https;\n    }\n\n    public boolean isUnlocked() {\n        return unlocked;\n    }\n\n    void setUnlocked(boolean unlocked) {\n        this.unlocked = unlocked;\n    }\n\n    public boolean isTelnet() {\n        return telnet;\n    }\n\n    void setTelnet(boolean telnet) {\n        this.telnet = telnet;\n    }\n\n    public int getQueryCredits() {\n        return queryCredits;\n    }\n\n    void setQueryCredits(int queryCredits) {\n        this.queryCredits = queryCredits;\n    }\n\n    public int getScanCredits() {\n        return scanCredits;\n    }\n\n    void setScanCredits(int scanCredits) {\n        this.scanCredits = scanCredits;\n    }\n\n    public String getPlan() {\n        return plan;\n    }\n\n    void setPlan(String plan) {\n        this.plan = plan;\n    }\n\n    @Override\n    public String toString() {\n        return \"ApiStatus{\" +\n                \"https=\" + https +\n                \", unlocked=\" + unlocked +\n                \", telnet=\" + telnet +\n                \", queryCredits=\" + queryCredits +\n                \", scanCredits=\" + scanCredits +\n                \", plan='\" + plan + '\\'' +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/query/QueryReport.java\npublic class QueryReport {\n\n    private final int total;\n\n    @SerializedName(\"matches\")\n    private final List<Query> queries;\n\n    public QueryReport(int total, List<Query> queries) {\n        this.total = total;\n        this.queries = queries;\n    }\n\n    public int getTotal() {\n        return total;\n    }\n\n    public List<Query> getQueries() {\n        return queries;\n    }\n\n    @Override\n    public String toString() {\n        return \"QueryReport{\" +\n                \"total=\" + total +\n                \", queries=\" + queries +\n                '}';\n    }\n}\nsrc/main/java/com/fooock/shodan/model/user/Account.java\npublic class Account {\n\n    private final int credits;\n    private final boolean member;\n\n    @SerializedName(\"display_name\")\n    private final String displayName;\n    private final String created;\n\n    Account(boolean member, int credits, String displayName, String created) {\n        this.member = member;\n        this.credits = credits;\n        this.displayName = displayName;\n        this.created = created;\n    }\n\n    public boolean isMember() {\n        return member;\n    }\n\n    public int getCredits() {\n        return credits;\n    }\n\n    public String getDisplayName() {\n        return displayName;\n    }\n\n    public String getCreated() {\n        return created;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        Account account = (Account) o;\n\n        if (credits != account.credits) {\n            return false;\n        }\n        if (member != account.member) {\n            return false;\n        }\n        if (displayName != null ? !displayName.equals(account.displayName)\n                : account.displayName != null) {\n            return false;\n        }\n        return created.equals(account.created);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = credits;\n        result = 31 * result + (member ? 1 : 0);\n        result = 31 * result + (displayName != null ? displayName.hashCode() : 0);\n        result = 31 * result + created.hashCode();\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Account{\" +\n                \"credits=\" + credits +\n                \", member=\" + member +\n                \", displayName='\" + displayName + '\\'' +\n                \", created='\" + created + '\\'' +\n                '}';\n    }\n}\n", "answers": ["    public Observable<ApiStatus> info() {"], "length": 2260, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "88a9a2fd897099b9188ea9e362ef12ca36bf8bf75c2a3382"}
{"input": "package com.glooory.flatreader.ui.ribao;\r\nimport android.content.Context;\r\nimport android.os.Bundle;\r\nimport android.support.annotation.Nullable;\r\nimport android.support.v4.widget.SwipeRefreshLayout;\r\nimport android.support.v7.widget.LinearLayoutManager;\r\nimport android.support.v7.widget.RecyclerView;\r\nimport android.view.LayoutInflater;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\nimport com.chad.library.adapter.base.BaseQuickAdapter;\r\nimport com.chad.library.adapter.base.listener.OnItemChildClickListener;\r\nimport com.glooory.flatreader.R;\r\nimport com.glooory.flatreader.adapter.RibaoSectionAdapter;\r\nimport com.glooory.flatreader.base.BaseFragment;\r\nimport com.glooory.flatreader.base.MyApplication;\r\nimport com.glooory.flatreader.entity.ribao.RibaoStoryBean;\r\nimport com.glooory.flatreader.greendao.DaoSession;\r\nimport com.glooory.flatreader.greendao.RibaoStoryBeanDao;\r\nimport com.glooory.flatreader.callback.OnSectionChangeListener;\r\nimport com.glooory.flatreader.ui.main.MainActivity;\r\nimport com.glooory.flatreader.ui.storydetail.StoryDetailActivity;\r\nimport com.glooory.flatreader.util.GreenDaoUtils;\r\nimport java.util.List;\r\nimport butterknife.ButterKnife;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Created by Glooory on 2016/9/29 0029 17:38.\r\n */\r\n\r\npublic class RibaoFragment extends BaseFragment implements RibaoContract.View,\r\n        SwipeRefreshLayout.OnRefreshListener,\r\n        BaseQuickAdapter.RequestLoadMoreListener {\r\n    private RecyclerView mRecyclerView;\r\n    private SwipeRefreshLayout mSwipeLayout;\r\n    private RibaoContract.Presenter mPresenter;\r\n    private RibaoSectionAdapter mAdapter;\r\n    private int mPageSize = 30; //用来触发Adapter上拉自动加载的关键字\r\n    private LinearLayoutManager mLinearLayoutManager;\r\n    private String mCurrentTitle;\r\n    private OnSectionChangeListener mSectionListener;\r\n    private RibaoStoryBeanDao mRibaoDao;\r\n\r\n    public static RibaoFragment newInstance() {\r\n        return new RibaoFragment();\r\n    }\r\n\r\n    @Override\r\n    public void onAttach(Context context) {\r\n        super.onAttach(context);\r\n        if (context instanceof MainActivity) {\r\n            mSectionListener = (OnSectionChangeListener) context;\r\n        }\r\n        mCurrentTitle = context.getString(R.string.title_ribao_latest);\r\n        DaoSession daoSession = ((MyApplication) context.getApplicationContext()).getDaoSession();\r\n        mRibaoDao = daoSession.getRibaoStoryBeanDao();\r\n    }\r\n\r\n    @Override\r\n    public void onCreate(@Nullable Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        new RibaoPresenter(mContext, this);\r\n    }\r\n\r\n    @Nullable\r\n    @Override\r\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\r\n        mSwipeLayout = (SwipeRefreshLayout) inflater.inflate(R.layout.view_swipe_recycler, container, false);\r\n        initView();\r\n        mPresenter.getLatestStories();\r\n        return mSwipeLayout;\r\n    }\r\n\r\n    private void initView() {\r\n        mSwipeLayout.setColorSchemeColors(mContext.getResources().getColor(R.color.red_g_i), mContext.getResources().getColor(R.color.green_g_i),\r\n                mContext.getResources().getColor(R.color.blue_g_i), mContext.getResources().getColor(R.color.yellow_g_i));\r\n        mSwipeLayout.setOnRefreshListener(this);\r\n        mRecyclerView = ButterKnife.findById(mSwipeLayout, R.id.recycler);\r\n        mLinearLayoutManager = new LinearLayoutManager(mContext);\r\n        mRecyclerView.setLayoutManager(mLinearLayoutManager);\r\n        initAdapter();\r\n        mRecyclerView.setAdapter(mAdapter);\r\n\r\n    }\r\n\r\n    private void initAdapter() {\r\n        mAdapter = new RibaoSectionAdapter(mContext);\r\n\r\n        //正在加载的footer\r\n        View loadingFooter = LayoutInflater.from(mContext).inflate(R.layout.view_loading_footer, mRecyclerView, false);\r\n        mAdapter.setLoadingView(loadingFooter);\r\n\r\n        mRecyclerView.addOnItemTouchListener(new OnItemChildClickListener() {\r\n            @Override\r\n            public void SimpleOnItemChildClick(BaseQuickAdapter baseQuickAdapter, View view, int i) {\r\n                if (!GreenDaoUtils.isEntityExists(mRibaoDao,\r", "context": "app/src/main/java/com/glooory/flatreader/adapter/RibaoSectionAdapter.java\npublic class RibaoSectionAdapter extends BaseSectionQuickAdapter<RibaoStoryBean> {\r\n    private Context mContext;\r\n    private RibaoStoryBeanDao mRibaoDao;\r\n\r\n    public RibaoSectionAdapter(Context context) {\r\n        super(R.layout.cardview_ribao_item, R.layout.view_section_header_ribao, null);\r\n        this.mContext = context;\r\n        DaoSession daoSession = ((MyApplication) context.getApplicationContext()).getDaoSession();\r\n        mRibaoDao = daoSession.getRibaoStoryBeanDao();\r\n    }\r\n\r\n    @Override\r\n    protected void convertHead(BaseViewHolder holder, RibaoStoryBean bean) {\r\n        holder.setText(R.id.tv_section_header_ribao, bean.header);\r\n    }\r\n\r\n    @Override\r\n    protected void convert(BaseViewHolder holder, RibaoStoryBean bean) {\r\n\r\n        if (bean.isMultipic()) {\r\n            holder.getView(R.id.tv_multipic).setVisibility(View.VISIBLE);\r\n        } else {\r\n            holder.getView(R.id.tv_multipic).setVisibility(View.INVISIBLE);\r\n        }\r\n        if (GreenDaoUtils.isEntityExists(mRibaoDao, RibaoStoryBeanDao.Properties.Id.eq(bean.getId()))) {\r\n            ((TextView) holder.getView(R.id.tv_ribao_item_title))\r\n                    .setTextColor(mContext.getResources().getColor(R.color.colorSecondaryText));\r\n        } else {\r\n            ((TextView) holder.getView(R.id.tv_ribao_item_title))\r\n                    .setTextColor(mContext.getResources().getColor(R.color.colorPrimaryText));\r\n        }\r\n        holder.setText(R.id.tv_ribao_item_title, bean.getTitle())\r\n                .addOnClickListener(R.id.cardview_ribao_item);\r\n\r\n        ImageLoader.load(mContext, (ImageView) holder.getView(R.id.img_card_ribao_item), bean.getImages().get(0));\r\n    }\r\n}\r\napp/src/main/java/com/glooory/flatreader/base/BaseFragment.java\npublic class BaseFragment extends Fragment {\r\n    protected Context mContext;\r\n\r\n    @Override\r\n    public void onAttach(Context context) {\r\n        super.onAttach(context);\r\n        this.mContext = context;\r\n    }\r\n\r\n    @Override\r\n    public void onResume() {\r\n        super.onResume();\r\n        MobclickAgent.onPageStart(getClass().getSimpleName());\r\n    }\r\n\r\n    @Override\r\n    public void onPause() {\r\n        super.onPause();\r\n        MobclickAgent.onPageEnd(getClass().getSimpleName());\r\n    }\r\n}\r\napp/src/main/java/com/glooory/flatreader/greendao/DaoSession.java\npublic class DaoSession extends AbstractDaoSession {\n\n    private final DaoConfig gankBeanDaoConfig;\n    private final DaoConfig iTHomeItemBeanDaoConfig;\n    private final DaoConfig ribaoStoryBeanDaoConfig;\n\n    private final GankBeanDao gankBeanDao;\n    private final ITHomeItemBeanDao iTHomeItemBeanDao;\n    private final RibaoStoryBeanDao ribaoStoryBeanDao;\n\n    public DaoSession(Database db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>\n            daoConfigMap) {\n        super(db);\n\n        gankBeanDaoConfig = daoConfigMap.get(GankBeanDao.class).clone();\n        gankBeanDaoConfig.initIdentityScope(type);\n\n        iTHomeItemBeanDaoConfig = daoConfigMap.get(ITHomeItemBeanDao.class).clone();\n        iTHomeItemBeanDaoConfig.initIdentityScope(type);\n\n        ribaoStoryBeanDaoConfig = daoConfigMap.get(RibaoStoryBeanDao.class).clone();\n        ribaoStoryBeanDaoConfig.initIdentityScope(type);\n\n        gankBeanDao = new GankBeanDao(gankBeanDaoConfig, this);\n        iTHomeItemBeanDao = new ITHomeItemBeanDao(iTHomeItemBeanDaoConfig, this);\n        ribaoStoryBeanDao = new RibaoStoryBeanDao(ribaoStoryBeanDaoConfig, this);\n\n        registerDao(GankBean.class, gankBeanDao);\n        registerDao(ITHomeItemBean.class, iTHomeItemBeanDao);\n        registerDao(RibaoStoryBean.class, ribaoStoryBeanDao);\n    }\n    \n    public void clear() {\n        gankBeanDaoConfig.clearIdentityScope();\n        iTHomeItemBeanDaoConfig.clearIdentityScope();\n        ribaoStoryBeanDaoConfig.clearIdentityScope();\n    }\n\n    public GankBeanDao getGankBeanDao() {\n        return gankBeanDao;\n    }\n\n    public ITHomeItemBeanDao getITHomeItemBeanDao() {\n        return iTHomeItemBeanDao;\n    }\n\n    public RibaoStoryBeanDao getRibaoStoryBeanDao() {\n        return ribaoStoryBeanDao;\n    }\n\n}\napp/src/main/java/com/glooory/flatreader/ui/main/MainActivity.java\npublic class MainActivity extends BaseActivity\r\n        implements NavigationView.OnNavigationItemSelectedListener,\r\n        OnSectionChangeListener, MainContract.View {\r\n    public static final int EXTERNAL_REQUEST_CODE = 409;\r\n\r\n    @BindView(R.id.toolbar)\r\n    Toolbar mToolbar;\r\n    @BindView(R.id.nav_view)\r\n    NavigationView mNavView;\r\n    @BindView(R.id.drawer_layout)\r\n    DrawerLayout mDrawer;\r\n\r\n    private MainContract.Presenter mPresenter;\r\n    private VersionInfoBean mVersionInfoBean;\r\n    private long exitTime;\r\n\r\n    private RationaleListener mRationaleListener = new RationaleListener() {\r\n        @Override\r\n        public void showRequestPermissionRationale(int requestCode, final Rationale rationale) {\r\n            new AlertDialog.Builder(MainActivity.this)\r\n                    .setTitle(R.string.external_permission_tip)\r\n                    .setMessage(R.string.external_permission_des)\r\n                    .setPositiveButton(\"好的\", new DialogInterface.OnClickListener() {\r\n                        @Override\r\n                        public void onClick(DialogInterface dialog, int which) {\r\n                            dialog.cancel();\r\n                            rationale.resume();\r\n                        }\r\n                    })\r\n                    .setNegativeButton(\"我拒绝\", new DialogInterface.OnClickListener() {\r\n                        @Override\r\n                        public void onClick(DialogInterface dialog, int which) {\r\n                            dialog.cancel();\r\n                            rationale.cancel();\r\n                        }\r\n                    }).show();\r\n        }\r\n    };\r\n\r\n    @Override\r\n    public void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n        setupWindowAnimations();\r\n        ButterKnife.bind(this);\r\n        new MainPresenter(this);\r\n        initView();\r\n        initRibaoUI();\r\n        mPresenter.checkUpdate();\r\n    }\r\n\r\n    private void setupWindowAnimations() {\r\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {\r\n            Slide slide = new Slide(Gravity.RIGHT);\r\n            slide.setDuration(200);\r\n            getWindow().setExitTransition(slide);\r\n        }\r\n    }\r\n\r\n    private void initView() {\r\n        setSupportActionBar(mToolbar);\r\n        getSupportActionBar().setTitle(R.string.title_ribao_latest);\r\n\r\n        mDrawer = (DrawerLayout) findViewById(R.id.drawer_layout);\r\n        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(\r\n                this, mDrawer, mToolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);\r\n        mDrawer.setDrawerListener(toggle);\r\n        toggle.syncState();\r\n\r\n        mNavView.setNavigationItemSelectedListener(this);\r\n        mNavView.getMenu().getItem(0).setChecked(true); //默认选中第一个选项\r\n    }\r\n\r\n    @Override\r\n    protected void setStatusBar() {\r\n        StatusBarUtil.setColorForDrawerLayout(this,\r\n                (DrawerLayout) findViewById(R.id.drawer_layout),\r\n                getResources().getColor(R.color.colorPrimaryDark),\r\n                0);\r\n    }\r\n\r\n    @Override\r\n    public void onBackPressed() {\r\n        if (mDrawer.isDrawerOpen(GravityCompat.START)) {\r\n            mDrawer.closeDrawer(GravityCompat.START);\r\n        } else {\r\n            super.onBackPressed();\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"StatementWithEmptyBody\")\r\n    @Override\r\n    public boolean onNavigationItemSelected(MenuItem item) {\r\n        // Handle navigation view item clicks here.\r\n        int id = item.getItemId();\r\n        switch (id) {\r\n            case R.id.nav_ribao:\r\n                initRibaoUI();\r\n                break;\r\n            case R.id.nav_gank:\r\n                getSupportActionBar().setTitle(getString(R.string.nav_gank_title));\r\n                getSupportFragmentManager().beginTransaction()\r\n                        .replace(R.id.content_main, GankFragment.newInstance()).commit();\r\n                break;\r\n            case R.id.nav_ithome:\r\n                getSupportActionBar().setTitle(getString(R.string.nav_it_title));\r\n                getSupportFragmentManager().beginTransaction()\r\n                        .replace(R.id.content_main, ITHomeFragment.newInstance()).commit();\r\n                break;\r\n            case R.id.nav_settings:\r\n                SettingsActivity.launch(MainActivity.this);\r\n                break;\r\n        }\r\n\r\n        mDrawer.closeDrawer(GravityCompat.START);\r\n        return true;\r\n    }\r\n\r\n    private void initRibaoUI() {\r\n        getSupportActionBar().setTitle(getString(R.string.title_ribao_latest));\r\n        getSupportFragmentManager().beginTransaction()\r\n                .replace(R.id.content_main, RibaoFragment.newInstance()).commit();\r\n    }\r\n\r\n    @Override\r\n    public void onSectionChange(String sectionTitle) {\r\n        getSupportActionBar().setTitle(sectionTitle);\r\n    }\r\n\r\n    @Override\r\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\r\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {\r\n            if (mDrawer.isDrawerOpen(GravityCompat.START)) {\r\n                mDrawer.closeDrawer(GravityCompat.START);\r\n            } else {\r\n                if (System.currentTimeMillis() - exitTime > 2000) {\r\n                    ToastUtils.showToastShort(R.string.exit_hint);\r\n                    exitTime = System.currentTimeMillis();\r\n                } else {\r\n                    finishSelf();\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return super.onKeyDown(keyCode, event);\r\n    }\r\n\r\n    @Override\r\n    protected void onResume() {\r\n        super.onResume();\r\n    }\r\n\r\n    @Override\r\n    public void showUpdateDialog(final VersionInfoBean bean) {\r\n        this.mVersionInfoBean = bean;\r\n        AlertDialog.Builder builder = new AlertDialog.Builder(this)\r\n                .setTitle(R.string.new_version_available)\r\n                .setMessage(String.format(getString(R.string.new_version_des), bean.getVersionname(), bean.getReleaseinfo(), bean.getSize()))\r\n                .setCancelable(false)\r\n                .setPositiveButton(R.string.download_new_version, new DialogInterface.OnClickListener() {\r\n                    @Override\r\n                    public void onClick(DialogInterface dialog, int which) {\r\n                        AndPermission.with(MainActivity.this)\r\n                                .requestCode(EXTERNAL_REQUEST_CODE)\r\n                                .permission(Manifest.permission.WRITE_EXTERNAL_STORAGE)\r\n                                .rationale(mRationaleListener)\r\n                                .send();\r\n                    }\r\n                })\r\n                .setNegativeButton(R.string.cancle, new DialogInterface.OnClickListener() {\r\n                    @Override\r\n                    public void onClick(DialogInterface dialog, int which) {\r\n                        SharedPreferences.Editor editor = getSharedPreferences(SPUtils.SP_NAME, Context.MODE_PRIVATE).edit();\r\n                        editor.putBoolean(Constants.DONNOT_REMIND_ANYMORE, true);\r\n                        editor.putInt(Constants.NEWEST_VERSION_CODE, bean.getVersioncode());\r\n                        editor.apply();\r\n                    }\r\n                });\r\n        builder.create().show();\r\n    }\r\n\r\n    private void actionDownload(VersionInfoBean bean) {\r\n        DownloadService.launch(MainActivity.this,\r\n                bean.getFilename());\r\n    }\r\n\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\r\n        AndPermission.onRequestPermissionsResult(this, requestCode, permissions, grantResults);\r\n    }\r\n\r\n    /**\r\n     * 请求获取 External 权限成功的回调\r\n     */\r\n    @PermissionYes(EXTERNAL_REQUEST_CODE)\r\n    private void getWriteExternalYes() {\r\n        actionDownload(mVersionInfoBean);\r\n    }\r\n\r\n    /**\r\n     * 请求读写 External 权限失败的回调\r\n     */\r\n    @PermissionNo(EXTERNAL_REQUEST_CODE)\r\n    private void getWriteExternalNo() {\r\n        ToastUtils.showToastShort(R.string.external_permission_failed);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void setPresenter(MainContract.Presenter presenter) {\r\n        this.mPresenter = presenter;\r\n    }\r\n\r\n    @Override\r\n    public void showProgress() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void dismissProgress() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void showLoadFailed() {\r\n\r\n    }\r\n}\r\napp/src/main/java/com/glooory/flatreader/callback/OnSectionChangeListener.java\npublic interface OnSectionChangeListener {\r\n\r\n    void onSectionChange(String sectionTitle);\r\n\r\n}\r\napp/src/main/java/com/glooory/flatreader/greendao/RibaoStoryBeanDao.java\npublic class RibaoStoryBeanDao extends AbstractDao<RibaoStoryBean, Long> {\n\n    public static final String TABLENAME = \"ribao\";\n\n    /**\n     * Properties of entity RibaoStoryBean.<br/>\n     * Can be used for QueryBuilder and for referencing column names.\n     */\n    public static class Properties {\n        public final static Property IdPrimary = new Property(0, Long.class, \"idPrimary\", true, \"_id\");\n        public final static Property Id = new Property(1, String.class, \"id\", false, \"NEWS_ID\");\n    }\n\n\n    public RibaoStoryBeanDao(DaoConfig config) {\n        super(config);\n    }\n    \n    public RibaoStoryBeanDao(DaoConfig config, DaoSession daoSession) {\n        super(config, daoSession);\n    }\n\n    /** Creates the underlying database table. */\n    public static void createTable(Database db, boolean ifNotExists) {\n        String constraint = ifNotExists? \"IF NOT EXISTS \": \"\";\n        db.execSQL(\"CREATE TABLE \" + constraint + \"\\\"ribao\\\" (\" + //\n                \"\\\"_id\\\" INTEGER PRIMARY KEY AUTOINCREMENT ,\" + // 0: idPrimary\n                \"\\\"NEWS_ID\\\" TEXT UNIQUE );\"); // 1: id\n    }\n\n    /** Drops the underlying database table. */\n    public static void dropTable(Database db, boolean ifExists) {\n        String sql = \"DROP TABLE \" + (ifExists ? \"IF EXISTS \" : \"\") + \"\\\"ribao\\\"\";\n        db.execSQL(sql);\n    }\n\n    @Override\n    protected final void bindValues(DatabaseStatement stmt, RibaoStoryBean entity) {\n        stmt.clearBindings();\n \n        Long idPrimary = entity.getIdPrimary();\n        if (idPrimary != null) {\n            stmt.bindLong(1, idPrimary);\n        }\n \n        String id = entity.getId();\n        if (id != null) {\n            stmt.bindString(2, id);\n        }\n    }\n\n    @Override\n    protected final void bindValues(SQLiteStatement stmt, RibaoStoryBean entity) {\n        stmt.clearBindings();\n \n        Long idPrimary = entity.getIdPrimary();\n        if (idPrimary != null) {\n            stmt.bindLong(1, idPrimary);\n        }\n \n        String id = entity.getId();\n        if (id != null) {\n            stmt.bindString(2, id);\n        }\n    }\n\n    @Override\n    public Long readKey(Cursor cursor, int offset) {\n        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);\n    }    \n\n    @Override\n    public RibaoStoryBean readEntity(Cursor cursor, int offset) {\n        RibaoStoryBean entity = new RibaoStoryBean( //\n            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // idPrimary\n            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1) // id\n        );\n        return entity;\n    }\n     \n    @Override\n    public void readEntity(Cursor cursor, RibaoStoryBean entity, int offset) {\n        entity.setIdPrimary(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));\n        entity.setId(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));\n     }\n    \n    @Override\n    protected final Long updateKeyAfterInsert(RibaoStoryBean entity, long rowId) {\n        entity.setIdPrimary(rowId);\n        return rowId;\n    }\n    \n    @Override\n    public Long getKey(RibaoStoryBean entity) {\n        if(entity != null) {\n            return entity.getIdPrimary();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public boolean hasKey(RibaoStoryBean entity) {\n        return entity.getIdPrimary() != null;\n    }\n\n    @Override\n    protected final boolean isEntityUpdateable() {\n        return true;\n    }\n    \n}\napp/src/main/java/com/glooory/flatreader/util/GreenDaoUtils.java\npublic class GreenDaoUtils {\r\n\r\n    private GreenDaoUtils() {\r\n    }\r\n\r\n    public static boolean isEntityExists(AbstractDao dao, WhereCondition condition) {\r\n        return dao.queryBuilder()\r\n                .where(condition)\r\n                .build()\r\n                .list()\r\n                .size() >= 1;\r\n    }\r\n\r\n    public static void insert(AbstractDao dao, Object entity, Property property) {\r\n        if (dao.queryBuilder().count() >= 400) {\r\n            Object firstEntity = dao.queryBuilder()\r\n                    .orderAsc(property)\r\n                    .build()\r\n                    .list()\r\n                    .get(0);\r\n            dao.delete(firstEntity);\r\n        }\r\n        dao.insert(entity);\r\n    }\r\n\r\n}\r\napp/src/main/java/com/glooory/flatreader/base/MyApplication.java\npublic class MyApplication extends Application {\r\n    public static MyApplication sInstance;\r\n    private DaoSession mDaoSession;\r\n\r\n    public static MyApplication getInstance() {\r\n        return sInstance;\r\n    }\r\n\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n        sInstance = this;\r\n        Logger.init();\r\n\r\n        if (LeakCanary.isInAnalyzerProcess(this)) {\r\n            // This process is dedicated to LeakCanary for heap analysis.\r\n            // You should not init your app in this process.\r\n            return;\r\n        }\r\n        LeakCanary.install(this);\r\n        // Normal app init code..\r\n\r\n        //init greendao\r\n        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, \"IsRead.db\");\r\n        Database db = helper.getWritableDb();\r\n        mDaoSession = new DaoMaster(db).newSession();\r\n    }\r\n\r\n    public DaoSession getDaoSession() {\r\n        return mDaoSession;\r\n    }\r\n}\r\napp/src/main/java/com/glooory/flatreader/entity/ribao/RibaoStoryBean.java\n@Entity(\r\n\r\n        nameInDb = \"ribao\"\r\n)\r\npublic class RibaoStoryBean extends SectionEntity {\r\n    /**\r\n     * images : [\"http://pic2.zhimg.com/7b2ea76fbdf40f866b043b989204e111.jpg\"]\r\n     * multipic : true\r\n     * type : 0\r\n     * id : 8845106\r\n     * ga_prefix : 093016\r\n     * title : 咨询公司制订了特别厉害的战略，可是怎么执行才好\r\n     */\r\n    @Id(autoincrement = true)\r\n    private Long idPrimary;\r\n\r\n    @Transient\r\n    private boolean multipic;\r\n\r\n    @Transient\r\n    private int type;\r\n\r\n    @Property(nameInDb = \"NEWS_ID\")\r\n    @Unique\r\n    private String id;\r\n\r\n    @Transient\r\n    private String ga_prefix;\r\n\r\n    @Transient\r\n    private String title;\r\n\r\n    @Transient\r\n    private String date;\r\n\r\n    @Transient\r\n    private List<String> images;\r\n\r\n    public RibaoStoryBean() {\r\n        super(false, null);\r\n    }\r\n\r\n    public RibaoStoryBean(boolean isHeader, String header) {\r\n        super(isHeader, header);\r\n    }\r\n\r\n    public RibaoStoryBean(Object o) {\r\n        super(o);\r\n    }\r\n\r\n    @Keep\r\n    public RibaoStoryBean(Long idPrimary, String id) {\r\n        super(false, null);\r\n        this.idPrimary = idPrimary;\r\n        this.id = id;\r\n    }\r\n\r\n    public String getDate() {\r\n        return date;\r\n    }\r\n\r\n    public void setDate(String date) {\r\n        this.date = date;\r\n    }\r\n\r\n    public boolean isMultipic() {\r\n        return multipic;\r\n    }\r\n\r\n    public void setMultipic(boolean multipic) {\r\n        this.multipic = multipic;\r\n    }\r\n\r\n    public int getType() {\r\n        return type;\r\n    }\r\n\r\n    public void setType(int type) {\r\n        this.type = type;\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getGa_prefix() {\r\n        return ga_prefix;\r\n    }\r\n\r\n    public void setGa_prefix(String ga_prefix) {\r\n        this.ga_prefix = ga_prefix;\r\n    }\r\n\r\n    public String getTitle() {\r\n        return title;\r\n    }\r\n\r\n    public void setTitle(String title) {\r\n        this.title = title;\r\n    }\r\n\r\n    public List<String> getImages() {\r\n        return images;\r\n    }\r\n\r\n    public void setImages(List<String> images) {\r\n        this.images = images;\r\n    }\r\n\r\n    public Long getIdPrimary() {\r\n        return this.idPrimary;\r\n    }\r\n\r\n    public void setIdPrimary(Long _id) {\r\n        this.idPrimary = _id;\r\n    }\r\n}\r\napp/src/main/java/com/glooory/flatreader/ui/storydetail/StoryDetailActivity.java\npublic class StoryDetailActivity extends BaseActivity implements StoryDetailContract.StoryDetailView {\r\n    @BindView(R.id.img_story_pic)\r\n    ImageView mStoryHeadImg;\r\n    @BindView(R.id.toolbar_story)\r\n    Toolbar mToolbar;\r\n    @BindView(R.id.webview_story)\r\n    WebView mWebview;\r\n    @BindView(R.id.coordinator_story)\r\n    CoordinatorLayout mCoordinator;\r\n    @BindView(R.id.collapsing_toolbar_story)\r\n    CollapsingToolbarLayout mCollapsingToolbar;\r\n\r\n    private String mStoryId;\r\n    private StoryDetailContract.StoryDetailPresenter mPresenter;\r\n\r\n    public static void launch(Activity activity, String storyId, ImageView tranImg) {\r\n        Intent intent = new Intent(activity, StoryDetailActivity.class);\r\n        intent.putExtra(Constants.STORY_ID, storyId);\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n            tranImg.setTransitionName(activity.getString(R.string.shared_imga_transition_name));\r\n            activity.startActivity(intent, ActivityOptionsCompat.makeSceneTransitionAnimation(\r\n                    activity, tranImg, activity.getString(R.string.shared_imga_transition_name)\r\n            ).toBundle());\r\n        } else {\r\n            activity.startActivity(intent);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_story);\r\n        setupWindowAnimations();\r\n        ButterKnife.bind(this);\r\n        new StoryDetailPresenter(mContext, this);\r\n        mStoryId = getIntent().getStringExtra(Constants.STORY_ID);\r\n        initView();\r\n        checkNetwork();\r\n        mPresenter.loadStory(mStoryId);\r\n    }\r\n\r\n    private void setupWindowAnimations() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n            Fade fade = new Fade();\r\n            fade.setDuration(200);\r\n            getWindow().setAllowEnterTransitionOverlap(true);\r\n            getWindow().setAllowReturnTransitionOverlap(true);\r\n            getWindow().setEnterTransition(fade);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void setStatusBar() {\r\n    }\r\n\r\n    private void initView() {\r\n        setSupportActionBar(mToolbar);\r\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\r\n        getSupportActionBar().setTitle(\"\");\r\n\r\n        //配置Webview\r\n//        if (Build.VERSION.SDK_INT >= 19) {\r\n//            mWebview.setLayerType(View.LAYER_TYPE_HARDWARE, null);\r\n//        }\r\n//        else {\r\n//            mWebview.setLayerType(View.LAYER_TYPE_SOFTWARE, null);\r\n//        }\r\n        WebSettings webSettings = mWebview.getSettings();\r\n        webSettings.setJavaScriptEnabled(true);\r\n        webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);\r\n        webSettings.setLoadWithOverviewMode(true);\r\n        webSettings.setDomStorageEnabled(true);\r\n        webSettings.setDatabaseEnabled(true);\r\n        webSettings.setAppCachePath(getCacheDir().getAbsolutePath() + \"/webviewcache\");\r\n        webSettings.setAppCacheEnabled(true);\r\n        webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);\r\n        mWebview.setWebChromeClient(new WebChromeClient());\r\n    }\r\n\r\n    private void loadStoryContent(RibaoStoryContentBean bean) {\r\n        ImageLoader.load(StoryDetailActivity.this, mStoryHeadImg, bean.getImage());\r\n        mCollapsingToolbar.setTitle(bean.getTitle());\r\n        String url = bean.getShare_url();\r\n        boolean isEmpty = TextUtils.isEmpty(bean.getBody());\r\n        String storyBody = bean.getBody();\r\n        List<String> cssList = bean.getCss();\r\n\r\n        if (isEmpty) {\r\n            mWebview.loadUrl(url);\r\n        } else {\r\n            String data = WebUtils.buildHtmlWithCss(storyBody, cssList, false);\r\n            mWebview.loadDataWithBaseURL(WebUtils.BASE_URL, data, WebUtils.MIME_TYPE, WebUtils.ENCODING, WebUtils.FAIL_URL);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void showStoryContent(RibaoStoryContentBean bean) {\r\n        loadStoryContent(bean);\r\n    }\r\n\r\n    @Override\r\n    public void setPresenter(StoryDetailContract.StoryDetailPresenter presenter) {\r\n        this.mPresenter = presenter;\r\n    }\r\n\r\n    @Override\r\n    public void showProgress() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void dismissProgress() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void showLoadFailed() {\r\n    }\r\n\r\n    @Override\r\n    protected void onDestroy() {\r\n        super.onDestroy();\r\n        if (mWebview != null && mWebview.getParent() != null) {\r\n            ((ViewGroup) mWebview.getParent()).removeView(mWebview);\r\n            mWebview.destroy();\r\n            mWebview = null;\r\n        }\r\n        if (mPresenter != null) {\r\n            mPresenter.detachView();\r\n        }\r\n    }\r\n}\r\n", "answers": ["                        RibaoStoryBeanDao.Properties.Id.eq(((RibaoStoryBean) mAdapter.getItem(i)).getId()))) {\r"], "length": 1936, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "281545dd015defdcfc5daf9f7dc2b02a9e3e3a2ac5bda2f5"}
{"input": "import datetime\nimport random\nfrom fints.exceptions import FinTSError\nfrom .formals import (\n    AlgorithmParameterIVName, AlgorithmParameterName, CompressionFunction,\n    DateTimeType, EncryptionAlgorithm, EncryptionAlgorithmCoded,\n    HashAlgorithm, IdentifiedRole, KeyName, KeyType, OperationMode,\n    SecurityApplicationArea, SecurityDateTime,\n    SecurityIdentificationDetails, SecurityMethod, SecurityProfile,\n    SecurityRole, SignatureAlgorithm, UsageEncryption, UserDefinedSignature,\n)\nfrom .message import FinTSMessage\nfrom .segments.message import HNSHA2, HNSHK4, HNVSD1, HNVSK3\nfrom .types import SegmentSequence\n\n\n\nclass EncryptionMechanism:\n    def encrypt(self, message: FinTSMessage):\n        raise NotImplemented()\n\n    def decrypt(self, message: FinTSMessage):\n        raise NotImplemented()\n\n\nclass AuthenticationMechanism:\n    def sign_prepare(self, message: FinTSMessage):\n        raise NotImplemented()\n    \n    def sign_commit(self, message: FinTSMessage):\n        raise NotImplemented()\n    \n    def verify(self, message: FinTSMessage):\n        raise NotImplemented()\n\n\nclass PinTanDummyEncryptionMechanism(EncryptionMechanism):\n    def __init__(self, security_method_version=1):\n        super().__init__()\n        self.security_method_version = security_method_version\n\n    def encrypt(self, message: FinTSMessage):\n        assert message.segments[0].header.type == 'HNHBK'\n        assert message.segments[-1].header.type == 'HNHBS'\n\n        plain_segments = message.segments[1:-1]\n        del message.segments[1:-1]\n\n        _now = datetime.datetime.now()\n\n        message.segments.insert(\n            1,\n            HNVSK3(\n                security_profile=SecurityProfile(SecurityMethod.PIN, self.security_method_version),\n                security_function='998',\n", "context": "fints/formals.py\nclass AlgorithmParameterIVName(RepresentableEnum):\n    IVC = '1' #: Initialization value, clear text\nfints/formals.py\nclass OperationMode(RepresentableEnum):\n    CBC = '2'  #: Cipher Block Chaining\n    ISO_9796_1 = '16'  #: ISO 9796-1 (bei RDH)\n    ISO_9796_2_RANDOM = '17'  #: ISO 9796-2 mit Zufallszahl (bei RDH)\n    PKCS1V15 = '18'  #: RSASSA-PKCS#1 V1.5 (bei RDH); RSAES-PKCS#1 V1.5 (bei RAH, RDH)\n    PSS = '19'  #: RSASSA-PSS (bei RAH, RDH)\n    ZZZ = '999'  #: Gegenseitig vereinbart (DDV: Retail-MAC)\nfints/formals.py\nclass SecurityApplicationArea(RepresentableEnum):\n    \"\"\"Bereich der Sicherheitsapplikation, kodiert, version 2\n\n    Informationen darüber, welche Daten vom kryptographischen Prozess verarbeitet werden.\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    SHM = '1'  #: Signaturkopf und HBCI-Nutzdaten\n    SHT = '2'  #: Von Signaturkopf bis Signaturabschluss\nfints/formals.py\nclass EncryptionAlgorithmCoded(RepresentableEnum):\n    TWOKEY3DES = '13' #: 2-Key-Triple-DES\n    AES256 = '14' #: AES-256\nfints/formals.py\nclass AlgorithmParameterName(RepresentableEnum):\n    KYE = '5' #: Symmetrischer Schlüssel, verschlüsselt mit symmetrischem Schlüssel\n    KYP = '6' #: Symmetrischer Schlüssel, verschlüsselt mit öffentlichem Schlüssel\nfints/formals.py\nclass HashAlgorithm(DataElementGroup):\n    usage_hash = DataElementField(type='code', max_length=3)\n    hash_algorithm = DataElementField(type='code', max_length=3)\n    algorithm_parameter_name = DataElementField(type='code', max_length=3)\n    algorithm_parameter_value = DataElementField(type='bin', max_length=512, required=False)\nfints/formals.py\nclass UsageEncryption(RepresentableEnum):\n    OSY = '2'  #: Owner Symmetric\nfints/segments/message.py\nclass HNVSD1(FinTS3Segment):\n    \"\"\"Verschlüsselte Daten, version 1\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    data = SegmentSequenceField(_d=\"Daten, verschlüsselt\")\nfints/message.py\nclass FinTSMessage(SegmentSequence):\n    DIRECTION = None\n    # Auto-Numbering, dialog relation, security base\n\n    def __init__(self, dialog=None, *args, **kwargs):\n        self.dialog = dialog\n        self.next_segment_number = 1\n        super().__init__(*args, **kwargs)\n\n    def __iadd__(self, segment: FinTS3Segment):\n        if not isinstance(segment, FinTS3Segment):\n            raise TypeError(\"Can only append FinTS3Segment instances, not {!r}\".format(segment))\n        segment.header.number = self.next_segment_number\n        self.next_segment_number += 1\n        self.segments.append(segment)\n        return self\n\n    def response_segments(self, ref, *args, **kwargs):\n        for segment in self.find_segments(*args, **kwargs):\n            if segment.header.reference == ref.header.number:\n                yield segment\n\n    def responses(self, ref, code=None):\n        for segment in self.response_segments(ref, HIRMS2):\n            for response in segment.responses:\n                if code is None or response.code == code:\n                    yield response\nfints/formals.py\nclass UserDefinedSignature(DataElementGroup):\n    pin = PasswordField(max_length=99)\n    tan = DataElementField(type='an', max_length=99, required=False)\nfints/formals.py\nclass SecurityMethod(RepresentableEnum):\n    DDV = 'DDV'\n    RAH = 'RAH'\n    RDH = 'RDH'\n    PIN = 'PIN'\nfints/formals.py\nclass SecurityRole(RepresentableEnum):\n    \"\"\"Rolle des Sicherheitslieferanten, kodiert, version 2\n\n    Kodierte Information über das Verhältnis desjenigen, der bezüglich der zu si-chernden Nachricht die Sicherheit gewährleistet.\n    Die Wahl ist von der bankfachlichen Auslegung der Signatur, respektive vom vertraglichen Zustand zwischen Kunde und Kreditinstitut abhängig.\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    ISS = '1'  #: Erfasser, Erstsignatur\n    CON = '3'  #: Unterstützer, Zweitsignatur\n    WIT = '4'  #: Zeuge/Übermittler, nicht Erfasser\nfints/formals.py\nclass KeyType(RepresentableEnum):\n    \"\"\"Schlüsselart\"\"\"\n    D = 'D'  #: Schlüssel zur Erzeugung digitaler Signaturen\n    S = 'S'  #: Signierschlüssel\n    V = 'V'  #: Chiffrierschlüssel\nfints/formals.py\nclass EncryptionAlgorithm(DataElementGroup):\n    usage_encryption = CodeField(UsageEncryption, max_length=3)\n    operation_mode = CodeField(OperationMode, max_length=3)\n    encryption_algorithm = CodeField(EncryptionAlgorithmCoded, max_length=3)\n    algorithm_parameter_value = DataElementField(type='bin', max_length=512)\n    algorithm_parameter_name = CodeField(AlgorithmParameterName, max_length=3)\n    algorithm_parameter_iv_name = CodeField(AlgorithmParameterIVName, max_length=3)\n    algorithm_parameter_iv_value = DataElementField(type='bin', max_length=512, required=False)\nfints/formals.py\nclass KeyName(DataElementGroup):\n    bank_identifier = DataElementGroupField(type=BankIdentifier)\n    user_id = DataElementField(type='id')\n    key_type = CodeField(KeyType, length=1, _d=\"Schlüsselart\")\n    key_number = DataElementField(type='num', max_length=3)\n    key_version = DataElementField(type='num', max_length=3)\nfints/formals.py\nclass IdentifiedRole(RepresentableEnum):\n    MS = '1' #: Message Sender\n    MR = '2' #: Message Receiver\nfints/segments/message.py\nclass HNVSK3(FinTS3Segment):\n    \"\"\"Verschlüsselungskopf, version 3\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    security_profile = DataElementGroupField(type=SecurityProfile, _d=\"Sicherheitsprofil\")\n    security_function = DataElementField(type='code', max_length=3, _d=\"Sicherheitsfunktion, kodiert\")\n    security_role = CodeField(SecurityRole, max_length=3, _d=\"Rolle des Sicherheitslieferanten, kodiert\")\n    security_identification_details = DataElementGroupField(type=SecurityIdentificationDetails, _d=\"Sicherheitsidentifikation, Details\")\n    security_datetime = DataElementGroupField(type=SecurityDateTime, _d=\"Sicherheitsdatum und -uhrzeit\")\n    encryption_algorithm = DataElementGroupField(type=EncryptionAlgorithm, _d=\"Verschlüsselungsalgorithmus\")\n    key_name = DataElementGroupField(type=KeyName, _d=\"Schlüsselname\")\n    compression_function = CodeField(CompressionFunction, max_length=3, _d=\"Komprimierungsfunktion\")\n    certificate = DataElementGroupField(type=Certificate, required=False, _d=\"Zertifikat\")\nfints/formals.py\nclass SecurityProfile(DataElementGroup):\n    \"\"\"Sicherheitsprofil\"\"\"\n    security_method = CodeField(enum=SecurityMethod, length=3, _d=\"Sicherheitsverfahren\")\n    security_method_version = DataElementField(type='num', _d=\"Version des Sicherheitsverfahrens\")\nfints/segments/message.py\nclass HNSHK4(FinTS3Segment):\n    \"\"\"Signaturkopf, version 4\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    security_profile = DataElementGroupField(type=SecurityProfile, _d=\"Sicherheitsprofil\")\n    security_function = DataElementField(type='code', max_length=3, _d=\"Sicherheitsfunktion, kodiert\")\n    security_reference = DataElementField(type='an', max_length=14, _d=\"Sicherheitskontrollreferenz\")\n    security_application_area = CodeField(SecurityApplicationArea, max_length=3, _d=\"Bereich der Sicherheitsapplikation, kodiert\")\n    security_role = CodeField(SecurityRole, max_length=3, _d=\"Rolle des Sicherheitslieferanten, kodiert\")\n    security_identification_details = DataElementGroupField(type=SecurityIdentificationDetails, _d=\"Sicherheitsidentifikation, Details\")\n    security_reference_number = DataElementField(type='num', max_length=16, _d=\"Sicherheitsreferenznummer\")\n    security_datetime = DataElementGroupField(type=SecurityDateTime, _d=\"Sicherheitsdatum und -uhrzeit\")\n    hash_algorithm = DataElementGroupField(type=HashAlgorithm, _d=\"Hashalgorithmus\")\n    signature_algorithm = DataElementGroupField(type=SignatureAlgorithm, _d=\"Signaturalgorithmus\")\n    key_name = DataElementGroupField(type=KeyName, _d=\"Schlüsselname\")\n    certificate = DataElementGroupField(type=Certificate, required=False, _d=\"Zertifikat\")\nfints/formals.py\nclass SignatureAlgorithm(DataElementGroup):\n    usage_signature = DataElementField(type='code', max_length=3)\n    signature_algorithm = DataElementField(type='code', max_length=3)\n    operation_mode = DataElementField(type='code', max_length=3)\nfints/formals.py\nclass CompressionFunction(RepresentableEnum):\n    \"\"\"Komprimierungsfunktion, version 2\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    NULL = '0'  #: Keine Kompression\n    LZW = '1'  #: Lempel, Ziv, Welch\n    COM = '2'  #: Optimized LZW\n    LZSS = '3'  #: Lempel, Ziv\n    LZHuf = '4'  #: LZ + Huffman Coding\n    ZIP = '5'  #: PKZIP\n    GZIP = '6'  #: deflate (http://www.gzip.org/zlib)\n    BZIP2 = '7'  #: bzip2 (http://sourceware.cygnus.com/bzip2/)\n    ZZZ = '999'  #: Gegenseitig vereinbart\nfints/exceptions.py\nclass FinTSError(Exception):\n    pass\nfints/formals.py\nclass SecurityDateTime(DataElementGroup):\n    date_time_type = CodeField(DateTimeType, max_length=3)\n    date = DataElementField(type='dat', required=False)\n    time = DataElementField(type='tim', required=False)\nfints/formals.py\nclass SecurityIdentificationDetails(DataElementGroup):\n    identified_role = CodeField(IdentifiedRole, max_length=3)\n    cid = DataElementField(type='bin', max_length=256)\n    identifier = DataElementField(type='id')\nfints/types.py\nclass SegmentSequence:\n    \"\"\"A sequence of FinTS3Segment objects\"\"\"\n\n    def __init__(self, segments=None):\n        if isinstance(segments, bytes):\n            from .parser import FinTS3Parser\n            parser = FinTS3Parser()\n            data = parser.explode_segments(segments)\n            segments = [parser.parse_segment(segment) for segment in data]\n        self.segments = list(segments) if segments else []\n\n    def render_bytes(self) -> bytes:\n        from .parser import FinTS3Serializer\n        return FinTS3Serializer().serialize_message(self)\n\n    def __repr__(self):\n        return \"{}.{}({!r})\".format(self.__class__.__module__, self.__class__.__name__, self.segments)\n\n    def print_nested(self, stream=None, level=0, indent=\"    \", prefix=\"\", first_level_indent=True, trailer=\"\", print_doc=True, first_line_suffix=\"\"):\n        import sys\n        stream = stream or sys.stdout\n        stream.write(\n            ((prefix + level * indent) if first_level_indent else \"\")\n            + \"{}.{}([\".format(self.__class__.__module__, self.__class__.__name__)\n            + first_line_suffix\n            + \"\\n\"\n        )\n        for segment in self.segments:\n            docstring = print_doc and segment.__doc__\n            if docstring:\n                docstring = docstring.splitlines()[0].strip()\n            if docstring:\n                docstring = \" # {}\".format(docstring)\n            else:\n                docstring = \"\"\n            segment.print_nested(stream=stream, level=level + 1, indent=indent, prefix=prefix, first_level_indent=True, trailer=\",\", print_doc=print_doc,\n                                 first_line_suffix=docstring)\n        stream.write((prefix + level * indent) + \"]){}\\n\".format(trailer))\n\n    def find_segments(self, query=None, version=None, callback=None, recurse=True, throw=False):\n        \"\"\"Yields an iterable of all matching segments.\n\n        :param query: Either a str or class specifying a segment type (such as 'HNHBK', or :class:`~fints.segments.message.HNHBK3`), or a list or tuple of strings or classes.\n                     If a list/tuple is specified, segments returning any matching type will be returned.\n        :param version: Either an int specifying a segment version, or a list or tuple of ints.\n                        If a list/tuple is specified, segments returning any matching version will be returned.\n        :param callback: A callable that will be given the segment as its sole argument and must return a boolean indicating whether to return this segment.\n        :param recurse: If True (the default), recurse into SegmentSequenceField values, otherwise only look at segments in this SegmentSequence.\n        :param throw: If True, a FinTSNoResponseError is thrown if no result is found. Defaults to False.\n\n        The match results of all given parameters will be AND-combined.\n        \"\"\"\n        found_something = False\n\n        if query is None:\n            query = []\n        elif isinstance(query, str) or not isinstance(query, (list, tuple, Iterable)):\n            query = [query]\n\n        if version is None:\n            version = []\n        elif not isinstance(version, (list, tuple, Iterable)):\n            version = [version]\n\n        if callback is None:\n            callback = lambda s: True\n\n        for s in self.segments:\n            if ((not query) or any((isinstance(s, t) if isinstance(t, type) else s.header.type == t) for t in query)) and \\\n                    ((not version) or any(s.header.version == v for v in version)) and \\\n                    callback(s):\n                yield s\n                found_something = True\n\n            if recurse:\n                for name, field in s._fields.items():\n                    val = getattr(s, name)\n                    if val and hasattr(val, 'find_segments'):\n                        for v in val.find_segments(query=query, version=version, callback=callback, recurse=recurse):\n                            yield v\n                            found_something = True\n\n        if throw and not found_something:\n            raise FinTSNoResponseError(\n                'The bank\\'s response did not contain a response to your request, please inspect debug log.'\n            )\n\n    def find_segment_first(self, *args, **kwargs):\n        \"\"\"Finds the first matching segment.\n\n        Same parameters as find_segments(), but only returns the first match, or None if no match is found.\"\"\"\n\n        for m in self.find_segments(*args, **kwargs):\n            return m\n\n        return None\n\n    def find_segment_highest_version(self, query=None, version=None, callback=None, recurse=True, default=None):\n        \"\"\"Finds the highest matching segment.\n\n        Same parameters as find_segments(), but returns the match with the highest version, or default if no match is found.\"\"\"\n        # FIXME Test\n\n        retval = None\n\n        for s in self.find_segments(query=query, version=version, callback=callback, recurse=recurse):\n            if not retval or s.header.version > retval.header.version:\n                retval = s\n\n        if retval is None:\n            return default\n\n        return retval\nfints/segments/message.py\nclass HNSHA2(FinTS3Segment):\n    \"\"\"Signaturabschluss, version 2\n\n    Source: FinTS Financial Transaction Services, Sicherheitsverfahren HBCI\"\"\"\n    security_reference = DataElementField(type='an', max_length=14, _d=\"Sicherheitskontrollreferenz\")\n    validation_result = DataElementField(type='bin', max_length=512, required=False, _d=\"Validierungsresultat\")\n    user_defined_signature = DataElementGroupField(type=UserDefinedSignature, required=False, _d=\"Benutzerdefinierte Signatur\")\nfints/formals.py\nclass DateTimeType(RepresentableEnum):\n    STS = '1'  #: Sicherheitszeitstempel\n    CRT = '6'  #: Certificate Revocation Time\n", "answers": ["                security_role=SecurityRole.ISS,"], "length": 1417, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "35b8b3e1d188f90143d0e0b703b62d29e51691ca88cb2595"}
{"input": "from boole.core.info import *\nfrom boole.core.context import *\nfrom boole.core.expr import Const, Sub, Pair, Fst, Snd, Box, root_app, \\\n  root_clause, root_pi, subst_expr\nfrom boole.elaboration.color import *\nfrom boole.elaboration.elab import app_expr, mvar_infer, sub_mvar\nfrom boole.semantics.value import Value\nfrom config import current_ctxt, push_ctxt\nimport boole.core.expr as e\nimport boole.core.typing as typing\nimport elab as elab_tools\nimport boole.core.tactics as tac\nimport unif as u\nimport boole.semantics.value as v\nimport config as conf\nimport boole.user_conf as user_conf\nst_term['__str__'] = tm_str\nst_term['__call__'] = tm_call\nst_term['__getitem__'] = get_pair\nst_term['__eq__'] = (lambda expr1, expr2: eq(expr1, expr2))\nst_term['__ne__'] = (lambda expr1, expr2: Not(eq(expr1, expr2)))\nst_term['__add__'] = (lambda expr1, expr2: add(expr1, expr2))\nst_term['__radd__'] = (lambda expr2, expr1: add(expr1, expr2))\nst_term['__mul__'] = (lambda expr1, expr2: mul(expr1, expr2))\nst_term['__rmul__'] = (lambda expr2, expr1: mul(expr1, expr2))\nst_term['__sub__'] = (lambda expr1, expr2: minus(expr1, expr2))\nst_term['__rsub__'] = (lambda expr2, expr1: minus(expr1, expr2))\nst_term['__div__'] = (lambda expr1, expr2: div(expr1, expr2))\nst_term['__rdiv__'] = (lambda expr2, expr1: div(expr1, expr2))\nst_term['__mod__'] = (lambda expr1, expr2: mod(expr1, expr2))\nst_term['__rmod__'] = (lambda expr2, expr1: mod(expr1, expr2))\nst_term['__pow__'] = (lambda expr1, expr2: power(expr1, expr2))\nst_term['__rpow__'] = (lambda expr2, expr1: power(expr1, expr2))\nst_term['__rshift__'] = type_arrow\nst_term['__le__'] = (lambda expr1, expr2: le(expr1, expr2))\nst_term['__ge__'] = (lambda expr1, expr2: le(expr2, expr1))\nst_term['__lt__'] = (lambda expr1, expr2: lt(expr1, expr2))\nst_term['__gt__'] = (lambda expr1, expr2: lt(expr2, expr1))\nst_term['__abs__'] = (lambda expr: absf(expr))\nst_term['__neg__'] = (lambda expr: uminus(expr))\n\n# operations for types\nst_typ['__call__'] = typ_call\nst_typ['__mul__'] = typ_mul\nst_typ['__rshift__'] = type_arrow\nst_typ['__str__'] = typ_str\nst_typ['__le__'] = typ_le\n\n\n###############################################################################\n#\n# More term and type constructors\n#\n###############################################################################\n\ndef fold_over(base_op, var, tm, **kwargs):\n    \"\"\"\n    Apply a base operation to a list of\n    objects\n    \"\"\"\n    if isinstance(var, list):\n        var.reverse()\n        res = tm\n        for v in var:\n            res = base_op(v, res, **kwargs)\n        var.reverse()\n        return res\n    else:\n        return base_op(var, tm, **kwargs)\n\n\n#TODO: this should be st_typ, but arrows are not printed\n#correctly at the type level.\n@with_info(st_term)\ndef pi_base(var, codom, **kwargs):\n    return elab_tools.pi(var, codom, **kwargs)\n\n\ndef pi(var, codom, **kwargs):\n    return fold_over(pi_base, var, codom, **kwargs)\n\n\n@with_info(st_term)\ndef abst_base(var, body):\n    return elab_tools.abst(var, body)\n\n\ndef abst(var, body):\n    return fold_over(abst_base, var, body)\n\n\n@with_info(st_term)\ndef forall_base(var, prop):\n    return elab_tools.forall(var, prop)\n\n\ndef forall(var, prop):\n    return fold_over(forall_base, var, prop)\n\n\n@with_info(st_term)\ndef exists_base(var, prop):\n    return elab_tools.exists(var, prop)\n\n\ndef exists(var, prop):\n    return fold_over(exists_base, var, prop)\n\n\n@with_info(st_term)\ndef sig_base(var, codom):\n    return elab_tools.sig(var, codom)\n\n\ndef sig(var, codom):\n    return fold_over(sig_base, var, codom)\n\n\n@with_info(st_term)\ndef nullctxt():\n    return e.nullctxt()\n\n\n@with_info(st_term)\ndef triv():\n    return elab_tools.trivial()\n\n\n@with_info(st_term)\ndef cast(expr, ty):\n    \"\"\"cast an expression to ty\n    \n    Arguments:\n    - `expr`: an expression\n    - `ty`: a type equal to the type of expr\n    \"\"\"\n", "context": "boole/elaboration/elab.py\ndef app_expr(f, f_ty, cast, args):\n    \"\"\"Applies a function to a list of\n    arguments, some of which are implicit.\n    \n    Arguments:\n    - `f`: an expression denoting the function\n    - `f_ty`: the function type\n    - `cast`: list of evidence terms for the type conversions\n    of each argument\n    - `args`: a list of arguments\n    \"\"\"\n    tm = f\n    rem_args = args\n    rem_cast = cast\n    rem_ty = f_ty\n\n    #TODO: This is a bit of a hack. We need \"maximally inserted arguments\"\n    #as in Coq to do this cleanly\n    if len(args) == 0:\n        while rem_ty.is_pi()\\\n              and rem_ty.info.implicit:\n            mvar = mk_meta(rem_ty.binder.var, rem_ty.dom)\n            #At this point we give the trivial evidence.\n            #after the term is created, we go through the whole\n            #term to collect local information (variables) and to add them\n            #the evidence term\n            mcast = trivial()\n            tm = t.App(mcast, tm, mvar)\n            rem_ty = e.subst_expr([mvar], rem_ty.body)\n    else:\n        while len(rem_args) != 0:\n            if rem_ty.is_pi()\\\n               and rem_ty.info.implicit:\n                mvar = mk_meta(rem_ty.binder.var, rem_ty.dom)\n                mcast = trivial()\n                tm = t.App(mcast, tm, mvar)\n                rem_ty = e.subst_expr([mvar], rem_ty.body)\n            elif rem_ty.is_pi():\n                tm = t.App(rem_cast[0], tm, rem_args[0])\n                rem_ty = e.subst_expr([rem_args[0]], rem_ty.body)\n                rem_cast = rem_cast[1:]\n                rem_args = rem_args[1:]\n            else:\n                #In this case, something is wrong with the type\n                #of f, and we simply blindly apply all the remaining\n                #arguments.\n                tm = t.App(rem_cast[0], tm, rem_args[0])\n                rem_cast = rem_cast[1:]\n                rem_args = rem_args[1:]\n    return tm\nboole/elaboration/elab.py\ndef sub_mvar(expr, undef=None):\n    \"\"\"Replace all meta-variables by their\n    value in a term.\n    \n    Arguments:\n    - `undef`: if this flag is set to True,\n    fail on unresolved meta-vars.\n    \"\"\"\n    return SubMvar(undef=undef).visit(expr)\nboole/semantics/value.py\nclass Value(object):\n    \"\"\"The class of semantic values\n    \n    Arguments:\n    - `pyval`: a python value\n    - `desc`: a boole expression that, together with the pyval,\n    gives a description of the object in question\n    - `is_num`: a boolean, indicates that pyval supports numeric operations\n    \"\"\"\n\n    def __init__(self, pyval=None, desc=None, is_num=False):\n        \"\"\"Creats the object\n        \"\"\"\n        self.pyval = pyval\n        self.desc = desc\n        self._is_num = is_num\n        \n    # TODO: what should the string method do? For now, just take the Python\n    # object\n    def __str__(self):\n        return str(self.pyval)\n    \n    def is_num(self):\n        return self._is_num\nboole/core/expr.py\nclass Const(Expr):\n    \"\"\"A constant declaration. Variables\n    and constants are identified.\n    \"\"\"\n\n    def __init__(self, name, type, value=None, **kwargs):\n        \"\"\"\n        \n        Arguments:\n        - `name`: A name representing the constant\n        - `type`: an expression representing its type\n        - `value`: possibly a semantic value, making this an interpreted\n        constant\n        \"\"\"\n        Expr.__init__(self)\n        self.name = name\n        self.type = type\n        self.value = value\n        for k in kwargs:\n            self.info[k] = kwargs[k]\n        self._hash = hash(('Const', self.name, self.type))\n\n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_const(self, *args, **kwargs)\n\n    def to_string(self):\n        return self.name\n\n    def is_const(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality. Simply compares names.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_const():\n            return self.name == expr.name\n        else:\n            return False\nboole/core/expr.py\ndef root_pi(expr):\n    \"\"\"Returns the pair (r, [an,..,a0])\n    such that expr = Pi(a0, Pi(.. Pi(an, r)..)\n    \n    Arguments:\n    - `expr`: an expression\n    \"\"\"\n    root = expr\n    args = []\n    while root.is_pi():\n        args.append(root.dom)\n        _, root = open_bound_fresh(root)\n    return (root, args)\nboole/core/expr.py\nclass Box(Expr):\n    \"\"\"Boxed epressions: a boxed expression\n    carries a an expression, a type and a witness that the type of\n    the expression is a subtype of the given type.\n    \"\"\"\n    \n    def __init__(self, conv, expr, type):\n        \"\"\"\n        \n        Arguments:\n        - `conv`: A witness to the equality between the type\n        of expr and type\n        - `expr`: The expression denoted by the box\n        - `type`: The type assigned to expr\n        \"\"\"\n        Expr.__init__(self)\n        self.conv = conv\n        self.expr = expr\n        self.type = type\n        self._hash = hash((\"Box\", self.expr))\n\n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_box(self, *args, **kwargs)\n\n    def to_string(self):\n        return \"Box({0!s},{1!s},{2!s})\".format(self.conv, self.expr, self.type)\n\n    def is_box(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_box():\n            return self.expr.equals(expr.expr)\n        else:\n            return False\nboole/core/expr.py\nclass Fst(Expr):\n    \"\"\"First projection for Sigma types\n    \"\"\"\n    \n    def __init__(self, expr):\n        \"\"\"\n        \n        Arguments:\n        - `expr`: the expression to which is applied the projection.\n        \"\"\"\n        Expr.__init__(self)\n        self.expr = expr\n        self._hash = hash((\"Fst\", self.expr))\n    \n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_fst(self, *args, **kwargs)\n\n    def to_string(self):\n        \"\"\"\n        \n        Arguments:\n        - `self`:\n        \"\"\"\n        return \"Fst({0!s})\".format(self.expr)\n\n    def is_fst(self):\n        return True\n\n    def equals(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_fst():\n            return self.expr.equals(expr.expr)\n        else:\n            return False\nboole/core/expr.py\nclass Snd(Expr):\n    \"\"\"Second projection for Sigma types\n    \"\"\"\n    \n    def __init__(self, expr):\n        \"\"\"\n        \n        Arguments:\n        - `expr`: the expression to which is applied the projection.\n        \"\"\"\n        Expr.__init__(self)\n        self.expr = expr\n        self._hash = hash((\"Snd\", self.expr))\n    \n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_snd(self, *args, **kwargs)\n\n    def to_string(self):\n        \"\"\"\n        \n        Arguments:\n        - `self`:\n        \"\"\"\n        return \"Snd({0!s})\".format(self.expr)\n\n    def is_snd(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_snd():\n            return self.expr.equals(expr.expr)\n        else:\n            return False\nboole/core/expr.py\ndef root_clause(expr):\n    \"\"\"Returns r such that expr is of the form\n    forall(x1,...,forall(xn, p1 >= (p2 >= ... (pm >= r))))\n    replacing xi with fresh variables\n    \n    Arguments:\n    - `expr`: an expression\n    \"\"\"\n    root = expr\n    while root.is_forall():\n        _, root = open_bound_fresh(root)\n    while is_impl(root):\n        root = arg_i(root, 1)\n    return root\nboole/core/expr.py\ndef root_app(expr):\n    \"\"\"Returns the pair (r, args)\n    such that expr = r(*args)\n    \n    Arguments:\n    - `expr`: an expression\n    \"\"\"\n    root = expr\n    args = []\n    while root.is_app():\n        args.append(root.arg)\n        root = root.fun\n        #The arguments were collected in reverse order\n    args.reverse()\n    return (root, args)\nboole/core/expr.py\nclass Pair(Expr):\n    \"\"\"Elements of Sigma types. They need to carry around their type,\n    for type-checking to be decidable.\n    \"\"\"\n    \n    def __init__(self, fst, snd, type):\n        \"\"\"\n        \n        Arguments:\n        - `fst`: an expression denoting the first component\n        - `snd`: an expression denoting the second component\n        - `type`: an expression\n        \"\"\"\n        Expr.__init__(self)\n        self.fst = fst\n        self.snd = snd\n        self.type = type\n        self._hash = hash((\"Pair\", self.type, self.fst, self.snd))\n\n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_pair(self, *args, **kwargs)\n\n    def to_string(self):\n        return \"Pair({0!s},{1!s},{2!s})\".\\\n               format(self.fst, self.snd, self.type)\n        \n    def is_pair(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_pair():\n            return self.fst.equals(expr.fst) and \\\n                   self.snd.equals(expr.snd) and \\\n                   self.type.equals(expr.type)\n        else:\n            return False\nboole/core/expr.py\nclass Sub(Expr):\n    \"\"\"The subtype relation. Makes sense regardless\n    of the type of the expressions.\n    \"\"\"\n    \n    def __init__(self, lhs, rhs):\n        \"\"\"\n        \n        Arguments:\n        - `lhs`: an expression\n        - `rhs`: an expression\n        \"\"\"\n        Expr.__init__(self)\n        self.lhs = lhs\n        self.rhs = rhs\n        self._hash = hash((\"Sub\", self.lhs, self.rhs))\n\n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_sub(self, *args, **kwargs)\n\n    def to_string(self):\n        \"\"\"\n        \n        Arguments:\n        - `self`:\n        \"\"\"\n        return \"Sub({0!s}, {1!s})\".format(self.lhs, self.rhs)\n\n    def is_sub(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_sub():\n            return (self.lhs.equals(expr.lhs)) and (self.rhs.equals(expr.rhs))\n        else:\n            return False\nboole/elaboration/elab.py\ndef mvar_infer(expr, ctxt=None):\n    \"\"\"Infer the type of an expression and return the pair\n    (type, proof obligations) or raise an exception of type\n    ExprTypeError.\n    \n    Arguments:\n    - `expr`: an expression\n    \"\"\"\n    if ctxt == None:\n        ty_ctxt_name = meta_var_gen.get_name('_unif_ctxt')\n        ty_ctxt = context.Context(ty_ctxt_name)\n    else:\n        ty_ctxt = ctxt\n    prf_obl_name = meta_var_gen.get_name('_unif_goals')\n    prf_obl = goals.empty_goals(prf_obl_name, ty_ctxt)\n    ty = t.ExprInfer().visit(expr, prf_obl)\n    return (ty, prf_obl)\nboole/core/expr.py\ndef subst_expr(exprs, expr, is_open=None):\n    \"\"\"Instantiate DB indices in expr according\n    to expr_list\n    \n    Arguments:\n    - `expr_list`: a list of expressions\n    - `expr`: an expression\n    \"\"\"\n    if is_open != None:\n        subster = SubstExpr(exprs, is_open=is_open)\n    else:\n        subster = SubstExpr(exprs)\n    return subster.visit(expr, 0)\n", "answers": ["    return Box(triv(), expr, ty)"], "length": 1771, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "e52768fb279b3ee3b37bd0b166cbb82d47024e30438a8563"}
{"input": "package de.unima.ar.collector.database;\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport de.unima.ar.collector.sensors.collectors.AccelerometerCollector;\nimport de.unima.ar.collector.sensors.collectors.GravityCollector;\nimport de.unima.ar.collector.sensors.collectors.GyroscopeCollector;\nimport de.unima.ar.collector.sensors.collectors.LinearAccelerationCollector;\nimport de.unima.ar.collector.sensors.collectors.MagnetometerCollector;\nimport de.unima.ar.collector.sensors.collectors.OrientationCollector;\nimport de.unima.ar.collector.sensors.collectors.PressureCollector;\nimport de.unima.ar.collector.sensors.collectors.RotationVectorCollector;\nimport de.unima.ar.collector.sensors.collectors.StepCounterCollector;\nimport de.unima.ar.collector.sensors.collectors.StepDetectorCollector;\nimport de.unima.ar.collector.shared.database.SQLTableName;\n\n\n\npublic class DatabaseHelper extends SQLiteOpenHelper\n{\n    private Context context;\n\n    private static final String sqlTableActivityData       = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.ACTIVITYDATA + \" (id INTEGER PRIMARY KEY AUTOINCREMENT, activityid INT NOL NULL, subactivityid INT, starttime INT, endtime INT)\";\n    private static final String sqlTablePostureData        = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.POSTUREDATA + \" (id INTEGER PRIMARY KEY AUTOINCREMENT, pid INT NOL NULL, starttime INT, endtime INT)\";\n    private static final String sqlTablePositionData       = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.POSITIONDATA + \" (id INTEGER PRIMARY KEY AUTOINCREMENT, pid INT NOL NULL, starttime INT, endtime INT)\";\n    private static final String sqlTableDevicePositionData = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.DEVICEPOSITIONDATA + \" (id INTEGER PRIMARY KEY AUTOINCREMENT, pid INT NOL NULL, starttime INT, endtime INT)\";\n    private static final String sqlTableTansferLog         = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.TRANSFERLOG + \"(id INTEGER PRIMARY KEY AUTOINCREMENT, transfer INT NOT NULL, entries int NOT NULL)\";\n\n    private static final String DATABASE_NAME    = \"sensordata.db\";\n    private static final int    DATABASE_VERSION = 3;\n\n\n    public DatabaseHelper(Context cxt)\n    {\n        super(cxt, DATABASE_NAME, null, DATABASE_VERSION);\n\n        this.context = cxt;\n    }\n\n\n    @Override\n    public void onCreate(SQLiteDatabase db)\n    {\n        // nothing\n    }\n\n\n    @Override\n    public void onUpgrade(SQLiteDatabase database, int oldVersion, int newVersion)\n    {\n        // nothing\n    }\n\n\n    public static void createDeviceDependentTables(String deviceID)\n    {\n        AccelerometerCollector.createDBStorage(deviceID);\n        GravityCollector.createDBStorage(deviceID);\n        GyroscopeCollector.createDBStorage(deviceID);\n        LinearAccelerationCollector.createDBStorage(deviceID);\n        MagnetometerCollector.createDBStorage(deviceID);\n        OrientationCollector.createDBStorage(deviceID);\n        PressureCollector.createDBStorage(deviceID);\n        RotationVectorCollector.createDBStorage(deviceID);\n        StepDetectorCollector.createDBStorage(deviceID);", "context": "wear/src/main/java/de/unima/ar/collector/sensors/collectors/OrientationCollector.java\npublic class OrientationCollector extends Collector\n{\n    private static final int      type       = 3;\n    private static final String[] valueNames = new String[]{ \"attr_azimuth\", \"attr_pitch\", \"attr_roll\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + values[0] + \";\" + valueNames[1] + \";\" + values[1] + \";\" + valueNames[2] + \";\" + values[2] + \";\" + valueNames[3] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], values[0]);\n            newValues.put(valueNames[1], values[1]);\n            newValues.put(valueNames[2], values[2]);\n            newValues.put(valueNames[3], time);\n\n            OrientationCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.ORIENTATION + \" (id INTEGER PRIMARY KEY, \" + valueNames[3] + \" INT, \" + valueNames[0] + \" REAL, \" + valueNames[1] + \" REAL, \" + valueNames[2] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.ORIENTATION;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        DBUtils.flushCache(SQLTableName.ORIENTATION, cache);\n    }\n}\nwear/src/main/java/de/unima/ar/collector/sensors/collectors/PressureCollector.java\npublic class PressureCollector extends Collector\n{\n    private static final int      type       = 6;\n    private static final String[] valueNames = new String[]{ \"attr_millibar\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + values[0] + \";\" + valueNames[1] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], values[0]);\n            newValues.put(valueNames[1], time);\n\n            PressureCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.PRESSURE + \" (id INTEGER PRIMARY KEY, \" + valueNames[1] + \" INT, \" + valueNames[0] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.PRESSURE;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        DBUtils.flushCache(SQLTableName.PRESSURE, cache);\n    }\n}\nwear/src/main/java/de/unima/ar/collector/sensors/collectors/StepCounterCollector.java\npublic class StepCounterCollector extends Collector\n{\n    private static final int      type       = 19;\n    private static final String[] valueNames = new String[]{ \"attr_step\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + values[0] + \";\" + valueNames[1] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], values[0]);\n            newValues.put(valueNames[1], time);\n\n            StepCounterCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.STEPCOUNTER + \" (id INTEGER PRIMARY KEY, \" + valueNames[1] + \" INT, \" + valueNames[0] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.STEPCOUNTER;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        DBUtils.flushCache(SQLTableName.STEPCOUNTER, cache);\n    }\n}\nwear/src/main/java/de/unima/ar/collector/sensors/collectors/GyroscopeCollector.java\npublic class GyroscopeCollector extends Collector\n{\n    private static final int      type       = 4;\n    private static final String[] valueNames = new String[]{ \"attr_x\", \"attr_y\", \"attr_z\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + values[0] + \";\" + valueNames[1] + \";\" + values[1] + \";\" + valueNames[2] + \";\" + values[2] + \";\" + valueNames[3] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], values[0]);\n            newValues.put(valueNames[1], values[1]);\n            newValues.put(valueNames[2], values[2]);\n            newValues.put(valueNames[3], time);\n\n            GyroscopeCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.GYROSCOPE + \" (id INTEGER PRIMARY KEY, \" + valueNames[3] + \" INT, \" + valueNames[0] + \" REAL, \" + valueNames[1] + \" REAL, \" + valueNames[2] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.GYROSCOPE;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            Log.d(\"TIMOSENSOR\", \"INSERT GYRO INTO DB\");\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        if(cache.keySet().size() != 0) {\n            Log.d(\"TIMOSENSOR\", \"FLUSH GYRO INTO DB\" + cache.values().iterator().next().size());\n        } else {\n            Log.d(\"TIMOSENSOR\", \"FLUSH GYRO INTO DB - CACHE EMPTY\");\n        }\n        DBUtils.flushCache(SQLTableName.GYROSCOPE, cache);\n    }\n}\nwear/src/main/java/de/unima/ar/collector/sensors/collectors/LinearAccelerationCollector.java\npublic class LinearAccelerationCollector extends Collector\n{\n    private static final int      type       = 10;\n    private static final String[] valueNames = new String[]{ \"attr_x\", \"attr_y\", \"attr_z\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + values[0] + \";\" + valueNames[1] + \";\" + values[1] + \";\" + valueNames[2] + \";\" + values[2] + \";\" + valueNames[3] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], values[0]);\n            newValues.put(valueNames[1], values[1]);\n            newValues.put(valueNames[2], values[2]);\n            newValues.put(valueNames[3], time);\n\n            LinearAccelerationCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.LINEAR + \" (id INTEGER PRIMARY KEY, \" + valueNames[3] + \" INT, \" + valueNames[0] + \" REAL, \" + valueNames[1] + \" REAL, \" + valueNames[2] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.LINEAR;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        DBUtils.flushCache(SQLTableName.LINEAR, cache);\n    }\n}\nwear/src/main/java/de/unima/ar/collector/sensors/collectors/GravityCollector.java\npublic class GravityCollector extends Collector\n{\n    private static final int      type       = 9;\n    private static final String[] valueNames = new String[]{ \"attr_x\", \"attr_y\", \"attr_z\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + values[0] + \";\" + valueNames[1] + \";\" + values[1] + \";\" + valueNames[2] + \";\" + values[2] + \";\" + valueNames[3] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], values[0]);\n            newValues.put(valueNames[1], values[1]);\n            newValues.put(valueNames[2], values[2]);\n            newValues.put(valueNames[3], time);\n\n            GravityCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.GRAVITY + \" (id INTEGER PRIMARY KEY, \" + valueNames[3] + \" INT, \" + valueNames[0] + \" REAL, \" + valueNames[1] + \" REAL, \" + valueNames[2] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.GRAVITY;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        DBUtils.flushCache(SQLTableName.GRAVITY, cache);\n    }\n}\nwear/src/main/java/de/unima/ar/collector/sensors/collectors/StepDetectorCollector.java\npublic class StepDetectorCollector extends Collector\n{\n    private static final int      type       = 18;\n    private static final String[] valueNames = new String[]{ \"attr_step\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + values[0] + \";\" + valueNames[1] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], values[0]);\n            newValues.put(valueNames[1], time);\n\n            StepDetectorCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.STEP + \" (id INTEGER PRIMARY KEY, \" + valueNames[1] + \" INT, \" + valueNames[0] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.STEP;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        DBUtils.flushCache(SQLTableName.STEP, cache);\n    }\n}\nwear/src/main/java/de/unima/ar/collector/sensors/collectors/RotationVectorCollector.java\npublic class RotationVectorCollector extends Collector\n{\n    private static final int      type       = 11;\n    private static final String[] valueNames = new String[]{ \"attr_x\", \"attr_y\", \"attr_z\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + values[0] + \";\" + valueNames[1] + \";\" + values[1] + \";\" + valueNames[2] + \";\" + values[2] + \";\" + valueNames[3] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], values[0]);\n            newValues.put(valueNames[1], values[1]);\n            newValues.put(valueNames[2], values[2]);\n            newValues.put(valueNames[3], time);\n\n            RotationVectorCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.ROTATION + \" (id INTEGER PRIMARY KEY, \" + valueNames[3] + \" INT, \" + valueNames[0] + \" REAL, \" + valueNames[1] + \" REAL, \" + valueNames[2] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.ROTATION;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        DBUtils.flushCache(SQLTableName.ROTATION, cache);\n    }\n}\nwear/src/main/java/de/unima/ar/collector/sensors/collectors/MagnetometerCollector.java\npublic class MagnetometerCollector extends Collector\n{\n    private static final int      type       = 2;\n    private static final String[] valueNames = new String[]{ \"attr_x\", \"attr_y\", \"attr_z\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + values[0] + \";\" + valueNames[1] + \";\" + values[1] + \";\" + valueNames[2] + \";\" + values[2] + \";\" + valueNames[3] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], values[0]);\n            newValues.put(valueNames[1], values[1]);\n            newValues.put(valueNames[2], values[2]);\n            newValues.put(valueNames[3], time);\n\n            MagnetometerCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.MAGNETIC + \" (id INTEGER PRIMARY KEY, \" + valueNames[3] + \" INT, \" + valueNames[0] + \" REAL, \" + valueNames[1] + \" REAL, \" + valueNames[2] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.MAGNETIC;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        DBUtils.flushCache(SQLTableName.MAGNETIC, cache);\n    }\n}\nwear/src/main/java/de/unima/ar/collector/sensors/collectors/AccelerometerCollector.java\npublic class AccelerometerCollector extends Collector\n{\n    private static final int      type       = 1;\n    private static final String[] valueNames = new String[]{ \"attr_x\", \"attr_y\", \"attr_z\", \"attr_time\" };\n\n    private boolean isRegistered = false;\n    private int     sensorRate   = 0;\n    private float[] gravity      = new float[]{ 0, 0, 0 };\n\n    private static Map<String, List<String[]>> cache = new HashMap<>();\n\n    private long startTimer = -1;\n    private long counter    = -1;\n\n\n    @Override\n    public void onSensorChanged(SensorEvent event)\n    {\n        float[] values = event.values.clone();\n        long time = System.currentTimeMillis();\n\n        if(!(1 + (int) ((time - startTimer) / (this.sensorRate / 1000)) > counter)) {\n            return;\n        }\n        counter++;\n\n        float x = values[0];\n        float y = values[1];\n        float z = values[2];\n\n        if(Settings.ACCLOWPASS) { // low pass filter\n            final float alpha = (float) 0.8;\n            gravity[0] = alpha * gravity[0] + (1 - alpha) * values[0];\n            gravity[1] = alpha * gravity[1] + (1 - alpha) * values[1];\n            gravity[2] = alpha * gravity[2] + (1 - alpha) * values[2];\n\n            x = values[0] - gravity[0];\n            y = values[1] - gravity[1];\n            z = values[2] - gravity[2];\n        }\n\n        String deviceID = DeviceID.get(SensorService.getInstance());\n\n        if(Settings.WEARTRANSFERDIRECT) {\n            String record = valueNames[0] + \";\" + x + \";\" + valueNames[1] + \";\" + y + \";\" + valueNames[2] + \";\" + z + \";\" + valueNames[3] + \";\" + time;\n            BroadcastService.getInstance().sendMessage(\"/sensor/data/\" + deviceID + \"/\" + type, record);\n        } else {\n            ContentValues newValues = new ContentValues();\n            newValues.put(valueNames[0], x);\n            newValues.put(valueNames[1], y);\n            newValues.put(valueNames[2], z);\n            newValues.put(valueNames[3], time);\n\n            AccelerometerCollector.writeDBStorage(deviceID, newValues);\n        }\n    }\n\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy)\n    {\n        // TODO\n    }\n\n\n    @Override\n    public int getType()\n    {\n        return type;\n    }\n\n\n    @Override\n    public void setSensorRate(int rate)\n    {\n        this.sensorRate = rate;\n    }\n\n\n    @Override\n    public int getSensorRate()\n    {\n        return sensorRate;\n    }\n\n\n    @Override\n    public void setRegisteredState(boolean b)\n    {\n        this.isRegistered = b;\n\n        if(this.isRegistered) {\n            this.startTimer = System.currentTimeMillis();\n            this.counter = 0;\n        } else {\n            this.startTimer = -1;\n            this.counter = -1;\n        }\n    }\n\n\n    @Override\n    public boolean isRegistered()\n    {\n        return this.isRegistered;\n    }\n\n\n    public static void createDBStorage(String deviceID)\n    {\n        String sqlTable = \"CREATE TABLE IF NOT EXISTS \" + SQLTableName.PREFIX + deviceID + SQLTableName.ACCELEROMETER + \" (id INTEGER PRIMARY KEY, \" + valueNames[3] + \" INT, \" + valueNames[0] + \" REAL, \" + valueNames[1] + \" REAL, \" + valueNames[2] + \" REAL)\";\n        SQLDBController.getInstance().execSQL(sqlTable);\n    }\n\n\n    public static void writeDBStorage(String deviceID, ContentValues newValues)\n    {\n        String tableName = SQLTableName.PREFIX + deviceID + SQLTableName.ACCELEROMETER;\n\n        if(Settings.DATABASE_DIRECT_INSERT) {\n            SQLDBController.getInstance().insert(tableName, null, newValues);\n            return;\n        }\n\n        List<String[]> clone = DBUtils.manageCache(deviceID, cache, newValues, (Settings.DATABASE_CACHE_SIZE + type * 200));\n        if(clone != null) {\n            Log.d(\"TIMOSENSOR\", \"INSERT ACC INTO DB\");\n            SQLDBController.getInstance().bulkInsert(tableName, clone);\n        }\n    }\n\n\n    public static void flushDBCache()\n    {\n        if(cache.keySet().size() != 0) {\n            Log.d(\"TIMOSENSOR\", \"FLUSH ACC INTO DB - \" + cache.values().iterator().next().size());\n        } else {\n            Log.d(\"TIMOSENSOR\", \"FLUSH ACC INTO DB - CACHE EMPTY\");\n        }\n        DBUtils.flushCache(SQLTableName.ACCELEROMETER, cache);\n    }\n}\nshared/src/main/java/de/unima/ar/collector/shared/database/SQLTableName.java\npublic class SQLTableName\n{\n    public static final String PREFIX = \"SDC_\";\n\n    public static final String ACTIVITIES         = PREFIX + \"Activity\";\n    public static final String SUBACTIVITIES      = PREFIX + \"SubActivity\";\n    public static final String POSTURES           = PREFIX + \"Posture\";\n    public static final String POSITIONS          = PREFIX + \"Position\";\n    public static final String DEVICEPOSITION     = PREFIX + \"DevicePosition\";\n    public static final String OPTIONS            = PREFIX + \"Options\";\n    public static final String SENSOROPTIONS      = PREFIX + \"SensorOptions\";\n    public static final String DEVICES            = PREFIX + \"Devices\";\n    public static final String ACTIVITYCORRECTION = PREFIX + \"ActivityCorrection\";\n    public static final String TRANSFERLOG        = PREFIX + \"TransferLog\";\n\n    public static final String ACTIVITYDATA       = PREFIX + \"ActivityData\";\n    public static final String POSTUREDATA        = PREFIX + \"PostureData\";\n    public static final String POSITIONDATA       = PREFIX + \"PositionData\";\n    public static final String DEVICEPOSITIONDATA = PREFIX + \"DevicePositionData\";\n\n    public static final String ACCELEROMETER = \"SensorAccelerometerData\";\n    public static final String AMBIENT       = \"SensorAmbientTemperatureData\";\n    public static final String GPS           = \"SensorGPSData\";\n    public static final String GRAVITY       = \"SensorGravityData\";\n    public static final String GYROSCOPE     = \"SensorGyroscopeData\";\n    public static final String LIGHT         = \"SensorLightData\";\n    public static final String LINEAR        = \"SensorLinearAccelerationData\";\n    public static final String MAGNETIC      = \"SensorMagneticFieldData\";\n    public static final String MICROPHONE    = \"SensorMicrophoneData\";\n    public static final String ORIENTATION   = \"SensorOrientationData\";\n    public static final String PRESSURE      = \"SensorPressureData\";\n    public static final String PROXIMITY     = \"SensorProximityData\";\n    public static final String RELATIVE      = \"SensorRelativeHumidityData\";\n    public static final String ROTATION      = \"SensorRotationVectorData\";\n    public static final String STEP          = \"SensorStepDetectorData\";\n    public static final String STEPCOUNTER   = \"SensorStepCounterData\";\n    public static final String VIDEO         = \"SensorVideoData\";\n\n}\n", "answers": ["        StepCounterCollector.createDBStorage(deviceID);"], "length": 3430, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "017079ca32bc1ead1efd76a1264b6a028b9c258b09f6cfa9"}
{"input": "import binascii\nimport calendar\nimport six\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom .types import EmbeddedSignatureHeader\nfrom .types import Signature\nfrom ...constants import CompressionAlgorithm\nfrom ...constants import Features as _Features\nfrom ...constants import HashAlgorithm\nfrom ...constants import KeyFlags as _KeyFlags\nfrom ...constants import KeyServerPreferences as _KeyServerPreferences\nfrom ...constants import NotationDataFlags\nfrom ...constants import PubKeyAlgorithm\nfrom ...constants import RevocationKeyClass\nfrom ...constants import RevocationReason\nfrom ...constants import SymmetricKeyAlgorithm\nfrom ...decorators import sdproperty\nfrom ...types import Fingerprint\n        from ..packets import SignatureV4\n\"\"\" signature.py\n\nSignature SubPackets\n\"\"\"\n\n\n\n\n\n\n\n\n__all__ = ['URI',\n           'FlagList',\n           'ByteFlag',\n           'Boolean',\n           'CreationTime',\n           'SignatureExpirationTime',\n           'ExportableCertification',\n           'TrustSignature',\n           'RegularExpression',\n           'Revocable',\n           'KeyExpirationTime',\n           'PreferredSymmetricAlgorithms',\n           'RevocationKey',\n           'Issuer',\n           'NotationData',\n           'PreferredHashAlgorithms',\n           'PreferredCompressionAlgorithms',\n           'KeyServerPreferences',\n           'PreferredKeyServer',\n           'PrimaryUserID',\n           'Policy',\n           'KeyFlags',\n           'SignersUserID',\n           'ReasonForRevocation',\n           'Features',\n           'EmbeddedSignature']\n\n\nclass URI(Signature):\n", "context": "src/leap/mx/vendor/pgpy/constants.py\nclass PubKeyAlgorithm(IntEnum):\n    Invalid = 0x00\n    #: Signifies that a key is an RSA key.\n    RSAEncryptOrSign = 0x01\n    RSAEncrypt = 0x02  # deprecated\n    RSASign = 0x03     # deprecated\n    #: Signifies that a key is an ElGamal key.\n    ElGamal = 0x10\n    #: Signifies that a key is a DSA key.\n    DSA = 0x11\n    #: Signifies that a key is an ECDH key.\n    ECDH = 0x12\n    #: Signifies that a key is an ECDSA key.\n    ECDSA = 0x13\n    FormerlyElGamalEncryptOrSign = 0x14  # deprecated - do not generate\n    # DiffieHellman = 0x15  # X9.42\n\n    @property\n    def can_gen(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign,\n                        PubKeyAlgorithm.DSA,\n                        PubKeyAlgorithm.ECDSA,\n                        PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_encrypt(self):  # pragma: no cover\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.ElGamal, PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_sign(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.DSA, PubKeyAlgorithm.ECDSA}\n\n    @property\n    def deprecated(self):\n        return self in {PubKeyAlgorithm.RSAEncrypt,\n                        PubKeyAlgorithm.RSASign,\n                        PubKeyAlgorithm.FormerlyElGamalEncryptOrSign}\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass Signature(SubPacket):\n    __typeid__ = -1\nsrc/leap/mx/vendor/pgpy/constants.py\nclass SymmetricKeyAlgorithm(IntEnum):\n    \"\"\"Supported symmetric key algorithms.\"\"\"\n    Plaintext = 0x00\n    #: .. warning::\n    #:     IDEA is insecure. PGPy only allows it to be used for decryption, not encryption!\n    IDEA = 0x01\n    #: Triple-DES with 168-bit key derived from 192\n    TripleDES = 0x02\n    #: CAST5 (or CAST-128) with 128-bit key\n    CAST5 = 0x03\n    #: Blowfish with 128-bit key and 16 rounds\n    Blowfish = 0x04\n    #: AES with 128-bit key\n    AES128 = 0x07\n    #: AES with 192-bit key\n    AES192 = 0x08\n    #: AES with 256-bit key\n    AES256 = 0x09\n    # Twofish with 256-bit key - not currently supported\n    Twofish256 = 0x0A\n    #: Camellia with 128-bit key\n    Camellia128 = 0x0B\n    #: Camellia with 192-bit key\n    Camellia192 = 0x0C\n    #: Camellia with 256-bit key\n    Camellia256 = 0x0D\n\n    @property\n    def cipher(self):\n        bs = {SymmetricKeyAlgorithm.IDEA: algorithms.IDEA,\n              SymmetricKeyAlgorithm.TripleDES: algorithms.TripleDES,\n              SymmetricKeyAlgorithm.CAST5: algorithms.CAST5,\n              SymmetricKeyAlgorithm.Blowfish: algorithms.Blowfish,\n              SymmetricKeyAlgorithm.AES128: algorithms.AES,\n              SymmetricKeyAlgorithm.AES192: algorithms.AES,\n              SymmetricKeyAlgorithm.AES256: algorithms.AES,\n              SymmetricKeyAlgorithm.Twofish256: namedtuple('Twofish256', ['block_size'])(block_size=128),\n              SymmetricKeyAlgorithm.Camellia128: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia192: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia256: algorithms.Camellia}\n\n        if self in bs:\n            return bs[self]\n\n        raise NotImplementedError(repr(self))\n\n    @property\n    def is_insecure(self):\n        insecure_ciphers = {SymmetricKeyAlgorithm.IDEA}\n        return self in insecure_ciphers\n\n    @property\n    def block_size(self):\n        return self.cipher.block_size\n\n    @property\n    def key_size(self):\n        ks = {SymmetricKeyAlgorithm.IDEA: 128,\n              SymmetricKeyAlgorithm.TripleDES: 192,\n              SymmetricKeyAlgorithm.CAST5: 128,\n              SymmetricKeyAlgorithm.Blowfish: 128,\n              SymmetricKeyAlgorithm.AES128: 128,\n              SymmetricKeyAlgorithm.AES192: 192,\n              SymmetricKeyAlgorithm.AES256: 256,\n              SymmetricKeyAlgorithm.Twofish256: 256,\n              SymmetricKeyAlgorithm.Camellia128: 128,\n              SymmetricKeyAlgorithm.Camellia192: 192,\n              SymmetricKeyAlgorithm.Camellia256: 256}\n\n        if self in ks:\n            return ks[self]\n\n        raise NotImplementedError(repr(self))\n\n    def gen_iv(self):\n        return os.urandom(self.block_size // 8)\n\n    def gen_key(self):\n        return os.urandom(self.key_size // 8)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass HashAlgorithm(IntEnum):\n    Invalid = 0x00\n    MD5 = 0x01\n    SHA1 = 0x02\n    RIPEMD160 = 0x03\n    _reserved_1 = 0x04\n    _reserved_2 = 0x05\n    _reserved_3 = 0x06\n    _reserved_4 = 0x07\n    SHA256 = 0x08\n    SHA384 = 0x09\n    SHA512 = 0x0A\n    SHA224 = 0x0B\n\n    def __init__(self, *args):\n        super(self.__class__, self).__init__()\n        self._tuned_count = 0\n\n    @property\n    def hasher(self):\n        return hashlib.new(self.name)\n\n    @property\n    def digest_size(self):\n        return self.hasher.digest_size\n\n    @property\n    def tuned_count(self):\n        if self._tuned_count == 0:\n            self.tune_count()\n\n        return self._tuned_count\n\n    def tune_count(self):\n        start = end = 0\n        htd = _hashtunedata[:]\n\n        while start == end:\n            # potentially do this multiple times in case the resolution of time.time is low enough that\n            # hashing 100 KiB isn't enough time to produce a measurable difference\n            # (e.g. if the timer for time.time doesn't have enough precision)\n            htd = htd + htd\n            h = self.hasher\n\n            start = time.time()\n            h.update(htd)\n            end = time.time()\n\n        # now calculate how many bytes need to be hashed to reach our expected time period\n        # GnuPG tunes for about 100ms, so we'll do that as well\n        _TIME = 0.100\n        ct = int(len(htd) * (_TIME / (end - start)))\n        c1 = ((ct >> (ct.bit_length() - 5)) - 16)\n        c2 = (ct.bit_length() - 11)\n        c = ((c2 << 4) + c1)\n\n        # constrain self._tuned_count to be between 0 and 255\n        self._tuned_count = max(min(c, 255), 0)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass CompressionAlgorithm(IntEnum):\n    #: No compression\n    Uncompressed = 0x00\n    #: ZIP DEFLATE\n    ZIP = 0x01\n    #: ZIP DEFLATE with zlib headers\n    ZLIB = 0x02\n    #: Bzip2\n    BZ2 = 0x03\n\n    def compress(self, data):\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.compress(data)[2:-4]\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.compress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.compress(data)\n\n        raise NotImplementedError(self)\n\n    def decompress(self, data):\n        if six.PY2:\n            data = bytes(data)\n\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.decompress(data, -15)\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.decompress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.decompress(data)\n\n        raise NotImplementedError(self)\nsrc/leap/mx/vendor/pgpy/types.py\nclass Fingerprint(str):\n    \"\"\"\n    A subclass of ``str``. Can be compared using == and != to ``str``, ``unicode``, and other :py:obj:`Fingerprint` instances.\n\n    Primarily used as a key for internal dictionaries, so it ignores spaces when comparing and hashing\n    \"\"\"\n    @property\n    def keyid(self):\n        return str(self).replace(' ', '')[-16:]\n\n    @property\n    def shortid(self):\n        return str(self).replace(' ', '')[-8:]\n\n    def __new__(cls, content):\n        if isinstance(content, Fingerprint):\n            return content\n\n        # validate input before continuing: this should be a string of 40 hex digits\n        content = content.upper().replace(' ', '')\n        if not bool(re.match(r'^[A-F0-9]{40}$', content)):\n            raise ValueError(\"Expected: String of 40 hex digits\")\n\n        # store in the format: \"AAAA BBBB CCCC DDDD EEEE  FFFF 0000 1111 2222 3333\"\n        #                                               ^^ note 2 spaces here\n        spaces = [ ' ' if i != 4 else '  ' for i in range(10) ]\n        chunks = [ ''.join(g) for g in six.moves.zip_longest(*[iter(content)] * 4) ]\n        content = ''.join(j for i in six.moves.zip_longest(chunks, spaces, fillvalue='') for j in i).strip()\n\n        return str.__new__(cls, content)\n\n    def __eq__(self, other):\n        if isinstance(other, Fingerprint):\n            return str(self) == str(other)\n\n        if isinstance(other, (six.text_type, bytes, bytearray)):\n            if isinstance(other, (bytes, bytearray)):  # pragma: no cover\n                other = other.decode('latin-1')\n\n            other = str(other).replace(' ', '')\n            return any([self.replace(' ', '') == other,\n                        self.keyid == other,\n                        self.shortid == other])\n\n        return False  # pragma: no cover\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __hash__(self):\n        return hash(str(self.replace(' ', '')))\n\n    def __bytes__(self):\n        return binascii.unhexlify(six.b(self.replace(' ', '')))\nsrc/leap/mx/vendor/pgpy/constants.py\nclass Features(FlagEnum):\n    ModificationDetection = 0x01\n\n    @classproperty\n    def pgpy_features(cls):\n        return Features.ModificationDetection\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyFlags(FlagEnum):\n    #: Signifies that a key may be used to certify keys and user ids. Primary keys always have this, even if it is not specified.\n    Certify = 0x01\n    #: Signifies that a key may be used to sign messages and documents.\n    Sign = 0x02\n    #: Signifies that a key may be used to encrypt messages.\n    EncryptCommunications = 0x04\n    #: Signifies that a key may be used to encrypt storage. Currently equivalent to :py:obj:`~pgpy.constants.EncryptCommunications`.\n    EncryptStorage = 0x08\n    #: Signifies that the private component of a given key may have been split by a secret-sharing mechanism. Split\n    #: keys are not currently supported by PGPy.\n    Split = 0x10\n    #: Signifies that a key may be used for authentication.\n    Authentication = 0x20\n    #: Signifies that the private component of a key may be in the possession of more than one person.\n    MultiPerson = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyServerPreferences(IntEnum):\n    Unknown = 0x00\n    NoModify = 0x80\nsrc/leap/mx/vendor/pgpy/decorators.py\ndef sdproperty(fget):\n    def defset(obj, val):  # pragma: no cover\n        raise TypeError(str(val.__class__))\n\n    class SDProperty(property):\n        def register(self, cls=None, fset=None):\n            return self.fset.register(cls, fset)\n\n        def setter(self, fset):\n            self.register(object, fset)\n            return type(self)(self.fget, self.fset, self.fdel, self.__doc__)\n\n    return SDProperty(fget, sdmethod(defset))\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass EmbeddedSignatureHeader(VersionedHeader):\n    def __bytearray__(self):\n        return bytearray([self.version])\n\n    def parse(self, packet):\n        self.tag = 2\n        super(EmbeddedSignatureHeader, self).parse(packet)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass NotationDataFlags(FlagEnum):\n    HumanReadable = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass RevocationReason(IntEnum):\n    #: No reason was specified. This is the default reason.\n    NotSpecified = 0x00\n    #: The key was superseded by a new key. Only meaningful when revoking a key.\n    Superseded = 0x01\n    #: Key material has been compromised. Only meaningful when revoking a key.\n    Compromised = 0x02\n    #: Key is retired and no longer used. Only meaningful when revoking a key.\n    Retired = 0x03\n    #: User ID information is no longer valid. Only meaningful when revoking a certification of a user id.\n    UserID = 0x20\nsrc/leap/mx/vendor/pgpy/constants.py\nclass RevocationKeyClass(FlagEnum):\n    Sensitive = 0x40\n    Normal = 0x80\n", "answers": ["    @sdproperty"], "length": 1318, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "ea34735f9ac205293023394877d630555a04b487a2cf6036"}
{"input": "import info.ata4.minecraft.minema.Minema;\nimport info.ata4.minecraft.minema.client.config.MinemaConfig;\nimport info.ata4.minecraft.minema.client.event.FrameEvent;\nimport info.ata4.minecraft.minema.client.event.FrameImportEvent;\nimport info.ata4.minecraft.minema.client.event.FrameInitEvent;\nimport info.ata4.minecraft.minema.client.modules.exporters.FrameExporter;\nimport info.ata4.minecraft.minema.client.modules.exporters.ImageFrameExporter;\nimport info.ata4.minecraft.minema.client.modules.exporters.PipeFrameExporter;\nimport info.ata4.minecraft.minema.client.modules.importers.FrameImporter;\nimport info.ata4.minecraft.minema.client.modules.modifiers.DisplaySizeModifier;\nimport info.ata4.minecraft.minema.client.modules.modifiers.GameSettingsModifier;\nimport info.ata4.minecraft.minema.client.modules.modifiers.TimerModifier;\nimport info.ata4.minecraft.minema.client.util.CaptureFrame;\nimport info.ata4.minecraft.minema.client.util.CaptureTime;\nimport info.ata4.minecraft.minema.client.util.ChatUtils;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.util.text.TextFormatting;\nimport net.minecraftforge.common.MinecraftForge;\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\nimport net.minecraftforge.fml.common.gameevent.TickEvent.Phase;\nimport net.minecraftforge.fml.common.gameevent.TickEvent.RenderTickEvent;\n/*\n ** 2014 July 28\n **\n ** The author disclaims copyright to this source code.  In place of\n ** a legal notice, here is a blessing:\n **    May you do good and not evil.\n **    May you find forgiveness for yourself and forgive others.\n **    May you share freely, never taking more than you give.\n */\npackage info.ata4.minecraft.minema.client.modules;\n\n\n/**\n *\n * @author Nico Bergemann <barracuda415 at yahoo.de>\n */\npublic class CaptureSession extends CaptureModule {\n\n    public static Minecraft MC = Minecraft.getMinecraft();\n\n    private final ArrayList<CaptureModule> modules = new ArrayList<>();\n\n    private Path movieDir;", "context": "src/main/java/info/ata4/minecraft/minema/client/event/FrameImportEvent.java\npublic class FrameImportEvent extends FrameEvent {\n\n    public FrameImportEvent(CaptureFrame frame, CaptureTime time, Path movieDir) {\n        super(frame, time, movieDir);\n    }\n\n}\nsrc/main/java/info/ata4/minecraft/minema/client/modules/exporters/FrameExporter.java\npublic abstract class FrameExporter extends CaptureModule {\n\n    private static final Logger L = LogManager.getLogger();\n\n    protected ExecutorService exportService;\n    protected Future<?> exportFuture;\n\n    public FrameExporter(MinemaConfig cfg) {\n        super(cfg);\n    }\n\n    @Override\n    protected void doEnable() throws Exception {\n        exportService = Executors.newSingleThreadExecutor();\n    }\n\n    @Override\n    protected void doDisable() throws Exception {\n        exportService.shutdown();\n\n        try {\n            if (!exportService.awaitTermination(3, TimeUnit.SECONDS)) {\n                L.warn(\"Frame export service termination timeout\");\n                exportService.shutdownNow();\n            }\n        } catch (InterruptedException ex) {\n            handleWarning(ex, \"Frame export service termination interrupted\");\n        }\n    }\n\n    @SubscribeEvent\n    public void onFrameImport(FrameImportEvent evt) throws ExecutionException {\n        if (!isEnabled()) {\n            return;\n        }\n\n        // wait for the previous task to complete before sending the next one\n        try {\n            if (exportFuture != null) {\n                exportFuture.get();\n            }\n        } catch (InterruptedException ex) {\n            // catch uncritical interruption exception\n            handleWarning(ex, \"Frame export task interrupted\");\n        }\n    }\n\n    @SubscribeEvent\n    public void onFrameExport(FrameExportEvent evt) {\n        if (!isEnabled()) {\n            return;\n        }\n\n        // export frame in the background so that the next frame can be\n        // rendered in the meantime\n        exportFuture = exportService.submit(() -> {\n            try {\n                doExportFrame(evt);\n            } catch (Exception ex) {\n                throw new RuntimeException(\"Can't export frame \" + evt.time.getNumFrames(), ex);\n            }\n        });\n    }\n\n    protected abstract void doExportFrame(FrameExportEvent evt) throws Exception;\n}\nsrc/main/java/info/ata4/minecraft/minema/client/modules/modifiers/GameSettingsModifier.java\npublic class GameSettingsModifier extends CaptureModule {\n\n    private static final Minecraft MC = Minecraft.getMinecraft();\n\n    private int framerateLimit;\n    private boolean vSync;\n    private boolean pauseOnLostFocus;\n\n    public GameSettingsModifier(MinemaConfig cfg) {\n        super(cfg);\n    }\n\n    @Override\n    protected void doEnable() throws Exception {\n        GameSettings gs = MC.gameSettings;\n\n        // disable build-in framerate limit\n        framerateLimit = gs.limitFramerate;\n        gs.limitFramerate = Integer.MAX_VALUE;\n\n        // disable vSync\n        vSync = gs.enableVsync;\n        gs.enableVsync = false;\n\n        // don't pause when losing focus\n        pauseOnLostFocus = gs.pauseOnLostFocus;\n        gs.pauseOnLostFocus = false;\n\n    }\n\n    @Override\n    protected void doDisable() throws Exception {\n        // restore everything\n        GameSettings gs = MC.gameSettings;\n        gs.limitFramerate = framerateLimit;\n        gs.pauseOnLostFocus = pauseOnLostFocus;\n        gs.enableVsync = vSync;\n    }\n\n}\nsrc/main/java/info/ata4/minecraft/minema/client/modules/importers/FrameImporter.java\npublic class FrameImporter extends CaptureModule {\n\n    private static final int PBO_TARGET = GL_PIXEL_PACK_BUFFER_ARB;\n    private static final int PBO_USAGE = GL_STREAM_READ_ARB;\n    private static final int PBO_ACCESS = GL_READ_ONLY_ARB;\n\n    private final boolean usePBO;\n    private final boolean useFBO;\n\n    // PBO state variables\n    private int frontName;\n    private int backName;\n    private ByteBuffer bufferPBO;\n    private boolean firstFrame;\n\n    public FrameImporter(MinemaConfig cfg) {\n        super(cfg);\n\n        usePBO = GLContext.getCapabilities().GL_ARB_pixel_buffer_object && cfg.usePBO.get();\n        useFBO = OpenGlHelper.isFramebufferEnabled();\n    }\n\n    @SubscribeEvent\n    public void onFrameInit(FrameInitEvent e) {\n        int bufferSize = e.frame.buffer.capacity();\n\n        if (usePBO) {\n            frontName = glGenBuffersARB();\n            glBindBufferARB(PBO_TARGET, frontName);\n            glBufferDataARB(PBO_TARGET, bufferSize, PBO_USAGE);\n\n            backName = glGenBuffersARB();\n            glBindBufferARB(PBO_TARGET, backName);\n            glBufferDataARB(PBO_TARGET, bufferSize, PBO_USAGE);\n\n            glBindBufferARB(PBO_TARGET, 0);\n\n            firstFrame = true;\n        }\n    }\n\n    @SubscribeEvent\n    public void onFrameImport(FrameImportEvent e) {\n        CaptureFrame frame = e.frame;\n\n        // check if the dimensions are still the same\n        frame.checkWindowSize();\n\n        if (usePBO) {\n            glBindBufferARB(PBO_TARGET, frontName);\n        }\n\n        // read pixels\n        frame.readPixels(useFBO, usePBO);\n\n        ByteBuffer buffer = e.frame.buffer;\n\n        if (usePBO) {\n            // copy back buffer\n            glBindBufferARB(PBO_TARGET, backName);\n            bufferPBO = glMapBufferARB(PBO_TARGET, PBO_ACCESS, buffer.capacity(), bufferPBO);\n            bufferPBO.rewind();\n            buffer.rewind();\n            buffer.put(bufferPBO);\n            glUnmapBufferARB(PBO_TARGET);\n            glBindBufferARB(PBO_TARGET, 0);\n\n            // If mapping threw an error -> crash immediately please\n            Util.checkGLError();\n\n            // swap PBOs\n            int swapName = frontName;\n            frontName = backName;\n            backName = swapName;\n        }\n\n        buffer.rewind();\n        \n        // first frame is empty in PBO mode, don't export it\n        if (usePBO && firstFrame) {\n            firstFrame = false;\n            return;\n        }\n\n        // send frame export event\n        Minema.EVENT_BUS.post(new FrameExportEvent(e.frame, e.time, e.movieDir));\n        e.time.nextFrame();\n    }\n\n    @Override\n    protected void doEnable() throws Exception {\n    }\n\n    @Override\n    protected void doDisable() throws Exception {\n        if (usePBO) {\n            glDeleteBuffersARB(frontName);\n            glDeleteBuffersARB(backName);\n        }\n    }\n}\nsrc/main/java/info/ata4/minecraft/minema/client/util/CaptureFrame.java\npublic class CaptureFrame {\n\n    private static final Minecraft MC = Minecraft.getMinecraft();\n    private static final int BPP = 3;\n    private static final int TYPE = GL_UNSIGNED_BYTE;\n    private static final int FORMAT = GL_BGR;\n\n    public final int width;\n    public final int height;\n    public final ByteBuffer buffer;\n\n    public CaptureFrame() {\n        this.width = MC.displayWidth;\n        this.height = MC.displayHeight;\n        this.buffer = ByteBuffer.allocateDirect(width * height * BPP);\n    }\n\n    public void checkWindowSize() {\n        int displayWidth = MC.displayWidth;\n        int displayHeight = MC.displayHeight;\n        if (displayWidth != width || displayHeight != height) {\n            throw new IllegalStateException(String.format(\n                \"Display size changed! %dx%d not equals the start dimension of %dx%d\",\n                displayWidth, displayHeight, width, height));\n        }\n    }\n\n    public void readPixels(boolean fbo, boolean pbo) {\n        buffer.rewind();\n\n        // set alignment flags\n        glPixelStorei(GL_PACK_ALIGNMENT, 1);\n        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n        // read texture from framebuffer if enabled, otherwise use slower\n        // glReadPixels\n        if (fbo) {\n            Framebuffer fb = MC.getFramebuffer();\n            fb.bindFramebufferTexture();\n            if (pbo) {\n                glGetTexImage(GL_TEXTURE_2D, 0, FORMAT, TYPE, 0);\n            } else {\n                glGetTexImage(GL_TEXTURE_2D, 0, FORMAT, TYPE, buffer);\n            }\n            fb.unbindFramebufferTexture();\n        } else {\n            if (pbo) {\n                glReadPixels(0, 0, width, height, FORMAT, TYPE, 0);\n            } else {\n                glReadPixels(0, 0, width, height, FORMAT, TYPE, buffer);\n            }\n        }\n    }\n}\nsrc/main/java/info/ata4/minecraft/minema/client/util/CaptureTime.java\npublic class CaptureTime {\n\n    private static final Map<TimeUnit, String> TU_SUFFIX;\n\n    static {\n        Map<TimeUnit, String> tuSuffix = new EnumMap<>(TimeUnit.class);\n        tuSuffix.put(TimeUnit.DAYS, \"d\");\n        tuSuffix.put(TimeUnit.HOURS, \"h\");\n        tuSuffix.put(TimeUnit.MINUTES, \"m\");\n        tuSuffix.put(TimeUnit.SECONDS, \"s\");\n        tuSuffix.put(TimeUnit.MILLISECONDS, \"ms\");\n        tuSuffix.put(TimeUnit.MICROSECONDS, \"µs\");\n        tuSuffix.put(TimeUnit.NANOSECONDS, \"ns\");\n        TU_SUFFIX = Collections.unmodifiableMap(tuSuffix);\n    }\n\n    public static String getTimeUnit(long nanos) {\n        TimeUnit tu = null;\n        TimeUnit[] tus = TimeUnit.values();\n        long time = nanos;\n\n        for (int i = tus.length - 1; i >= 0; i--) {\n            tu = tus[i];\n            time = tu.convert(nanos, TimeUnit.NANOSECONDS);\n            if (time > 1) {\n                break;\n            }\n        }\n\n        return time + TU_SUFFIX.get(tu);\n    }\n\n    public static String getTimeStringFull(long nanos) {\n        long hours = TimeUnit.NANOSECONDS.toHours(nanos);\n        long minutes = TimeUnit.NANOSECONDS.toMinutes(nanos) - TimeUnit.HOURS.toMinutes(hours);\n        long seconds = TimeUnit.NANOSECONDS.toSeconds(nanos) - TimeUnit.MINUTES.toSeconds(minutes)\n                - TimeUnit.HOURS.toSeconds(hours);\n        long milis = TimeUnit.NANOSECONDS.toMillis(nanos) - TimeUnit.SECONDS.toMillis(seconds)\n                - TimeUnit.MINUTES.toMillis(minutes) - TimeUnit.HOURS.toMillis(hours);\n\n        return String.format(\"%02d:%02d:%02d.%03d\", hours, minutes, seconds, milis);\n    }\n\n    public static String getTimeStringSimple(long nanos) {\n        long hours = TimeUnit.NANOSECONDS.toHours(nanos);\n        long minutes = TimeUnit.NANOSECONDS.toMinutes(nanos) - TimeUnit.HOURS.toMinutes(hours);\n        long seconds = TimeUnit.NANOSECONDS.toSeconds(nanos) - TimeUnit.MINUTES.toSeconds(minutes)\n                - TimeUnit.HOURS.toSeconds(hours);\n\n        return String.format(\"%dh %dm %ds\", hours, minutes, seconds);\n    }\n\n    private final long startTime;\n    private final long nanosPerFrame;\n    private long currentFrameTime;\n    private long prevFrameTime;\n    private int frames;\n\n    public CaptureTime(double frameRate) {\n        nanosPerFrame = (long) (TimeUnit.SECONDS.toNanos(1) / frameRate);\n        startTime = currentFrameTime = prevFrameTime = System.nanoTime();\n    }\n\n    public void nextFrame() {\n        prevFrameTime = currentFrameTime;\n        currentFrameTime = System.nanoTime();\n        frames++;\n    }\n\n    public int getNumFrames() {\n        return frames;\n    }\n\n    public boolean isNextFrame() {\n        return getTimeSincePreviousFrame() >= nanosPerFrame;\n    }\n\n    public long getPreviousCaptureTime() {\n        return currentFrameTime - prevFrameTime;\n    }\n\n    public long getTimeSincePreviousFrame() {\n        return System.nanoTime() - prevFrameTime;\n    }\n\n    public long getStartTime() {\n        return startTime;\n    }\n\n    public long getRealTime() {\n        return System.nanoTime() - startTime;\n    }\n\n    public String getRealTimeString() {\n        return getTimeStringFull(getRealTime());\n    }\n\n    public long getVideoTime() {\n        return frames * nanosPerFrame;\n    }\n\n    public String getVideoTimeString() {\n        return getTimeStringFull(getVideoTime());\n    }\n\n    public double getAverageFPS() {\n        return TimeUnit.SECONDS.toNanos(1) / ((double) getRealTime() / (double) getNumFrames());\n    }\n}\nsrc/main/java/info/ata4/minecraft/minema/client/config/MinemaConfig.java\npublic class MinemaConfig {\n\n    private static final int MAX_TEXTURE_SIZE = Minecraft.getGLMaximumTextureSize();\n\n    public static final String LANG_KEY = \"minema.config\";\n\n    public final ConfigBoolean useVideoEncoder = new ConfigBoolean(true);\n    public final ConfigString videoEncoderPath = new ConfigString(\"ffmpeg\");\n    public final ConfigString videoEncoderParams = new ConfigString(\n        \"-f rawvideo -pix_fmt bgr24 -s %WIDTH%x%HEIGHT% -r %FPS% -i - -vf vflip \" +\n        \"-c:v libx264 -preset ultrafast -tune zerolatency -qp 20 video.mp4\");\n    public final ConfigEnum<SnapResolution> snapResolution = new ConfigEnum<>(SnapResolution.MOD2);\n\n    public final ConfigInteger frameWidth = new ConfigInteger(0, 0, MAX_TEXTURE_SIZE);\n    public final ConfigInteger frameHeight = new ConfigInteger(0, 0, MAX_TEXTURE_SIZE);\n    public final ConfigDouble frameRate = new ConfigDouble(30.0, 0.01, 1000.0);\n    public final ConfigInteger frameLimit = new ConfigInteger(-1, -1);\n    public final ConfigString capturePath = new ConfigString(\"movies\");\n    public final ConfigBoolean showOverlay = new ConfigBoolean(false);\n    public final ConfigBoolean usePBO = new ConfigBoolean(true);\n\n    public final ConfigDouble engineSpeed = new ConfigDouble(1.0, 0.01);\n    // public final ConfigInteger particleLimit = new ConfigInteger(64000, -1);\n    public final ConfigBoolean syncEngine = new ConfigBoolean(true);\n    // public final ConfigBoolean preloadChunks = new ConfigBoolean(false);\n\n    public MinemaConfig(Configuration cfg) {\n        useVideoEncoder.link(cfg, \"encoding.useVideoEncoder\", LANG_KEY);\n        videoEncoderPath.link(cfg, \"encoding.videoEncoderPath\", LANG_KEY);\n        videoEncoderParams.link(cfg, \"encoding.videoEncoderParams\", LANG_KEY);\n        snapResolution.link(cfg, \"encoding.snapResolution\", LANG_KEY);\n\n        frameWidth.link(cfg, \"capturing.frameWidth\", LANG_KEY);\n        frameHeight.link(cfg, \"capturing.frameHeight\", LANG_KEY);\n        frameRate.link(cfg, \"capturing.frameRate\", LANG_KEY);\n        frameLimit.link(cfg, \"capturing.frameLimit\", LANG_KEY);\n        capturePath.link(cfg, \"capturing.capturePath\", LANG_KEY);\n        showOverlay.link(cfg, \"capturing.showOverlay\", LANG_KEY);\n        usePBO.link(cfg, \"capturing.usePBO\", LANG_KEY);\n\n        engineSpeed.link(cfg, \"engine.engineSpeed\", LANG_KEY);\n        // particleLimit.link(config, \"engine.particleLimit\", LANG_KEY);\n        syncEngine.link(cfg, \"engine.syncEngine\", LANG_KEY);\n    }\n\n    public int getFrameWidth() {\n        int width = frameWidth.get();\n        \n        // use display width if not set\n        if (width == 0) {\n            width = Display.getWidth();\n        }\n\n        // snap to nearest\n        if (useVideoEncoder.get()) {\n            width = snapResolution.get().snap(width);\n        }\n\n        return width;\n    }\n\n    public int getFrameHeight() {\n        int height = frameHeight.get();\n        \n        // use display height if not set\n        if (height == 0) {\n            height = Display.getHeight();\n        }\n\n        // snap to nearest\n        if (useVideoEncoder.get()) {\n            height = snapResolution.get().snap(height);\n        }\n\n        return height;\n    }\n\n    public boolean useFrameSize() {\n        return getFrameWidth() != Display.getWidth() || getFrameHeight() != Display.getHeight();\n    }\n\n    public boolean isSyncEngine() {\n        return Minecraft.getMinecraft().isSingleplayer() && syncEngine.get();\n    }\n}\nsrc/main/java/info/ata4/minecraft/minema/client/modules/exporters/PipeFrameExporter.java\npublic class PipeFrameExporter extends FrameExporter {\n\n    private Process proc;\n    private WritableByteChannel pipe;\n\n    public PipeFrameExporter(MinemaConfig cfg) {\n        super(cfg);\n    }\n\n    @SubscribeEvent\n    public void onFrameInit(FrameInitEvent e) {\n        try {\n            String params = cfg.videoEncoderParams.get();\n            params = params.replace(\"%WIDTH%\", String.valueOf(e.frame.width));\n            params = params.replace(\"%HEIGHT%\", String.valueOf(e.frame.height));\n            params = params.replace(\"%FPS%\", String.valueOf(cfg.frameRate.get()));\n\n            List<String> cmds = new ArrayList<>();\n            cmds.add(cfg.videoEncoderPath.get());\n            cmds.addAll(Arrays.asList(StringUtils.split(params, ' ')));\n\n            // build encoder process and redirect output\n            ProcessBuilder pb = new ProcessBuilder(cmds);\n            pb.directory(e.movieDir.toFile());\n            pb.redirectErrorStream(true);\n            pb.redirectOutput(e.movieDir.resolve(\"encoder.log\").toFile());\n            proc = pb.start();\n\n            // Java wraps the process output stream into a BufferedOutputStream,\n            // but its little buffer is just slowing everything down with the huge\n            // amount of data we're dealing here, so unwrap it with this little hack.\n            OutputStream os = proc.getOutputStream();\n            if (os instanceof FilterOutputStream) {\n                Field outField = FilterOutputStream.class.getDeclaredField(\"out\");\n                outField.setAccessible(true);\n                os = (OutputStream) outField.get(os);\n            }\n\n            pipe = Channels.newChannel(os);\n        } catch (Exception ex) {\n            handleError(ex, \"Can't start encoder\");\n        }\n    }\n\n    @Override\n    protected void doDisable() throws Exception {\n        super.doDisable();\n\n        try {\n            if (pipe.isOpen()) {\n                pipe.close();\n            }\n        } catch (IOException ex) {\n            handleWarning(ex, \"Pipe not closed properly\");\n        }\n\n        try {\n            if (proc != null) {\n                proc.waitFor(1, TimeUnit.MINUTES);\n                proc.destroy();\n            }\n        } catch (InterruptedException ex) {\n            handleWarning(ex, \"Pipe program termination interrupted\");\n        }\n    }\n\n    @Override\n    protected void doExportFrame(FrameExportEvent evt) throws Exception {\n        if (pipe.isOpen()) {\n            pipe.write(evt.frame.buffer);\n        }\n    }\n}\nsrc/main/java/info/ata4/minecraft/minema/client/event/FrameInitEvent.java\npublic class FrameInitEvent extends FrameEvent {\n    \n    public FrameInitEvent(CaptureFrame frame, CaptureTime time, Path movieDir) {\n        super(frame, time, movieDir);\n    }\n\n}\nsrc/main/java/info/ata4/minecraft/minema/client/util/ChatUtils.java\npublic class ChatUtils {\n\n    private static final Minecraft MC = Minecraft.getMinecraft();\n\n    public static void print(String msg, TextFormatting format, Object... args) {\n        if (MC.ingameGUI == null) {\n            return;\n        }\n\n        GuiNewChat chat = MC.ingameGUI.getChatGUI();\n        TextComponentTranslation ret = new TextComponentTranslation(msg, args);\n        ret.getStyle().setColor(format);\n\n        chat.printChatMessage(ret);\n    }\n\n}\nsrc/main/java/info/ata4/minecraft/minema/client/modules/modifiers/TimerModifier.java\npublic class TimerModifier extends CaptureModule implements PrivateAccessor {\n\n    private static final Logger L = LogManager.getLogger();\n    private static final Minecraft MC = Minecraft.getMinecraft();\n\n    private float defaultTps;\n\n    public TimerModifier(MinemaConfig cfg) {\n        super(cfg);\n    }\n\n    @Override\n    protected void doEnable() {\n        Timer defaultTimer = minecraftGetTimer(MC);\n\n        // check if it's modified already\n        if (defaultTimer instanceof FixedTimer) {\n            L.warn(\"Timer is already modified!\");\n            return;\n        }\n\n        // get default ticks per second if possible\n        if (defaultTimer != null) {\n            defaultTps = timerGetTicksPerSecond(defaultTimer);\n        }\n\n        float fps = cfg.frameRate.get().floatValue();\n        float speed = cfg.engineSpeed.get().floatValue();\n\n        // set fixed delay timer\n        minecraftSetTimer(MC, new FixedTimer(defaultTps, fps, speed));\n    }\n\n    @Override\n    protected void doDisable() {\n        // check if it's still modified\n        if (!(minecraftGetTimer(MC) instanceof FixedTimer)) {\n            L.warn(\"Timer is already restored!\");\n            return;\n        }\n\n        // restore default timer\n        minecraftSetTimer(MC, new Timer(defaultTps));\n    }\n}\nsrc/main/java/info/ata4/minecraft/minema/client/event/FrameEvent.java\n@Cancelable\npublic abstract class FrameEvent extends Event  {\n\n    public final CaptureFrame frame;\n    public final CaptureTime time;\n    public final Path movieDir;\n\n    public FrameEvent(CaptureFrame frame, CaptureTime time, Path movieDir) {\n        this.frame = frame;\n        this.time = time;\n        this.movieDir = movieDir;\n    }\n}\nsrc/main/java/info/ata4/minecraft/minema/client/modules/exporters/ImageFrameExporter.java\npublic class ImageFrameExporter extends FrameExporter {\n\n    public ImageFrameExporter(MinemaConfig cfg) {\n        super(cfg);\n    }\n\n    @Override\n    protected void doExportFrame(FrameExportEvent evt) throws IOException {\n        String fileName = String.format(\"%06d.tga\", evt.time.getNumFrames());\n        Path path = evt.movieDir.resolve(fileName);\n        writeImage(path, evt.frame.buffer, evt.frame.width, evt.frame.height);\n    }\n\n    private void writeImage(Path path, ByteBuffer bb, int width, int height) throws IOException {\n        ByteBuffer tgah = ByteBuffer.allocate(18);\n        tgah.order(ByteOrder.LITTLE_ENDIAN);\n\n        // image type - uncompressed true-color image\n        tgah.position(2);\n        tgah.put((byte) 2);\n\n        // width and height\n        tgah.position(12);\n        tgah.putShort((short) (width & 0xffff));\n        tgah.putShort((short) (height & 0xffff));\n\n        // bits per pixel\n        tgah.position(16);\n        tgah.put((byte) 24);\n\n        tgah.rewind();\n\n        try (FileChannel fc = FileChannel.open(path, CREATE, WRITE)) {\n            fc.write(tgah);\n            fc.write(bb);\n        }\n    }\n}\nsrc/main/java/info/ata4/minecraft/minema/Minema.java\n@Mod(\n    modid = Minema.ID,\n    name = Minema.NAME,\n    version = Minema.VERSION,\n    guiFactory = \"info.ata4.minecraft.minema.client.config.MinemaConfigGuiFactory\"\n)\npublic class Minema {\n\n    public static final String NAME = \"Minema\";\n    public static final String ID = NAME;\n    public static final String VERSION = \"@VERSION@\";\n\n    @Instance(ID)\n    public static Minema instance;\n    public static final EventBus EVENT_BUS = new EventBus();\n\n    private ModMetadata metadata;\n    private Configuration configForge;\n    private MinemaConfig config;\n    private CaptureSession session;\n\n    @EventHandler\n    public void onPreInit(FMLPreInitializationEvent evt) {\n        File file = evt.getSuggestedConfigurationFile();\n        configForge = new Configuration(file);\n        config = new MinemaConfig(configForge);\n        metadata = evt.getModMetadata();\n    }\n\n    @EventHandler\n    public void onInit(FMLInitializationEvent evt) {\n        ClientCommandHandler.instance.registerCommand(new CommandMinema(this));\n        MinecraftForge.EVENT_BUS.register(new KeyHandler(this));\n    }\n    \n    public Configuration getConfigForge() {\n        return configForge;\n    }\n\n    public MinemaConfig getConfig() {\n        return config;\n    }\n\n    public ModMetadata getMetadata() {\n        return metadata;\n    }\n\n    public void enable() {\n        session = new CaptureSession(config);\n        session.enable();\n    }\n\n    public void disable() {\n        if (isEnabled()) {\n            session.disable();\n        }\n        session = null;\n    }\n\n    public boolean isEnabled() {\n        return session != null && session.isEnabled();\n    }\n}\nsrc/main/java/info/ata4/minecraft/minema/client/modules/modifiers/DisplaySizeModifier.java\npublic class DisplaySizeModifier extends CaptureModule {\n\n    private static final Minecraft MC = Minecraft.getMinecraft();\n\n    private int originalWidth;\n    private int originalHeight;\n\n    public DisplaySizeModifier(MinemaConfig cfg) {\n        super(cfg);\n    }\n\n    @Override\n    protected void doEnable() {\n        originalWidth = Display.getWidth();\n        originalHeight = Display.getHeight();\n\n        resize(cfg.getFrameWidth(), cfg.getFrameHeight());\n\n        // render framebuffer texture in original size\n        if (OpenGlHelper.isFramebufferEnabled()) {\n            setFramebufferTextureSize(originalWidth, originalHeight);\n        }\n    }\n\n    @Override\n    protected void doDisable() {\n        resize(originalWidth, originalHeight);\n    }\n\n    public void resize(int width, int height) {\n        MC.resize(width, height);\n    }\n\n    public void setFramebufferTextureSize(int width, int height) {\n        Framebuffer fb = MC.getFramebuffer();\n        fb.framebufferTextureWidth = width;\n        fb.framebufferTextureHeight = height;\n    }\n}\n", "answers": ["    private CaptureTime time;"], "length": 2248, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "48d855bfde920e5e4c41f42a9495916d2d62c50a40d29eaa"}
{"input": "import numpy as np\nimport operator\nimport pickle\nimport pytest\nimport unyt.unit_symbols as unit_symbols\n    import unyt as u\n    import unyt as u\n    import unyt\n    import unyt\nfrom numpy.testing import (\n    assert_almost_equal,\n    assert_allclose,\n    assert_array_almost_equal_nulp,\n    assert_equal,\n)\nfrom sympy import Symbol\nfrom unyt.array import unyt_quantity\nfrom unyt.testing import assert_allclose_units\nfrom unyt.unit_registry import UnitRegistry\nfrom unyt.dimensions import (\n    mass,\n    length,\n    time,\n    temperature,\n    energy,\n    magnetic_field_cgs,\n    magnetic_field_mks,\n    power,\n    rate,\n)\nfrom unyt.exceptions import InvalidUnitOperation, UnitsNotReducible, UnitConversionError\nfrom unyt.unit_object import default_unit_registry, Unit, UnitParseError\nfrom unyt.unit_systems import cgs_unit_system, UnitSystem\nfrom unyt._unit_lookup_table import (\n    default_unit_symbol_lut,\n    name_alternatives,\n    unit_prefixes,\n)\nfrom unyt._physical_ratios import (\n    m_per_pc,\n    sec_per_year,\n    m_per_km,\n    m_per_mpc,\n    mass_sun_kg,\n)\n    from sympy import nsimplify\n    from unyt import dimensionless\n    from unyt import electrostatic_unit, elementary_charge_cgs\n    from unyt import m\n    from unyt import degF, dimensionless\n    from unyt import UnitRegistry\n    from unyt import cm\n    from unyt import A, cm\n    from unyt._unit_lookup_table import (\n        default_unit_name_alternatives,\n        name_alternatives,\n        inv_name_alternatives,\n    )\n    from unyt import Unit\n    from unyt import Unit, attosecond, second\n    from unyt import Unit\n\n    assert_equal(u1.latex_repr, \"\")\n    assert_equal(u2.latex_repr, \"\")\n\n\ndef test_create_from_string():\n    \"\"\"\n    Create units with strings and check attributes.\n\n    \"\"\"\n\n    u1 = Unit(\"kg * m**2 * s**-2\")\n    assert u1.dimensions == energy\n    assert u1.base_value == 1.0\n\n    # make sure order doesn't matter\n    u2 = Unit(\"m**2 * s**-2 * kg\")\n    assert u2.dimensions == energy\n    assert u2.base_value == 1.0\n\n    # Test rationals\n    u3 = Unit(\"kg**0.5 * m**-0.5 * s**-1\")\n    assert u3.dimensions == magnetic_field_cgs\n    assert u3.base_value == 1.0\n\n    # sqrt functions\n    u4 = Unit(\"sqrt(kg)/sqrt(m)/s\")\n    assert u4.dimensions == magnetic_field_cgs\n    assert u4.base_value == 1.0\n\n    # commutative sqrt function\n    u5 = Unit(\"sqrt(kg/m)/s\")\n    assert u5.dimensions == magnetic_field_cgs\n    assert u5.base_value == 1.0\n\n    # nonzero CGS conversion factor\n    u6 = Unit(\"Msun/pc**3\")\n    assert u6.dimensions == mass / length ** 3\n    assert_array_almost_equal_nulp(\n        np.array([u6.base_value]), np.array([mass_sun_kg / m_per_pc ** 3])\n    )\n\n    with pytest.raises(UnitParseError):\n        Unit(\"m**m\")\n    with pytest.raises(UnitParseError):\n        Unit(\"m**g\")\n    with pytest.raises(UnitParseError):\n        Unit(\"m+g\")\n    with pytest.raises(UnitParseError):\n        Unit(\"m-g\")\n    with pytest.raises(UnitParseError):\n        Unit(\"hello!\")\n    with pytest.raises(UnitParseError):\n        Unit(\"True\")\n    with pytest.raises(UnitParseError):\n        Unit(\"else\")\n    with pytest.raises(UnitParseError):\n        Unit(\"hello(37)\")\n    with pytest.raises(UnitParseError):\n        Unit(\"hello(foo=37)\")\n\n    cm = Unit(\"cm\")\n    data = 1 * cm\n\n    assert Unit(data) == cm\n    assert Unit(b\"cm\") == cm\n\n\ndef test_create_from_expr():\n    \"\"\"\n    Create units from sympy Exprs and check attributes.\n\n    \"\"\"\n    pc_mks = m_per_pc\n    yr_mks = sec_per_year\n\n    # Symbol expr\n    s1 = Symbol(\"pc\", positive=True)\n    s2 = Symbol(\"yr\", positive=True)\n    # Mul expr\n    s3 = s1 * s2\n    # Pow expr\n    s4 = s1 ** 2 * s2 ** (-1)\n\n    u1 = Unit(s1)\n    u2 = Unit(s2)\n    u3 = Unit(s3)\n    u4 = Unit(s4)\n\n    assert u1.expr == s1\n    assert u2.expr == s2\n    assert u3.expr == s3\n    assert u4.expr == s4\n\n    assert_allclose_units(u1.base_value, pc_mks, 1e-12)\n    assert_allclose_units(u2.base_value, yr_mks, 1e-12)\n    assert_allclose_units(u3.base_value, pc_mks * yr_mks, 1e-12)\n    assert_allclose_units(u4.base_value, pc_mks ** 2 / yr_mks, 1e-12)\n\n    assert u1.dimensions == length\n    assert u2.dimensions == time\n    assert u3.dimensions == length * time\n    assert u4.dimensions == length ** 2 / time\n\n\ndef test_create_with_duplicate_dimensions():\n    \"\"\"\n    Create units with overlapping dimensions. Ex: km/Mpc.\n\n    \"\"\"\n\n    u1 = Unit(\"J * s**-1\")\n    u2 = Unit(\"km/s/Mpc\")\n    km_mks = m_per_km\n    Mpc_mks = m_per_mpc\n\n    assert u1.base_value == 1\n    assert u1.dimensions == power\n\n    assert_allclose_units(u2.base_value, km_mks / Mpc_mks, 1e-12)\n", "context": "unyt/exceptions.py\nclass InvalidUnitOperation(Exception):\n    \"\"\"Raised when an operation on a unit object is not allowed\n\n    Example\n    -------\n\n    >>> from unyt import cm, g\n    >>> cm + g  # doctest: +IGNORE_EXCEPTION_DETAIL +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    unyt.exceptions.InvalidUnitOperation: addition with unit objects\n    is not allowed\n    \"\"\"\n\n    pass\nunyt/_unit_lookup_table.py\ndef generate_name_alternatives():\n    def append_name(n, okey, key):\nunyt/testing.py\ndef assert_allclose_units(actual, desired, rtol=1e-7, atol=0, **kwargs):\n    \"\"\"Raise an error if two objects are not equal up to desired tolerance\n\n    This is a wrapper for :func:`numpy.testing.assert_allclose` that also\n    verifies unit consistency\n\n    Parameters\n    ----------\n    actual : array-like\n        Array obtained (possibly with attached units)\n    desired : array-like\n        Array to compare with (possibly with attached units)\n    rtol : float, optional\n        Relative tolerance, defaults to 1e-7\n    atol : float or quantity, optional\n        Absolute tolerance. If units are attached, they must be consistent\n        with the units of ``actual`` and ``desired``. If no units are attached,\n        assumes the same units as ``desired``. Defaults to zero.\n\n    See Also\n    --------\n    :func:`unyt.array.allclose_units`\n\n    Notes\n    -----\n    Also accepts additional keyword arguments accepted by\n    :func:`numpy.testing.assert_allclose`, see the documentation of that\n    function for details.\n\n    Examples\n    --------\n    >>> import unyt as u\n    >>> actual = [1e-5, 1e-3, 1e-1]*u.m\n    >>> desired = actual.to(\"cm\")\n    >>> assert_allclose_units(actual, desired)\n    \"\"\"\n    if not allclose_units(actual, desired, rtol, atol, **kwargs):\n        raise AssertionError\nunyt/exceptions.py\nclass UnitsNotReducible(Exception):\n    \"\"\"Raised when a unit cannot be safely represented in a unit system\n\n    Example\n    -------\n\n    >>> from unyt import A, cm\n    >>> data = 12*A/cm\n    >>> data.in_cgs()\\\n  # doctest: +IGNORE_EXCEPTION_DETAIL +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    unyt.exceptions.UnitsNotReducible: The unit \"A/cm\" (dimensions\n    \"(current_mks)/(length)\") cannot be reduced to an expression\n    within the cgs system of units.\n    \"\"\"\n\n    def __init__(self, unit, units_base):\n        self.unit = unit\n        self.units_base = units_base\n        Exception.__init__(self)\n\n    def __str__(self):\n        err = (\n            'The unit \"%s\" (dimensions \"%s\") cannot be reduced to an '\n            \"expression within the %s system of units.\"\n            % (self.unit, self.unit.dimensions, self.units_base)\n        )\n        return err\nunyt/array.py\nclass unyt_quantity(unyt_array):\n    \"\"\"\n    A scalar associated with a unit.\n\n    Parameters\n    ----------\n\n    input_scalar : an integer or floating point scalar\n        The scalar to attach units to\n    input_units : String unit specification, unit symbol object, or astropy\n                  units\n        The units of the quantity. Powers must be specified using python syntax\n        (cm**3, not cm^3).\n    registry : A UnitRegistry object\n        The registry to create units from. If input_units is already associated\n        with a unit registry and this is specified, this will be used instead\n        of the registry associated with the unit object.\n    dtype : data-type\n        The dtype of the array data.\n    name : string\n        The name of the scalar. Defaults to None. This attribute does not propagate\n        through mathematical operations, but is preserved under indexing\n        and unit conversions.\n\n    Examples\n    --------\n\n    >>> a = unyt_quantity(3., 'cm')\n    >>> b = unyt_quantity(2., 'm')\n    >>> print(a + b)\n    203.0 cm\n    >>> print(b + a)\n    2.03 m\n\n    NumPy ufuncs will pass through units where appropriate.\n\n    >>> import numpy as np\n    >>> from unyt import g, cm\n    >>> a = 12*g/cm**3\n    >>> print(np.abs(a))\n    12 g/cm**3\n\n    and strip them when it would be annoying to deal with them.\n\n    >>> print(np.log10(a))\n    1.0791812460476249\n\n    \"\"\"\n\n    def __new__(\n        cls,\n        input_scalar,\n        units=None,\n        registry=None,\n        dtype=None,\n        bypass_validation=False,\n        input_units=None,\n        name=None,\n    ):\n        if input_units is not None:\n            warnings.warn(\n                \"input_units has been deprecated, please use units instead\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if units is not None:\n            input_units = units\n        if not (\n            bypass_validation\n            or isinstance(input_scalar, (numeric_type, np.number, np.ndarray))\n        ):\n            raise RuntimeError(\"unyt_quantity values must be numeric\")\n        if input_units is None:\n            units = getattr(input_scalar, \"units\", None)\n        else:\n            units = input_units\n        ret = unyt_array.__new__(\n            cls,\n            np.asarray(input_scalar),\n            units,\n            registry,\n            dtype=dtype,\n            bypass_validation=bypass_validation,\n            name=name,\n        )\n        if ret.size > 1:\n            raise RuntimeError(\"unyt_quantity instances must be scalars\")\n        return ret\n\n    def __round__(self):\n        return type(self)(round(float(self)), self.units)\nunyt/unit_registry.py\nclass UnitRegistry:\n    \"\"\"A registry for unit symbols\"\"\"\n\n    _unit_system_id = None\n\n    def __init__(self, add_default_symbols=True, lut=None, unit_system=None):\n        self._unit_object_cache = {}\n        if lut:\n            self.lut = lut\n        else:\n            self.lut = {}\n\n        self.unit_system = _sanitize_unit_system(unit_system, None)\n\n        if add_default_symbols:\n            self.lut.update(default_unit_symbol_lut)\n\n    def __getitem__(self, key):\n        try:\n            ret = self.lut[str(key)]\n        except KeyError:\n            try:\n                _lookup_unit_symbol(str(key), self.lut)\n                ret = self.lut[str(key)]\n            except UnitParseError:\n                raise SymbolNotFoundError(\n                    \"The symbol '%s' does not exist in this registry.\" % key\n                )\n        return ret\n\n    def __contains__(self, item):\n        if str(item) in self.lut:\n            return True\n        try:\n            _lookup_unit_symbol(str(item), self.lut)\n            return True\n        except UnitParseError:\n            return False\n\n    @property\n    def unit_system_id(self):\n        \"\"\"\n        This is a unique identifier for the unit registry created\n        from a FNV hash. It is needed to register a dataset's code\n        unit system in the unit system registry.\n        \"\"\"\n        if self._unit_system_id is None:\n            hash_data = bytearray()\n            for k, v in sorted(self.lut.items()):\n                hash_data.extend(k.encode(\"utf8\"))\n                hash_data.extend(repr(v).encode(\"utf8\"))\n            m = md5()\n            m.update(hash_data)\n            self._unit_system_id = str(m.hexdigest())\n        return self._unit_system_id\n\n    @property\n    def prefixable_units(self):\n        return [u for u in self.lut if self.lut[u][4]]\n\n    def add(\n        self,\n        symbol,\n        base_value,\n        dimensions,\n        tex_repr=None,\n        offset=None,\n        prefixable=False,\n    ):\n        \"\"\"\n        Add a symbol to this registry.\n\n        Parameters\n        ----------\n\n        symbol : str\n           The name of the unit\n        base_value : float\n           The scaling from the units value to the equivalent SI unit\n           with the same dimensions\n        dimensions : expr\n           The dimensions of the unit\n        tex_repr : str, optional\n           The LaTeX representation of the unit. If not provided a LaTeX\n           representation is automatically generated from the name of\n           the unit.\n        offset : float, optional\n           If set, the zero-point offset to apply to the unit to convert\n           to SI. This is mostly used for units like Farhenheit and\n           Celcius that are not defined on an absolute scale.\n        prefixable : bool\n           If True, then SI-prefix versions of the unit will be created\n           along with the unit itself.\n\n        \"\"\"\n        from unyt.unit_object import _validate_dimensions\n\n        self._unit_system_id = None\n\n        # Validate\n        if not isinstance(base_value, float):\n            raise UnitParseError(\n                \"base_value (%s) must be a float, got a %s.\"\n                % (base_value, type(base_value))\n            )\n\n        if offset is not None:\n            if not isinstance(offset, float):\n                raise UnitParseError(\n                    \"offset value (%s) must be a float, got a %s.\"\n                    % (offset, type(offset))\n                )\n        else:\n            offset = 0.0\n\n        _validate_dimensions(dimensions)\n\n        if tex_repr is None:\n            # make educated guess that will look nice in most cases\n            tex_repr = r\"\\rm{\" + symbol.replace(\"_\", r\"\\ \") + \"}\"\n\n        # Add to lut\n        self.lut[symbol] = (base_value, dimensions, offset, tex_repr, prefixable)\n\n    def remove(self, symbol):\n        \"\"\"\n        Remove the entry for the unit matching `symbol`.\n\n        Parameters\n        ----------\n\n        symbol : str\n           The name of the unit symbol to remove from the registry.\n\n        \"\"\"\n        self._unit_system_id = None\n\n        if symbol not in self.lut:\n            raise SymbolNotFoundError(\n                \"Tried to remove the symbol '%s', but it does not exist \"\n                \"in this registry.\" % symbol\n            )\n\n        del self.lut[symbol]\n\n    def modify(self, symbol, base_value):\n        \"\"\"\n        Change the base value of a unit symbol.  Useful for adjusting code\n        units after parsing parameters.\n\n        Parameters\n        ----------\n\n        symbol : str\n           The name of the symbol to modify\n        base_value : float\n           The new base_value for the symbol.\n\n        \"\"\"\n        self._unit_system_id = None\n\n        if symbol not in self.lut:\n            raise SymbolNotFoundError(\n                \"Tried to modify the symbol '%s', but it does not exist \"\n                \"in this registry.\" % symbol\n            )\n\n        if hasattr(base_value, \"in_base\"):\n            new_dimensions = base_value.units.dimensions\n            base_value = base_value.in_base(\"mks\")\n            base_value = base_value.value\n        else:\n            new_dimensions = self.lut[symbol][1]\n\n        self.lut[symbol] = (float(base_value), new_dimensions) + self.lut[symbol][2:]\n\n    def keys(self):\n        \"\"\"\n        Print out the units contained in the lookup table.\n\n        \"\"\"\n        return self.lut.keys()\n\n    def to_json(self):\n        \"\"\"\n        Returns a json-serialized version of the unit registry\n        \"\"\"\n        sanitized_lut = {}\n        for k, v in self.lut.items():\n            san_v = list(v)\n            repr_dims = str(v[1])\n            san_v[1] = repr_dims\n            sanitized_lut[k] = tuple(san_v)\n\n        return json.dumps(sanitized_lut)\n\n    @classmethod\n    def from_json(cls, json_text):\n        \"\"\"\n        Returns a UnitRegistry object from a json-serialized unit registry\n\n        Parameters\n        ----------\n\n        json_text : str\n           A string containing a json represention of a UnitRegistry\n        \"\"\"\n        data = json.loads(json_text)\n        lut = _correct_old_unit_registry(data, sympify=True)\n        return cls(lut=lut, add_default_symbols=False)\n\n    def list_same_dimensions(self, unit_object):\n        \"\"\"\n        Return a list of base unit names that this registry knows about that\n        are of equivalent dimensions to *unit_object*.\n        \"\"\"\n        equiv = [k for k, v in self.lut.items() if v[1] is unit_object.dimensions]\n        equiv = list(sorted(set(equiv)))\n        return equiv\nunyt/dimensions.py\ndef accepts(**arg_units):\n    def check_accepts(f):\n        def new_f(*args, **kwargs):\ndef returns(r_unit):\n    def check_returns(f):\n        def new_f(*args, **kwargs):\ndef _has_dimensions(quant, dim):\nunyt/_physical_ratios.py\nHUGE = 1.0e90\nTINY = 1.0e-40\nunyt/unit_object.py\ndef _get_latex_representation(expr, registry):\n    def __init__(self):\n    def ua(self):\n    def uq(self):\n    def __new__(\n        cls,\n        unit_expr=sympy_one,\n        base_value=None,\n        base_offset=0.0,\n        dimensions=None,\n        registry=None,\n        latex_repr=None,\n    ):\n    def latex_repr(self):\n    def units(self):\n    def __hash__(self):\n    def __repr__(self):\n    def __str__(self):\n    def __add__(self, u):\n    def __radd__(self, u):\n    def __sub__(self, u):\n    def __rsub__(self, u):\n    def __iadd__(self, u):\n    def __isub__(self, u):\n    def __imul__(self, u):\n    def __itruediv__(self, u):\n    def __rmul__(self, u):\n    def __mul__(self, u):\n    def __truediv__(self, u):\n    def __rtruediv__(self, u):\n    def __pow__(self, p):\n    def __eq__(self, u):\n    def __ne__(self, u):\n    def copy(self):\n    def __deepcopy__(self, memodict=None):\n    def same_dimensions_as(self, other_unit):\n    def is_dimensionless(self):\n    def is_code_unit(self):\n    def list_equivalencies(self):\n    def has_equivalent(self, equiv):\n    def get_base_equivalent(self, unit_system=None):\n    def get_cgs_equivalent(self):\n    def get_mks_equivalent(self):\n    def get_conversion_factor(self, other_units, dtype=None):\n    def latex_representation(self):\n    def as_coeff_unit(self):\n    def simplify(self):\ndef _factor_pairs(expr):\ndef _create_unit_from_factor(factor, registry):\ndef _cancel_mul(expr, registry):\ndef _em_conversion(orig_units, conv_data, to_units=None, unit_system=None):\ndef _check_em_conversion(unit, to_unit=None, unit_system=None, registry=None):\ndef _get_conversion_factor(old_units, new_units, dtype):\ndef _get_unit_data_from_expr(unit_expr, unit_symbol_lut):\ndef _validate_dimensions(dimensions):\ndef define_unit(\n    symbol, value, tex_repr=None, offset=None, prefixable=False, registry=None\n):\nclass _ImportCache(object):\nclass Unit(object):\nNULL_UNIT = Unit()\nunyt/unit_systems.py\ndef add_symbols(namespace, registry):\ndef add_constants(namespace, registry):\ndef _split_prefix(symbol_str, unit_symbol_lut):\ndef _get_system_unit_string(dims, base_units):\n    def __init__(\n        self,\n        name,\n        length_unit,\n        mass_unit,\n        time_unit,\n        temperature_unit=\"K\",\n        angle_unit=\"rad\",\n        current_mks_unit=\"A\",\n        luminous_intensity_unit=\"cd\",\n        logarithmic_unit=\"Np\",\n        registry=None,\n    ):\n    def __getitem__(self, key):\n    def __setitem__(self, key, value):\n    def __str__(self):\n    def __repr__(self):\n    def has_current_mks(self):\nclass UnitSystem(object):\nunyt/exceptions.py\nclass UnitConversionError(Exception):\n    \"\"\"An error raised when converting to a unit with different dimensions.\n\n    Example\n    -------\n\n    >>> import unyt as u\n    >>> data = 3*u.g\n    >>> data.to('m')  # doctest: +IGNORE_EXCEPTION_DETAIL +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    unyt.exceptions.UnitConversionError: Cannot convert between 'g'\n    (dim '(mass)') and 'm' (dim '(length)').\n    \"\"\"\n\n    def __init__(self, unit1, dimension1, unit2, dimension2):\n        self.unit1 = unit1\n        self.unit2 = unit2\n        self.dimension1 = dimension1\n        self.dimension2 = dimension2\n        Exception.__init__(self)\n\n    def __str__(self):\n        err = \"Cannot convert between '%s' (dim '%s') and '%s' \" \"(dim '%s').\" % (\n            self.unit1,\n            self.dimension1,\n            self.unit2,\n            self.dimension2,\n        )\n        return err\n", "answers": ["    assert u2.dimensions == rate"], "length": 2042, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "803514a49c5cd69c77ec60f52cfd6829a0e8e58b1b40104e"}
{"input": "import sys\nimport msgfy\nimport subprocrunner as spr\n    import ujson as json\n    import json  # type: ignore\nfrom docker.errors import DockerException\nfrom simplesqlite import SimpleSQLite\nfrom simplesqlite.model import Integer, Model, Text\nfrom .__version__ import __version__\nfrom ._argparse_wrapper import ArgparseWrapper\nfrom ._common import check_command_installation, initialize_cli\nfrom ._const import Tc, TcCommandOutput\nfrom ._docker import DockerClient\nfrom ._error import TargetNotFoundError\nfrom ._logger import logger\nfrom ._network import verify_network_interface\nfrom ._tc_script import write_tc_script\nfrom .parser.shaping_rule import TcShapingRuleParser\n        from pygments import highlight\n        from pygments.formatters import TerminalTrueColorFormatter\n        from pygments.lexers import JsonLexer\n\n        pygments_installed = True\n    except ImportError:\n        pygments_installed = False\n\n    if is_colorize and pygments_installed:\n        print(\n            highlight(\n                code=text, lexer=JsonLexer(), formatter=TerminalTrueColorFormatter(style=\"monokai\")\n            )\n        )\n    else:\n        print(text)\n\n\ndef export_settings(export_path, out_rules, in_rules):\n    with SimpleSQLite(export_path, mode=\"a\") as con:\n        ShapingRuleModel.attach(con)\n        ShapingRuleModel.create()\n\n        for out_rule in out_rules:\n            ShapingRuleModel.insert(ShapingRuleModel(**out_rule))\n\n        for in_rule in in_rules:\n            ShapingRuleModel.insert(ShapingRuleModel(**in_rule))\n\n\ndef extract_tc_params(options):\n    dclient = None\n    if options.use_docker:\n        try:\n            dclient = DockerClient(options.tc_command_output)\n        except DockerException as e:\n            logger.error(msgfy.to_error_message(e))\n            sys.exit(1)\n\n    tc_params = {}\n\n    for device in options.device:\n        try:\n            if options.use_docker:\n                container = device\n                container_info = dclient.extract_container_info(container)\n\n                if not container_info.state.running:\n                    logger.error(\n                        \"{id} ({name}) not running (current status: {status})\".format(\n                            id=container,\n                            name=container_info.name,\n                            status=container_info.state.status,\n                        )\n                    )\n                    continue\n\n                dclient.create_veth_table(container)\n\n                for veth in dclient.fetch_veth_list(container_info.name):\n                    rule_parser = TcShapingRuleParser(\n                        device=veth,\n                        ip_version=options.ip_version,\n                        tc_command_output=options.tc_command_output,\n                        logger=logger,\n                        export_path=options.export_path,\n                        is_parse_filter_id=not options.exclude_filter_id,\n                        dump_db_path=options.dump_db_path,\n                    )\n                    rule_parser.parse()\n\n                    if options.export_path:\n                        rule_parser.con.dump(options.export_path)\n                        out_rules, in_rules = rule_parser.extract_export_parameters()\n                        export_settings(options.export_path, out_rules, in_rules)\n\n                    tc_params.update(rule_parser.get_tc_parameter())\n                    key = \"{id} (device={veth})\".format(id=container_info.id[:12], veth=veth)\n                    tc_params[key] = tc_params.pop(veth)\n            else:\n                verify_network_interface(device, options.tc_command_output)\n                rule_parser = TcShapingRuleParser(\n                    device=device,\n                    ip_version=options.ip_version,\n                    tc_command_output=options.tc_command_output,\n                    logger=logger,\n                    export_path=options.export_path,\n                    is_parse_filter_id=not options.exclude_filter_id,\n                    dump_db_path=options.dump_db_path,\n                )\n                rule_parser.parse()\n\n                if options.export_path:\n                    rule_parser.con.dump(options.export_path)\n                    out_rules, in_rules = rule_parser.extract_export_parameters()\n                    export_settings(options.export_path, out_rules, in_rules)\n\n                tc_params.update(rule_parser.get_tc_parameter())\n        except TargetNotFoundError as e:\n            logger.warning(e)\n            continue\n\n    return tc_params\n\n\ndef main():\n    options = parse_option()\n\n    initialize_cli(options)\n    check_command_installation(\"tc\")\n\n    if options.tc_command_output != TcCommandOutput.NOT_SET:\n        spr.SubprocessRunner.default_is_dry_run = True\n\n    tc_params = extract_tc_params(options)\n    command_history = \"\\n\".join(spr.SubprocessRunner.get_history())\n\n    if options.tc_command_output == TcCommandOutput.STDOUT:\n        print(command_history)\n        return 0\n\n    if options.tc_command_output == TcCommandOutput.SCRIPT:\n        write_tc_script(\n", "context": "tcconfig/_const.py\nclass TcCommandOutput:\n    NOT_SET = None\n    STDOUT = \"STDOUT\"\n    SCRIPT = \"SCRIPT\"\ntcconfig/parser/shaping_rule.py\nclass TcShapingRuleParser:\n    @property\n    def con(self):\n        return self.__con\n\n    @property\n    def device(self):\n        return self.__device\n\n    @property\n    def ifb_device(self):\n        return self.__ifb_device\n\n    def __init__(\n        self,\n        device,\n        ip_version,\n        logger,\n        tc_command_output,\n        export_path=None,\n        is_parse_filter_id=True,\n        dump_db_path=None,\n    ):\n        if dump_db_path is None:\n            self.__con = connect_memdb()\n        else:\n            self.__con = SimpleSQLite(dump_db_path, \"w\")\n\n        Filter.attach(self.__con)\n        Filter.create()\n\n        Qdisc.attach(self.__con)\n        Qdisc.create()\n\n        self.__device = device\n        self.__ip_version = ip_version\n        self.__tc_command_output = tc_command_output\n        self.__logger = logger\n        self.__export_path = export_path\n\n        self.clear()\n        self.__ifb_device = self.__get_ifb_from_device()\n\n        self.__iptables_ctrl = IptablesMangleController(True, ip_version)\n\n        self.is_parse_filter_id = is_parse_filter_id\n\n    def clear(self):\n        self.__filter_parser = TcFilterParser(self.__con, self.__ip_version)\n        self.__parsed_mappings = {}\n\n    def extract_export_parameters(self):\n        _, out_rules = self.__get_shaping_rule(self.device)\n        _, in_rules = self.__get_shaping_rule(self.ifb_device)\n\n        for out_rule in out_rules:\n            out_rule.update(\n                {Tc.Param.DEVICE: self.device, Tc.Param.DIRECTION: TrafficDirection.OUTGOING}\n            )\n\n        for in_rule in in_rules:\n            in_rule.update(\n                {Tc.Param.DEVICE: self.ifb_device, Tc.Param.DIRECTION: TrafficDirection.INCOMING}\n            )\n\n        return (out_rules, in_rules)\n\n    def get_tc_parameter(self):\n        out_rule_maps, _ = self.__get_shaping_rule(self.device)\n        in_rule_maps, _ = self.__get_shaping_rule(self.ifb_device)\n\n        return {\n            self.device: {\n                TrafficDirection.OUTGOING: out_rule_maps,\n                TrafficDirection.INCOMING: in_rule_maps,\n            }\n        }\n\n    def parse(self):\n        self.__parse_device(self.device)\n        self.__parse_device(self.ifb_device)\n\n    def __parse_device(self, device):\n        if not device:\n            return\n\n        if self.__parsed_mappings.get(device):\n            return\n\n        self.__parse_tc_class(device)\n        self.__parse_tc_filter(device)\n        self.__parse_tc_qdisc(device)\n\n        self.__parsed_mappings[device] = True\n\n    def __get_ifb_from_device(self):\n        if not is_execute_tc_command(self.__tc_command_output):\n            return None\n\n        filter_runner = subprocrunner.SubprocessRunner(\n            \"{:s} show dev {:s} root\".format(get_tc_base_command(TcSubCommand.FILTER), self.device),\n            error_log_level=\"QUIET\",\n            dry_run=False,\n        )\n        if filter_runner.run() != 0 and filter_runner.stderr.find(\"Cannot find device\") != -1:\n            raise NetworkInterfaceNotFoundError(target=self.device)\n\n        return self.__filter_parser.parse_incoming_device(filter_runner.stdout)\n\n    def __get_filter_key(self, filter_param):\n        key_items = OrderedDict()\n\n        if Tc.Param.HANDLE in filter_param:\n            handle = filter_param.get(Tc.Param.HANDLE)\n            typepy.Integer(handle).validate()\n            handle = int(handle)\n\n            for mangle in self.__iptables_ctrl.parse():\n                if mangle.mark_id != handle:\n                    continue\n\n                key_items[Tc.Param.DST_NETWORK] = mangle.destination\n                if typepy.is_not_null_string(mangle.source):\n                    key_items[Tc.Param.SRC_NETWORK] = mangle.source\n                key_items[Tc.Param.PROTOCOL] = mangle.protocol\n\n                break\n            else:\n                raise ValueError(\"mangle mark not found: {}\".format(mangle))\n        else:\n            src_network = filter_param.get(Tc.Param.SRC_NETWORK)\n            if typepy.is_not_null_string(src_network) and not is_anywhere_network(\n                src_network, self.__ip_version\n            ):\n                key_items[Tc.Param.SRC_NETWORK] = src_network\n\n            dst_network = filter_param.get(Tc.Param.DST_NETWORK)\n            if typepy.is_not_null_string(dst_network) and not is_anywhere_network(\n                dst_network, self.__ip_version\n            ):\n                key_items[Tc.Param.DST_NETWORK] = dst_network\n\n            src_port = filter_param.get(Tc.Param.SRC_PORT)\n            if typepy.Integer(src_port).is_type():\n                key_items[Tc.Param.SRC_PORT] = \"{}\".format(src_port)\n            elif src_port is not None:\n                self.__logger.warning(\n                    \"expected a integer value for {}, actual {}: {}\".format(\n                        Tc.Param.SRC_PORT, type(src_port), src_port\n                    )\n                )\n\n            dst_port = filter_param.get(Tc.Param.DST_PORT)\n            if typepy.Integer(dst_port).is_type():\n                key_items[Tc.Param.DST_PORT] = \"{}\".format(dst_port)\n            elif src_port is not None:\n                self.__logger.warning(\n                    \"expected a integer value for {}, actual {}\".format(\n                        Tc.Param.DST_PORT, type(dst_port)\n                    )\n                )\n\n            protocol = filter_param.get(Tc.Param.PROTOCOL)\n            if typepy.is_not_null_string(protocol):\n                key_items[Tc.Param.PROTOCOL] = protocol\n\n        key = \", \".join([\"{}={}\".format(key, value) for key, value in key_items.items()])\n\n        return key, key_items\n\n    def __get_shaping_rule(self, device):\n        if typepy.is_null_string(device):\n            return ({}, [])\n\n        self.__parse_device(device)\n        where_dev_query = Where(Tc.Param.DEVICE, device)\n\n        try:\n            class_params = self.__con.select_as_dict(\n                table_name=TcSubCommand.CLASS.value, where=where_dev_query\n            )\n        except TableNotFoundError:\n            class_params = []\n\n        try:\n            filter_params = Filter.select(where=where_dev_query)\n        except TableNotFoundError:\n            filter_params = []\n\n        shaping_rule_mapping = {}\n        shaping_rules = []\n\n        for filter_param in filter_params:\n            filter_param = filter_param.as_dict()\n            self.__logger.debug(\"{:s} param: {}\".format(TcSubCommand.FILTER, filter_param))\n            shaping_rule = {}\n\n            filter_key, rule_with_keys = self.__get_filter_key(filter_param)\n            if typepy.is_null_string(filter_key):\n                self.__logger.debug(\"empty filter key: {}\".format(filter_param))\n                continue\n\n            qdisc_id = filter_param.get(Tc.Param.FLOW_ID)\n            if qdisc_id is None:\n                qdisc_id = filter_param.get(Tc.Param.CLASS_ID)\n\n            try:\n                qdisc_params = Qdisc.select(\n                    where=And([where_dev_query, Where(Tc.Param.PARENT, qdisc_id)])\n                )\n            except TableNotFoundError:\n                qdisc_params = []\n\n            for qdisc_param in qdisc_params:\n                qdisc_param = qdisc_param.as_dict()\n                self.__logger.debug(\"{:s} param: {}\".format(TcSubCommand.QDISC, qdisc_param))\n\n                if self.is_parse_filter_id:\n                    shaping_rule[Tc.Param.FILTER_ID] = filter_param.get(Tc.Param.FILTER_ID)\n\n                # shaping_rule[Tc.Param.PRIORITY] = filter_param.get(\n                #    Tc.Param.PRIORITY)\n\n                shaping_rule.update(\n                    self.__strip_param(\n                        qdisc_param,\n                        [Tc.Param.DEVICE, Tc.Param.PARENT, Tc.Param.HANDLE, \"direct_qlen\"],\n                    )\n                )\n\n            for class_param in class_params:\n                self.__logger.debug(\"{:s} param: {}\".format(TcSubCommand.CLASS, class_param))\n\n                if class_param.get(Tc.Param.CLASS_ID) not in (\n                    filter_param.get(Tc.Param.FLOW_ID),\n                    filter_param.get(Tc.Param.CLASS_ID),\n                ):\n                    continue\n\n                if self.is_parse_filter_id:\n                    shaping_rule[Tc.Param.FILTER_ID] = filter_param.get(Tc.Param.FILTER_ID)\n\n                # shaping_rule[Tc.Param.PRIORITY] = filter_param.get(\n                #    Tc.Param.PRIORITY)\n\n                shaping_rule.update(\n                    self.__strip_param(class_param, [Tc.Param.DEVICE, Tc.Param.CLASS_ID])\n                )\n\n            if not shaping_rule:\n                self.__logger.debug(\"shaping rule not found for '{}'\".format(filter_param))\n                continue\n\n            self.__logger.debug(\"shaping rule found: {} {}\".format(filter_key, shaping_rule))\n\n            rule_with_keys.update(shaping_rule)\n            shaping_rules.append(rule_with_keys)\n\n            shaping_rule_mapping[filter_key] = shaping_rule\n\n        return (shaping_rule_mapping, shaping_rules)\n\n    def __parse_tc_qdisc(self, device):\n        TcQdiscParser(self.__con).parse(\n            device, run_tc_show(TcSubCommand.QDISC, device, self.__tc_command_output)\n        )\n\n    def __parse_tc_filter(self, device):\n        self.__filter_parser.parse(\n            device, run_tc_show(TcSubCommand.FILTER, device, self.__tc_command_output)\n        )\n\n    def __parse_tc_class(self, device):\n        TcClassParser(self.__con).parse(\n            device, run_tc_show(TcSubCommand.CLASS, device, self.__tc_command_output)\n        )\n\n    @staticmethod\n    def __strip_param(params, strip_params):\n        work_params = copy.deepcopy(params)\n\n        for strip_param in strip_params:\n            try:\n                del work_params[strip_param]\n            except KeyError:\n                pass\n\n        return {key: value for key, value in work_params.items() if value is not None}\ntcconfig/_network.py\ndef verify_network_interface(device, tc_command_output):\n    from ._common import is_execute_tc_command\n\n    if not is_execute_tc_command(tc_command_output):\n        return\n\n    with IPRoute() as ipr:\n        avail_interfaces = [link.get_attr(\"IFLA_IFNAME\") for link in ipr.get_links()]\n\n    if device not in avail_interfaces:\n        raise NetworkInterfaceNotFoundError(target=device)\ntcconfig/_error.py\nclass TargetNotFoundError(Exception):\n    @abc.abstractproperty\n    def _target_type(self):\n        return None\n\n    def __init__(self, *args, **kwargs):\n        self._target = kwargs.pop(\"target\", None)\n\n        super().__init__(*args, **kwargs)\n\n    def __str__(self, *args, **kwargs):\n        item_list = [Exception.__str__(self, *args, **kwargs)]\n\n        if self._target:\n            item_list.append(\"{} not found: {}\".format(self._target_type, self._target))\n\n        return \" \".join(item_list).strip()\n\n    def __repr__(self, *args, **kwargs):\n        return self.__str__(*args, **kwargs)\ntcconfig/_argparse_wrapper.py\nclass ArgparseWrapper:\n    \"\"\"\n    Wrapper class for argparse\n    \"\"\"\n\n    def __init__(self, version, description=\"\"):\n        self.parser = argparse.ArgumentParser(\n            formatter_class=argparse.RawDescriptionHelpFormatter,\n            description=description,\n            epilog=dedent(\n                \"\"\"\\\n                Documentation: https://tcconfig.rtfd.io/\n                Issue tracker: https://github.com/thombashi/tcconfig/issues\n                \"\"\"\n            ),\n        )\n        self.parser.add_argument(\n            \"-V\", \"--version\", action=\"version\", version=\"%(prog)s {}\".format(version)\n        )\n        self._add_tc_command_arg_group()\n        self._add_log_level_argument_group()\n\n        group = self.parser.add_argument_group(\"Debug\")\n        group.add_argument(\n            \"--debug-query\", action=\"store_true\", default=False, help=\"for debug print.\"\n        )\n        group.add_argument(\n            \"--stacktrace\",\n            dest=\"is_output_stacktrace\",\n            action=\"store_true\",\n            default=False,\n            help=\"\"\"print stack trace for debug information.\n            --debug option required to see the debug print.\n            \"\"\",\n        )\n\n    def add_routing_group(self):\n        group = self.parser.add_argument_group(\"Routing\")\n        group.add_argument(\n            \"--direction\",\n            choices=TrafficDirection.LIST,\n            default=TrafficDirection.OUTGOING,\n            help=\"\"\"the direction of network communication that imposes traffic control.\n            'incoming' requires ifb kernel module and Linux kernel 2.6.20 or later.\n            (default = %(default)s)\n            \"\"\",\n        )\n        group.add_argument(\n            \"--network\",\n            \"--dst-network\",\n            dest=\"dst_network\",\n            help=\"\"\"specify destination IP-address/network that applies traffic control.\n            defaults to any.\"\"\",\n        )\n        group.add_argument(\n            \"--src-network\",\n            help=\"\"\"specify source IP-address/network that applies traffic control.\n            defaults to any.\n            this option has no effect when executing with \"--direction incoming\" option.\n            note: this option required to execute with the --iptables option when using tbf\n            algorithm.\n            \"\"\",\n        )\n        group.add_argument(\n            \"--port\",\n            \"--dst-port\",\n            dest=\"dst_port\",\n            type=int,\n            help=\"specify destination port number that applies traffic control. defaults to any.\",\n        )\n        group.add_argument(\n            \"--src-port\",\n            type=int,\n            help=\"specify source port number that applies traffic control. defaults to any.\",\n        )\n        group.add_argument(\n            \"--ipv6\",\n            dest=\"is_ipv6\",\n            action=\"store_true\",\n            default=False,\n            help=\"apply traffic control to IPv6 packets rather than IPv4.\",\n        )\n\n        return group\n\n    def _add_log_level_argument_group(self):\n        dest = \"log_level\"\n\n        group = self.parser.add_mutually_exclusive_group()\n        group.add_argument(\n            \"--debug\",\n            dest=dest,\n            action=\"store_const\",\n            const=\"DEBUG\",\n            default=\"INFO\",\n            help=\"for debug print.\",\n        )\n        group.add_argument(\n            \"--quiet\",\n            dest=dest,\n            action=\"store_const\",\n            const=\"QUIET\",\n            default=\"INFO\",\n            help=\"suppress execution log messages.\",\n        )\n\n        return group\n\n    def add_docker_group(self, is_add_srcdst=True):\n        group = self.parser.add_argument_group(\"Docker\")\n        group.add_argument(\n            \"--docker\",\n            dest=\"use_docker\",\n            action=\"store_true\",\n            default=False,\n            help=\"\"\"\n            apply traffic control to a docker container.\n            to use this option, you will need to specify a container id as 'device' as follows:\n\n                tcset --container <container id>\n            \"\"\",\n        )\n        if is_add_srcdst:\n            group.add_argument(\"--src-container\", help=\"specify source container id or name.\")\n            group.add_argument(\"--dst-container\", help=\"specify destination container id or name.\")\n\n        return group\n\n    def _add_tc_command_arg_group(self):\n        group = self.parser.add_mutually_exclusive_group()\n        group.add_argument(\n            \"--tc-command\",\n            dest=\"tc_command_output\",\n            action=\"store_const\",\n            const=TcCommandOutput.STDOUT,\n            default=TcCommandOutput.NOT_SET,\n            help=\"\"\"\n            display tc commands to be executed and exit.\n            these commands are not actually executed.\n            \"\"\",\n        )\n\n        group.add_argument(\n            \"--tc-script\",\n            dest=\"tc_command_output\",\n            action=\"store_const\",\n            const=TcCommandOutput.SCRIPT,\n            default=TcCommandOutput.NOT_SET,\n            help=\"\"\"\n            generate a shell script file that described tc commands.\n            this tc script execution result nearly equivalent with the tcconfig command.\n            the script can be executed without tcconfig package installation.\n            \"\"\",\n        )\ntcconfig/_docker.py\nclass DockerClient:\n    @property\n    def __netns_root_path(self):\n        return Path(\"/var/run/netns\")\n\n    def __init__(self, tc_command_output=TcCommandOutput.NOT_SET):\n        self.__client = APIClient(version=\"auto\")\n        self.__host_name = os.uname()[1]\n        self.__tc_command_output = tc_command_output\n\n        self.__con = connect_memdb()\n        IfIndex.attach(self.__con)\n\n    def exist_container(self, container):\n        try:\n            self.__verify_container(container)\n            return True\n        except ContainerNotFoundError:\n            return False\n\n    def verify_container(self, container, exit_on_exception=False):\n        if not is_execute_tc_command(self.__tc_command_output):\n            return\n\n        try:\n            self.__verify_container(container)\n        except ContainerNotFoundError as e:\n            if exit_on_exception:\n                logger.error(msgfy.to_error_message(e))\n                sys.exit(errno.EPERM)\n\n            raise\n\n    def extract_running_container_names(self):\n        running_container_name_list = []\n\n        for container in self.__get_containers():\n            if container.get(\"State\") != \"running\":\n                continue\n\n            running_container_name_list.append(container[\"Names\"][0].lstrip(\"/\"))\n\n        return running_container_name_list\n\n    def extract_container_info(self, container):\n        try:\n            container_map = self.__client.inspect_container(container=container)\n        except APIError as e:\n            logger.error(e)\n            sys.exit(1)\n\n        container_name = container_map[\"Name\"].lstrip(\"/\")\n        container_state = container_map[\"State\"]\n        container_info = ContainerInfo(\n            id=container_map[\"Id\"],\n            name=container_name,\n            pid=int(container_state[\"Pid\"]),\n            ipaddr=container_map[\"NetworkSettings\"][\"IPAddress\"],\n            image=container_map[\"Config\"][\"Image\"],\n            state=namedtuple(\"ContainerState\", (k.lower() for k in container_state.keys()))(\n                *container_state.values()\n            ),\n        )\n\n        return container_info\n\n    def create_veth_table(self, container):\n        try:\n            self.__netns_root_path.makedirs_p()\n        except PermissionError as e:\n            logger.error(e)\n            sys.exit(errno.EPERM)\n\n        container_info = self.extract_container_info(container)\n        logger.debug(\n            \"found container: name={}, pid={}\".format(container_info.name, container_info.pid)\n        )\n\n        try:\n            netns_path = self.__get_netns_path(container_info.name)\n\n            if not os.path.lexists(netns_path):\n                logger.debug(\"make symlink to {}\".format(netns_path))\n\n                try:\n                    Path(\"/proc/{:d}/ns/net\".format(container_info.pid)).symlink(netns_path)\n                except PermissionError as e:\n                    logger.error(e)\n                    sys.exit(errno.EPERM)\n\n            return_code = self.__create_ifindex_table(container_info.name)\n            if return_code != 0:\n                sys.exit(return_code)\n\n            return return_code\n        finally:\n            netns_path.remove_p()\n\n    def select_veth(self, container_name):\n        for container_record in IfIndex.select(where=Where(\"host\", container_name)):\n            yield from IfIndex.select(\n                where=And(\n                    [\n                        Where(\"host\", self.__host_name),\n                        Where(\"ifindex\", container_record.peer_ifindex),\n                    ]\n                )\n            )\n\n    def fetch_veth_list(self, container_name):\n        return [veth_record.ifname for veth_record in self.select_veth(container_name)]\n\n    def __verify_container(self, container):\n        if len(self.__get_containers()) == 0:\n            raise ContainerNotFoundError()\n\n        try:\n            self.__client.inspect_container(container=container)\n        except NotFound:\n            raise ContainerNotFoundError(target=container)\n        except APIError as e:\n            logger.error(e)\n            sys.exit(1)\n\n    def __get_containers(self):\n        try:\n            return self.__client.containers()\n        except APIError as e:\n            logger.error(e)\n            sys.exit(1)\n\n    def __get_netns_path(self, container_name):\n        return self.__netns_root_path / container_name\n\n    def __create_ifindex_table(self, container_name):\n        netns_path = self.__get_netns_path(container_name)\n\n        try:\n            netns_path.stat()\n        except PermissionError as e:\n            logger.error(e)\n            return errno.EPERM\n\n        IfIndex.create()\n\n        proc = SubprocessRunner(\n            \"ip netns exec {ns} ip link show type veth\".format(ns=container_name), dry_run=False\n        )\n        if proc.run() != 0:\n            logger.error(proc.stderr)\n            return proc.returncode\n\n        veth_groups_regexp = re.compile(\"([0-9]+): ([a-z0-9]+)@([a-z0-9]+): \")\n        peer_ifindex_prefix_regexp = re.compile(\"^if\")\n\n        try:\n            for i, line in enumerate(proc.stdout.splitlines()):\n                match = veth_groups_regexp.search(line)\n                if not match:\n                    continue\n\n                logger.debug(\"parse veth @{} [{:02d}] {}\".format(container_name, i, line))\n                ifindex, ifname, peer_ifindex = match.groups()\n                IfIndex.insert(\n                    IfIndex(\n                        host=container_name,\n                        ifindex=int(ifindex),\n                        ifname=ifname,\n                        peer_ifindex=int(peer_ifindex_prefix_regexp.sub(\"\", peer_ifindex)),\n                    )\n                )\n\n            proc = SubprocessRunner(\"ip link show type veth\", dry_run=False)\n            if proc.run() != 0:\n                logger.error(proc.stderr)\n                return proc.returncode\n\n            for line in proc.stdout.splitlines():\n                logger.debug(\"parse veth @docker-host [{:02d}] {}\".format(i, line))\n                match = veth_groups_regexp.search(line)\n                if not match:\n                    continue\n\n                ifindex, ifname, peer_ifindex = match.groups()\n                try:\n                    IfIndex.insert(\n                        IfIndex(\n                            host=self.__host_name,\n                            ifindex=int(ifindex),\n                            ifname=ifname,\n                            peer_ifindex=int(peer_ifindex_prefix_regexp.sub(\"\", peer_ifindex)),\n                        )\n                    )\n                except OperationalError as e:\n                    logger.error(msgfy.to_error_message(e))\n        finally:\n            IfIndex.commit()\n\n            try:\n                netns_path.remove_p()\n            except PermissionError as e:\n                logger.error(msgfy.to_error_message(e))\n                return errno.EPERM\n\n        return 0\ntcconfig/_logger.py\nMODULE_NAME = \"tcconfig\"\ndef set_logger(is_enable):\ndef set_log_level(log_level):\ntcconfig/_const.py\nclass Tc:\n    class Command:\n        TCSET = \"tcset\"\n        TCDEL = \"tcdel\"\n        TCSHOW = \"tcshow\"\n\n    class Param:\n        DEVICE = \"device\"\n        DIRECTION = \"direction\"\n        FILTER_ID = \"filter_id\"\n        CLASS_ID = \"classid\"\n        DST_NETWORK = \"dst-network\"\n        DST_PORT = \"dst-port\"\n        FLOW_ID = \"flowid\"\n        HANDLE = \"handle\"\n        PARENT = \"parent\"\n        PRIORITY = \"priority\"\n        PROTOCOL = \"protocol\"\n        SRC_NETWORK = \"src-network\"\n        SRC_PORT = \"src-port\"\n\n    class ValueRange:\n        class LatencyTime:\n            MIN = \"0ms\"\n            MAX = \"60min\"\n\n    class Min:\n        LATENCY_TIME = \"0ms\"\n\n    class Max:\n        LATENCY_TIME = \"60min\"\ntcconfig/_common.py\ndef check_command_installation(command):\n    if find_bin_path(command):\n        return\n\n    logger.error(\"command not found: {}\".format(command))\n    sys.exit(errno.ENOENT)\ntcconfig/__version__.py\n\ntcconfig/_common.py\ndef initialize_cli(options):\n    set_log_level(options.log_level)\n\n    spr.SubprocessRunner.is_save_history = True\n\n    if options.is_output_stacktrace:\n        spr.SubprocessRunner.is_output_stacktrace = options.is_output_stacktrace\n\n    SimpleSQLite.global_debug_query = options.debug_query\ntcconfig/_tc_script.py\ndef write_tc_script(tcconfig_command, command_history, filename_suffix=None):\n    filename_item_list = [tcconfig_command]\n    if typepy.is_not_null_string(filename_suffix):\n        filename_item_list.append(filename_suffix)\n\n    script_line_list = [\"#!/bin/sh\", \"\"]\n\n    org_tcconfig_cmd = _get_original_tcconfig_command(tcconfig_command)\n\n    if tcconfig_command != Tc.Command.TCSHOW:\n        script_line_list.extend(\n            [\n                \"# command sequence in this script attempt to simulate the following \"\n                \"tcconfig command:\",\n                \"#\",\n                \"#   {:s}\".format(org_tcconfig_cmd),\n            ]\n        )\n\n    script_line_list.extend(\n        [\n            \"#\",\n            \"# the script execution result may different from '{}'\".format(org_tcconfig_cmd),\n            \"#\",\n            \"# created by {:s} on {:s}.\".format(\n                tcconfig_command, datetime.datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S%z\")\n            ),\n            \"\",\n            command_history,\n        ]\n    )\n\n    filename = \"_\".join(filename_item_list) + \".sh\"\n    with open(filename, \"w\", encoding=\"utf8\") as fp:\n        fp.write(\"\\n\".join(script_line_list) + \"\\n\")\n\n    os.chmod(filename, 0o755)\n    logger.info(\"written a tc script to '{:s}'\".format(filename))\n", "answers": ["            Tc.Command.TCSHOW, command_history, filename_suffix=\"-\".join(options.device)"], "length": 1874, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "12e8bbb259d78efa8de3bcd57ceb0b4d255e0b3f6d93d68c"}
{"input": "import com.github.felixgail.gplaymusic.api.GPlayMusic;\nimport com.github.felixgail.gplaymusic.api.TrackApi;\nimport com.github.felixgail.gplaymusic.exceptions.NetworkException;\nimport com.github.felixgail.gplaymusic.model.enums.Provider;\nimport com.github.felixgail.gplaymusic.model.enums.ResultType;\nimport com.github.felixgail.gplaymusic.model.enums.StreamQuality;\nimport com.github.felixgail.gplaymusic.model.enums.SubscriptionType;\nimport com.github.felixgail.gplaymusic.model.requests.IncrementPlaycountRequest;\nimport com.github.felixgail.gplaymusic.model.responses.Result;\nimport com.github.felixgail.gplaymusic.model.snippets.ArtRef;\nimport com.github.felixgail.gplaymusic.util.language.Language;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.annotations.Expose;\nimport com.google.gson.annotations.SerializedName;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.OptionalInt;\n\n  public Optional<String> getStoreId() {\n    return Optional.ofNullable(storeId);\n  }\n\n  public String getAlbumId() {\n    return albumId;\n  }\n\n  public Optional<List<String>> getArtistId() {\n    return Optional.ofNullable(artistId);\n  }\n\n  public Optional<String> getNid() {\n    return Optional.ofNullable(nid);\n  }\n\n  public boolean isTrackAvailableForSubscription() {\n    return trackAvailableForSubscription;\n  }\n\n\n  public boolean isTrackAvailableForPurchase() {\n    return trackAvailableForPurchase;\n  }\n\n  public boolean isAlbumAvailableForPurchase() {\n    return albumAvailableForPurchase;\n  }\n\n  public Optional<String> getExplicitType() {\n    return Optional.ofNullable(explicitType);\n  }\n\n  public String getWentryID() {\n    return wentryID;\n  }\n\n  public OptionalInt getTotalTrackCount() {\n    return OptionalInt.of(totalTrackCount);\n  }\n\n  public OptionalInt getTotalDiscCount() {\n    return OptionalInt.of(totalDiscCount);\n  }\n\n  public Optional<String> getLastRatingChangeTimestamp() {\n    return Optional.ofNullable(lastRatingChangeTimestamp);\n  }\n\n  public Optional<String> getLastModifiedTimestamp() {\n    return Optional.ofNullable(lastModifiedTimestamp);\n  }\n\n  public Optional<String> getContentType() {\n    return Optional.ofNullable(contentType);\n  }\n\n  public Optional<String> getCreationTimestamp() {\n    return Optional.ofNullable(creationTimestamp);\n  }\n\n  public Optional<String> getRecentTimestamp() {\n    return Optional.ofNullable(recentTimestamp);\n  }\n\n  public Optional<String> getUuid() {\n    return Optional.ofNullable(uuid);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    return (o instanceof Track) && ((Track) o).getID().equals(this.getID());\n  }\n\n  @Override\n  public Signature getSignature() {\n    return super.createSignature(this.getID());\n  }\n\n  @Override\n  public ResultType getResultType() {\n    return RESULT_TYPE;\n  }\n\n  /**\n   * Returns a URL to download the song in set quality. URL will only be valid for 1 minute. You\n   * will likely need to handle redirects. <br> <b>Please note that this function is available for\n   * Subscribers only. On free accounts use {@link #getStationTrackURL(StreamQuality)}.</b>\n   *\n   * @param quality quality of the stream\n   * @return temporary url to the title\n   * @throws IOException Throws an IOException on severe failures (no internet connection...) or a\n   * {@link NetworkException} on request failures.\n   */\n  @Override\n  public URL getStreamURL(StreamQuality quality)\n      throws IOException {\n    if (!easyDownloadPossible()) {\n      getStationTrackURL(quality);\n    }\n    return urlFetcher(mainApi, quality, Provider.STREAM, EMPTY_MAP);\n  }\n\n  /**\n   * Fetch the URL for a track from a free Station. Make sure this Track was returned by a {@link\n   * Station}. Otherwise an {@link IOException} will be thrown. <br> <b>Subscribers will be\n   * redirected to {@link #getStreamURL(StreamQuality)}</b>\n   *\n   * @param quality - quality of the stream\n   * @return a url to download songs from.\n   * @throws IOException on severe failures (no internet connection...) or a {@link\n   * NetworkException} on request failures.\n   */\n  public URL getStationTrackURL(StreamQuality quality)\n      throws IOException {\n    if (mainApi.getConfig().getSubscription() == SubscriptionType.ALL_ACCESS) {\n      return getStreamURL(quality);\n    }\n    if (getWentryID() == null || getWentryID().isEmpty()) {", "context": "src/main/java/com/github/felixgail/gplaymusic/model/requests/IncrementPlaycountRequest.java\npublic class IncrementPlaycountRequest implements Serializable {\n\n  @Expose\n  @SerializedName(\"track_stats\")\n  private List<Inner> trackStats;\n\n  public IncrementPlaycountRequest(int playCount, @NotNull Track track) {\n    this.trackStats = Collections.singletonList(new Inner(playCount, track));\n  }\n\n  private class Inner {\n\n    @Expose\n    private String id;\n    @Expose\n    @SerializedName(\"incremental_plays\")\n    private int plays;\n    @Expose\n    @SerializedName(\"last_play_time_millis\")\n    private String lastPlayedMillis;\n    @Expose\n    private int type;\n    @Expose\n    @SerializedName(\"track_events\")\n    private List<Event> events;\n\n    Inner(int playCount, @NotNull Track track) {\n      long timeStampMillis = System.currentTimeMillis();\n\n      this.id = track.getID();\n      this.plays = playCount;\n      this.lastPlayedMillis = String.valueOf(timeStampMillis);\n      this.type = track.getID().startsWith(\"T\") ? 2 : 1;\n\n      events = new LinkedList<>();\n      String timestampMicros = String.valueOf(timeStampMillis * 1000);\n      for (int i = 0; i < playCount; i++) {\n        events.add(new Event(timestampMicros));\n      }\n    }\n  }\n\n  private class Event {\n\n    @Expose\n    @SerializedName(\"context_type\")\n    private int contextType = 1;\n    @Expose\n    @SerializedName(\"event_timestamp_micros\")\n    private String timestamp;\n    @Expose\n    @SerializedName(\"event_type\")\n    private int eventType = 2;\n\n    Event(String timestampMicros) {\n      this.timestamp = timestampMicros;\n    }\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/enums/ResultType.java\npublic enum ResultType implements Serializable {\n  @SerializedName(\"1\")\n  TRACK(1, \"track\", Track.class),\n  @SerializedName(\"2\")\n  ARTIST(2, \"artist\", Artist.class),\n  @SerializedName(\"3\")\n  ALBUM(3, \"album\", Album.class),\n  @SerializedName(\"4\")\n  PLAYLIST(4, \"playlist\", Playlist.class),\n  @SerializedName(\"6\")\n  STATION(6, \"station\", Station.class),\n  @SerializedName(\"7\")\n  SITUATION(7, \"situation\", Situation.class),\n  @SerializedName(\"8\")\n  VIDEO(8, \"youtube_video\", Video.class),\n  @SerializedName(\"9\")\n  PODCAST_SERIES(9, \"podcast\", PodcastSeries.class); //Not tested, needs US vpn\n\n  private final int value;\n  private final String name;\n  private final Type type;\n\n  ResultType(final int value, final String name, final Type type) {\n    this.value = value;\n    this.name = name;\n    this.type = type;\n  }\n\n  public int getValue() {\n    return value;\n  }\n\n  public Type getType() {\n    return type;\n  }\n\n  public String getName() {\n    return name;\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/enums/SubscriptionType.java\npublic enum SubscriptionType implements Serializable {\n  @SerializedName(\"aa\")\n  ALL_ACCESS(\"aa\"),\n  @SerializedName(\"fr\")\n  FREE(\"fr\");\n\n  private String value;\n\n  SubscriptionType(String v) {\n    this.value = v;\n  }\n\n  public String getValue() {\n    return this.value;\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/api/GPlayMusic.java\npublic final class GPlayMusic {\n\n  private GPlayService service;\n  private Config config;\n  private RequestInterceptor interceptor;\n  private GenreApi genreApi;\n  private PlaylistApi playlistApi;\n  private PlaylistEntryApi playlistEntryApi;\n  private StationApi stationApi;\n  private TrackApi trackApi;\n\n  private GPlayMusic(GPlayService service, RequestInterceptor interceptor) {\n    this.service = service;\n    this.interceptor = interceptor;\n    this.genreApi = new GenreApi(this);\n    this.playlistEntryApi = new PlaylistEntryApi(this);\n    this.playlistApi = new PlaylistApi(this, playlistEntryApi);\n    this.stationApi = new StationApi(this);\n    this.trackApi = new TrackApi(this);\n  }\n\n  public Config getConfig() {\n    return config;\n  }\n\n  private void setConfig(Config config) {\n    this.config = config;\n  }\n\n  public Album getAlbum(String albumID, boolean includeTracks) throws IOException {\n    return getService().getAlbum(albumID, includeTracks).execute().body();\n  }\n\n  /**\n   * Fetches for an artist by {@code artistID}.\n   *\n   * @param artistID {@link Artist#getArtistId()} of the artist searched for.\n   * @param includeAlbums whether albums of the artist shall be included in the response.\n   * @param numTopTracks response includes up to provided number of most heard songs in response\n   * @param numRelArtist response includes up to provided number of similar artist in response\n   * @return An executable call which returns an artist on execution.\n   */\n  public Artist getArtist(String artistID, boolean includeAlbums, int numTopTracks,\n      int numRelArtist)\n      throws IOException {\n    return getService().getArtist(artistID, includeAlbums, numTopTracks, numRelArtist)\n        .execute().body();\n  }\n\n  /**\n   * This method will return the service used to make calls to google play, and therefore allows for\n   * low level and asynchronous calls. Be sure to check the response for error codes.\n   *\n   * @return {@link GPlayService} instance used by the current API.\n   */\n  public GPlayService getService() {\n    return this.service;\n  }\n\n  /**\n   * Queries Google Play Music for content. Content can be every combination of {@link SearchTypes}\n   * enum.\n   *\n   * @param query Query String\n   * @param maxResults Limits the results. Keep in mind that higher numbers increase loading time.\n   * @param types Content types that should be queried for\n   * @return A SearchResponse instance holding all content returned\n   * @throws IOException Throws an IOException on severe failures (no internet connection...) or a\n   * {@link NetworkException} on request failures.\n   */\n  public SearchResponse search(String query, int maxResults, SearchTypes types)\n      throws IOException {\n    return getService().search(query, maxResults, types).execute().body();\n  }\n\n  /**\n   * Provides convenience by wrapping the {@link #search(String, int, SearchTypes)} method and\n   * setting the maxResults parameter to 50.\n   */\n  public SearchResponse search(String query, SearchTypes types)\n      throws IOException {\n    return search(query, 50, types);\n  }\n\n  /**\n   * Fetches a list of all devices connected with the current google play account.\n   *\n   * @return A DeviceList instance containing all devices connected to the current Google Play\n   * account.\n   * @throws IOException Throws an IOException on severe failures (no internet connection...) or a\n   * {@link NetworkException} on request failures.\n   */\n  public ListResult<DeviceInfo> getRegisteredDevices()\n      throws IOException {\n    return getService().getDevices().execute().body();\n  }\n\n  /**\n   * Returns a list of promoted {@link Track}s. Which tracks are in the returned list is determined\n   * by google\n   *\n   * @throws IOException on severe failures (no internet connection...) or a {@link\n   * NetworkException} on request failures.\n   */\n  public List<Track> getPromotedTracks()\n      throws IOException {\n    return getService().getPromotedTracks().execute().body().toList();\n    //TODO: set api\n  }\n\n  public List<PodcastSeries> listPodcastSeries(Genre genre)\n      throws IOException {\n    return service.listBrowsePodcastSeries(genre.getId()).execute().body().toList();\n  }\n\n  /**\n   * Returns a selection of {@link ListenNowItem}s consisting of {@link ListenNowStation} and {@link\n   * com.github.felixgail.gplaymusic.model.listennow.ListenNowAlbum}.\n   */\n  public List<ListenNowItem> listListenNowItems() throws IOException {\n    return service.listListenNowItems().execute().body().getListenNowItems();\n  }\n\n  /**\n   * Returns the current {@link ListenNowStation} for your timezone.\n   */\n  public ListenNowSituation getListenNowSituation() throws IOException {\n    return service.getListenNowSituation(new TimeZoneOffset()).execute().body();\n  }\n\n  /**\n   * Returns the current {@link ListenNowStation} with a set offset.\n   *\n   * @param offsetInSeconds the offset in seconds to UTC.\n   */\n  public ListenNowSituation getListenNowSituation(int offsetInSeconds) throws IOException {\n    return service.getListenNowSituation(new TimeZoneOffset(String.valueOf(offsetInSeconds)))\n        .execute().body();\n  }\n\n  public GenreApi getGenreApi() {\n    return genreApi;\n  }\n\n  public PlaylistApi getPlaylistApi() {\n    return playlistApi;\n  }\n\n  public PlaylistEntryApi getPlaylistEntryApi() {\n    return playlistEntryApi;\n  }\n\n  public StationApi getStationApi() {\n    return stationApi;\n  }\n\n  public TrackApi getTrackApi() {\n    return trackApi;\n  }\n\n  /**\n   * Changes the token used to authenticate the client.\n   *\n   * @param token a new valid token to access the google service\n   */\n  public void changeToken(@NotNull AuthToken token) {\n    interceptor.setToken(token);\n  }\n\n  /**\n   * Use this class to create a {@link GPlayMusic} instance.\n   */\n  public final static class Builder {\n\n    private OkHttpClient.Builder httpClientBuilder;\n    private AuthToken authToken;\n    private Locale locale = Locale.US;\n    private String androidID;\n    private ErrorInterceptor.InterceptorBehaviour\n        interceptorBehaviour = ErrorInterceptor.InterceptorBehaviour.THROW_EXCEPTION;\n    private boolean debug = false;\n\n    /**\n     * Used while building the {@link GPlayMusic} instance. If no {@link OkHttpClient.Builder} is\n     * provided via {@link #setHttpClientBuilder(OkHttpClient.Builder)} the instance returned by\n     * this method will be used for building.\n     *\n     * @return Returns the default {@link OkHttpClient.Builder} instance\n     */\n    public static OkHttpClient.Builder getDefaultHttpBuilder() {\n      ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)\n          .tlsVersions(TlsVersion.TLS_1_2)\n          .cipherSuites(\n              CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n              CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n              CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)\n          .build();\n      return new OkHttpClient.Builder()\n          .connectionSpecs(Collections.singletonList(spec));\n    }\n\n    public boolean isDebug() {\n      return debug;\n    }\n\n    /**\n     * If set to <em>true</em>, will log every request and response made by the Client.<br> <b> Be\n     * careful as this can easily leak personal information. Be sure to always check the output.\n     * </b>\n     */\n    public GPlayMusic.Builder setDebug(boolean debug) {\n      this.debug = debug;\n      return this;\n    }\n\n    /**\n     * Set a custom {@link OkHttpClient.Builder} to build the {@link GPlayMusic} instance with. If\n     * left untouched the Builder will use the default instance accessible through {@link\n     * #getDefaultHttpBuilder()}.\n     *\n     * @return This {@link Builder} instance.\n     */\n    public Builder setHttpClientBuilder(OkHttpClient.Builder builder) {\n      this.httpClientBuilder = builder;\n      return this;\n    }\n\n    /**\n     * Set an {@link AuthToken} to access the Google Play Service. This method has to be called\n     * before building the {@link GPlayMusic} instance.\n     *\n     * @param token An {@link AuthToken} either saved from a prior session or created through the\n     * {@link TokenProvider#provideToken(String, String, String)} method.\n     * @return This {@link Builder} instance.\n     */\n    public Builder setAuthToken(AuthToken token) {\n      this.authToken = token;\n      return this;\n    }\n\n    /**\n     * Set a local to use during calls to the Google Play Service. Defaults to {@link Locale#US}.\n     *\n     * @return This {@link Builder} instance.\n     */\n    public Builder setLocale(Locale locale) {\n      this.locale = locale;\n      return this;\n    }\n\n    /**\n     * Set a Behaviour for the {@link ErrorInterceptor} appended to the {@link\n     * OkHttpClient.Builder}. Throws Exceptions on default. May cause instability when set to {@link\n     * com.github.felixgail.gplaymusic.util.interceptor.ErrorInterceptor.InterceptorBehaviour#LOG}.\n     *\n     * @return This {@link Builder} instance.\n     */\n    public Builder setInterceptorBehaviour(\n        ErrorInterceptor.InterceptorBehaviour interceptorBehaviour) {\n      this.interceptorBehaviour = interceptorBehaviour;\n      return this;\n    }\n\n    /**\n     * Set an AndroidID used for stream calls to the Google Play Service. In general the IMEI used\n     * for logging in should be sufficient. If logged in with a MAC use {@link\n     * GPlayMusic#getRegisteredDevices()} for a list of connected devices or leave empty. On empty\n     * the {@link #build()}-method will use search online for a suitable device.\n     *\n     * @return This {@link Builder} instance.\n     */\n    public Builder setAndroidID(String androidID) {\n      this.androidID = androidID;\n      return this;\n    }\n\n    /**\n     * Builds a new {@link GPlayMusic} instance with the customizations set to this builder. Make\n     * sure to call {@link #setAuthToken(AuthToken)} before building with this method.\n     *\n     * @return Returns a new {@link GPlayMusic} instance\n     */\n    public GPlayMusic build() {\n      try {\n        if (this.authToken == null) {\n          throw new InitializationException(Language.get(\"api.init.EmptyToken\"));\n        }\n\n        if (this.httpClientBuilder == null) {\n          this.httpClientBuilder = getDefaultHttpBuilder();\n        }\n\n        RequestInterceptor parameterInterceptor = new RequestInterceptor(authToken);\n\n        this.httpClientBuilder\n            .addInterceptor(parameterInterceptor)\n            .addInterceptor(new ErrorInterceptor(this.interceptorBehaviour))\n            .followRedirects(false);\n        if (this.debug) {\n          this.httpClientBuilder.addInterceptor(new LoggingInterceptor());\n        }\n\n        OkHttpClient httpClient = this.httpClientBuilder.build();\n\n        ModelPostProcessor postProcessor = new ModelPostProcessor();\n        GsonBuilder builder = new GsonFireBuilder()\n            .registerPostProcessor(Model.class, postProcessor)\n            .createGsonBuilder()\n            .registerTypeAdapter(Result.class, new ResultDeserializer())\n            .registerTypeAdapter(ListenNowStation.class, new ListenNowStationDeserializer());\n\n        Retrofit retrofit = new Retrofit.Builder()\n            .baseUrl(HttpUrl.parse(\"https://mclients.googleapis.com/\"))\n            .addConverterFactory(GsonConverterFactory.create(builder.create()))\n            .client(httpClient)\n            .build();\n\n        GPlayMusic gPlay = new GPlayMusic(retrofit.create(GPlayService.class),\n            parameterInterceptor);\n        postProcessor.setApi(gPlay);\n        retrofit2.Response<Config> configResponse =\n                gPlay.getService().config(this.locale).execute();\n        if (!configResponse.isSuccessful()) {\n          throw new InitializationException(Language.get(\"network.GenericError\"),\n              NetworkException.parse(configResponse.raw()));\n        }\n        Config config = configResponse.body();\n        if (config == null) {\n          throw new InitializationException(Language.get(\"api.init.EmptyConfig\"));\n        }\n        config.setLocale(locale);\n        Language.setLocale(locale);\n        gPlay.setConfig(config);\n\n        parameterInterceptor.addParameter(\"dv\", \"0\")\n            .addParameter(\"hl\", locale.toString())\n            .addParameter(\"tier\", config.getSubscription().getValue());\n\n        if (androidID == null) {\n          Optional<DeviceInfo> optional =\n              gPlay.getRegisteredDevices().toList().stream()\n                  .filter(deviceInfo -> (deviceInfo.getType().equals(\"ANDROID\")))\n                  .findFirst();\n          if (optional.isPresent()) {\n            config.setAndroidID(optional.get().getId());\n          } else {\n            throw new InitializationException(Language.get(\"api.init.NoAndroidId\"));\n          }\n        } else {\n          config.setAndroidID(androidID);\n        }\n        return gPlay;\n      } catch (IOException e) {\n        throw new InitializationException(e);\n      }\n    }\n\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/exceptions/NetworkException.java\npublic class NetworkException extends IOException implements Serializable {\n\n  private final static Gson gson = new Gson();\n  @Expose\n  @SerializedName(\"error\")\n  private ErrorHelper helper = new ErrorHelper();\n\n  private Response response;\n\n  public NetworkException(int code, String message) {\n    helper = new ErrorHelper();\n    helper.setCode(code);\n    helper.setMessage(message);\n  }\n\n  public static NetworkException parse(Response response) {\n    try {\n      return gson.fromJson(response.body().charStream(), NetworkException.class);\n    } catch (JsonSyntaxException e) {\n      return new NetworkException(response.code(), response.message());\n    }\n  }\n\n  public int getCode() {\n    return helper.getCode();\n  }\n\n  @Override\n  public String getMessage() {\n    return helper.getMessage();\n  }\n\n\n  public Response getResponse() {\n    return response;\n  }\n\n  public NetworkException setResponse(Response response) {\n    this.response = response;\n    return this;\n  }\n\n  private String getRequestInformation() {\n\n    if (response != null) {\n      return NetworkPrettyPrinter.getRequestPrint(response.request());\n    }\n    return \"\";\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%s:\\nError Code: %d \\nMessage: %s \\n\\n%s\\n\\n%s\\n\\n%s\\n\",\n        Language.get(\"network.GenericError\"), getCode(), getMessage(), getRequestInformation(),\n        NetworkPrettyPrinter.getResponsePrint(response), super.toString());\n  }\n\n  private class ErrorHelper implements Serializable {\n\n    @Expose\n    private int code;\n    @Expose\n    private String message;\n\n    public int getCode() {\n      return code;\n    }\n\n    public void setCode(int code) {\n      this.code = code;\n    }\n\n    public String getMessage() {\n      return message;\n    }\n\n    public void setMessage(String message) {\n      this.message = message;\n    }\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/enums/StreamQuality.java\npublic enum StreamQuality implements Serializable {\n  @SerializedName(\"lo\")\n  LOW(\"lo\"),\n  @SerializedName(\"med\")\n  MEDIUM(\"med\"),\n  @SerializedName(\"hi\")\n  HIGH(\"hi\");\n\n  private String value;\n\n  StreamQuality(String value) {\n    this.value = value;\n  }\n\n  @Override\n  public String toString() {\n    return value;\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/util/language/Language.java\npublic class Language {\n\n  private final static Locale defaultLocale = Locale.US;\n  private final static Properties defaultLang;\n\n  private static Locale currentLocale;\n  private static Properties currentLang;\n\n  static {\n    currentLocale = defaultLocale;\n    try {\n      Properties lang = getNewLanguage(defaultLocale);\n      currentLang = lang;\n    } catch (IOException | NullPointerException e) {\n      Logger.getGlobal().warning(String.format(\"Default language file (%s) not found.\",\n          defaultLocale.toString()));\n      currentLang = new Properties();\n    }\n    defaultLang = currentLang;\n  }\n\n  private static Properties getNewLanguage(Locale locale) throws IOException {\n    Properties lang = new Properties();\n    InputStream in = Language.class\n        .getClassLoader()\n        .getResourceAsStream(\"lang/\" + locale.toString());\n    InputStreamReader reader = new InputStreamReader(in, Charset.forName(\"UTF-8\"));\n    lang.load(reader);\n    in.close();\n    return lang;\n  }\n\n  public static void setLocale(Locale locale) {\n    if (!locale.equals(currentLocale)) {\n      if (locale.equals(defaultLocale)) {\n        currentLocale = defaultLocale;\n        currentLang = defaultLang;\n      } else {\n        try {\n          currentLang = getNewLanguage(locale);\n          currentLocale = locale;\n        } catch (IOException | NullPointerException e) {\n          Logger.getGlobal().warning(\n              String.format(Language.get(\"language.FileNotFound\"),\n                  locale.toString()));\n        }\n      }\n    }\n  }\n\n  public static void setDefault() {\n    currentLocale = defaultLocale;\n    currentLang = defaultLang;\n  }\n\n  public static String get(String key) {\n    if (currentLang.containsKey(key)) {\n      return currentLang.getProperty(key);\n    }\n    Logger.getGlobal().warning(\n        String.format(Language.get(\"language.KeyNotFoundCurrent\"),\n            currentLocale.toString(), key));\n    if (defaultLang.containsKey(key)) {\n      return defaultLang.getProperty(key);\n    }\n    Logger.getGlobal().warning(\n        String.format(Language.get(\"language.KeyNotFoundDefault\"),\n            defaultLocale.toString(), key));\n    return String.format(\"{%s}\", key);\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/snippets/ArtRef.java\npublic class ArtRef {\n\n  @Expose\n  private String url;\n  @Expose\n  private String aspectRatio;\n  @Expose\n  private Autogen autogen;\n  @Expose\n  private ColorStyles colorStyles;\n\n  public Optional<ColorStyles> getColorStyles() {\n    return Optional.ofNullable(colorStyles);\n  }\n\n  public String getUrl() {\n    return url;\n  }\n\n  public Optional<String> getAspectRatio() {\n    return Optional.ofNullable(aspectRatio);\n  }\n\n  public Optional<Autogen> isAutogen() {\n    return Optional.ofNullable(autogen);\n  }\n\n  @JsonAdapter(AutogenEnumDeserializer.class)\n  public enum Autogen {\n    TRUE,\n    FALSE\n  }\n\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/enums/Provider.java\npublic enum Provider {\n  STREAM(\"mplay\"),\n  STATION(\"wplay\"),\n  PODCAST(\"fplay\");\n\n  private String value;\n\n  Provider(String v) {\n    this.value = v;\n  }\n\n  @Override\n  public String toString() {\n    return this.value;\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/responses/Result.java\npublic interface Result {\n\n  ResultType getResultType();\n}\nsrc/main/java/com/github/felixgail/gplaymusic/api/TrackApi.java\npublic class TrackApi implements SubApi {\n\n  private GPlayMusic mainApi;\n  private LibraryTrackCache libraryTrackCache;\n\n  TrackApi(GPlayMusic api) {\n    this.mainApi = api;\n    this.libraryTrackCache = new LibraryTrackCache(api);\n  }\n\n  /**\n   * Provides convenience by wrapping the {@link GPlayMusic#search(String, int, SearchTypes)} method\n   * and limiting the content types to Tracks only.\n   *\n   * @return Returns a list of tracks returned by the google play service.\n   */\n  public List<Track> search(String query, int maxResults) throws IOException {\n    return mainApi.search(query, maxResults, new SearchTypes(ResultType.TRACK))\n        .getTracks();\n  }\n\n  public Track getTrack(String trackID) throws IOException {\n    Track track;\n    if (trackID.startsWith(\"T\")) {\n      track = mainApi.getService().fetchTrack(trackID).execute().body();\n    } else {\n      track = libraryTrackCache.find(trackID).orElseThrow(() ->\n          new IllegalArgumentException(String.format(\"No track with id '%s' found.\", trackID)));\n    }\n    if (track == null || track.getID() == null) {\n      throw new IOException(String.format(\"'%s' did not return a valid track\", trackID));\n    }\n    return track;\n  }\n\n  public List<Track> getLibraryTracks() throws IOException {\n    return libraryTrackCache.getAll();\n  }\n\n  /**\n   * Filters cache and returns tracks with 'Thumbs up' mark\n   * @return List of tracks liked by user\n   * @throws IOException if GMusic request fails\n   */\n  public List<Track> getThumbsUpTracks() throws IOException {\n    return libraryTrackCache.getAll().stream()\n            .filter(t -> t.getRating().isPresent() && Integer.valueOf(t.getRating().get()) > 1)\n            .collect(Collectors.toList());\n  }\n\n  /**\n   * Library tracks can only be fetched as whole. To shorten wait times, collected songs are cached.\n   * Please consider updating the cache (asynchronously) when using the library over a long period\n   * of time, or when new songs could be added to the library during runtime. <br> If outside access\n   * to the library is expected during runtime, disabling caching via {@link #useCache(boolean)}\n   * should also be considered.\n   */\n  public void updateCache() throws IOException {\n    libraryTrackCache.update();\n  }\n\n  /**\n   * Enables/Disables caching of library tracks.\n   */\n  public void useCache(boolean useCache) {\n    libraryTrackCache.setUseCache(useCache);\n  }\n\n  @Override\n  public GPlayMusic getMainApi() {\n    return mainApi;\n  }\n}\n", "answers": ["      throw new IOException(Language.get(\"track.InvalidWentryID\"));"], "length": 2705, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "19a0159bcf2092543f018ce3258b50af6fd35ed61f66b525"}
{"input": "import org.json.JSONArray;\nimport org.json.JSONObject;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.widget.ImageView;\nimport com.yanzhenjie.nohttp.download.DownloadQueue;\nimport com.yanzhenjie.nohttp.download.DownloadRequest;\nimport com.yanzhenjie.nohttp.rest.ByteArrayRequest;\nimport com.yanzhenjie.nohttp.rest.ImageRequest;\nimport com.yanzhenjie.nohttp.rest.JsonArrayRequest;\nimport com.yanzhenjie.nohttp.rest.JsonObjectRequest;\nimport com.yanzhenjie.nohttp.rest.Request;\nimport com.yanzhenjie.nohttp.rest.RequestQueue;\nimport com.yanzhenjie.nohttp.rest.Response;\nimport com.yanzhenjie.nohttp.rest.StringRequest;\nimport com.yanzhenjie.nohttp.rest.SyncRequestExecutor;\n/*\n * Copyright 2015 Yan Zhenjie\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.yanzhenjie.nohttp;\n\n\n\n\n/**\n * <p>\n * NoHttp.\n * </p>\n * Created in Jul 28, 2015 7:32:22 PM.\n *\n * @author Yan Zhenjie.\n */\npublic class NoHttp {\n\n    private static InitializationConfig sInitializeConfig;\n\n    private NoHttp() {\n    }\n\n    /**\n     * Initialize NoHttp, should invoke on {@link android.app.Application#onCreate()}.\n     *\n     * @param context {@link Context}.\n     */\n    public static void initialize(Context context) {\n        initialize(InitializationConfig.newBuilder(context).build());\n    }\n\n    /**\n     * Initialize NoHttp, should invoke on {@link android.app.Application#onCreate()}.\n     */\n    public static void initialize(InitializationConfig initializeConfig) {\n        sInitializeConfig = initializeConfig;\n    }\n\n    /**\n     * Test initialized.\n     */\n    private static void testInitialize() {\n        if (sInitializeConfig == null)\n            throw new ExceptionInInitializerError(\"Please invoke NoHttp.initialize(Application) on Application#onCreate()\");\n    }\n\n    /**\n     * Gets context of app.\n     */\n    public static Context getContext() {\n        testInitialize();\n        return sInitializeConfig.getContext();\n    }\n\n    /**\n     * Get InitializationConfig.\n     */\n    public static InitializationConfig getInitializeConfig() {\n        testInitialize();\n        return sInitializeConfig;\n    }\n\n    /**\n     * Create a queue of handle, the default thread pool size is 3.\n     *\n     * @return returns the handle queue, the queue is used to control the entry of the handle.\n     * @see #newRequestQueue(int)\n     */\n    public static RequestQueue newRequestQueue() {\n        return newRequestQueue(3);\n    }\n\n    /**\n     * Create a queue of handle.\n     *\n     * @param threadPoolSize handle the number of concurrent.\n     * @return returns the handle queue, the queue is used to control the entry of the handle.\n     * @see #newRequestQueue()\n     */\n    public static RequestQueue newRequestQueue(int threadPoolSize) {\n        RequestQueue requestQueue = new RequestQueue(threadPoolSize);\n        requestQueue.start();\n        return requestQueue;\n    }\n\n    /**\n     * Create a String type handle, the handle method is {@link RequestMethod#GET}.\n     *\n     * @param url such as: {@code http://www.nohttp.net}.\n     * @return {@code Request<String>}.\n     * @see #createStringRequest(String, RequestMethod)\n     */\n    public static Request<String> createStringRequest(String url) {\n        return new StringRequest(url);\n    }\n\n    /**\n     * Create a String type handle, custom handle method, method from {@link RequestMethod}.\n     *\n     * @param url           such as: {@code http://www.nohttp.net}.\n     * @param requestMethod {@link RequestMethod}.\n     * @return {@code Request<String>}.\n     * @see #createStringRequest(String)\n     */\n    public static Request<String> createStringRequest(String url, RequestMethod requestMethod) {\n        return new StringRequest(url, requestMethod);\n    }\n\n    /**\n     * Create a JSONObject type handle, the handle method is {@link RequestMethod#GET}.\n     *\n     * @param url such as: {@code http://www.nohttp.net}.\n     * @return {@code Request<JSONObject>}.\n     * @see #createJsonObjectRequest(String, RequestMethod)\n     */\n    public static Request<JSONObject> createJsonObjectRequest(String url) {", "context": "nohttp/src/main/java/com/yanzhenjie/nohttp/rest/RequestQueue.java\npublic class RequestQueue {\n\n    private AtomicInteger mInteger = new AtomicInteger(1);\n    private final BlockingQueue<Work<? extends Request<?>, ?>> mQueue = new PriorityBlockingQueue<>();\n    private final CancelerManager mCancelerManager = new CancelerManager();\n    private RequestDispatcher[] mDispatchers;\n\n    /**\n     * @param threadPoolSize number of thread pool.\n     */\n    public RequestQueue(int threadPoolSize) {\n        mDispatchers = new RequestDispatcher[threadPoolSize];\n    }\n\n    /**\n     * All dispatcher in the boot queue, such as the dispatcher that has already been started in the queue,\n     * will stop all dispatcher first and restart the equal number of dispatcher.\n     *\n     * @see #stop()\n     */\n    public void start() {\n        stop();\n\n        for (int i = 0; i < mDispatchers.length; i++) {\n            RequestDispatcher dispatcher = new RequestDispatcher(mQueue);\n            mDispatchers[i] = dispatcher;\n            dispatcher.start();\n        }\n    }\n\n    /**\n     * Add a request to the queue.\n     *\n     * @param what the {@code what} be returned in the result callback.\n     * @param request {@link Request}.\n     * @param listener {@link OnResponseListener}.\n     * @param <T> {@link T}.\n     */\n    public <T> void add(int what, final Request<T> request, OnResponseListener<T> listener) {\n        Worker<? extends Request<T>, T> worker = new Worker<>(request);\n        AsyncCallback<T> callback = new AsyncCallback<T>(listener) {\n            @Override\n            public void onFinish(int what) {\n                mCancelerManager.removeCancel(request);\n                super.onFinish(what);\n            }\n        };\n        final Work<? extends Request<T>, T> work = new Work<>(worker, what, callback);\n        work.setSequence(mInteger.incrementAndGet());\n\n        callback.setQueue(mQueue);\n        callback.setWork(work);\n\n        request.setCancelable(work);\n\n        mCancelerManager.addCancel(request, work);\n        mQueue.add(work);\n    }\n\n    /**\n     * @deprecated use {@link #unFinishSize()} instead.\n     */\n    @Deprecated\n    public int size() {\n        return unFinishSize();\n    }\n\n    /**\n     * The number of requests that have not been executed yet.\n     */\n    public int unStartSize() {\n        return mQueue.size();\n    }\n\n    /**\n     * The number of all requests, including the request being executed.\n     */\n    public int unFinishSize() {\n        return mCancelerManager.size();\n    }\n\n    /**\n     * Cancel all requests and stop all dispatchers in the queue.\n     */\n    public void stop() {\n        cancelAll();\n\n        for (RequestDispatcher dispatcher : mDispatchers) {\n            if (dispatcher != null) {\n                dispatcher.quit();\n            }\n        }\n    }\n\n    /**\n     * According to the sign to cancel a task.\n     *\n     * @see CancelerManager#cancel(Object)\n     */\n    public void cancelBySign(Object sign) {\n        mCancelerManager.cancel(sign);\n    }\n\n    /**\n     * Cancel all requests.\n     */\n    public void cancelAll() {\n        mCancelerManager.cancelAll();\n    }\n\n    static class AsyncCallback<T>\n      implements OnResponseListener<T> {\n\n        private final OnResponseListener<T> mCallback;\n        private BlockingQueue<Work<? extends Request<?>, ?>> mQueue;\n        private Work<? extends Request<?>, ?> mWork;\n\n        AsyncCallback(OnResponseListener<T> callback) {\n            this.mCallback = callback;\n        }\n\n        public void setQueue(BlockingQueue<Work<? extends Request<?>, ?>> queue) {\n            this.mQueue = queue;\n        }\n\n        public void setWork(Work<? extends Request<?>, ?> work) {\n            this.mWork = work;\n        }\n\n        @Override\n        public void onStart(final int what) {\n            HandlerDelivery.getInstance().post(new Runnable() {\n                @Override\n                public void run() {\n                    mCallback.onStart(what);\n                }\n            });\n        }\n\n        @Override\n        public void onSucceed(final int what, final Response<T> response) {\n            HandlerDelivery.getInstance().post(new Runnable() {\n                @Override\n                public void run() {\n                    mCallback.onSucceed(what, response);\n                }\n            });\n        }\n\n        @Override\n        public void onFailed(final int what, final Response<T> response) {\n            HandlerDelivery.getInstance().post(new Runnable() {\n                @Override\n                public void run() {\n                    mCallback.onFailed(what, response);\n                }\n            });\n        }\n\n        @Override\n        public void onFinish(final int what) {\n            if (mQueue.contains(mWork)) {\n                mQueue.remove(mWork);\n            }\n\n            HandlerDelivery.getInstance().post(new Runnable() {\n                @Override\n                public void run() {\n                    mCallback.onFinish(what);\n                }\n            });\n        }\n    }\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/download/DownloadQueue.java\npublic class DownloadQueue {\n\n    private AtomicInteger mInteger = new AtomicInteger(1);\n    private final BlockingQueue<Work<? extends DownloadRequest>> mQueue = new PriorityBlockingQueue<>();\n    private final CancelerManager mCancelerManager = new CancelerManager();\n    private DownloadDispatcher[] mDispatchers;\n\n    /**\n     * @param threadPoolSize number of thread pool.\n     */\n    public DownloadQueue(int threadPoolSize) {\n        mDispatchers = new DownloadDispatcher[threadPoolSize];\n    }\n\n    /**\n     * All dispatcher in the boot queue, such as the dispatcher that has already been started in the queue,\n     * will stop all dispatcher first and restart the equal number of dispatcher.\n     *\n     * @see #stop()\n     */\n    public void start() {\n        stop();\n\n        for (int i = 0; i < mDispatchers.length; i++) {\n            DownloadDispatcher dispatcher = new DownloadDispatcher(mQueue);\n            mDispatchers[i] = dispatcher;\n            dispatcher.start();\n        }\n    }\n\n    /**\n     * Add a request to the queue.\n     *\n     * @param what the {@code what} be returned in the result callback.\n     * @param request {@link DownloadRequest}\n     * @param listener {@link DownloadListener}\n     */\n    public void add(int what, final DownloadRequest request, DownloadListener listener) {\n        AsyncCallback callback = new AsyncCallback(listener);\n        Worker<? extends DownloadRequest> worker = new Worker<>(what, request, callback);\n        final Work<? extends DownloadRequest> work = new Work<>(worker, what, callback);\n        work.setSequence(mInteger.incrementAndGet());\n\n        callback.setQueue(mQueue);\n        callback.setCancelerManager(mCancelerManager);\n        callback.setWork(work);\n        callback.setRequest(request);\n\n        request.setCancelable(work);\n\n        mCancelerManager.addCancel(request, work);\n        mQueue.add(work);\n    }\n\n    /**\n     * @deprecated use {@link #unFinishSize()} instead.\n     */\n    @Deprecated\n    public int size() {\n        return unFinishSize();\n    }\n\n    /**\n     * The number of requests that have not been executed yet.\n     */\n    public int unStartSize() {\n        return mQueue.size();\n    }\n\n    /**\n     * The number of all requests, including the request being executed.\n     */\n    public int unFinishSize() {\n        return mCancelerManager.size();\n    }\n\n    /**\n     * Cancel all requests and stop all dispatchers in the queue.\n     */\n    public void stop() {\n        cancelAll();\n\n        for (DownloadDispatcher dispatcher : mDispatchers) {\n            if (dispatcher != null) {\n                dispatcher.quit();\n            }\n        }\n    }\n\n    /**\n     * According to the sign to cancel a task.\n     *\n     * @see CancelerManager#cancel(Object)\n     */\n    public void cancelBySign(Object sign) {\n        mCancelerManager.cancel(sign);\n    }\n\n    /**\n     * Cancel all requests.\n     */\n    public void cancelAll() {\n        mCancelerManager.cancelAll();\n    }\n\n    private static class AsyncCallback\n      implements DownloadListener {\n\n        private final DownloadListener mCallback;\n        private BlockingQueue<Work<? extends DownloadRequest>> mQueue;\n        private Work<? extends DownloadRequest> mWork;\n        private CancelerManager mCancelerManager;\n        private DownloadRequest mRequest;\n\n        public AsyncCallback(DownloadListener callback) {\n            this.mCallback = callback;\n        }\n\n        public void setQueue(BlockingQueue<Work<? extends DownloadRequest>> queue) {\n            mQueue = queue;\n        }\n\n        public void setWork(Work<? extends DownloadRequest> work) {\n            mWork = work;\n        }\n\n        public void setCancelerManager(CancelerManager cancelerManager) {\n            mCancelerManager = cancelerManager;\n        }\n\n        public void setRequest(DownloadRequest request) {\n            mRequest = request;\n        }\n\n        @Override\n        public void onDownloadError(final int what, final Exception exception) {\n            removeRequest();\n            HandlerDelivery.getInstance().post(new Runnable() {\n                @Override\n                public void run() {\n                    mCallback.onDownloadError(what, exception);\n                }\n            });\n        }\n\n        @Override\n        public void onStart(final int what, final boolean isResume, final long rangeSize,\n                            final Headers headers, final long allCount) {\n            HandlerDelivery.getInstance().post(new Runnable() {\n                @Override\n                public void run() {\n                    mCallback.onStart(what, isResume, rangeSize, headers, allCount);\n                }\n            });\n        }\n\n        @Override\n        public void onProgress(final int what, final int progress, final long fileCount, final long speed) {\n            HandlerDelivery.getInstance().post(new Runnable() {\n                @Override\n                public void run() {\n                    mCallback.onProgress(what, progress, fileCount, speed);\n                }\n            });\n        }\n\n        @Override\n        public void onFinish(final int what, final String filePath) {\n            removeRequest();\n            HandlerDelivery.getInstance().post(new Runnable() {\n                @Override\n                public void run() {\n                    mCallback.onFinish(what, filePath);\n                }\n            });\n        }\n\n        @Override\n        public void onCancel(final int what) {\n            removeRequest();\n            HandlerDelivery.getInstance().post(new Runnable() {\n                @Override\n                public void run() {\n                    mCallback.onCancel(what);\n                }\n            });\n        }\n\n        private void removeRequest() {\n            mCancelerManager.removeCancel(mRequest);\n            if (mQueue.contains(mWork)) {\n                mQueue.remove(mWork);\n            }\n        }\n    }\n\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/rest/JsonArrayRequest.java\npublic class JsonArrayRequest extends Request<JSONArray> {\n\n    public JsonArrayRequest(String url) {\n        this(url, RequestMethod.GET);\n    }\n\n    public JsonArrayRequest(String url, RequestMethod requestMethod) {\n        super(url, requestMethod);\n        setAccept(Headers.HEAD_VALUE_CONTENT_TYPE_JSON);\n    }\n\n    @Override\n    public JSONArray parseResponse(Headers responseHeaders, byte[] responseBody) throws Exception {\n        String jsonStr = StringRequest.parseResponseString(responseHeaders, responseBody);\n        return new JSONArray(jsonStr);\n    }\n\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/rest/Request.java\npublic abstract class Request<Result> extends BasicRequest<Request> {\n    /**\n     * Cache key.\n     */\n    private String mCacheKey;\n    /**\n     * If just read from cache.\n     */\n    private CacheMode mCacheMode = CacheMode.DEFAULT;\n\n    /**\n     * Create a handle, handle method is {@link RequestMethod#GET}.\n     *\n     * @param url handle address, like: http://www.nohttp.net.\n     */\n    public Request(String url) {\n        this(url, RequestMethod.GET);\n    }\n\n    /**\n     * Create a handle\n     *\n     * @param url           handle address, like: http://www.nohttp.net.\n     * @param requestMethod handle method, like {@link RequestMethod#GET}, {@link RequestMethod#POST}.\n     */\n    public Request(String url, RequestMethod requestMethod) {\n        super(url, requestMethod);\n    }\n\n    /**\n     * Set the handle cache primary key, it should be globally unique.\n     *\n     * @param key unique key.\n     */\n    public Request setCacheKey(String key) {\n        this.mCacheKey = key;\n        return this;\n    }\n\n    /**\n     * Get key of cache data.\n     *\n     * @return cache key.\n     */\n    public String getCacheKey() {\n        return TextUtils.isEmpty(mCacheKey) ? url() : mCacheKey;\n    }\n\n    /**\n     * Set the cache mode.\n     *\n     * @param cacheMode The value from {@link CacheMode}.\n     */\n    public Request setCacheMode(CacheMode cacheMode) {\n        this.mCacheMode = cacheMode;\n        return this;\n    }\n\n    /**\n     * He got the handle cache mode.\n     *\n     * @return value from {@link CacheMode}.\n     */\n    public CacheMode getCacheMode() {\n        return mCacheMode;\n    }\n\n    /**\n     * Parse handle results for generic objects.\n     *\n     * @param responseHeaders response headers of server.\n     * @param responseBody    response data of server.\n     * @return your response result.\n     * @throws Exception parse error.\n     */\n    public abstract Result parseResponse(Headers responseHeaders, byte[] responseBody) throws Exception;\n\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/rest/StringRequest.java\npublic class StringRequest extends Request<String> {\n\n    public StringRequest(String url) {\n        this(url, RequestMethod.GET);\n    }\n\n    public StringRequest(String url, RequestMethod requestMethod) {\n        super(url, requestMethod);\n    }\n\n    @Override\n    public String parseResponse(Headers responseHeaders, byte[] responseBody) throws Exception {\n        return parseResponseString(responseHeaders, responseBody);\n    }\n\n    /**\n     * Parse http response to string.\n     *\n     * @param responseHeaders header from http response.\n     * @param responseBody    byteArray from http response.\n     * @return result fro response.\n     */\n    public static String parseResponseString(Headers responseHeaders, byte[] responseBody) {\n        if (responseBody == null || responseBody.length == 0)\n            return \"\";\n        String charset = HeaderUtils.parseHeadValue(responseHeaders.getContentType(), \"charset\", \"\");\n        return IOUtils.toString(responseBody, charset);\n    }\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/rest/ByteArrayRequest.java\npublic class ByteArrayRequest extends Request<byte[]> {\n\n    public ByteArrayRequest(String url) {\n        this(url, RequestMethod.GET);\n    }\n\n    public ByteArrayRequest(String url, RequestMethod requestMethod) {\n        super(url, requestMethod);\n    }\n\n    @Override\n    public byte[] parseResponse(Headers responseHeaders, byte[] responseBody) throws Exception {\n        return responseBody == null ? new byte[0] : responseBody;\n    }\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/rest/JsonObjectRequest.java\npublic class JsonObjectRequest extends Request<JSONObject> {\n\n    public JsonObjectRequest(String url) {\n        this(url, RequestMethod.GET);\n    }\n\n    public JsonObjectRequest(String url, RequestMethod requestMethod) {\n        super(url, requestMethod);\n        setAccept(Headers.HEAD_VALUE_CONTENT_TYPE_JSON);\n    }\n\n    @Override\n    public JSONObject parseResponse(Headers responseHeaders, byte[] responseBody) throws Exception {\n        String jsonStr = StringRequest.parseResponseString(responseHeaders, responseBody);\n        return new JSONObject(jsonStr);\n    }\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/rest/Response.java\npublic interface Response<T> {\n\n    /**\n     * Get the Request.\n     */\n    Request<T> request();\n\n    /**\n     * Get the response code of handle.\n     *\n     * @return response code.\n     */\n    int responseCode();\n\n    /**\n     * Request is executed successfully.\n     *\n     * @return True: Succeed, false: failed.\n     */\n    boolean isSucceed();\n\n    /**\n     * Whether the data returned from the cache.\n     *\n     * @return True: the data from cache, false: the data from server.\n     */\n    boolean isFromCache();\n\n    /**\n     * Get http response headers.\n     *\n     * @return {@link Headers}.\n     */\n    Headers getHeaders();\n\n    /**\n     * Get handle results.\n     *\n     * @return {@link T}.\n     */\n    T get();\n\n    /**\n     * When the handle fail to getList the exception type.\n     *\n     * @return The exception.\n     */\n    Exception getException();\n\n    /**\n     * Gets the tag of handle.\n     *\n     * @return {@link Object}.\n     */\n    Object getTag();\n\n    /**\n     * Gets the millisecond of handle.\n     *\n     * @return {@link Long}.\n     */\n    long getNetworkMillis();\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/rest/SyncRequestExecutor.java\npublic enum SyncRequestExecutor {\n\n    INSTANCE;\n\n    private RequestHandler mRequestHandler;\n\n    SyncRequestExecutor() {\n        InitializationConfig initializationConfig = NoHttp.getInitializeConfig();\n        mRequestHandler = new RequestHandler(\n                initializationConfig.getCacheStore(),\n                initializationConfig.getNetworkExecutor(),\n                initializationConfig.getInterceptor()\n        );\n    }\n\n    /**\n     * Perform a handle.\n     */\n    public <T> Response<T> execute(Request<T> request) {\n        return mRequestHandler.handle(request);\n    }\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/download/DownloadRequest.java\npublic class DownloadRequest extends BasicRequest<DownloadRequest> {\n    /**\n     * Also didn't download to start download again.\n     */\n    public static final int STATUS_RESTART = 0;\n    /**\n     * Part has been downloaded, continue to download last time.\n     */\n    public static final int STATUS_RESUME = 1;\n    /**\n     * Has the download is complete, not to download operation.\n     */\n    public static final int STATUS_FINISH = 2;\n\n    /**\n     * File the target folder.\n     */\n    private final String mFileDir;\n    /**\n     * The file target name.\n     */\n    private final String mFileName;\n    /**\n     * If is to download a file, whether the breakpoint continuing.\n     */\n    private final boolean isRange;\n    /**\n     * If there is a old files, whether to delete the old files.\n     */\n    private final boolean isDeleteOld;\n\n    /**\n     * Create download handle.\n     *\n     * @param url           url.\n     * @param requestMethod {@link RequestMethod}.\n     * @param fileFolder    file save folder.\n     * @param isDeleteOld   find the same when the file is deleted after download, or on behalf of the download is\n     *                      complete, not to handle the network.\n     * @see #DownloadRequest(String, RequestMethod, String, String, boolean, boolean)\n     */\n    public DownloadRequest(String url, RequestMethod requestMethod, String fileFolder, boolean isRange, boolean isDeleteOld) {\n        this(url, requestMethod, fileFolder, null, isRange, isDeleteOld);\n    }\n\n    /**\n     * Create a download object.\n     *\n     * @param url           download address.\n     * @param requestMethod {@link RequestMethod}.\n     * @param fileFolder    folder to save file.\n     * @param filename      filename.\n     * @param isRange       whether the breakpoint continuing.\n     * @param isDeleteOld   find the same when the file is deleted after download, or on behalf of the download is\n     *                      complete, not to handle the network.\n     * @see #DownloadRequest(String, RequestMethod, String, boolean, boolean)\n     */\n    public DownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) {\n        super(url, requestMethod);\n        this.mFileDir = fileFolder;\n        this.mFileName = filename;\n        this.isRange = isRange;\n        this.isDeleteOld = isDeleteOld;\n    }\n\n    /**\n     * Return the mFileDir.\n     *\n     * @return it won't be empty.\n     */\n    public String getFileDir() {\n        return this.mFileDir;\n    }\n\n    /**\n     * Return the mFileName.\n     *\n     * @return it won't be empty.\n     */\n    public String getFileName() {\n        return this.mFileName;\n    }\n\n    /**\n     * Return the isRange.\n     *\n     * @return true: breakpoint continuing, false: don't need a breakpoint continuing.\n     */\n    public boolean isRange() {\n        return this.isRange;\n    }\n\n    /**\n     * If there is a old files, whether to delete the old files.\n     *\n     * @return true: deleted, false: don't delete.\n     */\n    public boolean isDeleteOld() {\n        return this.isDeleteOld;\n    }\n\n    /**\n     * <p>\n     * Query before download status {@link #STATUS_RESTART} representative no download do to download again; Download\n     * {@link #STATUS_RESUME} represents a part of, to continue to download; {@link #STATUS_FINISH} representatives\n     * have finished downloading.\n     * </p>\n     *\n     * @return int value, compared with the {@value #STATUS_RESTART}, {@value #STATUS_RESUME}, {@value #STATUS_FINISH}.\n     * @see #STATUS_RESTART\n     * @see #STATUS_RESUME\n     * @see #STATUS_FINISH\n     */\n    public int checkBeforeStatus() {\n        if (this.isRange) {\n            try {\n                File lastFile = new File(mFileDir, mFileName);\n                if (lastFile.exists() && !isDeleteOld)\n                    return STATUS_FINISH;\n                File tempFile = new File(mFileDir, mFileName + \".nohttp\");\n                if (tempFile.exists())\n                    return STATUS_RESUME;\n            } catch (Exception ignored) {\n            }\n        }\n        return STATUS_RESTART;\n    }\n}\nnohttp/src/main/java/com/yanzhenjie/nohttp/rest/ImageRequest.java\npublic class ImageRequest extends Request<Bitmap> {\n\n    private final int mMaxWidth;\n    private final int mMaxHeight;\n    private final Bitmap.Config mDecodeConfig;\n    private ImageView.ScaleType mScaleType;\n\n    /**\n     * Decoding lock so that we don't decode more than one image at a time (to avoid OOM's).\n     */\n    private static final Object DECODE_LOCK = new Object();\n\n    public ImageRequest(String url, RequestMethod requestMethod, int maxWidth, int maxHeight, Bitmap.Config\n            decodeConfig, ImageView.ScaleType scaleType) {\n        super(url, requestMethod);\n        this.mMaxWidth = maxWidth;\n        this.mMaxHeight = maxHeight;\n        this.mDecodeConfig = decodeConfig;\n        this.mScaleType = scaleType;\n        setAccept(\"image/*\");\n    }\n\n    @Override\n    public Bitmap parseResponse(Headers responseHeaders, byte[] responseBody) throws Exception {\n        synchronized (DECODE_LOCK) {\n            Bitmap bitmap = null;\n            if (responseBody != null) {\n                try {\n                    bitmap = doResponse(responseBody);\n                } catch (OutOfMemoryError e) {\n                    String errorMessage = String.format(Locale.US, \"Caught OOM for %d byte image, url=%s\",\n                            responseBody.length, url());\n                    Logger.e(e, errorMessage);\n                }\n            }\n            return bitmap;\n        }\n    }\n\n    /**\n     * The real guts of AnalyzeResponse. Broken out for readability.\n     */\n    private Bitmap doResponse(byte[] byteArray) throws OutOfMemoryError {\n        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();\n        Bitmap bitmap;\n        if (mMaxWidth == 0 && mMaxHeight == 0) {\n            decodeOptions.inPreferredConfig = mDecodeConfig;\n            bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.length, decodeOptions);\n        } else {\n            decodeOptions.inJustDecodeBounds = true;\n            BitmapFactory.decodeByteArray(byteArray, 0, byteArray.length, decodeOptions);\n            int actualWidth = decodeOptions.outWidth;\n            int actualHeight = decodeOptions.outHeight;\n\n            int desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight, actualWidth, actualHeight, mScaleType);\n            int desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth, actualHeight, actualWidth, mScaleType);\n\n            decodeOptions.inJustDecodeBounds = false;\n            decodeOptions.inSampleSize = findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);\n            Bitmap tempBitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.length, decodeOptions);\n\n            if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth || tempBitmap.getHeight() >\n                    desiredHeight)) {\n                bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true);\n                tempBitmap.recycle();\n            } else {\n                bitmap = tempBitmap;\n            }\n        }\n        return bitmap;\n    }\n\n    private static int getResizedDimension(int maxPrimary, int maxSecondary, int actualPrimary, int actualSecondary,\n                                           ImageView.ScaleType scaleType) {\n\n        // If no dominant value at all, just return the actual.\n        if ((maxPrimary == 0) && (maxSecondary == 0)) {\n            return actualPrimary;\n        }\n\n        // If ScaleType.FIT_XY fill the whole rectangle, ignore ratio.\n        if (scaleType == ImageView.ScaleType.FIT_XY) {\n            if (maxPrimary == 0) {\n                return actualPrimary;\n            }\n            return maxPrimary;\n        }\n\n        // If primary is unspecified, scale primary to match secondary's scaling ratio.\n        if (maxPrimary == 0) {\n            double ratio = (double) maxSecondary / (double) actualSecondary;\n            return (int) (actualPrimary * ratio);\n        }\n\n        if (maxSecondary == 0) {\n            return maxPrimary;\n        }\n\n        double ratio = (double) actualSecondary / (double) actualPrimary;\n        int resized = maxPrimary;\n\n        // If ScaleType.CENTER_CROP fill the whole rectangle, preserve aspect ratio.\n        if (scaleType == ImageView.ScaleType.CENTER_CROP) {\n            if ((resized * ratio) < maxSecondary) {\n                resized = (int) (maxSecondary / ratio);\n            }\n            return resized;\n        }\n\n        if ((resized * ratio) > maxSecondary) {\n            resized = (int) (maxSecondary / ratio);\n        }\n        return resized;\n    }\n\n    // Visible for testing.\n    public static int findBestSampleSize(int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) {\n        double wr = (double) actualWidth / desiredWidth;\n        double hr = (double) actualHeight / desiredHeight;\n        double ratio = Math.min(wr, hr);\n        float n = 1.0f;\n        while ((n * 2) <= ratio) {\n            n *= 2;\n        }\n        return (int) n;\n    }\n\n}\n", "answers": ["        return new JsonObjectRequest(url);"], "length": 3108, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "f7c98836f7de7b92a5f535192ca0ed21ff4947c8dead620d"}
{"input": "package com.sora.util.akatsuki;\nimport static com.sora.util.akatsuki.SourceUtils.T;\nimport static com.sora.util.akatsuki.SourceUtils.type;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.type.TypeMirror;\nimport javax.tools.Diagnostic.Kind;\nimport com.sora.util.akatsuki.BundleContext.SimpleBundleContext;\nimport com.sora.util.akatsuki.analyzers.CascadingTypeAnalyzer;\nimport com.sora.util.akatsuki.analyzers.CascadingTypeAnalyzer.Analysis;\nimport com.sora.util.akatsuki.analyzers.CascadingTypeAnalyzer.InvocationType;\nimport com.sora.util.akatsuki.analyzers.Element;\nimport com.sora.util.akatsuki.models.BaseModel;\nimport com.sora.util.akatsuki.models.ClassInfo;\nimport com.sora.util.akatsuki.models.FieldModel;\nimport com.sora.util.akatsuki.models.SourceClassModel;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.MethodSpec.Builder;\nimport com.squareup.javapoet.ParameterSpec;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeSpec;\nimport com.squareup.javapoet.TypeVariableName;\n\n\n\n\n\npublic class BundleRetainerClassBuilder extends BaseModel {\n\n\tenum Direction {\n\t\tSAVE(\"save\", InvocationType.SAVE), RESTORE(\"restore\", InvocationType.RESTORE);\n\n\t\tfinal String methodName;\n\t\tfinal InvocationType type;\n\n\t\tDirection(String methodName, InvocationType type) {\n\t\t\tthis.methodName = methodName;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\n\tprivate final SourceClassModel classModel;\n\tprivate final EnumSet<Direction> directions;\n\tprivate final Function<ClassInfo, ClassInfo> classInfoFunction;\n\tprivate final Function<ClassInfo, ClassInfo> superClassInfoFunction;\n\n\tprivate Optional<Predicate<FieldModel>> fieldModelPredicate = Optional.empty();\n\tprivate Optional<AnalysisTransformation> analysisTransformation = Optional.empty();\n\tprivate Optional<BundleContext> bundleContext = Optional.empty();\n\n\tBundleRetainerClassBuilder(ProcessorContext context, SourceClassModel classModel,\n\t\t\tEnumSet<Direction> direction, Function<ClassInfo, ClassInfo> classInfoFunction,\n\t\t\tFunction<ClassInfo, ClassInfo> superClassInfoFunction) {\n\t\tsuper(context);\n\t\tthis.classModel = classModel;\n\t\tthis.directions = direction;\n\t\tthis.classInfoFunction = classInfoFunction;\n\t\tthis.superClassInfoFunction = superClassInfoFunction;\n\t}\n\n\tpublic BundleRetainerClassBuilder withFieldPredicate(Predicate<FieldModel> modelPredicate) {\n\t\tthis.fieldModelPredicate = Optional.of(modelPredicate);\n\t\treturn this;\n\t}\n\n\tpublic BundleRetainerClassBuilder withAnalysisTransformation(\n\t\t\tAnalysisTransformation transformation) {\n\t\tthis.analysisTransformation = Optional.of(transformation);\n\t\treturn this;\n\t}\n\n\tpublic BundleRetainerClassBuilder withBundleContext(BundleContext context) {\n\t\tthis.bundleContext = Optional.of(context);\n\t\treturn this;\n\t}\n\n\t// public ClassInfo classInfo() {\n\t// return classInfo;\n\t// }\n\n\tpublic TypeSpec.Builder build() {\n\n\t\tBundleContext bundleContext = this.bundleContext\n\t\t\t\t.orElse(new SimpleBundleContext(\"source\", \"bundle\"));\n\n\t\tfinal ClassName sourceClassName = ClassName.get(classModel.originatingElement());\n\n\t\tTypeVariableName actualClassCapture = SourceUtils.T_extends(sourceClassName);\n\n\t\tfinal ParameterSpec sourceSpec = ParameterSpec\n\t\t\t\t.builder(actualClassCapture, bundleContext.sourceObjectName(), Modifier.FINAL)\n\t\t\t\t.build();\n\n\t\tfinal ParameterSpec bundleSpec = ParameterSpec\n\t\t\t\t.builder(ClassName.get(AndroidTypes.Bundle.asMirror(context)),\n\t\t\t\t\t\tbundleContext.bundleObjectName(), Modifier.FINAL)\n\t\t\t\t.build();\n\n\t\tEnumMap<Direction, Builder> actionBuilderMap = new EnumMap<>(Direction.class);\n\n\t\t// we implement the interface here, all methods action must actually be\n\t\t// there\n\t\tfor (Direction direction : Direction.values()) {\n\t\t\tfinal Builder saveMethodBuilder = MethodSpec.methodBuilder(direction.methodName)\n\t\t\t\t\t.addModifiers(Modifier.PUBLIC).returns(void.class).addParameter(sourceSpec)\n\t\t\t\t\t.addParameter(bundleSpec);\n\t\t\tactionBuilderMap.put(direction, saveMethodBuilder);\n\t\t\tif (classModel.directSuperModel().isPresent()) {\n\t\t\t\tString superInvocation = \"super.$L($L, $L)\";\n\t\t\t\tsaveMethodBuilder.addStatement(superInvocation, direction.methodName,\n\t\t\t\t\t\tbundleContext.sourceObjectName(), bundleContext.bundleObjectName());\n\t\t\t}\n\t\t}\n\n\t\tList<Element<TypeMirror>> elements = classModel.fields().stream().map(Element::new)\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tEnumSet<Direction> emptyDirections = EnumSet.complementOf(this.directions);\n\n\t\tfor (Direction direction : emptyDirections) {\n\t\t\tactionBuilderMap.get(direction).addCode(\"throw new $T($S);\", AssertionError.class,\n\t\t\t\t\t\"Unused action, should not be called at all\");\n\t\t}\n\n\t\tfor (Element<TypeMirror> element : elements) {\n\t\t\tif (!fieldModelPredicate.orElseGet(() -> fm -> true).test(element.model()))\n\t\t\t\tcontinue;\n\n\t\t\tfinal CascadingTypeAnalyzer<?, ?, ?> strategy = context.resolver().resolve(element);\n\t\t\tif (strategy == null) {\n\t\t\t\tcontext.messager().printMessage(Kind.ERROR,\n\t\t\t\t\t\t\"unsupported field, reflected type is \" + element.refinedMirror()\n\t\t\t\t\t\t\t\t+ \" representing class is \" + element.refinedMirror().getClass(),\n\t\t\t\t\t\telement.originatingElement());\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tfor (Direction direction : directions) {\n\t\t\t\t\t\tAnalysis analysis = strategy.transform(bundleContext, element,\n\t\t\t\t\t\t\t\tdirection.type);\n\t\t\t\t\t\tanalysisTransformation.ifPresent(\n\t\t\t\t\t\t\t\tft -> ft.transform(context, direction, element, analysis));\n\t\t\t\t\t\tactionBuilderMap.get(direction)\n\t\t\t\t\t\t\t\t.addCode(JavaPoetUtils.escapeStatement(analysis.preEmitOnce()\n\t\t\t\t\t\t\t\t\t\t+ analysis.emit() + analysis.postEmitOnce()));\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception | Error e) {\n\t\t\t\t\tcontext.messager().printMessage(Kind.ERROR, \"An exception/error occurred\",\n\t\t\t\t\t\t\telement.originatingElement());\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTypeSpec.Builder typeSpecBuilder = TypeSpec\n\t\t\t\t.classBuilder(classInfoFunction.apply(classModel.asClassInfo()).className)\n\t\t\t\t.addModifiers(Modifier.PUBLIC).addTypeVariable(actualClassCapture);\n\n\t\tfor (Builder builder : actionBuilderMap.values()) {\n\t\t\ttypeSpecBuilder.addMethod(builder.build());\n\t\t}\n\n\t\tOptional<SourceClassModel> superModel = classModel.directSuperModel();\n\n\t\tif (superModel.isPresent()) {\n\t\t\tClassName className = superClassInfoFunction.apply(superModel.get().asClassInfo())\n\t\t\t\t\t.toClassName();", "context": "akatsuki-compiler/src/main/java/com/sora/util/akatsuki/models/BaseModel.java\npublic class BaseModel {\n\n\tprotected final ProcessorContext context;\n\n\tpublic BaseModel(ProcessorContext context) {\n\t\tthis.context = context;\n\t}\n\n}\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/analyzers/CascadingTypeAnalyzer.java\npublic interface Analysis {\n\n\tvoid prependOnce(Analysis analysis);\n\n\tvoid appendOnce(Analysis analysis);\n\n\tvoid prependOnce(String string);\n\n\tvoid appendOnce(String string);\n\n\tString emit();\n\n\tvoid transform(CodeTransform transform);\n\n\tvoid wrap(CodeTransform transformation);\n\n\tString preEmitOnce();\n\n\tString postEmitOnce();\n\n}\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/SourceUtils.java\npublic static final TypeVariableName T = var(\"T\");\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/models/FieldModel.java\npublic class FieldModel {\n\n\tpublic enum Flag {\n\t\tHIDDEN\n\t}\n\n\tpublic final VariableElement element;\n\tprivate final Set<Class<? extends Annotation>> annotated;\n\tfinal EnumSet<Flag> flags = EnumSet.noneOf(Flag.class);\n\n\tpublic FieldModel(VariableElement element, Set<Class<? extends Annotation>> annotated) {\n\t\tthis.element = element;\n\t\tthis.annotated = annotated;\n\t}\n\n\tpublic String name() {\n\t\treturn element.getSimpleName().toString();\n\t}\n\n\tpublic <A extends Annotation> Optional<A> annotation(Class<A> annotationClass) {\n\t\treturn annotated.contains(annotationClass)\n\t\t\t\t? Optional.of(element.getAnnotation(annotationClass)) : Optional.empty();\n\t}\n\n\tpublic EnumSet<Flag> flags() {\n\t\treturn EnumSet.copyOf(flags);\n\t}\n\n\tpublic TypeElement enclosingElement() {\n\t\treturn (TypeElement) element.getEnclosingElement();\n\t}\n\n\tpublic TypeMirror type() {\n\t\treturn element.asType();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o)\n\t\t\treturn true;\n\t\tif (o == null || getClass() != o.getClass())\n\t\t\treturn false;\n\t\tFieldModel that = (FieldModel) o;\n\t\treturn element.equals(that.element);\n\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn element.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn MoreObjects.toStringHelper(this).add(\"element\", element).add(\"flags\", flags)\n\t\t\t\t.toString();\n\t}\n}\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/SourceUtils.java\npublic static ParameterizedTypeName type(Class<?> clazz, TypeVariableName... variableNames) {\n\treturn ParameterizedTypeName.get(ClassName.get(clazz), variableNames);\n}\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/models/ClassInfo.java\npublic class ClassInfo {\n\n\tpublic final String fullyQualifiedPackageName;\n\tpublic final String className;\n\n\tpublic final List<String> enclosingClasses;\n\n\tpublic ClassInfo(String fullyQualifiedPackageName, String className,\n\t\t\tList<String> enclosingClasses) {\n\t\tthis.fullyQualifiedPackageName = fullyQualifiedPackageName;\n\t\tthis.className = className;\n\t\tthis.enclosingClasses = Collections.unmodifiableList(enclosingClasses);\n\t}\n\n\tpublic ClassInfo(String fullyQualifiedPackageName, String className,\n\t\t\tString... enclosingClasses) {\n\t\tthis(fullyQualifiedPackageName, className, Arrays.asList(enclosingClasses));\n\t}\n\n\tpublic String fullyQualifiedClassName() {\n\t\treturn fullyQualifiedPackageName + \".\"\n\t\t\t\t+ (enclosingClasses.size() == 0 ? \"\" : Joiner.on('$').join(enclosingClasses) + \"$\")\n\t\t\t\t+ className;\n\t}\n\n\tpublic ClassInfo withFqpnTransform(Function<String, String> function) {\n\t\treturn new ClassInfo(function.apply(fullyQualifiedPackageName), className, enclosingClasses);\n\t}\n\n\tpublic ClassInfo withNameTransform(Function<String, String> function) {\n\t\treturn new ClassInfo(fullyQualifiedPackageName, function.apply(className), enclosingClasses);\n\t}\n\n\tpublic ClassInfo withEnclosingClasses(String... classes) {\n\n\t\tArrayList<String> c = new ArrayList<>(enclosingClasses);\n\t\tc.addAll(Arrays.asList(classes));\n\n\t\treturn new ClassInfo(fullyQualifiedPackageName, className, c);\n\t}\n\n\tpublic ClassName toClassName() {\n\t\tif (enclosingClasses.isEmpty()) {\n\t\t\treturn ClassName.get(fullyQualifiedPackageName, className);\n\t\t} else {\n\t\t\t// XXX this is just stupid, JavaPoet has a private constructor just\n\t\t\t// for this...\n\t\t\tArrayList<String> names = new ArrayList<>(enclosingClasses);\n\t\t\tnames.add(className);\n\t\t\tList<String> subList = names.subList(1, names.size());\n\t\t\treturn ClassName.get(fullyQualifiedPackageName, names.get(0),\n\t\t\t\t\tsubList.toArray(new String[subList.size()]));\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn fullyQualifiedClassName();\n\t}\n}\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/models/SourceClassModel.java\npublic class SourceClassModel extends BaseModel {\n\n\tprivate final TypeElement enclosingClass;\n\tprivate SourceClassModel parent;\n\tprivate Set<SourceClassModel> children;\n\tfinal List<FieldModel> fields = new ArrayList<>();\n\n\tSourceClassModel(ProcessorContext context, TypeElement enclosingClass) {\n\t\tsuper(context);\n\t\tthis.enclosingClass = enclosingClass;\n\n\t\tif (!enclosingClassValid(context, enclosingClass)) {\n\t\t\tthrow new RuntimeException(\"Element \" + enclosingClass + \" is not valid\");\n\t\t}\n\n\t}\n\n\tvoid linkParent(Map<String, SourceClassModel> map) {\n\t\tTypeElement superClass = enclosingClass;\n\t\twhile ((superClass.getKind() == ElementKind.CLASS)) {\n\t\t\tfinal Element superElement = context.types().asElement(superClass.getSuperclass());\n\t\t\tif (!(superElement instanceof TypeElement)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsuperClass = (TypeElement) superElement;\n\n\t\t\tfinal SourceClassModel superModel = map.get(superClass.getQualifiedName().toString());\n\t\t\tif (superModel != null) {\n\t\t\t\t// we found our closest super class\n\t\t\t\tthis.parent = superModel;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// this.children.forEach(c -> c.linkParent(map));\n\t}\n\n\tvoid findChildren(Map<String, SourceClassModel> map, RoundEnvironment environment) {\n\t\tSet<SourceClassModel> models = new HashSet<>();\n\t\tfor (Element root : environment.getRootElements()) {\n\n\t\t\troot.accept(new SimpleElementVisitor8<Void, Set<SourceClassModel>>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Void visitType(TypeElement element, Set<SourceClassModel> models) {\n\t\t\t\t\tif (element.getKind() == ElementKind.CLASS && element != enclosingClass) {\n\t\t\t\t\t\t// we're in a class now\n\t\t\t\t\t\tif (context.utils().isAssignable(element.asType(), mirror(), true)) {\n\t\t\t\t\t\t\t// the class extends the source class, add it to the\n\t\t\t\t\t\t\t// map\n\t\t\t\t\t\t\tSourceClassModel existing = map\n\t\t\t\t\t\t\t\t\t.get(element.getQualifiedName().toString());\n\t\t\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\t\t\t// class model was instantiated in the\n\t\t\t\t\t\t\t\t// verification phase\n\n\t\t\t\t\t\t\t\tif (existing.parent == null)\n\t\t\t\t\t\t\t\t\texisting.parent = SourceClassModel.this;\n\n\t\t\t\t\t\t\t\tmodels.add(existing);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// new class found\n\t\t\t\t\t\t\t\tSourceClassModel model = new SourceClassModel(context, element);\n\t\t\t\t\t\t\t\tmodel.parent = SourceClassModel.this;\n\t\t\t\t\t\t\t\tmodels.add(model);\n\t\t\t\t\t\t\t\tmodel.findChildren(map, environment);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// keep walking\n\t\t\t\t\t\telement.getEnclosedElements().forEach(e -> e.accept(this, models));\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}, models);\n\t\t}\n\t\tthis.children = Collections.unmodifiableSet(models);\n\t}\n\n\tvoid markHiddenFields() {\n\t\t// set colliding fields with the proper flag\n\t\tfields.stream().filter(model -> parent != null && parent.containsFieldWithSameName(model))\n\t\t\t\t.findAny().ifPresent(m -> m.flags.add(Flag.HIDDEN));\n\t}\n\n\tprivate boolean containsFieldWithSameName(FieldModel model) {\n\t\treturn fields.stream().anyMatch(m -> m.name().equals(model.name()));\n\t}\n\n\tpublic List<FieldModel> fields() {\n\t\treturn Collections.unmodifiableList(fields);\n\t}\n\n\tpublic String fullyQualifiedName() {\n\t\treturn enclosingClass.getQualifiedName().toString();\n\t}\n\n\tpublic String simpleName() {\n//\t\tif (enclosingClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n//\t\t\tString fqn = enclosingClass.getQualifiedName().toString();\n//\t\t\treturn fqn.substring(fqn.indexOf('.') + 1, fqn.length());\n//\t\t} else {\n\t\t\treturn enclosingClass.getSimpleName().toString();\n//\t\t}\n\t}\n\n\tpublic String fullyQualifiedPackageName() {\n\t\treturn context.elements().getPackageOf(enclosingClass).toString();\n\t}\n\n\tpublic boolean containsModifier(Modifier modifier) {\n\t\treturn enclosingClass.getModifiers().contains(modifier);\n\t}\n\n\tpublic ClassInfo asClassInfo() {\n\t\tString fqpn = fullyQualifiedPackageName();\n\t\tString className;\n\t\tif (enclosingClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n\t\t\t// in case of the static class, we get all the nested classes and\n\t\t\t// replace '.' with '$'\n\t\t\tclassName = CharMatcher.is('.')\n\t\t\t\t\t.replaceFrom(fullyQualifiedName().replace(fqpn + \".\", \"\"), '$');\n\t\t} else {\n\t\t\tclassName = simpleName();\n\t\t}\n\t\treturn new ClassInfo(fqpn, className);\n\t}\n\n\tpublic TypeElement originatingElement() {\n\t\treturn enclosingClass;\n\t}\n\n\tpublic <A extends Annotation> Optional<A> annotation(Class<A> annotationClass) {\n\t\treturn Optional.ofNullable(enclosingClass.getAnnotation(annotationClass));\n\t}\n\n\tpublic Optional<SourceClassModel> directSuperModel() {\n\t\treturn Optional.ofNullable(parent);\n\t}\n\n\tpublic Optional<SourceClassModel> directSuperModelWithAnnotation(\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\treturn parent != null && parent.containsAnyAnnotation(annotationClass) ? directSuperModel()\n\t\t\t\t: Optional.empty();\n\t}\n\n\tpublic boolean containsAnyAnnotation(Class<? extends Annotation> annotationClass) {\n\t\treturn fields.stream().anyMatch(fm -> fm.annotation(annotationClass).isPresent());\n\t}\n\n\tpublic Set<SourceClassModel> children() {\n\t\treturn children;\n\t}\n\n\tpublic TypeMirror mirror() {\n\t\treturn enclosingClass.asType();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o)\n\t\t\treturn true;\n\t\tif (o == null || getClass() != o.getClass())\n\t\t\treturn false;\n\t\tSourceClassModel that = (SourceClassModel) o;\n\t\treturn enclosingClass.equals(that.enclosingClass);\n\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn enclosingClass.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn MoreObjects.toStringHelper(this).add(\"enclosingClass\", enclosingClass)\n\t\t\t\t.add(\"parent\", parent != null ? parent.fullyQualifiedName() : null)\n\t\t\t\t.add(\"children\", Arrays.toString(children.stream()\n\t\t\t\t\t\t.map(SourceClassModel::fullyQualifiedName).toArray(String[]::new)))\n\t\t\t\t.add(\"fields\", fields).toString();\n\t}\n}\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/analyzers/CascadingTypeAnalyzer.java\npublic enum InvocationType {\n\tSAVE, RESTORE\n}\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/BundleContext.java\nclass SimpleBundleContext implements BundleContext {\n\n\tprivate final String sourceObjectName;\n\tprivate final String bundleObjectName;\n\n\tSimpleBundleContext(String sourceObjectName, String bundleObjectName) {\n\t\tthis.sourceObjectName = sourceObjectName;\n\t\tthis.bundleObjectName = bundleObjectName;\n\t}\n\n\t@Override\n\tpublic String sourceObjectName() {\n\t\treturn sourceObjectName;\n\t}\n\n\t@Override\n\tpublic String bundleObjectName() {\n\t\treturn bundleObjectName;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn MoreObjects.toStringHelper(this).add(\"sourceObjectName\", sourceObjectName)\n\t\t\t\t.add(\"bundleObjectName\", bundleObjectName).toString();\n\t}\n}\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/analyzers/Element.java\npublic class Element<T extends TypeMirror> {\n\n\tprivate final FieldModel model;\n\n\tprivate final List<CodeTransform> keyNameTransformations;\n\tprivate final List<CodeTransform> fieldAccessorTransformations;\n\tprivate String accessorExpression;\n\n\tprivate TypeMirror fieldMirror;\n\tprivate T refinedMirror;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Element(FieldModel model) {\n\t\tthis.model = model;\n\t\tthis.keyNameTransformations = new ArrayList<>();\n\t\tthis.fieldAccessorTransformations = new ArrayList<>();\n\t\tthis.accessorExpression = \"\";\n\t\tthis.fieldMirror = model.type();\n\t\tthis.refinedMirror = (T) model.type();\n\t}\n\n\t// copy constructor\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Element(Element<?> element) {\n\t\tthis.model = element.model;\n\t\tthis.keyNameTransformations = new ArrayList<>(element.keyNameTransformations);\n\t\tthis.fieldAccessorTransformations = new ArrayList<>(element.fieldAccessorTransformations);\n\t\tthis.accessorExpression = element.accessorExpression;\n\t\tthis.fieldMirror = element.fieldMirror;\n\t\tthis.refinedMirror = (T) element.refinedMirror;\n\t}\n\n\tpublic javax.lang.model.element.Element originatingElement() {\n\t\treturn model.element;\n\t}\n\n\tpublic FieldModel model() {\n\t\treturn model;\n\t}\n\n\tpublic String accessor(Function<String, String> fieldAccessFunction) {\n\t\tString fieldAccess = fieldAccessFunction.apply(model.name() + accessorExpression);\n\t\tfor (Function<String, String> transformations : fieldAccessorTransformations) {\n\t\t\tfieldAccess = transformations.apply(fieldAccess);\n\t\t}\n\t\treturn fieldAccess;\n\t}\n\n\tpublic String uniqueName() {\n\t\tif (model.flags().contains(Flag.HIDDEN)) {\n\t\t\t// fieldName_packageName\n\t\t\treturn model.name() + \"_\" + model.enclosingElement().getQualifiedName();\n\t\t} else {\n\t\t\t// fieldName\n\t\t\treturn model.name();\n\t\t}\n\t}\n\n\tpublic String keyName() {\n\t\tString keyName = \"\\\"\" + uniqueName() + \"\\\"\";\n\t\tfor (Function<String, String> transformations : keyNameTransformations) {\n\t\t\tkeyName = transformations.apply(keyName);\n\t\t}\n\t\treturn keyName;\n\t}\n\n\tpublic TypeMirror fieldMirror() {\n\t\treturn fieldMirror;\n\t}\n\n\tpublic T refinedMirror() {\n\t\treturn refinedMirror;\n\t}\n\n\tpublic Builder<T> toBuilder() {\n\t\treturn new Builder<>(this);\n\t}\n\n\tpublic <NT extends TypeMirror> Element<NT> refine(NT newTypeMirror) {\n\t\treturn toBuilder().refinedType(newTypeMirror).build();\n\t}\n\n\tpublic static class Builder<T extends TypeMirror> {\n\n\t\tpublic enum SetterMode {\n\t\t\tAPPEND((o, i) -> o + i), PREPEND((o, i) -> i + o), REPLACE((o, i) -> i);\n\n\t\t\tprivate final BiFunction<String, String, String> function;\n\n\t\t\tSetterMode(BiFunction<String, String, String> function) {\n\t\t\t\tthis.function = function;\n\t\t\t}\n\n\t\t\tpublic String process(String original, String input) {\n\t\t\t\treturn function.apply(original, input);\n\t\t\t}\n\t\t}\n\n\t\tprivate Element<T> element;\n\n\t\tprivate Builder(Element<T> element) {\n\t\t\tthis.element = new Element<>(element);\n\t\t}\n\n\t\tpublic <NT extends TypeMirror> Builder<NT> type(NT type) {\n\t\t\treturn fieldType(type).refinedType(type);\n\t\t}\n\n\t\tpublic Builder<T> fieldType(TypeMirror mirror) {\n\t\t\telement.fieldMirror = mirror;\n\t\t\treturn this;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <NT extends TypeMirror> Builder<NT> refinedType(NT mirror) {\n\t\t\telement.refinedMirror = (T) mirror;\n\t\t\treturn (Builder<NT>) this;\n\t\t}\n\n\t\tpublic Builder<T> keyName(SetterMode mode, String name) {\n\t\t\telement.keyNameTransformations.add((original) -> mode.process(original, name));\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder<T> fieldNameTransforms(CodeTransform transform) {\n\t\t\telement.fieldAccessorTransformations.add(transform);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder<T> accessor(SetterMode mode, String accessor) {\n\t\t\telement.accessorExpression = mode.process(element.accessorExpression, accessor);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Element<T> build() {\n\t\t\tfinal Element<T> element = this.element;\n\t\t\t// forbid mutation through the builder once the object has been\n\t\t\t// build\n\t\t\tthis.element = null;\n\t\t\treturn element;\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn MoreObjects.toStringHelper(this)\n\t\t\t\t.add(\"keyNameTransformations\", Iterables.size(keyNameTransformations))\n\t\t\t\t.add(\"accessorExpression\", accessorExpression).add(\"fieldMirror\", fieldMirror)\n\t\t\t\t.add(\"refinedMirror\", refinedMirror).toString();\n\t}\n}\nakatsuki-compiler/src/main/java/com/sora/util/akatsuki/analyzers/CascadingTypeAnalyzer.java\npublic abstract class CascadingTypeAnalyzer<S extends CascadingTypeAnalyzer<S, T, A>, T extends TypeMirror, A extends Analysis>\n\t\textends TransformationContext {\n\n\tprivate int cascadeDepth;\n\n\tpublic enum InvocationType {\n\t\tSAVE, RESTORE\n\t}\n\n\tpublic static final Escaper ESCAPER = new CharEscaperBuilder()\n\t\t\t.addEscapes(new char[] { '[', ']', '.', '(', ')' }, \"_\").toEscaper();\n\n\tprotected TypeMirror targetMirror;\n\tprotected TypeCastStrategy strategy = TypeCastStrategy.AUTO_CAST;\n\tprotected String suffix = \"\";\n\n\tS target(TypeMirror mirror) {\n\t\tfinal S instance = createInstance(this);\n\t\tcloneFields(instance);\n\t\tinstance.targetMirror = mirror;\n\t\treturn instance;\n\t}\n\n\tS cast(TypeCastStrategy strategy) {\n\t\tfinal S instance = createInstance(this);\n\t\tcloneFields(instance);\n\t\tinstance.strategy = strategy;\n\t\treturn instance;\n\t}\n\n\tS suffix(String suffix) {\n\t\tfinal S instance = createInstance(this);\n\t\tcloneFields(instance);\n\t\tinstance.suffix = this.suffix + suffix;\n\t\treturn instance;\n\t}\n\n\tprivate void cloneFields(CascadingTypeAnalyzer<?, ?, ?> target) {\n\t\ttarget.targetMirror = this.targetMirror;\n\t\ttarget.suffix = this.suffix;\n\t\ttarget.strategy = this.strategy;\n\t}\n\n\tprotected abstract S createInstance(TransformationContext context);\n\n\tpublic enum TypeCastStrategy {\n\t\tNO_CAST((context, from, to) -> null), //\n\t\tFORCE_CAST((context, from, to) -> to.toString()), //\n\t\tAUTO_CAST((context, from, to) -> context.utils().isAssignable(from, to, true) ? null\n\t\t\t\t: to.toString());//\n\n\t\tprivate final ClassCastFunction function;\n\n\t\tTypeCastStrategy(ClassCastFunction function) {\n\t\t\tthis.function = function;\n\t\t}\n\n\t\tpublic interface ClassCastFunction {\n\t\t\tString createCastExpression(ProcessorContext context, TypeMirror from, TypeMirror to);\n\t\t}\n\n\t}\n\n\tpublic CascadingTypeAnalyzer(TransformationContext context) {\n\t\tsuper(context);\n\t\tthis.cascadeDepth = 0;\n\t}\n\n\tpublic static class InvocationContext<T extends TypeMirror> {\n\t\tpublic final BundleContext bundleContext;\n\t\tpublic final Element<T> field;\n\t\tpublic final InvocationType type;\n\n\t\tpublic InvocationContext(BundleContext bundleContext, Element<T> field,\n\t\t\t\tInvocationType type) {\n\t\t\tthis.bundleContext = bundleContext;\n\t\t\tthis.field = field;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\n\tprotected abstract A createAnalysis(InvocationContext<T> context) throws UnknownTypeException;\n\n\tprotected String fieldAccessor(InvocationContext<?> context) {\n\t\treturn context.field.accessor(fn -> {\n\t\t\tString objectName = context.bundleContext.sourceObjectName();\n\t\t\treturn Strings.isNullOrEmpty(objectName) ? fn : objectName + \".\" + fn;\n\t\t});\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic A transform(BundleContext bundleContext, Element<?> element, InvocationType type)\n\t\t\tthrows UnknownTypeException {\n\t\tLog.verbose(this,\n\t\t\t\ttype + \">\" + cascadeDepth + Strings.repeat(\" \", cascadeDepth) + \"\\\\Cascade:\"\n\t\t\t\t\t\t+ toString() + \" -> \" + element.toString() + \" with \" + bundleContext);\n\t\treturn createAnalysis(new InvocationContext<>(bundleContext, (Element<T>) element, type));\n\t}\n\n\tprotected Analysis cascade(CascadingTypeAnalyzer<?, ?, ?> transformation,\n\t\t\tInvocationContext<?> context, TypeMirror mirror) throws UnknownTypeException {\n\t\treturn cascade(transformation, context, f -> f.refine(mirror));\n\t}\n\n\tprotected Analysis cascade(CascadingTypeAnalyzer<?, ?, ?> transformation,\n\t\t\tInvocationContext<?> context, Function<Element<?>, Element<?>> elementTransformation)\n\t\t\t\t\tthrows UnknownTypeException {\n\t\ttransformation.cascadeDepth = cascadeDepth + 1;\n\t\treturn transformation.transform(context.bundleContext,\n\t\t\t\telementTransformation.apply(context.field), context.type);\n\n\t}\n\n\tprotected TypeMirror targetOrElse(TypeMirror mirror) {\n\t\treturn targetMirror != null ? targetMirror : mirror;\n\t}\n\n\tpublic interface Analysis {\n\n\t\tvoid prependOnce(Analysis analysis);\n\n\t\tvoid appendOnce(Analysis analysis);\n\n\t\tvoid prependOnce(String string);\n\n\t\tvoid appendOnce(String string);\n\n\t\tString emit();\n\n\t\tvoid transform(CodeTransform transform);\n\n\t\tvoid wrap(CodeTransform transformation);\n\n\t\tString preEmitOnce();\n\n\t\tString postEmitOnce();\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn MoreObjects.toStringHelper(this).add(\"targetMirror\", targetMirror)\n\t\t\t\t.add(\"strategy\", strategy).add(\"suffix\", suffix).toString();\n\t}\n\n\tstatic abstract class ChainedAnalysis implements Analysis {\n\n\t\tprivate final List<String> preEmit = new ArrayList<>();\n\t\tprivate final List<String> postEmit = new ArrayList<>();\n\t\tprotected final CodeTransforms transforms = new CodeTransforms();\n\n\t\t@Override\n\t\tpublic void prependOnce(Analysis analysis) {\n\t\t\tappendAnalysis(preEmit, analysis);\n\t\t}\n\n\t\t@Override\n\n\t\tpublic void appendOnce(Analysis analysis) {\n\t\t\tappendAnalysis(postEmit, analysis);\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void wrap(CodeTransform transform) {\n\t\t\ttransforms.append(transform);\n\t\t}\n\n\t\t@Override\n\t\tpublic void prependOnce(String string) {\n\t\t\tpreEmit.add(string);\n\t\t}\n\n\t\t@Override\n\t\tpublic void appendOnce(String string) {\n\t\t\tpostEmit.add(string);\n\t\t}\n\n\t\t@Override\n\t\tpublic String preEmitOnce() {\n\t\t\treturn preEmit.stream().collect(Collectors.joining());\n\t\t}\n\n\t\t@Override\n\t\tpublic String postEmitOnce() {\n\t\t\treturn postEmit.stream().collect(Collectors.joining());\n\t\t}\n\n\t\tprivate void appendAnalysis(List<String> list, Analysis analysis) {\n\t\t\tlist.add(analysis.preEmitOnce());\n\t\t\tlist.add(analysis.emit());\n\t\t\tlist.add(analysis.postEmitOnce());\n\t\t}\n\n\t}\n\n\tstatic class DefaultAnalysis extends ChainedAnalysis {\n\n\t\tprivate final Map<String, Object> scope;\n\t\tprivate RawStatement expression;\n\n\t\tDefaultAnalysis(Map<String, Object> scope, RawStatement statement) {\n\t\t\tthis.scope = scope;\n\t\t\tthis.expression = statement;\n\t\t}\n\n\t\t@Override\n\t\tpublic String emit() {\n\t\t\treturn preEmitOnce() + MustacheUtils.render(scope, transforms.apply(expression.render(scope))) + postEmitOnce();\n\t\t}\n\n\t\t@Override\n\t\tpublic void transform(CodeTransform transform) {\n\t\t\texpression.transform(transform);\n\t\t}\n\n\t\tstatic <T extends TypeMirror> DefaultAnalysis of(CascadingTypeAnalyzer<?, T, ?> analyzer,\n\t\t\t\tRawStatement statement, InvocationContext<T> context,\n\t\t\t\tMap<String, Object> extraScope) {\n\t\t\tfinal HashMap<String, Object> scope = new HashMap<>();\n\t\t\tscope.put(\"fieldName\", analyzer.fieldAccessor(context));\n\t\t\tscope.put(\"keyName\", context.field.keyName());\n\t\t\tscope.put(\"bundle\", context.bundleContext.bundleObjectName());\n\t\t\tif (extraScope != null)\n\t\t\t\tscope.putAll(extraScope);\n\t\t\treturn new DefaultAnalysis(scope, statement);\n\t\t}\n\n\t\tstatic <T extends TypeMirror> DefaultAnalysis of(CascadingTypeAnalyzer<?, T, ?> analyzer,\n\t\t\t\tString methodName, InvocationContext<T> context) {\n\t\t\tfinal HashMap<String, Object> scope = new HashMap<>();\n\t\t\tscope.put(\"methodName\", methodName);\n\t\t\tRawStatement statement;\n\t\t\tif (context.type == InvocationType.SAVE) {\n\t\t\t\t// field mirror -> target mirror , we don't need to cast\n\t\t\t\tstatement = new InvocationStatement(\n\t\t\t\t\t\t\"{{bundle}}.put{{methodName}}({{keyName}}, {{fieldName}})\");\n\t\t\t} else {\n\t\t\t\tif (analyzer.targetMirror != null) {\n\t\t\t\t\t// when restore, target mirror is the return mirror so we\n\t\t\t\t\t// cast in opposite detection: target mirror -> field mirror\n\t\t\t\t\tfinal String castExpression = analyzer.strategy.function.createCastExpression(\n\t\t\t\t\t\t\tanalyzer, analyzer.targetMirror, context.field.fieldMirror());\n\t\t\t\t\tif (!Strings.isNullOrEmpty(castExpression)) {\n\t\t\t\t\t\tscope.put(\"cast\", true);\n\t\t\t\t\t\tscope.put(\"castExpression\", castExpression);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatement = new InvocationAssignmentStatement(\"{{fieldName}}\",\n\t\t\t\t\t\t\"{{#cast}}({{castExpression}}){{/cast}}{{bundle}}.get{{methodName}}({{keyName}})\");\n\t\t\t}\n\t\t\treturn of(analyzer, statement, context, scope);\n\t\t}\n\n\t}\n\n\tpublic static class ConversionException extends RuntimeException {\n\n\t\tpublic ConversionException(String message) {\n\t\t\tsuper(message);\n\t\t}\n\n\t\tpublic ConversionException(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\t}\n\n\tpublic static class UnknownTypeException extends ConversionException {\n\n\t\t// public final Field<?> field;\n\n\t\tpublic UnknownTypeException(Element<?> element) {\n\t\t\tsuper(\"unknown type \" + element + \"(\" + element.refinedMirror().getClass() + \")\");\n\t\t}\n\n\t\tpublic UnknownTypeException(TypeMirror mirror) {\n\t\t\tsuper(\"unknown type \" + mirror + \"(\" + mirror.getClass() + \")\");\n\t\t}\n\n\t}\n\n\t@FunctionalInterface\n\tpublic interface CodeTransform extends Function<String, String> {\n\n\t}\n\n\tpublic static class CodeTransforms {\n\t\tprivate final ArrayList<CodeTransform> transforms = new ArrayList<>();\n\n\t\tpublic void append(CodeTransform transform) {\n\t\t\tthis.transforms.add(transform);\n\t\t}\n\n\t\tpublic String apply(String source) {\n\t\t\tfor (CodeTransform transform : transforms) {\n\t\t\t\tsource = transform.apply(source);\n\t\t\t}\n\t\t\treturn source;\n\t\t}\n\t}\n\n\tpublic interface RawStatement {\n\n\t\tString render(Object scope);\n\n\t\tvoid transform(CodeTransform transformation);\n\n\t}\n\n\tpublic static class InvocationStatement implements RawStatement {\n\n\t\tprivate String template;\n\n\t\tpublic InvocationStatement(String template) {\n\t\t\tthis.template = template;\n\t\t}\n\n\t\t@Override\n\t\tpublic String render(Object scope) {\n\t\t\treturn MustacheUtils.render(scope, template) + \";\\n\";\n\t\t}\n\n\t\t@Override\n\t\tpublic void transform(CodeTransform transform) {\n\t\t\ttemplate = transform.apply(template);\n\t\t}\n\t}\n\n\tpublic static class InvocationAssignmentStatement extends InvocationStatement {\n\n\t\tprivate final String variable;\n\n\t\tpublic InvocationAssignmentStatement(String variable, String template) {\n\t\t\tsuper(template);\n\t\t\tthis.variable = variable;\n\t\t}\n\n\t\t@Override\n\t\tpublic String render(Object scope) {\n\t\t\treturn MustacheUtils.render(scope, variable) + \" = \" + super.render(scope);\n\t\t}\n\t}\n}\n", "answers": ["\t\t\ttypeSpecBuilder.superclass(type(className, T));"], "length": 2674, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "5f821555b06138e64ff9cac2865bf4ee66e16ffa34a74a1f"}
{"input": "package com.crowdin.logic;\nimport com.crowdin.client.Crowdin;\nimport com.crowdin.client.CrowdinProjectCacheProvider;\nimport com.crowdin.client.FileBean;\nimport com.crowdin.client.RequestBuilder;\nimport com.crowdin.client.core.model.PatchRequest;\nimport com.crowdin.client.labels.model.Label;\nimport com.crowdin.client.languages.model.Language;\nimport com.crowdin.client.sourcefiles.model.*;\nimport com.crowdin.util.FileUtil;\nimport com.crowdin.util.NotificationUtil;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport org.apache.commons.lang.StringUtils;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\nimport static com.crowdin.Constants.MESSAGES_BUNDLE;\nimport static com.crowdin.util.FileUtil.joinPaths;\nimport static com.crowdin.util.FileUtil.normalizePath;\nimport static com.crowdin.util.FileUtil.sepAtStart;\nimport static com.crowdin.util.FileUtil.unixPath;\n\n\n\n\npublic class SourceLogic {\n\n    private final VirtualFile root;\n    private final Project project;\n    private final Crowdin crowdin;\n    private final Map<String, FileInfo> filePaths;\n    private final Map<String, Directory> dirPaths;\n    private final Map<String, Long> labels;\n    private final Long branchId;\n\n    public static void processSources(\n        Project project, VirtualFile root,\n        Crowdin crowdin, CrowdinProjectCacheProvider.CrowdinProjectCache projectCache,\n        Branch branch, boolean preserveHierarchy, Map<FileBean, List<VirtualFile>> sourcesToUpload\n    ) {\n        Map<String, FileInfo> filePaths = projectCache.getFileInfos(branch);\n        Map<String, Directory> dirPaths = projectCache.getDirs().getOrDefault(branch, new HashMap<>());\n        Map<String, Long> labels = SourceLogic.prepareLabels(crowdin, new ArrayList<>(sourcesToUpload.keySet()));\n        Long branchId = (branch != null) ? branch.getId() : null;\n\n        SourceLogic sourceLogic = new SourceLogic(root, project, crowdin, filePaths, dirPaths, labels, branchId);\n        for (FileBean fileBean : sourcesToUpload.keySet()) {\n            if (fileBean.getExcludedTargetLanguages() != null && !fileBean.getExcludedTargetLanguages().isEmpty()) {\n                SourceLogic.checkExcludedTargetLanguages(fileBean.getExcludedTargetLanguages(), projectCache.getSupportedLanguages(), projectCache.getProjectLanguages());\n            }\n        }\n        for (FileBean fileBean : sourcesToUpload.keySet()) {\n            for (VirtualFile source : sourcesToUpload.get(fileBean)) {\n                try {\n                    sourceLogic.uploadSource(source, fileBean, preserveHierarchy);\n                } catch (Exception e) {\n                    NotificationUtil.logErrorMessage(project, e);\n                    NotificationUtil.showErrorMessage(project, e.getMessage());\n                }\n            }\n        }\n    }\n\n    public SourceLogic(\n        VirtualFile root, Project project,\n        Crowdin crowdin,\n        Map<String, FileInfo> filePaths, Map<String, Directory> dirPaths, Map<String, Long> labelMap, Long branchId\n    ) {\n        this.root = root;\n        this.project = project;\n        this.crowdin = crowdin;\n        this.filePaths = filePaths;\n        this.dirPaths = dirPaths;\n        this.labels = labelMap;\n        this.branchId = branchId;\n    }\n\n    public void uploadSource(VirtualFile source, FileBean fileBean, boolean preserveHierarchy) {\n        try {\n            VirtualFile pathToPattern = FileUtil.getBaseDir(source, fileBean.getSource());\n\n            GeneralFileExportOptions exportOptions = new GeneralFileExportOptions();\n\n            String path;\n            String parentPath;\n            if (preserveHierarchy) {\n                String relativePathToPattern = FileUtil.findRelativePath(root, pathToPattern);\n                String patternPathToFile = FileUtil.findRelativePath(pathToPattern, source.getParent());\n", "context": "src/main/java/com/crowdin/util/FileUtil.java\npublic static String normalizePath(String path) {\n    return path.replaceAll(\"[\\\\\\\\/]+\", SystemUtils.IS_OS_WINDOWS ? \"\\\\\\\\\" : \"/\");\n}\nsrc/main/java/com/crowdin/client/FileBean.java\n@Data\npublic class FileBean {\n\n    private String source;\n    private String translation;\n    private List<String> excludedTargetLanguages;\n    private List<String> labels;\n}\nsrc/main/java/com/crowdin/client/RequestBuilder.java\npublic class RequestBuilder {\n\n    public static UpdateFileRequest updateFile(Long storageId, ExportOptions exportOptions) {\n        UpdateFileRequest request = new UpdateFileRequest();\n        request.setExportOptions(exportOptions);\n        request.setStorageId(storageId);\n        return request;\n    }\n\n    public static AddFileRequest addFile(\n        Long storageId, String name, Long branchId, Long directoryId,\n        String type, ExportOptions exportOptions\n    ) {\n        AddFileRequest request = new AddFileRequest();\n        request.setStorageId(storageId);\n        request.setName(name);\n        request.setBranchId(branchId);\n        request.setDirectoryId(directoryId);\n        request.setExportOptions(exportOptions);\n        return request;\n    }\n\n    public static AddBranchRequest addBranch(String name) {\n        AddBranchRequest request = new AddBranchRequest();\n        request.setName(name);\n        return request;\n    }\n\n    public static UploadTranslationsRequest uploadTranslation(Long fileId, Long storageId) {\n        UploadTranslationsRequest request = new UploadTranslationsRequest();\n        request.setFileId(fileId);\n        request.setStorageId(storageId);\n        return request;\n    }\n\n    public static AddLabelRequest addLabel(String title) {\n        AddLabelRequest request = new AddLabelRequest();\n        request.setTitle(title);\n        return request;\n    }\n\n    public static List<PatchRequest> updateExcludedTargetLanguages(List<String> excludedTargetLanguages) {\n        List<PatchRequest> request = new ArrayList<>();\n        PatchRequest patchRequest = new PatchRequest();\n        patchRequest.setPath(\"/excludedTargetLanguages\");\n        patchRequest.setOp(PatchOperation.REPLACE);\n        patchRequest.setValue(excludedTargetLanguages);\n        request.add(patchRequest);\n        return request;\n    }\n}\nsrc/main/java/com/crowdin/client/Crowdin.java\npublic class Crowdin {\n\n    private final Long projectId;\n\n    private final Project project;\n\n    private final com.crowdin.client.Client client;\n\n    public Crowdin(@NotNull Project project, @NotNull Long projectId, @NotNull String apiToken, String baseUrl) {\n        this.project = project;\n        this.projectId = projectId;\n        Credentials credentials = new Credentials(apiToken, null, baseUrl);\n        ClientConfig clientConfig = ClientConfig.builder()\n            .userAgent(Util.getUserAgent())\n            .build();\n        this.client = new Client(credentials, clientConfig);\n    }\n\n    public Long addStorage(String fileName, InputStream content) {\n        try {\n            return this.client.getStorageApi()\n                .addStorage(fileName, content)\n                .getData()\n                .getId();\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public void updateSource(Long sourceId, UpdateFileRequest request) {\n        try {\n            this.client.getSourceFilesApi()\n                .updateOrRestoreFile(this.projectId, sourceId, request)\n                .getData();\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public URL downloadFile(Long fileId) {\n        try {\n            return url(this.client.getSourceFilesApi()\n                .downloadFile(this.projectId, fileId)\n                .getData());\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public void addSource(AddFileRequest request) {\n        try {\n            this.client.getSourceFilesApi()\n                .addFile(this.projectId, request)\n                .getData();\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public void editSource(Long fileId, List<PatchRequest> request) {\n        try {\n            this.client.getSourceFilesApi()\n                .editFile(this.projectId, fileId, request);\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public void uploadTranslation(String languageId, UploadTranslationsRequest request) {\n        try {\n            this.client.getTranslationsApi()\n                .uploadTranslations(this.projectId, languageId, request)\n                .getData();\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public Directory addDirectory(AddDirectoryRequest request) {\n        try {\n            return this.client.getSourceFilesApi()\n                .addDirectory(this.projectId, request)\n                .getData();\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public com.crowdin.client.projectsgroups.model.Project getProject() {\n        try {\n            return this.client.getProjectsGroupsApi()\n                .getProject(this.projectId)\n                .getData();\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public List<Language> extractProjectLanguages(com.crowdin.client.projectsgroups.model.Project crowdinProject) {\n        return crowdinProject.getTargetLanguages();\n    }\n\n    public File downloadTranslations(VirtualFile baseDir, Long branchId) {\n        try {\n            CrowdinTranslationCreateProjectBuildForm buildProjectTranslationRequest = new CrowdinTranslationCreateProjectBuildForm();\n            buildProjectTranslationRequest.setBranchId(branchId);\n            ResponseObject<ProjectBuild> projectBuildResponseObject = this.client.getTranslationsApi().buildProjectTranslation(this.projectId, buildProjectTranslationRequest);\n            Long buildId = projectBuildResponseObject.getData().getId();\n\n            boolean finished = false;\n            while (!finished) {\n                ResponseObject<ProjectBuild> projectBuildStatusResponseObject = this.client.getTranslationsApi().checkBuildStatus(this.projectId, buildId);\n                finished = projectBuildStatusResponseObject.getData().getStatus().equalsIgnoreCase(\"finished\");\n            }\n\n            ResponseObject<DownloadLink> downloadLinkResponseObject = this.client.getTranslationsApi().downloadProjectTranslations(this.projectId, buildId);\n            String link = downloadLinkResponseObject.getData().getUrl();\n\n            File file = new File(baseDir.getCanonicalPath() + \"/all.zip\");\n            try (ReadableByteChannel readableByteChannel = Channels.newChannel(new URL(link).openStream()); FileOutputStream fos = new FileOutputStream(file)) {\n                fos.getChannel().transferFrom(readableByteChannel, 0, Long.MAX_VALUE);\n            }\n            return file;\n        } catch (Exception e) {\n            NotificationUtil.showErrorMessage(this.project, this.getErrorMessage(e));\n            return null;\n        }\n    }\n\n    public List<Language> getSupportedLanguages() {\n        try {\n            return client.getLanguagesApi().listSupportedLanguages(500, 0)\n                .getData()\n                .stream()\n                .map(ResponseObject::getData)\n                .collect(Collectors.toList());\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public Map<Long, Directory> getDirectories(Long branchId) {\n        try {\n            return executeRequestFullList((limit, offset) ->\n                    this.client.getSourceFilesApi()\n                        .listDirectories(this.projectId, branchId, null, true, limit, offset)\n                        .getData()\n                )\n                .stream()\n                .map(ResponseObject::getData)\n                .filter(dir -> Objects.equals(dir.getBranchId(), branchId))\n                .collect(Collectors.toMap(Directory::getId, Function.identity()));\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public List<com.crowdin.client.sourcefiles.model.FileInfo> getFiles(Long branchId) {\n        try {\n            return executeRequestFullList((limit, offset) ->\n                    this.client.getSourceFilesApi()\n                        .listFiles(this.projectId, branchId, null, null, true, 500, 0)\n                        .getData()\n                )\n                .stream()\n                .map(ResponseObject::getData)\n                .filter(file -> Objects.equals(file.getBranchId(), branchId))\n                .collect(Collectors.toList());\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    /**\n     * @param request represents function that downloads list of models and has two args (limit, offset)\n     * @param <T> represents model\n     * @return list of models accumulated from request function\n     */\n    private static <T> List<T> executeRequestFullList(BiFunction<Integer, Integer, List<T>> request) {\n        List<T> models = new ArrayList<>();\n        long counter;\n        int limit = 500;\n        do {\n            List<T> responseModels = request.apply(limit, models.size());\n            models.addAll(responseModels);\n            counter = responseModels.size();\n        } while (counter == limit);\n        return models;\n    }\n\n    public Branch addBranch(AddBranchRequest request) {\n        try {\n            return this.client.getSourceFilesApi()\n                .addBranch(this.projectId, request)\n                .getData();\n        } catch (Exception e) {\n            String errorMessage = this.getErrorMessage(e);\n            if (errorMessage.contains(\"regexNotMatch File name can't contain\")) {\n                throw new RuntimeException(MESSAGES_BUNDLE.getString(\"errors.branch_contains_forbidden_symbols\"));\n            } else {\n                throw new RuntimeException(errorMessage, e);\n            }\n        }\n    }\n\n    public Optional<Branch> getBranch(String name) {\n        List<ResponseObject<Branch>> branches = this.client.getSourceFilesApi().listBranches(this.projectId, name, 500, null).getData();\n        return branches.stream()\n                .filter(e -> e.getData().getName().equalsIgnoreCase(name))\n                .map(ResponseObject::getData)\n                .findFirst();\n    }\n\n    public Map<String, Branch> getBranches() {\n        try {\n            return executeRequestFullList((limit, offset) ->\n                this.client.getSourceFilesApi()\n                    .listBranches(this.projectId, null, limit, offset)\n                    .getData()\n            )\n                .stream()\n                .map(ResponseObject::getData)\n                .collect(Collectors.toMap(Branch::getName, Function.identity()));\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public List<LanguageProgress> getProjectProgress() {\n        try {\n            return executeRequestFullList((limit, offset) -> this.client.getTranslationStatusApi()\n                .getProjectProgress(this.projectId, limit, offset, null)\n                .getData()\n                .stream()\n                .map(ResponseObject::getData)\n                .collect(Collectors.toList()));\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public List<FileProgress> getLanguageProgress(String languageId) {\n        try {\n            return executeRequestFullList((limit, offset) -> this.client.getTranslationStatusApi()\n                .getLanguageProgress(this.projectId, languageId, limit, offset)\n                .getData()\n                .stream()\n                .map(ResponseObject::getData)\n                .collect(Collectors.toList()));\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public List<Label> listLabels() {\n        try {\n        return executeRequestFullList((limit, offset) -> this.client.getLabelsApi()\n            .listLabels(this.projectId, limit, offset)\n            .getData()\n            .stream()\n            .map(ResponseObject::getData)\n            .collect(Collectors.toList()));\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    public Label addLabel(AddLabelRequest request) {\n        try {\n            return this.client.getLabelsApi()\n                .addLabel(this.projectId, request)\n                .getData();\n        } catch (Exception e) {\n            throw new RuntimeException(this.getErrorMessage(e), e);\n        }\n    }\n\n    private String getErrorMessage(Exception e) {\n        if (e instanceof HttpException) {\n            HttpException ex = (HttpException) e;\n            String code = (ex.getError() != null && ex.getError().getCode() != null) ? ex.getError().getCode() : \"<empty_code>\";\n            String message = (ex.getError() != null && ex.getError().getMessage() != null) ? ex.getError().getMessage() : \"<empty_message>\";\n            if (\"401\".equals(code)) {\n                return MESSAGES_BUNDLE.getString(\"errors.authorize\");\n            } else {\n                return String.format(\"Error from server: <Code: %s, Message: %s>\", code, message);\n            }\n        } else if (e instanceof HttpBadRequestException) {\n            HttpBadRequestException ex = (HttpBadRequestException) e;\n            if (ex.getErrors() == null) {\n                return \"HttpBadRequestException<empty_error>\";\n            }\n            if (ex.getErrors() == null) {\n                return \"Wrong parameters: <Key: <empty_key>, Code: <empty_code>, Message: <empty_message>\";\n            }\n            return \"Wrong parameters: \\n\" + ex.getErrors()\n                .stream()\n                .map(HttpBadRequestException.ErrorHolder::getError)\n                .flatMap(holder -> holder.getErrors()\n                    .stream()\n                    .filter(Objects::nonNull)\n                    .map(error ->\n                        String.format(\"<Key: %s, Code: %s, Message: %s>\",\n                            (holder.getKey() != null) ? holder.getKey() : \"<empty_key>\",\n                            (error.getCode() != null) ? error.getCode() : \"<empty_code>\",\n                            (error.getMessage() != null) ? error.getMessage() : \"<empty_message>\")))\n                .collect(Collectors.joining(\"\\n\"));\n        } else {\n            return e.getMessage();\n        }\n    }\n\n    private boolean concurrentIssue(Exception error) {\n        return this.codeExists(error, \"notUnique\") || this.codeExists(error, \"parallelCreation\");\n    }\n\n    private boolean codeExists(Exception e, String code) {\n        if (e instanceof HttpException) {\n            return ((HttpException) e).getError().getCode().equalsIgnoreCase(code);\n        } else if (e instanceof HttpBadRequestException) {\n            return ((HttpBadRequestException) e).getErrors().stream()\n                    .anyMatch(error -> error.getError().getErrors().stream()\n                            .anyMatch(er -> er.getCode().equalsIgnoreCase(code))\n                    );\n        } else {\n            return false;\n        }\n    }\n\n    private Long waitAndFindBranch(String name) throws Exception {\n        return RetryUtil.retry(() -> {\n            ResponseList<Branch> branchResponseList = this.client.getSourceFilesApi().listBranches(this.projectId, name, 500, null);\n            ResponseObject<Branch> branchResponseObject = branchResponseList.getData().stream()\n                    .filter(branch -> branch.getData().getName().equalsIgnoreCase(name))\n                    .findFirst().orElse(null);\n            if (branchResponseObject != null) {\n                return branchResponseObject.getData().getId();\n            } else {\n                throw new Exception(String.format(MESSAGES_BUNDLE.getString(\"errors.find_branch\"), name));\n            }\n        });\n    }\n\n    private boolean customMessage(Exception e) {\n        if (e instanceof HttpException) {\n            HttpException ex = (HttpException) e;\n            if (ex.getError().getCode().equalsIgnoreCase(\"401\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private URL url(DownloadLink downloadLink) {\n        try {\n            return new URL(downloadLink.getUrl());\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unexpected exception: malformed download url: \" + downloadLink.getUrl(), e);\n        }\n    }\n\n}\nsrc/main/java/com/crowdin/util/FileUtil.java\npublic static String joinPaths(String... paths) {\n    return FileUtil.normalizePath(String.join(File.separator, paths));\n}\nsrc/main/java/com/crowdin/Constants.java\npublic static final ResourceBundle MESSAGES_BUNDLE = ResourceBundle.getBundle(\"messages/messages\");\nsrc/main/java/com/crowdin/client/CrowdinProjectCacheProvider.java\npublic class CrowdinProjectCacheProvider {\n\n    private static CrowdinProjectCache crowdinProjectCache;\n\n    private static boolean outdated = false;\n    private static List<String> outdatedBranches = new ArrayList<>();\n\n    @Data\n    public static class CrowdinProjectCache {\n        private boolean managerAccess;\n        private Project project;\n        private List<Language> SupportedLanguages;\n        private List<Language> ProjectLanguages;\n        private Map<String, Branch> branches;\n        private Map<Branch, Map<String, Directory>> dirs;\n        private Map<Branch, Map<String, ? extends FileInfo>> fileInfos;\n        private LanguageMapping languageMapping;\n\n        /**\n         * Returns project information with additional information. Should be checked for managerAccess before accessing this value\n         * @return Project information with additional information\n         */\n        public ProjectSettings getProjectSettings() {\n            this.checkForManagerAccess();\n            return (ProjectSettings) this.getProject();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public Map<String, FileInfo> getFileInfos(Branch branch) {\n            if (fileInfos.containsKey(branch)) {\n                return (Map<String, FileInfo>) fileInfos.get(branch);\n            } else {\n                Map<String, FileInfo> newMap = new HashMap<>();\n                fileInfos.put(branch, newMap);\n                return newMap;\n            }\n        }\n\n        /**\n         * Returns list of files with additional information. Should be checked for managerAccess before accessing this values\n         * @return List of files with additional information\n         */\n        @SuppressWarnings(\"unchecked\")\n        public Map<String, File> getFiles(Branch branch) {\n            this.checkForManagerAccess();\n            if (fileInfos.containsKey(branch)) {\n                return (Map<String, File>) fileInfos.get(branch);\n            } else {\n                Map<String, File> newMap = new HashMap<>();\n                fileInfos.put(branch, newMap);\n                return newMap;\n            }\n        }\n\n        /**\n         * Returns server language mapping. Should be checked for managerAccess before accessing this value\n         * @return Langauge Mapping from server\n         */\n        public LanguageMapping getLanguageMapping() {\n            this.checkForManagerAccess();\n            return languageMapping;\n        }\n\n        private void checkForManagerAccess() {\n            if (!isManagerAccess()) {\n                throw new RuntimeException(\"Unexpected error: Manager access is required\");\n            }\n        }\n\n    }\n\n    private CrowdinProjectCacheProvider() {\n\n    }\n\n    public synchronized static CrowdinProjectCache getInstance(Crowdin crowdin, String branchName, boolean update) {\n        if (crowdinProjectCache == null) {\n            crowdinProjectCache = new CrowdinProjectCache();\n        }\n        if (crowdinProjectCache.getProject() == null || update) {\n            crowdinProjectCache.setProject(crowdin.getProject());\n            crowdinProjectCache.setManagerAccess(crowdinProjectCache.getProject() instanceof ProjectSettings);\n            if (crowdinProjectCache.isManagerAccess()) {\n                crowdinProjectCache.setLanguageMapping(\n                    LanguageMapping.fromServerLanguageMapping(crowdinProjectCache.getProjectSettings().getLanguageMapping()));\n            }\n        }\n        if (crowdinProjectCache.getSupportedLanguages() == null) {\n            crowdinProjectCache.setSupportedLanguages(crowdin.getSupportedLanguages());\n        }\n        if (crowdinProjectCache.getProjectLanguages() == null || update) {\n            crowdinProjectCache.setProjectLanguages(crowdin.extractProjectLanguages(crowdinProjectCache.getProject()));\n        }\n        if (crowdinProjectCache.getBranches() == null || outdated || update) {\n            crowdinProjectCache.setBranches(crowdin.getBranches());\n            outdated = false;\n        }\n        if (crowdinProjectCache.getFileInfos() == null) {\n            crowdinProjectCache.setFileInfos(new HashMap<>());\n        }\n        if (crowdinProjectCache.getDirs() == null) {\n            crowdinProjectCache.setDirs(new HashMap<>());\n        }\n        if ((branchName != null && !branchName.isEmpty()) && !crowdinProjectCache.getBranches().containsKey(branchName)) {\n            return crowdinProjectCache;\n        }\n        Branch branch = crowdinProjectCache.getBranches().get(branchName);\n        if (!crowdinProjectCache.getFileInfos().containsKey(branch)\n                || !crowdinProjectCache.getDirs().containsKey(branch)\n                || outdatedBranches.contains(branchName)\n                || update) {\n            Long branchId = (branch != null) ? branch.getId() : null;\n            List<com.crowdin.client.sourcefiles.model.FileInfo> files = crowdin.getFiles(branchId);\n            Map<Long, Directory> dirs = crowdin.getDirectories(branchId);\n            crowdinProjectCache.getFileInfos().put(branch, CrowdinFileUtil.buildFilePaths(files, dirs));\n            crowdinProjectCache.getDirs().put(branch, CrowdinFileUtil.buildDirPaths(dirs));\n            outdatedBranches.remove(branchName);\n        }\n        return crowdinProjectCache;\n    }\n\n    public synchronized static void outdateBranch(String branchName) {\n        outdated = true;\n        outdatedBranches.add(branchName);\n    }\n}\nsrc/main/java/com/crowdin/util/FileUtil.java\npublic static String unixPath(String path) {\n    return path.replaceAll(\"[\\\\\\\\/]+\", \"/\");\n}\nsrc/main/java/com/crowdin/util/FileUtil.java\npublic static String sepAtStart(String path) {\n    return File.separator + noSepAtStart(path);\n}\nsrc/main/java/com/crowdin/util/NotificationUtil.java\npublic final class NotificationUtil {\n\n    private static final NotificationGroup GROUP_DISPLAY_ID_INFO =\n            new NotificationGroup(\"Crowdin\",\n                    NotificationDisplayType.BALLOON, true);\n\n    private static final NotificationGroup GROUP_DISPLAY_ID_INFO_LOG =\n        new NotificationGroup(\"Crowdin\",\n            NotificationDisplayType.NONE, true);\n    private static boolean isDebug = false;\n    private static SimpleDateFormat logDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n\n\n    private static final String TITLE = \"Crowdin\";\n\n    private NotificationUtil() {\n        throw new UnsupportedOperationException();\n    }\n\n    public static void showInformationMessage(@NotNull Project project, @NotNull String message) {\n        showMessage(project, message, NotificationType.INFORMATION);\n    }\n\n    public static void showErrorMessage(@NotNull Project project, @NotNull String message) {\n        showMessage(project, message, NotificationType.ERROR);\n    }\n\n    public static void showWarningMessage(@NotNull Project project, @NotNull String message) {\n        showMessage(project, message, NotificationType.WARNING);\n    }\n\n    private static void showMessage(Project project, String message, NotificationType type) {\n        ApplicationManager.getApplication().invokeLater(() -> {\n            Notification notification = GROUP_DISPLAY_ID_INFO.createNotification(TITLE, message, type, null);\n            Notifications.Bus.notify(notification, project);\n        });\n    }\n\n    public static void setLogDebugLevel(boolean isDebug) {\n        NotificationUtil.isDebug = isDebug;\n    }\n\n    public static void logDebugMessage(@NotNull Project project, @NotNull String message) {\n        logMessage(project, message, NotificationType.INFORMATION, \"DEBUG\");\n    }\n\n    public static void logErrorMessage(@NotNull Project project, @NotNull Exception e) {\n        Throwable rootCause = ExceptionUtils.getRootCause(e);\n        logMessage(project, ExceptionUtils.getStackTrace((rootCause != null) ? rootCause : e), NotificationType.ERROR, \"ERROR\");\n    }\n\n    private static void logMessage(@NotNull Project project, @NotNull String message, @NotNull NotificationType type, String level) {\n        if (isDebug) {\n            String formattedMessage = String.format(\"%s %s : %s\", logDateFormat.format(new Date()), level, message);\n            ApplicationManager.getApplication().invokeLater(() -> {\n                Notification notification = GROUP_DISPLAY_ID_INFO_LOG.createNotification(TITLE, formattedMessage, type, null);\n                Notifications.Bus.notify(notification, project);\n            });\n        }\n    }\n}\nsrc/main/java/com/crowdin/util/FileUtil.java\npublic final class FileUtil {\n\n    public static final String PATH_SEPARATOR = FileSystems.getDefault().getSeparator();\n    public static final String PATH_SEPARATOR_REGEX = \"\\\\\".equals(PATH_SEPARATOR) ? \"\\\\\\\\\" : PATH_SEPARATOR;\n\n    private FileUtil() {\n        throw new UnsupportedOperationException();\n    }\n\n    public static VirtualFile getProjectBaseDir(Project project) {\n        String baseDirString = project.getBasePath();\n        return findVFileByPath(baseDirString);\n    }\n\n    public static VirtualFile findVFileByPath(String path) {\n        return LocalFileSystem.getInstance().findFileByPath(path);\n    }\n\n    public static String findRelativePath(@NonNull VirtualFile baseDir, @NonNull VirtualFile file) {\n        return StringUtils.removeStart(file.getCanonicalPath(), baseDir.getCanonicalPath())\n            .replaceAll(\"^[\\\\\\\\/]+\", \"\");\n//        @AvailableSince(\"181.2784.17\")\n//        return VfsUtil.findRelativePath(baseDir, file, java.io.File.separatorChar);\n    }\n\n    public static VirtualFile getBaseDir(VirtualFile file, String relativePath) {\n        VirtualFile dir = file;\n        int depth = FileUtil.splitPath(relativePath.replaceAll(\"^[\\\\\\\\/]?\\\\*\\\\*[\\\\\\\\/]?\", \"\")).length;\n        for (int i = depth; i > 0; i--) {\n            if (dir.getParent() == null) {\n                break;\n            }\n            dir = dir.getParent();\n        }\n        return dir;\n    }\n\n    public static List<VirtualFile> getSourceFilesRec(VirtualFile root, String source) {\n        int sepIndex = source.indexOf(\"/\");\n        List<VirtualFile> files = new ArrayList<>();\n        boolean isDir = sepIndex != -1;\n        String searchable = (isDir) ? source.substring(0, sepIndex) : source;\n        if (\"**\".equals(searchable) && isDir) {\n            for (VirtualFile child : root.getChildren()) {\n                if (child.isDirectory()) {\n                    files.addAll(getSourceFilesRec(child, source));\n                }\n            }\n            files.addAll(getSourceFilesRec(root, source.substring(sepIndex + 1)));\n        } else if (searchable.contains(\"*\")) {\n            String searchableRegex = searchable.replace(\"*\", \".*\");\n            for (VirtualFile child : root.getChildren()) {\n                if (!child.isDirectory() && !isDir && child.getName().matches(searchableRegex)) {\n                    files.add(child);\n                } else if (child.isDirectory() && isDir && child.getName().matches(searchableRegex)) {\n                    files.addAll(getSourceFilesRec(child, source.substring(sepIndex+1)));\n                }\n            }\n        } else {\n            VirtualFile foundChild = root.findChild(searchable);\n            if (foundChild != null) {\n                if (foundChild.isDirectory() && isDir) {\n                    files.addAll(getSourceFilesRec(foundChild, source.substring(sepIndex+1)));\n                } else if (!foundChild.isDirectory() && !isDir) {\n                    files.add(foundChild);\n                }\n            }\n        }\n        return files;\n    }\n\n    public static List<File> walkDir(Path dir) {\n        try {\n            return java.nio.file.Files.walk(dir)\n                    .filter(java.nio.file.Files::isRegularFile)\n                    .map(Path::toFile)\n                    .collect(Collectors.toList());\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static Predicate<String> filePathRegex(String filePathPattern, boolean preserveHierarchy) {\n        if (preserveHierarchy) {\n            return Pattern.compile(\"^\" + PlaceholderUtil.formatSourcePatternForRegex(noSepAtStart(filePathPattern)) + \"$\").asPredicate();\n        } else {\n            List<String> sourcePatternSplits = Arrays.stream(splitPath(noSepAtStart(filePathPattern)))\n                .map(PlaceholderUtil::formatSourcePatternForRegex)\n                .collect(Collectors.toList());\n\n            StringBuilder sourcePatternRegex = new StringBuilder();\n            for (int i = 0; i < sourcePatternSplits.size()-1; i++) {\n                sourcePatternRegex.insert(0, \"(\")\n                    .append(sourcePatternSplits.get(i)).append(PATH_SEPARATOR_REGEX).append(\")?\");\n            }\n            sourcePatternRegex.insert(0, FileUtil.PATH_SEPARATOR_REGEX).insert(0, \"^\")\n                .append(sourcePatternSplits.get(sourcePatternSplits.size()-1)).append(\"$\");\n\n            return Pattern.compile(sourcePatternRegex.toString()).asPredicate();\n        }\n    }\n\n    public static void downloadFile(Object requestor, VirtualFile file, InputStream data) throws IOException {\n        File tempFile = FileUtilRt.createTempFile(RandomStringUtils.randomAlphanumeric(9), \".crowdin.tmp\", true);\n        try (OutputStream tempFileOutput = new FileOutputStream(tempFile)) {\n            FileUtilRt.copy(data, tempFileOutput);\n        }\n\n        WriteAction.runAndWait(() -> {\n            try (InputStream tempFileInput = new FileInputStream(tempFile); OutputStream fileOutput = file.getOutputStream(requestor)) {\n                FileUtilRt.copy(tempFileInput, fileOutput);\n            }\n        });\n    }\n\n    public static VirtualFile createIfNeededFilePath(Object requestor, VirtualFile root, String filePath) throws IOException {\n        String[] splitFilePath = splitPath(noSepAtStart(filePath));\n        return WriteAction.computeAndWait(() -> {\n            VirtualFile dir = root;\n            for (int i = 0; i < splitFilePath.length - 1; i++) {\n                VirtualFile child = dir.findChild(splitFilePath[i]);\n                dir = (child != null) ? child : dir.createChildDirectory(requestor, splitFilePath[i]);\n            }\n            VirtualFile file = dir.findChild(splitFilePath[splitFilePath.length-1]);\n            return (file != null) ? file : dir.createChildData(requestor, splitFilePath[splitFilePath.length-1]);\n        });\n    }\n\n    public static String normalizePath(String path) {\n        return path.replaceAll(\"[\\\\\\\\/]+\", SystemUtils.IS_OS_WINDOWS ? \"\\\\\\\\\" : \"/\");\n    }\n\n    public static String unixPath(String path) {\n        return path.replaceAll(\"[\\\\\\\\/]+\", \"/\");\n    }\n\n    public static String[] splitPath(String path) {\n        return path.split(\"[\\\\\\\\/]+\");\n    }\n\n    public static String joinPaths(String... paths) {\n        return FileUtil.normalizePath(String.join(File.separator, paths));\n    }\n\n    public static String noSepAtStart(String path) {\n        return path.replaceAll(\"^[\\\\\\\\/]+\", \"\");\n    }\n\n    public static String sepAtStart(String path) {\n        return File.separator + noSepAtStart(path);\n    }\n\n    public static String noSepAtEnd(String path) {\n        return path.replaceAll(\"[\\\\\\\\/]+$\", \"\");\n    }\n\n    public static String sepAtEnd(String path) {\n        return noSepAtEnd(path) + PATH_SEPARATOR;\n    }\n}\n", "answers": ["                path = sepAtStart(normalizePath(joinPaths(relativePathToPattern, patternPathToFile, source.getName())));"], "length": 2616, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "0af8a4d6da92d00ea240eb42cd7be0a8acb7aaad5f5df9e3"}
{"input": "package FastFootShoesHistoricDataLoader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.apache.geode.demo.fastfootshoes.model.Alert;\nimport org.apache.geode.demo.fastfootshoes.model.Customer;\nimport org.apache.geode.demo.fastfootshoes.model.MarkUp;\nimport org.apache.geode.demo.fastfootshoes.model.Product;\nimport org.apache.geode.demo.fastfootshoes.model.Transaction;\nimport org.apache.geode.demo.fastfootshoes.repositories.AlertRepository;\nimport org.apache.geode.demo.fastfootshoes.repositories.CustomerRepository;\nimport org.apache.geode.demo.fastfootshoes.repositories.MarkUpRepository;\nimport org.apache.geode.demo.fastfootshoes.repositories.ProductRepository;\nimport org.apache.geode.demo.fastfootshoes.repositories.TransactionRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.supercsv.cellprocessor.ParseDate;\nimport org.supercsv.cellprocessor.ParseDouble;\nimport org.supercsv.cellprocessor.ParseInt;\nimport org.supercsv.cellprocessor.constraint.NotNull;\nimport org.supercsv.cellprocessor.ift.CellProcessor;\nimport org.supercsv.io.CsvBeanReader;\nimport org.supercsv.io.ICsvBeanReader;\nimport org.supercsv.prefs.CsvPreference;\n\n\n/**\n * This class reads CSV files from the class path and loads them into the cluster\n * as Key/Value pairs\n * @author lshannon\n *\n */\n@Component\npublic class CacheLoader {\n\t\n\tprivate static final String RECORDS_ADDED_TO_GEM_FIRE = \" Records Added To GemFire: \";\n\tprivate ICsvBeanReader beanReader;\n\tprivate List<String> errorLog = new ArrayList<String>();\n\tprivate List<String> activityLog = new ArrayList<String>();\n\n\t@Autowired\n\tCustomerRepository customerRepository;\n\t\n\t@Autowired\n\tProductRepository productRepository;\n\t\n\t@Autowired\n\tTransactionRepository transactionRepository;\n\t\n\t@Autowired\n\tMarkUpRepository markupRepository;\n\t\n\t@Autowired", "context": "FastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/repositories/AlertRepository.java\npublic interface AlertRepository extends GemfireRepository<Alert, String> {\n\n\n}\nFastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/model/Customer.java\n@Region(\"Customer\")\npublic class Customer {\n\t\n\tprivate String name;\n\tprivate String emailAddress;\n\tprivate String city;\n\tprivate Date birthday;\n\t\n\t//this ID will act as the key when doing puts/gets into the cluster\n\t@Id\n\tprivate String id;\n\t\n\tpublic Customer() {\n\t\t\n\t}\n\t\n\t\n\t\n\tpublic Customer(String name, String emailAddress, String city,\n\t\t\tDate birthday, String id) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.emailAddress = emailAddress;\n\t\tthis.city = city;\n\t\tthis.birthday = birthday;\n\t\tthis.id = id;\n\t}\n\n\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getCity() {\n\t\treturn city;\n\t}\n\t\n\tpublic void setCity(String city) {\n\t\tthis.city = city;\n\t}\n\t\n\tpublic Date getBirthday() {\n\t\treturn birthday;\n\t}\n\t\n\tpublic void setBirthday(Date birthday) {\n\t\tthis.birthday = birthday;\n\t}\n\n\tpublic String getEmailAddress() {\n\t\treturn emailAddress;\n\t}\n\n\tpublic void setEmailAddress(String emailAddress) {\n\t\tthis.emailAddress = emailAddress;\n\t}\n\t\n\t\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Customer [name=\" + name + \", emailAddress=\" + emailAddress\n\t\t\t\t+ \", city=\" + city + \", birthday=\" + birthday + \", id=\" + id\n\t\t\t\t+ \"]\";\n\t}\n\n}\nFastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/model/Alert.java\n@Region(\"Alert\")\npublic class Alert {\n\t\n\tprivate String message;\n\tprivate Date messageDate;\n\t\n\t//this ID will act as the key when doing puts/gets into the cluster\n\t@Id\n\tprivate String id;\n\t\n\t\n\tpublic String getMessage() {\n\t\treturn message;\n\t}\n\tpublic void setMessage(String message) {\n\t\tthis.message = message;\n\t}\n\tpublic Date getMessageDate() {\n\t\treturn messageDate;\n\t}\n\tpublic void setMessageDate(Date messageDate) {\n\t\tthis.messageDate = messageDate;\n\t}\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Alert [message=\" + message + \", messageDate=\" + messageDate\n\t\t\t\t+ \", id=\" + id + \"]\";\n\t}\n\n}\nFastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/model/Product.java\n@Region(\"Product\")\npublic class Product {\n\t\n\tprivate int stockOnHand;\n\tprivate double wholeSalePrice;\n\tprivate String brand;\n\tprivate String name;\n\tprivate String type;\n\tprivate String color;\n\tprivate double size;\n\tprivate String gender;\n\t\n\t//this ID will act as the key when doing puts/gets into the cluster\n\t@Id\n\tprivate String id;\n\t\n\tpublic int getStockOnHand() {\n\t\treturn stockOnHand;\n\t}\n\tpublic void setStockOnHand(int stockOnHand) {\n\t\tthis.stockOnHand = stockOnHand;\n\t}\n\tpublic double getWholeSalePrice() {\n\t\treturn wholeSalePrice;\n\t}\n\tpublic void setWholeSalePrice(double wholeSalePrice) {\n\t\tthis.wholeSalePrice = wholeSalePrice;\n\t}\n\tpublic String getBrand() {\n\t\treturn brand;\n\t}\n\tpublic void setBrand(String brand) {\n\t\tthis.brand = brand;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getType() {\n\t\treturn type;\n\t}\n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\t}\n\tpublic double getSize() {\n\t\treturn size;\n\t}\n\tpublic void setSize(double size) {\n\t\tthis.size = size;\n\t}\n\tpublic String getGender() {\n\t\treturn gender;\n\t}\n\tpublic void setGender(String gender) {\n\t\tthis.gender = gender;\n\t}\n\tpublic String getColor() {\n\t\treturn color;\n\t}\n\tpublic void setColor(String color) {\n\t\tthis.color = color;\n\t}\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Product [stockOnHand=\" + stockOnHand + \", wholeSalePrice=\"\n\t\t\t\t+ wholeSalePrice + \", brand=\" + brand + \", name=\" + name\n\t\t\t\t+ \", type=\" + type + \", color=\" + color + \", size=\" + size\n\t\t\t\t+ \", gender=\" + gender + \", id=\" + id + \"]\";\n\t}\n\t\n}\nFastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/repositories/ProductRepository.java\npublic interface ProductRepository extends GemfireRepository<Product, String> {\n\n\tCollection<Product> findAll();\n\t\n\tProduct findById(String id);\n\n\t@Query(\"SELECT * FROM /Product p WHERE p.stockOnHand > 0\")\n\tCollection<Product> findAllWithStock();\n\n\t@Query(\"SELECT * FROM /Product p WHERE p.brand = $1 and p.\\\"type\\\"= $2 and p.gender = $3\")\n\tCollection<Product> findAllByBrandTypeGender(String brand, String type,\n\t\t\tString gender);\n\n\t@Query(\"SELECT * FROM /Product p   WHERE  p.brand = $1 and  p.\\\"type\\\" = $2 and  p.gender = $3 and  p.stockOnHand > 0\")\n\tCollection<Product> findAllWithStockByBrandTypeGender(String brand,String type, String gender);\n\n    @Query(\"SELECT * FROM /Product p WHERE p.\\\"type\\\" LIKE $1 and p.stockOnHand > 0\")\n    Collection<Product> findAllWithStockByBrand( String brand) ;\n\n}\nFastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/repositories/TransactionRepository.java\npublic interface TransactionRepository extends GemfireRepository<Transaction, String> {\n\t\n\tTransaction findById(String id);\n\t\n\t@Query(\"SELECT * FROM /Transaction t WHERE t.customerId = $1\")\n\tCollection<Transaction> findByCustomer(String id);\n\t\n\t@Query(\"SELECT * FROM /Transaction t where t.orderStatus = 'open'\")\n\tCollection<Transaction> findOpenOrders();\n\t\n\t@Query(\"SELECT * FROM /Transaction t where (t.orderStatus = 'open' or t.orderStatus = 'shipped') and t.customerId = $1\")\n\tCollection<Transaction> findCompletedOrders(String id);\n\t\n\t@Query(\"SELECT count(*) FROM /Transaction t where t.orderStatus = 'open'\")\n\tInteger getCount();\n\n\n}\nFastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/model/Transaction.java\n@Region(\"Transaction\")\npublic class Transaction {\n\n\tprivate String customerId;\n\tprivate Date transactionDate;\n\tprivate String productId;\n\tprivate int quantity;\n\tprivate double retailPrice;\n\tprivate String orderStatus;\n\t@Id\n\tprivate String id;\n\tprivate double markUp;\n\tpublic static String ORDER_COMPLETED = \"shipped\";\n\tpublic static String ORDER_CANCELLED = \"cancelled\";\n\tpublic static String ORDER_OPEN = \"open\";\n\t\n\tpublic Date getTransactionDate() {\n\t\treturn transactionDate;\n\t}\n\t\n\tpublic void setTransactionDate(Date transactionDate) {\n\t\tthis.transactionDate = transactionDate;\n\t}\n\t\n\tpublic String getProductId() {\n\t\treturn productId;\n\t}\n\n\tpublic void setProductId(String productId) {\n\t\tthis.productId = productId;\n\t}\n\n\n\tpublic int getQuantity() {\n\t\treturn quantity;\n\t}\n\t\n\tpublic void setQuantity(int quantity) {\n\t\tthis.quantity = quantity;\n\t}\n\t\n\t\n\tpublic double getRetailPrice() {\n\t\treturn retailPrice;\n\t}\n\t\n\tpublic void setRetailPrice(double retailPrice) {\n\t\tthis.retailPrice = retailPrice;\n\t}\n\t\n\tpublic String getOrderStatus() {\n\t\treturn orderStatus;\n\t}\n\t\n\tpublic void setOrderStatus(String orderStatus) {\n\t\tthis.orderStatus = orderStatus;\n\t}\n\n\tpublic double getMarkUp() {\n\t\treturn markUp;\n\t}\n\n\tpublic void setMarkUp(double markUp) {\n\t\tthis.markUp = markUp;\n\t}\n\n\tpublic String getCustomerId() {\n\t\treturn customerId;\n\t}\n\n\tpublic void setCustomerId(String customerId) {\n\t\tthis.customerId = customerId;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Transaction [customerId=\" + customerId + \", transactionDate=\"\n\t\t\t\t+ transactionDate + \", productId=\" + productId + \", quantity=\"\n\t\t\t\t+ quantity + \", retailPrice=\" + retailPrice + \", orderStatus=\"\n\t\t\t\t+ orderStatus + \", id=\" + id + \", markUp=\" + markUp + \"]\";\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tTransaction other = (Transaction) obj;\n\t\tif (customerId == null) {\n\t\t\tif (other.customerId != null)\n\t\t\t\treturn false;\n\t\t} else if (!customerId.equals(other.customerId))\n\t\t\treturn false;\n\t\tif (id == null) {\n\t\t\tif (other.id != null)\n\t\t\t\treturn false;\n\t\t} else if (!id.equals(other.id))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(markUp) != Double\n\t\t\t\t.doubleToLongBits(other.markUp))\n\t\t\treturn false;\n\t\tif (orderStatus == null) {\n\t\t\tif (other.orderStatus != null)\n\t\t\t\treturn false;\n\t\t} else if (!orderStatus.equals(other.orderStatus))\n\t\t\treturn false;\n\t\tif (productId == null) {\n\t\t\tif (other.productId != null)\n\t\t\t\treturn false;\n\t\t} else if (!productId.equals(other.productId))\n\t\t\treturn false;\n\t\tif (quantity != other.quantity)\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(retailPrice) != Double\n\t\t\t\t.doubleToLongBits(other.retailPrice))\n\t\t\treturn false;\n\t\tif (transactionDate == null) {\n\t\t\tif (other.transactionDate != null)\n\t\t\t\treturn false;\n\t\t} else if (!transactionDate.equals(other.transactionDate))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\t\n\t\n}\nFastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/model/MarkUp.java\n@Region(\"MarkUp\")\npublic class MarkUp {\n\n\tprivate double rate;\n\tprivate String levelName;\n\tprivate int qualifyingTransactionCountFloor;\n\tprivate int qualifyingTransactionCountCeiling;\n\t\n\t//this ID will act as the key when doing puts/gets into the cluster\n\t@Id\n\tprivate String id;\n\t\n\tpublic double getRate() {\n\t\treturn rate;\n\t}\n\tpublic void setRate(double rate) {\n\t\tthis.rate = rate;\n\t}\n\tpublic String getLevelName() {\n\t\treturn levelName;\n\t}\n\tpublic void setLevelName(String levelName) {\n\t\tthis.levelName = levelName;\n\t}\n\tpublic int getQualifyingTransactionCountFloor() {\n\t\treturn qualifyingTransactionCountFloor;\n\t}\n\tpublic void setQualifyingTransactionCountFloor(\n\t\t\tint qualifyingTransactionCountFloor) {\n\t\tthis.qualifyingTransactionCountFloor = qualifyingTransactionCountFloor;\n\t}\n\tpublic int getQualifyingTransactionCountCeiling() {\n\t\treturn qualifyingTransactionCountCeiling;\n\t}\n\tpublic void setQualifyingTransactionCountCeiling(\n\t\t\tint qualifyingTransactionCountCeiling) {\n\t\tthis.qualifyingTransactionCountCeiling = qualifyingTransactionCountCeiling;\n\t}\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"MarkUp [rate=\" + rate + \", levelName=\" + levelName\n\t\t\t\t+ \", qualifyingTransactionCountFloor=\"\n\t\t\t\t+ qualifyingTransactionCountFloor\n\t\t\t\t+ \", qualifyingTransactionCountCeiling=\"\n\t\t\t\t+ qualifyingTransactionCountCeiling + \", id=\" + id + \"]\";\n\t}\n\t\n}\nFastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/repositories/CustomerRepository.java\npublic interface CustomerRepository extends GemfireRepository<Customer, String> {\n\n\tCustomer findByEmailAddress(String emailAddress);\n\n\tCustomer findById(String id);\n\n\t//TODO could this not be by attribute?\n\t@Query(\"SELECT * FROM /Transaction t WHERE t.customerId = $1\")\n\tCollection<Transaction> findByCustomer(@Param(\"customerId\") String id);\n\n\t@Query(\"SELECT * FROM /Customer t WHERE t.emailAddress LIKE $1\")\n\tCollection<Customer> searchCustomers(String email);\n\n}\nFastFootShoesModel/src/main/java/org/apache/geode/demo/fastfootshoes/repositories/MarkUpRepository.java\npublic interface MarkUpRepository extends GemfireRepository<MarkUp, String> {\n\n}\n", "answers": ["\tAlertRepository alertRepository;"], "length": 1393, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "5793684b2e55650422bc523a52fe1a347210a02d3fc1a27c"}
{"input": "from django.conf import settings\nfrom django.contrib.auth.models import User\nfrom django.core.urlresolvers import reverse\nfrom django.forms.models import modelform_factory, modelformset_factory\nfrom django.http import HttpResponse, HttpResponseRedirect, HttpResponseNotFound\nfrom django.shortcuts import render_to_response, get_object_or_404\nfrom django.template import RequestContext\nfrom django.template.loader import render_to_string\nfrom django.utils.translation import ugettext_lazy as _\nfrom redsolutioncms.forms import UserCreationForm, FrontpageForm, CategoryForm\nfrom redsolutioncms.importpath import importpath\nfrom redsolutioncms.loader import home_dir, process_cmd_string, project_dir\nfrom redsolutioncms.make import AlreadyMadeException\nfrom redsolutioncms.models import CMSSettings, ProcessTask, Category\nfrom redsolutioncms.packages import load_package_list\n        from urllib2 import HTTPError, URLError\nimport os, subprocess, datetime\n\nCONFIG_FILES = ['manage', 'settings', 'urls', ]\n\n\ndef index(request):\n    \"\"\"\n    Shows greetings form, base settings form: project name, database settings, etc.\n    \"\"\"\n    cms_settings = CMSSettings.objects.get_settings()\n    cms_settings.initialized = True\n    cms_settings.save()\n    SettingsForm = modelform_factory(CMSSettings, exclude=['initialized',\n        'frontpage_handler', 'base_template'])\n    if request.method == 'POST':\n        form = SettingsForm(data=request.POST, files=request.FILES, instance=cms_settings)\n        if form.is_valid():\n            form.save()\n            return HttpResponseRedirect(reverse('apps'))\n    else:\n        form = SettingsForm(instance=cms_settings)\n    return render_to_response('redsolutioncms/index.html', {\n        'form': form,\n    }, context_instance=RequestContext(request))\n\n\ndef apps(request):\n    \"\"\"\n    Second step. Shows available packages listing.\n    \"\"\"\n    FormsetClass = modelformset_factory(Category, CategoryForm)\n\n    if request.method == 'POST':\n        formset = FormsetClass(request.POST)\n        if formset.is_valid():\n            formset.save()\n            return HttpResponseRedirect(reverse('load'))\n    else:\n        try:\n            load_package_list()\n        except (HTTPError, URLError):\n            return render_to_response('redsolutioncms/error.html', {\n                'error': _('Htttp problem with index server'),\n            })\n        formset = FormsetClass()\n    return render_to_response('redsolutioncms/apps.html', {\n        'formset': formset,\n    }, context_instance=RequestContext(request))\n\n\ndef load(request):\n    \"\"\"\n    Show wait circle loader, fetch packages from index site.\n    Template has AJAX checker, so user will be redirected to next step automatically.\n    Saves installation information for packages.\n    Makes settings.py, urls.py, manage.py with installed setup-packages.\n    Syncdb for setup-packages.\n    \"\"\"\n    task = ProcessTask.objects.create(\n        task=process_cmd_string('\"%(django)s\" kill_runserver'),\n        lock=True, wait=True)\n    ProcessTask.objects.create(task=process_cmd_string('\"%(django)s\" install_packages'), wait=True)\n    ProcessTask.objects.create(task=process_cmd_string('\"%(django)s\" change_settings'), wait=True)\n    ProcessTask.objects.create(task=process_cmd_string('\"%(django)s\" syncdb --noinput'), wait=True)\n    ProcessTask.objects.create(task=process_cmd_string('\"%(django)s\" runserver --noreload'))\n    return render_to_response('redsolutioncms/wait.html', {\n        'task_id':task.id,\n        'redirect_to': reverse('custom'),\n        'start_task_id':task.id,\n        'title': _('Downloading packages'),\n    }, context_instance=RequestContext(request))\n\ndef custom(request):\n    \"\"\"\n    User can go to detail settings for packages or can ask to make project.\n    Make files for new project.\n    \"\"\"\n    cms_settings = CMSSettings.objects.get_settings()\n    if request.method == 'POST':\n        entry_points = ['redsolutioncms']\n        cms_settings.base_template = 'base_template.html'\n        cms_settings.save()\n        # handle frontpage\n        frontpage_form = FrontpageForm(request.POST)\n        if frontpage_form.is_valid():\n            frontpage_form.save()\n            for package in cms_settings.packages.installed():\n                for entry_point in package.entry_points.all():\n                    entry_points.append(entry_point.module)\n            make_objects = []\n            for entry_point in entry_points:\n                try:\n                    make_object = importpath('.'.join([entry_point, 'make', 'make']))\n                except ImportError, error:\n                    print 'Entry point %s has no make object.' % entry_point\n                    continue\n                else:\n                    make_objects.append(make_object)\n\n            for make_object in make_objects:\n                make_object.flush()\n            for make_object in make_objects:\n                try:\n                    make_object.premake()\n", "context": "redsolutioncms/models.py\nclass Category(models.Model):\n    '''Category for package'''\n\n    class Meta:\n        ordering = ['-required', 'id']\n\n    settings = models.ForeignKey(CMSSettings, related_name='categories')\n    name = models.CharField(verbose_name=_('Category name'), max_length=255)\n    parent = models.ForeignKey('self', null=True)\n    required = models.BooleanField(verbose_name=_('Mandatory category'), default=False)\n\n    def __unicode__(self):\n        return self.name\n\n    def verbose_name(self):\n        '''\n        Hardcoded categories names \n        '''\n        verbose_names = {\n            'frontpage': _('Frontpage handlers'),\n            'content': _('Content plugins'),\n            'utilities': _('Utilities'),\n            'templates': _('Templates for site'),\n            'other': _('Other applications'),\n        }\n        return verbose_names.get(self.name, self.name)\nredsolutioncms/packages.py\ndef load_package_list():\n    \"\"\"\n    Creates objects in CMSPackages model for all modules at PYPI\n    \"\"\"\n    cms_settings = CMSSettings.objects.get_settings()\n    all_packages = search_index('redsolutioncms')\n\n    # Flush old apps?\n    cms_settings.packages.all().delete()\n    cms_settings.categories.all().delete()\n    # fill database again\n    # create required catagories\n    Category.objects.create(name='frontpage', required=True, settings=cms_settings)\n    Category.objects.create(name='templates', required=True, settings=cms_settings)\n\n    for package in all_packages.itervalues():\n        cms_package = cms_settings.packages.create(\n            selected=False,\n            package=package['name'],\n            version=package['version'],\n            verbose_name=package['name'].replace('django-', '').replace('redsolutioncms.', ''),\n            description=package['summary'],\n            screenshot=package.get('screenshot'),\n        )\n        # fill cms_settings foreign key\n        cms_settings.packages.add(cms_package)\n        if package.get('categories'):\n            for category in package['categories']:\n                category_obj, created = Category.objects.get_or_create(\n                    name=category, settings=cms_settings)\n                category_obj.packages.add(cms_package)\n        else:\n            other_category, created = Category.objects.get_or_create(\n                name='other', settings=cms_settings)\n            other_category.packages.add(cms_package)\nredsolutioncms/forms.py\nclass CategoryForm(forms.ModelForm):\n    class Meta:\n        model = Category\n        fields = ['id']\n\n    def __init__(self, *args, **kwds):\n        super(CategoryForm, self).__init__(*args, **kwds)\n        category = self.instance\n        if category.name == 'templates':\n            self.fields['template'] = forms.ChoiceField(\n                label=_('Template'),\n                widget=forms.RadioSelect,\n                choices=[(package.id, package.screenshot) for package in category.packages.all()],\n                required=False,\n            )\n        else:\n            for package in category.packages.all():\n                self.fields['package_%s' % package.id] = forms.BooleanField(\n                    label=_(package.verbose_name), required=False, help_text=_(package.description))\n\n    def clean(self):\n        if self.instance.name == 'templates':\n            template_id = self.cleaned_data.get('template', '')\n            if not self.instance.packages.filter(id__in=template_id).count():\n                raise forms.ValidationError(_('You must select only one package from this category'))\n        else:\n            packages = self.cleaned_data.keys()\n            packages.remove('id')\n            package_ids = [p.replace('package_', '') for p in packages\n                if self.cleaned_data[p]]\n            if self.instance.required:\n                if not self.instance.packages.filter(id__in=package_ids).count():\n                    raise forms.ValidationError(_('You must select at least one package from this category'))\n        return self.cleaned_data\n\n    def save(self, *args, **kwds):\n        if self.instance.name == 'templates':\n            package_ids = [self.cleaned_data.get('template', ''), ]\n        else:\n            packages = self.cleaned_data.keys()\n            packages.remove('id')\n            package_ids = [p.replace('package_', '') for p in packages\n                if self.cleaned_data[p]]\n        # select:\n        self.instance.packages.filter(id__in=package_ids).update(selected=True)\n        # unselect others:\n        self.instance.packages.exclude(id__in=package_ids).update(selected=False)\n        super(CategoryForm, self).save(*args, **kwds)\nredsolutioncms/forms.py\nclass UserCreationForm(forms.Form):\n    username = forms.RegexField(label=_(\"Username\"), max_length=30, regex=r'^\\w+$',\n        help_text=_(\"Required. 30 characters or fewer. Alphanumeric characters only (letters, digits and underscores).\"),\n        error_message=_(\"This value must contain only letters, numbers and underscores.\"), initial='admin')\n    password1 = forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput)\n    password2 = forms.CharField(label=_(\"Password confirmation\"), widget=forms.PasswordInput)\n    email = forms.EmailField(label=_(\"E-mail\"), max_length=75, initial='admin@example.com')\n\n    def clean_password2(self):\n        password1 = self.cleaned_data.get(\"password1\", \"\")\n        password2 = self.cleaned_data[\"password2\"]\n        if password1 != password2:\n            raise forms.ValidationError(_(\"The two password fields didn't match.\"))\n        return password2\nredsolutioncms/models.py\nclass ProcessTask(models.Model):\n    task = models.CharField(verbose_name=_('task'), max_length=255)\n    pid = models.IntegerField(verbose_name=_('process pid'), blank=True, null=True)\n    lock = models.BooleanField(verbose_name=_('task inactive'), default=False)\n    executed = models.BooleanField(verbose_name=_('task executed'), default=False)\n    process_finished = models.BooleanField(verbose_name=_('process finished'), default=False)\n    wait = models.BooleanField(verbose_name=_('wait finish'), default=False)\n\n    def __unicode__(self):\n        return self.task\nredsolutioncms/make.py\nclass AlreadyMadeException(Exception):\n    \"\"\"\n    Exception raise if function in Make class was called twice.\n    \"\"\"\nredsolutioncms/importpath.py\ndef importpath(path, error_text=None):\n    \"\"\"\n    Import value by specified ``path``.\n    Value can represent module, class, object, attribute or method.\n    If ``error_text`` is not None and import will\n    raise ImproperlyConfigured with user friendly text.\n    \"\"\"\n    result = None\n    attrs = []\n    parts = path.split('.')\n    exception = None\n    while parts:\n        try:\n            result = __import__('.'.join(parts), {}, {}, [''])\n        except ImportError, e:\n            if exception is None:\n                exception = e\n            attrs = parts[-1:] + attrs\n            parts = parts[:-1]\n        else:\n            break\n    for attr in attrs:\n        try:\n            result = getattr(result, attr)\n        except (AttributeError, ValueError), error:\n            if error_text is not None:\n                raise ImproperlyConfigured('Error: %s can import \"%s\"' % (error_text, path))\n            else:\n                if exception is None:\n                    raise ImportError(path)\n                raise exception\n    return result\nredsolutioncms/forms.py\nclass FrontpageForm(forms.Form):\n\n    def __init__(self, *args, **kwargs):\n        super(FrontpageForm, self).__init__(*args, **kwargs)\n        self.fields['frontpage'] = forms.ChoiceField(\n            label=_('Choose frontpage handler'),\n            choices=self.get_fronpage_handlers(),\n        )\n\n    def get_fronpage_handlers(self):\n        installed_packages = CMSSettings.objects.get_settings().packages.installed()\n        handlers = []\n        for package in installed_packages:\n            for entry_point in package.entry_points.frontpage_handlers():\n                handlers.append((entry_point.module, package.verbose_name),)\n        return handlers\n\n    def save(self):\n        '''Write frontpage setting to global CMS settings'''\n        entry_point = CMSEntryPoint.objects.get(module=self.cleaned_data['frontpage'])\n        cms_settings = CMSSettings.objects.get_settings()\n        cms_settings.frontpage_handler = entry_point\n        cms_settings.save()\nredsolutioncms/loader.py\ndef install_in_home():\ndef run_cmd(cmd, cmd_dict=None):\ndef process_cmd_string(cmd, cmd_dict=None):\ndef run_in_home(cmd):\ndef main():\nredsolutioncms/models.py\nclass CMSSettings(BaseSettings):\n    DATABASE_ENGINES = [\n        ('postgresql_psycopg2', 'postgresql_psycopg2',),\n        ('postgresql', 'postgresql',),\n        ('mysql', 'mysql',),\n        ('sqlite3', 'sqlite3',),\n    ]\n\n    project_name = models.CharField(verbose_name=_('Project name'),\n        max_length=50, default='myproject', help_text=_('Invent a project name'))\n    domain = models.CharField(verbose_name=_('Desired domain'),\n        max_length=50, default='myproject.com', help_text=_('Enter your site domain for configuration'))\n    default_from_email = models.EmailField(verbose_name=_('Default from e-mail'),\n        default='webmaster@example.com',\n        help_text=_('Value for \"DEFAULT_FROM_EMAIL\" and \"SERVER_EMAIL\"'))\n    database_engine = models.CharField(verbose_name=_('Database engine'),\n        max_length=50, choices=DATABASE_ENGINES, default='sqlite3')\n    database_name = models.CharField(verbose_name=_('Database name'),\n        max_length=50, default='myproject.sqlite', help_text=_('In case of sqlite3, database filename'))\n    database_user = models.CharField(verbose_name=_('Database user'),\n        max_length=50, blank=True, default='', help_text=_('Not used with sqlite3'))\n    database_password = models.CharField(verbose_name=_('Database password'),\n        max_length=50, blank=True, default='', help_text=_('Not used with sqlite3'))\n    database_host = models.CharField(verbose_name=_('Database host'),\n        max_length=50, blank=True, default='', help_text=_('Not used with sqlite3'))\n    database_port = models.IntegerField(verbose_name=_('Database port'),\n        blank=True, null=True, help_text=_('Not used with sqlite3'))\n    # hidden fields\n    initialized = models.BooleanField(verbose_name=_('CMS was initialized'), default=False)\n    base_template = models.CharField(verbose_name=_('Base template'), max_length=50, blank=True, default='')\n    frontpage_handler = models.ForeignKey('CMSEntryPoint', related_name='settings', null=True)\n\n    def render_to(self, file_name, template_name, dictionary=None, mode='a+'):\n        \"\"\"\n        ``file_name`` is relative path to destination file.\n            It can be list or tuple to be os.path.joined\n            To make settings.py use: 'settings.py'\n            To make template use: ['..', 'templates', 'base.html']\n            To make media use: ['..', 'media', 'css', 'style.css']\n        \n        ``template_name`` is name of template to be rendered.\n        \n        ``dictionary`` is context dictionary.\n            ``cms_settings`` variable always will be add to context.\n        \n         ``mode`` is mode in witch destination file will be opened.\n             Use 'w' to override old content.\n        \"\"\"\n        if isinstance(file_name, (tuple, list)):\n            file_name = join(*file_name)\n        file_name = join(project_dir, self.project_name, file_name)\n        try:\n            os.makedirs(dirname(file_name))\n        except OSError:\n            pass\n        if dictionary is None:\n            dictionary = {}\n        dictionary['cms_settings'] = self\n        value = render_to_string(template_name, dictionary)\n        value = value.encode('utf-8')\n        open(file_name, mode).write(value)\n\n    def copy_to(self, dst, src, merge=True, mode='wb'):\n        \"\"\"\n        Deprecated. Use ``copy_dir`` or ``copy_file`` instead.\n        Copies directory or file with mergig directories capability.\n        If ``src`` is regular file, copy it in ``dst`` file or ``dst`` dir.\n        If ``src`` is directory, ``dst`` must be directory or must not exist.\n        If ``dst`` dir exists, merge or replace it with ``src`` content, \n        depending on ``merge`` argument\n        \n        Example:\n        cms_settings.copy_to(os.path.join(project_media, 'img'), path_to_images)\n        \"\"\"\n        import warnings\n        warnings.warn('Deprecated. Use ``copy_dir`` or ``copy_file`` instead.')\n\n        # first, check ``src``\n        if isfile(src):\n            self.copy_file(dst, src, mode)\n        if isdir(src):\n            self.copy_dir(dst, src, merge)\n    \n    def copy_file(self, dst, src, mode='wb'):\n        '''\n        Copy or append file content.\n        Mode 'w' is for file rewriting, 'a' for appending to the end of file\n        '''\n        # silently try to make parent dir\n        try:\n            os.makedirs(dirname(dst))\n        except OSError:\n            pass\n        if not exists(dst):\n            shutil.copy(src, dst)\n        else:\n            dst_file = open(dst, mode)\n            src_file = open(src, 'r')\n            dst_file.write(src_file.read())\n            dst_file.close()\n            src_file.close()\n        \n    def copy_dir(self, dst, src, merge=True):\n        '''\n        Copy whole dir recursively.\n        When merge=True, target directory will not be deleted,\n        othwerwise, it will.\n        '''\n        if exists(dst):\n            if isdir(dst):\n                if not merge:\n                    shutil.rmtree(dst)\n                    shutil.copytree(src, dst)\n                else:\n                    merge_dirs(src, dst)\n            else:\n                raise IOError('Error: ``dst`` is not dir')\n        else:\n            shutil.copytree(src, dst)\n\n    def package_was_installed(self, package_name):\n        return package_name in self.installed_packages\n\n    @property\n    def installed_packages(self):\n        return self.packages.installed().values_list('package', flat=True)\n\n    @property\n    def project_dir(self):\n        import warnings\n        warnings.warn('Project dir is deprecated attribute. Use redsolutioncms.loader.project_dir instead')\n        return project_dir\n\n    @property\n    def temp_dir(self):\n        import warnings\n        warnings.warn('Project dir is deprecated attribute. Use redsolutioncms.loader.home_dir instead')\n        return home_dir\n", "answers": ["                except AlreadyMadeException:"], "length": 1433, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "4840cdfd00ab7f23aa464a424033100ed937a3558567acb6"}
{"input": "from .base import BaseMessage\nfrom .records import RecordUpdateMessage, RecordDeleteMessage, RecordCreateMessage\nfrom ..exceptions import PyOrientBadMethodCallException\nfrom ..constants import COMMAND_OP, FIELD_BOOLEAN, FIELD_BYTE, FIELD_CHAR, \\\n    FIELD_INT, FIELD_LONG, FIELD_SHORT, FIELD_STRING, QUERY_SYNC, FIELD_BYTES, \\\n    TX_COMMIT_OP, QUERY_GREMLIN, QUERY_ASYNC, QUERY_CMD, QUERY_TYPES, \\\n    QUERY_SCRIPT\nfrom ..utils import need_connected, need_db_opened, dlog\n            from datetime import datetime\n        self._query = _query\n        return self\n\n    def set_limit(self, _limit):\n        self._limit = _limit\n        return self\n\n    def _read_sync(self):\n\n        # type of response\n        # decode body char with flag continue ( Header already read )\n        response_type = self._decode_field( FIELD_CHAR )\n        if not isinstance(response_type, str):\n            response_type = response_type.decode()\n        res = []\n        if response_type == 'n':\n            self._append( FIELD_CHAR )\n            super( CommandMessage, self ).fetch_response(True)\n            # end Line \\x00\n            return None\n        elif response_type == 'r' or response_type == 'w':\n            res = [ self._read_record() ]\n            self._append( FIELD_CHAR )\n            # end Line \\x00\n            _res = super( CommandMessage, self ).fetch_response(True)\n            if response_type == 'w':\n                res = [ res[0].oRecordData['result'] ]\n        elif response_type == 'a':\n            self._append( FIELD_STRING )\n            self._append( FIELD_CHAR )\n            res = [ super( CommandMessage, self ).fetch_response(True)[0] ]\n        elif response_type == 'l':\n            self._append( FIELD_INT )\n            list_len = super( CommandMessage, self ).fetch_response(True)[0]\n\n            for n in range(0, list_len):\n                res.append( self._read_record() )\n\n            # async-result-type can be:\n            # 0: no records remain to be fetched\n            # 1: a record is returned as a result set\n            # 2: a record is returned as pre-fetched to be loaded in client's\n            #       cache only. It's not part of the result set but the client\n            #       knows that it's available for later access\n            cached_results = self._read_async_records()\n            # cache = cached_results['cached']\n        else:\n            # this should be never happen, used only to debug the protocol\n            msg = b''\n            self._orientSocket._socket.setblocking( 0 )\n            m = self._orientSocket.read(1)\n            while m != \"\":\n                msg += m\n                m = self._orientSocket.read(1)\n\n        return res\n\n    def set_callback(self, func):\n        if hasattr(func, '__call__'):\n            self._callback = func\n        else:\n            raise PyOrientBadMethodCallException( func + \" is not a callable \"\n                                                         \"function\", [])\n        return self\n#\n# TX COMMIT\n#\n# Commits a transaction. This operation flushes all the\n#   pending changes to the server side.\n#\n# Request: (tx-id:int)(using-tx-log:byte)(tx-entry)*(0-byte indicating end-of-records)\n\n#   tx-entry: (operation-type:byte)(cluster-id:short)\n#       (cluster-position:long)(record-type:byte)(entry-content)\n#\n#     entry-content for CREATE: (record-content:bytes)\n#     entry-content for UPDATE: (version:record-version)(content-changed:boolean)(record-content:bytes)\n#     entry-content for DELETE: (version:record-version)\n\n# Response: (created-record-count:int)[(client-specified-cluster-id:short)\n#   (client-specified-cluster-position:long)(created-cluster-id:short)\n#   (created-cluster-position:long)]*(updated-record-count:int)[(updated-cluster-id:short)\n#   (updated-cluster-position:long)(new-record-version:int)]*(count-of-collection-changes:int)\n#   [(uuid-most-sig-bits:long)(uuid-least-sig-bits:long)(updated-file-id:long)(updated-page-index:long)\n#   (updated-page-offset:int)]*\n#\n# Where:\n# tx-id is the Transaction's Id\n# use-tx-log tells if the server must use the Transaction\n#   Log to recover the transaction. 1 = true, 0 = false\n# operation-type can be:\n# 1, for UPDATES\n# 2, for DELETES\n# 3, for CREATIONS\n#\n# record-content depends on the operation type:\n# For UPDATED (1): (original-record-version:int)(record-content:bytes)\n# For DELETED (2): (original-record-version:int)\n# For CREATED (3): (record-content:bytes)\n#\n# This response contains two parts: a map of 'temporary' client-generated\n#   record ids to 'real' server-provided record ids for each CREATED record,\n#   and a map of UPDATED record ids to update record-versions.\n#\n# Look at Optimistic Transaction to know how temporary RecordIDs are managed.\n#\n# The last part or response is referred to RidBag management.\n#   Take a look at the main page for more details.\nclass _TXCommitMessage(BaseMessage):\n    def __init__(self, _orient_socket):\n        super(_TXCommitMessage, self).__init__(_orient_socket)\n\n        self._tx_id = -1\n        self._operation_stack = []\n        self._pre_operation_records = {}\n        self._operation_records = {}\n\n        self._temp_cluster_position_seq = -2\n\n        # order matters\n", "context": "pyorient/constants.py\nFIELD_INT = {\"type\": INT, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nFIELD_LONG = {\"type\": LONG, \"bytes\": 8, \"struct\": None}\npyorient/constants.py\nQUERY_TYPES   = (\n    QUERY_SYNC,\n    QUERY_ASYNC,\n    QUERY_CMD,\n    QUERY_GREMLIN,\n    QUERY_SCRIPT,\n)\npyorient/messages/records.py\nclass RecordUpdateMessage(BaseMessage):\n\n    def __init__(self, _orient_socket ):\n        super( RecordUpdateMessage, self ).__init__(_orient_socket)\n\n        self._data_segment_id = -1  # default\n        self._cluster_id = b'0'\n        self._cluster_position = 0\n        self._record_content = ''\n\n        # True:  content of record has been changed\n        #        and content should be updated in storage\n        # False: the record was modified but its own\n        #        content has not been changed.\n        #        So related collections (e.g. rid-bags) have to be updated, but\n        #        record version and content should not be.\n        # NOT USED before protocol 23\n        self._update_content = True\n\n        # > -1 default Standard document update (version control)\n        self._record_version_policy = -1\n\n        # Used for transactions\n        self._record_version = -1\n\n        self._record_type = RECORD_TYPE_DOCUMENT\n        self._mode_async = 0  # means synchronous mode\n\n        # order matters\n        self._append( ( FIELD_BYTE, RECORD_UPDATE_OP ) )\n\n    @need_db_opened\n    def prepare(self, params=None):\n\n        try:\n            # mandatory if not passed by method\n            self.set_cluster_id( params[0] )\n\n            # mandatory if not passed by method\n            self.set_cluster_position( params[1] )\n\n            # mandatory if not passed by method\n            self._record_content = params[2]\n\n            self._record_version = params[3]  # Optional|Needed for transaction\n\n            self.set_record_type( params[4] )  # optional\n\n            self._record_version_policy = params[5]  # optional\n            self._mode_async = params[6]  # optional\n\n            self._update_content = params[7]  # optional\n\n        except IndexError:\n            # Use default for non existent indexes\n            pass\n\n        record = self._record_content\n        if not isinstance( record, OrientRecord ):\n            record = self._record_content = OrientRecord( record )\n\n        o_record_enc = self.get_serializer().encode(record)\n        self._append( ( FIELD_SHORT, int(self._cluster_id) ) )\n        self._append( ( FIELD_LONG, int(self._cluster_position) ) )\n\n        if self.get_protocol() >= 23:\n            self._append( ( FIELD_BOOLEAN, self._update_content ) )\n\n        self._append( ( FIELD_STRING, o_record_enc ) )\n        self._append( ( FIELD_INT, int(self._record_version_policy) ) )\n        self._append( ( FIELD_BYTE, self._record_type ) )\n        self._append( ( FIELD_BOOLEAN, self._mode_async ) )\n\n        return super( RecordUpdateMessage, self ).prepare()\n\n    def fetch_response(self):\n\n        # skip execution in case of transaction\n        if self._orientSocket.in_transaction is True:\n            return self\n\n        self._append( FIELD_INT )  # record-version\n        result = super( RecordUpdateMessage, self ).fetch_response()\n\n        # There are some strange behaviours with protocols between 19 and 23\n        # the INT ( count-of-collection-changes ) in documentation\n        # is present, but don't know why,\n        #\n        # Not every time this INT is present!!!!\n        # On Protocol version between 21 and 23 record Upload/Create could\n        # not work\n        chng = 0\n        _changes = []\n        if self.get_protocol() > 21:\n            try:\n                chng = self._decode_field( FIELD_INT )\n                \"\"\" count-of-collection-changes \"\"\"\n            except ( PyOrientConnectionException, TypeError ):\n                pass\n\n            try:\n                if chng > 0 and self.get_protocol() > 23:\n\n                    for x in range( 0, chng ):\n                        change = [\n                            self._decode_field( FIELD_LONG ),  # (uuid-most-sig-bits:long)\n                            self._decode_field( FIELD_LONG ),  # (uuid-least-sig-bits:long)\n                            self._decode_field( FIELD_LONG ),  # (updated-file-id:long)\n                            self._decode_field( FIELD_LONG ),  # (updated-page-index:long)\n                            self._decode_field( FIELD_INT )    # (updated-page-offset:int)\n                        ]\n                        _changes.append( change )\n\n            except IndexError:\n                # append an empty field\n                result.append(None)\n\n        self._record_content.update(\n            __version=result[0]\n        )\n\n        return [ self._record_content, chng, _changes ]\n\n    def set_data_segment_id(self, data_segment_id):\n        self._data_segment_id = data_segment_id\n        return self\n\n    def set_cluster_id(self, cluster_id):\n        self._cluster_id = parse_cluster_id(cluster_id)\n        return self\n\n    def set_cluster_position(self, _cluster_position):\n        self._cluster_position = parse_cluster_position(_cluster_position)\n        return self\n\n    def set_record_content(self, record):\n        self._record_content = record\n        return self\n\n    def set_record_type(self, record_type ):\n        if record_type in RECORD_TYPES:\n            # user choice storage if present\n            self._record_type = record_type\n        else:\n            raise PyOrientBadMethodCallException(\n                record_type + ' is not a valid record type', []\n            )\n        return self\n\n    def set_mode_async(self):\n        self._mode_async = 1\n        return self\n\n    def set_record_version_policy(self, _policy):\n        self._record_version_policy = _policy\n        return self\n\n    def set_no_update_content(self):\n        self._update_content = False\n        return self\npyorient/constants.py\nQUERY_GREMLIN = \"com.orientechnologies.orient.graph.gremlin.OCommandGremlin\"\npyorient/constants.py\nFIELD_CHAR = {\"type\": CHAR, \"bytes\": 1, \"struct\": None}\npyorient/messages/base.py\nclass BaseMessage(object):\n\n    def __init__(self, sock=OrientSocket):\n        \"\"\"\n        :type sock: OrientSocket\n        \"\"\"\n        sock.get_connection()\n        self._orientSocket = sock\n        self._protocol = self._orientSocket.protocol\n        self._session_id = self._orientSocket.session_id\n\n        # handles token auth\n        self._auth_token = self._orientSocket.auth_token\n        self._request_token = False\n\n        self._header = []\n        \"\"\":type : list of [str]\"\"\"\n\n        self._body = []\n        \"\"\":type : list of [str]\"\"\"\n\n        self._fields_definition = []\n        \"\"\":type : list of [object]\"\"\"\n\n        self._command = chr(0)\n        self._db_opened = self._orientSocket.db_opened\n        self._connected = self._orientSocket.connected\n\n        self._node_list = []\n        \"\"\":type : list of [OrientNode]\"\"\"\n\n        self._serializer = None\n\n        self._output_buffer = b''\n        self._input_buffer = b''\n\n        # callback function for async queries\n        self._callback = None\n\n        # callback for push received from the server\n        self._push_callback = None\n\n        self._need_token = True\n\n        global in_transaction\n        in_transaction = False\n\n    def get_serializer(self):\n        \"\"\"\n        Lazy return of the serialization, we retrive the type from the :class: `OrientSocket <pyorient.orient.OrientSocket>` object\n        :return: an Instance of the serializer suitable for decoding or encoding\n        \"\"\"\n        if self._orientSocket.serialization_type==OrientSerialization.Binary:\n            return OrientSerialization.get_impl(self._orientSocket.serialization_type,\n                                                self._orientSocket._props)\n        else:\n            return OrientSerialization.get_impl(self._orientSocket.serialization_type)\n\n    def get_orient_socket_instance(self):\n        return self._orientSocket\n\n    def is_connected(self):\n        return self._connected is True\n\n    def database_opened(self):\n        return self._db_opened\n\n    def get_cluster_map(self):\n        \"\"\":type : list of [OrientNode]\"\"\"\n        return self._node_list\n\n\n    def set_session_token( self, token='' ):\n        \"\"\"\n        :param token: Set the request to True to use the token authentication\n        :type token: bool|string\n        :return: self\n        \"\"\"\n        if token != '' and token is not None:\n            if type(token) is bool:\n                self._request_token = token\n            elif type(token) is str or type(token) is bytes:\n                self._request_token = True\n                self._auth_token = token\n                self._db_opened = True\n                self._connected = True\n                self._update_socket_token()\n        return self\n\n    def get_session_token( self ):\n        \"\"\"\n        Retrieve the session token to reuse after\n        :return:\n        \"\"\"\n        return self._auth_token\n\n    def _update_socket_id(self):\n        \"\"\"Force update of socket id from inside the class\"\"\"\n        self._orientSocket.session_id = self._session_id\n        return self\n\n    def _update_socket_token(self):\n        \"\"\"Force update of socket token from inside the class\"\"\"\n        self._orientSocket.auth_token = self._auth_token\n        return self\n\n    def _reset_fields_definition(self):\n        self._fields_definition = []\n\n    def prepare(self, *args):\n\n        # session_id\n        self._fields_definition.insert( 1, ( FIELD_INT, self._session_id ) )\n\n\n        \"\"\"\n        #  Token authentication handling\n        #  we must recognize ConnectMessage and DbOpenMessage messages\n        \"\"\"\n        if self._need_token and self._request_token is True:\n            self._fields_definition.insert(\n                2, ( FIELD_STRING, self._auth_token )\n            )\n\n        self._output_buffer = b''.join(\n            self._encode_field( x ) for x in self._fields_definition\n        )\n        return self\n\n    def get_protocol(self):\n        if self._protocol < 0:\n            self._protocol = self._orientSocket.protocol\n        return self._protocol\n\n    def _decode_header(self):\n\n        # read header's information\n        self._header = [ self._decode_field( FIELD_BYTE ),\n                         self._decode_field( FIELD_INT ) ]\n\n        # decode message errors and raise an exception\n        if self._header[0] == 1:\n\n            # Parse the error\n            exception_class = b''\n            exception_message = b''\n\n            more = self._decode_field( FIELD_BOOLEAN )\n\n            while more:\n                # read num bytes by the field definition\n                exception_class += self._decode_field( FIELD_STRING )\n                exception_message += self._decode_field( FIELD_STRING )\n                more = self._decode_field( FIELD_BOOLEAN )\n\n                if self.get_protocol() > 18:  # > 18 1.6-snapshot\n                    # read serialized version of exception thrown on server side\n                    # useful only for java clients\n                    serialized_exception = self._decode_field( FIELD_STRING )\n                    # trash\n                    del serialized_exception\n\n            raise PyOrientCommandException(\n                exception_class.decode( 'utf8' ),\n                [ exception_message.decode( 'utf8' ) ]\n            )\n\n        elif self._header[0] == 3:\n            # Push notification, Node cluster changed\n            # TODO: UNTESTED CODE!!!\n            # FIELD_BYTE (OChannelBinaryProtocol.PUSH_DATA);  # WRITE 3\n            # FIELD_INT (Integer.MIN_VALUE);  # SESSION ID = 2^-31\n            # 80: \\x50 Request Push 1 byte: Push command id\n            push_command_id = self._decode_field(FIELD_BYTE)\n            push_message = self._decode_field( FIELD_STRING )\n            _, payload = self.get_serializer().decode(push_message)\n            if self._push_callback:\n                self._push_callback(push_command_id, payload)\n\n            end_flag = self._decode_field( FIELD_BYTE )\n\n            # this flag can be set more than once\n            while end_flag == 3:\n                self._decode_field( FIELD_INT )  # FAKE SESSION ID = 2^-31\n                op_code = self._decode_field( FIELD_BYTE )  # 80: 0x50 Request Push\n\n                # REQUEST_PUSH_RECORD\t        79\n                # REQUEST_PUSH_DISTRIB_CONFIG\t80\n                # REQUEST_PUSH_LIVE_QUERY\t    81\n                if op_code == 80:\n                    # for node in\n                    payload = self.get_serializer().decode(\n                        self._decode_field( FIELD_STRING )\n                    )  # JSON WITH THE NEW CLUSTER CFG\n\n                    # reset the nodelist\n                    self._node_list = []\n                    for node in payload['members']:\n                        self._node_list.append( OrientNode( node ) )\n\n                end_flag = self._decode_field( FIELD_BYTE )\n\n            # Try to set the new session id???\n            self._header[1] = self._decode_field( FIELD_INT )  # REAL SESSION ID\n            pass\n\n        from .connection import ConnectMessage\n        from .database import DbOpenMessage\n        \"\"\"\n        #  Token authentication handling\n        #  we must recognize ConnectMessage and DbOpenMessage messages\n            TODO: change this check avoiding cross import,\n            importing a subclass in a super class is bad\n        \"\"\"\n        if not isinstance(self, (ConnectMessage, DbOpenMessage)) \\\n                and self._request_token is True:\n            token_refresh = self._decode_field(FIELD_STRING)\n            if token_refresh != b'':\n                self._auth_token = token_refresh\n                self._update_socket_token()\n\n    def _decode_body(self):\n        # read body\n        for field in self._fields_definition:\n            self._body.append( self._decode_field( field ) )\n\n        # clear field stack\n        self._reset_fields_definition()\n        return self\n\n    def _decode_all(self):\n        self._decode_header()\n        self._decode_body()\n\n    def fetch_response(self, *_continue):\n        \"\"\"\n        # Decode header and body\n        # If flag continue is set( Header already read ) read only body\n        :param _continue:\n        :return:\n        \"\"\"\n        if len(_continue) is not 0:\n            self._body = []\n            self._decode_body()\n            self.dump_streams()\n        # already fetched, get last results as cache info\n        elif len(self._body) is 0:\n            self._decode_all()\n            self.dump_streams()\n        return self._body\n\n    def dump_streams(self):\n        if is_debug_active():\n            if len( self._output_buffer ):\n                print(\"\\nRequest :\")\n                hexdump( self._output_buffer )\n                # print(repr(self._output_buffer))\n            if len( self._input_buffer ):\n                print(\"\\nResponse:\")\n                hexdump( self._input_buffer )\n                # print(repr(self._input_buffer))\n\n    def _append(self, field):\n        \"\"\"\n        @:rtype self: BaseMessage\n        @type field: object\n        \"\"\"\n        self._fields_definition.append( field )\n        return self\n\n    def __str__(self):\n\n        return \"\\n_output_buffer: \\n\" + hexdump( self._output_buffer, 'return' ) \\\n               + \"\\n\\n_input_buffer: \\n\" + hexdump( self._input_buffer, 'return' )\n\n    def send(self):\n        if self._orientSocket.in_transaction is False:\n            self._orientSocket.write( self._output_buffer )\n            self._reset_fields_definition()\n        if is_debug_active():\n            self.dump_streams()\n            # reset output buffer\n            self._output_buffer = b\"\"\n\n        return self\n\n    def close(self):\n        self._orientSocket.close()\n\n    @staticmethod\n    def _encode_field(field):\n\n        # tuple with type\n        t, v = field\n        _content = None\n\n        if t['type'] == INT:\n            _content = struct.pack(\"!i\", v)\n        elif t['type'] == SHORT:\n            _content = struct.pack(\"!h\", v)\n        elif t['type'] == LONG:\n            _content = struct.pack(\"!q\", v)\n        elif t['type'] == BOOLEAN:\n            if sys.version_info[0] < 3:\n                _content = chr(1) if v else chr(0)\n            else:\n                _content = bytes([1]) if v else bytes([0])\n        elif t['type'] == BYTE:\n            if sys.version_info[0] < 3:\n                _content = v\n            else:\n                _content = bytes([ord(v)])\n        elif t['type'] == BYTES:\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRING:\n            if sys.version_info[0] >= 3:\n                if isinstance(v, str):\n                    v = v.encode('utf-8')\n            else:\n                if isinstance(v, unicode):\n                    v = v.encode('utf-8')\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRINGS:\n            _content = b''\n            for s in v:\n                if sys.version_info[0] >= 3:\n                    if isinstance(s, str):\n                        s = s.encode('utf-8')\n                else:\n                    if isinstance(s, unicode):\n                        s = s.encode('utf-8')\n                _content += struct.pack(\"!i\", len(s)) + s\n\n        return _content\n\n    def _decode_field(self, _type):\n        _value = b\"\"\n        # read buffer length and decode value by field definition\n        if _type['bytes'] is not None:\n            _value = self._orientSocket.read( _type['bytes'] )\n        # if it is a string decode first 4 Bytes as INT\n        # and try to read the buffer\n        if _type['type'] == STRING or _type['type'] == BYTES:\n\n            _len = struct.unpack('!i', _value)[0]\n            if _len == -1 or _len == 0:\n                _decoded_string = b''\n            else:\n                _decoded_string = self._orientSocket.read( _len )\n\n            self._input_buffer += _value\n            self._input_buffer += _decoded_string\n\n            return _decoded_string\n\n        elif _type['type'] == RECORD:\n\n            # record_type\n            record_type = self._decode_field( _type['struct'][0] )\n\n            rid = \"#\" + str( self._decode_field( _type['struct'][1] ) )\n            rid += \":\" + str( self._decode_field( _type['struct'][2] ) )\n            \n            version = self._decode_field( _type['struct'][3] )\n            content = self._decode_field( _type['struct'][4] )\n            return {'rid': rid, 'record_type': record_type,\n                    'content': content, 'version': version}\n\n        elif _type['type'] == LINK:\n\n            rid = \"#\" + str( self._decode_field( _type['struct'][0] ) )\n            rid += \":\" + str( self._decode_field( _type['struct'][1] ) )\n            return rid\n\n        else:\n            self._input_buffer += _value\n\n            if _type['type'] == BOOLEAN:\n                return ord(_value) == 1\n            elif _type['type'] == BYTE:\n                return ord(_value)\n            elif _type['type'] == CHAR:\n                return _value\n            elif _type['type'] == SHORT:\n                return struct.unpack('!h', _value)[0]\n            elif _type['type'] == INT:\n                return struct.unpack('!i', _value)[0]\n            elif _type['type'] == LONG:\n                return struct.unpack('!q', _value)[0]\n\n    def _read_async_records(self):\n        \"\"\"\n        # async-result-type byte as trailing byte of a record can be:\n        # 0: no records remain to be fetched\n        # 1: a record is returned as a result set\n        # 2: a record is returned as pre-fetched to be loaded in client's\n        #       cache only. It's not part of the result set but the client\n        #       knows that it's available for later access\n        \"\"\"\n        _status = self._decode_field( FIELD_BYTE )  # status\n\n        while _status != 0:\n\n            try:\n\n                # if a callback for the cache is not set, raise exception\n                if not hasattr(self._callback, '__call__'):\n                    raise AttributeError()\n\n                _record = self._read_record()\n\n                if _status == 1:  # async record type\n                    # async_records.append( _record )  # save in async\n                    self._callback( _record )  # save in async\n                elif _status == 2:  # cache\n                    # cached_records.append( _record )  # save in cache\n                    self._callback( _record )  # save in cache\n\n            except AttributeError:\n                # AttributeError: 'RecordLoadMessage' object has\n                # no attribute '_command_type'\n                raise PyOrientBadMethodCallException(\n                    str(self._callback) + \" is not a callable function\", [])\n            finally:\n                # read new status and flush the debug buffer\n                _status = self._decode_field( FIELD_BYTE )  # status\n\n    def _read_record(self):\n        \"\"\"\n        # The format depends if a RID is passed or an entire\n            record with its content.\n\n        # In case of null record then -2 as short is passed.\n\n        # In case of RID -3 is passes as short and then the RID:\n            (-3:short)(cluster-id:short)(cluster-position:long).\n\n        # In case of record:\n            (0:short)(record-type:byte)(cluster-id:short)\n            (cluster-position:long)(record-version:int)(record-content:bytes)\n\n        :raise: PyOrientNullRecordException\n        :return: OrientRecordLink,OrientRecord\n        \"\"\"\n        marker = self._decode_field( FIELD_SHORT )  # marker\n\n        if marker is -2:\n            raise PyOrientNullRecordException('NULL Record', [])\n        elif marker is -3:\n            res = OrientRecordLink( self._decode_field( FIELD_TYPE_LINK ) )\n        else:\n            # read record\n            __res = self._decode_field( FIELD_RECORD )\n            \n            if self._orientSocket.serialization_type==OrientSerialization.Binary:\n                class_name, data = self.get_serializer().decode(__res['content'])\n            else:\n                # bug in orientdb csv serialization in snapshot 2.0\n                class_name, data = self.get_serializer().decode(__res['content'].rstrip())\n\n\n            res = OrientRecord(\n                dict(\n                    __o_storage=data,\n                    __o_class=class_name,\n                    __version=__res['version'],\n                    __rid=__res['rid']\n                )\n            )\n\n        self.dump_streams()  # debug log\n        self._output_buffer = b''\n        self._input_buffer = b''\n\n        return res\npyorient/constants.py\nQUERY_CMD     = \"com.orientechnologies.orient.core.sql.OCommandSQL\"\npyorient/constants.py\nCOMMAND_OP                 = chr(41)\npyorient/constants.py\nQUERY_SCRIPT  = \"com.orientechnologies.orient.core.command.script.OCommandScript\"\npyorient/constants.py\nFIELD_STRING = {\"type\": STRING, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nFIELD_SHORT = {\"type\": SHORT, \"bytes\": 2, \"struct\": None}\npyorient/messages/records.py\nclass RecordDeleteMessage(BaseMessage):\n\n    def __init__(self, _orient_socket ):\n        super( RecordDeleteMessage, self ).__init__(_orient_socket)\n\n        self._cluster_id = b'0'\n        self._cluster_position = b'0'\n        self._record_version = -1\n        self._mode_async = 0  # means synchronous mode\n\n        # only needed for transactions\n        self._record_type = RECORD_TYPE_DOCUMENT\n\n        # order matters\n        self._append( ( FIELD_BYTE, RECORD_DELETE_OP ) )\n\n    @need_db_opened\n    def prepare(self, params=None):\n\n        try:\n            # mandatory if not passed by method\n            self.set_cluster_id( params[0] )\n\n            # mandatory if not passed by method\n            self.set_cluster_position( params[1] )\n\n            self._record_version = params[2]   # optional\n            self._mode_async = params[3]  # optional\n        except IndexError:\n            # Use default for non existent indexes\n            pass\n\n        self._append( ( FIELD_SHORT, int(self._cluster_id) ) )\n        self._append( ( FIELD_LONG, int(self._cluster_position) ) )\n        self._append( ( FIELD_INT, int(self._record_version) ) )\n        self._append( ( FIELD_BOOLEAN, self._mode_async ) )\n\n        return super( RecordDeleteMessage, self ).prepare()\n\n    def fetch_response(self):\n\n        # skip execution in case of transaction\n        if self._orientSocket.in_transaction is True:\n            return self\n\n        self._append( FIELD_BOOLEAN )  # payload-status\n        return super( RecordDeleteMessage, self ).fetch_response()[0]\n\n    def set_record_version(self, _record_version):\n        self._record_version = _record_version\n        return self\n\n    def set_cluster_id(self, cluster_id):\n        self._cluster_id = parse_cluster_id(cluster_id)\n        return self\n\n    def set_cluster_position(self, _cluster_position):\n        self._cluster_position = parse_cluster_position(_cluster_position)\n        return self\n\n    def set_record_type(self, _record_type):\n        self._record_type = _record_type\n        return self\n\n    def set_mode_async(self):\n        self._mode_async = 1\n        return self\npyorient/exceptions.py\nclass PyOrientBadMethodCallException(PyOrientException):\n    pass\npyorient/constants.py\nQUERY_ASYNC   = \"com.orientechnologies.orient.core.sql.query.OSQLAsynchQuery\"\npyorient/constants.py\nTX_COMMIT_OP               = chr(60)\npyorient/messages/records.py\nclass RecordCreateMessage(BaseMessage):\n\n    def __init__(self, _orient_socket ):\n        super( RecordCreateMessage, self ).__init__(_orient_socket)\n\n        self._data_segment_id = -1  # default\n        self._cluster_id = b'0'\n        self._record_content = OrientRecord\n        self._record_type = RECORD_TYPE_DOCUMENT\n        self._mode_async = 0  # means synchronous mode\n\n        # order matters\n        self._append( ( FIELD_BYTE, RECORD_CREATE_OP ) )\n\n    @need_db_opened\n    def prepare(self, params=None):\n\n        try:\n            # mandatory if not passed by method\n            self.set_cluster_id( params[0] )\n\n            # mandatory if not passed by method\n            self._record_content = params[1]\n\n            self.set_record_type( params[2] )  # optional\n\n        except IndexError:\n            # Use default for non existent indexes\n            pass\n\n        record = self._record_content\n        if not isinstance( record, OrientRecord ):\n            record = self._record_content = OrientRecord( record )\n\n        o_record_enc = self.get_serializer().encode(record)\n        if self.get_protocol() < 24:\n            self._append( ( FIELD_INT, int(self._data_segment_id) ) )\n\n        self._append( ( FIELD_SHORT, int(self._cluster_id) ) )\n        self._append( ( FIELD_STRING, o_record_enc ) )\n        self._append( ( FIELD_BYTE, self._record_type ) )\n        self._append( ( FIELD_BOOLEAN, self._mode_async ) )\n\n        return super( RecordCreateMessage, self ).prepare()\n\n    def fetch_response(self):\n\n        # skip execution in case of transaction\n        if self._orientSocket.in_transaction is True:\n            return self\n\n        if self.get_protocol() > 25:\n            self._append( FIELD_SHORT )  # cluster-id\n\n        self._append( FIELD_LONG )  # cluster-position\n        self._append( FIELD_INT )  # record-version\n        result = super( RecordCreateMessage, self ).fetch_response()\n\n        # There are some strange behaviours with protocols between 19 and 23\n        # the INT ( count-of-collection-changes ) in documentation\n        # is present, but don't know why,\n        #\n        # Not every time this INT is present!!!!\n        # On Protocol version between 21 and 23 record Upload/Create could\n        # not work\n        chng = 0\n        _changes = []\n        if self.get_protocol() > 21:\n            try:\n                chng = self._decode_field( FIELD_INT )\n                \"\"\" count-of-collection-changes \"\"\"\n            except ( PyOrientConnectionException, TypeError ):\n                pass\n\n            try:\n                if chng > 0 and self.get_protocol() > 23:\n\n                    for x in range( 0, chng ):\n                        change = [\n                            self._decode_field( FIELD_LONG ),  # (uuid-most-sig-bits:long)\n                            self._decode_field( FIELD_LONG ),  # (uuid-least-sig-bits:long)\n                            self._decode_field( FIELD_LONG ),  # (updated-file-id:long)\n                            self._decode_field( FIELD_LONG ),  # (updated-page-index:long)\n                            self._decode_field( FIELD_INT )    # (updated-page-offset:int)\n                        ]\n                        _changes.append( change )\n\n            except IndexError:\n                # Should not happen because of protocol check\n                pass\n\n        if self.get_protocol() > 25:\n            rid = \"#\" + str(result[0]) + \":\" + str(result[1])\n            version = result[2]\n        else:\n            rid = \"#\" + self._cluster_id + \":\" + str(result[0])\n            version = result[1]\n\n        self._record_content.update(\n            __version=version,\n            __rid=rid\n        )\n\n        return self._record_content  # [ self._record_content, _changes ]\n\n    def set_data_segment_id(self, data_segment_id):\n        self._data_segment_id = data_segment_id\n        return self\n\n    def set_cluster_id(self, cluster_id):\n        self._cluster_id = parse_cluster_id(cluster_id)\n        return self\n\n    def set_record_content(self, record):\n        self._record_content = record\n        return self\n\n    def set_record_type(self, record_type ):\n        if record_type in RECORD_TYPES:\n            # user choice storage if present\n            self._record_type = record_type\n        else:\n            raise PyOrientBadMethodCallException(\n                record_type + ' is not a valid record type', []\n            )\n        return self\n\n    def set_mode_async(self):\n        self._mode_async = 1\n        return self\npyorient/constants.py\nFIELD_BYTE = {\"type\": BYTE, \"bytes\": 1, \"struct\": None}\npyorient/constants.py\nQUERY_SYNC    = \"com.orientechnologies.orient.core.sql.query.OSQLSynchQuery\"\npyorient/constants.py\nFIELD_BYTES = {\"type\": BYTES, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nFIELD_BOOLEAN = {\"type\": BOOLEAN, \"bytes\": 1, \"struct\": None}\n", "answers": ["        self._append(( FIELD_BYTE, TX_COMMIT_OP ))"], "length": 3275, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "2a5eb8bb3174281996b1e200e17a4ee1935b6c7300fff41f"}
{"input": "package jira.For.Android.TaskDetails;\nimport java.util.Calendar;\nimport java.util.List;\nimport jira.For.Android.DLog;\nimport jira.For.Android.R;\nimport jira.For.Android.Connector.Connector;\nimport jira.For.Android.Connector.ConnectorComments;\nimport jira.For.Android.Connector.ConnectorWorkLog;\nimport jira.For.Android.DataTypes.Comment;\nimport jira.For.Android.DataTypes.DataTypesMethods;\nimport jira.For.Android.DataTypes.Issue;\nimport jira.For.Android.ImagesCacher.ImagesCacher;\nimport jira.For.Android.PagerView.ViewForPagerInterface;\nimport jira.For.Android.TaskDetails.TaskDetailsActivity.Tabs;\nimport jira.For.Android.TaskDetails.Comments.AddCommentThread;\nimport jira.For.Android.TaskDetails.Comments.LoadCommentsThread;\nimport jira.For.Android.TaskDetails.WorkLog.LoadWorkLogThread;\nimport android.app.Activity;\nimport android.content.Context;\nimport android.text.Editable;\nimport android.text.TextWatcher;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnTouchListener;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\n\n\n// Klasa zajmuje się zwracaniem napompowanych layoutów i tytułów\n\nclass ViewsForTaskDetails implements ViewForPagerInterface {\n\n\tTaskDetailsActivity activity;", "context": "android app/jiraForAndroid/src/jira/For/Android/TaskDetails/TaskDetailsActivity.java\nenum Tabs {\n\tbasicInfo, comments, worklog, attachments;\n\n\tstatic Tabs fromInt(int a) {\n\t\tswitch (a) {\n\t\t\tcase 0:\n\t\t\t\treturn comments;\n\t\t\tcase 1:\n\t\t\t\treturn basicInfo;\n\t\t\tcase 2:\n\t\t\t\treturn worklog;\n\t\t\tcase 3:\n\t\t\t\treturn attachments;\n\t\t}\n\t\treturn null;\n\t}\n}\nandroid app/jiraForAndroid/src/jira/For/Android/TaskDetails/Comments/LoadCommentsThread.java\npublic class LoadCommentsThread extends Thread<List<Comment>> {\n\n\tIssue task;\n\n\tprivate final ConnectorComments connectorComments;\n\n\tpublic LoadCommentsThread(View view, TaskDetailsActivity activity,\n\t                          Issue task, ConnectorComments connectorComments) {\n\t\tsuper(view, activity);\n\t\tthis.task = task;\n\t\tthis.connectorComments = connectorComments;\n\t}\n\n\t@Override\n\tprotected void onPreExecute() {\n\t\tsuper.onPreExecute();\n\t}\n\n\tprotected synchronized void onPostExecute(List<Comment> result) {\n\t\tsuper.hideProgressBar();\n\t\t// TODO Connector ma zwraca� nulla jak nic nie ma naprawde!\n\t\tListView listView = (ListView) activity\n\t\t        .findViewById(R.id.comments_list_listview);\n\t\tif (result == null) {\n\t\t\tresult = new ArrayList<Comment>();\n\t\t}\n\t\tCommentsAdapter adapter = new CommentsAdapter(\n\t\t        activity.getBaseContext(), result);\n\n\t\tlistView.setAdapter(adapter);\n\t\tlistView.setEmptyView(activity\n\t\t        .findViewById(R.id.comments_list_no_comments));\n\t}\n\n\t@Override\n\tprotected synchronized List<Comment> doInBackground(Void... params) {\n\t\ttry {\n\t\t\treturn connectorComments.getComments(task.getKey());\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\tsetException(e);\n\t\t}\n\t\treturn null;\n\t}\n\n}\nandroid app/jiraForAndroid/src/jira/For/Android/Connector/ConnectorComments.java\n@Singleton\npublic class ConnectorComments {\n\n\t@Inject\n\tprivate Connector connector;\n\t@Inject\n\tprivate KSoapExecutor soap;\n\n    public synchronized List<Comment> getComments(String issueKey)\n\t        throws CommunicationException, AuthorizationException,\n\t        AuthenticationException {\n\t\tif (issueKey == null) {\n\t\t\tthrow new IllegalArgumentException(\"issueKey cannot be null\");\n\t\t}\n\n\t\tSoapObject getComments = SoapObjectBuilder.start()\n\t\t        .withMethod(\"getComments\")\n\t\t        .withProperty(\"token\", connector.getToken())\n\t\t        .withProperty(\"issueKey\", issueKey).build();\n\n\t\t@SuppressWarnings(\"unchecked\")\n        Vector<SoapObject> vc = soap.execute(getComments, Vector.class);\n\t\tif (vc == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Comment> comments = new ArrayList<Comment>();\n\n\t\tSoapObject p;// Temporary variable!\n\t\tfor (int i = 0; i < vc.size(); ++i) {\n\t\t\tp = vc.get(i);\n\n\t\t\t// TODO consider whether all these fields are necessary\n\n\t\t\tString author = p.getPropertySafelyAsString(\"author\");\n\t\t\tif (author == null || author.compareToIgnoreCase(\"null\") == 0) {\n\t\t\t\tSystem.out.println(\"Ej no tak nie powinno być!!!!!!!!!\");\n\t\t\t}\n\n\t\t\tcomments.add(new Comment(connector.downloadUserInformation(author),\n\t\t\t        p.getPropertySafelyAsString(\"body\"), p\n\t\t\t                .getPropertySafelyAsString(\"groupLevel\"), p\n\t\t\t                .getPropertySafelyAsString(\"id\"), p\n\t\t\t                .getPropertySafelyAsString(\"roleLevel\"), p\n\t\t\t                .getPropertySafelyAsString(\"updateAuthor\"), p\n\t\t\t                .getPropertySafelyAsString(\"created\"), p\n\t\t\t                .getPropertySafelyAsString(\"updated\")));\n\t\t}\n\n\t\treturn comments;\n\t}\n\n\t/**\n\t * Adds a comment to the specified issue\n\t * \n\t * @param message\n\t * @param issueKey\n\t * @throws AuthenticationException\n\t * @throws AuthorizationException\n\t * @throws CommunicationException\n\t */\n\tpublic void addComment(String issueKey, Comment comment)\n\t        throws CommunicationException, AuthorizationException,\n\t        AuthenticationException {\n\n\t\tif (comment == null || issueKey == null) {\n\t\t\tthrow new IllegalArgumentException(\"Wrong arguments\\ncomment: \"\n\t\t\t        + comment.toString() + \"\\nissueKey: \" + issueKey);\n\t\t}\n\n\t\tSoapObject remoteComment = new SoapObject(\n\t\t        \"http://beans.soap.rpc.jira.atlassian.com\", \"RemoteComment\");\n\n\t\tremoteComment.addProperty(\"body\", comment.getBody());\n\n\t\tSoapObject addComment = SoapObjectBuilder.start()\n\t\t        .withMethod(\"addComment\")\n\t\t        .withProperty(\"token\", connector.getToken())\n\t\t        .withProperty(\"issueKey\", issueKey)\n\t\t        .withSoapObject(remoteComment).build();\n\n\t\tsoap.execute(addComment);\n\t}\n}\nandroid app/jiraForAndroid/src/jira/For/Android/DataTypes/DataTypesMethods.java\npublic class DataTypesMethods {\n\n\tprivate static final String datePattern = \"yyyy-MM-ddHH:mm:ss\";\n\tprivate static final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\n\t        datePattern);\n\tprivate static SimpleDateFormat simpleDateFormatGMT = setFormatGMT();\n\n\tprivate static SimpleDateFormat setFormatGMT() {\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(datePattern);\n\t\tsdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\t\treturn sdf;\n\t}\n\n\tpublic static Date GMTStringToLocalDate(String dateAsString) {\n\t\tDate date = null;\n\t\tdateAsString = dateAsString.replace('T', ' ');\n\t\ttry {\n\t\t\tdate = simpleDateFormatGMT.parse(dateAsString);\n\t\t} catch (ParseException e) {\n\t\t\tDLog.e(\"Error, program was unable to parse string to date\",\n\t\t\t        e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn date;\n\t}\n\n\tpublic static Date stringToDate(String dateAsString) {\n\t\tDate date = null;\n\t\tdateAsString = dateAsString.replace('T', ' ');\n\t\ttry {\n\t\t\tdate = simpleDateFormat.parse(dateAsString);\n\t\t} catch (ParseException e) {\n\t\t\tDLog.e(\"Error, program was unable to parse string to date\",\n\t\t\t        e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn date;\n\t}\n\n\tpublic static String dateToString(Date dateAsDate) {\n\t\treturn simpleDateFormat.format(dateAsDate);\n\t}\n\n\tpublic static String dateToGMTString(Date dateAsDate) {\n\n\t\treturn simpleDateFormatGMT.format(dateAsDate);\n\t}\n}\nandroid app/jiraForAndroid/src/jira/For/Android/ImagesCacher/ImagesCacher.java\npublic class ImagesCacher {\n\n\tprivate static ImagesCacher INSTANCE = null;\n\tprivate Context applicationContext;\n\n\tpublic HashMap<String, Bitmap> issuesPrioritesBitmaps = new HashMap<String, Bitmap>();\n\tpublic HashMap<String, Bitmap> issuesStatusesBitmaps = new HashMap<String, Bitmap>();\n\tpublic HashMap<String, Bitmap> issuesTypesBitmaps = new HashMap<String, Bitmap>();\n\n\tprivate HashMap<String, IssueType> issueTypes;\n\tprivate HashMap<String, Priority> priorities;\n\tprivate HashMap<String, Status> statuses;\n\n\tprivate ImagesCacher(HashMap<String, IssueType> issueTypes,\n\t                     HashMap<String, Priority> priorities,\n\t                     HashMap<String, Status> statuses, Context context) {\n\t\tthis.issueTypes = issueTypes;\n\t\tthis.priorities = priorities;\n\t\tthis.statuses = statuses;\n\t\tapplicationContext = context;\n\t}\n\n\tpublic static synchronized ImagesCacher getInstance() {\n\t\treturn INSTANCE;\n\t}\n\n\tpublic static synchronized ImagesCacher getInstance2(\n\t        HashMap<String, IssueType> issueTypes,\n\t        HashMap<String, Priority> priorities,\n\t        HashMap<String, Status> statuses, Context context) {\n\t\tif (INSTANCE == null) {\n\t\t\tINSTANCE = new ImagesCacher(issueTypes, priorities, statuses,\n\t\t\t        context);\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void clearMemory() {\n\t\tissuesPrioritesBitmaps.clear();\n\t\tissuesStatusesBitmaps.clear();\n\t\tissuesTypesBitmaps.clear();\n\n\t\t// TODO Jeszcze wyczyścić pamięć stałą!\n\t}\n\n\tpublic void downloadAllNeededData() {\n\n\t\tdownloadIconTypes();\n\n\t\tdownloadIconPriorites();\n\n\t\tdownloadIconStatuses();\n\t}\n\n\tpublic void flushToMemory() {\n\t\tflushHashMap(issuesPrioritesBitmaps);\n\t\tflushHashMap(issuesStatusesBitmaps);\n\t\tflushHashMap(issuesTypesBitmaps);\n\t}\n\n\tprivate void flushHashMap(HashMap<String, Bitmap> input) {\n\n\t\tSet<String> keySet = input.keySet();\n\t\tfor (String key : keySet) {\n\t\t\ttry {\n\t\t\t\tFileOutputStream fileOutputStream = applicationContext\n\t\t\t\t        .openFileOutput(key, Context.MODE_WORLD_WRITEABLE);\n\t\t\t\tinput.get(key).compress(Bitmap.CompressFormat.PNG, 90,\n\t\t\t\t        fileOutputStream);\n\t\t\t\tfileOutputStream.close();\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(this.toString(), \"Writing file to memory error!!!\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean downloadIcon(HashMap<String, ?> mapaIN,\n\t        HashMap<String, Bitmap> mapaOUT) throws IOException {\n\t\tSystem.out.println(\"POBIERAM!!!!!!!!!!!!\");\n\t\tBitmap bmp;\n\n\t\tString urlOfIcon;\n\t\tURL url;\n\t\tURLConnection connection;\n\t\tInputStream inputStream;\n\t\tfor (String id : mapaIN.keySet()) {\n\n\t\t\tif (mapaOUT.containsKey(id) == false) {\n\t\t\t\tSystem.out.println(\"Nie mam id:\" + id);\n\t\t\t\turlOfIcon = ((IconUrlProvider) mapaIN\n\t\t\t\t        .get(id)).getIcon();\n\t\t\t\turl = new URL(urlOfIcon);\n\t\t\t\tconnection = url.openConnection();\n\n\t\t\t\tinputStream = connection.getInputStream();\n\n\t\t\t\tBufferedInputStream bufferedInputStream = new BufferedInputStream(\n\t\t\t\t        inputStream);\n\n\t\t\t\tByteArrayBuffer baf = new ByteArrayBuffer(256);\n\t\t\t\tint current = 0;\n\t\t\t\twhile ((current = bufferedInputStream.read()) != -1) {\n\t\t\t\t\tbaf.append((byte) current);\n\t\t\t\t}\n\n\t\t\t\tbmp = BitmapFactory.decodeByteArray(baf.toByteArray(), 0,\n\t\t\t\t        baf.length());\n\n\t\t\t\tif (bmp == null) Log.e(\"IssueType\",\n\t\t\t\t        \"Nie udało się odkodowac pliku: \" + urlOfIcon);\n\n\t\t\t\tmapaOUT.put(id, bmp);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate void downloadIconTypes() {\n\t\ttry {\n\t\t\tdownloadIcon(issueTypes, issuesTypesBitmaps);\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate void downloadIconPriorites() {\n\t\ttry {\n\t\t\tdownloadIcon(priorities, issuesPrioritesBitmaps);\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate void downloadIconStatuses() {\n\t\ttry {\n\t\t\tdownloadIcon(statuses, issuesStatusesBitmaps);\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\nandroid app/jiraForAndroid/src/jira/For/Android/DataTypes/Issue.java\npublic class Issue implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate String id, assignee, assigneeFullName, description, environment, key, priority,\n\t        project, reporter, reporterFullName, resolution, status, summary, type;\n\tprivate long votes;\n\n\tprivate Date updated, created, duedate;// xsd:dateTime\n\n\t// Poniższe zostaną poprawione w przyszłości\n\t//private String fixVersions;// impl:ArrayOf_tns1_RemoteVersion\n\t//private String customFieldValues;// impl:ArrayOf_tns1_RemoteCustomFieldValue\n\t//private String components;// impl:ArrayOf_tns1_RemoteComponent\n\t//private String attachmentNames;// impl:ArrayOf_xsd_string\n\t//private String affectsVersions;// impl:ArrayOf_tns1_RemoteVersion\n\n\t@Deprecated\n\tpublic void pochwalSie() {\n\t\tSystem.out.println(\"\\nKey: \" + key + \"\\nassignee: \" + assignee\n\t\t        + \"\\nsummary: \" + summary + \"\\nid: \" + id + \"\\ndescription: \"\n\t\t        + description + \"\\nevn: \" + environment + \"\\nPriority: \"\n\t\t        + priority + \"\\nproject: \" + project + \"\\nreporter: \"\n\t\t        + reporter + \"\\nresolution: \" + resolution + \"\\nstatus: \"\n\t\t        + status + \"\\nsummary: \" + summary + \"\\ntype: \" + type\n\t\t        + \"\\nvotes: \" + votes);\n\t}\n\n\tpublic Issue(String id, String assignee, String assigneeFullName,\n\t\t\t\t String description, String updated, String created,\n\t\t\t\t String duedate, String environment, String key,\n\t\t\t\t String priority, String project, String reporter,\n\t\t\t\t String reporterFullName, String resolution, String status,\n\t\t\t\t String summary, String type, long votes) {\n\n\t\tsetId(id);\n\t\tsetAssignee(assignee);\n\t\tsetAssigneeFullName(assigneeFullName);\n\t\tsetDescription(description);\n\t\tsetEnvironment(environment);\n\t\tsetKey(key);\n\t\tsetPriority(priority);\n\t\tsetProject(project);\n\t\tsetReporter(reporter);\n\t\tsetReporterFullName(reporterFullName);\n\t\tsetResolution(resolution);\n\t\tsetStatus(status);\n\t\tsetSummary(summary);\n\t\tsetType(type);\n\t\tsetVotes(votes);\n\n\t\t// Parsing dates\n\t\tsetDuedate(duedate);\n\t\tsetCreated(created);\n\t\tsetUpdated(updated);\n\t}\n\n\tpublic final String getId() {\n\t\treturn id;\n\t}\n\n\tpublic final void setId(String id) {\n\t\tif (id == null || id.compareToIgnoreCase(\"null\") == 0) this.id = \"NO ID\";\n\t\telse this.id = id;\n\t}\n\n\tpublic final String getAssigneeName() {\n\t\treturn assignee;\n\t}\n\n\tpublic final void setAssignee(String assignee) {\n\t\tif (assignee == null || assignee.compareToIgnoreCase(\"null\") == 0) this.assignee = \"NO ASSIGNEE\";\n\t\telse this.assignee = assignee;\n\t}\n\t\n\tpublic final String getAssigneeFullName() {\n\t\treturn assigneeFullName;\n\t}\n\t\n\tpublic final void setAssigneeFullName(String assigneeFullName) {\n\t\tif (assigneeFullName == null || assigneeFullName.compareToIgnoreCase(\"null\") == 0)\n\t\t\tthis.assigneeFullName = \"Unassigned\";\n\t\telse this.assigneeFullName = assigneeFullName;\n\t}\n\n\tpublic final String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic final void setDescription(String description) {\n\t\tif (description == null || description.compareToIgnoreCase(\"null\") == 0) this.description = \"NO DESCRIPTION\";\n\t\telse this.description = description;\n\t}\n\n\tpublic final String getEnvironment() {\n\t\treturn environment;\n\t}\n\n\tpublic final void setEnvironment(String environment) {\n\t\tif (environment == null || environment.compareToIgnoreCase(\"null\") == 0) this.environment = \"NO ENVIRONMENT\";\n\t\telse this.environment = environment;\n\t}\n\n\tpublic final String getKey() {\n\t\treturn key;\n\t}\n\n\tpublic final void setKey(String key) {\n\t\tif (key == null || key.compareToIgnoreCase(\"null\") == 0) this.key = \"NO KEY\";\n\t\telse this.key = key;\n\t}\n\n\tpublic final String getPriority() {\n\t\treturn priority;\n\t}\n\n\tpublic final void setPriority(String priority) {\n\t\tif (priority == null || priority.compareToIgnoreCase(\"null\") == 0) this.priority = \"NO PRIORITY\";\n\t\telse this.priority = priority;\n\t}\n\n\tpublic final String getProject() {\n\t\treturn project;\n\t}\n\n\tpublic final void setProject(String project) {\n\t\tif (project == null || project.compareToIgnoreCase(\"null\") == 0) this.project = \"NO PROJECT\";\n\t\telse this.project = project;\n\t}\n\n\tpublic final String getReporterName() {\n\t\treturn reporter;\n\t}\n\n\tpublic final void setReporter(String reporter) {\n\t\tif (reporter == null || reporter.compareToIgnoreCase(\"null\") == 0) this.reporter = \"NO REPORTER\";\n\t\telse this.reporter = reporter;\n\t}\n\t\n\tpublic final String getReporterFullName() {\n\t\treturn reporterFullName;\n\t}\n\t\n\tpublic final void setReporterFullName(String reporterFullName) {\n\t\tif (reporterFullName == null || reporterFullName.compareToIgnoreCase(\"null\") == 0)\n\t\t\tthis.reporterFullName = \"NO REPORTER\";\n\t\telse this.reporterFullName = reporterFullName;\n\t}\n\n\tpublic final String getResolution() {\n\n\t\treturn resolution;\n\t}\n\n\tpublic final void setResolution(String resolution) {\n\t\tif (resolution == null || resolution.compareToIgnoreCase(\"null\") == 0) this.resolution = \"Unresolved\";\n\t\t//else this.resolution = resolution;\n\t\telse this.resolution = \"Fixed\";\n\t}\n\n\tpublic final String getStatus() {\n\n\t\treturn status;\n\t}\n\n\tpublic final void setStatus(String status) {\n\t\tif (status == null || status.compareToIgnoreCase(\"null\") == 0) this.status = \"NO STATUS\";\n\t\telse this.status = status;\n\t}\n\n\tpublic final String getSummary() {\n\n\t\treturn summary;\n\t}\n\n\tpublic final void setSummary(String summary) {\n\t\tif (summary == null || summary.compareToIgnoreCase(\"null\") == 0) this.summary = \"NO SUMMARY\";\n\t\telse this.summary = summary;\n\t}\n\n\tpublic final String getType() {\n\n\t\treturn type;\n\t}\n\n\tpublic final void setType(String type) {\n\t\tif (type == null || type.compareToIgnoreCase(\"null\") == 0) this.type = \"NO TYPE\";\n\t\telse this.type = type;\n\t}\n\n\tpublic final long getVotes() {\n\t\treturn votes;\n\t}\n\n\tpublic final void setVotes(long votes) {\n\t\tthis.votes = votes;\n\t}\n\t\n\tpublic final Date getUpdatedAsDate() {\n\t\treturn updated;\n\t}\n\n\tpublic final String getUpdated() {\n\t\tif (updated == null) return \"NO UPDATED\";\n\t\treturn updated.toLocaleString();\n\t}\n\n\tpublic final void setUpdated(String updated) {\n\t\tthis.updated = DataTypesMethods.GMTStringToLocalDate(updated);\n\t}\n\n\tpublic final String getCreated() {\n\t\tif (created == null) return \"NO CREATED\";\n\t\treturn created.toLocaleString();\n\t}\n\n\tpublic final void setCreated(String created) {\n\n\t\tif (created != null && created.compareToIgnoreCase(\"null\") != 0) {\n\t\t\tthis.created = DataTypesMethods.GMTStringToLocalDate(created);\n\t\t}\n\t}\n\n\tpublic final String getDuedate() {\n\t\tif (duedate == null) return \"NO DUEDATE\";\n\t\treturn duedate.toLocaleString();\n\t}\n\n\tpublic final void setDuedate(String duedate) {\n\n\t\tif (duedate != null && duedate.compareToIgnoreCase(\"null\") != 0) {\n\t\t\tthis.duedate = DataTypesMethods.stringToDate(duedate);\n\t\t}\n\t}\n}\nandroid app/jiraForAndroid/src/jira/For/Android/TaskDetails/Comments/AddCommentThread.java\npublic class AddCommentThread extends Thread<Void> {\n\n\tprivate Comment comment;\n\tprivate String issueKey;\n\tprivate final ConnectorComments connectorComments;\n\n\tpublic AddCommentThread(TaskDetailsActivity taskDetailsActivity,\n\t                        Comment comment, String issueKey, ConnectorComments connectorComments) {\n\t\tsuper(taskDetailsActivity);\n\t\tthis.comment = comment;\n\t\tthis.issueKey = issueKey;\n\t\tthis.connectorComments = connectorComments;\n\t}\n\n\t@Override\n\tprotected synchronized void onPreExecute() {\n\n\t\t// Showing progressbar activity while adding comment and refreshing list\n\n\t\t// TODO Dodać ukrywania listy tasków\n\t\tview.findViewById(R.id.edit_text_comment).setVisibility(View.INVISIBLE);\n\t\tview.findViewById(R.id.button_send_comment).setVisibility(\n\t\t        View.INVISIBLE);\n\n\t\tview.findViewById(R.id.comments_list_listview).setVisibility(\n\t\t        View.INVISIBLE);\n\n\t\tview.findViewById(R.id.data_is_loading).setVisibility(View.VISIBLE);\n\t\tview.findViewById(R.id.progress_bar).setVisibility(View.VISIBLE);\n\t};\n\n\t@Override\n\tprotected Void doInBackground(Void... params) {\n\t\tDLog.i(\"AddCommentThread\", \"doInBackground() <-- i'm here\");\n\t\ttry {\n\t\t\tconnectorComments.addComment(issueKey, comment);\n\t\t} catch (Exception e) {\n\t\t\tsetException(e);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected synchronized void onPostExecute(Void cos) {\n\t\tDLog.i(\"AddCommentThread\", \"onPostExecute <--- i'm here\");\n\t\thideProgressBar();\n\n\t\tEditText messageOfComment = (EditText) view\n\t\t        .findViewById(R.id.edit_text_comment);\n\t\tmessageOfComment.setVisibility(TextView.VISIBLE);\n\t\tview.findViewById(R.id.button_send_comment).setVisibility(View.VISIBLE);\n\t\tview.findViewById(R.id.comments_list_listview).setVisibility(\n\t\t        View.VISIBLE);\n\n\t\t// Jeżeli udało się wysłać komentarz //TODO zrobić to lepiej\n\t\tif (ex == null) {\n\t\t\t\n\t\t\tSystem.out.println(\"Wiec wysłałem komentarz?\");\n\t\t\t// If we send msg so we clear field/focus etc.\n\t\t\tmessageOfComment.setText(\"\");\n\t\t\tmessageOfComment.clearFocus();\n\t\t\tInputMethodManager inputMethodManager = (InputMethodManager) activity\n\t\t\t        .getSystemService(Context.INPUT_METHOD_SERVICE);\n\t\t\tinputMethodManager.hideSoftInputFromWindow(\n\t\t\t        messageOfComment.getWindowToken(),\n\t\t\t        InputMethodManager.RESULT_UNCHANGED_SHOWN);\n\n\t\t\t// Adding comment to the list :D move this to thread when add is\n\t\t\t// succesfull\n\t\t\tListView listView = (ListView) activity\n\t\t\t        .findViewById(R.id.comments_list_listview);\n\t\t\tCommentsAdapter listAdapter = (CommentsAdapter) listView\n\t\t\t        .getAdapter();\n\t\t\tlistAdapter.addComment(comment);\n\t\t\tlistAdapter.notifyDataSetChanged();\n\t\t}\n\t\telse {\n\n\t\t\tSystem.out\n\t\t\t        .println(\"Nie udalo się dodać komentarza!!!!!!!!!!!!!!!!!!!\");\n\t\t\tshowFailInformation();\n\t\t}\n\t}\n}\nandroid app/jiraForAndroid/src/jira/For/Android/Connector/Connector.java\n@Singleton\npublic final class Connector {\n\n\t@Inject\n\tprivate ConnectorUser connectorUser;\n\t@Inject\n\tprivate ConnectorIssueTypes connectorIssueTypes;\n\t@Inject\n\tprivate ConnectorPriority connectorPriority;\n\t@Inject\n\tprivate ConnectorStatus connectorStatus;\n\t@Inject\n\tprivate AuthenthicationService authenthicationService = new AuthenthicationService();\n\tprivate String username;\n\tprivate HashMap<String, User> users = new HashMap<String, User>();;\n\tprivate ImagesCacher imagesCacher;\n\tpublic HashMap<String, String> issuesTypesNames = new HashMap<String, String>();\n\tpublic HashMap<String, String> issuesPrioritiesNames = new HashMap<String, String>();\n\tpublic HashMap<String, String> issuesStatusesNames = new HashMap<String, String>();\n\tprivate static HashMap<String, IssueType> issueTypes = new HashMap<String, IssueType>();\n\tprivate static HashMap<String, Priority> priorities = new HashMap<String, Priority>();\n\tprivate static HashMap<String, Status> statuses = new HashMap<String, Status>();\n\t// Namespace we dontneed it now.\n\tprivate boolean isConnected = false;\n\n\tpublic boolean getIsConnected() {\n\t\treturn isConnected;\n\t}\n\n\tpublic void setIsConnected(boolean isConnected) {\n\t\tthis.isConnected = isConnected;\n\t}\n\n\tprivate void setUsernamePasswordUrl(String username, String password,\n\t        String url) {\n\n\t\tthis.username = username;\n\t}\n\n\t/**\n\t * This method login user to jira and get a token form it.\n\t * \n\t * @return Returns true if login gone okey.\n\t * @throws AuthorizationException\n\t * @throws Exception\n\t */\n\tpublic boolean jiraLogin(String username, String password, String url,\n\t        boolean secureConnection) throws AuthenticationException,\n\t        CommunicationException, AuthorizationException {\n\t\tString protocol = secureConnection ? \"https://\" : \"http://\";\n\t\tURL surl;\n        try {\n\t        surl = new URL(protocol+url);\n        } catch (MalformedURLException e) {\n\t        throw new CommunicationException(e);\n        }\n\t\tauthenthicationService.login(username, password, surl);\n\n\t\tdownloadIssueTypes();\n\t\tdownloadPriorities();\n\t\tdownloadStatuses();\n\t\timagesCacher = ImagesCacher.getInstance2(issueTypes, priorities,\n\t\t        statuses, null);\n\t\timagesCacher.downloadAllNeededData();\n\t\tsetUsernamePasswordUrl(username, password, url);\n\t\treturn true;\n\t}\n\n\t/**\n\t * This method logout user from the server.\n\t * \n\t * @return Returns true if logout gone okey.\n\t * @throws Exception\n\t */\n\tpublic boolean jiraLogout() {\n\t\tauthenthicationService.logout();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Download User full information\n\t * \n\t * @throws AuthenticationException\n\t * @throws AuthorizationException\n\t * @throws CommunicationException\n\t * @throws Exception\n\t */\n\tUser downloadUserInformation(String username)\n\t        throws CommunicationException, AuthorizationException,\n\t        AuthenticationException {\n\n\t\tif (!users.containsKey(username)) {\n\t\t\tusers.put(username, connectorUser.jiraGetUser(username));\n\t\t}\n\t\treturn getUser(username);\n\t}\n\n\t/**\n\t * Get user form HashMap\n\t * \n\t * @return\n\t */\n\tpublic User getUser(String username) {\n\t\treturn users.get(username);\n\t}\n\n\t/**\n\t * Get all users\n\t */\n\tpublic HashMap<String, User> getUsers() {\n\t\t// System.out.println(\"Mam tyle userow: \" + users.size());\n\t\treturn users;\n\t}\n\n\t/**\n\t * Get user logged in this application\n\t * \n\t * @return\n\t * @throws Exception\n\t */\n\tpublic User getThisUser() {\n\n\t\treturn getUser(username);\n\t}\n\n\t/*\n\t * Poniższe metody dotyczące IssueTypes i Priorities nie działają do końca\n\t * (nie wiedzieć czemu, wywalają błędy o nullowości HashMapy), jednakże są\n\t * one tutaj, by uniknąć niepotrzebnych mergy w najbliższym czasie, - Michał\n\t */\n\t/**\n\t * Download all issue types\n\t * \n\t * @throws AuthenticationException\n\t * @throws AuthorizationException\n\t * @throws CommunicationException\n\t * @throws Exception\n\t */\n\tpublic void downloadIssueTypes() throws CommunicationException,\n\t        AuthorizationException, AuthenticationException {\n\t\tissueTypes = connectorIssueTypes.jiraGetIssueTypes();\n\t}\n\n\t/**\n\t * Get issue type from HashMap\n\t */\n\tpublic IssueType getIssueType(String type) {\n\t\treturn issueTypes.get(type);\n\t}\n\n\t/**\n\t * Get all issue types\n\t */\n\tpublic HashMap<String, IssueType> getIssueTypes() {\n\t\treturn issueTypes;\n\t}\n\n\t/**\n\t * Download all priorities\n\t * \n\t * @throws AuthenticationException\n\t * @throws AuthorizationException\n\t * @throws CommunicationException\n\t * @throws RemoteException\n\t * @throws Exception\n\t */\n\tpublic void downloadPriorities() throws CommunicationException,\n\t        AuthorizationException, AuthenticationException {\n\t\tpriorities = connectorPriority.jiraGetPriorities();\n\t}\n\n\t/**\n\t * Get priority type from HashMap\n\t */\n\tpublic Priority getPriority(String priority) {\n\t\tDLog.i(\"ilosc priorytetow\", String.valueOf(priorities.size()));\n\t\treturn priorities.get(priority);\n\t}\n\n\t/**\n\t * Download all statuses\n\t * \n\t * @throws AuthenticationException\n\t * @throws AuthorizationException\n\t * @throws CommunicationException\n\t * @throws Exception\n\t */\n\tpublic void downloadStatuses() throws CommunicationException,\n\t        AuthorizationException, AuthenticationException {\n\t\tstatuses = connectorStatus.jiraGetStatuses();\n\t}\n\n\t/**\n\t * Get status type from HashMap\n\t */\n\tpublic Status getStatus(String status) {\n\t\treturn statuses.get(status);\n\t}\n\n\t/**\n\t * Get all priorities\n\t */\n\tpublic HashMap<String, Priority> getPriorities() {\n\t\treturn priorities;\n\t}\n\n\t/**\n\t * @return Returns the Token\n\t */\n\tpublic String getToken() {\n\t\treturn authenthicationService.getToken();\n\t}\n\n\n\t/**\n\t * Check do we have internet connection simply is data transfer is available\n\t */\n\tpublic boolean doWeHaveInternet(Context context) {\n\n\t\tif (context == null) {\n\t\t\tDLog.e(\"Connector\", \"doWeHaveInternet() context is NULL!\");\n\t\t\treturn false;\n\t\t}\n\t\tConnectivityManager manager = (ConnectivityManager) context\n\t\t        .getSystemService(Context.CONNECTIVITY_SERVICE);\n\n\t\tNetworkInfo netInfo = manager.getActiveNetworkInfo();\n\t\tif (netInfo == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn netInfo.isConnected();\n\t}\n\n}\nandroid app/jiraForAndroid/src/jira/For/Android/Connector/ConnectorWorkLog.java\n@Singleton\npublic class ConnectorWorkLog {\n\n\t@Inject\n\tprivate Connector connector;\n\t@Inject\n\tprivate KSoapExecutor soap;\n\n\tpublic synchronized List<WorkLog> getWorklog(String issueKey)\n\t        throws IOException, XmlPullParserException, Exception {\n\n\t\tif (issueKey == null) throw new Exception(\"Bad arguments\\nIssue key:\"\n\t\t        + issueKey);\n\n\t\tSoapObject getWorklogs = SoapObjectBuilder.start()\n\t\t        .withMethod(\"getWorklogs\")\n\t\t        .withProperty(\"token\", connector.getToken())\n\t\t        .withProperty(\"issueKey\", issueKey).build();\n\n\t\treturn downloadFromServer(getWorklogs);\n\n\t}\n\n\tprivate synchronized List<WorkLog>\n\t        downloadFromServer(SoapObject getWorklogs)\n\t                throws CommunicationException, AuthorizationException,\n\t                AuthenticationException {\n\n\t\t@SuppressWarnings(\"unchecked\")\n        Vector<SoapObject> vc = soap.execute(getWorklogs, Vector.class);\n\t\tif (vc == null) return null;\n\t\tLog.e(\"worklogi\", Integer.toString(vc.size()));\n\t\tList<WorkLog> worklogs = new ArrayList<WorkLog>();\n\n\t\tSoapObject p;// Pomocnicza zmienna!\n\t\tfor (int i = 0; i < vc.size(); ++i) {\n\t\t\tp = vc.get(i);\n\n\t\t\tString author = p.getPropertySafelyAsString(\"author\");\n\t\t\tif (author == null || author.compareToIgnoreCase(\"null\") == 0) System.out\n\t\t\t        .println(\"Ej no tak nie powinno być!!!!!!!!!\");\n\t\t\tString created = p.getPropertySafelyAsString(\"created\");\n\t\t\tif (created == null || created.compareToIgnoreCase(\"null\") == 0) System.out\n\t\t\t        .println(\"Ej no tak nie powinno być!!!!!!!!!\");\n\t\t\tString startDate = p.getPropertySafelyAsString(\"startDate\");\n\t\t\tif (startDate == null || startDate.compareToIgnoreCase(\"null\") == 0) System.out\n\t\t\t        .println(\"Ej no tak nie powinno być!!!!!!!!!\");\n\t\t\tString updated = p.getPropertySafelyAsString(\"updated\");\n\t\t\tif (updated == null || updated.compareToIgnoreCase(\"null\") == 0) System.out\n\t\t\t        .println(\"Ej no tak nie powinno być!!!!!!!!!\");\n\n\t\t\tworklogs.add(new WorkLog(connector.downloadUserInformation(author),\n\t\t\t        p.getPropertySafelyAsString(\"comment\"), p\n\t\t\t                .getPropertySafelyAsString(\"timeSpent\"), p\n\t\t\t                .getPropertySafelyAsString(\"updateAuthor\"),\n\t\t\t        DataTypesMethods.GMTStringToLocalDate(created),\n\t\t\t        DataTypesMethods.GMTStringToLocalDate(startDate),\n\t\t\t        DataTypesMethods.GMTStringToLocalDate(updated),\n\t\t\t        Long.parseLong(p\n\t\t\t                .getPropertySafelyAsString(\"timeSpentInSeconds\"))));\n\t\t}\n\n\t\tLog.e(\"worklogi1\", Integer.toString(worklogs.size()));\n\n\t\treturn worklogs;\n\n\t}\n\n}\nandroid app/jiraForAndroid/src/jira/For/Android/TaskDetails/WorkLog/LoadWorkLogThread.java\npublic class LoadWorkLogThread extends Thread<List<WorkLog>> {\n\n\tIssue task;\n\tprivate final ConnectorWorkLog connectorWorklog;\n\n\tpublic LoadWorkLogThread(View view, TaskDetailsActivity activity,\n\t                         Issue task, ConnectorWorkLog connector) {\n\t\tsuper(view, activity);\n\t\tthis.task = task;\n\t\tthis.connectorWorklog = connector;\n\t}\n\n\tprotected synchronized void onPostExecute(List<WorkLog> result) {\n\t\tsuper.hideProgressBar();\n\t\t// TODO Connector ma zwracać nulla jak nic nie ma naprawde!\n\t\tif (result == null) {\n\t\t\tview.findViewById(R.id.worklog_list_no_worklog).setVisibility(\n\t\t\t        View.VISIBLE);\n\t\t}\n\t\telse {\n\t\t\tWorkLogAdapter adapter = new WorkLogAdapter(\n\t\t\t        activity.getBaseContext(), result);\n\t\t\tListView listView = (ListView) activity\n\t\t\t        .findViewById(R.id.worklog_listview);\n\t\t\tlistView.setVisibility(View.VISIBLE);\n\t\t\tlistView.setAdapter(adapter);\n\t\t}\n\t}\n\n\t@Override\n\tprotected synchronized List<WorkLog> doInBackground(Void... params) {\n\t\ttry {\n\t\t\treturn connectorWorklog.getWorklog(task.getKey());\n\t\t} catch (Exception e) {\n\t\t\tsetException(e);\n\t\t}\n\t\treturn null;\n\t}\n\n}\nandroid app/jiraForAndroid/src/jira/For/Android/DataTypes/Comment.java\npublic class Comment {\n\n\tprivate String body, groupLevel, id, roleLevel, updateAuthor;\n\tprivate Date created, updated;\n\tprivate User author;\n\n\t@Deprecated\n\tpublic void pochwalSie() {\n\t\tSystem.out.println(\"\\nAuthor: \" + getAuthorFullName() + \"\\nBody: \"\n\t\t        + getBody() + \"\\nGroup Level: \" + getGroupLevel() + \"\\nid: \"\n\t\t        + getId() + \"\\nRoleLevel: \" + getRoleLevel()\n\t\t        + \"\\nUpdate author: \" + getUpdateAuthor() + \"\\nCreated: \"\n\t\t        + getCreated() + \"\\nUpdated: \" + getUpdated());\n\t}\n\n\tpublic Comment(User author, String body, String groupLevel, String id,\n\t               String roleLevel, String updateAuthor, String created,\n\t               String updated) {\n\t\tsetAuthor(author);\n\t\tsetBody(body);\n\t\tsetGroupLevel(groupLevel);\n\t\tsetId(id);\n\t\tsetRoleLevel(roleLevel);\n\t\tsetUpdateAuthor(updateAuthor);\n\t\tsetCreated(created);\n\t\tsetUpdated(updated);\n\t}\n\n\t// TODO Zaimplementować toString()\n\t@Override\n\tpublic String toString() {\n\t\treturn \"RemoteComment{author=\" + author.getName() + \"; body=\" + body\n\t\t        + \"; roleLevel=null; }\";// tak na szybkiego\n\t};\n\n\tpublic final String getAuthorName() {\n\t\treturn author.getName();\n\t}\n\n\tpublic String getAuthorFullName() {\n\t\treturn author.getFullname();\n\t}\n\n\tpublic final String getBody() {\n\t\treturn body;\n\t}\n\n\tpublic final String getGroupLevel() {\n\t\treturn groupLevel;\n\t}\n\n\tpublic final String getId() {\n\t\treturn id;\n\t}\n\n\tpublic final String getRoleLevel() {\n\t\treturn roleLevel;\n\t}\n\n\tpublic final String getUpdateAuthor() {\n\t\treturn updateAuthor;\n\t}\n\n\tpublic final String getCreated() {\n\t\treturn created.toLocaleString();\n\t}\n\n\tpublic final String getUpdated() {\n\t\treturn updated.toLocaleString();\n\t}\n\n\tpublic final void setAuthor(User author) {\n\t\tthis.author = author;\n\t}\n\n\tpublic final void setBody(String body) {\n\t\tif (body == null || body.compareToIgnoreCase(\"null\") == 0) this.body = \"NO BODY\";\n\t\telse this.body = body;\n\t}\n\n\tpublic final void setGroupLevel(String groupLevel) {\n\t\tif (groupLevel == null || groupLevel.compareToIgnoreCase(\"null\") == 0) this.groupLevel = \"NO GROUP LEVEL\";\n\t\telse this.groupLevel = groupLevel;\n\t}\n\n\tpublic final void setId(String id) {\n\t\tif (id == null || id.compareToIgnoreCase(\"null\") == 0) this.id = \"NO ID\";\n\t\telse this.id = id;\n\t}\n\n\tpublic final void setRoleLevel(String roleLevel) {\n\t\tif (roleLevel == null || roleLevel.compareToIgnoreCase(\"null\") == 0) this.roleLevel = \"NO ROLE LEVEL\";\n\t\telse this.roleLevel = roleLevel;\n\t}\n\n\tpublic final void setUpdateAuthor(String updateAuthor) {\n\t\tif (updateAuthor == null\n\t\t        || updateAuthor.compareToIgnoreCase(\"null\") == 0) this.updateAuthor = \"NO UPDATE AUTHOR\";\n\t\telse this.updateAuthor = updateAuthor;\n\t}\n\n\tpublic final void setCreated(String created) {\n\t\tif (created != null && created.compareToIgnoreCase(\"null\") != 0) {\n\t\t\tthis.created = DataTypesMethods.GMTStringToLocalDate(created);\n\t\t}\n\t}\n\n\tpublic final void setUpdated(String updated) {\n\t\tif (updated != null && updated.compareToIgnoreCase(\"null\") != 0) {\n\t\t\tthis.updated = DataTypesMethods.GMTStringToLocalDate(updated);\n\t\t}\n\t}\n}\nandroid app/jiraForAndroid/src/jira/For/Android/DLog.java\npublic class DLog {\r\n\r\n\tpublic static void i(String message) {\r\n\t\tLog.i(\"jira_for_android\", message);\r\n\t}\r\n\r\n\tpublic static void i(String TAG, String message) {\r\n\t\tLog.i(TAG, message);\r\n\t}\r\n\r\n\tpublic static void e(String message) {\r\n\t\tLog.e(\"jira_for_android\", message);\r\n\t}\r\n\r\n\tpublic static void e(String TAG, String message) {\r\n\t\tLog.e(TAG, message);\r\n\t}\r\n}\r\nandroid app/jiraForAndroid/src/jira/For/Android/PagerView/ViewForPagerInterface.java\npublic interface ViewForPagerInterface {\n\n\tpublic String getTitle(int a);\n\n\tpublic View loadView(LayoutInflater inflater, int pos);\n\n\tpublic int getLength();\n\n}\n", "answers": ["\tIssue task;"], "length": 3252, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "c27c0c36d78034f1a4755d22cea9dd1ea50ead1a9454a279"}
{"input": "package org.wickedsource.docxstamper;\nimport org.docx4j.openpackaging.packages.WordprocessingMLPackage;\nimport org.wickedsource.docxstamper.api.DocxStamperException;\nimport org.wickedsource.docxstamper.api.commentprocessor.ICommentProcessor;\nimport org.wickedsource.docxstamper.api.typeresolver.ITypeResolver;\nimport org.wickedsource.docxstamper.api.typeresolver.TypeResolverRegistry;\nimport org.wickedsource.docxstamper.el.ExpressionResolver;\nimport org.wickedsource.docxstamper.processor.CommentProcessorRegistry;\nimport org.wickedsource.docxstamper.processor.displayif.DisplayIfProcessor;\nimport org.wickedsource.docxstamper.processor.displayif.IDisplayIfProcessor;\nimport org.wickedsource.docxstamper.processor.repeat.*;\nimport org.wickedsource.docxstamper.processor.replaceExpression.IReplaceWithProcessor;\nimport org.wickedsource.docxstamper.processor.replaceExpression.ReplaceWithProcessor;\nimport org.wickedsource.docxstamper.proxy.ProxyBuilder;\nimport org.wickedsource.docxstamper.replace.PlaceholderReplacer;\nimport org.wickedsource.docxstamper.replace.typeresolver.DateResolver;\nimport org.wickedsource.docxstamper.replace.typeresolver.FallbackResolver;\nimport org.wickedsource.docxstamper.replace.typeresolver.image.Image;\nimport org.wickedsource.docxstamper.replace.typeresolver.image.ImageResolver;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Date;\nimport java.util.Map;\n\n\n\n/**\n * <p>\n * Main class of the docx-stamper library. This class can be used to \"stamp\" .docx templates\n * to create a .docx document filled with custom data at runtime.\n * </p>\n *\n * @param <T> the class of the context object used to resolve expressions against.\n */\npublic class DocxStamper<T> {\n\n  private PlaceholderReplacer<T> placeholderReplacer;\n\n  private CommentProcessorRegistry commentProcessorRegistry;\n\n  private TypeResolverRegistry typeResolverRegistry;\n\n  private DocxStamperConfiguration config = new DocxStamperConfiguration();\n\n  public DocxStamper() {\n    initFields();\n  }\n\n  public DocxStamper(DocxStamperConfiguration config) {\n    this.config = config;\n    initFields();\n  }\n\n  private void initFields() {\n    typeResolverRegistry = new TypeResolverRegistry(new FallbackResolver());\n    typeResolverRegistry.registerTypeResolver(Image.class, new ImageResolver());\n    typeResolverRegistry.registerTypeResolver(Date.class, new DateResolver(\"dd.MM.yyyy\"));", "context": "src/main/java/org/wickedsource/docxstamper/api/DocxStamperException.java\npublic class DocxStamperException extends RuntimeException {\n\n    public DocxStamperException(String message) {\n        super(message);\n    }\n\n    public DocxStamperException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public DocxStamperException(Throwable cause) {\n        super(cause);\n    }\n\n}\nsrc/main/java/org/wickedsource/docxstamper/api/typeresolver/TypeResolverRegistry.java\npublic class TypeResolverRegistry {\n\n    private ITypeResolver defaultResolver;\n\n    private Map<Class<?>, ITypeResolver> typeResolversByType = new HashMap<>();\n\n    public TypeResolverRegistry(ITypeResolver defaultResolver) {\n        this.defaultResolver = defaultResolver;\n    }\n\n    public <T> void registerTypeResolver(Class<T> resolvedType, ITypeResolver resolver) {\n        typeResolversByType.put(resolvedType, resolver);\n    }\n\n    /**\n     * Gets the ITypeResolver that was registered for the specified type.\n     *\n     * @param type the class for which to find the ITypeResolver.\n     * @param <T>  the type resolved by the ITypeResolver.\n     * @return the ITypeResolver implementation that was earlier registered for the given class, or the default ITypeResolver\n     * if none is found.\n     */\n    public <T> ITypeResolver getResolverForType(Class<T> type) {\n        ITypeResolver resolver = typeResolversByType.get(type);\n        if (resolver == null) {\n            return defaultResolver;\n        } else {\n            return resolver;\n        }\n    }\n\n    /**\n     * Sets the default ITypeResolver that is used for classes that have no ITypeResolver registered.\n     *\n     * @param defaultResolver the resolver to use as default.\n     */\n    public void setDefaultResolver(ITypeResolver defaultResolver) {\n        this.defaultResolver = defaultResolver;\n    }\n\n    public ITypeResolver getDefaultResolver() {\n        return defaultResolver;\n    }\n}\nsrc/main/java/org/wickedsource/docxstamper/api/commentprocessor/ICommentProcessor.java\npublic interface ICommentProcessor {\n\n    /**\n     * This method is called after all comments in the .docx template have been passed to the comment processor.\n     * All manipulations of the .docx document SHOULD BE done in this method. If certain manipulations are already done\n     * within in the custom methods of a comment processor, the ongoing iteration over the paragraphs in the document\n     * may be disturbed.\n     *\n     * @param document The word document that can be manipulated by using the DOCX4J api.\n     */\n    void commitChanges(WordprocessingMLPackage document);\n\n    /**\n     * Passes the paragraph that is currently being processed (i.e. the paragraph that is commented in the\n     * .docx template. This method is always called BEFORE the custom methods of the custom comment processor interface\n     * are called.\n     *\n     * @param coordinates coordinates of the currently processed paragraph within the template.\n     */\n    void setCurrentParagraphCoordinates(ParagraphCoordinates coordinates);\n\n\n    /**\n     * Passes the run that is currently being processed (i.e. the run that is commented in the\n     * .docx template. This method is always called BEFORE the custom methods of the custom comment processor interface\n     * are called.\n     *\n     * @param coordinates coordinates of the currently processed run within the template.\n     */\n    void setCurrentRunCoordinates(RunCoordinates coordinates);\n\n\n    /**\n     * Passes the comment range wrapper that is currently being processed\n     * (i.e. the start and end of comment that in the .docx template.\n     * This method is always called BEFORE the custom methods of the custom comment\n     * processor interface are called.\n     *\n     *  @param commentWrapper of the currently processed comment within the template.\n     */\n    void setCurrentCommentWrapper(CommentWrapper commentWrapper);\n\n    /**\n     * Resets all state in the comment processor so that it can be re-used in another stamping process.\n     */\n    void reset();\n\n}\nsrc/main/java/org/wickedsource/docxstamper/el/ExpressionResolver.java\npublic class ExpressionResolver {\n\n    private static final ExpressionUtil expressionUtil = new ExpressionUtil();\n\n    private final EvaluationContextConfigurer evaluationContextConfigurer;\n\n    public ExpressionResolver() {\n        this.evaluationContextConfigurer = new NoOpEvaluationContextConfigurer();\n    }\n\n    public ExpressionResolver(EvaluationContextConfigurer evaluationContextConfigurer) {\n        this.evaluationContextConfigurer = evaluationContextConfigurer;\n    }\n\n    /**\n     * Runs the given expression against the given context object and returns the result of the evaluated expression.\n     *\n     * @param expressionString the expression to evaluate.\n     * @param contextRoot      the context object against which the expression is evaluated.\n     * @return the result of the evaluated expression.\n     */\n    public Object resolveExpression(String expressionString, Object contextRoot) {\n        if ((expressionString.startsWith(\"${\") || expressionString.startsWith(\"#{\")) && expressionString.endsWith(\"}\")) {\n            expressionString = expressionUtil.stripExpression(expressionString);\n        }\n        ExpressionParser parser = new SpelExpressionParser();\n        StandardEvaluationContext evaluationContext = new StandardEvaluationContext(contextRoot);\n        evaluationContextConfigurer.configureEvaluationContext(evaluationContext);\n        Expression expression = parser.parseExpression(expressionString);\n        return expression.getValue(evaluationContext);\n    }\n\n}\nsrc/main/java/org/wickedsource/docxstamper/processor/replaceExpression/IReplaceWithProcessor.java\npublic interface IReplaceWithProcessor {\n\n\t/**\n\t * May be called to replace a single word inside a paragraph with an expression\n\t * defined in a comment. The comment must be applied to a single word for the\n\t * replacement to take effect!\n\t *\n\t * @param expression the expression to replace the text with\n\t */\n\tvoid replaceWordWith(String expression);\n\n}\nsrc/main/java/org/wickedsource/docxstamper/processor/displayif/DisplayIfProcessor.java\npublic class DisplayIfProcessor extends BaseCommentProcessor implements IDisplayIfProcessor {\n\n\tprivate List<ParagraphCoordinates> paragraphsToBeRemoved = new ArrayList<>();\n\n\tprivate List<TableCoordinates> tablesToBeRemoved = new ArrayList<>();\n\n\tprivate List<TableRowCoordinates> tableRowsToBeRemoved = new ArrayList<>();\n\n\t@Override\n\tpublic void commitChanges(WordprocessingMLPackage document) {\n\t\tObjectDeleter deleter = new ObjectDeleter(document);\n\t\tremoveParagraphs(deleter);\n\t\tremoveTables(deleter);\n\t\tremoveTableRows(deleter);\n\t}\n\n\t@Override\n\tpublic void reset() {\n\t\tparagraphsToBeRemoved = new ArrayList<>();\n\t\ttablesToBeRemoved = new ArrayList<>();\n\t\ttableRowsToBeRemoved = new ArrayList<>();\n\t}\n\n\tprivate void removeParagraphs(ObjectDeleter deleter) {\n\t\tfor (ParagraphCoordinates pCoords : paragraphsToBeRemoved) {\n\t\t\tdeleter.deleteParagraph(pCoords);\n\t\t}\n\t}\n\n\tprivate void removeTables(ObjectDeleter deleter) {\n\t\tfor (TableCoordinates tCoords : tablesToBeRemoved) {\n\t\t\tdeleter.deleteTable(tCoords);\n\t\t}\n\t}\n\n\tprivate void removeTableRows(ObjectDeleter deleter) {\n\t\tfor (TableRowCoordinates rCoords : tableRowsToBeRemoved) {\n\t\t\tdeleter.deleteTableRow(rCoords);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void displayParagraphIf(Boolean condition) {\n\t\tif (!condition) {\n\t\t\tParagraphCoordinates coords = getCurrentParagraphCoordinates();\n\t\t\tparagraphsToBeRemoved.add(coords);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void displayTableIf(Boolean condition) {\n\t\tif (!condition) {\n\t\t\tParagraphCoordinates pCoords = getCurrentParagraphCoordinates();\n\t\t\tif (pCoords.getParentTableCellCoordinates() == null ||\n\t\t\t\t\tpCoords.getParentTableCellCoordinates().getParentTableRowCoordinates() == null ||\n\t\t\t\t\tpCoords.getParentTableCellCoordinates().getParentTableRowCoordinates().getParentTableCoordinates() == null) {\n\t\t\t\tthrow new CommentProcessingException(\"Paragraph is not within a table!\", pCoords);\n\t\t\t}\n\t\t\ttablesToBeRemoved.add(pCoords.getParentTableCellCoordinates().getParentTableRowCoordinates().getParentTableCoordinates());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void displayTableRowIf(Boolean condition) {\n\t\tif (!condition) {\n\t\t\tParagraphCoordinates pCoords = getCurrentParagraphCoordinates();\n\t\t\tif (pCoords.getParentTableCellCoordinates() == null ||\n\t\t\t\t\tpCoords.getParentTableCellCoordinates().getParentTableRowCoordinates() == null) {\n\t\t\t\tthrow new CommentProcessingException(\"Paragraph is not within a table!\", pCoords);\n\t\t\t}\n\t\t\ttableRowsToBeRemoved.add(pCoords.getParentTableCellCoordinates().getParentTableRowCoordinates());\n\t\t}\n\t}\n}\nsrc/main/java/org/wickedsource/docxstamper/replace/typeresolver/image/Image.java\npublic class Image {\n\n    private byte[] imageBytes;\n\n    private String filename;\n\n    private String altText;\n\n    private Integer maxWidth;\n\n    /**\n     * @param in - content of the image as InputStream\n     */\n    public Image(InputStream in) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        IOUtils.copy(in, out);\n        this.imageBytes = out.toByteArray();\n    }\n\n    /**\n     * @param in - content of the image as InputStream\n     * @param maxWidth - max width of the image in twip\n     */\n    public Image(InputStream in, Integer maxWidth) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        IOUtils.copy(in, out);\n        this.imageBytes = out.toByteArray();\n        this.maxWidth = maxWidth;\n    }\n\n    /**\n     * @param imageBytes - content of the image as array of the bytes\n     */\n    public Image(byte[] imageBytes) {\n        this.imageBytes = imageBytes;\n    }\n\n    /**\n     * @param imageBytes - content of the image as array of the bytes\n     * @param maxWidth - max width of the image in twip\n     */\n    public Image(byte[] imageBytes, Integer maxWidth) {\n        this.imageBytes = imageBytes;\n        this.maxWidth = maxWidth;\n    }\n\n    public String getFilename() {\n        return filename;\n    }\n\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n    public String getAltText() {\n        return altText;\n    }\n\n    public void setAltText(String altText) {\n        this.altText = altText;\n    }\n\n    public byte[] getImageBytes() {\n        return imageBytes;\n    }\n\n    public void setImageBytes(byte[] imageBytes) {\n        this.imageBytes = imageBytes;\n    }\n\n    /**\n     * @return max width of the image in twip, if it is specified, or null.\n     */\n    public Integer getMaxWidth() {\n        return maxWidth;\n    }\n}\nsrc/main/java/org/wickedsource/docxstamper/api/typeresolver/ITypeResolver.java\npublic interface ITypeResolver<S, T> {\n\n    /**\n     * This method is called when a placeholder in the .docx template is to replaced by the result of an expression that\n     * was found in the .docx template. It creates an object of the DOCX4J api that is put in the place of the found\n     * expression.\n     *\n     * @param document         the word document that can be accessed via the DOCX4J api.\n     * @param expressionResult the result of an expression. Only objects of classes this type resolver is registered for\n     *                         within the TypeResolverRegistrey are passed into this method.\n     * @return an object of the DOCX4J api (usually of type org.docx4j.wml.R = \"run of text\") that will be put in the place of an\n     * expression found in the .docx document.\n     */\n    T resolve(WordprocessingMLPackage document, S expressionResult);\n\n}\nsrc/main/java/org/wickedsource/docxstamper/processor/CommentProcessorRegistry.java\npublic class CommentProcessorRegistry {\n\n  private Logger logger = LoggerFactory.getLogger(CommentProcessorRegistry.class);\n\n  private Map<ICommentProcessor, Class<?>> commentProcessorInterfaces = new HashMap<>();\n\n  private List<ICommentProcessor> commentProcessors = new ArrayList<>();\n\n  private ExpressionResolver expressionResolver = new ExpressionResolver();\n\n  private ExpressionUtil expressionUtil = new ExpressionUtil();\n\n  private PlaceholderReplacer placeholderReplacer;\n\n  private boolean failOnInvalidExpression = true;\n\n  public CommentProcessorRegistry(PlaceholderReplacer placeholderReplacer) {\n    this.placeholderReplacer = placeholderReplacer;\n  }\n\n  public void setExpressionResolver(ExpressionResolver expressionResolver) {\n    this.expressionResolver = expressionResolver;\n  }\n\n  public void registerCommentProcessor(Class<?> interfaceClass,\n                                       ICommentProcessor commentProcessor) {\n    this.commentProcessorInterfaces.put(commentProcessor, interfaceClass);\n    this.commentProcessors.add(commentProcessor);\n  }\n\n  /**\n   * Lets each registered ICommentProcessor have a run on the specified docx\n   * document. At the end of the document the commit method is called for each\n   * ICommentProcessor. The ICommentProcessors are run in the order they were\n   * registered.\n   *\n   * @param document    the docx document over which to run the registered ICommentProcessors.\n   * @param proxyBuilder a builder for a proxy around the context root object to customize its interface\n   * @param <T>         type of the contextRoot object.\n   */\n  public <T> void runProcessors(final WordprocessingMLPackage document, final ProxyBuilder<T> proxyBuilder) {\n    final Map<BigInteger, CommentWrapper> comments = CommentUtil.getComments(document);\n    final List<CommentWrapper> proceedComments = new ArrayList<>();\n\n    CoordinatesWalker walker = new BaseCoordinatesWalker(document) {\n\n      @Override\n      protected void onParagraph(ParagraphCoordinates paragraphCoordinates) {\n        runProcessorsOnParagraphComment(document, comments, proxyBuilder, paragraphCoordinates)\n                .ifPresent(proceedComments::add);\n        runProcessorsOnInlineContent(proxyBuilder, paragraphCoordinates);\n      }\n\n      @Override\n      protected void onRun(RunCoordinates runCoordinates,\n                                     ParagraphCoordinates paragraphCoordinates) {\n        runProcessorsOnRunComment(document, comments, proxyBuilder, paragraphCoordinates, runCoordinates)\n                .ifPresent(proceedComments::add);\n      }\n\n    };\n    walker.walk();\n\n    for (ICommentProcessor processor : commentProcessors) {\n      processor.commitChanges(document);\n    }\n    for (CommentWrapper commentWrapper : proceedComments) {\n      CommentUtil.deleteComment(commentWrapper);\n    }\n\n  }\n\n  /**\n   * Finds all processor expressions within the specified paragraph and tries\n   * to evaluate it against all registered {@link ICommentProcessor}s.\n   *\n   * @param proxyBuilder         a builder for a proxy around the context root object to customize its interface\n   * @param paragraphCoordinates the paragraph to process.\n   * @param <T>                  type of the context root object\n   */\n  private <T> void runProcessorsOnInlineContent(ProxyBuilder<T> proxyBuilder,\n                                                ParagraphCoordinates paragraphCoordinates) {\n\n    ParagraphWrapper paragraph = new ParagraphWrapper(paragraphCoordinates.getParagraph());\n    List<String> processorExpressions = expressionUtil\n            .findProcessorExpressions(paragraph.getText());\n\n    for (String processorExpression : processorExpressions) {\n      String strippedExpression = expressionUtil.stripExpression(processorExpression);\n\n      for (final ICommentProcessor processor : commentProcessors) {\n        Class<?> commentProcessorInterface = commentProcessorInterfaces.get(processor);\n        proxyBuilder.withInterface(commentProcessorInterface, processor);\n        processor.setCurrentParagraphCoordinates(paragraphCoordinates);\n      }\n\n      try {\n        T contextRootProxy = proxyBuilder.build();\n        expressionResolver.resolveExpression(strippedExpression, contextRootProxy);\n        placeholderReplacer.replace(paragraph, processorExpression, null);\n        logger.debug(String.format(\n                \"Processor expression '%s' has been successfully processed by a comment processor.\",\n                processorExpression));\n      } catch (SpelEvaluationException | SpelParseException e) {\n        if (failOnInvalidExpression) {\n          throw new UnresolvedExpressionException(strippedExpression, e);\n        } else {\n          logger.warn(String.format(\n                  \"Skipping processor expression '%s' because it can not be resolved by any comment processor. Reason: %s. Set log level to TRACE to view Stacktrace.\",\n                  processorExpression, e.getMessage()));\n          logger.trace(\"Reason for skipping processor expression: \", e);\n        }\n      } catch (ProxyException e) {\n        throw new DocxStamperException(\"Could not create a proxy around context root object\", e);\n      }\n    }\n  }\n\n\n  /**\n   * Takes the first comment on the specified paragraph and tries to evaluate\n   * the string within the comment against all registered\n   * {@link ICommentProcessor}s.\n   *\n   * @param document             the word document.\n   * @param comments             the comments within the document.\n   * @param proxyBuilder          a builder for a proxy around the context root object to customize its interface\n   * @param paragraphCoordinates the paragraph whose comments to evaluate.\n   * @param <T>                  the type of the context root object.\n   */\n  private <T> Optional<CommentWrapper> runProcessorsOnParagraphComment(final WordprocessingMLPackage document,\n                                                   final Map<BigInteger, CommentWrapper> comments, ProxyBuilder<T> proxyBuilder,\n                                                   ParagraphCoordinates paragraphCoordinates) {\n    Comments.Comment comment = CommentUtil.getCommentFor(paragraphCoordinates.getParagraph(), document);\n    return runCommentProcessors(document, comments, proxyBuilder, comment, paragraphCoordinates, null);\n  }\n\n  private <T> Optional<CommentWrapper> runProcessorsOnRunComment(final WordprocessingMLPackage document,\n                                                       final Map<BigInteger, CommentWrapper> comments, ProxyBuilder<T> proxyBuilder,\n                                                       ParagraphCoordinates paragraphCoordinates, RunCoordinates runCoordinates) {\n    Comments.Comment comment = CommentUtil.getCommentAround(runCoordinates.getRun(), document);\n    return runCommentProcessors(document, comments, proxyBuilder, comment, paragraphCoordinates, runCoordinates);\n  }\n\n  private <T> Optional<CommentWrapper> runCommentProcessors(final WordprocessingMLPackage document,\n                                                           final Map<BigInteger, CommentWrapper> comments, ProxyBuilder<T> proxyBuilder,\n                                                            Comments.Comment comment, ParagraphCoordinates paragraphCoordinates,\n                                                           RunCoordinates runCoordinates) {\n\n    CommentWrapper commentWrapper = Optional.ofNullable(comment)\n            .map(Comments.Comment::getId)\n            .map(comments::get)\n            .orElse(null);\n\n    if (Objects.isNull(comment) || Objects.isNull(commentWrapper)) {\n      // no comment to process\n      return Optional.empty();\n    }\n\n    String commentString = CommentUtil.getCommentString(comment);\n\n    for (final ICommentProcessor processor : commentProcessors) {\n      Class<?> commentProcessorInterface = commentProcessorInterfaces.get(processor);\n      proxyBuilder.withInterface(commentProcessorInterface, processor);\n      processor.setCurrentParagraphCoordinates(paragraphCoordinates);\n      processor.setCurrentRunCoordinates(runCoordinates);\n      processor.setCurrentCommentWrapper(commentWrapper);\n    }\n\n    try {\n      T contextRootProxy = proxyBuilder.build();\n      expressionResolver.resolveExpression(commentString, contextRootProxy);\n      comments.remove(comment.getId()); // guarantee one-time processing\n      logger.debug(\n              String.format(\"Comment '%s' has been successfully processed by a comment processor.\",\n                      commentString));\n      return Optional.of(commentWrapper);\n    } catch (SpelEvaluationException | SpelParseException e) {\n      if (failOnInvalidExpression) {\n        throw new UnresolvedExpressionException(commentString, e);\n      } else {\n        logger.warn(String.format(\n                \"Skipping comment expression '%s' because it can not be resolved by any comment processor. Reason: %s. Set log level to TRACE to view Stacktrace.\",\n                commentString, e.getMessage()));\n        logger.trace(\"Reason for skipping comment: \", e);\n      }\n    } catch (ProxyException e) {\n      throw new DocxStamperException(\"Could not create a proxy around context root object\", e);\n    }\n    return Optional.empty();\n  }\n\n  public boolean isFailOnInvalidExpression() {\n    return failOnInvalidExpression;\n  }\n\n  public void setFailOnInvalidExpression(boolean failOnInvalidExpression) {\n    this.failOnInvalidExpression = failOnInvalidExpression;\n  }\n\n  public void reset() {\n    for (ICommentProcessor processor : commentProcessors) {\n      processor.reset();\n    }\n  }\n}\nsrc/main/java/org/wickedsource/docxstamper/replace/typeresolver/DateResolver.java\npublic class DateResolver extends AbstractToTextResolver<Date> {\n\n    private String formatString;\n\n    private DateFormat dateFormat;\n\n    /**\n     * Creates a new DateResolver.\n     *\n     * @param formatString the format to use for date formatting. See java.text.SimpleDateFormat.\n     */\n    public DateResolver(String formatString) {\n        this.formatString = formatString;\n        this.dateFormat = new SimpleDateFormat(formatString);\n    }\n\n    @Override\n    protected String resolveStringForObject(Date date) {\n        synchronized (dateFormat) {\n            return dateFormat.format(date);\n        }\n    }\n\n    public String getFormatString() {\n        return formatString;\n    }\n\n}\nsrc/main/java/org/wickedsource/docxstamper/replace/typeresolver/image/ImageResolver.java\npublic class ImageResolver implements ITypeResolver {\n\n    private static Random random = new Random();\n\n    @Override\n    public R resolve(WordprocessingMLPackage document, Object image) {\n        try {\n            // TODO: adding the same image twice will put the image twice into the docx-zip file. make the second\n            //       addition of the same image a reference instead.\n            Image img = (Image) image;\n            return createRunWithImage(document, img.getImageBytes(), img.getFilename(), img.getAltText(), img.getMaxWidth());\n        } catch (Exception e) {\n            throw new DocxStamperException(\"Error while adding image to document!\", e);\n        }\n    }\n\n    public static R createRunWithImage(WordprocessingMLPackage wordMLPackage, byte[] bytes, String filenameHint, String altText, Integer maxWidth) throws Exception {\n        BinaryPartAbstractImage imagePart = BinaryPartAbstractImage.createImagePart(wordMLPackage, bytes);\n\n        // creating random ids assuming they are unique\n        // id must not be too large, otherwise Word cannot open the document\n        int id1 = random.nextInt(100000);\n        int id2 = random.nextInt(100000);\n        if (filenameHint == null) {\n            filenameHint = \"dummyFileName\";\n        }\n        if (altText == null) {\n            altText = \"dummyAltText\";\n        }\n\n        Inline inline;\n        if (maxWidth == null) {\n            inline = imagePart.createImageInline(filenameHint, altText,\n                    id1, id2, false);\n        } else {\n            inline = imagePart.createImageInline(filenameHint, altText,\n                    id1, id2, false, maxWidth);\n        }\n\n        // Now add the inline in w:p/w:r/w:drawing\n        org.docx4j.wml.ObjectFactory factory = new org.docx4j.wml.ObjectFactory();\n        org.docx4j.wml.R run = factory.createR();\n        org.docx4j.wml.Drawing drawing = factory.createDrawing();\n        run.getContent().add(drawing);\n        drawing.getAnchorOrInline().add(inline);\n\n        return run;\n\n    }\n\n}\nsrc/main/java/org/wickedsource/docxstamper/replace/PlaceholderReplacer.java\npublic class PlaceholderReplacer<T> {\n\n  private Logger logger = LoggerFactory.getLogger(PlaceholderReplacer.class);\n\n  private ExpressionUtil expressionUtil = new ExpressionUtil();\n\n  private ExpressionResolver expressionResolver = new ExpressionResolver();\n\n  private TypeResolverRegistry typeResolverRegistry;\n\n  private String lineBreakPlaceholder;\n\n  private boolean leaveEmptyOnExpressionError = false;\n\n  private boolean replaceNullValues = false;\n\n  public PlaceholderReplacer(TypeResolverRegistry typeResolverRegistry) {\n    this.typeResolverRegistry = typeResolverRegistry;\n  }\n\n  public PlaceholderReplacer(TypeResolverRegistry typeResolverRegistry, String lineBreakPlaceholder) {\n    this.typeResolverRegistry = typeResolverRegistry;\n    this.lineBreakPlaceholder = lineBreakPlaceholder;\n  }\n\n  public boolean isLeaveEmptyOnExpressionError() {\n    return leaveEmptyOnExpressionError;\n  }\n\n  public void setLeaveEmptyOnExpressionError(boolean leaveEmptyOnExpressionError) {\n    this.leaveEmptyOnExpressionError = leaveEmptyOnExpressionError;\n  }\n\n  public void setReplaceNullValues(boolean replaceNullValues) {\n    this.replaceNullValues = replaceNullValues;\n  }\n  \n  public void setExpressionResolver(ExpressionResolver expressionResolver) {\n    this.expressionResolver = expressionResolver;\n  }\n\n  /**\n   * Finds expressions in a document and resolves them against the specified context object. The expressions in the\n   * document are then replaced by the resolved values.\n   *\n   * @param document          the document in which to replace all expressions.\n   * @param proxyBuilder      builder for a proxy around the context root to customize its interface\n   */\n  public void resolveExpressions(final WordprocessingMLPackage document, ProxyBuilder<T> proxyBuilder) {\n    try {\n      final T expressionContext = proxyBuilder.build();\n      CoordinatesWalker walker = new BaseCoordinatesWalker(document) {\n        @Override\n        protected void onParagraph(ParagraphCoordinates paragraphCoordinates) {\n          resolveExpressionsForParagraph(paragraphCoordinates.getParagraph(), expressionContext, document);\n        }\n      };\n      walker.walk();\n    } catch (ProxyException e) {\n      throw new DocxStamperException(\"could not create proxy around context root!\", e);\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public void resolveExpressionsForParagraph(P p, T expressionContext, WordprocessingMLPackage document) {\n    ParagraphWrapper paragraphWrapper = new ParagraphWrapper(p);\n    List<String> placeholders = expressionUtil.findVariableExpressions(paragraphWrapper.getText());\n    for (String placeholder : placeholders) {\n      try {\n        Object replacement = expressionResolver.resolveExpression(placeholder, expressionContext);\n        if (replacement != null) {\n          ITypeResolver resolver = typeResolverRegistry.getResolverForType(replacement.getClass());\n          Object replacementObject = resolver.resolve(document, replacement);\n          replace(paragraphWrapper, placeholder, replacementObject);\n          logger.debug(String.format(\"Replaced expression '%s' with value provided by TypeResolver %s\", placeholder, resolver.getClass()));\n        } else if(replaceNullValues) {\n            ITypeResolver resolver = typeResolverRegistry.getDefaultResolver();\n            Object replacementObject = resolver.resolve(document, replacement);\n            replace(paragraphWrapper, placeholder, replacementObject);\n            logger.debug(String.format(\"Replaced expression '%s' with value provided by TypeResolver %s\", placeholder, resolver.getClass()));\n        }\n      } catch (SpelEvaluationException | SpelParseException e) {\n        logger.warn(String.format(\n                \"Expression %s could not be resolved against context root of type %s. Reason: %s. Set log level to TRACE to view Stacktrace.\",\n                placeholder, expressionContext.getClass(), e.getMessage()));\n        logger.trace(\"Reason for skipping expression:\", e);\n\n        if(isLeaveEmptyOnExpressionError()) {\n          replace(paragraphWrapper,placeholder,null);\n        }\n      }\n    }\n    if (this.lineBreakPlaceholder != null) {\n      replaceLineBreaks(paragraphWrapper);\n    }\n  }\n\n  private void replaceLineBreaks(ParagraphWrapper paragraphWrapper) {\n    Br lineBreak = Context.getWmlObjectFactory().createBr();\n    R run = RunUtil.create(lineBreak);\n    while (paragraphWrapper.getText().contains(this.lineBreakPlaceholder)) {\n      replace(paragraphWrapper, this.lineBreakPlaceholder, run);\n    }\n  }\n\n  public void replace(ParagraphWrapper p, String placeholder, Object replacementObject) {\n    if (replacementObject == null) {\n      replacementObject = RunUtil.create(\"\");\n    }\n    if (replacementObject instanceof R) {\n      RunUtil.applyParagraphStyle(p.getParagraph(), (R) replacementObject);\n    }\n    p.replace(placeholder, replacementObject);\n  }\n\n}\nsrc/main/java/org/wickedsource/docxstamper/proxy/ProxyBuilder.java\npublic class ProxyBuilder<T> {\n\n  private T root;\n\n  private Map<Class<?>, Object> interfacesToImplementations = new HashMap<>();\n\n  /**\n   * Specifies the root object for the proxy that shall be enhanced.\n   *\n   * @param rootObject the root object.\n   * @return this builder for chaining.\n   */\n  public ProxyBuilder<T> withRoot(T rootObject) {\n    this.root = rootObject;\n    return this;\n  }\n\n  /**\n   * Specifies an interfaces and an implementation of an interface by which the root object\n   * shall be extended.\n   *\n   * @param interfaceClass the class of the interface\n   * @param interfaceImpl  an implementation of the interface\n   * @return this builder for chaining.\n   */\n  public ProxyBuilder<T> withInterface(Class<?> interfaceClass, Object interfaceImpl) {\n    this.interfacesToImplementations.put(interfaceClass, interfaceImpl);\n    return this;\n  }\n\n  /**\n   * Creates a proxy object out of the specified root object and the specified interfaces\n   * and implementations.\n   *\n   * @return a proxy object that is still of type T but additionally implements all specified\n   * interfaces.\n   * @throws ProxyException if the proxy could not be created.\n   */\n  public T build() throws ProxyException {\n\n    if (this.root == null) {\n      throw new IllegalArgumentException(\"root must not be null!\");\n    }\n\n    if (this.interfacesToImplementations.isEmpty()) {\n      // nothing to proxy\n      return this.root;\n    }\n\n    try {\n      ProxyMethodHandler methodHandler = new ProxyMethodHandler(root,\n              interfacesToImplementations);\n      ProxyFactory proxyFactory = new ProxyFactory();\n      proxyFactory.setSuperclass(root.getClass());\n      proxyFactory.setInterfaces(interfacesToImplementations.keySet().toArray(new Class[]{}));\n      return (T) proxyFactory.create(new Class[0], new Object[0], methodHandler);\n    } catch (Exception e) {\n      throw new ProxyException(e);\n    }\n  }\n\n\n}\nsrc/main/java/org/wickedsource/docxstamper/processor/displayif/IDisplayIfProcessor.java\npublic interface IDisplayIfProcessor {\n\n    /**\n     * May be called to delete the commented paragraph or not, depending on the given boolean condition.\n     *\n     * @param condition if true, the commented paragraph will remain in the document. If false, the commented paragraph\n     *                  will be deleted at stamping.\n     */\n    void displayParagraphIf(Boolean condition);\n\n    /**\n     * May be called to delete the table surrounding the commented paragraph, depending on the given boolean condition.\n     *\n     * @param condition if true, the table row surrounding the commented paragraph will remain in the document. If false, the table row\n     *                  will be deleted at stamping.\n     */\n    void displayTableRowIf(Boolean condition);\n\n    /**\n     * May be called to delete the table surrounding the commented paragraph, depending on the given boolean condition.\n     *\n     * @param condition if true, the table surrounding the commented paragraph will remain in the document. If false, the table\n     *                  will be deleted at stamping.\n     */\n    void displayTableIf(Boolean condition);\n\n}\nsrc/main/java/org/wickedsource/docxstamper/replace/typeresolver/FallbackResolver.java\npublic class FallbackResolver extends AbstractToTextResolver<Object> {\n\n    @Override\n    protected String resolveStringForObject(Object object) {\n        if(object!=null)\n            return String.valueOf(object);\n        else\n            return \"\";\n    }\n\n}\nsrc/main/java/org/wickedsource/docxstamper/processor/replaceExpression/ReplaceWithProcessor.java\npublic class ReplaceWithProcessor extends BaseCommentProcessor\n\t\timplements IReplaceWithProcessor {\n\n\tpublic ReplaceWithProcessor() {\n\n\t}\n\n\t@Override\n\tpublic void commitChanges(WordprocessingMLPackage document) {\n\t}\n\n\t@Override\n\tpublic void reset() {\n\t\t// nothing to rest\n\t}\n\n\t@Override\n\tpublic void replaceWordWith(String expression) {\n\t\tif (this.getCurrentRunCoordinates() != null) {\n\t\t\tRunUtil.setText(this.getCurrentRunCoordinates().getRun(), expression);\n\t\t}\n\n\t}\n\n}\n", "answers": ["    for (Map.Entry<Class<?>, ITypeResolver> entry : config.getTypeResolvers().entrySet()) {"], "length": 3197, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "f69aefc95d38f5b289043282c44611c96b533e97a8a7f48b"}
{"input": "from ..exceptions import PyOrientBadMethodCallException\nfrom .base import BaseMessage\nfrom ..constants import CONNECT_OP, FIELD_BYTE, FIELD_INT, FIELD_SHORT, \\\n    FIELD_STRINGS, FIELD_BOOLEAN, FIELD_STRING, NAME, SUPPORTED_PROTOCOL, \\\n    VERSION, SHUTDOWN_OP\nfrom ..utils import need_connected\n__author__ = 'Ostico <ostico@gmail.com>'\n\n#from ..serializations import OrientSerialization\n\n#\n# Connect\n#\nclass ConnectMessage(BaseMessage):\n\n    def __init__(self, _orient_socket):\n        super( ConnectMessage, self ).__init__(_orient_socket)\n\n        self._user = ''\n        self._pass = ''\n        self._client_id = ''\n        self._need_token = False\n        self._append( ( FIELD_BYTE, CONNECT_OP ) )\n\n    def prepare(self, params=None ):\n\n        if isinstance( params, tuple ) or isinstance( params, list ):\n            try:\n                self._user = params[0]\n                self._pass = params[1]\n                self._client_id = params[2]\n\n            except IndexError:\n                # Use default for non existent indexes\n                pass\n\n", "context": "pyorient/constants.py\nSUPPORTED_PROTOCOL = 36\npyorient/messages/base.py\nclass BaseMessage(object):\n\n    def __init__(self, sock=OrientSocket):\n        \"\"\"\n        :type sock: OrientSocket\n        \"\"\"\n        sock.get_connection()\n        self._orientSocket = sock\n        self._protocol = self._orientSocket.protocol\n        self._session_id = self._orientSocket.session_id\n\n        # handles token auth\n        self._auth_token = self._orientSocket.auth_token\n        self._request_token = False\n\n        self._header = []\n        \"\"\":type : list of [str]\"\"\"\n\n        self._body = []\n        \"\"\":type : list of [str]\"\"\"\n\n        self._fields_definition = []\n        \"\"\":type : list of [object]\"\"\"\n\n        self._command = chr(0)\n        self._db_opened = self._orientSocket.db_opened\n        self._connected = self._orientSocket.connected\n\n        self._node_list = []\n        \"\"\":type : list of [OrientNode]\"\"\"\n\n        self._serializer = None\n\n        self._output_buffer = b''\n        self._input_buffer = b''\n\n        # callback function for async queries\n        self._callback = None\n\n        # callback for push received from the server\n        self._push_callback = None\n\n        self._need_token = True\n\n        global in_transaction\n        in_transaction = False\n\n    def get_serializer(self):\n        \"\"\"\n        Lazy return of the serialization, we retrive the type from the :class: `OrientSocket <pyorient.orient.OrientSocket>` object\n        :return: an Instance of the serializer suitable for decoding or encoding\n        \"\"\"\n        if self._orientSocket.serialization_type==OrientSerialization.Binary:\n            return OrientSerialization.get_impl(self._orientSocket.serialization_type,\n                                                self._orientSocket._props)\n        else:\n            return OrientSerialization.get_impl(self._orientSocket.serialization_type)\n\n    def get_orient_socket_instance(self):\n        return self._orientSocket\n\n    def is_connected(self):\n        return self._connected is True\n\n    def database_opened(self):\n        return self._db_opened\n\n    def get_cluster_map(self):\n        \"\"\":type : list of [OrientNode]\"\"\"\n        return self._node_list\n\n\n    def set_session_token( self, token='' ):\n        \"\"\"\n        :param token: Set the request to True to use the token authentication\n        :type token: bool|string\n        :return: self\n        \"\"\"\n        if token != '' and token is not None:\n            if type(token) is bool:\n                self._request_token = token\n            elif type(token) is str or type(token) is bytes:\n                self._request_token = True\n                self._auth_token = token\n                self._db_opened = True\n                self._connected = True\n                self._update_socket_token()\n        return self\n\n    def get_session_token( self ):\n        \"\"\"\n        Retrieve the session token to reuse after\n        :return:\n        \"\"\"\n        return self._auth_token\n\n    def _update_socket_id(self):\n        \"\"\"Force update of socket id from inside the class\"\"\"\n        self._orientSocket.session_id = self._session_id\n        return self\n\n    def _update_socket_token(self):\n        \"\"\"Force update of socket token from inside the class\"\"\"\n        self._orientSocket.auth_token = self._auth_token\n        return self\n\n    def _reset_fields_definition(self):\n        self._fields_definition = []\n\n    def prepare(self, *args):\n\n        # session_id\n        self._fields_definition.insert( 1, ( FIELD_INT, self._session_id ) )\n\n\n        \"\"\"\n        #  Token authentication handling\n        #  we must recognize ConnectMessage and DbOpenMessage messages\n        \"\"\"\n        if self._need_token and self._request_token is True:\n            self._fields_definition.insert(\n                2, ( FIELD_STRING, self._auth_token )\n            )\n\n        self._output_buffer = b''.join(\n            self._encode_field( x ) for x in self._fields_definition\n        )\n        return self\n\n    def get_protocol(self):\n        if self._protocol < 0:\n            self._protocol = self._orientSocket.protocol\n        return self._protocol\n\n    def _decode_header(self):\n\n        # read header's information\n        self._header = [ self._decode_field( FIELD_BYTE ),\n                         self._decode_field( FIELD_INT ) ]\n\n        # decode message errors and raise an exception\n        if self._header[0] == 1:\n\n            # Parse the error\n            exception_class = b''\n            exception_message = b''\n\n            more = self._decode_field( FIELD_BOOLEAN )\n\n            while more:\n                # read num bytes by the field definition\n                exception_class += self._decode_field( FIELD_STRING )\n                exception_message += self._decode_field( FIELD_STRING )\n                more = self._decode_field( FIELD_BOOLEAN )\n\n                if self.get_protocol() > 18:  # > 18 1.6-snapshot\n                    # read serialized version of exception thrown on server side\n                    # useful only for java clients\n                    serialized_exception = self._decode_field( FIELD_STRING )\n                    # trash\n                    del serialized_exception\n\n            raise PyOrientCommandException(\n                exception_class.decode( 'utf8' ),\n                [ exception_message.decode( 'utf8' ) ]\n            )\n\n        elif self._header[0] == 3:\n            # Push notification, Node cluster changed\n            # TODO: UNTESTED CODE!!!\n            # FIELD_BYTE (OChannelBinaryProtocol.PUSH_DATA);  # WRITE 3\n            # FIELD_INT (Integer.MIN_VALUE);  # SESSION ID = 2^-31\n            # 80: \\x50 Request Push 1 byte: Push command id\n            push_command_id = self._decode_field(FIELD_BYTE)\n            push_message = self._decode_field( FIELD_STRING )\n            _, payload = self.get_serializer().decode(push_message)\n            if self._push_callback:\n                self._push_callback(push_command_id, payload)\n\n            end_flag = self._decode_field( FIELD_BYTE )\n\n            # this flag can be set more than once\n            while end_flag == 3:\n                self._decode_field( FIELD_INT )  # FAKE SESSION ID = 2^-31\n                op_code = self._decode_field( FIELD_BYTE )  # 80: 0x50 Request Push\n\n                # REQUEST_PUSH_RECORD\t        79\n                # REQUEST_PUSH_DISTRIB_CONFIG\t80\n                # REQUEST_PUSH_LIVE_QUERY\t    81\n                if op_code == 80:\n                    # for node in\n                    payload = self.get_serializer().decode(\n                        self._decode_field( FIELD_STRING )\n                    )  # JSON WITH THE NEW CLUSTER CFG\n\n                    # reset the nodelist\n                    self._node_list = []\n                    for node in payload['members']:\n                        self._node_list.append( OrientNode( node ) )\n\n                end_flag = self._decode_field( FIELD_BYTE )\n\n            # Try to set the new session id???\n            self._header[1] = self._decode_field( FIELD_INT )  # REAL SESSION ID\n            pass\n\n        from .connection import ConnectMessage\n        from .database import DbOpenMessage\n        \"\"\"\n        #  Token authentication handling\n        #  we must recognize ConnectMessage and DbOpenMessage messages\n            TODO: change this check avoiding cross import,\n            importing a subclass in a super class is bad\n        \"\"\"\n        if not isinstance(self, (ConnectMessage, DbOpenMessage)) \\\n                and self._request_token is True:\n            token_refresh = self._decode_field(FIELD_STRING)\n            if token_refresh != b'':\n                self._auth_token = token_refresh\n                self._update_socket_token()\n\n    def _decode_body(self):\n        # read body\n        for field in self._fields_definition:\n            self._body.append( self._decode_field( field ) )\n\n        # clear field stack\n        self._reset_fields_definition()\n        return self\n\n    def _decode_all(self):\n        self._decode_header()\n        self._decode_body()\n\n    def fetch_response(self, *_continue):\n        \"\"\"\n        # Decode header and body\n        # If flag continue is set( Header already read ) read only body\n        :param _continue:\n        :return:\n        \"\"\"\n        if len(_continue) is not 0:\n            self._body = []\n            self._decode_body()\n            self.dump_streams()\n        # already fetched, get last results as cache info\n        elif len(self._body) is 0:\n            self._decode_all()\n            self.dump_streams()\n        return self._body\n\n    def dump_streams(self):\n        if is_debug_active():\n            if len( self._output_buffer ):\n                print(\"\\nRequest :\")\n                hexdump( self._output_buffer )\n                # print(repr(self._output_buffer))\n            if len( self._input_buffer ):\n                print(\"\\nResponse:\")\n                hexdump( self._input_buffer )\n                # print(repr(self._input_buffer))\n\n    def _append(self, field):\n        \"\"\"\n        @:rtype self: BaseMessage\n        @type field: object\n        \"\"\"\n        self._fields_definition.append( field )\n        return self\n\n    def __str__(self):\n\n        return \"\\n_output_buffer: \\n\" + hexdump( self._output_buffer, 'return' ) \\\n               + \"\\n\\n_input_buffer: \\n\" + hexdump( self._input_buffer, 'return' )\n\n    def send(self):\n        if self._orientSocket.in_transaction is False:\n            self._orientSocket.write( self._output_buffer )\n            self._reset_fields_definition()\n        if is_debug_active():\n            self.dump_streams()\n            # reset output buffer\n            self._output_buffer = b\"\"\n\n        return self\n\n    def close(self):\n        self._orientSocket.close()\n\n    @staticmethod\n    def _encode_field(field):\n\n        # tuple with type\n        t, v = field\n        _content = None\n\n        if t['type'] == INT:\n            _content = struct.pack(\"!i\", v)\n        elif t['type'] == SHORT:\n            _content = struct.pack(\"!h\", v)\n        elif t['type'] == LONG:\n            _content = struct.pack(\"!q\", v)\n        elif t['type'] == BOOLEAN:\n            if sys.version_info[0] < 3:\n                _content = chr(1) if v else chr(0)\n            else:\n                _content = bytes([1]) if v else bytes([0])\n        elif t['type'] == BYTE:\n            if sys.version_info[0] < 3:\n                _content = v\n            else:\n                _content = bytes([ord(v)])\n        elif t['type'] == BYTES:\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRING:\n            if sys.version_info[0] >= 3:\n                if isinstance(v, str):\n                    v = v.encode('utf-8')\n            else:\n                if isinstance(v, unicode):\n                    v = v.encode('utf-8')\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRINGS:\n            _content = b''\n            for s in v:\n                if sys.version_info[0] >= 3:\n                    if isinstance(s, str):\n                        s = s.encode('utf-8')\n                else:\n                    if isinstance(s, unicode):\n                        s = s.encode('utf-8')\n                _content += struct.pack(\"!i\", len(s)) + s\n\n        return _content\n\n    def _decode_field(self, _type):\n        _value = b\"\"\n        # read buffer length and decode value by field definition\n        if _type['bytes'] is not None:\n            _value = self._orientSocket.read( _type['bytes'] )\n        # if it is a string decode first 4 Bytes as INT\n        # and try to read the buffer\n        if _type['type'] == STRING or _type['type'] == BYTES:\n\n            _len = struct.unpack('!i', _value)[0]\n            if _len == -1 or _len == 0:\n                _decoded_string = b''\n            else:\n                _decoded_string = self._orientSocket.read( _len )\n\n            self._input_buffer += _value\n            self._input_buffer += _decoded_string\n\n            return _decoded_string\n\n        elif _type['type'] == RECORD:\n\n            # record_type\n            record_type = self._decode_field( _type['struct'][0] )\n\n            rid = \"#\" + str( self._decode_field( _type['struct'][1] ) )\n            rid += \":\" + str( self._decode_field( _type['struct'][2] ) )\n            \n            version = self._decode_field( _type['struct'][3] )\n            content = self._decode_field( _type['struct'][4] )\n            return {'rid': rid, 'record_type': record_type,\n                    'content': content, 'version': version}\n\n        elif _type['type'] == LINK:\n\n            rid = \"#\" + str( self._decode_field( _type['struct'][0] ) )\n            rid += \":\" + str( self._decode_field( _type['struct'][1] ) )\n            return rid\n\n        else:\n            self._input_buffer += _value\n\n            if _type['type'] == BOOLEAN:\n                return ord(_value) == 1\n            elif _type['type'] == BYTE:\n                return ord(_value)\n            elif _type['type'] == CHAR:\n                return _value\n            elif _type['type'] == SHORT:\n                return struct.unpack('!h', _value)[0]\n            elif _type['type'] == INT:\n                return struct.unpack('!i', _value)[0]\n            elif _type['type'] == LONG:\n                return struct.unpack('!q', _value)[0]\n\n    def _read_async_records(self):\n        \"\"\"\n        # async-result-type byte as trailing byte of a record can be:\n        # 0: no records remain to be fetched\n        # 1: a record is returned as a result set\n        # 2: a record is returned as pre-fetched to be loaded in client's\n        #       cache only. It's not part of the result set but the client\n        #       knows that it's available for later access\n        \"\"\"\n        _status = self._decode_field( FIELD_BYTE )  # status\n\n        while _status != 0:\n\n            try:\n\n                # if a callback for the cache is not set, raise exception\n                if not hasattr(self._callback, '__call__'):\n                    raise AttributeError()\n\n                _record = self._read_record()\n\n                if _status == 1:  # async record type\n                    # async_records.append( _record )  # save in async\n                    self._callback( _record )  # save in async\n                elif _status == 2:  # cache\n                    # cached_records.append( _record )  # save in cache\n                    self._callback( _record )  # save in cache\n\n            except AttributeError:\n                # AttributeError: 'RecordLoadMessage' object has\n                # no attribute '_command_type'\n                raise PyOrientBadMethodCallException(\n                    str(self._callback) + \" is not a callable function\", [])\n            finally:\n                # read new status and flush the debug buffer\n                _status = self._decode_field( FIELD_BYTE )  # status\n\n    def _read_record(self):\n        \"\"\"\n        # The format depends if a RID is passed or an entire\n            record with its content.\n\n        # In case of null record then -2 as short is passed.\n\n        # In case of RID -3 is passes as short and then the RID:\n            (-3:short)(cluster-id:short)(cluster-position:long).\n\n        # In case of record:\n            (0:short)(record-type:byte)(cluster-id:short)\n            (cluster-position:long)(record-version:int)(record-content:bytes)\n\n        :raise: PyOrientNullRecordException\n        :return: OrientRecordLink,OrientRecord\n        \"\"\"\n        marker = self._decode_field( FIELD_SHORT )  # marker\n\n        if marker is -2:\n            raise PyOrientNullRecordException('NULL Record', [])\n        elif marker is -3:\n            res = OrientRecordLink( self._decode_field( FIELD_TYPE_LINK ) )\n        else:\n            # read record\n            __res = self._decode_field( FIELD_RECORD )\n            \n            if self._orientSocket.serialization_type==OrientSerialization.Binary:\n                class_name, data = self.get_serializer().decode(__res['content'])\n            else:\n                # bug in orientdb csv serialization in snapshot 2.0\n                class_name, data = self.get_serializer().decode(__res['content'].rstrip())\n\n\n            res = OrientRecord(\n                dict(\n                    __o_storage=data,\n                    __o_class=class_name,\n                    __version=__res['version'],\n                    __rid=__res['rid']\n                )\n            )\n\n        self.dump_streams()  # debug log\n        self._output_buffer = b''\n        self._input_buffer = b''\n\n        return res\npyorient/constants.py\nFIELD_STRING = {\"type\": STRING, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nCONNECT_OP                 = chr(2)\npyorient/exceptions.py\nclass PyOrientBadMethodCallException(PyOrientException):\n    pass\npyorient/constants.py\nVERSION = \"1.5.5\"\npyorient/constants.py\nFIELD_SHORT = {\"type\": SHORT, \"bytes\": 2, \"struct\": None}\npyorient/constants.py\nNAME = \"OrientDB Python binary client (pyorient)\"\npyorient/constants.py\nFIELD_STRINGS = {\"type\": STRINGS, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nFIELD_BYTE = {\"type\": BYTE, \"bytes\": 1, \"struct\": None}\npyorient/constants.py\nSHUTDOWN_OP                = chr(1)\npyorient/constants.py\nFIELD_INT = {\"type\": INT, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nFIELD_BOOLEAN = {\"type\": BOOLEAN, \"bytes\": 1, \"struct\": None}\n", "answers": ["        self._append( ( FIELD_STRINGS, [NAME, VERSION] ) )"], "length": 1700, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "8bdb4903740c13b8b28717dd2d3042830565ce341f6041ca"}
{"input": "import pytest\nimport itertools as it\nfrom ..lazy_synth import (modulo_counter, line, impulse, ones, zeros, zeroes,\n                          white_noise, gauss_noise, TableLookup, fadein,\n                          fadeout, sin_table, saw_table)\nfrom ..lazy_stream import Stream\nfrom ..lazy_misc import almost_eq, sHz, blocks, rint, lag2freq\nfrom ..lazy_compat import orange, xrange, xzip\nfrom ..lazy_itertools import count\nfrom ..lazy_math import pi, inf\n# -*- coding: utf-8 -*-\n# This file is part of AudioLazy, the signal processing Python package.\n# Copyright (C) 2012-2016 Danilo de Jesus da Silva Bellini\n#\n# AudioLazy is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nTesting module for the lazy_synth module\n\"\"\"\n\np = pytest.mark.parametrize\n\n\n# Audiolazy internal imports\n\n\nclass TestLineFadeInFadeOut(object):\n\n  def test_line(self):\n    s, Hz = sHz(rate=2)\n    L = line(4 * s, .1, .9)\n    assert almost_eq(L, (.1 * x for x in xrange(1, 9)))\n\n  def test_line_append(self):\n    s, Hz = sHz(rate=3)\n    L1 = line(2 * s, 2, 8)\n    L1_should = [2, 3, 4, 5, 6, 7]\n    L2 = line(1 * s, 8, -1)\n    L2_should = [8, 5, 2]\n    L3 = line(2 * s, -1, 9, finish=True)\n    L3_should = [-1, 1, 3, 5, 7, 9]\n    env = L1.append(L2).append(L3)\n    env = env.map(int)\n    env_should = L1_should + L2_should + L3_should\n    assert list(env) == env_should\n\n  def test_fade_in(self):\n    s, Hz = sHz(rate=4)\n    L = fadein(2.5 * s)\n    assert almost_eq(L, (.1 * x for x in xrange(10)))\n\n  def test_fade_out(self):\n    s, Hz = sHz(rate=5)\n", "context": "audiolazy/lazy_math.py\ndef log(x, base=None):\ndef log1p(x):\ndef log10(x):\ndef log2(x):\ndef factorial(n):\ndef dB10(data):\ndef dB20(data):\ndef sign(x):\naudiolazy/lazy_synth.py\ndef modulo_counter(start=0., modulo=256., step=1.):\ndef line(dur, begin=0., end=1., finish=False):\ndef fadein(dur):\ndef fadeout(dur):\ndef attack(a, d, s):\ndef ones(dur=None):\ndef zeros(dur=None):\ndef adsr(dur, a, d, s, r):\ndef white_noise(dur=None, low=-1., high=1.):\ndef gauss_noise(dur=None, mu=0., sigma=1.):\n  def __binary__(cls, op):\n    def dunder(self, other):\n  def __rbinary__(cls, op):\n    def dunder(self, other):\n  def __unary__(cls, op):\n    def dunder(self):\n  def __init__(self, table, cycles=1):\n  def table(self):\n  def table(self, value):\n  def __len__(self):\n  def __call__(self, freq, phase=0.):\n  def __getitem__(self, idx):\n  def __eq__(self, other):\n  def __ne__(self, other):\n  def harmonize(self, harmonics_dict):\n  def normalize(self):\ndef sinusoid(freq, phase=0.):\ndef impulse(dur=None, one=1., zero=0.):\ndef karplus_strong(freq, tau=2e4, memory=white_noise):\nclass TableLookupMeta(AbstractOperatorOverloaderMeta):\nclass TableLookup(meta(metaclass=TableLookupMeta)):\nDEFAULT_TABLE_SIZE = 2**16\naudiolazy/lazy_misc.py\ndef sHz(rate):\n  \"\"\"\n  Unit conversion constants.\n\n  Useful for casting to/from the default package units (number of samples for\n  time and rad/second for frequency). You can use expressions like\n  ``440 * Hz`` to get a frequency value, or assign like ``kHz = 1e3 * Hz`` to\n  get other unit, as you wish.\n\n  Parameters\n  ----------\n  rate :\n    Sample rate in samples per second\n\n  Returns\n  -------\n  A tuple ``(s, Hz)``, where ``s`` is the second unit and ``Hz`` is the hertz\n  unit, as the number of samples and radians per sample, respectively.\n\n  \"\"\"\n  return float(rate), 2 * pi / rate\naudiolazy/lazy_compat.py\ndef orange(*args, **kwargs):\ndef iteritems(dictionary):\ndef itervalues(dictionary):\ndef im_func(method):\ndef meta(*bases, **kwargs):\n    def __new__(mcls, name, mbases, namespace):\nPYTHON2 = sys.version_info.major == 2\nSTR_TYPES = (getattr(builtins, \"basestring\", str),)\nINT_TYPES = (int, getattr(builtins, \"long\", None)) if PYTHON2 else (int,)\nSOME_GEN_TYPES = (types.GeneratorType, xrange(0).__class__, enumerate, xzip,\n                  xzip_longest, xmap, xfilter)\nNEXT_NAME = \"next\" if PYTHON2 else \"__next__\"\nHAS_MATMUL = sys.version_info >= (3,5)\n  class NewMeta(type):\naudiolazy/lazy_itertools.py\ndef accumulate(iterable):\ndef tee(data, n=2):\naudiolazy/lazy_misc.py\ndef rint(x, step=1):\n  \"\"\"\n  Round to integer.\n\n  Parameters\n  ----------\n  x :\n    Input number (integer or float) to be rounded.\n  step :\n    Quantization level (defaults to 1). If set to 2, the output will be the\n    \"best\" even number.\n\n  Result\n  ------\n  The step multiple nearest to x. When x is exactly halfway between two\n  possible outputs, it'll result the one farthest to zero.\n\n  \"\"\"\n  div, mod = divmod(x, step)\n  err = min(step / 10., .1)\n  result = div * step\n  if x > 0:\n    result += err\n  elif x < 0:\n    result -= err\n  if (operator.ge if x >= 0 else operator.gt)(2 * mod, step):\n    result += step\n  return int(result)\naudiolazy/lazy_misc.py\ndef blocks(seq, size=None, hop=None, padval=0.):\n  \"\"\"\n  General iterable blockenizer.\n\n  Generator that gets ``size`` elements from ``seq``, and outputs them in a\n  collections.deque (mutable circular queue) sequence container. Next output\n  starts ``hop`` elements after the first element in last output block. Last\n  block may be appended with ``padval``, if needed to get the desired size.\n\n  The ``seq`` can have hybrid / hetherogeneous data, it just need to be an\n  iterable. You can use other type content as padval (e.g. None) to help\n  segregate the padding at the end, if desired.\n\n  Note\n  ----\n  When hop is less than size, changing the returned contents will keep the\n  new changed value in the next yielded container.\n\n  \"\"\"\n  # Initialization\n  res = deque(maxlen=size) # Circular queue\n  idx = 0\n  last_idx = size - 1\n  if hop is None:\n    hop = size\n  reinit_idx = size - hop\n\n  # Yields each block, keeping last values when needed\n  if hop <= size:\n    for el in seq:\n      res.append(el)\n      if idx == last_idx:\n        yield res\n        idx = reinit_idx\n      else:\n        idx += 1\n\n  # Yields each block and skips (loses) data due to hop > size\n  else:\n    for el in seq:\n      if idx < 0: # Skips data\n        idx += 1\n      else:\n        res.append(el)\n        if idx == last_idx:\n          yield res\n          #res = dtype()\n          idx = size-hop\n        else:\n          idx += 1\n\n  # Padding to finish\n  if idx > max(size-hop, 0):\n    for _ in xrange(idx,size):\n      res.append(padval)\n    yield res\naudiolazy/lazy_misc.py\ndef lag2freq(v):\n  \"\"\" Converts from lag (number of samples) to frequency (rad/sample). \"\"\"\n  return 2 * pi / v\naudiolazy/lazy_stream.py\nclass Stream(meta(Iterable, metaclass=StreamMeta)):\n  \"\"\"\n  Stream class. Stream instances are iterables that can be seem as generators\n  with elementwise operators.\n\n  Examples\n  --------\n  If you want something like:\n\n  >>> import itertools\n  >>> x = itertools.count()\n  >>> y = itertools.repeat(3)\n  >>> z = 2*x + y\n  Traceback (most recent call last):\n      ...\n  TypeError: unsupported operand type(s) for *: 'int' and ...\n\n  That won't work with standard itertools. That's an error, and not only\n  __mul__ but also __add__ isn't supported by their types. On the other hand,\n  you can use this Stream class:\n\n  >>> x = Stream(itertools.count()) # Iterable\n  >>> y = Stream(3) # Non-iterable repeats endlessly\n  >>> z = 2*x + y\n  >>> z\n  <audiolazy.lazy_stream.Stream object at 0x...>\n  >>> z.take(12)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]\n\n  If you just want to use your existing code, an \"itertools\" alternative is\n  already done to help you:\n\n  >>> from audiolazy import lazy_itertools as itertools\n  >>> x = itertools.count()\n  >>> y = itertools.repeat(3)\n  >>> z = 2*x + y\n  >>> w = itertools.takewhile(lambda pair: pair[0] < 10, enumerate(z))\n  >>> list(el for idx, el in w)\n  [3, 5, 7, 9, 11, 13, 15, 17, 19, 21]\n\n  All operations over Stream objects are lazy and not thread-safe.\n\n  See Also\n  --------\n  thub :\n    \"Tee\" hub to help using the Streams like numbers in equations and filters.\n  tee :\n    Just like itertools.tee, but returns a tuple of Stream instances.\n  Stream.tee :\n    Keeps the Stream usable and returns a copy to be used safely.\n  Stream.copy :\n    Same to ``Stream.tee``.\n\n  Notes\n  -----\n  In that example, after declaring z as function of x and y, you should\n  not use x and y anymore. Use the thub() or the tee() functions, or\n  perhaps the x.tee() or x.copy() Stream methods instead, if you need\n  to use x again otherwhere.\n\n  \"\"\"\n  __ignored_classes__ = tuple()\n\n  def __init__(self, *dargs):\n    \"\"\"\n    Constructor for a Stream.\n\n    Parameters\n    ----------\n    *dargs:\n      The parameters should be iterables that will be chained together. If\n      they're not iterables, the stream will be an endless repeat of the\n      given elements. If any parameter is a generator and its contents is\n      used elsewhere, you should use the \"tee\" (Stream method or itertools\n      function) before.\n\n    Notes\n    -----\n    All operations that works on the elements will work with this iterator\n    in a element-wise fashion (like Numpy 1D arrays). When the stream\n    sizes differ, the resulting stream have the size of the shortest\n    operand.\n\n    Examples\n    --------\n    A finite sequence:\n\n    >>> x = Stream([1,2,3]) + Stream([8,5]) # Finite constructor\n    >>> x\n    <audiolazy.lazy_stream.Stream object at 0x...>\n    >>> tuple(x)\n    (9, 7)\n\n    But be careful:\n\n    >>> x = Stream(1,2,3) + Stream(8,5) # Periodic constructor\n    >>> x\n    <audiolazy.lazy_stream.Stream object at 0x...>\n    >>> x.take(15) # Don't try \"tuple\" or \"list\": this Stream is endless!\n    [9, 7, 11, 6, 10, 8, 9, 7, 11, 6, 10, 8, 9, 7, 11]\n\n    \"\"\"\n    if len(dargs) == 0:\n      raise TypeError(\"Missing argument(s)\")\n\n    elif len(dargs) == 1:\n      if isinstance(dargs[0], Iterable):\n        self._data = iter(dargs[0])\n      else:\n        self._data = it.repeat(dargs[0])\n\n    else:\n      if all(isinstance(arg, Iterable) for arg in dargs):\n        self._data = it.chain(*dargs)\n      elif not any(isinstance(arg, Iterable) for arg in dargs):\n        self._data = it.cycle(dargs)\n      else:\n        raise TypeError(\"Input with both iterables and non-iterables\")\n\n  def __iter__(self):\n    \"\"\" Returns the Stream contents iterator. \"\"\"\n    return self._data\n\n  def __bool__(self):\n    \"\"\"\n    Boolean value of a stream, called by the bool() built-in and by \"if\"\n    tests. As boolean operators \"and\", \"or\" and \"not\" couldn't be overloaded,\n    any trial to cast an instance of this class to a boolean should be seen\n    as a mistake.\n    \"\"\"\n    raise TypeError(\"Streams can't be used as booleans.\\n\"\n                    \"If you need a boolean stream, try using bitwise \"\n                    \"operators & and | instead of 'and' and 'or'. If using \"\n                    \"'not', you can use the inversion operator ~, casting \"\n                    \"its returned int back to bool.\\n\"\n                    \"If you're using it in a 'if' comparison (e.g. for unit \"\n                    \"testing), try to freeze the stream before with \"\n                    \"list(my_stream) or tuple(my_stream).\")\n\n  __nonzero__ = __bool__ # For Python 2.x compatibility\n\n  def blocks(self, *args, **kwargs):\n    \"\"\"\n    Interface to apply audiolazy.blocks directly in a stream, returning\n    another stream. Use keyword args.\n    \"\"\"\n    return Stream(blocks(iter(self), *args, **kwargs))\n\n  def take(self, n=None, constructor=list):\n    \"\"\"\n    Returns a container with the n first elements from the Stream, or less if\n    there aren't enough. Use this without args if you need only one element\n    outside a list.\n\n    Parameters\n    ----------\n    n :\n      Number of elements to be taken. Defaults to None.\n      Rounded when it's a float, and this can be ``inf`` for taking all.\n    constructor :\n      Container constructor function that can receie a generator as input.\n      Defaults to ``list``.\n\n    Returns\n    -------\n    The first ``n`` elements of the Stream sequence, created by the given\n    constructor unless ``n == None``, which means returns the next element\n    from the sequence outside any container.\n    If ``n`` is None, this can raise StopIteration due to lack of data in\n    the Stream. When ``n`` is a number, there's no such exception.\n\n    Examples\n    --------\n    >>> Stream(5).take(3) # Three elements\n    [5, 5, 5]\n    >>> Stream(1.2, 2, 3).take() # One element, outside a container\n    1.2\n    >>> Stream(1.2, 2, 3).take(1) # With n = 1 argument, it'll be in a list\n    [1.2]\n    >>> Stream(1.2, 2, 3).take(1, constructor=tuple) # Why not a tuple?\n    (1.2,)\n    >>> Stream([1, 2]).take(3) # More than the Stream size, n is integer\n    [1, 2]\n    >>> Stream([]).take() # More than the Stream size, n is None\n    Traceback (most recent call last):\n      ...\n    StopIteration\n\n    Taking rounded float quantities and \"up to infinity\" elements\n    (don't try using ``inf`` with endless Stream instances):\n\n    >>> Stream([4, 3, 2, 3, 2]).take(3.4)\n    [4, 3, 2]\n    >>> Stream([4, 3, 2, 3, 2]).take(3.6)\n    [4, 3, 2, 3]\n    >>> Stream([4, 3, 2, 3, 2]).take(inf)\n    [4, 3, 2, 3, 2]\n\n    See Also\n    --------\n    Stream.peek :\n      Returns the n first elements from the Stream, without removing them.\n\n    Note\n    ----\n    You should avoid using take() as if this would be an iterator. Streams\n    are iterables that can be easily part of a \"for\" loop, and their\n    iterators (the ones automatically used in for loops) are slightly faster.\n    Use iter() builtin if you need that, instead, or perhaps the blocks\n    method.\n\n    \"\"\"\n    if n is None:\n      return next(self._data)\n    if isinf(n) and n > 0:\n      return constructor(self._data)\n    if isinstance(n, float):\n      n = rint(n) if n > 0 else 0 # So this works with -inf and nan\n    return constructor(next(self._data) for _ in xrange(n))\n\n  def copy(self):\n    \"\"\"\n    Returns a \"T\" (tee) copy of the given stream, allowing the calling\n    stream to continue being used.\n    \"\"\"\n    a, b = it.tee(self._data) # 2 generators, not thread-safe\n    self._data = a\n    return Stream(b)\n\n  def peek(self, n=None, constructor=list):\n    \"\"\"\n    Sees/peeks the next few items in the Stream, without removing them.\n\n    Besides that this functions keeps the Stream items, it's the same to the\n    ``Stream.take()`` method.\n\n    See Also\n    --------\n    Stream.take :\n      Returns the n first elements from the Stream, removing them.\n\n    Note\n    ----\n    When applied in a StreamTeeHub, this method doesn't consume a copy.\n    Data evaluation is done only once, i.e., after peeking the data is simply\n    stored to be yielded again when asked for.\n\n    \"\"\"\n    return self.copy().take(n=n, constructor=constructor)\n\n  def skip(self, n):\n    \"\"\"\n    Throws away the first ``n`` values from the Stream.\n\n    Note\n    ----\n    Performs the evaluation lazily, i.e., the values are thrown away only\n    after requesting the next value.\n\n    \"\"\"\n    def skipper(data):\n      for _ in xrange(int(round(n))):\n        next(data)\n      for el in data:\n        yield el\n\n    self._data = skipper(self._data)\n    return self\n\n  def limit(self, n):\n    \"\"\"\n    Enforces the Stream to finish after ``n`` items.\n    \"\"\"\n    data = self._data\n    self._data = (next(data) for _ in xrange(int(round(n))))\n    return self\n\n  def __getattr__(self, name):\n    \"\"\"\n    Returns a Stream of attributes or methods, got in an elementwise fashion.\n    \"\"\"\n    if name == NEXT_NAME:\n      raise AttributeError(\"Streams are iterable, not iterators\")\n    return Stream(getattr(a, name) for a in self._data)\n\n  def __call__(self, *args, **kwargs):\n    \"\"\"\n    Returns the results from calling elementwise (where each element is\n    assumed to be callable), with the same arguments.\n    \"\"\"\n    return Stream(a(*args, **kwargs) for a in self._data)\n\n  def append(self, *other):\n    \"\"\"\n    Append self with other stream(s). Chaining this way has the behaviour:\n\n      ``self = Stream(self, *others)``\n\n    \"\"\"\n    self._data = it.chain(self._data, Stream(*other)._data)\n    return self\n\n  def map(self, func):\n    \"\"\"\n    A lazy way to apply the given function to each element in the stream.\n    Useful for type casting, like:\n\n    >>> from audiolazy import count\n    >>> count().take(5)\n    [0, 1, 2, 3, 4]\n    >>> my_stream = count().map(float)\n    >>> my_stream.take(5) # A float counter\n    [0.0, 1.0, 2.0, 3.0, 4.0]\n\n    \"\"\"\n    self._data = xmap(func, self._data)\n    return self\n\n  def filter(self, func):\n    \"\"\"\n    A lazy way to skip elements in the stream that gives False for the given\n    function.\n    \"\"\"\n    self._data = xfilter(func, self._data)\n    return self\n\n  @classmethod\n  def register_ignored_class(cls, ignore):\n    cls.__ignored_classes__ += (ignore,)\n\n  def __abs__(self):\n    return self.map(abs)\naudiolazy/lazy_misc.py\n@almost_eq.strategy(\"bits\")\ndef almost_eq(a, b, bits=32, tol=1, ignore_type=True, pad=0.):\n  \"\"\"\n  Almost equal, based on the amount of floating point significand bits.\n\n  Alternative to \"a == b\" for float numbers and iterables with float numbers,\n  and tests for sequence contents (i.e., an elementwise a == b, that also\n  works with generators, nested lists, nested generators, etc.). If the type\n  of both the contents and the containers should be tested too, set the\n  ignore_type keyword arg to False.\n  Default version is based on 32 bits IEEE 754 format (23 bits significand).\n  Could use 64 bits (52 bits significand) but needs a\n  native float type with at least that size in bits.\n  If a and b sizes differ, at least one will be padded with the pad input\n  value to keep going with the comparison.\n\n  Note\n  ----\n  Be careful with endless generators!\n\n  \"\"\"\n  if not (ignore_type or type(a) == type(b)):\n    return False\n  is_it_a = isinstance(a, Iterable)\n  is_it_b = isinstance(b, Iterable)\n  if is_it_a != is_it_b:\n    return False\n  if is_it_a:\n    return all(almost_eq.bits(ai, bi, bits, tol, ignore_type)\n               for ai, bi in xzip_longest(a, b, fillvalue=pad))\n  significand = {32: 23, 64: 52, 80: 63, 128: 112\n                }[bits] # That doesn't include the sign bit\n  power = tol - significand - 1\n  return abs(a - b) <= 2 ** power * abs(a + b)\n", "answers": ["    L = fadeout(2 * s)"], "length": 2605, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "56c45bfed224c26bb617b8089df613586ae55fa518b1a991"}
{"input": "import com.bazaarvoice.jless.ast.node.ArgumentsNode;\nimport com.bazaarvoice.jless.ast.node.ExpressionGroupNode;\nimport com.bazaarvoice.jless.ast.node.ExpressionNode;\nimport com.bazaarvoice.jless.ast.node.ExpressionPhraseNode;\nimport com.bazaarvoice.jless.ast.node.FilterArgumentNode;\nimport com.bazaarvoice.jless.ast.node.FunctionNode;\nimport com.bazaarvoice.jless.ast.node.LineBreakNode;\nimport com.bazaarvoice.jless.ast.node.MediaQueryNode;\nimport com.bazaarvoice.jless.ast.node.MediaTypeNode;\nimport com.bazaarvoice.jless.ast.node.MediaTypeRestriction;\nimport com.bazaarvoice.jless.ast.node.MultipleLineCommentNode;\nimport com.bazaarvoice.jless.ast.node.Node;\nimport com.bazaarvoice.jless.ast.node.ParametersNode;\nimport com.bazaarvoice.jless.ast.node.PropertyNode;\nimport com.bazaarvoice.jless.ast.node.RuleSetNode;\nimport com.bazaarvoice.jless.ast.node.ScopeNode;\nimport com.bazaarvoice.jless.ast.node.SelectorGroupNode;\nimport com.bazaarvoice.jless.ast.node.SelectorNode;\nimport com.bazaarvoice.jless.ast.node.SelectorSegmentNode;\nimport com.bazaarvoice.jless.ast.node.SimpleNode;\nimport com.bazaarvoice.jless.ast.node.SingleLineCommentNode;\nimport com.bazaarvoice.jless.ast.node.SpacingNode;\nimport com.bazaarvoice.jless.ast.node.VariableDefinitionNode;\nimport com.bazaarvoice.jless.ast.node.VariableReferenceNode;\n/**\n * Copyright 2010 Bazaarvoice, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author J. Ryan Stinnett (ryan.stinnett@bazaarvoice.com)\n */\n\npackage com.bazaarvoice.jless.ast.visitor;\n\n\npublic abstract class DefaultNodeVisitor implements NodeAdditionVisitor, NodeNavigationVisitor {\n    \n    protected abstract boolean defaultValue();\n    \n    // Base visit methods\n    // These eliminate the need for visit methods that no visitor uses\n    \n    @Override\n    public boolean add(Node node) {\n        return defaultValue();\n    }\n\n    @Override\n    public boolean enter(Node node) {\n        return defaultValue();\n    }\n\n    @Override\n    public boolean visit(Node node) {\n        return defaultValue();\n    }\n\n    @Override\n    public boolean exit(Node node) {\n        return defaultValue();\n    }\n\n    @Override\n    public boolean visitInvisible(Node node) {\n        return defaultValue();\n    }\n\n    // Concrete visit methods (NodeAdditionVisitor)\n\n    @Override\n    public boolean add(ParametersNode node) {\n        return defaultValue();\n    }\n\n    @Override\n    public boolean add(RuleSetNode node) {\n        return defaultValue();\n    }\n\n    @Override\n    public boolean add(ScopeNode node) {\n        return defaultValue();\n    }\n\n    @Override\n    public boolean add(SelectorNode node) {\n        return defaultValue();\n    }\n\n    @Override\n    public boolean add(MediaQueryNode node) {\n        return defaultValue();\n    }\n\n    @Override", "context": "src/main/java/com/bazaarvoice/jless/ast/node/MediaTypeRestriction.java\npublic class MediaTypeRestriction extends InternalNode {\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/MediaQueryNode.java\npublic class MediaQueryNode extends InternalNode {\n\n    public MediaQueryNode() {\n        super();\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/SingleLineCommentNode.java\npublic class SingleLineCommentNode extends SimpleNode {\n\n    public SingleLineCommentNode(String text) {\n        super(text);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean visit(NodeNavigationVisitor visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/SimpleNode.java\npublic class SimpleNode extends LeafNode {\n\n    private String _value;\n\n    public SimpleNode(String value) {\n        _value = value;\n    }\n\n    public String getValue() {\n        return _value;\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean visit(NodeNavigationVisitor visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/VariableReferenceNode.java\npublic class VariableReferenceNode extends LeafNode {\n\n    private String _name;\n\n    public VariableReferenceNode(String name) {\n        _name = name;\n    }\n\n    /**\n     * Search up the scope tree to locate the variable's value. The parser has already verified that\n     * the variable is defined.\n     */\n    public String getValue() {\n        for (ScopeNode scope = NodeTreeUtils.getParentScope(this); scope != null; scope = NodeTreeUtils.getParentScope(scope)) {\n            ExpressionGroupNode value = scope.getVariable(_name);\n            if (value == null) {\n                continue;\n            }\n\n            return value.toString();\n        }\n\n        return _name; // Unable to find the variable's value, return the name for now (helpful for debugging)\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean visit(NodeNavigationVisitor visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/SelectorSegmentNode.java\npublic class SelectorSegmentNode extends LeafNode {\n\n    public static final String NO_COMBINATOR = \"\";\n    public static final String DESCENDANT_COMBINATOR = \" \";\n\n    private String _combinator;\n    private String _simpleSelector;\n    private boolean _subElementSelector;\n    private boolean _universal;\n\n    public SelectorSegmentNode(String combinator) {\n        _combinator = combinator;\n    }\n\n    public SelectorSegmentNode(String combinator, String simpleSelector) {\n        _combinator = combinator;\n        _simpleSelector = simpleSelector;\n    }\n\n    public String getCombinator() {\n        return _combinator;\n    }\n\n    public boolean setCombinator(String combinator) {\n        _combinator = combinator;\n        return true;\n    }\n\n    public String getSimpleSelector() {\n        return _simpleSelector;\n    }\n\n    public boolean setSimpleSelector(String simpleSelector) {\n        _simpleSelector = simpleSelector;\n        return true;\n    }\n\n    /**\n     * Implies that the simple selector starts with some sub-element selection, such as an attribute or pseudo-class.\n     */\n    public boolean isSubElementSelector() {\n        return _subElementSelector;\n    }\n\n    public boolean setSubElementSelector(boolean subElementSelector) {\n        _subElementSelector = subElementSelector;\n        return true;\n    }\n\n    public boolean isUniversal() {\n        return _universal;\n    }\n\n    public boolean setUniversal(boolean universal) {\n        _universal = universal;\n        return true;\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean visit(NodeNavigationVisitor visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/VariableDefinitionNode.java\npublic class VariableDefinitionNode extends InternalNode {\n\n    private String _name;\n\n    public VariableDefinitionNode(String name) {\n        _name = name;\n    }\n\n    public String getName() {\n        return _name;\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/SelectorGroupNode.java\npublic class SelectorGroupNode extends InternalNode {\n\n    public SelectorGroupNode(Node child) {\n        super(child);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/FunctionNode.java\npublic class FunctionNode extends InternalNode {\n\n    private String _name;\n\n    public FunctionNode(String name) {\n        _name = name;\n    }\n\n    public String getName() {\n        return _name;\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/ArgumentsNode.java\npublic class ArgumentsNode extends InternalNode {\n\n    public ArgumentsNode() {\n        super();\n    }\n\n    public ArgumentsNode(Node child) {\n        super(child);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/ParametersNode.java\npublic class ParametersNode extends InternalNode {\n\n    public ParametersNode() {\n        super();\n    }\n\n    public ParametersNode(Node child) {\n        super(child);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/FilterArgumentNode.java\npublic class FilterArgumentNode extends InternalNode {\n\n    private String _name;\n\n    public FilterArgumentNode(String name) {\n        _name = name;\n    }\n\n    public String getName() {\n        return _name;\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/ExpressionNode.java\npublic class ExpressionNode extends InternalNode {\n\n    public ExpressionNode(Node child) {\n        super(child);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/ScopeNode.java\npublic class ScopeNode extends InternalNode {\n\n    private static final String FILTER_PROPERTY = \"filter\";\n\n    private Map<String, ExpressionGroupNode> _variableNameToValueMap = new HashMap<String, ExpressionGroupNode>();\n    private Map<String, RuleSetNode> _selectorToRuleSetMap = new HashMap<String, RuleSetNode>();\n    private List<VariableDefinitionNode> _parameterDefinitions = new ArrayList<VariableDefinitionNode>();\n    private Map<String, PropertyNode> _propertyNameToNodeMap = new HashMap<String, PropertyNode>();\n    private ScopeNode _parentScope;\n    private boolean _bracketsDisplayed = true;\n\n    public ScopeNode() {\n        super();\n        setAdditionVisitor();\n    }\n\n    public ScopeNode(Node node) {\n        this();\n        addChild(node);\n    }\n\n    public ScopeNode(Collection<Node> nodeCollection) {\n        this();\n        addChildren(nodeCollection);\n    }\n\n    public boolean isVariableDefined(String name) {\n        return _variableNameToValueMap.containsKey(name);\n    }\n\n    public ExpressionGroupNode getVariable(String name) {\n        return _variableNameToValueMap.get(name);\n    }\n\n    public RuleSetNode getRuleSet(String selectorGroup) {\n        return _selectorToRuleSetMap.get(selectorGroup);\n    }\n\n    public ScopeNode getParentScope() {\n        return _parentScope;\n    }\n\n    public void setParentScope(ScopeNode parentScope) {\n        _parentScope = parentScope;\n    }\n\n    public boolean isBracketsDisplayed() {\n        return _bracketsDisplayed;\n    }\n\n    public void setBracketsDisplayed(boolean bracketsDisplayed) {\n        _bracketsDisplayed = bracketsDisplayed;\n    }\n\n    /**\n     * Creates a clone of this scope to be attached to the tree at the site of a mixin reference. If an ArgumentsNode is passed,\n     * each of its values override those defined by the mixin's parameters.\n     */\n    public ScopeNode callMixin(String name, ArgumentsNode arguments) {\n        List<ExpressionGroupNode> argumentList = (arguments != null) ? NodeTreeUtils.getChildren(arguments, ExpressionGroupNode.class) : Collections.<ExpressionGroupNode>emptyList();\n        if (argumentList.size() > _parameterDefinitions.size()) {\n            throw new IllegalMixinArgumentException(name, _parameterDefinitions.size());\n        }\n\n        // Clone scope and filter out any white space\n        ScopeNode mixinScope = clone();\n        NodeTreeUtils.filterLineBreaks(mixinScope);\n\n        // If arguments were passed, apply them\n        for (int i = 0; i < argumentList.size(); i++) {\n            ExpressionGroupNode argument = argumentList.get(i);\n            // Replace the value of the definition\n            VariableDefinitionNode parameter = mixinScope._parameterDefinitions.get(i);\n            parameter.clearChildren();\n            parameter.addChild(argument);\n        }\n\n        // Mark this scope's containing rule set as invisible since it has been used as a mixin\n        getParent().setVisible(false);\n\n        return mixinScope;\n    }\n\n    /**\n     * Some nodes are captured in additional structures to aid later resolution.\n     */\n    private void setAdditionVisitor() {\n        setAdditionVisitor(new InclusiveNodeVisitor() {\n            /**\n             * Add parameter set as a child for printing input, but also add each defined value to the variable map.\n             */\n            @Override\n            public boolean add(ParametersNode node) {\n                for (VariableDefinitionNode variable : NodeTreeUtils.getChildren(node, VariableDefinitionNode.class)) {\n                    _parameterDefinitions.add(variable);\n                    add(variable);\n                }\n                return super.add(node);\n            }\n\n            /**\n             * Store the rule set's scope by selector group\n             */\n            @Override\n            public boolean add(RuleSetNode node) {\n                SelectorGroupNode selectorGroup = NodeTreeUtils.getFirstChild(node, SelectorGroupNode.class);\n                for (SelectorNode selectorNode : NodeTreeUtils.getChildren(selectorGroup, SelectorNode.class)) {\n                    StringBuilder sb = new StringBuilder();\n                    for (Node selectorChild : selectorNode.getChildren()) {\n                        sb.append(selectorChild.toString());\n                    }\n                    String selector = sb.toString();\n                    // Mixins lock on first definition\n                    if (!_selectorToRuleSetMap.containsKey(selector)) {\n                        _selectorToRuleSetMap.put(selector, node);\n                    }\n                }\n                return super.add(node);\n            }\n\n            /**\n             * Absorb all children of the given scope. This assumes that cloning is not necessary.\n             */\n            @Override\n            public boolean add(ScopeNode node) {\n                NodeTreeUtils.moveChildren(node, ScopeNode.this);\n                return false; // Don't add the original scope itself\n            }\n\n            /**\n             * Store variable definitions in a map by name\n             */\n            @Override\n            public boolean add(VariableDefinitionNode node) {\n                String name = node.getName();\n                // \"Variables\" lock on first definition\n                if (!_variableNameToValueMap.containsKey(name)) {\n                    _variableNameToValueMap.put(name, NodeTreeUtils.getFirstChild(node, ExpressionGroupNode.class));\n                }\n                return super.add(node);\n            }\n\n            /**\n             * Store property nodes by name. If there are multiple properties for a given name, only retain the last one.\n             */\n            @Override\n            public boolean add(PropertyNode node) {\n                String name = node.getName();\n\n                // If this is the IE-specific \"filter\" property, always add it\n                if (name.equals(FILTER_PROPERTY)) {\n                    return super.add(node);\n                }\n\n                // If the value of this property node is a vendor-specific keyword, always add it\n                if (node.getChildren().get(0).toString().startsWith(\"-\")) {\n                    return super.add(node);\n                }\n\n                // Check if this property has been seen before\n                if (_propertyNameToNodeMap.containsKey(name)) {\n                    PropertyNode oldPropertyNode = _propertyNameToNodeMap.get(name);\n                    int oldPropertyIndex = getChildren().indexOf(oldPropertyNode);\n\n                    if (oldPropertyNode.isVisible()) {\n                        // Hide the unneeded property\n                        oldPropertyNode.setVisible(false);\n\n                        // Attempt to hide one surrounding white space node\n                        if (!hideWhiteSpaceNode(oldPropertyIndex - 1)) {\n                            hideWhiteSpaceNode(oldPropertyIndex + 1);\n                        }\n                    }\n                }\n\n                // Store the property as the latest for this name\n                _propertyNameToNodeMap.put(name, node);\n\n                return super.add(node);\n            }\n        });\n    }\n\n    private boolean hideWhiteSpaceNode(int index) {\n        if (index < 0 || index >= getChildren().size()) {\n            return false;\n        }\n\n        Node node = getChildren().get(index);\n        if (!(node instanceof WhiteSpaceCollectionNode || node instanceof SpacingNode) || !node.isVisible()) {\n            return false;\n        }\n\n        node.setVisible(false);\n        return true;\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n\n    /**\n     * The internal state of this node will be rebuilt as cloned children are added by the super class.\n     */\n    @Override\n    public ScopeNode clone() {\n        return (ScopeNode) super.clone();\n    }\n\n    /**\n     * Recreate internal state before children are cloned.\n     */\n    @Override\n    protected void cloneChildren(InternalNode node) {\n        ScopeNode scope = (ScopeNode) node;\n\n        // Reset internal state\n        scope._variableNameToValueMap = new HashMap<String, ExpressionGroupNode>();\n        scope._selectorToRuleSetMap = new HashMap<String, RuleSetNode>();\n        scope._parameterDefinitions = new ArrayList<VariableDefinitionNode>();\n        scope._propertyNameToNodeMap = new HashMap<String, PropertyNode>();\n        scope.setAdditionVisitor();\n\n        super.cloneChildren(node);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/ExpressionPhraseNode.java\npublic class ExpressionPhraseNode extends InternalNode {\n\n    public ExpressionPhraseNode(Node child) {\n        super(child);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/ExpressionGroupNode.java\npublic class ExpressionGroupNode extends InternalNode {\n\n    public ExpressionGroupNode() {\n        super();\n    }\n\n    public ExpressionGroupNode(Node node) {\n        super(node);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/LineBreakNode.java\npublic class LineBreakNode extends LeafNode {\n    \n    private int _lineBreaks;\n\n    public LineBreakNode(String text) {\n        _lineBreaks = StringUtils.countMatches(text, \"\\n\");\n    }\n\n    public LineBreakNode(int count) {\n        _lineBreaks = count;\n    }\n\n    @Override\n    protected boolean hasData() {\n        return _lineBreaks > 0;\n    }\n\n    public int getLineBreaks() {\n        return _lineBreaks;\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean visit(NodeNavigationVisitor visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/Node.java\npublic abstract class Node implements MutableTreeNode<Node>, Cloneable {\n    private InternalNode _parent;\n    private boolean _visible = true;\n\n    @Override\n    public InternalNode getParent() {\n        return _parent;\n    }\n\n    public void setParent(InternalNode parent) {\n        _parent = parent;\n    }\n\n    public boolean isVisible() {\n        return _visible;\n    }\n\n    /**\n     * Controls whether the node and its children will be visited by a traversal visitor.\n     */\n    public boolean setVisible(boolean visible) {\n        _visible = visible;\n        return true;\n    }\n\n    /**\n     * This simplifies parsing rules by allowing you to always create nodes and call addChild(),\n     * and then the concrete node can report whether it actually contains data that should be\n     * added to the AST.\n     */\n    protected boolean hasData() {\n        return true;\n    }\n\n    public abstract boolean addChild(Node child);\n\n    protected abstract boolean add(NodeAdditionVisitor visitor);\n\n    protected abstract boolean visitInvisible(NodeNavigationVisitor visitor);\n\n    public abstract boolean filter(NodeNavigationVisitor visitor);\n\n    public abstract boolean traverse(NodeNavigationVisitor visitor);\n\n    @SuppressWarnings ({\"unchecked\", \"CloneDoesntDeclareCloneNotSupportedException\"})\n    @Override\n    public Node clone() {\n        Node node;\n        try {\n            // Clone any primitive fields\n            node = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new IllegalStateException(\"Object is marked Cloneable, but super.clone() failed.\");\n        }\n\n        // Reset internal state\n        node._parent = null;\n\n        return node;\n    }\n\n    @Override\n    public String toString() {\n        Printer p = new Printer() {\n            @Override\n            public boolean visitInvisible(Node node) {\n                return true; // Always print invisible nodes\n            }\n        };\n        traverse(p);\n        return p.toString();\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/PropertyNode.java\npublic class PropertyNode extends InternalNode {\n\n    private String _name;\n\n    public PropertyNode(String name) {\n        _name = name;\n    }\n\n    public String getName() {\n        return _name;\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/SpacingNode.java\npublic class SpacingNode extends SimpleNode {\n\n    public SpacingNode(String text) {\n        super(text);\n    }\n\n    @Override\n    protected boolean hasData() {\n        return getValue().length() > 0;\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean visit(NodeNavigationVisitor visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/RuleSetNode.java\npublic class RuleSetNode extends InternalNode {\n\n    public RuleSetNode() {\n        super();\n    }\n\n    public RuleSetNode(Node child) {\n        super(child);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/MultipleLineCommentNode.java\npublic class MultipleLineCommentNode extends SimpleNode {\n\n    public MultipleLineCommentNode(String text) {\n        super(text);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean visit(NodeNavigationVisitor visitor) {\n        return visitor.visit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/SelectorNode.java\npublic class SelectorNode extends InternalNode {\n\n    public SelectorNode() {\n        super();\n        setAdditionVisitor();\n    }\n\n    public SelectorNode(Node child) {\n        this();\n        addChild(child);\n    }\n\n    private void setAdditionVisitor() {\n        setAdditionVisitor(new InclusiveNodeVisitor() {\n            /**\n             * Absorb all children of the given selector. This assumes that cloning is not necessary.\n             */\n            @Override\n            public boolean add(SelectorNode selector) {\n                // If the first segment is a universal (\"*\") segment, it must remain first in the list\n                SelectorSegmentNode sourceSegment = NodeTreeUtils.getFirstChild(selector, SelectorSegmentNode.class);\n                if (sourceSegment.isUniversal()) {\n                    // If the first destination segment is not a sub-element selector and it has no combinator,\n                    // switch it to the descendant combinator before absorbing the universal segment.\n                    setCombinatorIfNotSubElement(SelectorNode.this);\n                    // Add the universal HTML segment at the front of the list\n                    addChild(0, sourceSegment);\n                }\n\n                // If the first source segment is not a sub-element selector and it has no combinator,\n                // switch it to the descendant combinator before absorbing the segments.\n                setCombinatorIfNotSubElement(selector);\n\n                NodeTreeUtils.moveChildren(selector, SelectorNode.this);\n                return false; // Don't add the original selector itself\n            }\n        });\n    }\n\n    private void setCombinatorIfNotSubElement(SelectorNode selector) {\n        SelectorSegmentNode sourceSegment = NodeTreeUtils.getFirstChild(selector, SelectorSegmentNode.class);\n        if (!sourceSegment.isSubElementSelector() && sourceSegment.getCombinator().equals(SelectorSegmentNode.NO_COMBINATOR)) {\n            sourceSegment.setCombinator(SelectorSegmentNode.DESCENDANT_COMBINATOR);\n        }\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n\n    /**\n     * The internal state of this node will be rebuilt as cloned children are added by the super class.\n     */\n    @Override\n    public SelectorNode clone() {\n        return (SelectorNode) super.clone();\n    }\n\n    /**\n     * Recreate internal state before children are cloned.\n     */\n    @Override\n    protected void cloneChildren(InternalNode node) {\n        SelectorNode selector = (SelectorNode) node;\n\n        // Reset internal state\n        selector.setAdditionVisitor();\n\n        super.cloneChildren(node);\n    }\n}\nsrc/main/java/com/bazaarvoice/jless/ast/node/MediaTypeNode.java\npublic class MediaTypeNode extends InternalNode  {\n\n    @Override\n    protected boolean enter(NodeNavigationVisitor visitor) {\n        return visitor.enter(this);\n    }\n\n    @Override\n    protected boolean exit(NodeNavigationVisitor visitor) {\n        return visitor.exit(this);\n    }\n\n    @Override\n    protected boolean add(NodeAdditionVisitor visitor) {\n        return visitor.add(this);\n    }\n\n    @Override\n    protected boolean visitInvisible(NodeNavigationVisitor visitor) {\n        return visitor.visitInvisible(this);\n    }\n}\n", "answers": ["    public boolean add(MediaTypeNode node) {"], "length": 2828, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "39da528c23289d7eb9520128b82be35afc0c6491a307b734"}
{"input": "from django.contrib.auth import (\n    REDIRECT_FIELD_NAME,\n    get_user_model,\n    login,\n    update_session_auth_hash,\n)\nfrom django.contrib.auth.forms import PasswordChangeForm\nfrom django.contrib.auth.views import LoginView, LogoutView\nfrom django.http import Http404\nfrom django.shortcuts import redirect\nfrom django.urls import reverse\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.debug import sensitive_post_parameters\nfrom django.views.generic import (\n    CreateView,\n    DetailView,\n    ListView,\n    TemplateView,\n    UpdateView,\n)\nfrom manifest import defaults, messages, signals\nfrom manifest.forms import (\n    EmailChangeForm,\n    LoginForm,\n    ProfileUpdateForm,\n    RegisterForm,\n)\nfrom manifest.mixins import (\n    EmailChangeMixin,\n    LoginRequiredMixin,\n    MessageMixin,\n    SecureRequiredMixin,\n    SendActivationMailMixin,\n    UserFormMixin,\n)\nfrom manifest.utils import get_login_redirect\n# -*- coding: utf-8 -*-\n\"\"\" Manifest Views\n\"\"\"\n\n\n\n\n@method_decorator(sensitive_post_parameters(\"password\"), name=\"dispatch\")\nclass AuthLoginView(LoginView, SecureRequiredMixin, MessageMixin):\n    \"\"\"Authenticate user by email or username with password.\n\n    If the credentials are correct and the user ``is_active``,\n    user will be redirected to ``success_url`` if it is defined.\n\n    If ``success_url`` is not defined, the ``login_redirect`` function\n    will be called with the arguments ``REDIRECT_FIELD_NAME`` and an\n    instance of the ``User`` who is trying the login. The returned\n    value of the function will be the URL that will be redirected to.\n    \"\"\"\n\n    form_class = LoginForm\n    template_name = \"manifest/auth_login.html\"\n    success_message = messages.AUTH_LOGIN_SUCCESS\n    redirect_authenticated_user = True\n\n    def form_valid(self, form):\n        user = form.get_user()\n        if user.is_active:\n            login(self.request, user)\n            self.request.session.set_expiry(\n                defaults.MANIFEST_REMEMBER_DAYS[1] * 86400\n            )\n            self.set_success_message(self.success_message)\n            if self.success_url:\n                return redirect(self.success_url)\n", "context": "manifest/forms.py\nclass RegisterForm(UserCreationForm):\n    \"\"\"\n    Form for creating a new user account.\n\n    Validates that the requested username and email is not already in use.\n    Also requires the password to be entered twice.\n\n    \"\"\"\n\n    username = forms.RegexField(\n        label=_(\"Username\"),\n        regex=r\"^\\w+$\",\n        max_length=30,\n        widget=forms.TextInput(\n            attrs=dict(ATTRS_DICT, placeholder=_(\"Pick a username\"))\n        ),\n        error_messages={\n            \"invalid\": _(\n                \"Username must contain only letters, numbers and underscores.\"\n            )\n        },\n    )\n\n    email = forms.EmailField(\n        label=_(\"Email address\"),\n        widget=forms.TextInput(\n            attrs=dict(\n                ATTRS_DICT,\n                maxlength=75,\n                placeholder=_(\"Enter your email address\"),\n            )\n        ),\n    )\n\n    password1 = forms.CharField(\n        label=_(\"Password\"),\n        widget=forms.PasswordInput(\n            attrs=dict(ATTRS_DICT, placeholder=_(\"Enter a password\"))\n        ),\n    )\n\n    password2 = forms.CharField(\n        label=_(\"Comfirm pasword\"),\n        widget=forms.PasswordInput(\n            attrs=dict(ATTRS_DICT, placeholder=_(\"Enter password again\"))\n        ),\n    )\n\n    class Meta:\n        model = get_user_model()\n        fields = [\"username\", \"email\", \"password1\", \"password2\"]\n\n    def clean_username(self):\n        \"\"\"\n        Validate that the username is unique and not listed\n        in ``defaults.MANIFEST_FORBIDDEN_USERNAMES`` list.\n\n        \"\"\"\n        try:\n            get_user_model().objects.get(\n                username=self.cleaned_data[\"username\"]\n            )\n        except get_user_model().DoesNotExist:\n            pass\n        else:\n            raise forms.ValidationError(\n                _(\"A user with that username already exists.\")\n            )\n        # pylint: disable=bad-continuation\n        if (\n            self.cleaned_data[\"username\"].lower()\n            in defaults.MANIFEST_FORBIDDEN_USERNAMES\n        ):\n            raise forms.ValidationError(_(\"This username is not allowed.\"))\n        return self.cleaned_data[\"username\"]\n\n    def clean_email(self):\n        \"\"\"\n        Validate that the email address is unique.\n\n        \"\"\"\n        # pylint: disable=bad-continuation\n        if get_user_model().objects.filter(\n            Q(email__iexact=self.cleaned_data[\"email\"])\n            | Q(email_unconfirmed__iexact=self.cleaned_data[\"email\"])\n        ):\n            raise forms.ValidationError(EMAIL_IN_USE_MESSAGE)\n        return self.cleaned_data[\"email\"]\n\n    def save(self, commit=True):\n        \"\"\"\n        Creates a new user and account. Returns the newly created user.\n\n        \"\"\"\n\n        user = get_user_model().objects.create_user(\n            self.cleaned_data[\"username\"],\n            self.cleaned_data[\"email\"],\n            self.cleaned_data[\"password1\"],\n            not defaults.MANIFEST_ACTIVATION_REQUIRED,\n        )\n        return user\nmanifest/mixins.py\nclass MessageMixin:\n    \"\"\"\n    View mixin adding messages to response.\n    \"\"\"\n\n    success_message = \"\"\n    error_message = \"\"\n    extra_context = None\n\n    def set_success_message(self, message):\n        if defaults.MANIFEST_USE_MESSAGES:\n            messages.success(self.request, message, fail_silently=True)\n\n    def set_error_message(self, message):\n        if defaults.MANIFEST_USE_MESSAGES:\n            messages.error(self.request, message, fail_silently=True)\nmanifest/mixins.py\nclass SecureRequiredMixin(View):\n    \"\"\"\n    Mixin that switches URL from http to https if\n    ``MANIFEST_USE_HTTPS`` setting is ``True``.\n\n    \"\"\"\n\n    @method_decorator(decorators.secure_required)\n    def dispatch(self, request, *args, **kwargs):\n        return super().dispatch(request, *args, **kwargs)\nmanifest/mixins.py\nclass LoginRequiredMixin(View):\n    \"\"\"\n    Mixin that redirects user to login form if not authenticated yet.\n\n    \"\"\"\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        return super().dispatch(request, *args, **kwargs)\nmanifest/utils.py\ndef get_login_redirect(redirect=None):\n    \"\"\"\n    Redirect user after successful login.\n\n    Returns ``redirect`` parameter if it exists and resolved, else\n    ``MANIFEST_LOGIN_REDIRECT_URL`` setting.\n\n    :param redirect:\n        A URL usually supplied by ``next`` form field.\n\n    :return: String containing the URL for redirect to.\n\n    \"\"\"\n    return redirect if redirect else defaults.MANIFEST_LOGIN_REDIRECT_URL\nmanifest/forms.py\nclass LoginForm(forms.Form):\n    \"\"\"\n    A custom form where the identification can be a email address or username.\n\n    \"\"\"\n\n    identification = forms.CharField(\n        label=_(\"Username or Email\"),\n        widget=forms.TextInput(attrs=ATTRS_DICT),\n        max_length=75,\n        error_messages={\n            \"required\": _(\"Please enter your username or email address.\")\n        },\n    )\n\n    password = forms.CharField(\n        label=_(\"Password\"),\n        widget=forms.PasswordInput(attrs=ATTRS_DICT, render_value=False),\n    )\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Custom init to set ``request`` to ``None``.\n\n        \"\"\"\n        self.user_cache = None\n        self.request = kwargs.pop(\"request\", None)\n        super().__init__(*args, **kwargs)\n\n    def clean(self):\n        \"\"\"\n        Checks for the identification and password.\n\n        If the combination can't be found will raise an invalid sign in error.\n\n        \"\"\"\n        identification = self.cleaned_data.get(\"identification\")\n        password = self.cleaned_data.get(\"password\")\n\n        if identification and password:\n            self.user_cache = authenticate(\n                identification=identification, password=password\n            )\n            if self.user_cache is None:\n                raise forms.ValidationError(\n                    _(\"Please check your identification and password.\")\n                )\n        return self.cleaned_data\n\n    def get_user(self):\n        \"\"\"\n        Returns user object.\n        \"\"\"\n        return self.user_cache\nmanifest/forms.py\nclass EmailChangeForm(forms.Form):\n    \"\"\"\n    Form for changing user email address.\n\n    \"\"\"\n\n    email = forms.EmailField(\n        label=_(\"New email\"),\n        required=True,\n        widget=forms.TextInput(attrs=dict(ATTRS_DICT, maxlength=75)),\n    )\n\n    def __init__(self, *args, user=None, **kwargs):\n        \"\"\"\n        The current ``user`` is needed for initialisation of this form so\n        that we can check if the email address is still free and not always\n        returning ``True`` for this query because it's the users own email\n        address.\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        if not isinstance(user, get_user_model()):\n            raise TypeError(_(\"User must be an instance of User\"))\n        self.user = user\n\n    def clean_email(self):\n        \"\"\"\n        Validate that the email is not already registered with another user.\n\n        \"\"\"\n        if self.cleaned_data[\"email\"].lower() == self.user.email:\n            raise forms.ValidationError(\n                _(\"You're already known under this email address.\")\n            )\n        # pylint: disable=bad-continuation\n        if (\n            get_user_model()\n            .objects.filter(email__iexact=self.cleaned_data[\"email\"])\n            .exclude(email__iexact=self.user.email)\n        ):\n            raise forms.ValidationError(EMAIL_IN_USE_MESSAGE)\n        return self.cleaned_data[\"email\"]\n\n    def save(self):\n        \"\"\"\n        Save method calls :func:`user.change_email()` method which sends out\n        an email with a verification key to verify and with it enable this\n        new email address.\n\n        \"\"\"\n        return self.user.change_email(self.cleaned_data[\"email\"])\nmanifest/messages.py\nAUTH_LOGIN_SUCCESS = _(\"User logged in.\")\nAUTH_LOGOUT_SUCCESS = _(\"User logged out.\")\nAUTH_REGISTER_SUCCESS = _(\"User registered.\")\nAUTH_REGISTER_ERROR = _(\"Registration failed.\")\nAUTH_REGISTER_FORBIDDEN = _(\"Registration forbidden.\")\nAUTH_ACTIVATE_SUCCESS = _(\"Account activated.\")\nAUTH_ACTIVATE_ERROR = _(\"Activation failed!\")\nPASSWORD_RESET_SUCCESS = _(\"Password reset sent.\")\nPASSWORD_RESET_VERIFY_SUCCESS = _(\"Token verified.\")\nPASSWORD_RESET_VERIFY_ERROR = _(\"Verification failed.\")\nPASSWORD_RESET_CONFIRM_SUCCESS = _(\"New password saved.\")\nPASSWORD_RESET_CONFIRM_ERROR = _(\"Password reset failed.\")\nPASSWORD_CHANGE_SUCCESS = _(\"Password changed.\")\nEMAIL_CHANGE_SUCCESS = _(\"Email changed.\")\nEMAIL_CHANGE_CONFIRM_SUCCESS = _(\"Email confirmed.\")\nEMAIL_CHANGE_CONFIRM_ERROR = _(\"Confirmation failed.\")\nPROFILE_UPDATE_SUCCESS = _(\"Profile updated.\")\nREGION_UPDATE_SUCCESS = _(\"Regional settings updated.\")\nPICTURE_UPLOAD_SUCCESS = _(\"Picture uploaded.\")\nEMAIL_IN_USE_MESSAGE = _(\n    \"This email address is already in use. Please supply a different email.\"\n)\nmanifest/mixins.py\nclass EmailChangeMixin(SendMailMixin):\n\n    email_subject_template_name_old = (\n        \"manifest/emails/confirmation_email_subject_old.txt\"\n    )\n    email_message_template_name_old = (\n        \"manifest/emails/confirmation_email_message_old.txt\"\n    )\n    email_html_template_name_old = None\n    email_subject_template_name_new = (\n        \"manifest/emails/confirmation_email_subject_new.txt\"\n    )\n    email_message_template_name_new = (\n        \"manifest/emails/confirmation_email_message_new.txt\"\n    )\n    email_html_template_name_new = None\n\n    def send_confirmation_mail(self, user):\n\n        context = {\n            \"user\": user,\n            \"new_email\": user.email_unconfirmed,\n            \"confirmation_key\": user.email_confirmation_key,\n        }\n\n        self.email_subject_template_name = self.email_subject_template_name_old\n        self.email_message_template_name = self.email_message_template_name_old\n        self.email_html_template_name = self.email_html_template_name_old\n        self.send_mail(user.email, context)\n\n        self.email_subject_template_name = self.email_subject_template_name_new\n        self.email_message_template_name = self.email_message_template_name_new\n        self.email_html_template_name = self.email_html_template_name_new\n        self.send_mail(user.email_unconfirmed, context)\nmanifest/forms.py\nclass ProfileUpdateForm(forms.ModelForm):\n    \"\"\" Base form used for fields that are always required \"\"\"\n\n    GENDER_CHOICES = ((\"F\", _(\"Female\")), (\"M\", _(\"Male\")))\n\n    first_name = forms.CharField(\n        label=_(\"First name\"), max_length=30, required=True\n    )\n    last_name = forms.CharField(\n        label=_(\"Last name\"), max_length=30, required=True\n    )\n\n    gender = forms.ChoiceField(\n        required=True, choices=GENDER_CHOICES, widget=forms.RadioSelect()\n    )\n    birth_date = forms.DateField(\n        required=True,\n        widget=forms.widgets.SelectDateWidget(\n            years=range(\n                datetime.today().year - 10, datetime.today().year - 99, -1\n            )\n        ),\n    )\n\n    class Meta:\n        model = get_user_model()\n        fields = [\"first_name\", \"last_name\", \"gender\", \"birth_date\"]\nmanifest/mixins.py\nclass UserFormMixin(\n    FormView, SecureRequiredMixin, LoginRequiredMixin, MessageMixin\n):\n    \"\"\"\n    Mixin that sets forms user argument to ``request.user``.\n    \"\"\"\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        kwargs[\"user\"] = self.request.user\n        return kwargs\nmanifest/defaults.py\nMANIFEST_ACTIVATED_LABEL = getattr(\n    settings, \"MANIFEST_ACTIVATED_LABEL\", \"ACCOUNT_ACTIVATED\"\n)\nMANIFEST_ACTIVATION_DAYS = getattr(settings, \"MANIFEST_ACTIVATION_DAYS\", 7)\nMANIFEST_ACTIVATION_REQUIRED = getattr(\n    settings, \"MANIFEST_ACTIVATION_REQUIRED\", True\n)\nMANIFEST_AVATAR_DEFAULT = getattr(\n    settings, \"MANIFEST_GRAVATAR_DEFAULT\", \"gravatar\"\n)\nMANIFEST_AVATAR_SIZE = getattr(settings, \"MANIFEST_AVATAR_SIZE\", 128)\nMANIFEST_DISABLE_PROFILE_LIST = getattr(\n    settings, \"MANIFEST_DISABLE_PROFILE_LIST\", False\n)\nMANIFEST_FORBIDDEN_USERNAMES = getattr(\n    settings,\n    \"MANIFEST_FORBIDDEN_USERNAMES\",\n    (\n        \"login\",\n        \"logout\",\n        \"register\",\n        \"activate\",\n        \"signin\",\n        \"signout\",\n        \"signup\",\n        \"me\",\n        \"user\",\n        \"account\",\n        \"email\",\n        \"password\",\n        \"profile\",\n        \"about\",\n        \"contact\",\n        \"test\",\n    ),\n)\nMANIFEST_GRAVATAR_DEFAULT = getattr(\n    settings, \"MANIFEST_GRAVATAR_DEFAULT\", \"identicon\"\n)\nMANIFEST_LANGUAGE_CODE = getattr(settings, \"LANGUAGE_CODE\", \"en-us\")\nMANIFEST_LOCALE_FIELD = getattr(settings, \"MANIFEST_LOCALE_FIELD\", \"locale\")\nMANIFEST_LOGIN_REDIRECT_URL = getattr(\n    settings, \"MANIFEST_LOGIN_REDIRECT_URL\", reverse_lazy(\"profile_settings\")\n)\nMANIFEST_LOGOUT_ON_GET = getattr(settings, \"MANIFEST_LOGOUT_ON_GET\", False)\nMANIFEST_PICTURE_FORMATS = getattr(\n    settings, \"MANIFEST_PICTURE_FORMATS\", [\"jpeg\", \"gif\", \"png\"]\n)\nMANIFEST_PICTURE_MAX_FILE = getattr(\n    settings, \"MANIFEST_PICTURE_MAX_FILE\", 1024 * 1024\n)\nMANIFEST_PICTURE_MAX_SIZE = getattr(\n    settings, \"MANIFEST_PICTURE_MAX_SIZE\", \"1024 x 1024\"\n)\nMANIFEST_PICTURE_PATH = getattr(settings, \"MANIFEST_PICTURE_PATH\", \"manifest\")\nMANIFEST_REDIRECT_ON_LOGOUT = getattr(\n    settings, \"MANIFEST_REDIRECT_ON_LOGOUT\", \"/\"\n)\nMANIFEST_REMEMBER_DAYS = getattr(\n    settings, \"ACCOUNTS_REMEMBER_ME_DAYS\", ((\"a month\"), 30)\n)\nMANIFEST_SESSION_LOGIN = getattr(settings, \"MANIFEST_SESSION_LOGIN\", True)\nMANIFEST_TIME_ZONE = getattr(settings, \"TIME_ZONE\", \"Europe/Istanbul\")\nMANIFEST_USE_HTTPS = getattr(settings, \"MANIFEST_USE_HTTPS\", False)\nMANIFEST_USE_MESSAGES = getattr(settings, \"MANIFEST_USE_MESSAGES\", True)\nmanifest/mixins.py\nclass SendActivationMailMixin(SendMailMixin):\n    def send_activation_mail(self, user):\n        context = {\n            \"user\": user,\n            \"activation_days\": defaults.MANIFEST_ACTIVATION_DAYS,\n            \"activation_key\": user.activation_key,\n        }\n        self.send_mail(user.email, context)\nmanifest/signals.py\nREGISTRATION_COMPLETE = Signal(providing_args=[\"user\", \"request\"])\nACTIVATION_COMPLETE = Signal(providing_args=[\"user\"])\nCINFIRMATION_COMPLETE = Signal(providing_args=[\"user\"])\nPASSWORD_RESET_COMPLETE = Signal(providing_args=[\"user\"])\n", "answers": ["            url = get_login_redirect("], "length": 1277, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "fe7d2539537cd6edb5932502090d38c322e1fe8d75b0570c"}
{"input": "import static net.amigocraft.mglib.Main.locale;\nimport net.amigocraft.mglib.MGUtil;\nimport net.amigocraft.mglib.Main;\nimport net.amigocraft.mglib.UUIDFetcher;\nimport net.amigocraft.mglib.event.player.MGPlayerSpectateEvent;\nimport net.amigocraft.mglib.exception.NoSuchPlayerException;\nimport net.amigocraft.mglib.exception.PlayerOfflineException;\nimport net.amigocraft.mglib.exception.PlayerPresentException;\nimport net.amigocraft.mglib.exception.RoundFullException;\nimport net.amigocraft.mglib.misc.JoinResult;\nimport net.amigocraft.mglib.misc.Metadatable;\nimport net.amigocraft.mglib.util.NmsUtil;\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.Location;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.PlayerInventory;\nimport org.bukkit.potion.PotionEffect;\nimport org.bukkit.potion.PotionEffectType;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Random;\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2015 Maxim Roncacé\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage net.amigocraft.mglib.api;\n\n\n\n\n\n/**\n * Represents a player participating in a minigame.\n *\n * @since 0.1.0\n */\npublic class MGPlayer implements Metadatable {\n\n\tHashMap<String, Object> metadata = new HashMap<String, Object>();\n\n\tprivate String plugin;\n\tprivate String name;\n\tprivate String arena;\n\tprivate boolean spectating = false;\n\tprivate String prefix = \"\";\n\tprivate GameMode prevGameMode;\n\tprivate String team = null;\n\tprivate boolean frozen = false;\n\n\t/**\n\t * Creates a new MGPlayer instance.\n\t *\n\t * @param plugin the plugin to associate the MGPlayer with\n\t * @param name   the username of the player\n\t * @param arena  the arena of the player\n\t * @since 0.1.0\n\t */\n\tpublic MGPlayer(String plugin, String name, String arena) {\n\t\tthis.plugin = plugin;\n\t\tthis.name = name;\n\t\tthis.arena = arena;\n\t}\n\n\t/**\n\t * Gets the minigame plugin associated with this {@link MGPlayer}.\n\t *\n\t * @return the minigame plugin associated with this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic String getPlugin() {\n\t\treturn plugin;\n\t}\n\n\t/**\n\t * Gets the MGLib API instance registered by the minigame plugin associated\n\t * with this {@link MGPlayer}.\n\t *\n\t * @return the MGLib API instance registered by the minigame plugin\n\t * associated with this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic Minigame getMinigame() {\n\t\treturn Minigame.getMinigameInstance(plugin);\n\t}\n\n\t/**\n\t * Gets the username of this {@link MGPlayer}.\n\t *\n\t * @return the username of this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t/**\n\t * Gets the arena associated with this {@link MGPlayer}.\n\t *\n\t * @return the arena associated with this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic String getArena() {\n\t\treturn arena;\n\t}\n\n\t/**\n\t * Retrieves the prefix of this player (used on lobby signs).\n\t *\n\t * @return the prefix of this player\n\t * @since 0.1.0\n\t */\n\tpublic String getPrefix() {\n\t\treturn prefix;\n\t}\n\n\t/**\n\t * Retrieves the name of the team this player is on, or null if they are not\n\t * on a team.\n\t *\n\t * @return the name of the team this player is on, or null if they are not\n\t * on a team\n\t * @since 0.3.0\n\t */\n\tpublic String getTeam() {\n\t\treturn team;\n\t}\n\n\t/**\n\t * Sets the name of the team this player is on.\n\t *\n\t * @param team the name of the team this player is on. Set to null for no\n\t *             team.\n\t * @since 0.3.0\n\t */\n\tpublic void setTeam(String team) {\n\t\tthis.team = team;\n\t}\n\n\t/**\n\t * Sets the arena of this {@link MGPlayer}. Please do not call this method\n\t * unless you understand the implications of doing so.\n\t *\n\t * @param arena the new arena of this {@link MGPlayer}\n\t * @since 0.1.0\n\t */\n\tpublic void setArena(String arena) {\n\t\tthis.arena = arena;\n\t}\n\n\t/**\n\t * Gets the {@link Round} associated with this player.\n\t *\n\t * @return the {@link Round} associated with this player\n\t * @since 0.1.0\n\t */\n\tpublic Round getRound() {\n\t\treturn Minigame.getMinigameInstance(plugin).getRound(arena.toLowerCase());\n\t}\n\n\t/**\n\t * Gets whether this player is spectating their round, as opposed to\n\t * participating in it.\n\t *\n\t * @return whether this player is spectating their round (can return true\n\t * even if {@link Player#isDead()} returns false).\n\t * @since 0.1.0\n\t */\n\tpublic boolean isSpectating() {\n\t\treturn spectating;\n\t}\n\n\t/**\n\t * Sets whether this player is spectating or not.\n\t *\n\t * @param spectating whether the player is spectating\n\t * @since 0.1.0\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void setSpectating(boolean spectating) {\n\t\tthis.spectating = spectating;\n\t\tif (spectating) {\n\t\t\tMGPlayerSpectateEvent event = new MGPlayerSpectateEvent(this.getRound(), this);\n\t\t\tMGUtil.callEvent(event);\n\t\t\tif (event.isCancelled()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tfinal Player p = Bukkit.getPlayer(this.getName());\n\t\t\tif (p != null) { // check that player is online\n\t\t\t\tp.closeInventory(); // close any inventory they have open\n\t\t\t\tif (!Main.isVanillaSpectatingDisabled() &&\n\t\t\t\t\t\tthis.getRound().getConfigManager().isUsingVanillaSpectating() &&\n\t\t\t\t\t\tNmsUtil.SPECTATOR_SUPPORT) {\n\t\t\t\t\tp.setGameMode(org.bukkit.GameMode.SPECTATOR);\n\t\t\t\t\tp.sendMessage(ChatColor.DARK_PURPLE + Main.locale.getMessage(\"info.personal.spectating\")); // tell them\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tp.setGameMode(org.bukkit.GameMode.ADVENTURE); // disable block breaking\n\t\t\t\t\tString message = ChatColor.DARK_PURPLE + Main.locale.getMessage(\"info.personal.spectating\"); // tell them\n\t\t\t\t\tif (Bukkit.getAllowFlight() && getRound().getConfigManager().isSpectatorFlightAllowed()) {\n\t\t\t\t\t\tp.setAllowFlight(true); // enable flight\n\t\t\t\t\t}\n\t\t\t\t\tp.sendMessage(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tPlayer p = Bukkit.getPlayer(this.getName());\n\t\t\tif (p != null) { // check that player is online\n\t\t\t\tif (!Main.isVanillaSpectatingDisabled() &&\n\t\t\t\t\t\tthis.getRound().getConfigManager().isUsingVanillaSpectating()) {\n\t\t\t\t\tp.setGameMode(org.bukkit.GameMode.valueOf(this.getRound().getConfigManager().getDefaultGameMode().name()));\n\t\t\t\t}\n\t\t\t\t//noinspection ConstantConditions\n\t\t\t\tfor (Player pl : NmsUtil.getOnlinePlayers()) {\n\t\t\t\t\tpl.showPlayer(p);\n\t\t\t\t}\n\t\t\t\tif (getRound() != null) {\n\t\t\t\t\t// set them to the default gamemode for arenas\n\t\t\t\t\tp.setGameMode(org.bukkit.GameMode.valueOf(getRound().getConfigManager().getDefaultGameMode().name()));\n\t\t\t\t}\n\t\t\t\tp.setFlying(false); // disable flight\n\t\t\t}\n\t\t}\n\t\tMinigame.getMinigameInstance(plugin).getLobbyManager().update(this.getArena());\n\t}\n\n\t/**\n\t * Sets the prefix of this player (used on lobby signs).\n\t *\n\t * @param prefix the new prefix of this player\n\t * @since 0.1.0\n\t */\n\tpublic void setPrefix(String prefix) {\n\t\tthis.prefix = prefix;\n\t}\n\n\t/**\n\t * Adds this {@link MGPlayer} to the given {@link Round round}.\n\t *\n\t * @param round the name of the round to add the player to\n\t * @return the result of this player being added to the round\n\t * @throws PlayerOfflineException if the player is not online\n\t * @throws PlayerPresentException if the player is already in a round\n\t * @throws RoundFullException     if the round is full\n\t * @since 0.1.0\n\t */\n\tpublic JoinResult addToRound(String round)", "context": "src/main/java/net/amigocraft/mglib/UUIDFetcher.java\npublic class UUIDFetcher implements Callable<Map<String, UUID>> {\n\n\tstatic HashMap<String, UUID> uuids = new HashMap<String, UUID>();\n\n\tprivate static final double PROFILES_PER_REQUEST = 100;\n\tprivate static final String PROFILE_URL = \"https://api.mojang.com/profiles/minecraft\";\n\tprivate final JSONParser jsonParser = new JSONParser();\n\tprivate final List<String> names;\n\tprivate final boolean rateLimiting;\n\n\tpublic UUIDFetcher(List<String> names, boolean rateLimiting) {\n\t\tthis.names = ImmutableList.copyOf(names);\n\t\tthis.rateLimiting = rateLimiting;\n\t}\n\n\tpublic UUIDFetcher(List<String> names) {\n\t\tthis(names, true);\n\t}\n\n\tpublic Map<String, UUID> call() throws Exception {\n\t\tMap<String, UUID> uuidMap = new HashMap<String, UUID>();\n\t\tint requests = (int)Math.ceil(names.size() / PROFILES_PER_REQUEST);\n\t\tfor (int i = 0; i < requests; i++) {\n\t\t\tHttpURLConnection connection = createConnection();\n\t\t\tString body = JSONArray.toJSONString(names.subList(i * 100, Math.min((i + 1) * 100, names.size())));\n\t\t\twriteBody(connection, body);\n\t\t\tJSONArray array = (JSONArray)jsonParser.parse(new InputStreamReader(connection.getInputStream()));\n\t\t\tfor (Object profile : array) {\n\t\t\t\tJSONObject jsonProfile = (JSONObject)profile;\n\t\t\t\tString id = (String)jsonProfile.get(\"id\");\n\t\t\t\tString name = (String)jsonProfile.get(\"name\");\n\t\t\t\tUUID uuid = UUIDFetcher.getUUID(id);\n\t\t\t\tuuidMap.put(name, uuid);\n\t\t\t}\n\t\t\tif (rateLimiting && i != requests - 1) {\n\t\t\t\tThread.sleep(100L);\n\t\t\t}\n\t\t}\n\t\tuuids.putAll(uuidMap);\n\t\treturn uuidMap;\n\t}\n\n\tprivate static void writeBody(HttpURLConnection connection, String body) throws Exception {\n\t\tOutputStream stream = connection.getOutputStream();\n\t\tstream.write(body.getBytes());\n\t\tstream.flush();\n\t\tstream.close();\n\t}\n\n\tprivate static HttpURLConnection createConnection() throws Exception {\n\t\tURL url = new URL(PROFILE_URL);\n\t\tHttpURLConnection connection = (HttpURLConnection)url.openConnection();\n\t\tconnection.setRequestMethod(\"POST\");\n\t\tconnection.setRequestProperty(\"Content-Type\", \"application/json\");\n\t\tconnection.setUseCaches(false);\n\t\tconnection.setDoInput(true);\n\t\tconnection.setDoOutput(true);\n\t\treturn connection;\n\t}\n\n\tprivate static UUID getUUID(String id) {\n\t\treturn UUID.fromString(id.substring(0, 8) + \"-\" + id.substring(8, 12) + \"-\" + id.substring(12, 16) + \"-\" +\n\t\t\t\tid.substring(16, 20) + \"-\" + id.substring(20, 32));\n\t}\n\n\tpublic static byte[] toBytes(UUID uuid) {\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(new byte[16]);\n\t\tbyteBuffer.putLong(uuid.getMostSignificantBits());\n\t\tbyteBuffer.putLong(uuid.getLeastSignificantBits());\n\t\treturn byteBuffer.array();\n\t}\n\n\tpublic static UUID fromBytes(byte[] array) {\n\t\tif (array.length != 16) {\n\t\t\tthrow new IllegalArgumentException(\"Illegal byte array length: \" + array.length);\n\t\t}\n\t\tByteBuffer byteBuffer = ByteBuffer.wrap(array);\n\t\tlong mostSignificant = byteBuffer.getLong();\n\t\tlong leastSignificant = byteBuffer.getLong();\n\t\treturn new UUID(mostSignificant, leastSignificant);\n\t}\n\n\tpublic static UUID getUUIDOf(String name) throws Exception {\n\t\tif (uuids.containsKey(name)) {\n\t\t\treturn uuids.get(name);\n\t\t}\n\t\tUUID uuid = new UUIDFetcher(Arrays.asList(name)).call().get(name);\n\t\tUUIDFetcher.addUUID(name, uuid);\n\t\treturn uuid;\n\t}\n\n\tpublic static void addUUID(String name, UUID uuid) {\n\t\tuuids.put(name, uuid);\n\t}\n\n\tpublic static void removeUUID(String name) {\n\t\tuuids.remove(name);\n\t}\n\n\tpublic static void uninitialize() {\n\t\tMGUtil.verifyDisablingStatus();\n\t\tuuids.clear();\n\t\tuuids = null;\n\t}\n}\nsrc/main/java/net/amigocraft/mglib/misc/Metadatable.java\npublic interface Metadatable {\n\n\t/**\n\t * Retrieves a given value from this object's metadata by its key.\n\t *\n\t * @param key the key to retrieve.\n\t * @return the key's mapped value, or null if it is not mapped.\n\t * @since 0.3.0\n\t */\n\tpublic Object getMetadata(String key);\n\n\t/**\n\t * Adds a key-value pair to this object's metadata.\n\t *\n\t * <p><strong>Note:</strong> This method consists of a single call to\n\t * {@link HashMap#put(Object, Object)}, so existing keys will be overwritten.</p>\n\t *\n\t * @param key   the key to store in the round's metadata.\n\t * @param value the value to assign to the given key.\n\t * @since 0.3.0\n\t */\n\tpublic void setMetadata(String key, Object value);\n\n\t/**\n\t * Removes the given key from this object's metadata.\n\t *\n\t * @param key the key to remove from this object's metadata.\n\t * @since 0.3.0\n\t */\n\tpublic void removeMetadata(String key);\n\n\t/**\n\t * Checks whether a given key is present in this object's metadata.\n\t *\n\t * @param key the key to test for.\n\t * @return whether the key is present in this object's metadata.\n\t * @since 0.3.0\n\t */\n\tpublic boolean hasMetadata(String key);\n\n\t/**\n\t * Retrieves a {@link HashMap} representing this object's complete metadata.\n\t *\n\t * @return this object's metadata in the form of a {@link HashMap}.\n\t * @since 0.3.0\n\t */\n\tpublic HashMap<String, Object> getAllMetadata();\n\n}\nsrc/main/java/net/amigocraft/mglib/MGUtil.java\npublic class MGUtil {\n\n\tstatic Main plugin;\n\n\t/**\n\t * Returns the {@link JavaPlugin} instance for MGLib.\n\t *\n\t * <p><strong>This should not be called</strong> from a hooking plugin under\n\t * any circumstance.</p>\n\t *\n\t * @return the {@link JavaPlugin} instance for MGLib.\n\t * @since 0.4.0\n\t */\n\tpublic static Main getPlugin() {\n\t\treturn plugin;\n\t}\n\n\t/**\n\t * Loads and returns the given plugin's arenas.yml file.\n\t *\n\t * @param plugin The plugin to load the YAML file from.\n\t * @return The loaded {@link YamlConfiguration} object.\n\t * @since 0.1.0\n\t */\n\tpublic static MGYamlConfiguration loadArenaYaml(String plugin) {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tJavaPlugin jp = Minigame.getMinigameInstance(plugin).getPlugin();\n\t\tFile f = new File(jp.getDataFolder(), \"arenas.yml\");\n\t\ttry {\n\t\t\tif (!jp.getDataFolder().exists()) {\n\t\t\t\tjp.getDataFolder().mkdirs();\n\t\t\t}\n\t\t\tif (!f.exists()) {\n\t\t\t\tf.createNewFile();\n\t\t\t}\n\t\t\tMGYamlConfiguration y = new MGYamlConfiguration();\n\t\t\ty.load(f);\n\t\t\treturn y;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log.severe(\"An exception occurred while loading arena data for plugin \" + plugin);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Saves the given plugin's arenas.yml file.\n\t *\n\t * @param plugin the plugin to save the given {@link YamlConfiguration} to\n\t * @param y      the {@link YamlConfiguration} to save\n\t */\n\tpublic static void saveArenaYaml(String plugin, YamlConfiguration y) {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tJavaPlugin jp = Minigame.getMinigameInstance(plugin).getPlugin();\n\t\tFile f = new File(jp.getDataFolder(), \"arenas.yml\");\n\t\ttry {\n\t\t\tif (!f.exists()) {\n\t\t\t\tf.createNewFile();\n\t\t\t}\n\t\t\ty.save(f);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log.severe(\"An exception occurred while saving arena data for plugin \" + plugin);\n\t\t}\n\t}\n\n\t/**\n\t * Determines whether the provided string can be parsed to an integer.\n\t *\n\t * @param s the string to check\n\t * @return whether the provided string can be parsed to an integer\n\t */\n\tpublic static boolean isInteger(String s) {\n\t\ttry {\n\t\t\tInteger.parseInt(s);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (NumberFormatException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Logs the given message if verbose logging is enabled.\n\t *\n\t * @param message the message to log\n\t * @param prefix  the prefix to place in front of the message. This will\n\t *                automatically be placed within brackets\n\t * @param level   the {@link LogLevel level} at which to log the message\n\t * @since 0.3.0\n\t */\n\tpublic static void log(String message, String prefix, LogLevel level) {\n\t\tif (Main.LOGGING_LEVEL.compareTo(level) >= 0) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"[\").append(level.toString()).append(\"]\");\n\t\t\tif (prefix != null) {\n\t\t\t\tsb.append(\"[\").append(prefix).append(\"]\");\n\t\t\t}\n\t\t\tsb.append(\" \").append(message);\n\t\t\tif (level == LogLevel.SEVERE) {\n\t\t\t\tSystem.err.println(sb.toString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(sb.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Calls an event, but sends it only to the appropriate plugin.\n\t * <strong>Please do not call this from your pluginv unless you are aware of\n\t * the implications.</strong>\n\t *\n\t * @param event the event to call\n\t * @since 0.3.0\n\t */\n\tpublic static void callEvent(MGLibEvent event) {\n\t\tHandlerList hl = event.getHandlers();\n\t\tfor (RegisteredListener rl : hl.getRegisteredListeners()) {\n\t\t\tif (rl.getPlugin().getName().equals(event.getPlugin()) || rl.getPlugin().getName().equals(\"MGLib\")) {\n\t\t\t\ttry {\n\t\t\t\t\trl.callEvent(event);\n\t\t\t\t}\n\t\t\t\tcatch (EventException ex) {\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves the sign attached to a given block, or null if ones does not\n\t * exist.\n\t *\n\t * @param block the block to check for an attached sign\n\t * @return the sign attached to a given block, or null if ones does not\n\t * exist\n\t */\n\tpublic static Block getAttachedSign(Block block) {\n\t\tBlockFace[] faces = new BlockFace[]{\n\t\t\t\tBlockFace.NORTH, BlockFace.SOUTH, BlockFace.EAST, BlockFace.WEST, BlockFace.UP\n\t\t};\n\t\tfor (BlockFace face : faces) {\n\t\t\tBlock adjBlock = block.getRelative(face);\n\t\t\tif (adjBlock.getState() instanceof Sign) {\n\t\t\t\tif (face != BlockFace.UP) {\n\t\t\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\t\t\tbyte data = adjBlock.getData();\n\t\t\t\t\tbyte north = 0x2;\n\t\t\t\t\tbyte south = 0x3;\n\t\t\t\t\tbyte west = 0x4;\n\t\t\t\t\tbyte east = 0x5;\n\t\t\t\t\tBlockFace attached = null;\n\t\t\t\t\tif (data == east) {\n\t\t\t\t\t\tattached = BlockFace.WEST;\n\t\t\t\t\t}\n\t\t\t\t\telse if (data == west) {\n\t\t\t\t\t\tattached = BlockFace.EAST;\n\t\t\t\t\t}\n\t\t\t\t\telse if (data == north) {\n\t\t\t\t\t\tattached = BlockFace.SOUTH;\n\t\t\t\t\t}\n\t\t\t\t\telse if (data == south) {\n\t\t\t\t\t\tattached = BlockFace.NORTH;\n\t\t\t\t\t}\n\t\t\t\t\tif (adjBlock.getType() == Material.SIGN_POST) {\n\t\t\t\t\t\tattached = BlockFace.DOWN;\n\t\t\t\t\t}\n\t\t\t\t\tif (block.getX() == adjBlock.getRelative(attached).getX() &&\n\t\t\t\t\t\t\tblock.getY() == adjBlock.getRelative(attached).getY() &&\n\t\t\t\t\t\t\tblock.getZ() == adjBlock.getRelative(attached).getZ()) {\n\t\t\t\t\t\treturn adjBlock;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determines the environment of the given world based on its folder\n\t * structure.\n\t *\n\t * @param world the name of the world to determine the environment of\n\t * @return the environment of the given world\n\t * @since 0.3.0\n\t */\n\tpublic static Environment getEnvironment(String world) {\n\t\tFile worldFolder = new File(Bukkit.getWorldContainer(), world);\n\t\tif (worldFolder.exists()) {\n\t\t\tfor (File f : worldFolder.listFiles()) {\n\t\t\t\tif (f.getName().equals(\"region\")) {\n\t\t\t\t\treturn Environment.NORMAL;\n\t\t\t\t}\n\t\t\t\telse if (f.getName().equals(\"DIM1\")) {\n\t\t\t\t\treturn Environment.THE_END;\n\t\t\t\t}\n\t\t\t\telse if (f.getName().equals(\"DIM-1\")) {\n\t\t\t\t\treturn Environment.NETHER;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Deletes a folder recursively.\n\t *\n\t * @param folder the folder to delete\n\t * @since 0.3.0\n\t */\n\tpublic static void deleteFolder(File folder) {\n\t\tfor (File f : folder.listFiles()) {\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tdeleteFolder(f);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf.delete();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Throws an {@link UnsupportedOperationException} if MGLib is not\n\t * disabling.\n\t *\n\t * @throws UnsupportedOperationException if MGLib is not currently\n\t *                                       disabling\n\t * @since 0.4.0\n\t */\n\tpublic static void verifyDisablingStatus() throws UnsupportedOperationException {\n\t\tif (!Main.isDisabling()) {\n\t\t\tthrow new UnsupportedOperationException(Main.locale.getMessage(\"plugin.alert.not-disabling\"));\n\t\t}\n\t}\n\n\t/**\n\t * Converts a Bukkit {@link Location} to a {@link Location3D}.\n\t *\n\t * @param location the {@link Location} to convert\n\t * @return the new {@link Location3D}\n\t * @since 0.4.0\n\t */\n\tpublic static Location3D fromBukkitLocation(Location location) {\n\t\treturn fromBukkitLocation(location, false);\n\t}\n\n\t/**\n\t * Converts a Bukkit {@link Location} to a {@link Location3D}.\n\t *\n\t * @param location the {@link Location} to convert\n\t * @param copyOrientation whether the pitch and yaw of <code>location</code>\n\t *                        will be stored in the new {@link Location3D}\n\t *                        (defaults to <code>false</code> if omitted).\n\t * @return the new {@link Location3D}\n\t * @since 0.4.0\n\t */\n\tpublic static Location3D fromBukkitLocation(Location location, boolean copyOrientation) {\n\t\tif (copyOrientation) {\n\t\t\treturn new Location3D(location.getWorld().getName(),\n\t\t\t\t\t(float)location.getX(), (float)location.getY(), (float)location.getZ(),\n\t\t\t\t\tlocation.getPitch(), location.getYaw());\n\t\t}\n\t\telse {\n\t\t\treturn new Location3D(location.getWorld().getName(),\n\t\t\t\t\t(float)location.getX(), (float)location.getY(), (float)location.getZ());\n\t\t}\n\t}\n\n\t/**\n\t * Converts a {@link Location3D} to a Bukkit {@link org.bukkit.Location}.\n\t *\n\t * @param location the {@link Location3D} to convert\n\t *                        (defaults to <code>false</code> if omitted).\n\t * @return the new {@link org.bukkit.Location}\n\t * @since 0.4.0\n\t */\n\tpublic static Location toBukkitLocation(Location3D location) {\n\t\t\treturn new Location(Bukkit.getWorld(location.getWorld()),\n\t\t\t\t\tlocation.getX(), location.getY(), location.getZ(),\n\t\t\t\t\tlocation.getPitch(), location.getYaw());\n\t}\n}\nsrc/main/java/net/amigocraft/mglib/exception/RoundFullException.java\npublic class RoundFullException extends Exception {\n\n\tprivate static final long serialVersionUID = -4824489285215148872L;\n\n}\nsrc/main/java/net/amigocraft/mglib/exception/PlayerOfflineException.java\npublic class PlayerOfflineException extends Exception {\n\n\tprivate static final long serialVersionUID = 1477050494550899458L;\n\n}\nsrc/main/java/net/amigocraft/mglib/misc/JoinResult.java\npublic enum JoinResult {\n\n\tSUCCESS,\n\tROUND_FULL, // not used, RoundFullException thrown instead\n\tROUND_PREPARING,\n\tROUND_PLAYING,\n\tINVENTORY_SAVE_ERROR,\n\tCANCELLED,\n\tINTERNAL_ERROR\n\n}\nsrc/main/java/net/amigocraft/mglib/Main.java\npublic class Main extends JavaPlugin {\n\n\t/**\n\t * MGLib's logger.\n\t *\n\t * <p><strong>This is for use within the library; please do not use this in\n\t * your plugin or you'll confuse the server owner.</strong></p>\n\t *\n\t * @since 0.1.0\n\t */\n\tpublic static Logger log;\n\n\t/**\n\t * Whether block changes should be logged immediately.\n\t */\n\tpublic static boolean IMMEDIATE_LOGGING;\n\n\t/**\n\t * The minimum level at which messages should be logged.\n\t */\n\tpublic static LogLevel LOGGING_LEVEL;\n\n\t/**\n\t * Whether vanilla spectating is globally disabled.\n\t */\n\tprivate static boolean VANILLA_SPECTATING_DISABLED;\n\n\t/**\n\t * The locale for MGLib itself.\n\t */\n\tpublic static Locale locale;\n\n\tprivate static boolean disabling = false;\n\n\t/**\n\t * Standard {@link JavaPlugin#onEnable()} override.\n\t *\n\t * @since 0.1.0\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void onEnable() {\n\n\t\tMGUtil.plugin = this;\n\t\tlog = getLogger();\n\t\tBukkit.getPluginManager().registerEvents(new MGListener(), this);\n\t\tsaveDefaultConfig();\n\t\tIMMEDIATE_LOGGING = getConfig().getBoolean(\"immediate-logging\");\n\t\tLOGGING_LEVEL = LogLevel.valueOf(getConfig().getString(\"logging-level\").toUpperCase());\n\t\tif (LOGGING_LEVEL == null) {\n\t\t\tLOGGING_LEVEL = LogLevel.WARNING;\n\t\t\tMain.log(\"The configured logging level is invalid!\", LogLevel.WARNING);\n\t\t}\n\t\tVANILLA_SPECTATING_DISABLED = getConfig().getBoolean(\"disable-vanilla-spectating\");\n\n\t\tlocale = new Locale(\"MGLib\");\n\t\tlocale.initialize();\n\n\t\t// updater\n\t\tif (getConfig().getBoolean(\"enable-updater\")) {\n\t\t\tnew Updater(this, 74979, this.getFile(), Updater.UpdateType.DEFAULT, true);\n\t\t}\n\n\t\t// submit metrics\n\t\tif (getConfig().getBoolean(\"enable-metrics\")) {\n\t\t\ttry {\n\t\t\t\tMetrics metrics = new Metrics(this);\n\t\t\t\tmetrics.start();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tlog.warning(locale.getMessage(\"plugin.alert.metrics-fail\"));\n\t\t\t}\n\t\t}\n\t\tif (this.getDescription().getVersion().contains(\"dev\")) {\n\t\t\tlog.warning(locale.getMessage(\"plugin.alert.dev-build\"));\n\t\t}\n\n\t\t// store UUIDs of online players\n\t\tList<String> names = new ArrayList<String>();\n\t\tfor (Player pl : NmsUtil.getOnlinePlayers()) {\n\t\t\tnames.add(pl.getName());\n\t\t}\n\t\ttry {\n\t\t\tnew UUIDFetcher(names).call();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log.severe(locale.getMessage(\"plugin.alert.uuid-fail\"));\n\t\t}\n\n\t\tlog.info(locale.getMessage(\"plugin.event.enable\", this.toString()));\n\t}\n\n\t/**\n\t * Standard {@link JavaPlugin#onDisable()} override.\n\t *\n\t * @since 0.1.0\n\t */\n\t@Override\n\tpublic void onDisable() {\n\t\tdisabling = true;\n\t\tBukkit.broadcastMessage(ChatColor.DARK_PURPLE + \"[MGLib] \" + locale.getMessage(\"plugin.event.restart\"));\n\t\tfor (Minigame mg : Minigame.getMinigameInstances()) {\n\t\t\tfor (Round r : mg.getRoundList()) {\n\t\t\t\tr.end(false);\n\t\t\t}\n\t\t}\n\t\tMinigame.uninitialize();\n\t\tMGLibEvent.uninitialize();\n\t\tNmsUtil.uninitialize();\n\t\tUUIDFetcher.uninitialize();\n\t\tlog.info(locale.getMessage(\"plugin.event.disable\", this.toString()));\n\t\tMain.uninitialize();\n\t}\n\n\t/**\n\t * <p>This method should not be called from your plugin. So don't use it.\n\t * Please.</p>\n\t *\n\t * @param plugin the name of the plugin to register worlds for\n\t */\n\tpublic static void registerWorlds(String plugin) {\n\t\tMGListener.addWorlds(plugin);\n\t}\n\n\tprivate static void uninitialize() {\n\t\tlog = null;\n\t\tMGUtil.plugin = null;\n\t}\n\n\t/**\n\t * Internal convenience method for logging. <strong>Please do not call this\n\t * from your plugin.</strong>\n\t *\n\t * @param message the message to log.\n\t * @param level   the {@link LogLevel level} at which to log the message\n\t * @since 0.3.0\n\t */\n\tpublic static void log(String message, LogLevel level) {\n\t\tMGUtil.log(message, \"MGLib\", level);\n\t}\n\n\t@Override\n\tpublic boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n\t\tif (label.equalsIgnoreCase(\"mglib\")) {\n\t\t\tsender.sendMessage(ChatColor.LIGHT_PURPLE +\n\t\t\t\t\tlocale.getMessage(\"plugin.event.info\", getDescription().getVersion(), \"Maxim Roncacé\"));\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Retrieves worlds registered with MGLib's event listener for the given\n\t * plugin.\n\t *\n\t * @param plugin the plugin to retrieve worlds for\n\t * @return worlds registered with MGLib's event listener for the given\n\t * plugin\n\t * @since 0.4.0\n\t */\n\tpublic static List<String> getWorlds(String plugin) {\n\t\treturn MGListener.getWorlds();\n\t}\n\n\t/**\n\t * Retrieves a hashmap mapping the names of online players to their\n\t * respective UUIDs.\n\t *\n\t * @return a hashmap mapping the names of online players to their\n\t * respective UUIDs\n\t * @since 0.3.0\n\t */\n\tpublic static HashMap<String, UUID> getOnlineUUIDs() {\n\t\treturn UUIDFetcher.uuids;\n\t}\n\n\t/**\n\t * Retrieves whether vanilla spectating has been globally disabled by\n\t * MGLib's config.yml file.\n\t *\n\t * @return whether vanilla spectating has been globally disabled by MGLib's\n\t * config.yml file\n\t * @since 0.3.0\n\t */\n\tpublic static boolean isVanillaSpectatingDisabled() {\n\t\treturn VANILLA_SPECTATING_DISABLED;\n\t}\n\n\t/**\n\t * Determines whether MGLib is in the process of disabling.\n\t * This is to provide security when unsetting static objects.\n\t *\n\t * @return whether MGLib is in the process of disabling.\n\t * @since 0.4.0\n\t */\n\tpublic static boolean isDisabling() {\n\t\treturn disabling;\n\t}\n\n}\nsrc/main/java/net/amigocraft/mglib/exception/PlayerPresentException.java\npublic class PlayerPresentException extends Exception {\n\n\tprivate static final long serialVersionUID = -5109025861934945989L;\n\n}\nsrc/main/java/net/amigocraft/mglib/event/player/MGPlayerSpectateEvent.java\npublic class MGPlayerSpectateEvent extends MGPlayerEvent implements Cancellable {\n\n\tprotected Round round;\n\tprivate boolean cancelled;\n\n\t/**\n\t * Creates a new instance of this event.\n\t *\n\t * @param round  the round the player has joined\n\t * @param player the player involved in this event\n\t * @since 0.2.0\n\t */\n\tpublic MGPlayerSpectateEvent(Round round, MGPlayer player) {\n\t\tsuper(player);\n\t\tthis.round = round;\n\t}\n\n\t/**\n\t * Returns the {@link Round round} involved in this event.\n\t *\n\t * @return the {@link Round round} involved in this event\n\t * @since 0.2.0\n\t */\n\tpublic Round getRound() {\n\t\treturn round;\n\t}\n\n\t@Override\n\tpublic boolean isCancelled() {\n\t\treturn this.cancelled;\n\t}\n\n\t@Override\n\tpublic void setCancelled(boolean cancel) {\n\t\tthis.cancelled = cancel;\n\t}\n\n}\nsrc/main/java/net/amigocraft/mglib/exception/NoSuchPlayerException.java\npublic class NoSuchPlayerException extends Exception {\n\n\tprivate static final long serialVersionUID = 2117053927855770796L;\n\n}\nsrc/main/java/net/amigocraft/mglib/util/NmsUtil.java\npublic class NmsUtil {\n\n\tprivate static final String VERSION_STRING;\n\tprivate static final boolean NMS_SUPPORT;\n\tpublic static final boolean SPECTATOR_SUPPORT;\n\n\t// general classes for sending packets\n\tpublic static Method craftPlayer_getHandle;\n\tpublic static Field playerConnection;\n\tpublic static Method playerConnection_sendPacket;\n\tpublic static Method playerConnection_a_packetPlayInClientCommand;\n\n\t// for respawning players automatically\n\tpublic static Object clientCommandPacketInstance;\n\n\tprivate static Method getOnlinePlayers;\n\tpublic static boolean newOnlinePlayersMethod = false;\n\n\tstatic {\n\t\tboolean ss;\n\t\ttry {\n\t\t\tGameMode.valueOf(\"SPECTATOR\");\n\t\t\tss = true;\n\t\t} catch (IllegalArgumentException ex) {\n\t\t\tss = false;\n\t\t}\n\t\tSPECTATOR_SUPPORT = ss;\n\t\tboolean nmsException = false;\n\t\tString[] array = Bukkit.getServer().getClass().getPackage().getName().split(\"\\\\.\");\n\t\tVERSION_STRING = array.length == 4 ? array[3] + \".\" : \"\";\n\t\ttry {\n\t\t\tgetOnlinePlayers = Bukkit.class.getMethod(\"getOnlinePlayers\");\n\t\t\tif (getOnlinePlayers.getReturnType() == Collection.class) {\n\t\t\t\tnewOnlinePlayersMethod = true;\n\t\t\t}\n\n\t\t\t// get method for recieving CraftPlayer's EntityPlayer\n\t\t\tcraftPlayer_getHandle = getCraftClass(\"entity.CraftPlayer\").getMethod(\"getHandle\");\n\t\t\t// get the PlayerConnection of the EntityPlayer\n\t\t\tplayerConnection = getNmsClass(\"EntityPlayer\").getDeclaredField(\"playerConnection\");\n\t\t\t// method to send the packet\n\t\t\tplayerConnection_sendPacket = getNmsClass(\"PlayerConnection\").getMethod(\"sendPacket\", getNmsClass(\"Packet\"));\n\t\t\tplayerConnection_a_packetPlayInClientCommand = getNmsClass(\"PlayerConnection\")\n\t\t\t\t\t.getMethod(\"a\", getNmsClass(\"PacketPlayInClientCommand\"));\n\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tClass<? extends Enum> enumClass;\n\t\t\t\t\tObject performRespawn;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// this changed at some point in 1.8 to an inner class; I don't really care to figure out exactly when\n\t\t\t\t\t\tenumClass = (Class<? extends Enum>)getNmsClass(\"PacketPlayInClientCommand$EnumClientCommand\");\n\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\t// older 1.8 builds/1.7\n\t\t\t\t\t\tenumClass = (Class<? extends Enum>)getNmsClass(\"EnumClientCommand\");\n\t\t\t\t\t}\n\t\t\t\t\tperformRespawn = Enum.valueOf(\n\t\t\t\t\t\t\tenumClass, \"PERFORM_RESPAWN\"\n\t\t\t\t\t);\n\t\t\t\t\tclientCommandPacketInstance = getNmsClass(\"PacketPlayInClientCommand\")\n\t\t\t\t\t\t\t.getConstructor(performRespawn.getClass())\n\t\t\t\t\t\t\t.newInstance(performRespawn);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\tclientCommandPacketInstance = getNmsClass(\"Packet205ClientCommand\").getConstructor().newInstance();\n\t\t\t\t\tclientCommandPacketInstance.getClass().getDeclaredField(\"a\").set(clientCommandPacketInstance, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t\tMain.log(Main.locale.getMessage(\"plugin.alert.nms.client-command\"), LogLevel.WARNING);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log(Main.locale.getMessage(\"plugin.alert.nms.fail\"), LogLevel.WARNING);\n\t\t\tnmsException = true;\n\t\t}\n\n\t\tNMS_SUPPORT = !nmsException;\n\t}\n\n\t/**\n\t * Retrieves a class by the given name from the package\n\t * <code>net.minecraft.server</code>.\n\t *\n\t * @param name the class to retrieve\n\t * @return the class object from the package\n\t * <code>net.minecraft.server</code>\n\t * @throws ClassNotFoundException if the class does not exist in the\n\t * package\n\t */\n\tpublic static Class<?> getNmsClass(String name) throws ClassNotFoundException {\n\t\tString className = \"net.minecraft.server.\" + VERSION_STRING + name;\n\t\treturn Class.forName(className);\n\t}\n\n\t/**\n\t * Retrieves a class by the given name from the package\n\t * <code>org.bukkit.craftbukkit</code>.\n\t *\n\t * @param name the class to retrieve\n\t * @return the class object from the package\n\t * <code>org.bukkit.craftbukkit</code>\n\t * @throws ClassNotFoundException if the class does not exist in the\n\t * package\n\t */\n\tpublic static Class<?> getCraftClass(String name) throws ClassNotFoundException {\n\t\tString className = \"org.bukkit.craftbukkit.\" + VERSION_STRING + name;\n\t\treturn Class.forName(className);\n\t}\n\n\t/**\n\t * Sends a PlayInClientCommand packet to the given player.\n\t *\n\t * @param player the {@link Player} to send the packet to\n\t * @throws Exception if an exception occurs while sending the packet\n\t */\n\tpublic static void sendRespawnPacket(Player player) throws Exception {\n\t\tif (NMS_SUPPORT) {\n\t\t\tObject nmsPlayer = NmsUtil.craftPlayer_getHandle.invoke(player);\n\t\t\tObject conn = NmsUtil.playerConnection.get(nmsPlayer);\n\t\t\tNmsUtil.playerConnection_a_packetPlayInClientCommand.invoke(conn, NmsUtil.clientCommandPacketInstance);\n\t\t}\n\t}\n\n\t/**\n\t * Version-independent getOnlinePlayers() method.\n\t *\n\t * @return a list of online players\n\t * @since 0.4.0\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static Collection<? extends Player> getOnlinePlayers() {\n\t\ttry {\n\t\t\tif (newOnlinePlayersMethod) {\n\t\t\t\treturn (Collection<? extends Player>)getOnlinePlayers.invoke(null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Arrays.asList((Player[])getOnlinePlayers.invoke(null));\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log(Main.locale.getMessage(\"plugin.alert.nms.online-players\"), LogLevel.SEVERE);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tex.printStackTrace();\n\t\t\tMain.log(Main.locale.getMessage(\"plugin.alert.nms.online-players\"), LogLevel.SEVERE);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Unsets all static objects in this class.\n\t *\n\t * @throws UnsupportedOperationException if MGLib is not currently disabling\n\t *\n\t * @since 0.4.0\n\t */\n\tpublic static void uninitialize() {\n\t\tMGUtil.verifyDisablingStatus();\n\t\tcraftPlayer_getHandle = null;\n\t\tplayerConnection = null;\n\t\tplayerConnection_sendPacket = null;\n\t}\n}\nsrc/main/java/net/amigocraft/mglib/Main.java\npublic static Locale locale;\n", "answers": ["\t\t\tthrows PlayerOfflineException, PlayerPresentException, RoundFullException {"], "length": 3914, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "57fe3a1a96903bf9ba1d1fb027d6f8cce220608050122d4b"}
{"input": "package org.summer.dp.cms.service;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport javax.annotation.Resource;\r\nimport org.springframework.data.jpa.domain.Specification;\r\nimport org.springframework.stereotype.Service;\r\nimport org.summer.dp.cms.entity.base.Account;\r\nimport org.summer.dp.cms.entity.base.Department;\r\nimport org.summer.dp.cms.entity.base.Employee;\r\nimport org.summer.dp.cms.entity.base.EmployeePosts;\r\nimport org.summer.dp.cms.entity.base.Function;\r\nimport org.summer.dp.cms.entity.base.Post;\r\nimport org.summer.dp.cms.entity.base.PostFunction;\r\nimport org.summer.dp.cms.repository.AccountRepository;\r\nimport org.summer.dp.cms.repository.DepartmentRepository;\r\nimport org.summer.dp.cms.repository.EmployeeRepository;\r\nimport org.summer.dp.cms.repository.FunctionRepository;\r\nimport org.summer.dp.cms.support.persistence.DynamicSpecifications;\r\nimport org.summer.dp.cms.support.persistence.SearchFilter;\r\nimport org.summer.dp.cms.vo.CurrentInfo;\r\nimport org.summer.dp.cms.vo.Menu;\r\nimport org.summer.dp.cms.vo.Permission;\r\n\r\n\r\n\r\n\r\n/**\r\n * 当前登录用户信息\r\n * 部门  岗位 公司  访问页面权限 岗位权限  \r\n * @author 赵宝东\r\n *\r\n */\r\n@Service\r\npublic class CurrentUserInfoService {\r\n\t@Resource\r\n\tAccountRepository accountRepository ;\r\n\t@Resource\r\n\tEmployeeRepository employeeRepository ;\r\n\t@Resource\r\n\tDepartmentRepository departmentRepository ;\r\n\t@Resource\r\n\tFunctionRepository functionRepository;\r\n\r\n\t/**\r\n\t * \r\n\t * @param userId \r\n\t * @return 页面使用的VO\r\n\t */\r\n\t@SuppressWarnings(\"null\")\r\n\tpublic CurrentInfo findCurrentUserInfo(Account account){\r\n\r", "context": "src/main/java/org/summer/dp/cms/support/persistence/SearchFilter.java\npublic class SearchFilter {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(SearchFilter.class);\n\n\t// private static final SimpleDateFormat dateFormat = new\n\t// SimpleDateFormat(\"yyyy-MM-dd\");\n\n\tprivate static final SimpleDateFormat dateTimeFormat = new SimpleDateFormat(\n\t\t\t\"yyyy-MM-dd HH:mm:ss\");\n\n\tstatic {\n\t\t// 使ConvertUtils支持java.util.Date的转换\n\t\tConvertUtils.register(new DateLocaleConverter(), Date.class);\n\t}\n\n\tpublic enum Operator {\n\t\tEQ, LIKE, GT, LT, GTE, LTE, OREQ, ORLIKE, ANDLIKE , NOTEQ, ANDNOTEQ, NOTLIKE, ANDNOTLIKE,\n\t\tNULL, NOTNULL, IN, QUERY\n\t\t//OREQ, ORLIKE, ANDLIKE 后面必须带的是String\n\t}\n\n\t/** 属性数据类型. */\n\tpublic enum PropertyType {\n\t\tS(String.class), I(Integer.class), L(Long.class), N(Double.class), D(Date.class), B(Boolean.class), E(Enum.class), M(BigDecimal.class);\n\n\t\tprivate Class<?> clazz;\n\n\t\tprivate PropertyType(Class<?> clazz) {\n\t\t\tthis.clazz = clazz;\n\t\t}\n\n\t\tpublic Class<?> getValue() {\n\t\t\treturn clazz;\n\t\t}\n\t}\n\n\tpublic String fieldName;\n\tpublic Object value;\n\tpublic Operator operator;\n\n\tpublic SearchFilter(String fieldName, Operator operator, Object value) {\n\t\tthis.fieldName = fieldName;\n\t\tthis.value = value;\n\t\tthis.operator = operator;\n\t}\n\n\t/**\n\t * searchParams中key的格式为LIKES_name\n\t */\n\tpublic static Map<String, SearchFilter> parse(Map<String, Object> searchParams) {\n\t\tMap<String, SearchFilter> filters = Maps.newHashMap();\n\t\tString filedName;\n\t\tOperator operator;\n\t\tfor (Entry<String, Object> entry : searchParams.entrySet()) {\n\t\t\t// 过滤掉空值\n\t\t\tString key = entry.getKey();\n\n\t\t\tObject value = entry.getValue();\n\t\t\tif (key == null || value == null || StringUtils.isBlank(value.toString())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// http:\\\\192.168.1.1:8080\\bigdata\\tt.do?db_sum_alias=carCount,busCount&db_query=a=\n\t\t\t// 拆分operator与filedAttribute\n\t\t\tString[] names = StringUtils.split(key, \"_\");\n\t\t\tif (names.length != 2 && names.length != 3) {\n\t\t\t\t// throw new IllegalArgumentException(key + \" is not a valid search filter name\");\n\t\t\t\tlogger.warn(key + \" is not a valid search filter name\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClass<?> propertyClass = null;\n\t\t\tif (names.length == 3) {\n\t\t\t\ttry {\n\t\t\t\t\tpropertyClass = Enum.valueOf(PropertyType.class, names[2]).getValue();\n\t\t\t\t\tlogger.debug(key + \":\" + propertyClass.getName());\n\t\t\t\t\tif (propertyClass != null) {\n\t\t\t\t\t\tif (propertyClass.getName().equals(\"java.util.Date\")) {\n\t\t\t\t\t\t\tString str = value.toString();\n\t\t\t\t\t\t\tif (str.length() == 10) {\n\t\t\t\t\t\t\t\tif (names[0].equals(\"GT\") || names[0].equals(\"GTE\")) {\n\t\t\t\t\t\t\t\t\tstr += \" 00:00:00\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (names[0].equals(\"LT\") || names[0].equals(\"LTE\")) {\n\t\t\t\t\t\t\t\t\tstr += \" 23:59:59\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue = dateTimeFormat.parseObject(str);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = ConvertUtils.convert(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\tlogger.warn(key + \" PropertyType is not a valid type!\", e);\n\t\t\t\t} catch (ParseException e) {\n\t\t\t\t\tlogger.warn(key + \" PropertyType is not a valid type!\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfiledName = names[1];\n\t\t\toperator = Operator.valueOf(names[0]);\n\t\t\t// 创建searchFilter\n\t\t\tSearchFilter filter = new SearchFilter(filedName, operator, value);\n\t\t\tfilters.put(key, filter);\n\t\t}\n\n\t\treturn filters;\n\t}\n\n\t/**\n\t * @author 何高才\n\t * searchParams中key的格式为LIKES_name\n\t * \n\t * @see 属性[操作符]=值\n\t * @see 属性.属性[操作符]=值\n\t * \n\t * http://192.168.1.92:8080/yhwlsys_base/jobs/find.do?Employees.employeeId_eq=15\n\t *  http://192.168.1.92:8080/yhwlsys_base/jobs/find.do?Employees.employeeId=15\n\t *  http://192.168.1.92:8080/yhwlsys_base/jobs/find.do?Employees.name_like=123\n\t */\n\tpublic static Map<String, SearchFilter> parse2Filter(Map<String, Object> searchParams) {\n\t\tMap<String, SearchFilter> filters = Maps.newHashMap();\n\t\tfor (Entry<String, Object> entry : searchParams.entrySet()) {\n\t\t\tString key = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\t// 过滤掉空值\n\t\t\tif (value != null && StringUtils.isBlank(value.toString())) { continue; }\n\t\t\t\n\t\t\t// count和page都是用于分页的，建议前端表单提交不要使用这两个单词\n\t\t\tif(\"count\".equals(key) || \"page\".equals(key) || \"_\".equals(key)) { continue; }\n\t\t\t\n\t\t\t// 这个orderParam用于由前端传入排序的值\n\t\t\tif(key.startsWith(\"orderParams\")) { continue; }\n\t\t\t// 这个rjdParam用于由前端传入减少Json数据量的值\n\t\t\tif(key.startsWith(\"rjdParams\")) { continue; }\n\t\t\t\n\t\t\t// rjd用于由前端传入减少Json数据量的值\n\t\t\tif(key.equals(\"rjd\")) { continue; }\n\t\t\t\n\t\t\tString lowerCase = key.toLowerCase();\n\t\t\tif(lowerCase.equalsIgnoreCase(\"db_query\")) {\n\t\t\t\t/*String strs[] = value.toString().split(\"@|\\\\|\");\n\t\t\t\tString fields[];\n\t\t\t\tMap<String, Object> _searchParams = new HashMap<String, Object>(strs.length);\n\t\t\t\tfor(String str : strs) {\n\t\t\t\t\tfields = StringUtil.split(str, '=');\n\t\t\t\t\tif(fields != null && fields.length == 2) {\n\t\t\t\t\t\t_searchParams.put(fields[0], fields[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfilters.putAll(parse2Filter(_searchParams));*/\n\t\t\t\tSearchFilter filter = new SearchFilter(key, Operator.QUERY, value);\n\t\t\t\tfilters.put(key, filter);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tString filedName = null;\n\t\t\tString oper = null;\n\t\t\tint leftLast = key.lastIndexOf('_');\n\t\t\tif(leftLast > -1) {  // 如果存在\n\t\t\t\t// 拆分operator与filedAttribute\n\t\t\t\tfiledName = key.substring(0, leftLast);\n\t\t\t\toper = key.substring(leftLast + 1).toUpperCase();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfiledName = key;\n\t\t\t\toper = \"EQ\";\n\t\t\t}\n\n\t\t\t// 创建searchFilter\n\t\t\tSearchFilter filter = new SearchFilter(\n\t\t\t\t\t// 说明是一个集合类\n\t\t\t\t\tfiledName.indexOf('.') > -1? \"[join]\" + filedName : filedName, \n\t\t\t\t\t\t\tOperator.valueOf( oper ), \n\t\t\t\t\t\t\tvalue);\n\t\t\tfilters.put(key, filter);\n\t\t}\n\n\t\treturn filters;\n\t}\n\t\n\t\n\t/**\n\t * @see Page<BJob> jobs = SearchFilter.query(\"jName[like]=sma&jId=3&BEmployees.employeeId=2\", pageable, BJob.class, jobsRepository);\n\t * @param query  -->  \"jName[like]=sma&jId=3&BEmployees.employeeId=2\"\n\t * @param pageable --> PageRequest pageable;\n\t * @param entity --> BJob.class\n\t * @param repository --> jobsRepository 继承JpaSpecificationExecutor\n\t * @return\n\t */\n\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tpublic static Page query(String query, PageRequest pageable , Class<?> entity, JpaSpecificationExecutor repository) {\n\t\tString strs[] = StringUtils.split(query, '&');\n\t\tif(strs == null || strs.length == 0) {\n\t\t\tthrow new IllegalArgumentException(\"query 不能为null或者空字符串\");\n\t\t}\n\t\telse {\n\t\t\tMap<String, Object> searchParams = new HashMap<String, Object>(strs.length);  // TreeMap不用排序\n\t\t\tfor(String str : strs) {\n\t\t\t\tString keyValue[] = StringUtils.split(str, '=');\n\t\t\t\tif(keyValue.length != 2) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"\\\"\" + query + \"\\\"包含不正确的键值对\");\n\t\t\t\t}\n\t\t\t\tsearchParams.put(StringUtils.trim(keyValue[0]), keyValue[1]);\n\t\t\t}\n\t\t\tSpecification spec = DynamicSpecifications.bySearchFilter(SearchFilter.parse2Filter(searchParams).values(), entity);\n\t\t\treturn repository.findAll(spec, pageable);\n\t\t}\n\t}\n\t\n\t/**\n\t * @see List<BJob> jobs = SearchFilter.query(\"jName[like]=sma&jId=3&BEmployees.employeeId=2\", BJob.class, jobsRepository);\n\t * @param query  -->  \"jName[like]=sma&jId=3&BEmployees.employeeId=2\"\n\t * @param entity --> BJob.class\n\t * @param repository --> jobsRepository 继承JpaSpecificationExecutor\n\t * @return\n\t */\n\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tpublic static List query(String query, Class<?> entity, JpaSpecificationExecutor repository) {\n\t\tString strs[] = StringUtils.split(query, '&');\n\t\tif(strs == null || strs.length == 0) {\n\t\t\tthrow new IllegalArgumentException(\"query不能为null或者空字符串\");\n\t\t}\n\t\telse {\n\t\t\tMap<String, Object> searchParams = new HashMap<String, Object>(strs.length);  // TreeMap不用排序\n\t\t\tfor(String str : strs) {\n\t\t\t\tString keyValue[] = StringUtils.split(str, '=');\n\t\t\t\tif(keyValue.length != 2) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"\\\"\" + query + \"\\\"包含不正确的键值对\");\n\t\t\t\t}\n\t\t\t\tsearchParams.put(StringUtils.trim(keyValue[0]), keyValue[1]);\n\t\t\t}\n\t\t\tSpecification spec = DynamicSpecifications.bySearchFilter(SearchFilter.parse2Filter(searchParams).values(), entity);\n\t\t\treturn repository.findAll(spec);\n\t\t}\n\t}\n\t\n}\nsrc/main/java/org/summer/dp/cms/entity/base/PostFunction.java\n@Entity\r\n@Table(name = \"post_function\")\r\npublic class PostFunction implements java.io.Serializable {\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = -2002546310575775614L;\r\n\tprivate Long id;\r\n\tprivate Function function;\r\n\tprivate Post post;\r\n\r\n\tpublic PostFunction() {\r\n\t}\r\n\r\n\tpublic PostFunction(Function function, Post post) {\r\n\t\tthis.function = function;\r\n\t\tthis.post = post;\r\n\t}\r\n\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = IDENTITY)\r\n\t@Column(name = \"ID\", unique = true, nullable = false)\r\n\tpublic Long getId() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic void setId(Long id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"FCUNTION_ID\", nullable = false)\r\n\tpublic Function getFunction() {\r\n\t\treturn this.function;\r\n\t}\r\n\r\n\tpublic void setFunction(Function function) {\r\n\t\tthis.function = function;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"POST_ID\", nullable = false)\r\n\tpublic Post getPost() {\r\n\t\treturn this.post;\r\n\t}\r\n\r\n\tpublic void setPost(Post post) {\r\n\t\tthis.post = post;\r\n\t}\r\n\r\n}\r\nsrc/main/java/org/summer/dp/cms/vo/Menu.java\npublic class Menu {\r\n   \r\n}\r\nsrc/main/java/org/summer/dp/cms/entity/base/EmployeePosts.java\n@Entity\r\n@Table(name = \"employee_posts\")\r\npublic class EmployeePosts implements java.io.Serializable {\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = 7361688749674065936L;\r\n\tprivate Long id;\r\n\tprivate Employee employee;\r\n\tprivate Post post;\r\n\r\n\tpublic EmployeePosts() {\r\n\t}\r\n\r\n\tpublic EmployeePosts(Employee employee, Post post) {\r\n\t\tthis.employee = employee;\r\n\t\tthis.post = post;\r\n\t}\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = IDENTITY)\r\n\t@Column(name = \"ID\", unique = true, nullable = false)\r\n\tpublic Long getId() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic void setId(Long id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"EMP_ID\", nullable = false)\r\n\tpublic Employee getEmployee() {\r\n\t\treturn this.employee;\r\n\t}\r\n\r\n\tpublic void setEmployee(Employee employee) {\r\n\t\tthis.employee = employee;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"POST_ID\", nullable = false)\r\n\tpublic Post getPost() {\r\n\t\treturn this.post;\r\n\t}\r\n\r\n\tpublic void setPost(Post post) {\r\n\t\tthis.post = post;\r\n\t}\r\n\r\n}\r\nsrc/main/java/org/summer/dp/cms/vo/CurrentInfo.java\npublic class CurrentInfo implements java.io.Serializable{\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = -8608567303375326512L;\r\n\t\r\n\tprivate Account account; \r\n\tprivate Employee employee;\r\n\tprivate Set<Post> postList;\r\n\tprivate boolean needFilter = true;//是否需要过滤，这个变量登录完后才会有值\r\n\tprivate long defaultPostId ;\r\n\tprivate String indexPage ;\r\n\tprivate List<Function> menus;\r\n\tprivate List<Function> permissions;\r\n\t\r\n\r\n\tpublic Account getAccount() {\r\n\t\treturn account;\r\n\t}\r\n\tpublic void setAccount(Account account) {\r\n\t\tthis.account = account;\r\n\t}\r\n\r\n\tpublic Employee getEmployee() {\r\n\t\treturn employee;\r\n\t}\r\n\tpublic void setEmployee(Employee employee) {\r\n\t\tthis.employee = employee;\r\n\t}\r\n\tpublic Set<Post> getPostList() {\r\n\t\treturn postList;\r\n\t}\r\n\tpublic void setPostList(Set<Post> postList) {\r\n\t\tthis.postList = postList;\r\n\t}\r\n\tpublic boolean isNeedFilter() {\r\n\t\treturn needFilter;\r\n\t}\r\n\tpublic void setNeedFilter(boolean needFilter) {\r\n\t\tthis.needFilter = needFilter;\r\n\t}\r\n\tpublic long getDefaultPostId() {\r\n\t\treturn defaultPostId;\r\n\t}\r\n\tpublic void setDefaultPostId(long defaultPostId) {\r\n\t\tthis.defaultPostId = defaultPostId;\r\n\t}\r\n\tpublic String getIndexPage() {\r\n\t\treturn indexPage;\r\n\t}\r\n\tpublic void setIndexPage(String indexPage) {\r\n\t\tthis.indexPage = indexPage;\r\n\t}\r\n\tpublic List<Function> getMenus() {\r\n\t\treturn menus;\r\n\t}\r\n\tpublic void setMenus(List<Function> menus) {\r\n\t\tthis.menus = menus;\r\n\t}\r\n\tpublic List<Function> getPermissions() {\r\n\t\treturn permissions;\r\n\t}\r\n\tpublic void setPermissions(List<Function> permissions) {\r\n\t\tthis.permissions = permissions;\r\n\t}\r\n\tpublic CurrentInfo(){};\r\n\tpublic CurrentInfo(Account account, Employee employee, Set<Post> postList) {\r\n\t\tsuper();\r\n\t\tthis.account = account;\r\n\t\tthis.employee = employee;\r\n\t\tthis.postList = postList;\r\n\t}\r\n\r\n}\r\nsrc/main/java/org/summer/dp/cms/entity/base/Account.java\n@Entity\r\n@Table(name = \"account\",  uniqueConstraints = @UniqueConstraint(columnNames = \"LOGIN_NAME\"))\r\npublic class Account implements java.io.Serializable {\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = 1264240706007686716L;\r\n\tprivate Long id;\r\n\tprivate Employee employeeByModifyUserId;\r\n\tprivate Employee employeeByAddUserId;\r\n\tprivate String loginName;\r\n\tprivate String password;\r\n\tprivate Date addDate;\r\n\tprivate Date modifyDate;\r\n\tprivate Integer status;\r\n\tprivate Set<Employee> employees = new HashSet<Employee>(0);\r\n\r\n\tpublic Account() {\r\n\t}\r\n\r\n\tpublic Account(String loginName, String password, Date addDate) {\r\n\t\tthis.loginName = loginName;\r\n\t\tthis.password = password;\r\n\t\tthis.addDate = addDate;\r\n\t}\r\n\r\n\tpublic Account(Employee employeeByModifyUserId,\r\n\t\t\tEmployee employeeByAddUserId, String loginName, String password,\r\n\t\t\tDate addDate, Date modifyDate, Integer status,\r\n\t\t\tSet<Employee> employees) {\r\n\t\tthis.employeeByModifyUserId = employeeByModifyUserId;\r\n\t\tthis.employeeByAddUserId = employeeByAddUserId;\r\n\t\tthis.loginName = loginName;\r\n\t\tthis.password = password;\r\n\t\tthis.addDate = addDate;\r\n\t\tthis.modifyDate = modifyDate;\r\n\t\tthis.status = status;\r\n\t\tthis.employees = employees;\r\n\t}\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = IDENTITY)\r\n\t@Column(name = \"ID\", unique = true, nullable = false)\r\n\tpublic Long getId() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic void setId(Long id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"MODIFY_USER_ID\")\r\n\tpublic Employee getEmployeeByModifyUserId() {\r\n\t\treturn this.employeeByModifyUserId;\r\n\t}\r\n\r\n\tpublic void setEmployeeByModifyUserId(Employee employeeByModifyUserId) {\r\n\t\tthis.employeeByModifyUserId = employeeByModifyUserId;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"ADD_USER_ID\")\r\n\tpublic Employee getEmployeeByAddUserId() {\r\n\t\treturn this.employeeByAddUserId;\r\n\t}\r\n\r\n\tpublic void setEmployeeByAddUserId(Employee employeeByAddUserId) {\r\n\t\tthis.employeeByAddUserId = employeeByAddUserId;\r\n\t}\r\n\r\n\t@Column(name = \"LOGIN_NAME\", unique = true, nullable = false, length = 32)\r\n\tpublic String getLoginName() {\r\n\t\treturn this.loginName;\r\n\t}\r\n\r\n\tpublic void setLoginName(String loginName) {\r\n\t\tthis.loginName = loginName;\r\n\t}\r\n\r\n\t@Column(name = \"PASSWORD\", nullable = false, length = 32)\r\n\tpublic String getPassword() {\r\n\t\treturn this.password;\r\n\t}\r\n\r\n\tpublic void setPassword(String password) {\r\n\t\tthis.password = password;\r\n\t}\r\n\r\n\t@Temporal(TemporalType.DATE)\r\n\t@Column(name = \"ADD_DATE\", nullable = false, length = 10)\r\n\tpublic Date getAddDate() {\r\n\t\treturn this.addDate;\r\n\t}\r\n\r\n\tpublic void setAddDate(Date addDate) {\r\n\t\tthis.addDate = addDate;\r\n\t}\r\n\r\n\t@Temporal(TemporalType.DATE)\r\n\t@Column(name = \"MODIFY_DATE\", length = 10)\r\n\tpublic Date getModifyDate() {\r\n\t\treturn this.modifyDate;\r\n\t}\r\n\r\n\tpublic void setModifyDate(Date modifyDate) {\r\n\t\tthis.modifyDate = modifyDate;\r\n\t}\r\n\r\n\t@Column(name = \"STATUS\")\r\n\tpublic Integer getStatus() {\r\n\t\treturn this.status;\r\n\t}\r\n\r\n\tpublic void setStatus(Integer status) {\r\n\t\tthis.status = status;\r\n\t}\r\n\r\n\t@OneToMany(fetch = FetchType.LAZY, mappedBy = \"account\")\r\n\tpublic Set<Employee> getEmployees() {\r\n\t\treturn this.employees;\r\n\t}\r\n\r\n\tpublic void setEmployees(Set<Employee> employees) {\r\n\t\tthis.employees = employees;\r\n\t}\r\n\r\n}\r\nsrc/main/java/org/summer/dp/cms/repository/EmployeeRepository.java\npublic interface EmployeeRepository extends PagingAndSortingRepository<Employee, Long>, JpaSpecificationExecutor<Employee>{\r\n\tEmployee findByAccountId(long accountId);\r\n}\r\nsrc/main/java/org/summer/dp/cms/repository/DepartmentRepository.java\npublic interface DepartmentRepository extends PagingAndSortingRepository<Department, Long>, JpaSpecificationExecutor<Department>{\r\n\r\n}\r\nsrc/main/java/org/summer/dp/cms/vo/Permission.java\npublic class Permission {\r\n\tprivate String requestUri;//不匹配requestUri的请求就是没有配置该权限\r\n\r\n\tpublic String getRequestUri() {\r\n\t\treturn requestUri;\r\n\t}\r\n\r\n\tpublic void setRequestUri(String requestUri) {\r\n\t\tthis.requestUri = requestUri;\r\n\t}\r\n\r\n\tpublic boolean equals(String currentRequestUri){\r\n\t\tif(this.requestUri.equals(currentRequestUri))\r\n\t\t\treturn true;\r\n\t\t\t\r\n\t\treturn false;\r\n\r\n\t}\r\n}\r\nsrc/main/java/org/summer/dp/cms/entity/base/Function.java\n@Entity\r\n@Table(name = \"function\")\r\npublic class Function implements java.io.Serializable {\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = -6707687628423571265L;\r\n\tprivate Long id;\r\n\tprivate String name;\r\n\tprivate int crudo;\r\n\tprivate String requestUri;\r\n\tprivate String entityPackage;\r\n\tprivate Long impler;\r\n\tprivate String ctrlName;\r\n\tprivate String jsUrl;\r\n\tprivate byte isMenu;\r\n\tprivate byte menuLevel;\r\n\tprivate Set<PostFunction> postFunctions = new HashSet<PostFunction>(0);\r\n\r\n\tpublic Function() {\r\n\t}\r\n\r\n\tpublic Function(String name, int crudo, String requestUri,\r\n\t\t\tString entityPackage, String ctrlName, String jsUrl) {\r\n\t\tthis.name = name;\r\n\t\tthis.crudo = crudo;\r\n\t\tthis.requestUri = requestUri;\r\n\t\tthis.entityPackage = entityPackage;\r\n\t\tthis.ctrlName = ctrlName;\r\n\t\tthis.jsUrl = jsUrl;\r\n\t}\r\n\r\n\tpublic Function(String name, int crudo, String requestUri,\r\n\t\t\tString entityPackage, Long impler, String ctrlName, String jsUrl,\r\n\t\t\tSet<PostFunction> postFunctions) {\r\n\t\tthis.name = name;\r\n\t\tthis.crudo = crudo;\r\n\t\tthis.requestUri = requestUri;\r\n\t\tthis.entityPackage = entityPackage;\r\n\t\tthis.impler = impler;\r\n\t\tthis.ctrlName = ctrlName;\r\n\t\tthis.jsUrl = jsUrl;\r\n\t\tthis.postFunctions = postFunctions;\r\n\t}\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = IDENTITY)\r\n\t@Column(name = \"ID\", unique = true, nullable = false)\r\n\tpublic Long getId() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic void setId(Long id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\t@Column(name = \"NAME\", nullable = false, length = 32)\r\n\tpublic String getName() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\t@Column(name = \"CRUDO\", nullable = false)\r\n\tpublic int getCrudo() {\r\n\t\treturn this.crudo;\r\n\t}\r\n\r\n\tpublic void setCrudo(int crudo) {\r\n\t\tthis.crudo = crudo;\r\n\t}\r\n\r\n\t@Column(name = \"REQUEST_URI\", nullable = false, length = 128)\r\n\tpublic String getRequestUri() {\r\n\t\treturn this.requestUri;\r\n\t}\r\n\r\n\tpublic void setRequestUri(String requestUri) {\r\n\t\tthis.requestUri = requestUri;\r\n\t}\r\n\r\n\t@Column(name = \"ENTITY_PACKAGE\", nullable = false, length = 128)\r\n\tpublic String getEntityPackage() {\r\n\t\treturn this.entityPackage;\r\n\t}\r\n\r\n\tpublic void setEntityPackage(String entityPackage) {\r\n\t\tthis.entityPackage = entityPackage;\r\n\t}\r\n\r\n\t@Column(name = \"IMPLER\")\r\n\tpublic Long getImpler() {\r\n\t\treturn this.impler;\r\n\t}\r\n\r\n\tpublic void setImpler(Long impler) {\r\n\t\tthis.impler = impler;\r\n\t}\r\n\r\n\t@Column(name = \"CTRL_NAME\", nullable = false)\r\n\tpublic String getCtrlName() {\r\n\t\treturn this.ctrlName;\r\n\t}\r\n\r\n\tpublic void setCtrlName(String ctrlName) {\r\n\t\tthis.ctrlName = ctrlName;\r\n\t}\r\n\r\n\t@Column(name = \"JS_URL\", nullable = false)\r\n\tpublic String getJsUrl() {\r\n\t\treturn this.jsUrl;\r\n\t}\r\n\r\n\tpublic void setJsUrl(String jsUrl) {\r\n\t\tthis.jsUrl = jsUrl;\r\n\t}\r\n\r\n\t@OneToMany(fetch = FetchType.LAZY, mappedBy = \"function\")\r\n\tpublic Set<PostFunction> getPostFunctions() {\r\n\t\treturn this.postFunctions;\r\n\t}\r\n\r\n\tpublic void setPostFunctions(Set<PostFunction> postFunctions) {\r\n\t\tthis.postFunctions = postFunctions;\r\n\t}\r\n\r\n\tpublic byte getIsMenu() {\r\n\t\treturn isMenu;\r\n\t}\r\n\r\n\tpublic void setIsMenu(byte isMenu) {\r\n\t\tthis.isMenu = isMenu;\r\n\t}\r\n\r\n\tpublic byte getMenuLevel() {\r\n\t\treturn menuLevel;\r\n\t}\r\n\r\n\tpublic void setMenuLevel(byte menuLevel) {\r\n\t\tthis.menuLevel = menuLevel;\r\n\t}\r\n}\r\nsrc/main/java/org/summer/dp/cms/repository/FunctionRepository.java\npublic interface FunctionRepository extends PagingAndSortingRepository<Function, Long>, JpaSpecificationExecutor<Function>{\r\n   \r\n}\r\nsrc/main/java/org/summer/dp/cms/entity/base/Employee.java\n@Entity\r\n@Table(name = \"employee\" , uniqueConstraints = @UniqueConstraint(columnNames = \"ACCOUNT_ID\"))\r\npublic class Employee implements java.io.Serializable {\r\n\tprivate static final long serialVersionUID = 2663464651034487322L;\r\n\tprivate Long id;\r\n\tprivate Employee employeeByModifyUserId;\r\n\tprivate Employee employeeByAddUserId;\r\n\tprivate Account account;\r\n\tprivate String name;\r\n\tprivate Long defaultPostId;\r\n\tprivate Date addDate;\r\n\tprivate Date modifyDate;\r\n\tprivate String educationBackground;\r\n\tprivate Integer maritalStatus;\r\n\tprivate Integer state;\r\n\tprivate Date dateOfBirth;\r\n\tprivate String idCard;\r\n\tprivate String email;\r\n\r\n\tprivate Set<EmployeePosts> employeePostses = new HashSet<EmployeePosts>(0);\r\n\r\n\tpublic Employee() {\r\n\t}\r\n\r\n\tpublic Employee(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic Employee(Employee employeeByModifyUserId,\r\n\t\t\tEmployee employeeByAddUserId, Account account, String name,\r\n\t\t\tLong defaultPostId, Date addDate, Date modifyDate,\r\n\t\t\tString educationBackground, Integer maritalStatus, Integer state,\r\n\t\t\tDate dateOfBirth, String idCard, String email,\r\n\t\t\tSet<Employee> employeesForModifyUserId,\r\n\t\t\tSet<Account> accountsForModifyUserId,\r\n\t\t\tSet<Account> accountsForAddUserId,\r\n\t\t\tSet<Employee> employeesForAddUserId,\r\n\t\t\tSet<EmployeePosts> employeePostses) {\r\n\t\tthis.employeeByModifyUserId = employeeByModifyUserId;\r\n\t\tthis.employeeByAddUserId = employeeByAddUserId;\r\n\t\tthis.account = account;\r\n\t\tthis.name = name;\r\n\t\tthis.defaultPostId = defaultPostId;\r\n\t\tthis.addDate = addDate;\r\n\t\tthis.modifyDate = modifyDate;\r\n\t\tthis.educationBackground = educationBackground;\r\n\t\tthis.maritalStatus = maritalStatus;\r\n\t\tthis.state = state;\r\n\t\tthis.dateOfBirth = dateOfBirth;\r\n\t\tthis.idCard = idCard;\r\n\t\tthis.email = email;\r\n\t\tthis.employeePostses = employeePostses;\r\n\t}\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = IDENTITY)\r\n\t@Column(name = \"ID\", unique = true, nullable = false)\r\n\tpublic Long getId() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic void setId(Long id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"MODIFY_USER_ID\")\r\n\tpublic Employee getEmployeeByModifyUserId() {\r\n\t\treturn this.employeeByModifyUserId;\r\n\t}\r\n\r\n\tpublic void setEmployeeByModifyUserId(Employee employeeByModifyUserId) {\r\n\t\tthis.employeeByModifyUserId = employeeByModifyUserId;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"ADD_USER_ID\")\r\n\tpublic Employee getEmployeeByAddUserId() {\r\n\t\treturn this.employeeByAddUserId;\r\n\t}\r\n\r\n\tpublic void setEmployeeByAddUserId(Employee employeeByAddUserId) {\r\n\t\tthis.employeeByAddUserId = employeeByAddUserId;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"ACCOUNT_ID\", unique = true)\r\n\tpublic Account getAccount() {\r\n\t\treturn this.account;\r\n\t}\r\n\r\n\tpublic void setAccount(Account account) {\r\n\t\tthis.account = account;\r\n\t}\r\n\r\n\t@Column(name = \"NAME\", nullable = false, length = 16)\r\n\tpublic String getName() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\t@Column(name = \"DEFAULT_POST_ID\")\r\n\tpublic Long getDefaultPostId() {\r\n\t\treturn this.defaultPostId;\r\n\t}\r\n\r\n\tpublic void setDefaultPostId(Long defaultPostId) {\r\n\t\tthis.defaultPostId = defaultPostId;\r\n\t}\r\n\r\n\t@Temporal(TemporalType.DATE)\r\n\t@Column(name = \"ADD_DATE\", length = 10)\r\n\tpublic Date getAddDate() {\r\n\t\treturn this.addDate;\r\n\t}\r\n\r\n\tpublic void setAddDate(Date addDate) {\r\n\t\tthis.addDate = addDate;\r\n\t}\r\n\r\n\t@Temporal(TemporalType.DATE)\r\n\t@Column(name = \"MODIFY_DATE\", length = 10)\r\n\tpublic Date getModifyDate() {\r\n\t\treturn this.modifyDate;\r\n\t}\r\n\r\n\tpublic void setModifyDate(Date modifyDate) {\r\n\t\tthis.modifyDate = modifyDate;\r\n\t}\r\n\r\n\t@Column(name = \"EDUCATION_BACKGROUND\", length = 32)\r\n\tpublic String getEducationBackground() {\r\n\t\treturn this.educationBackground;\r\n\t}\r\n\r\n\tpublic void setEducationBackground(String educationBackground) {\r\n\t\tthis.educationBackground = educationBackground;\r\n\t}\r\n\r\n\t@Column(name = \"MARITAL_STATUS\")\r\n\tpublic Integer getMaritalStatus() {\r\n\t\treturn this.maritalStatus;\r\n\t}\r\n\r\n\tpublic void setMaritalStatus(Integer maritalStatus) {\r\n\t\tthis.maritalStatus = maritalStatus;\r\n\t}\r\n\r\n\t@Column(name = \"STATE\")\r\n\tpublic Integer getState() {\r\n\t\treturn this.state;\r\n\t}\r\n\r\n\tpublic void setState(Integer state) {\r\n\t\tthis.state = state;\r\n\t}\r\n\r\n\t@Temporal(TemporalType.DATE)\r\n\t@Column(name = \"DATE_OF_BIRTH\", length = 10)\r\n\tpublic Date getDateOfBirth() {\r\n\t\treturn this.dateOfBirth;\r\n\t}\r\n\r\n\tpublic void setDateOfBirth(Date dateOfBirth) {\r\n\t\tthis.dateOfBirth = dateOfBirth;\r\n\t}\r\n\r\n\t@Column(name = \"ID_CARD\", length = 32)\r\n\tpublic String getIdCard() {\r\n\t\treturn this.idCard;\r\n\t}\r\n\r\n\tpublic void setIdCard(String idCard) {\r\n\t\tthis.idCard = idCard;\r\n\t}\r\n\r\n\t@Column(name = \"EMAIL\", length = 64)\r\n\tpublic String getEmail() {\r\n\t\treturn this.email;\r\n\t}\r\n\r\n\tpublic void setEmail(String email) {\r\n\t\tthis.email = email;\r\n\t}\r\n\r\n\t@OneToMany(fetch = FetchType.LAZY, mappedBy = \"employee\")\r\n\tpublic Set<EmployeePosts> getEmployeePostses() {\r\n\t\treturn this.employeePostses;\r\n\t}\r\n\r\n\tpublic void setEmployeePostses(Set<EmployeePosts> employeePostses) {\r\n\t\tthis.employeePostses = employeePostses;\r\n\t}\r\n\r\n}\r\nsrc/main/java/org/summer/dp/cms/entity/base/Post.java\n@Entity\r\n@Table(name = \"post\")\r\npublic class Post implements java.io.Serializable {\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = -4462117857046731958L;\r\n\tprivate Long id;\r\n\tprivate Department department;\r\n\tprivate Long addUserId;\r\n\tprivate Date addDate;\r\n\tprivate Date modifyDate;\r\n\tprivate Long modifyUserId;\r\n\tprivate String name;\r\n\tprivate String indexPage;\r\n\tprivate Integer needFilter;\r\n\tprivate Set<PostFunction> postFunctions = new HashSet<PostFunction>(0);\r\n\tprivate Set<EmployeePosts> employeePostses = new HashSet<EmployeePosts>(0);\r\n\r\n\tpublic Post() {\r\n\t}\r\n\r\n\tpublic Post(Department department, Long addUserId, Date addDate,\r\n\t\t\tDate modifyDate, Long modifyUserId, String name, String indexPage,\r\n\t\t\tInteger needFilter,Set<PostFunction> postFunctions, Set<EmployeePosts> employeePostses) {\r\n\t\tthis.department = department;\r\n\t\tthis.addUserId = addUserId;\r\n\t\tthis.addDate = addDate;\r\n\t\tthis.modifyDate = modifyDate;\r\n\t\tthis.modifyUserId = modifyUserId;\r\n\t\tthis.name = name;\r\n\t\tthis.indexPage = indexPage;\r\n\t\tthis.needFilter = needFilter;\r\n\t\tthis.postFunctions = postFunctions;\r\n\t\tthis.employeePostses = employeePostses;\r\n\t}\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = IDENTITY)\r\n\t@Column(name = \"ID\", unique = true, nullable = false)\r\n\tpublic Long getId() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic void setId(Long id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"DEPARTMENT_ID\")\r\n\tpublic Department getDepartment() {\r\n\t\treturn this.department;\r\n\t}\r\n\r\n\tpublic void setDepartment(Department department) {\r\n\t\tthis.department = department;\r\n\t}\r\n\r\n\t@Column(name = \"ADD_USER_ID\")\r\n\tpublic Long getAddUserId() {\r\n\t\treturn this.addUserId;\r\n\t}\r\n\r\n\tpublic void setAddUserId(Long addUserId) {\r\n\t\tthis.addUserId = addUserId;\r\n\t}\r\n\r\n\t@Temporal(TemporalType.DATE)\r\n\t@Column(name = \"ADD_DATE\", length = 10)\r\n\tpublic Date getAddDate() {\r\n\t\treturn this.addDate;\r\n\t}\r\n\r\n\tpublic void setAddDate(Date addDate) {\r\n\t\tthis.addDate = addDate;\r\n\t}\r\n\r\n\t@Temporal(TemporalType.DATE)\r\n\t@Column(name = \"MODIFY_DATE\", length = 10)\r\n\tpublic Date getModifyDate() {\r\n\t\treturn this.modifyDate;\r\n\t}\r\n\r\n\tpublic void setModifyDate(Date modifyDate) {\r\n\t\tthis.modifyDate = modifyDate;\r\n\t}\r\n\r\n\t@Column(name = \"MODIFY_USER_ID\")\r\n\tpublic Long getModifyUserId() {\r\n\t\treturn this.modifyUserId;\r\n\t}\r\n\r\n\tpublic void setModifyUserId(Long modifyUserId) {\r\n\t\tthis.modifyUserId = modifyUserId;\r\n\t}\r\n\r\n\t@Column(name = \"NAME\", length = 32)\r\n\tpublic String getName() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\t@Column(name = \"INDEX_PAGE\", length = 64)\r\n\tpublic String getIndexPage() {\r\n\t\treturn this.indexPage;\r\n\t}\r\n\r\n\tpublic void setIndexPage(String indexPage) {\r\n\t\tthis.indexPage = indexPage;\r\n\t}\r\n\r\n\t@Column(name = \"NEED_FILTER\")\r\n\tpublic Integer getNeedFilter() {\r\n\t\treturn this.needFilter;\r\n\t}\r\n\r\n\tpublic void setNeedFilter(Integer needFilter) {\r\n\t\tthis.needFilter = needFilter;\r\n\t}\r\n\r\n\t@OneToMany(fetch = FetchType.LAZY, mappedBy = \"post\")\r\n\tpublic Set<PostFunction> getPostFunctions() {\r\n\t\treturn this.postFunctions;\r\n\t}\r\n\r\n\tpublic void setPostFunctions(Set<PostFunction> postFunctions) {\r\n\t\tthis.postFunctions = postFunctions;\r\n\t}\r\n\r\n\t@OneToMany(fetch = FetchType.LAZY, mappedBy = \"post\")\r\n\tpublic Set<EmployeePosts> getEmployeePostses() {\r\n\t\treturn this.employeePostses;\r\n\t}\r\n\r\n\tpublic void setEmployeePostses(Set<EmployeePosts> employeePostses) {\r\n\t\tthis.employeePostses = employeePostses;\r\n\t}\r\n\r\n}\r\nsrc/main/java/org/summer/dp/cms/repository/AccountRepository.java\npublic interface AccountRepository extends PagingAndSortingRepository<Account, Long>, JpaSpecificationExecutor<Account>{\n\tpublic Account findByLoginName(String loginName);\n}\nsrc/main/java/org/summer/dp/cms/entity/base/Department.java\n@Entity\r\n@Table(name = \"department\")\r\npublic class Department implements java.io.Serializable {\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = -2485946314351634883L;\r\n\tprivate Long id;\r\n\tprivate Enterprise enterprise;\r\n\tprivate Date addDate;\r\n\tprivate Long addUserId;\r\n\tprivate Date modifyDate;\r\n\tprivate Long modifyUserId;\r\n\tprivate String name;\r\n\tprivate Set<Post> posts = new HashSet<Post>(0);\r\n\r\n\tpublic Department() {\r\n\t}\r\n\r\n\tpublic Department(Enterprise enterprise, Date addDate, Long addUserId,\r\n\t\t\tDate modifyDate, Long modifyUserId, String name, Set<Post> posts) {\r\n\t\tthis.enterprise = enterprise;\r\n\t\tthis.addDate = addDate;\r\n\t\tthis.addUserId = addUserId;\r\n\t\tthis.modifyDate = modifyDate;\r\n\t\tthis.modifyUserId = modifyUserId;\r\n\t\tthis.name = name;\r\n\t\tthis.posts = posts;\r\n\t}\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = IDENTITY)\r\n\t@Column(name = \"ID\", unique = true, nullable = false)\r\n\tpublic Long getId() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic void setId(Long id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\t@ManyToOne(fetch = FetchType.LAZY)\r\n\t@JoinColumn(name = \"ENTERPRISE_ID\")\r\n\tpublic Enterprise getEnterprise() {\r\n\t\treturn this.enterprise;\r\n\t}\r\n\r\n\tpublic void setEnterprise(Enterprise enterprise) {\r\n\t\tthis.enterprise = enterprise;\r\n\t}\r\n\r\n\t@Temporal(TemporalType.DATE)\r\n\t@Column(name = \"ADD_DATE\", length = 10)\r\n\tpublic Date getAddDate() {\r\n\t\treturn this.addDate;\r\n\t}\r\n\r\n\tpublic void setAddDate(Date addDate) {\r\n\t\tthis.addDate = addDate;\r\n\t}\r\n\r\n\t@Column(name = \"ADD_USER_ID\")\r\n\tpublic Long getAddUserId() {\r\n\t\treturn this.addUserId;\r\n\t}\r\n\r\n\tpublic void setAddUserId(Long addUserId) {\r\n\t\tthis.addUserId = addUserId;\r\n\t}\r\n\r\n\t@Temporal(TemporalType.DATE)\r\n\t@Column(name = \"MODIFY_DATE\", length = 10)\r\n\tpublic Date getModifyDate() {\r\n\t\treturn this.modifyDate;\r\n\t}\r\n\r\n\tpublic void setModifyDate(Date modifyDate) {\r\n\t\tthis.modifyDate = modifyDate;\r\n\t}\r\n\r\n\t@Column(name = \"MODIFY_USER_ID\")\r\n\tpublic Long getModifyUserId() {\r\n\t\treturn this.modifyUserId;\r\n\t}\r\n\r\n\tpublic void setModifyUserId(Long modifyUserId) {\r\n\t\tthis.modifyUserId = modifyUserId;\r\n\t}\r\n\r\n\t@Column(name = \"NAME\", length = 32)\r\n\tpublic String getName() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\t@OneToMany(fetch = FetchType.LAZY, mappedBy = \"department\")\r\n\tpublic Set<Post> getPosts() {\r\n\t\treturn this.posts;\r\n\t}\r\n\r\n\tpublic void setPosts(Set<Post> posts) {\r\n\t\tthis.posts = posts;\r\n\t}\r\n\r\n}\r\nsrc/main/java/org/summer/dp/cms/support/persistence/DynamicSpecifications.java\npublic class DynamicSpecifications {\n\tpublic static final Logger logger = LoggerFactory.getLogger(DynamicSpecifications.class);\n\t\n\t/**\n\t * @see 通过HASH值判断是否日期类型\n\t * @see 前端传过来的参数必然是byte,short,int,float,double, String, Byte, Short, Integer, Float, Double,Date 这些类型的hash值都是互不相同的\n\t * @param type java.util.Date\n\t * @return\n\t */\n\tpublic static boolean isDateType(Class<?> clazz) {\n\t\treturn clazz == Date.class;\n\t}\n\t\n\tpublic static Date parseDate(Object source, Operator oper) throws ParseException {\n\t\tString str = source.toString();\n\t\t// 2010-08-09\n\t\tif(str.length() == 10) {\n\t\t\tswitch(oper) {\n\t\t\tcase LT:\n\t\t\tcase LTE:\n\t\t\t\tstr += \" 23:59:59\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr += \" 00:00:00\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Constants.DF.parse(str);\n\t}\n\t\n\t/**\n\t * @see 动态生成JPA的规范\n\t * @param filters\n\t * @param entityClazz\n\t * @return\n\t */\n\tpublic static <T> Specification<T> bySearchFilter(final Collection<SearchFilter> filters, final Class<T> entityClazz) {\n\t\treturn bySearchFilter(filters, entityClazz, false, null);\n\t}\n\t\n\t/**\n\t * @see 动态生成JPA的规范\n\t * @param filters\n\t * @param entityClazz\n\t * @param isDistinct  true表示本次SQL将会加上distinct，false表示不加\n\t * @return\n\t */\n\tpublic static <T> Specification<T> bySearchFilter(final Collection<SearchFilter> filters, final Class<T> entityClazz, final boolean isDistinct, \n\t\t\tfinal List<OrderParam> orderParams) {\n\t\treturn new Specification<T>() {\n\t\t\t@Override\n\t\t\tpublic Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder builder) {\n\t\t\t\tif(orderParams != null && orderParams.size() > 0) {\n\t\t\t\t\t/*\n\t\t\t\t\tCriteriaQuery<Foo> criteriaQuery = criteriaBuilder.createQuery(Foo.class);\n\t\t\t\t\tRoot<Foo> from = criteriaQuery.from(Foo.class);\n\t\t\t\t\tCriteriaQuery<Foo> select = criteriaQuery.select(from);\n\t\t\t\t\tcriteriaQuery.orderBy(criteriaBuilder.asc(from.get(\"name\")));\n\t\t\t\t\t*/\n\t\t\t\t\tList<Order> orders = new ArrayList<Order>(orderParams.size());\n\t\t\t\t\tfor(OrderParam orderParam : orderParams) {\n\t\t\t\t\t\tif(orderParam != null && orderParam.getField() != null) {\n\t\t\t\t\t\t\tString fields[] = StringUtil.split(orderParam.getField(), '.');\n\t\t\t\t\t\t\tPath expression = (fields.length > 1)? root.join(fields[0]) : root.get(fields[0]);\n\t\t\t\t\t\t\tfor(int i = 1, len = fields.length; i < len; ++i) {\n\t\t\t\t\t\t\t\texpression = expression.get(fields[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(expression != null) {\n\t\t\t\t\t\t\t\tOrder order = (orderParam.getType() == null || orderParam.getType().equalsIgnoreCase(\"asc\"))? \n\t\t\t\t\t\t\t\t\t\tbuilder.asc(expression) : builder.desc(expression);\n\t\t\t\t\t\t\t\torders.add(order);\n//\t\t\t\t\t\t\t\tquery.orderBy(order);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tquery.orderBy(orders);\n\t\t\t\t}\n\t\t\t\tquery.distinct(isDistinct);\n\t\t\t\tif (Collections3.isNotEmpty(filters)) {\n\t\t\t\t\tList<Predicate> predicates = Lists.newArrayList();\n\t\t\t\t\tfor (SearchFilter filter : filters) {\n\t\t\t\t\t\t// nested path translate, 如Task的名为\"user.name\"的filedName, 转换为Task.user.name属性\n\t\t\t\t\t\tString[] names = StringUtils.split(filter.fieldName, '.');\n\t\t\t\t\t\tPath expression = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//////  修正路径不正确下的情形\n\t\t\t\t\t\tboolean hasJoin = names[0].startsWith(\"[join]\");\n\t\t\t\t\t\tString fn = hasJoin? names[0].substring(6) : names[0];\n\t\t\t\t\t\tboolean isNotDateType = !(filter.value instanceof Date);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\texpression = hasJoin? root.join(fn) : root.get(fn);\n\t\t\t\t\t\t\tif(isNotDateType && isDateType(expression.getJavaType())) {\n\t\t\t\t\t\t\t\t// filter.value不可能有\n\t\t\t\t\t\t\t\tfilter.value = parseDate(filter.value.toString(), filter.operator);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}catch(Exception e) {\n//\t\t\t\t\t\t\tlogger.error(e.getMessage(), e);\n\t\t\t\t\t\t\tcontinue;  // 抛异常的话就抛弃该表达式\n\t\t\t\t\t\t}\n\t\t\t\t\t\tboolean isPropertyNotValid = false;\n\t\t\t\t\t\tfor (int i = 1; i < names.length; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\texpression = expression.get(names[i]);\n\t\t\t\t\t\t\t\tif(isNotDateType && isDateType(expression.getJavaType())) {\n\t\t\t\t\t\t\t\t\tfilter.value = parseDate(filter.value.toString(), filter.operator);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch(Exception e) {\n//\t\t\t\t\t\t\t\tlogger.error(e.getMessage(), e);\n\t\t\t\t\t\t\t\tisPropertyNotValid = true;  // 该属性的确无效\n\t\t\t\t\t\t\t\tbreak;  // 抛异常的话就抛弃该表达式\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(expression == null || isPropertyNotValid) { continue; }\n\t\t\t\t\t\t///////\n\t\t\t\t\t\t\n\t\t\t\t\t\t// logic operator\n\t\t\t\t\t\tswitch (filter.operator) {\n\t\t\t\t\t\tcase EQ:\n\t\t\t\t\t\t\tpredicates.add(builder.equal(expression, filter.value));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LIKE:\n\t\t\t\t\t\t\tpredicates.add(builder.like(expression, \"%\" + filter.value + \"%\"));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GT:\n\t\t\t\t\t\t\tpredicates.add(builder.greaterThan(expression, (Comparable) filter.value));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LT:\n\t\t\t\t\t\t\tpredicates.add(builder.lessThan(expression, (Comparable) filter.value));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GTE:\n\t\t\t\t\t\t\tpredicates.add(builder.greaterThanOrEqualTo(expression, (Comparable) filter.value));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LTE:\n\t\t\t\t\t\t\tpredicates.add(builder.lessThanOrEqualTo(expression, (Comparable) filter.value));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ORLIKE:\n\t\t\t\t\t\t\tif(filter.value instanceof String){\n\t\t\t\t\t\t\t\tString value = (String) filter.value;\n\t\t\t\t\t\t\t\tString[] values = value.split(\",\");\n\t\t\t\t\t\t\t\tPredicate[] like = new Predicate[values.length];\n\t\t\t\t\t\t\t\tfor(int i=0;i< values.length;i++){\n\t\t\t\t\t\t\t\t\tlike[i]=builder.like(expression, \"%\" + values[i] + \"%\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpredicates.add(builder.or(like));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ANDLIKE:\n\t\t\t\t\t\t\tif(filter.value instanceof String){\n\t\t\t\t\t\t\t\tString value = (String) filter.value;\n\t\t\t\t\t\t\t\tString[] values = value.split(\",\");\n\t\t\t\t\t\t\t\tPredicate[] like = new Predicate[values.length];\n\t\t\t\t\t\t\t\tfor(int i=0;i< values.length;i++){\n\t\t\t\t\t\t\t\t\tlike[i]=builder.like(expression, \"%\" + values[i] + \"%\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpredicates.add(builder.and(like));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ANDNOTLIKE:\n\t\t\t\t\t\t\tif(filter.value instanceof String){\n\t\t\t\t\t\t\t\tString value = (String) filter.value;\n\t\t\t\t\t\t\t\tString[] values = value.split(\",\");\n\t\t\t\t\t\t\t\tPredicate[] like = new Predicate[values.length];\n\t\t\t\t\t\t\t\tfor(int i=0;i< values.length;i++){\n\t\t\t\t\t\t\t\t\tlike[i]=builder.notLike(expression, \"%\" + values[i] + \"%\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpredicates.add(builder.and(like));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase OREQ:\n\t\t\t\t\t\t\tif(filter.value instanceof String){\n\t\t\t\t\t\t\t\tString value = (String) filter.value;\n\t\t\t\t\t\t\t\tString[] values = value.split(\",\");\n\t\t\t\t\t\t\t\tPredicate[] like = new Predicate[values.length];\n\t\t\t\t\t\t\t\tfor(int i=0;i< values.length;i++){\n\t\t\t\t\t\t\t\t\tlike[i]=builder.equal(expression, values[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpredicates.add(builder.or(like));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tcase ANDNOTEQ:\n\t\t\t\t\t\t\tif(filter.value instanceof String){\n\t\t\t\t\t\t\t\tString value = (String) filter.value;\n\t\t\t\t\t\t\t\tString[] values = value.split(\",\");\n\t\t\t\t\t\t\t\tPredicate[] like = new Predicate[values.length];\n\t\t\t\t\t\t\t\tfor(int i=0;i< values.length;i++){\n\t\t\t\t\t\t\t\t\tlike[i]=builder.notEqual(expression, values[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpredicates.add(builder.and(like));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NOTEQ :\n\t\t\t\t\t\t\tpredicates.add(builder.notEqual(expression, (Comparable) filter.value));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NOTLIKE :\n\t\t\t\t\t\t\tpredicates.add(builder.notLike(expression, \"%\" + filter.value + \"%\"));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NULL:\n\t\t\t\t\t\t\tpredicates.add(builder.isNull(expression));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase NOTNULL:\n\t\t\t\t\t\t\tpredicates.add(builder.isNotNull(expression));\n\t\t\t\t\t\t\tbreak;\n//\t\t\t\t\t\tcase IN:\n//\t\t\t\t\t\t\tpredicates.add(builder.in(expression).in(values));\n//\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// 将所有条件用 and 联合起来\n\t\t\t\t\tif (!predicates.isEmpty()) {\n\t\t\t\t\t\treturn builder.and(predicates.toArray(new Predicate[predicates.size()]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn builder.conjunction();\n\t\t\t}\n\t\t};\n\t}\n}\n", "answers": ["\t\tEmployee employee = null;\r"], "length": 3898, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "8172299ff0fbe70a20a9b2d39ef0f8a2f7e392b066860346"}
{"input": "import binascii\nimport calendar\nimport six\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom .types import EmbeddedSignatureHeader\nfrom .types import Signature\nfrom ...constants import CompressionAlgorithm\nfrom ...constants import Features as _Features\nfrom ...constants import HashAlgorithm\nfrom ...constants import KeyFlags as _KeyFlags\nfrom ...constants import KeyServerPreferences as _KeyServerPreferences\nfrom ...constants import NotationDataFlags\nfrom ...constants import PubKeyAlgorithm\nfrom ...constants import RevocationKeyClass\nfrom ...constants import RevocationReason\nfrom ...constants import SymmetricKeyAlgorithm\nfrom ...decorators import sdproperty\nfrom ...types import Fingerprint\n        from ..packets import SignatureV4\n\"\"\" signature.py\n\nSignature SubPackets\n\"\"\"\n\n\n\n\n\n\n\n\n__all__ = ['URI',\n           'FlagList',\n           'ByteFlag',\n           'Boolean',\n           'CreationTime',\n           'SignatureExpirationTime',\n           'ExportableCertification',\n           'TrustSignature',\n           'RegularExpression',\n           'Revocable',\n           'KeyExpirationTime',\n           'PreferredSymmetricAlgorithms',\n           'RevocationKey',\n           'Issuer',\n           'NotationData',\n           'PreferredHashAlgorithms',\n           'PreferredCompressionAlgorithms',\n           'KeyServerPreferences',\n           'PreferredKeyServer',\n           'PrimaryUserID',\n           'Policy',\n           'KeyFlags',\n           'SignersUserID',\n           'ReasonForRevocation',\n           'Features',\n           'EmbeddedSignature']\n\n\nclass URI(Signature):\n    @sdproperty\n    def uri(self):\n        return self._uri\n\n    @uri.register(str)\n    @uri.register(six.text_type)\n    def uri_str(self, val):\n        self._uri = val\n\n    @uri.register(bytearray)\n    def uri_bytearray(self, val):\n        self.uri = val.decode('latin-1')\n\n    def __init__(self):\n        super(URI, self).__init__()\n        self.uri = \"\"\n\n    def __bytearray__(self):\n        _bytes = super(URI, self).__bytearray__()\n        _bytes += self.uri.encode()\n        return _bytes\n\n    def parse(self, packet):\n        super(URI, self).parse(packet)\n        self.uri = packet[:(self.header.length - 1)]\n        del packet[:(self.header.length - 1)]\n\n\nclass FlagList(Signature):\n    __flags__ = None\n\n    @sdproperty\n    def flags(self):\n        return self._flags\n\n    @flags.register(list)\n    @flags.register(tuple)\n    def flags_list(self, val):\n        self._flags = list(val)\n\n    @flags.register(int)\n    @flags.register(CompressionAlgorithm)\n", "context": "src/leap/mx/vendor/pgpy/constants.py\nclass RevocationReason(IntEnum):\n    #: No reason was specified. This is the default reason.\n    NotSpecified = 0x00\n    #: The key was superseded by a new key. Only meaningful when revoking a key.\n    Superseded = 0x01\n    #: Key material has been compromised. Only meaningful when revoking a key.\n    Compromised = 0x02\n    #: Key is retired and no longer used. Only meaningful when revoking a key.\n    Retired = 0x03\n    #: User ID information is no longer valid. Only meaningful when revoking a certification of a user id.\n    UserID = 0x20\nsrc/leap/mx/vendor/pgpy/types.py\nclass Fingerprint(str):\n    \"\"\"\n    A subclass of ``str``. Can be compared using == and != to ``str``, ``unicode``, and other :py:obj:`Fingerprint` instances.\n\n    Primarily used as a key for internal dictionaries, so it ignores spaces when comparing and hashing\n    \"\"\"\n    @property\n    def keyid(self):\n        return str(self).replace(' ', '')[-16:]\n\n    @property\n    def shortid(self):\n        return str(self).replace(' ', '')[-8:]\n\n    def __new__(cls, content):\n        if isinstance(content, Fingerprint):\n            return content\n\n        # validate input before continuing: this should be a string of 40 hex digits\n        content = content.upper().replace(' ', '')\n        if not bool(re.match(r'^[A-F0-9]{40}$', content)):\n            raise ValueError(\"Expected: String of 40 hex digits\")\n\n        # store in the format: \"AAAA BBBB CCCC DDDD EEEE  FFFF 0000 1111 2222 3333\"\n        #                                               ^^ note 2 spaces here\n        spaces = [ ' ' if i != 4 else '  ' for i in range(10) ]\n        chunks = [ ''.join(g) for g in six.moves.zip_longest(*[iter(content)] * 4) ]\n        content = ''.join(j for i in six.moves.zip_longest(chunks, spaces, fillvalue='') for j in i).strip()\n\n        return str.__new__(cls, content)\n\n    def __eq__(self, other):\n        if isinstance(other, Fingerprint):\n            return str(self) == str(other)\n\n        if isinstance(other, (six.text_type, bytes, bytearray)):\n            if isinstance(other, (bytes, bytearray)):  # pragma: no cover\n                other = other.decode('latin-1')\n\n            other = str(other).replace(' ', '')\n            return any([self.replace(' ', '') == other,\n                        self.keyid == other,\n                        self.shortid == other])\n\n        return False  # pragma: no cover\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __hash__(self):\n        return hash(str(self.replace(' ', '')))\n\n    def __bytes__(self):\n        return binascii.unhexlify(six.b(self.replace(' ', '')))\nsrc/leap/mx/vendor/pgpy/constants.py\nclass HashAlgorithm(IntEnum):\n    Invalid = 0x00\n    MD5 = 0x01\n    SHA1 = 0x02\n    RIPEMD160 = 0x03\n    _reserved_1 = 0x04\n    _reserved_2 = 0x05\n    _reserved_3 = 0x06\n    _reserved_4 = 0x07\n    SHA256 = 0x08\n    SHA384 = 0x09\n    SHA512 = 0x0A\n    SHA224 = 0x0B\n\n    def __init__(self, *args):\n        super(self.__class__, self).__init__()\n        self._tuned_count = 0\n\n    @property\n    def hasher(self):\n        return hashlib.new(self.name)\n\n    @property\n    def digest_size(self):\n        return self.hasher.digest_size\n\n    @property\n    def tuned_count(self):\n        if self._tuned_count == 0:\n            self.tune_count()\n\n        return self._tuned_count\n\n    def tune_count(self):\n        start = end = 0\n        htd = _hashtunedata[:]\n\n        while start == end:\n            # potentially do this multiple times in case the resolution of time.time is low enough that\n            # hashing 100 KiB isn't enough time to produce a measurable difference\n            # (e.g. if the timer for time.time doesn't have enough precision)\n            htd = htd + htd\n            h = self.hasher\n\n            start = time.time()\n            h.update(htd)\n            end = time.time()\n\n        # now calculate how many bytes need to be hashed to reach our expected time period\n        # GnuPG tunes for about 100ms, so we'll do that as well\n        _TIME = 0.100\n        ct = int(len(htd) * (_TIME / (end - start)))\n        c1 = ((ct >> (ct.bit_length() - 5)) - 16)\n        c2 = (ct.bit_length() - 11)\n        c = ((c2 << 4) + c1)\n\n        # constrain self._tuned_count to be between 0 and 255\n        self._tuned_count = max(min(c, 255), 0)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass PubKeyAlgorithm(IntEnum):\n    Invalid = 0x00\n    #: Signifies that a key is an RSA key.\n    RSAEncryptOrSign = 0x01\n    RSAEncrypt = 0x02  # deprecated\n    RSASign = 0x03     # deprecated\n    #: Signifies that a key is an ElGamal key.\n    ElGamal = 0x10\n    #: Signifies that a key is a DSA key.\n    DSA = 0x11\n    #: Signifies that a key is an ECDH key.\n    ECDH = 0x12\n    #: Signifies that a key is an ECDSA key.\n    ECDSA = 0x13\n    FormerlyElGamalEncryptOrSign = 0x14  # deprecated - do not generate\n    # DiffieHellman = 0x15  # X9.42\n\n    @property\n    def can_gen(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign,\n                        PubKeyAlgorithm.DSA,\n                        PubKeyAlgorithm.ECDSA,\n                        PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_encrypt(self):  # pragma: no cover\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.ElGamal, PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_sign(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.DSA, PubKeyAlgorithm.ECDSA}\n\n    @property\n    def deprecated(self):\n        return self in {PubKeyAlgorithm.RSAEncrypt,\n                        PubKeyAlgorithm.RSASign,\n                        PubKeyAlgorithm.FormerlyElGamalEncryptOrSign}\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass Signature(SubPacket):\n    __typeid__ = -1\nsrc/leap/mx/vendor/pgpy/constants.py\nclass NotationDataFlags(FlagEnum):\n    HumanReadable = 0x80\nsrc/leap/mx/vendor/pgpy/decorators.py\ndef sdproperty(fget):\n    def defset(obj, val):  # pragma: no cover\n        raise TypeError(str(val.__class__))\n\n    class SDProperty(property):\n        def register(self, cls=None, fset=None):\n            return self.fset.register(cls, fset)\n\n        def setter(self, fset):\n            self.register(object, fset)\n            return type(self)(self.fget, self.fset, self.fdel, self.__doc__)\n\n    return SDProperty(fget, sdmethod(defset))\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyServerPreferences(IntEnum):\n    Unknown = 0x00\n    NoModify = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass CompressionAlgorithm(IntEnum):\n    #: No compression\n    Uncompressed = 0x00\n    #: ZIP DEFLATE\n    ZIP = 0x01\n    #: ZIP DEFLATE with zlib headers\n    ZLIB = 0x02\n    #: Bzip2\n    BZ2 = 0x03\n\n    def compress(self, data):\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.compress(data)[2:-4]\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.compress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.compress(data)\n\n        raise NotImplementedError(self)\n\n    def decompress(self, data):\n        if six.PY2:\n            data = bytes(data)\n\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.decompress(data, -15)\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.decompress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.decompress(data)\n\n        raise NotImplementedError(self)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass SymmetricKeyAlgorithm(IntEnum):\n    \"\"\"Supported symmetric key algorithms.\"\"\"\n    Plaintext = 0x00\n    #: .. warning::\n    #:     IDEA is insecure. PGPy only allows it to be used for decryption, not encryption!\n    IDEA = 0x01\n    #: Triple-DES with 168-bit key derived from 192\n    TripleDES = 0x02\n    #: CAST5 (or CAST-128) with 128-bit key\n    CAST5 = 0x03\n    #: Blowfish with 128-bit key and 16 rounds\n    Blowfish = 0x04\n    #: AES with 128-bit key\n    AES128 = 0x07\n    #: AES with 192-bit key\n    AES192 = 0x08\n    #: AES with 256-bit key\n    AES256 = 0x09\n    # Twofish with 256-bit key - not currently supported\n    Twofish256 = 0x0A\n    #: Camellia with 128-bit key\n    Camellia128 = 0x0B\n    #: Camellia with 192-bit key\n    Camellia192 = 0x0C\n    #: Camellia with 256-bit key\n    Camellia256 = 0x0D\n\n    @property\n    def cipher(self):\n        bs = {SymmetricKeyAlgorithm.IDEA: algorithms.IDEA,\n              SymmetricKeyAlgorithm.TripleDES: algorithms.TripleDES,\n              SymmetricKeyAlgorithm.CAST5: algorithms.CAST5,\n              SymmetricKeyAlgorithm.Blowfish: algorithms.Blowfish,\n              SymmetricKeyAlgorithm.AES128: algorithms.AES,\n              SymmetricKeyAlgorithm.AES192: algorithms.AES,\n              SymmetricKeyAlgorithm.AES256: algorithms.AES,\n              SymmetricKeyAlgorithm.Twofish256: namedtuple('Twofish256', ['block_size'])(block_size=128),\n              SymmetricKeyAlgorithm.Camellia128: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia192: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia256: algorithms.Camellia}\n\n        if self in bs:\n            return bs[self]\n\n        raise NotImplementedError(repr(self))\n\n    @property\n    def is_insecure(self):\n        insecure_ciphers = {SymmetricKeyAlgorithm.IDEA}\n        return self in insecure_ciphers\n\n    @property\n    def block_size(self):\n        return self.cipher.block_size\n\n    @property\n    def key_size(self):\n        ks = {SymmetricKeyAlgorithm.IDEA: 128,\n              SymmetricKeyAlgorithm.TripleDES: 192,\n              SymmetricKeyAlgorithm.CAST5: 128,\n              SymmetricKeyAlgorithm.Blowfish: 128,\n              SymmetricKeyAlgorithm.AES128: 128,\n              SymmetricKeyAlgorithm.AES192: 192,\n              SymmetricKeyAlgorithm.AES256: 256,\n              SymmetricKeyAlgorithm.Twofish256: 256,\n              SymmetricKeyAlgorithm.Camellia128: 128,\n              SymmetricKeyAlgorithm.Camellia192: 192,\n              SymmetricKeyAlgorithm.Camellia256: 256}\n\n        if self in ks:\n            return ks[self]\n\n        raise NotImplementedError(repr(self))\n\n    def gen_iv(self):\n        return os.urandom(self.block_size // 8)\n\n    def gen_key(self):\n        return os.urandom(self.key_size // 8)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyFlags(FlagEnum):\n    #: Signifies that a key may be used to certify keys and user ids. Primary keys always have this, even if it is not specified.\n    Certify = 0x01\n    #: Signifies that a key may be used to sign messages and documents.\n    Sign = 0x02\n    #: Signifies that a key may be used to encrypt messages.\n    EncryptCommunications = 0x04\n    #: Signifies that a key may be used to encrypt storage. Currently equivalent to :py:obj:`~pgpy.constants.EncryptCommunications`.\n    EncryptStorage = 0x08\n    #: Signifies that the private component of a given key may have been split by a secret-sharing mechanism. Split\n    #: keys are not currently supported by PGPy.\n    Split = 0x10\n    #: Signifies that a key may be used for authentication.\n    Authentication = 0x20\n    #: Signifies that the private component of a key may be in the possession of more than one person.\n    MultiPerson = 0x80\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass EmbeddedSignatureHeader(VersionedHeader):\n    def __bytearray__(self):\n        return bytearray([self.version])\n\n    def parse(self, packet):\n        self.tag = 2\n        super(EmbeddedSignatureHeader, self).parse(packet)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass RevocationKeyClass(FlagEnum):\n    Sensitive = 0x40\n    Normal = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass Features(FlagEnum):\n    ModificationDetection = 0x01\n\n    @classproperty\n    def pgpy_features(cls):\n        return Features.ModificationDetection\n", "answers": ["    @flags.register(HashAlgorithm)"], "length": 1390, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "e3031e6ce9192b7214d3d491b233f14b1a454bcbb2150950"}
{"input": "import re\nimport pickle\nimport unittest\nfrom ..atoms import String, RegExp, IP, DomainName\nfrom ..rules import And, Or, No, Match, NonMatch, Fuzzy\nfrom ...events import Event\nfrom __future__ import unicode_literals\n\n\n\n\n\nclass TestRules(unittest.TestCase):\n    def test_results_should_get_cached(self):\n        rule = Match(\"a\", \"a\")\n        cache = {}\n        rule.match(Event(), cache)\n        self.assertTrue(rule in cache)\n        self.assertFalse(cache[rule])\n\n    def test_cached_results_should_get_used(self):\n        rule = Match(\"a\", \"a\")\n        cache = {rule: True}\n        self.assertTrue(rule.match(Event(), cache))\n\n\nclass TestAnd(unittest.TestCase):\n    def test_can_not_be_initialized_with_zero_arguments(self):\n        self.assertRaises(TypeError, And)\n\n    def test_commutativity(self):\n        a = Match(\"a\", \"a\")\n        b = Match(\"b\", \"b\")\n        self.assertEqual(And(a, b), And(b, a))\n\n    def test_redundant_arguments_get_deduplicated(self):\n        a = Match(\"a\", \"a\")\n        self.assertEqual(And(a, a), And(a))\n\n    _options = [\n        And(Match(\"a\"), Match(\"b\"))\n    ]\n\n    def test_pickling_and_unpickling(self):\n        for option in self._options:\n            self.assertEqual(option, pickle.loads(pickle.dumps(option)))\n\n    def test_repr(self):\n        for option in self._options:\n            self.assertEqual(option, eval(repr(option)))\n\n\nclass TestOr(unittest.TestCase):\n    def test_can_not_be_initialized_with_zero_arguments(self):\n", "context": "abusehelper/core/rules/rules.py\nclass No(Rule):\n    def init(self, rule):\n        Rule.init(self)\n\n        self._rule = rule\n\n    def unique_key(self):\n        return self._rule\n\n    def __repr__(self):\n        return Rule.__repr__(self, self._rule)\n\n    @property\n    def subrule(self):\n        return self._rule\n\n    def match_with_cache(self, obj, cache):\n        return not self._rule.match(obj, cache)\n\n    def dump(self):\n        return self._rule\n\n    @classmethod\n    def load(cls, rule):\n        return cls(rule)\nabusehelper/core/rules/rules.py\nclass NonMatch(Match):\n    def filter(self, value):\n        return self._value is None or not self._value.match(value)\nabusehelper/core/events.py\nclass Event(object):\n    __slots__ = [\"_attrs\"]\n\n    _UNDEFINED = object()\n\n    @classmethod\n    def _itemize(cls, *args, **keys):\n        result = dict()\n\n        for obj in args + (keys,):\n            if type(obj) == Event:\n                for key, values in obj._attrs.iteritems():\n                    if key not in result:\n                        result[key] = values.copy()\n                    else:\n                        result[key].update(values)\n                continue\n\n            if hasattr(obj, \"iteritems\"):\n                obj = obj.iteritems()\n            elif hasattr(obj, \"items\"):\n                obj = obj.items()\n\n            for key, values in obj:\n                if isinstance(values, basestring):\n                    values = (_normalize(values),)\n                else:\n                    values = (_normalize(x) for x in values)\n\n                key = _normalize(key)\n                if key not in result:\n                    result[key] = set(values)\n                else:\n                    result[key].update(values)\n\n        return result\n\n    @classmethod\n    def from_unicode(cls, string):\n        r\"\"\"\n        >>> event = Event({\"a\": \"b\"})\n        >>> Event.from_unicode(unicode(event)) == event\n        True\n\n        >>> event = event.union({u'=': u'\"'})\n        >>> Event.from_unicode(unicode(event)) == event\n        True\n\n        Regression test: Check that character escaping\n        doesn't mess up parsing.\n\n        >>> event = Event({\n        ...     u\"x\": u\"\\\\\",\n        ...     u\"y\": u\"b\"\n        ... })\n        >>> Event.from_unicode(ur'x=\"\\\\\", \"y\"=b') == event\n        True\n        \"\"\"\n\n        string = string.strip()\n        if not string:\n            return cls()\n\n        attrs = collections.defaultdict(list)\n\n        index = 0\n        length = len(string)\n        while True:\n            key, index = _unicode_parse_part(string, index)\n            if index >= length:\n                raise ValueError(\"unexpected string end\")\n            if string[index] != u\"=\":\n                raise ValueError(\"unexpected character %r at index %d\" %\n                                 (string[index], index))\n            index += 1\n\n            value, index = _unicode_parse_part(string, index)\n            attrs[key].append(value)\n\n            if index >= length:\n                return cls(attrs)\n\n            if string[index] != u\",\":\n                raise ValueError(\"unexpected character %r at index %d\" %\n                                 (string[index], index))\n            index += 1\n\n    @classmethod\n    def from_elements(self, elements):\n        \"\"\"Yield events parsed from XML element(s).\n\n        >>> element = Element(\"message\")\n        >>> list(Event.from_elements(element))\n        []\n        >>> element.add(Element(\"event\", xmlns=EVENT_NS))\n        >>> list(Event.from_elements(element)) == [Event()]\n        True\n\n        >>> event = Event({u\"\\\\uffff\": u\"\\\\x05\"}) # include some forbidden XML chars\n        >>> element = Element(\"message\")\n        >>> element.add(event.to_elements())\n        >>> list(Event.from_elements(element)) == [Event({u\"\\\\ufffd\": u\"\\\\ufffd\"})]\n        True\n        \"\"\"\n\n        # Future event format\n        for event_element in elements.children(\"e\", EVENT_NS):\n            attrs = collections.defaultdict(list)\n            for key_element in event_element.children(\"k\").with_attrs(\"a\"):\n                key = b64decode(key_element.get_attr(\"a\")).decode(\"utf-8\")\n                for value_element in key_element.children(\"v\").with_attrs(\"a\"):\n                    value = b64decode(value_element.get_attr(\"a\")).decode(\"utf-8\")\n                    attrs[key].append(value)\n            yield Event(attrs)\n\n        # Legacy event format\n        for event_element in elements.children(\"event\", EVENT_NS):\n            attrs = collections.defaultdict(list)\n            for attr in event_element.children(\"attr\").with_attrs(\"key\", \"value\"):\n                key = attr.get_attr(\"key\")\n                value = attr.get_attr(\"value\")\n                attrs[key].append(value)\n            yield Event(attrs)\n\n    def __init__(self, *args, **keys):\n        \"\"\"\n        Regression test: Keep the the correct internal encoding in the\n        copy/merge constructor.\n\n        >>> event = Event({u\"\\xe4\": u\"\\xe4\"})\n        >>> Event(event).items()\n        ((u'\\\\xe4', u'\\\\xe4'),)\n        \"\"\"\n\n        self._attrs = self._itemize(*args, **keys)\n\n    def union(self, *args, **keys):\n        \"\"\"Return a new event that contains all key-value pairs from\n        appearing in the original event and/or Event(*args, **keys).\n\n        >>> sorted(Event(a=[\"1\", \"2\"]).union(a=[\"1\", \"3\"]).items())\n        [(u'a', u'1'), (u'a', u'2'), (u'a', u'3')]\n        \"\"\"\n\n        return type(self)(self, *args, **keys)\n\n    def difference(self, *args, **keys):\n        \"\"\"Return a new event that contains all key-value pairs\n        from the original event except those also appearing in\n        Event(*args, **keys).\n\n        >>> sorted(Event(a=[\"1\", \"2\"]).difference(a=[\"1\", \"3\"]).items())\n        [(u'a', u'2')]\n        \"\"\"\n\n        other = self._itemize(*args, **keys)\n        result = dict()\n        for key, values in self._attrs.iteritems():\n            diff = values.difference(other.get(key, ()))\n            if diff:\n                result[key] = diff\n        return type(self)(result)\n\n    def add(self, key, value, *values):\n        \"\"\"Add value(s) for a key.\n\n        >>> event = Event()\n        >>> event.add(\"key\", \"1\")\n        >>> event.values(\"key\")\n        (u'1',)\n\n        More than one value can be added with one call.\n\n        >>> event = Event()\n        >>> event.add(\"key\", \"1\", \"2\")\n        >>> sorted(event.values(\"key\"))\n        [u'1', u'2']\n\n        Key-value pairs is already contained by the event are ignored.\n\n        >>> event = Event()\n        >>> event.add(\"key\", \"1\")\n        >>> event.values(\"key\")\n        (u'1',)\n        >>> event.add(\"key\", \"1\")\n        >>> event.values(\"key\")\n        (u'1',)\n        \"\"\"\n\n        self.update(key, (value,) + values)\n\n    def update(self, key, values):\n        \"\"\"Update the values of a key.\n\n        >>> event = Event()\n        >>> event.update(\"key\", [\"1\", \"2\"])\n        >>> sorted(event.values(\"key\"))\n        [u'1', u'2']\n\n        The event will not be modified if there are no values to add.\n\n        >>> event = Event()\n        >>> event.update(\"key\", [])\n        >>> event.contains(\"key\")\n        False\n        \"\"\"\n\n        key = _normalize(key)\n        if key not in self._attrs:\n            self._attrs[key] = set()\n        self._attrs[key].update(_normalize(value) for value in values)\n\n    def discard(self, key, value, *values):\n        \"\"\"Discard some value(s) of a key.\n\n        >>> event = Event()\n        >>> event.add(\"key\", \"1\", \"2\", \"3\")\n        >>> event.discard(\"key\", \"1\", \"3\")\n        >>> event.values(\"key\")\n        (u'2',)\n\n        Values that don't exist for the given key are silently ignored.\n\n        >>> event = Event()\n        >>> event.add(\"key\", \"2\")\n        >>> event.discard(\"key\", \"1\", \"2\")\n        >>> event.values(\"key\")\n        ()\n        \"\"\"\n\n        key = _normalize(key)\n        if key not in self._attrs:\n            return\n        valueset = self._attrs[key]\n        valueset.difference_update(_normalize(value) for value in (value,) + values)\n        if not valueset:\n            del self._attrs[key]\n\n    def clear(self, key):\n        \"\"\"Clear all values of a key.\n\n        >>> event = Event()\n        >>> event.add(\"key\", \"1\")\n        >>> event.clear(\"key\")\n        >>> event.contains(\"key\")\n        False\n\n        Clearing keys that do not exist does nothing.\n\n        >>> event = Event()\n        >>> event.clear(\"key\")\n        \"\"\"\n\n        key = _normalize(key)\n        self._attrs.pop(key, None)\n\n    def _unkeyed(self):\n        for values in self._attrs.itervalues():\n            for value in values:\n                yield value\n\n    def _iter(self, key, parser, filter):\n        if key is self._UNDEFINED:\n            values = set(self._unkeyed())\n        else:\n            key = _normalize(key)\n            values = self._attrs.get(key, ())\n\n        if parser is not None:\n            parsed = (parser(x) for x in values)\n\n            if filter is not None:\n                return (x for x in parsed if filter(x))\n            else:\n                return (x for x in parsed if x is not None)\n\n        if filter is not None:\n            return (x for x in values if filter(x))\n\n        return values\n\n    def pop(self, key, parser=None, filter=None):\n        \"\"\"Pop value(s) of a key and clear them.\n        >>> event = Event()\n        >>> event.add(\"key\", \"y\", \"x\", \"1.2.3.4\")\n        >>> sorted(event.pop(\"key\"))\n        [u'1.2.3.4', u'x', u'y']\n        >>> event.contains(\"key\")\n        False\n\n        Perform parsing, validation and filtering by passing in\n        parsing and filtering functions. Only values that match\n        are cleared from the event. Values that do not match\n        are preserved.\n\n        >>> def int_parse(string):\n        ...     try:\n        ...         return int(string)\n        ...     except ValueError:\n        ...         return None\n        >>> event = Event()\n        >>> event.add(\"key\", \"1\", \"a\")\n        >>> sorted(event.pop(\"key\", parser=int_parse))\n        [1]\n        >>> sorted(event.values(\"key\"))\n        [u'a']\n        \"\"\"\n\n        key = _normalize(key)\n        values = tuple(self._attrs.get(key, ()))\n\n        if parser is not None:\n            parsed = ((parser(x), x) for x in values)\n        else:\n            parsed = ((x, x) for x in values)\n\n        if filter is not None:\n            filtered = ((x, y) for (x, y) in parsed if filter(x))\n        else:\n            filtered = ((x, y) for (x, y) in parsed if x is not None)\n\n        results = []\n\n        for x, y in filtered:\n            self.discard(key, y)\n            results.append(x)\n\n        return tuple(results)\n\n    def values(self, key=_UNDEFINED, parser=None, filter=None):\n        \"\"\"Return a tuple of event values (for a specific key, if\n        given).\n\n        >>> event = Event(key=[\"1\", \"2\"], other=[\"3\", \"4\"])\n        >>> sorted(event.values())\n        [u'1', u'2', u'3', u'4']\n        >>> sorted(event.values(\"key\"))\n        [u'1', u'2']\n\n        Perform parsing, validation and filtering by passing in\n        parsing and filtering functions (by default all None objects\n        are filtered when a parsing function has been given).\n\n        >>> import socket\n        >>> def ipv4(string):\n        ...     try:\n        ...         return socket.inet_ntoa(socket.inet_aton(string))\n        ...     except socket.error:\n        ...         return None\n        >>> event = Event(key=[\"1.2.3.4\", \"abba\"], other=\"10.10.10.10\")\n        >>> event.values(\"key\", parser=ipv4)\n        ('1.2.3.4',)\n        >>> sorted(event.values(parser=ipv4))\n        ['1.2.3.4', '10.10.10.10']\n        \"\"\"\n\n        return tuple(self._iter(key, parser, filter))\n\n    def value(self, key=_UNDEFINED, default=_UNDEFINED,\n              parser=None, filter=None):\n        \"\"\"Return one event value (for a specific key, if given).\n\n        The value can be picked either from the values of some\n        specific key or amongst event values.\n\n        >>> event = Event(key=\"1\", other=\"2\")\n        >>> event.value(\"key\")\n        u'1'\n        >>> event.value() in [u\"1\", u\"2\"]\n        True\n\n        A default return value can be defined in case no suitable\n        value is available:\n\n        >>> event = Event()\n        >>> event.value(\"key\", \"default value\")\n        'default value'\n        >>> event.value(default=\"default value\")\n        'default value'\n\n        KeyError is raised if no suitable values are available and no\n        default is given.\n\n        >>> event = Event()\n        >>> event.value()\n        Traceback (most recent call last):\n            ...\n        KeyError: 'no value available'\n        >>> event.value(\"somekey\")\n        Traceback (most recent call last):\n            ...\n        KeyError: 'somekey'\n\n        As with .values(...), parsing and filtering functions can be\n        given, and they will be used to modify the results.\n\n        >>> def int_parse(string):\n        ...     try:\n        ...         return int(string)\n        ...     except ValueError:\n        ...         return None\n        >>> event = Event(key=[\"1\", \"a\"])\n        >>> event.value(parser=int_parse)\n        1\n        >>> event.value(\"key\", parser=int_parse)\n        1\n        >>> event.value(\"other\", parser=int_parse)\n        Traceback (most recent call last):\n            ...\n        KeyError: 'other'\n        \"\"\"\n\n        for value in self._iter(key, parser, filter):\n            return value\n\n        if default is self._UNDEFINED:\n            if key is self._UNDEFINED:\n                raise KeyError(\"no value available\")\n            raise KeyError(key)\n        return default\n\n    def contains(self, key=_UNDEFINED, value=_UNDEFINED,\n                 parser=None, filter=None):\n        \"\"\"Return whether the event contains a key-value pair (for\n        specific key and/or value, if given).\n\n        >>> event = Event()\n        >>> event.contains() # Does the event contain any values at all?\n        False\n\n        >>> event = event.union(key=\"1\")\n        >>> event.contains()\n        True\n        >>> event.contains(\"key\") # Any value for key \"key\"?\n        True\n        >>> event.contains(value=\"1\") # Value \"1\" for any key?\n        True\n        >>> event.contains(\"key\", \"1\") # Value \"1\" for key \"key\"?\n        True\n        >>> event.contains(\"other\", \"2\") # Value \"2\" for key \"other\"?\n        False\n\n        Parsing and filtering functions can be given to modify the results.\n\n        >>> def int_parse(string):\n        ...     try:\n        ...         return int(string)\n        ...     except ValueError:\n        ...         return None\n        >>> event.contains(parser=int_parse) # Any int value for any key?\n        True\n        >>> event.contains(\"key\", parser=int_parse) # Any int value for \"key\"?\n        True\n        >>> event.contains(value=1, parser=int_parse) # Value 1 for any key?\n        True\n        >>> event = event.union(other=\"x\")\n        >>> event.contains(\"other\", parser=int_parse)\n        False\n        \"\"\"\n\n        if key is self._UNDEFINED:\n            values = set(self._unkeyed())\n        else:\n            key = _normalize(key)\n            values = self._attrs.get(key, ())\n\n        if parser is not None:\n            parsed = (parser(x) for x in values)\n\n            if filter is not None:\n                filtered = (x for x in parsed if filter(x))\n            else:\n                filtered = (x for x in parsed if x is not None)\n        elif filter is not None:\n            filtered = (x for x in values if filter(x))\n        else:\n            filtered = values\n\n        for filtered_value in filtered:\n            if value is self._UNDEFINED or value == filtered_value:\n                return True\n        return False\n\n    def items(self, parser=None, filter=None):\n        \"\"\"Return a tuple of key-value pairs contained by the event.\n\n        >>> event = Event()\n        >>> event.items()\n        ()\n        >>> event = event.union(key=\"1\", other=[\"x\", \"y\"])\n        >>> sorted(event.items())\n        [(u'key', u'1'), (u'other', u'x'), (u'other', u'y')]\n\n        Parsing and filtering functions can be given to modify the results.\n\n        >>> def int_parse(string):\n        ...     try:\n        ...         return int(string)\n        ...     except ValueError:\n        ...         return None\n        >>> event.items(parser=int_parse)\n        ((u'key', 1),)\n\n        The order of the key-value pairs is undefined.\n        \"\"\"\n\n        result = list()\n\n        for key, values in self._attrs.iteritems():\n            for value in values:\n                if parser is not None:\n                    value = parser(value)\n                if filter is not None and not filter(value):\n                    continue\n                if filter is None and value is None:\n                    continue\n                result.append((key, value))\n\n        return tuple(result)\n\n    def keys(self, parser=None, filter=None):\n        \"\"\"Return a tuple of keys with at least one value.\n\n        >>> event = Event()\n        >>> event.keys()\n        ()\n        >>> event = event.union(key=\"1\", other=[\"x\", \"y\"])\n        >>> sorted(event.keys())\n        [u'key', u'other']\n\n        Parsing and filtering functions can be given to modify the\n        results.\n\n        >>> def int_parse(string):\n        ...     try:\n        ...         return int(string)\n        ...     except ValueError:\n        ...         return None\n        >>> sorted(event.keys(parser=int_parse))\n        [u'key']\n        \"\"\"\n\n        return tuple(key for key in self._attrs\n                     if self.contains(key, parser=parser, filter=filter))\n\n    def to_elements(self, include_body=True):\n        element = Element(\"event\", xmlns=EVENT_NS)\n\n        for key, value in self.items():\n            key = _replace_non_xml_chars(key)\n            value = _replace_non_xml_chars(value)\n            attr = Element(\"attr\", key=key, value=value)\n            element.add(attr)\n\n        if not include_body:\n            return element\n\n        body = Element(\"body\")\n        body.text = _replace_non_xml_chars(unicode(self))\n        return Elements(body, element)\n\n    def __reduce__(self):\n        return self.__class__, (self._attrs,)\n\n    def __eq__(self, other):\n        if not isinstance(other, Event):\n            return NotImplemented\n        return other._attrs == self._attrs\n\n    def __ne__(self, other):\n        value = self.__eq__(other)\n        if value is NotImplemented:\n            return NotImplemented\n        return not value\n\n    def __unicode__(self):\n        \"\"\"Return an unicode representation of the event.\n\n        >>> unicode(Event())\n        u''\n        >>> unicode(Event({\"a,\": \"b\"}))\n        u'\"a,\"=b'\n\n        The specific order of the key-value pairs is undefined.\n        \"\"\"\n\n        return u\", \".join(_unicode_quote(key) + u\"=\" + _unicode_quote(value)\n                          for (key, value) in self.items())\n\n    def __repr__(self):\n        attrs = dict()\n        for key, value in self.items():\n            attrs.setdefault(key, list()).append(value)\n        return self.__class__.__name__ + \"(\" + repr(attrs) + \")\"\nabusehelper/core/rules/rules.py\nclass Or(And):\n    def match_with_cache(self, obj, cache):\n        for rule in self.subrules:\n            if rule.match(obj, cache):\n                return True\n        return False\nabusehelper/core/rules/rules.py\nclass And(Rule):\n    def init(self, first, *rest):\n        Rule.init(self)\n\n        self._rules = frozenset((first,) + rest)\n\n    def unique_key(self):\n        return self._rules\n\n    def __repr__(self):\n        return Rule.__repr__(self, *self._rules)\n\n    @property\n    def subrules(self):\n        return self._rules\n\n    def match_with_cache(self, obj, cache):\n        for rule in self.subrules:\n            if not rule.match(obj, cache):\n                return False\n        return True\n\n    def dump(self):\n        return self._rules\n\n    @classmethod\n    def load(cls, subrules):\n        return cls(*subrules)\nabusehelper/core/rules/rules.py\nclass Fuzzy(Rule):\n    @property\n    def atom(self):\n        return self._atom\n\n    def init(self, atom):\n        Rule.init(self)\n\n        self._atom = atom\n\n        if isinstance(atom, atoms.String):\n            self._matcher = atoms.RegExp.from_string(atom.value, ignore_case=True)\n        else:\n            self._matcher = atom\n\n    def unique_key(self):\n        return self._atom\n\n    def __repr__(self):\n        return Rule.__repr__(self, self._atom)\n\n    def match_with_cache(self, event, cache):\n        if any(self._matcher.match(x) for x in event.keys()):\n            return True\n        if event.contains(filter=self._matcher.match):\n            return True\n        return False\n\n    def dump(self):\n        return self._atom\n\n    @classmethod\n    def load(cls, dumped):\n        return cls(dumped)\nabusehelper/core/rules/atoms.py\nclass RegExp(Atom):\n    _forbidden_flags = [\n        (re.X, \"re.X / re.VERBOSE\"),\n        (re.M, \"re.M / re.MULTILINE\"),\n        (re.L, \"re.L / re.LOCALE\")\n    ]\n\n    @classmethod\n    def from_string(cls, string, ignore_case=False):\n        return cls(re.escape(string), ignore_case=ignore_case)\n\n    @classmethod\n    def from_re(cls, re_obj):\n        for flag, name in cls._forbidden_flags:\n            if re_obj.flags & flag == flag:\n                raise ValueError(\"forbidden regular expression flag \" + name)\n\n        ignore_case = (re_obj.flags & re.I) != 0\n        return cls(re_obj.pattern, ignore_case=ignore_case)\n\n    @property\n    def pattern(self):\n        return self._regexp.pattern\n\n    @property\n    def ignore_case(self):\n        return self._regexp.flags & re.IGNORECASE != 0\n\n    def init(self, pattern, ignore_case=False):\n        Atom.init(self)\n\n        flags = re.U | re.S | (re.I if ignore_case else 0)\n        try:\n            self._regexp = re.compile(pattern, flags)\n        except re.error as error:\n            raise ValueError(error)\n\n    def unique_key(self):\n        return self._regexp.pattern, bool(self._regexp.flags & re.I)\n\n    def __repr__(self):\n        pattern = self._regexp.pattern\n        if self._regexp.flags & re.IGNORECASE == re.I:\n            return Atom.__repr__(self, pattern, ignore_case=True)\n        return Atom.__repr__(self, pattern)\n\n    def match(self, value):\n        return self._regexp.search(value)\n\n    def dump(self):\n        return self._regexp.pattern, bool(self._regexp.flags & re.I)\n\n    @classmethod\n    def load(cls, (pattern, ignore_case)):\n        return cls(pattern, ignore_case)\nabusehelper/core/rules/rules.py\nclass Match(Rule):\n    _to_atom = [\n        (basestring, atoms.String),\n        (type(re.compile(\".\")), atoms.RegExp.from_re)\n    ]\n\n    _from_atom = [\n        (atoms.String, lambda x: x.value)\n    ]\n\n    def _convert(self, obj, conversions):\n        for converted_type, conversion_func in conversions:\n            if isinstance(obj, converted_type):\n                return conversion_func(obj)\n        return obj\n\n    def init(self, key=None, value=None):\n        Rule.init(self)\n\n        self._key = self._convert(key, self._to_atom)\n        self._value = self._convert(value, self._to_atom)\n\n    def unique_key(self):\n        return self._key, self._value\n\n    def __repr__(self):\n        key = self._convert(self._key, self._from_atom)\n        value = self._convert(self._value, self._from_atom)\n\n        if key is None and value is None:\n            return Rule.__repr__(self)\n        if key is None:\n            return Rule.__repr__(self, value=value)\n        if value is None:\n            return Rule.__repr__(self, key=key)\n        return Rule.__repr__(self, key, value)\n\n    @property\n    def key(self):\n        return self._key\n\n    @property\n    def value(self):\n        return self._value\n\n    def match_with_cache(self, event, cache):\n        if self._key is None:\n            return event.contains(filter=self.filter)\n        return event.contains(self._key.value, filter=self.filter)\n\n    def filter(self, value):\n        return self._value is None or self._value.match(value)\n\n    def dump(self):\n        return (self._key, self._value)\n\n    @classmethod\n    def load(cls, (key, value)):\n        return cls(key, value)\nabusehelper/core/rules/atoms.py\nclass IP(Atom):\n    @property\n    def range(self):\n        return self._range\n\n    def init(self, range, extra=None):\n        Atom.init(self)\n\n        if isinstance(range, iprange.IPRange):\n            if extra is not None:\n                raise TypeError(\"unexpected second argument\")\n        else:\n            range = iprange.IPRange.from_autodetected(range, extra)\n        self._range = range\n\n    def unique_key(self):\n        return self._range\n\n    def __repr__(self):\n        return Atom.__repr__(self, unicode(self._range))\n\n    def __unicode__(self):\n        return unicode(self._range)\n\n    def match(self, value):\n        try:\n            range = iprange.IPRange.from_autodetected(value)\n        except ValueError:\n            return False\n        return self._range.contains(range)\n\n    def dump(self):\n        return unicode(self._range)\n\n    @classmethod\n    def load(cls, value):\n        return cls(value)\nabusehelper/core/rules/atoms.py\nclass DomainName(Atom):\n    @property\n    def pattern(self):\n        return self._pattern\n\n    def init(self, pattern):\n        Atom.init(self)\n\n        if not isinstance(pattern, _domainname.Pattern):\n            pattern = _domainname.Pattern.from_string(pattern)\n        self._pattern = pattern\n\n    def unique_key(self):\n        return self._pattern\n\n    def __repr__(self):\n        return Atom.__repr__(self, unicode(self._pattern))\n\n    def __unicode__(self):\n        return unicode(self._pattern)\n\n    def match(self, value):\n        name = _domainname.parse_name(value)\n        if name is None:\n            return False\n        return self._pattern.contains(name)\n\n    def dump(self):\n        return unicode(self._pattern)\n\n    @classmethod\n    def load(cls, value):\n        return cls(value)\nabusehelper/core/rules/atoms.py\nclass String(Atom):\n    def init(self, value):\n        Atom.init(self)\n\n        self._value = unicode(value)\n\n    def unique_key(self):\n        return self._value\n\n    def __repr__(self):\n        return Atom.__repr__(self, self._value)\n\n    @property\n    def value(self):\n        return self._value\n\n    def match(self, value):\n        return self._value == value\n\n    def dump(self):\n        return self._value\n\n    @classmethod\n    def load(cls, value):\n        return cls(value)\n", "answers": ["        self.assertRaises(TypeError, Or)"], "length": 2542, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "664c7b340621fd4b844f523e3d2a36f5fd09e8424cc28edc"}
{"input": "package net.okjsp.community;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.validation.Valid;\nimport net.okjsp.common.model.PagingList;\nimport net.okjsp.community.model.Article;\nimport net.okjsp.community.model.Board;\nimport net.okjsp.community.model.Comment;\nimport net.okjsp.community.service.BoardService;\nimport net.okjsp.community.service.CommentService;\nimport net.okjsp.community.service.CommunityService;\nimport net.okjsp.common.model.Paging;\nimport net.okjsp.layout.BasicLayoutController;\nimport net.okjsp.user.model.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.access.annotation.Secured;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\n\n\n\n\n@Controller\n@RequestMapping(value = \"/community\")\npublic class CommunityController extends BasicLayoutController {\n\t\n\t@Autowired", "context": "src/main/java/net/okjsp/community/service/CommentService.java\npublic interface CommentService {\n\n    public List<Comment> getList(\n            int boardNo,\n            int writeNo,\n            String searchflg,\n            String search,\n            String sort,\n            Paging paging);\n\n    public List<Comment> getListForArticle(\n            int boardNo,\n            int writeNo);\n    \n    public int getTotalCount(\n            int boardNo,\n            int writeNo);\n\n    public Comment getOne(\n            int boardNo,\n            int writeNo,\n            int commentId);\n\n    public boolean create(Comment comment);\n    \n    public boolean modify(Comment comment);\n    \n    public boolean destroy(Comment comment);\n \n\n}\nsrc/main/java/net/okjsp/community/model/Article.java\npublic class Article {\n\n\t// 게시판 ID\n\tprivate int boardId;\n\t\n\t// 하위 카테고리명\n\tprivate int categoryId;\n\t\n\t// 사용여부\n\tprivate boolean enabled;\n\t\n\t// 공통 글번호\n\tprivate int writeNo;\n\t\n\t// 회원 아이디\n\tprivate int userId;\n\t\n\t// 제목\n    @NotBlank\n\tprivate String title;\n\t\n\t//익명글 체크\n\tprivate boolean anonymized;\n\t\n\t//익명글 닉네임\n\tprivate String anonymousNickname;\n\t\n\t// 내용\n\tprivate String content;\n\t\n\t// 조회수\n\tprivate int postingHit;\n\t\n\t// 작성일시\n\tprivate Date writeDate;\n\t\n\t// 업데이트 일시\n\tprivate Date updateDate;\n\t\n\t//작성자\n\tprivate User user;\n\n    private int commentCount;\n\n    private List<Comment> comments;\n\n    //TODO: 첨부파일\n\n\tpublic User getUser() {\n\t\treturn user;\n\t}\n\n\tpublic void setUser(User user) {\n\t\tthis.user = user;\n\t}\n\n\tpublic int getBoardId() {\n\t\treturn boardId;\n\t}\n\n\tpublic void setBoardId(int boardId) {\n\t\tthis.boardId = boardId;\n\t}\n\n\tpublic int getCategoryId() {\n\t\treturn categoryId;\n\t}\n\n\tpublic void setCategoryId(int categoryId) {\n\t\tthis.categoryId = categoryId;\n\t}\n\n\tpublic boolean getEnabled() {\n\t\treturn enabled;\n\t}\n\n\tpublic void setEnabled(boolean enabled) {\n\t\tthis.enabled = enabled;\n\t}\n\n\tpublic int getWriteNo() {\n\t\treturn writeNo;\n\t}\n\n\tpublic void setWriteNo(int writeNo) {\n\t\tthis.writeNo = writeNo;\n\t}\n\n\tpublic int getUserId() {\n\t\treturn userId;\n\t}\n\n\tpublic void setUserId(int userId) {\n\t\tthis.userId = userId;\n\t}\n\n\tpublic String getTitle() {\n\t\treturn title;\n\t}\n\n\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n\n\tpublic void setContent(String content) {\n\t\tthis.content = content;\n\t}\n\n\tpublic int getPostingHit() {\n\t\treturn postingHit;\n\t}\n\n\tpublic void setPostingHit(int postingHit) {\n\t\tthis.postingHit = postingHit;\n\t}\n\n\tpublic Date getWriteDate() {\n\t\treturn writeDate;\n\t}\n\n\tpublic void setWriteDate(Date writeDate) {\n\t\tthis.writeDate = writeDate;\n\t}\n\n\tpublic Date getUpdateDate() {\n\t\treturn updateDate;\n\t}\n\n\tpublic void setUpdateDate(Date updateDate) {\n\t\tthis.updateDate = updateDate;\n\t}\n\n\tpublic boolean getAnonymized() {\n\t\treturn anonymized;\n\t}\n\n\tpublic void setAnonymized(boolean anonymized) {\n\t\tthis.anonymized = anonymized;\n\t}\n\n\tpublic String getAnonymousNickname() {\n\t\treturn anonymousNickname;\n\t}\n\n\tpublic void setAnonymousNickname(String anonymousNickname) {\n\t\tthis.anonymousNickname = anonymousNickname;\n\t}\n\n\n    public int getCommentCount() {\n        return commentCount;\n    }\n\n    public void setCommentCount(int commentCount) {\n        this.commentCount = commentCount;\n    }\n\n    public String getNickname() {\n        if(getAnonymized()) {\n            return getAnonymousNickname();\n        } else {\n            User user = getUser();\n            if(user != null) {\n                return user.getNickName();\n            } else {\n                return \"\";\n            }\n        }\n    }\n\n    public String getProfileImg() {\n        if(!getAnonymized()) {\n            User user = getUser();\n            if(user != null) {\n                return user.getProfileImg();\n            }\n        }\n        return \"\";\n    }\n\n    public List<Comment> getComments() {\n        return comments;\n    }\n\n    public void setComments(List<Comment> comments) {\n        this.comments = comments;\n    }\n}\nsrc/main/java/net/okjsp/user/model/User.java\npublic class User implements UserDetails, CredentialsContainer {\n\n    private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;\n\n    private int userId;\n\n    @NotBlank @Email\n    private String email;\n\n//    @NotBlank @Pattern(regexp = \"^(?=.*\\\\d)(?=.*[A-Za-z]).{6,20}$\")\n    private String password;\n\n    private String passwordConfirm;\n\n    @NotBlank @Size(min = 2, max = 50)\n    private String name;\n\n    @NotBlank @Size(max = 50)\n    private String nickName;\n\n    @Pattern(regexp = \"^[\\\\d]{2,4}\\\\-[\\\\d]{2,4}\\\\-[\\\\d]{4}$\")\n    private String tel;\n\n    private String profileImg;\n\n    private String letterAgr;\n    private String grade;\n\n    @DateTimeFormat(style = \"MM\", pattern = \"yyyy-MM-dd\")\n    private Date joinDate;\n\n    @DateTimeFormat(style = \"MM\", pattern = \"yyyy-MM-dd\")\n    private Date updateDate;\n\n    @DateTimeFormat(style = \"MM\", pattern = \"yyyy-MM-dd\")\n    private Date delDate;\n\n    private Set<GrantedAuthority> authorities;\n    private boolean accountNonExpired = true;\n    private boolean accountNonLocked = true;\n    private boolean credentialsNonExpired = true;\n    private boolean enabled = true;\n\n    private static final String salt = \"!okjspPwSalt*\";\n\n    @JsonIgnore\n    public String getSalt() {\n        return salt;\n    }\n\n    public int getUserId() {\n        return userId;\n    }\n\n    public void setUserId(int userId) {\n        this.userId = userId;\n    }\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return authorities;\n    }\n\n    @Override\n    @JsonIgnore\n    public String getPassword() {\n        return password;\n    }\n\n    @Override\n    public String getUsername() {\n        return email;\n    }\n\n    @Override\n    @JsonIgnore\n    public boolean isAccountNonExpired() {\n        return accountNonExpired;\n    }\n\n    @Override\n    @JsonIgnore\n    public boolean isAccountNonLocked() {\n        return accountNonLocked;\n    }\n\n    @Override\n    @JsonIgnore\n    public boolean isCredentialsNonExpired() {\n        return credentialsNonExpired;\n    }\n\n    @Override\n    @JsonIgnore\n    public boolean isEnabled() {\n        return accountNonExpired;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    @JsonIgnore\n    public String getPasswordConfirm() {\n        return passwordConfirm;\n    }\n\n    public void setPasswordConfirm(String passwordConfirm) {\n        this.passwordConfirm = passwordConfirm;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getNickName() {\n        return nickName;\n    }\n\n    public void setNickName(String nickName) {\n        this.nickName = nickName;\n    }\n\n    public String getTel() {\n        return tel;\n    }\n\n    public void setTel(String tel) {\n        this.tel = tel;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getProfileImg() {\n        return profileImg;\n    }\n\n    public void setProfileImg(String profileImg) {\n        this.profileImg = profileImg;\n    }\n\n    public String getLetterAgr() {\n        return letterAgr;\n    }\n\n    public void setLetterAgr(String letterAgr) {\n        this.letterAgr = letterAgr;\n    }\n\n    public String getGrade() {\n        return grade;\n    }\n\n    public void setGrade(String grade) {\n        this.grade = grade;\n    }\n\n    public Date getJoinDate() {\n        return joinDate;\n    }\n\n    public void setJoinDate(Date joinDate) {\n        this.joinDate = joinDate;\n    }\n\n    public Date getUpdateDate() {\n        return updateDate;\n    }\n\n    public void setUpdateDate(Date updateDate) {\n        this.updateDate = updateDate;\n    }\n\n    public Date getDelDate() {\n        return delDate;\n    }\n\n    public void setDelDate(Date delDate) {\n        this.delDate = delDate;\n    }\n\n    public void setAuthorities(Collection<? extends GrantedAuthority> authorities) {\n        this.authorities = Collections.unmodifiableSet(sortAuthorities(authorities));;\n    }\n\n    public void setAuthorities(Set<GrantedAuthority> authorities) {\n        this.authorities = Collections.unmodifiableSet(sortAuthorities(authorities));;\n    }\n\n    public void eraseCredentials() {\n        password = null;\n    }\n\n    private static SortedSet<GrantedAuthority> sortAuthorities(Collection<? extends GrantedAuthority> authorities) {\n        Assert.notNull(authorities, \"Cannot pass a null GrantedAuthority collection\");\n        // Ensure array iteration order is predictable (as per UserDetails.getAuthorities() contract and SEC-717)\n        SortedSet<GrantedAuthority> sortedAuthorities =\n                new TreeSet<GrantedAuthority>(new AuthorityComparator());\n\n        for (GrantedAuthority grantedAuthority : authorities) {\n            Assert.notNull(grantedAuthority, \"GrantedAuthority list cannot contain any null elements\");\n            sortedAuthorities.add(grantedAuthority);\n        }\n\n        return sortedAuthorities;\n    }\n\n    private static class AuthorityComparator implements Comparator<GrantedAuthority>, Serializable {\n        private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;\n\n        public int compare(GrantedAuthority g1, GrantedAuthority g2) {\n            // Neither should ever be null as each entry is checked before adding it to the set.\n            // If the authority is null, it is a custom authority and should precede others.\n            if (g2.getAuthority() == null) {\n                return -1;\n            }\n\n            if (g1.getAuthority() == null) {\n                return 1;\n            }\n\n            return g1.getAuthority().compareTo(g2.getAuthority());\n        }\n    }\n\n    /**\n     * Returns {@code true} if the supplied object is a {@code User} instance with the\n     * same {@code username} value.\n     * <p>\n     * In other words, the objects are equal if they have the same username, representing the\n     * same principal.\n     */\n    @Override\n    public boolean equals(Object rhs) {\n        if (rhs instanceof User) {\n            return email.equals(((User) rhs).email);\n        }\n        return false;\n    }\n\n    /**\n     * Returns the hashcode of the {@code username}.\n     */\n    @Override\n    public int hashCode() {\n        return email.hashCode();\n    }\n}\nsrc/main/java/net/okjsp/community/model/Board.java\npublic class Board implements Serializable {\n\n    private static final long serialVersionUID = -3404588398820203356L;\n\n    // 게시판ID\n\tprivate int boardId;\n\t\n\t// 게시판명\n\tprivate String boardName;\n\t\n\t// 하위 카테고리 ID\n\tprivate int categoryId;\n\t\n\t// 하위 카테고리 명\n\tprivate String categoryName;\n\t\n\t// 답변기능 사용여부\n\tprivate String replayCheck;\n\t\n\t// 추천기능 사용여부\n\tprivate String recommendCheck;\n\t\n\t// 싸움방지기능 사용여부\n\tprivate String brawlCheck;\n\t\n\t// 댓글기능 사용여부\n\tprivate String commentCheck;\n\t\n\t// 작성일시\n\tprivate String writeDate;\n\t\n\t// 업데이트일시\n\tprivate String updateDate;\n\n\tpublic int getBoardId() {\n\t\treturn boardId;\n\t}\n\n\tpublic void setBoardId(int boardId) {\n\t\tthis.boardId = boardId;\n\t}\n\n\tpublic String getBoardName() {\n\t\treturn boardName;\n\t}\n\n\tpublic void setBoardName(String boardName) {\n\t\tthis.boardName = boardName;\n\t}\n\n\tpublic int getCategoryId() {\n\t\treturn categoryId;\n\t}\n\n\tpublic void setCategoryId(int categoryId) {\n\t\tthis.categoryId = categoryId;\n\t}\n\n\tpublic String getCategoryName() {\n\t\treturn categoryName;\n\t}\n\n\tpublic void setCategoryName(String categoryName) {\n\t\tthis.categoryName = categoryName;\n\t}\n\n\tpublic String getReplayCheck() {\n\t\treturn replayCheck;\n\t}\n\n\tpublic void setReplayCheck(String replayCheck) {\n\t\tthis.replayCheck = replayCheck;\n\t}\n\n\tpublic String getRecommendCheck() {\n\t\treturn recommendCheck;\n\t}\n\n\tpublic void setRecommendCheck(String recommendCheck) {\n\t\tthis.recommendCheck = recommendCheck;\n\t}\n\n\tpublic String getBrawlCheck() {\n\t\treturn brawlCheck;\n\t}\n\n\tpublic void setBrawlCheck(String brawlCheck) {\n\t\tthis.brawlCheck = brawlCheck;\n\t}\n\n\tpublic String getCommentCheck() {\n\t\treturn commentCheck;\n\t}\n\n\tpublic void setCommentCheck(String commentCheck) {\n\t\tthis.commentCheck = commentCheck;\n\t}\n\n\tpublic String getWriteDate() {\n\t\treturn writeDate;\n\t}\n\n\tpublic void setWriteDate(String writeDate) {\n\t\tthis.writeDate = writeDate;\n\t}\n\n\tpublic String getUpdateDate() {\n\t\treturn updateDate;\n\t}\n\n\tpublic void setUpdateDate(String updateDate) {\n\t\tthis.updateDate = updateDate;\n\t}\n}\nsrc/main/java/net/okjsp/common/model/Paging.java\npublic class Paging {\n    int page = 1;\n    int sizePerList = 20;\n    int offset;\n    int listCount = 0;\n    int totalCount = 0;\n    Map<String, Object> params;\n\n    public int getPage() {\n        return page;\n    }\n\n    public void setPage(int page) {\n        this.page = page;\n    }\n\n    public int getSizePerList() {\n        return sizePerList;\n    }\n\n    public void setSizePerList(int sizePerList) {\n        this.sizePerList = sizePerList;\n    }\n\n    public int getOffset() {\n\n        offset = (page-1) * sizePerList;\n\n        return offset;\n    }\n\n    public int getTotalCount() {\n        return totalCount;\n    }\n\n    public void setTotalCount(int totalCount) {\n        this.totalCount = totalCount;\n    }\n\n    public int getListCount() {\n        return listCount;\n    }\n\n    public void setListCount(int listCount) {\n        this.listCount = listCount;\n    }\n\n    public int getLastIndex() {\n        if(totalCount == 0) {\n            return 0;\n        }\n\n        int lastIndex = listCount+getOffset();\n\n        return lastIndex;\n    }\n\n    public Map<String, Object> getParams() {\n        return params;\n    }\n\n    public void setParams(Map<String, Object> params) {\n        this.params = params;\n    }\n}\nsrc/main/java/net/okjsp/common/model/PagingList.java\npublic class PagingList {\n    private Paging paging;\n    private List<?> list;\n\n    public PagingList(Paging paging, List<?> list) {\n        this.list = list;\n        this.paging = paging;\n    }\n\n    public Paging getPaging() {\n        return paging;\n    }\n\n    public void setPaging(Paging paging) {\n        this.paging = paging;\n    }\n\n    public List<?> getList() {\n        return list;\n    }\n\n    public void setList(List<?> list) {\n        this.list = list;\n    }\n}\nsrc/main/java/net/okjsp/community/service/CommunityService.java\npublic interface CommunityService {\n\n\tpublic List<Article> getArticles(int boardId, int categoryId,\n                                     Paging paging);\n\t\n\tpublic Article getArticle(int writeNo);\n\n    public int getUserIdFromArticle(int writeNo);\n\n\tpublic int getTotalCount(int boardId, int categoryId);\n\n\tpublic boolean addArticleHit(int writeNo);\n\t\n\tpublic boolean create(Article article);\n\n    public boolean modify(Article article);\n\n    public boolean delete(int writeNo);\n}\nsrc/main/java/net/okjsp/community/model/Comment.java\npublic class Comment {\n\t//게시판 번호\n\tprivate int boardId;\n\t//글 번호\n\tprivate int writeNo;\n\t//코멘트 번호\n\tprivate int commentId;\n\t//본문\n\tprivate String content;\n    //작성자 id\n    private int userId;\n\t//올린 시간\n\tprivate Date writeDate;\n\t//수정 시간\n\tprivate Date updateDate;\n    //작성자\n    private User user;\n\n\t\n\tpublic int getBoardId() {\n\t\treturn boardId;\n\t}\n\tpublic void setBoardId(int boardId) {\n\t\tthis.boardId = boardId;\n\t}\n\tpublic int getWriteNo() {\n\t\treturn writeNo;\n\t}\n\tpublic void setWriteNo(int writeNo) {\n\t\tthis.writeNo = writeNo;\n\t}\n\tpublic int getCommentId() {\n\t\treturn commentId;\n\t}\n\tpublic void setCommentId(int commentId) {\n\t\tthis.commentId = commentId;\n\t}\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n\tpublic void setContent(String content) {\n\t\tthis.content = content;\n\t}\n\tpublic Date getWriteDate() {\n\t\treturn writeDate;\n\t}\n\tpublic void setWriteDate(Date writeDate) {\n\t\tthis.writeDate = writeDate;\n\t}\n\tpublic Date getUpdateDate() {\n\t\treturn updateDate;\n\t}\n\tpublic void setUpdateDate(Date updateDate) {\n\t\tthis.updateDate = updateDate;\n\t}\n    public int getUserId() {\n        return userId;\n    }\n    public void setUserId(int userId) {\n        this.userId = userId;\n    }\n    public User getUser() {\n        return user;\n    }\n    public void setUser(User user) {\n        this.user = user;\n    }\n}\nsrc/main/java/net/okjsp/layout/BasicLayoutController.java\n@Controller\npublic class BasicLayoutController {\n\n    Logger logger = Logger.getLogger(this.getClass());\n\n    @Autowired\n    LayoutService layoutService;\n\n    @ModelAttribute(\"NAV_LIST\")\n    public List<Navigation> nav() {\n\n        return layoutService.getNav();\n    }\n}\nsrc/main/java/net/okjsp/community/service/BoardService.java\npublic interface BoardService {\n    public List<Board> getBoardList();\n    public List<Board> getBoardListById(int boardId);\n}\n", "answers": ["    CommunityService communityService;"], "length": 1818, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "fd5b1517bbe1ff9079ed0366be6020dc5a362128d7633468"}
{"input": "from django.contrib import messages\nfrom django.contrib.auth import authenticate, get_user_model, login, logout\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.hashers import make_password\nfrom django.contrib.sites.shortcuts import get_current_site\nfrom django.core.urlresolvers import reverse\nfrom django.forms.formsets import formset_factory\nfrom django.shortcuts import get_object_or_404, redirect, render\nfrom django.utils.timezone import now\nfrom django.utils.translation import ugettext as _\nfrom connect.utils import send_connect_email\nfrom connect.accounts.forms import (\n    ActivateAccountForm, BaseLinkFormSet, BaseSkillFormSet, CloseAccountForm,\n    LinkForm, ProfileForm, RequestInvitationForm, SkillForm, UpdateEmailForm,\n    UpdatePasswordForm\n)\nfrom connect.accounts.models import Role, Skill, UserLink, UserSkill\nfrom connect.accounts.utils import create_inactive_user\nfrom connect.accounts.view_utils import (\n    match_link_to_brand, save_links, save_skills\n)\n\n\n\n\n\nUser = get_user_model()\n\n\ndef request_invitation(request):\n    \"\"\"\n    Allow a member of the public to request an account invitation.\n    \"\"\"\n    site = get_current_site(request)\n\n    if request.method == 'POST':\n        form = RequestInvitationForm(request.POST, request=request)\n\n        if form.is_valid():\n\n            # Create inactive user\n            full_name = form.cleaned_data['full_name']\n            email = form.cleaned_data['email']\n", "context": "connect/accounts/forms.py\nclass UpdatePasswordForm(forms.Form):\n    \"\"\"\n    Form for user to update their password\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.user = kwargs.pop('user', None)\n        super(UpdatePasswordForm, self).__init__(*args, **kwargs)\n\n        self.fields['new_password'] = forms.CharField(\n            widget=forms.PasswordInput(attrs={\n                'placeholder': _('New Password')\n            }),\n            error_messages={\n                'required': _('Please enter your new password.')\n            })\n\n        self.fields['current_password'] = forms.CharField(\n            widget=forms.PasswordInput(attrs={\n                'placeholder': _('Current Password')\n            }),\n            error_messages={\n                'required': _('Please enter your current password.')\n            })\n\n    def clean_current_password(self):\n        current_password = self.cleaned_data['current_password']\n\n        if not self.user.check_password(current_password):\n            raise forms.ValidationError(\n                _('Incorrect password. Please try again.'),\n                code='incorrect_pass'\n            )\n        else:\n            pass\nconnect/accounts/models.py\nclass UserLink(models.Model):\n    \"\"\"\n    Link attached to a user's profile, e.g. github account,\n    twitter account, etc.\n    \"\"\"\n    user = models.ForeignKey(settings.AUTH_USER_MODEL,\n                             verbose_name=_('user'),\n                             related_name='links')\n    anchor = models.CharField(_('anchor text'), max_length=100)\n    url = models.URLField(_('url'))\n    icon = models.ForeignKey('LinkBrand', blank=True, null=True,\n                             on_delete=models.SET_NULL,\n                             verbose_name=_('icon'))\n\n    def get_icon(self):\n        \"\"\"\n        If there is no icon matched - use default.\n        \"\"\"\n        try:\n            icon = self.icon.fa_icon\n        except AttributeError:\n            icon = 'fa-globe'\n\n        return icon\n\n    class Meta:\n        verbose_name = _('link')\n        verbose_name_plural = _('links')\n        unique_together = (('user', 'anchor'), ('user', 'url'))\n\n    def __str__(self):\n        return self.anchor\n\n    def save(self, *args, **kwargs):\n        \"\"\"\n        Attempt to match a user link to a recognised brand (LinkBrand).\n        \"\"\"\n        domain = urlsplit(self.url).netloc\n\n        try:\n            self.icon = LinkBrand.objects.get(domain=domain)\n        except ObjectDoesNotExist:\n            pass\n\n        super(UserLink, self).save(*args, **kwargs)\nconnect/accounts/models.py\nclass UserSkill(models.Model):\n    \"\"\"\n    How proficient an individual user is at a particular skill.\n    This model joins User and Skill ('through' table).\n    \"\"\"\n    BEGINNER = 10\n    INTERMEDIATE = 20\n    ADVANCED = 30\n    EXPERT = 40\n\n    PROFICIENCY_CHOICES = (\n        ('', '---------'),\n        (BEGINNER, _('Beginner')),\n        (INTERMEDIATE, _('Intermediate')),\n        (ADVANCED, _('Advanced')),\n        (EXPERT, _('Expert')),\n    )\n\n    user = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name=_(\"user\"))\n    skill = models.ForeignKey(Skill, verbose_name=_('skill'))\n    proficiency = models.IntegerField(_('proficiency'),\n                                      choices=PROFICIENCY_CHOICES,\n                                      default=BEGINNER)\n\n    def get_proficiency_percentage(self):\n        \"\"\"\n        Return a user's profiency in a particular skill as a percentage,\n        based on the position of the proficiency in PROFICIENCY_CHOICES.\n        \"\"\"\n        choice_values = [choice[0] for choice in self.PROFICIENCY_CHOICES]\n        if '' in choice_values:\n            choice_values.remove('')  # Remove the empty proficiency choice\n        choice_values.sort()  # Ensure values are in the correct order\n\n        value = choice_values.index(self.proficiency) + 1\n        factor = 100 / len(choice_values)\n        percentage = round(value * factor)\n\n        return percentage\n\n    class Meta:\n        verbose_name = _('user skill')\n        verbose_name_plural = _('user skills')\n        unique_together = ('user', 'skill')\n\n    def __str__(self):\n        return '{} - {}'.format(self.user.get_full_name(), self.skill.name)\nconnect/accounts/forms.py\nclass RequestInvitationForm(forms.Form):\n    \"\"\"\n    Form for member of the public to request an invitation.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.request = kwargs.pop('request', None)\n        super(RequestInvitationForm, self).__init__(*args, **kwargs)\n\n    full_name = forms.CharField(\n        max_length=30,\n        error_messages={'required': _('Please enter your full name.')}\n    )\n\n    email = forms.EmailField(\n        error_messages={\n            'required': _('Please enter your email address.'),\n            'invalid': _('Please enter a valid email address.')\n        })\n\n    comments = forms.CharField(\n        widget=forms.Textarea(attrs={'placeholder': _('Please explain why you '\n                                                      'would like to join '\n                                                      'this site')}),\n        error_messages={\n            'required': _('Please describe why you would like '\n                          'to create an account.')\n        }\n    )\n\n    def clean_email(self):\n        \"\"\"\n        Check whether the email is in the system.  If it is registered\n        to a closed account, send the user a reactivation link.\n        \"\"\"\n        email = self.cleaned_data['email']\n\n        user = get_user(email)\n        if user:\n            if user.is_closed:\n                invite_user_to_reactivate_account(user, request=self.request)\n                raise forms.ValidationError(\n                    _('This email address is already registered to another '\n                      '(closed) account. To reactivate this account, '\n                      'please check your email inbox. To register a new '\n                      'account, please use a different email address.'),\n\n                    code='email_registered_to_closed_account'\n                )\n\n            else:\n                raise forms.ValidationError(\n                    _('Sorry, this email address is already '\n                        'registered to another user.'),\n\n                    code='email_already_registered'\n                )\n\n        return email\nconnect/accounts/forms.py\nclass UpdateEmailForm(forms.Form):\n    \"\"\"\n    Form for user to update their password.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.user = kwargs.pop('user', None)\n        super(UpdateEmailForm, self).__init__(*args, **kwargs)\n\n        self.fields['email'] = forms.EmailField(\n            initial=self.user.email,\n            widget=forms.EmailInput(attrs={\n                'placeholder': _('Email')\n            }),\n            error_messages={\n                'required': _('Please enter your new email address.'),\n                'invalid': _('Please enter a valid email address.')\n            })\n\n        self.fields['password'] = forms.CharField(\n            widget=forms.PasswordInput(attrs={\n                'placeholder': _('Password')\n            }),\n            error_messages={\n                'required': _('Please enter your password.'),\n            })\n\n    def clean_email(self):\n        email = self.cleaned_data['email']\n\n        if email != self.user.email:\n            validate_email_availability(email)\n\n        return email\n\n    def clean_password(self):\n        password = self.cleaned_data['password']\n\n        if not self.user.check_password(password):\n            raise forms.ValidationError(\n                _('Incorrect password. Please try again.'),\n                code='incorrect_pass'\n            )\n        else:\n            pass\nconnect/accounts/models.py\nclass Role(models.Model):\n    \"\"\"\n    Roles that users can take when connecting with others.\n    e.g. Mentor, Mentee, Coding Partner, etc.\n    \"\"\"\n    name = models.CharField(_('name'), max_length=100)\n    description = models.TextField(_('description'), blank=True)\n\n    class Meta:\n        verbose_name = _('role')\n        verbose_name_plural = _('roles')\n\n    def __str__(self):\n        return self.name\nconnect/accounts/forms.py\nclass BaseSkillFormSet(BaseFormSet):\n    def clean(self):\n        \"\"\"\n        Adds validation to check that no skill is listed twice\n        and that all skills have both a name and proficiency.\n        \"\"\"\n        if any(self.errors):\n            return\n\n        skills = []\n\n        for form in self.forms:\n            if form.cleaned_data:\n                skill = form.cleaned_data['skill']\n                proficiency = form.cleaned_data['proficiency']\n\n                # Check that no two skills are the same\n                if skill and proficiency:\n                    if skill in skills:\n                        raise forms.ValidationError(\n                            _('Each skill can only be entered once.'),\n                            code='duplicate_skill'\n                        )\n\n                    skills.append(skill)\n\n                # Check that all skills have both a name and proficiency\n                if skill and not proficiency:\n\n                    raise forms.ValidationError(\n                        _('All skills must have a proficiency.'),\n                        code='missing_proficiency'\n                    )\n\n                elif proficiency and not skill:\n                    raise forms.ValidationError(\n                        _('All skills must have a skill name.'),\n                        code='missing_skill_name'\n                    )\nconnect/accounts/forms.py\nclass CloseAccountForm(forms.Form):\n    \"\"\"\n    Form for user to close their account\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.user = kwargs.pop('user', None)\n        super(CloseAccountForm, self).__init__(*args, **kwargs)\n\n        self.fields['password'] = forms.CharField(\n            widget=forms.PasswordInput(attrs={\n                'placeholder': _('Password')\n            }),\n            error_messages={\n                'required': _('Please enter your password.')\n            })\n\n    def clean_password(self):\n        \"\"\"\n        Adds validation to:\n        - Ensure current password matches the user's password.\n        \"\"\"\n        password = self.cleaned_data.get('password')\n\n        if not self.user.check_password(password):\n            raise forms.ValidationError(\n                _('Incorrect password. Please try again.'),\n                code='incorrect_pass'\n            )\n        else:\n            pass\nconnect/accounts/forms.py\nclass ActivateAccountForm(forms.Form):\n    \"\"\"\n    Form for a user to activate their account\n    (after clicking on invitation link)\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.user = kwargs.pop('user', None)\n        super(ActivateAccountForm, self).__init__(*args, **kwargs)\n\n        self.fields['full_name'] = forms.CharField(\n            initial=self.user.full_name,\n            error_messages={\n                'required': _('Please enter your full name.')\n            })\n\n    password = forms.CharField(\n        widget=forms.PasswordInput,\n        error_messages={\n            'required': _('Please select a password.')\n        })\n\n    confirm_password = forms.CharField(\n        widget=forms.PasswordInput,\n        error_messages={\n            'required': _('Please confirm your password.')\n        })\n\n    def clean(self):\n        \"\"\"\n        Adds validation to:\n        - Ensure password and reset confirm password are the same.\n        \"\"\"\n        cleaned_data = super(ActivateAccountForm, self).clean()\n\n        password1 = cleaned_data.get('password')\n        password2 = cleaned_data.get('confirm_password')\n\n        if password1 != password2:\n            raise forms.ValidationError(_('Your passwords do not match. '\n                                          'Please try again.'),\n                                        code='unmatched_passwords')\n\n        return cleaned_data\nconnect/accounts/forms.py\nclass LinkForm(forms.Form):\n    \"\"\"\n    Form for individual user links\n\n    \"\"\"\n    anchor = forms.CharField(max_length=100,\n                             widget=forms.TextInput(attrs={\n                                 'placeholder': _('Link Name / Anchor Text'),\n                             }),\n                             required=False)\n\n    url = forms.URLField(\n        widget=forms.URLInput(attrs={'placeholder': _('URL')}),\n        error_messages={'invalid': _('Please enter a valid URL.')},\n        required=False)\nconnect/accounts/utils.py\ndef create_inactive_user(email, full_name):\n    \"\"\"\n    Create inactive user with basic details.\n    Used when moderators invite new users and when a member of the public\n    requests an account.\n    \"\"\"\n    User = get_user_model()\n\n    user = User.objects.create_user(email)\n    user.is_active = False\n    user.full_name = full_name\n    user.set_unusable_password()\n\n    return user\nconnect/accounts/view_utils.py\ndef save_links(request, user, formset):\n    \"\"\"Wrapper function to save paired link anchors and URLs.\"\"\"\n    save_paired_items(request, user, formset, UserLink, 'anchor', 'url')\nconnect/utils.py\ndef send_connect_email(subject, template, recipient, site, sender='',\n                       url='', comments='', logged_against=''):\n    \"\"\"\n    Sends an email to notify users and moderators of relevant events.\n    Generates a plain text email from html template counterpart.\n    \"\"\"\n\n    email_header_url = site.config.email_header.url\n    email_header = ''.join(['http://', site.domain, email_header_url])\n\n    template_vars = {\n        'recipient': recipient,\n        'site_name': site.name,\n        'url': url,\n        'sender': sender,\n        'comments': comments,\n        'logged_against': logged_against,\n        'contact_email':  site.config.email,\n        'email_header': email_header,\n        # TODO: dynamically retrieve color from CSS\n        'link_color': 'e51e41'\n    }\n\n    # Render HTML email:\n    html_body = render_to_string(template, template_vars)\n\n    # Render plain text email:\n    text_body = html_body\n\n    # Strip out HTML head section:\n    p = re.compile('<head>(.|\\s)*?</head>')\n    text_body = p.sub('', text_body)\n    # Strip out excessive whitespace:\n    text_body = strip_tags(text_body).strip()\n    p = re.compile('(\\r|\\n)(\\x20|\\t)+')\n    text_body = p.sub('\\n', text_body)\n    p = re.compile('(\\r|\\n)(\\r|\\n)+')\n    text_body = p.sub('\\n\\n', text_body)\n\n    email = send_mail(subject=subject,\n                      message=text_body,\n                      from_email=site.config.email,\n                      recipient_list=[recipient.email],\n                      html_message=html_body)\n\n    return email\nconnect/accounts/forms.py\nclass SkillForm(forms.Form):\n    \"\"\"\n    Form for individual user skills\n    \"\"\"\n    skills = Skill.objects.all()\n    skill = forms.ModelChoiceField(queryset=skills, required=False)\n\n    proficiency = forms.ChoiceField(choices=UserSkill.PROFICIENCY_CHOICES,\n                                    required=False)\nconnect/accounts/view_utils.py\ndef match_link_to_brand(user_links):\n    \"\"\"\n    Attempt to match a user's links to recognised brands (LinkBrand).\n    This functionality also exists as a custom save() method on the model.\n    -- Use this with functions that create and update in bulk.\n    \"\"\"\n    for link in user_links:\n        domain = urlsplit(link.url).netloc\n\n        try:\n            brand = LinkBrand.objects.get(domain=domain)\n            link.icon = brand\n            link.save()\n\n        except ObjectDoesNotExist:\n            pass\n\n    return user_links\nconnect/accounts/forms.py\nclass BaseLinkFormSet(BaseFormSet):\n    def clean(self):\n        \"\"\"\n        Adds validation to check that no two links have the same anchor or URL\n        and that all links have both an anchor and URL.\n        \"\"\"\n        if any(self.errors):\n            return\n\n        anchors = []\n        urls = []\n        duplicates = False\n\n        for form in self.forms:\n            if form.cleaned_data:\n                anchor = form.cleaned_data['anchor']\n                url = form.cleaned_data['url']\n\n                # Check that no two links have the same anchor or URL\n                if anchor and url:\n                    if anchor in anchors:\n                        duplicates = True\n                    anchors.append(anchor)\n\n                    if url in urls:\n                        duplicates = True\n                    urls.append(url)\n\n                if duplicates:\n                    raise forms.ValidationError(\n                        _('Links must have unique anchors and URLs.'),\n                        code='duplicate_links'\n                    )\n\n                # Check that all links have both an anchor and URL\n                if url and not anchor:\n                    raise forms.ValidationError(\n                        _('All links must have an anchor.'),\n                        code='missing_anchor'\n                    )\n                elif anchor and not url:\n                    raise forms.ValidationError(\n                        _('All links must have a URL.'),\n                        code='missing_URL'\n                    )\nconnect/accounts/view_utils.py\ndef save_skills(request, user, formset):\n    \"\"\"Wrapper function to save paired skills and proficiencies.\"\"\"\n    save_paired_items(request, user, formset, UserSkill, 'skill',\n                      'proficiency')\nconnect/accounts/forms.py\nclass ProfileForm(forms.Form):\n    \"\"\"\n    Form for user to update their own profile details\n    (excluding skills and links which are handled by separate formsets)\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.user = kwargs.pop('user', None)\n        super(ProfileForm, self).__init__(*args, **kwargs)\n\n        self.fields['full_name'] = forms.CharField(\n            max_length=30,\n            initial=self.user.full_name,\n            widget=forms.TextInput(attrs={\n                'placeholder': _('Name'),\n            }),\n            error_messages={\n                'required': _('Please enter your full name.')\n            })\n\n        self.fields['bio'] = forms.CharField(\n            initial=self.user.bio,\n            widget=forms.Textarea(attrs={\n                'class': 'bio',\n                'placeholder': _('Add some details about yourself...'),\n                'rows': 'auto',\n            }),\n            required=False)\n\n        roles = Role.objects.all()\n        self.fields['roles'] = RoleModelMultipleChoiceField(\n            initial=self.user.roles.all(),\n            queryset=roles,\n            widget=forms.CheckboxSelectMultiple(),\n            required=False)\nconnect/accounts/models.py\nclass Skill(models.Model):\n    \"\"\"\n    Represents a skill in the community.\n    \"\"\"\n    name = models.CharField(_('name'), max_length=100, unique=True)\n    owner = models.ManyToManyField(settings.AUTH_USER_MODEL,\n                                   through='UserSkill',\n                                   verbose_name=_('owner'))\n\n    class Meta:\n        verbose_name = _('skill')\n        verbose_name_plural = _('skills')\n\n    def __str__(self):\n        return self.name\n", "answers": ["            new_user = create_inactive_user(email, full_name)"], "length": 1644, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "68f47d51d86f9370e438fdc919e3bc0e02e8d82aa51fd37e"}
{"input": "from datetime import datetime\nfrom django.test import TestCase\nfrom django.utils import timezone\nfrom freezegun import freeze_time\nfrom mock import patch\nfrom modules.utils import quote, phone_number_is_valid, remove_nondigit_characters, \\\n                                add_country_code_to_phone_number, prepare_phone_number, \\\n                                keywords_without_word, is_not_ascii\nfrom modules.date_helper import date_string_to_date, date_is_valid, \\\n                                date_to_date_string, date_string_dmy_to_date, \\\n                                date_string_mdy_to_date, date_string_ymd_to_date, \\\n                                try_parsing_partner_date, try_parsing_gen_date, \\\n                                datetime_string_mdy_to_datetime, datetime_string_ymd_to_datetime\nfrom modules.i18n import hindi_information, hindi_remind, hindi_born, \\\n                            subscribe_keywords, six_week_reminder_seven_days, \\\n                            six_week_reminder_one_day, ten_week_reminder_seven_days, \\\n                            ten_week_reminder_one_day, fourteen_week_reminder_seven_days, \\\n                            fourteen_week_reminder_one_day, nine_month_reminder_seven_days, \\\n                            nine_month_reminder_one_day, sixteen_month_reminder_seven_days, \\\n                            sixteen_month_reminder_one_day, five_year_reminder_seven_days, \\\n                            five_year_reminder_one_day, verify_pregnant_signup_birthdate, \\\n                            msg_subscribe, msg_unsubscribe, msg_already_sub, msg_failure, \\\n                            msg_failed_date\nfrom six import u\n        no_join_list = keywords_without_word(language=\"English\", word=\"join\")\n        list_comp_minus_join = [key for key in subscribe_keywords(\"English\") if key not in [\"join\"]]\n        self.assertEqual(list_comp_minus_join, no_join_list)\n        no_remind_list = keywords_without_word(language=\"English\", word=\"remind\")\n        list_comp_minus_remind = [key for key in subscribe_keywords(\"English\") if key not in [\"remind\"]]\n        self.assertEqual(list_comp_minus_remind, no_remind_list)\n        no_born_list = keywords_without_word(language=\"English\", word=\"born\")\n        list_comp_minus_born = [key for key in subscribe_keywords(\"English\") if key not in [\"born\"]]\n        self.assertEqual(list_comp_minus_born, no_born_list)\n\n    def test_removes_hindi_words(self):\n        no_info_list = keywords_without_word(language=\"Hindi\", word=hindi_information())\n        list_comp_minus_info = [key for key in subscribe_keywords(\"Hindi\") if key not in [hindi_information()]]\n        self.assertEqual(list_comp_minus_info, no_info_list)\n        no_remind_list = keywords_without_word(language=\"Hindi\", word=hindi_remind())\n        list_comp_minus_remind = [key for key in subscribe_keywords(\"Hindi\") if key not in [hindi_remind()]]\n        self.assertEqual(list_comp_minus_remind, no_remind_list)\n        no_born_list = keywords_without_word(language=\"Hindi\", word=hindi_born())\n        list_comp_minus_born = [key for key in subscribe_keywords(\"Hindi\") if key not in [hindi_born()]]\n        self.assertEqual(list_comp_minus_born, no_born_list)\n\n    def test_only_removes_words_in_set_english(self):\n        no_laugh_list = keywords_without_word(language=\"English\", word=\"hahahaha\")\n        self.assertEqual(subscribe_keywords(\"English\"), no_laugh_list)\n        no_capital_born_list = keywords_without_word(language=\"English\", word=\"Born\")\n        self.assertEqual(subscribe_keywords(\"English\"), no_capital_born_list)\n        no_partial_born_list = keywords_without_word(language=\"English\", word=\"bor\")\n        self.assertEqual(subscribe_keywords(\"English\"), no_partial_born_list)\n        no_hyphen_list = keywords_without_word(language=\"English\", word=\"---\")\n        self.assertEqual(subscribe_keywords(\"English\"), no_hyphen_list)\n        no_speical_character_list = keywords_without_word(language=\"English\", word=\"!*^%$\")\n        self.assertEqual(subscribe_keywords(\"English\"), no_speical_character_list)\n        no_empty_list = keywords_without_word(language=\"English\", word=\"\")\n        self.assertEqual(subscribe_keywords(\"English\"), no_empty_list)\n        no_blank_list = keywords_without_word(language=\"English\", word=\" \")\n        self.assertEqual(subscribe_keywords(\"English\"), no_blank_list)\n        no_triple_blank_list = keywords_without_word(language=\"English\", word=\"   \")\n        self.assertEqual(subscribe_keywords(\"English\"), no_triple_blank_list)\n        no_int_list = keywords_without_word(language=\"English\", word=10)\n        self.assertEqual(subscribe_keywords(\"English\"), no_int_list)\n        no_digit_list = keywords_without_word(language=\"English\", word=\"100\")\n        self.assertEqual(subscribe_keywords(\"English\"), no_digit_list)\n        no_hindi_remind_list = keywords_without_word(language=\"English\", word=hindi_remind())\n        self.assertEqual(subscribe_keywords(\"English\"), no_hindi_remind_list)\n        no_hindi_information_list = keywords_without_word(language=\"English\", word=hindi_information())\n        self.assertEqual(subscribe_keywords(\"English\"), no_hindi_information_list)\n        no_hindi_born_list = keywords_without_word(language=\"English\", word=hindi_born())\n        self.assertEqual(subscribe_keywords(\"English\"), no_hindi_born_list)\n\n    def test_only_removes_words_in_set_hindi(self):\n        no_random_char_list1 = keywords_without_word(language=\"Hindi\", word=u\"\\u092e\\u0947\\u0902\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_random_char_list1)\n        no_random_char_list2 = keywords_without_word(language=\"Hindi\", word=u\"\\u0917\\u0932\\u0947\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_random_char_list2)\n        no_partial_born_list = keywords_without_word(language=\"Hindi\", word=u\"\\u091c\\u0928\\u094d\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_partial_born_list)\n        no_hyphen_list = keywords_without_word(language=\"Hindi\", word=\"---\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_hyphen_list)\n        no_speical_character_list = keywords_without_word(language=\"Hindi\", word=\"!*^%$\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_speical_character_list)\n        no_empty_list = keywords_without_word(language=\"Hindi\", word=\"\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_empty_list)\n        no_blank_list = keywords_without_word(language=\"Hindi\", word=\" \")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_blank_list)\n        no_triple_blank_list = keywords_without_word(language=\"Hindi\", word=\"   \")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_triple_blank_list)\n        no_int_list = keywords_without_word(language=\"Hindi\", word=10)\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_int_list)\n        no_digit_list = keywords_without_word(language=\"Hindi\", word=\"100\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_digit_list)\n        no_english_remind_list = keywords_without_word(language=\"Hindi\", word=\"remind\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_english_remind_list)\n        no_english_join_list = keywords_without_word(language=\"Hindi\", word=\"join\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_english_join_list)\n        no_english_born_list = keywords_without_word(language=\"Hindi\", word=\"born\")\n        self.assertEqual(subscribe_keywords(\"Hindi\"), no_english_born_list)\n\nclass AsciiMessageTests(TestCase):\n    def test_is_not_ascii_with_ascii_text(self):\n        self.assertFalse(is_not_ascii(\" \"))\n        self.assertFalse(is_not_ascii(\"   \"))\n        self.assertFalse(is_not_ascii(\"\"))\n        self.assertFalse(is_not_ascii(\"Ascii string here\"))\n        self.assertFalse(is_not_ascii(\"Ascii string here that is really long\" * 5))\n        self.assertFalse(is_not_ascii(\"12234567890\"))\n        self.assertFalse(is_not_ascii(\"~!@#$%^&*()_+=-`\\\\{}][\\\":;'?><,./'\"))\n        self.assertFalse(is_not_ascii(u'\\u0000\\u0001\\u0002\\u0003\\u0004'))\n        self.assertFalse(is_not_ascii(u'\\u005B\\u005C\\u005D\\u005E\\u005F\\u0060'))\n        self.assertFalse(is_not_ascii(u'\\u007A\\u007B\\u007C\\u007D\\u007E\\u007F')) # last characters in ASCII set\n\n    def test_is_not_ascii_with_nonascii_text(self):\n        self.assertTrue(is_not_ascii(u'\\u04FA'))\n        self.assertTrue(is_not_ascii(u'\\u0080')) # First character after ASCII set\n        self.assertTrue(is_not_ascii(u'Ascii string start \\u04FA'))\n        self.assertTrue(is_not_ascii(u'\\u04FA Ascii string end'))\n        self.assertTrue(is_not_ascii(u'\\u04FA Ascii string mid \\u00BB'))\n        self.assertTrue(is_not_ascii(u'\\u04FA Ascii string mid one \\u00BB Ascii string end'))\n        self.assertTrue(is_not_ascii(u'\\u04FA Ascii string mid one \\u00BB Ascii string mid two \\u00BC'))\n        self.assertTrue(is_not_ascii(u'\\u00BA\\u00BB\\u00BC\\u00BD\\u00BE\\u00BF')) # First characters after ASCII set\n        self.assertTrue(is_not_ascii(u'\\u04FA\\u04FB\\u04FC\\u04FD\\u04FE\\u04FF'))\n        self.assertTrue(is_not_ascii(u'\\u00BA\\u00BB\\u00BC\\u00BD\\u00BE\\u00BF' * 5))\n\n    def test_is_not_ascii_with_english_messages(self):\n        self.assertFalse(is_not_ascii(\"join\"))\n        self.assertFalse(is_not_ascii(\"remind\"))\n        self.assertFalse(is_not_ascii(\"born\"))\n        self.assertFalse(is_not_ascii(msg_subscribe(\"English\")))\n        self.assertFalse(is_not_ascii(msg_unsubscribe(\"English\")))\n        self.assertFalse(is_not_ascii(msg_already_sub(\"English\")))\n        self.assertFalse(is_not_ascii(msg_failure(\"English\")))\n        self.assertFalse(is_not_ascii(msg_failed_date(\"English\")))\n        self.assertFalse(is_not_ascii(six_week_reminder_seven_days(\"English\")))\n        self.assertFalse(is_not_ascii(six_week_reminder_one_day(\"English\")))\n        self.assertFalse(is_not_ascii(ten_week_reminder_seven_days(\"English\")))\n        self.assertFalse(is_not_ascii(ten_week_reminder_one_day(\"English\")))\n        self.assertFalse(is_not_ascii(fourteen_week_reminder_seven_days(\"English\")))\n        self.assertFalse(is_not_ascii(fourteen_week_reminder_one_day(\"English\")))\n        self.assertFalse(is_not_ascii(nine_month_reminder_seven_days(\"English\")))\n        self.assertFalse(is_not_ascii(nine_month_reminder_one_day(\"English\")))\n        self.assertFalse(is_not_ascii(sixteen_month_reminder_seven_days(\"English\")))\n", "context": "modules/utils.py\ndef keywords_without_word(language, word):\n\tnew_keys = subscribe_keywords(language)\n\tif word in new_keys:\n\t\tnew_keys.remove(word)\n\treturn new_keys\nmodules/i18n.py\ndef msg_subscribe(language):\n    if language == \"English\":\n        return \"{name} has been subscribed to CSH health reminders. Text END to \" + TEXTLOCAL_PHONENUMBER + \" to unsubscribe.\"\n    elif language == \"Hindi\":\n        return u'{name} \\u0938\\u0940 \\u090f\\u0938 \\u090f\\u091a \\u0939\\u0947\\u0932\\u094d\\u0925 \\u0905\\u0928\\u0941\\u0938\\u094d\\u092e\\u0930\\u0928 \\u0915\\u0947 \\u0938\\u0926\\u0938\\u094d\\u092f \\u0939\\u0948\\u0902. \\u0938\\u0926\\u0938\\u094d\\u092f\\u0924\\u093e \\u0930\\u0926\\u094d\\u0926 \\u0915\\u0930\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u0932\\u093f\\u0916\\u0947\\u0902 \"END\" \\u0914\\u0930 \\u092d\\u0947\\u0902\\u091c \\u0926\\u0947 ' + TEXTLOCAL_PHONENUMBER + u' \\u092a\\u0930.'\nmodules/i18n.py\ndef five_year_reminder_seven_days(language):\n    return fourteen_week_reminder_seven_days(language)\nmodules/i18n.py\ndef hindi_information():\n    return u'\\u0907\\u0924\\u094d\\u0924\\u093f\\u0932\\u093e'\nmodules/i18n.py\ndef nine_month_reminder_one_day(language):\n    return six_week_reminder_one_day(language)\nmodules/utils.py\ndef is_not_ascii(message):\n\treturn any(ord(char) >= 128 for char in message)\nmodules/date_helper.py\ndef datetime_string_mdy_to_datetime(date_string):\n\treturn  datetime_from_date_string(date_string, \"%m/%d/%Y %I:%M:%S %p\").replace(tzinfo=timezone.get_default_timezone())\nmodules/date_helper.py\ndef date_string_ymd_to_date(date_string):\n\tfor fmt in [\"%Y-%m-%d\", \"%Y/%m/%d\"]:\n\t\ttry:\n\t\t\treturn datetime_from_date_string(date_string, fmt).date()\n\t\texcept ValueError:\n\t\t\tpass\n\traise ValueError(\"No valid year-month-day date format\")\nmodules/utils.py\ndef remove_nondigit_characters(phone_number):\n\treturn re.sub(\"[^0-9]\", \"\", phone_number)\nmodules/i18n.py\ndef hindi_remind():\n    return u'\\u0938\\u094d\\u092e\\u0930\\u0923'\nmodules/date_helper.py\ndef date_string_to_date(date_string):\n    sep = \"-\" if \"-\" in date_string else \"/\"\n    if len(date_string.split(sep)) < 3:\n        raise ValueError()\n    year = \"%Y\" if len(date_string.split(sep)[2]) == 4 else \"%y\"\n    pattern = \"%d\" + sep + \"%m\" + sep + year\n    return datetime.strptime(date_string, pattern).date()\nmodules/i18n.py\ndef subscribe_keywords(language):\n    if language == \"English\":\n        return [\"remind\", \"join\", \"born\"]\n    elif language == \"Hindi\":\n        return [hindi_remind(), hindi_information(), hindi_born()]\n    else:\n        return []\nmodules/i18n.py\ndef ten_week_reminder_one_day(language):\n    if language == \"English\":\n        return \"{name} is due for their important vaccinations tomorrow. Please do so then.\"\n    elif language == \"Hindi\":\n        return u'\\u091c\\u093c\\u093f\\u092e\\u094d\\u092e\\u0947\\u0926\\u093e\\u0930 \\u092e\\u093e\\u0924\\u093e \\u0939\\u094b\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u0906\\u092a\\u0915\\u094b \\u092c\\u0927\\u093e\\u0908. 1 \\u0926\\u093f\\u0928 \\u092e\\u0947\\u0902 {name} \\u0915\\u0947 \\u091c\\u093c\\u0930\\u0942\\u0930\\u0940 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u0906\\u092a \\u0938\\u0947 \\u092e\\u0941\\u0932\\u093e\\u0915\\u093c\\u093e\\u0924 \\u0939\\u094b\\u0917\\u0940.'\n    elif language == \"Gujarati\":\n        return u'{name} \\u0aa8 \\u0ac1\\u0a82\\u0ae7 \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae \\u0ac1\\u0a82\\u0aae\\u0ab9\\u0aa4\\u0acd\\u0ab5\\u0aaa\\u0ac2\\u0aa3\\u0aa3\\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aa6\\u0aa8\\u0aaf\\u0aa4 \\u0a9b\\u0ac7. \\u0aa4\\u0acb \\u0a95\\u0ac3\\u0aaa \\u0a95\\u0ab0\\u0ac0\\u0ac1\\u0a82\\u0aa8\\u0ac7\\u0aaa\\u0a9b\\u0ac0 \\u0a8f \\u0a95\\u0ab0\\u0a9c\\u0acb.'\nmodules/utils.py\ndef prepare_phone_number(phone_number):\n\tif phone_number == None:\n\t\treturn \"\"\n\tstripped_phone_number = remove_nondigit_characters(phone_number)\n\tif stripped_phone_number == \"0\" * len(stripped_phone_number):\n\t\treturn \"\"\n\telif len(stripped_phone_number) < 10:\n\t\treturn phone_number\n\treturn add_country_code_to_phone_number(stripped_phone_number)\nmodules/utils.py\ndef add_country_code_to_phone_number(phone_number):\n\tif not phone_number:\n\t\treturn phone_number\n\n\tbegins_with_nine_one = re.match(\"^91\", phone_number)\n\t\t\n\tif not begins_with_nine_one:\n\t\tphone_number = \"91\" + phone_number\n\n\treturn phone_number\nmodules/i18n.py\ndef hindi_born():\n    return u'\\u091c\\u0928\\u094d\\u092e'\nmodules/date_helper.py\ndef try_parsing_gen_date(date_string):\n\ttry:\n\t    return date_string_ymd_to_date(date_string)\n\texcept ValueError:\n\t\treturn date_string_mdy_to_date(date_string)\nmodules/i18n.py\ndef msg_failure(language):\n    if language == \"English\":\n        return \"Sorry, we didn't understand that message. Text END to \" + TEXTLOCAL_PHONENUMBER + \" to unsubscribe.\"\n    elif language == \"Hindi\":\n        return u'\\u0915\\u094d\\u0937\\u092e\\u093e \\u0915\\u0930\\u0947\\u0902, \\u0939\\u092e\\u0928\\u0947 \\u0909\\u0938 \\u0938\\u0902\\u0926\\u0947\\u0936 \\u0915\\u094b \\u0928\\u0939\\u0940\\u0902 \\u0938\\u092e\\u091d\\u093e. \\u0938\\u0926\\u0938\\u094d\\u092f\\u0924\\u093e \\u0930\\u0926\\u094d\\u0926 \\u0915\\u0930\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u0932\\u093f\\u0916\\u0947\\u0902 \"END\" \\u0914\\u0930 \\u092d\\u0947\\u0902\\u091c \\u0926\\u0947 ' + TEXTLOCAL_PHONENUMBER + ' \\u092a\\u0930.'\nmodules/i18n.py\ndef fourteen_week_reminder_one_day(language):\n    if language == \"English\":\n        return \"Your child is eligible to receive a free course of vaccines. {name} has their scheduled vaccination tomorrow.\"\n    elif language == \"Hindi\":\n        return u'1 \\u0926\\u093f\\u0928 \\u092e\\u0947\\u0902 {name} \\u0915\\u0940 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901 \\u090f\\u0935\\u0902 \\u0916\\u093c\\u0924\\u0930\\u0928\\u093e\\u0915 \\u092c\\u0940\\u092e\\u093e\\u0930\\u093f\\u0913\\u0902 \\u0938\\u0947 \\u092c\\u091a\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'\\u0aa1\\u0ac9\\u0a95\\u0acd\\u0a9f\\u0ab0\\u0ac9 \\u0a8f \\u0ae7 \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae\\u0abe\\u0a82  {name} \\u0aa8\\u0ac7 \\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aae\\u0abe\\u0a9f\\u0ac7 \\u0ab8\\u0ac2\\u0a9a\\u0ab5\\u0acd\\u0aaf\\u0ac1 \\u0a9b\\u0ac7.'\nmodules/i18n.py\ndef msg_failed_date(language):\n    if language == \"English\":\n        return \"Sorry, the date format was incorrect. An example message is 'Remind Sai 14-01-17' where 'Sai' is your child's first name and '14-01-17'' is their birthday.\"\n    elif language == \"Hindi\":\n        return u'\\u0915\\u094d\\u0937\\u092e\\u093e \\u0915\\u0940\\u091c\\u093f\\u092f\\u0947, \\u0924\\u093e\\u0930\\u0940\\u0916 \\u0915\\u093e \\u092a\\u094d\\u0930\\u093e\\u0930\\u0942\\u092a \\u0917\\u0932\\u0924 \\u0939\\u0948.'\nmodules/i18n.py\ndef msg_already_sub(language):\n    if language == \"English\":\n        return \"You are already registered to receive CSH health reminders.\"\n    elif language == \"Hindi\":\n        return u'\\u0906\\u092a \\u092a\\u0939\\u0932\\u0947 \\u0938\\u0947 \\u0939\\u0940 \\u0938\\u0940.\\u090f\\u0938.\\u091a \\u0938\\u094d\\u0935\\u093e\\u0938\\u094d\\u0925\\u094d\\u092f \\u0938\\u094d\\u092e\\u0930\\u0923 \\u092a\\u094d\\u0930\\u093e\\u092a\\u094d\\u0924 \\u0915\\u0930\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093f\\u090f \\u092a\\u0902\\u091c\\u0940\\u0915\\u0943\\u0924 \\u0939\\u0948\\u0902.'\nmodules/date_helper.py\ndef datetime_string_ymd_to_datetime(date_string):\n\t\ttry:\n\t\t\treturn datetime_from_date_string(date_string, \"%Y-%m-%d %H:%M:%S\").replace(tzinfo=timezone.get_default_timezone())\n\t\texcept ValueError:\n\t\t\tlogging.error(\"Invalid datetime entry for message: \" + quote(date_string))\n\t\t\treturn datetime.now().replace(tzinfo=timezone.get_default_timezone())\nmodules/i18n.py\ndef nine_month_reminder_seven_days(language):\n    return six_week_reminder_seven_days(language)\nmodules/i18n.py\ndef verify_pregnant_signup_birthdate(language):\n    if language == \"English\":\n        return \"You signed up for health reminders while pregnant. If your child has been born, text 'BORN Name DD-MM-YY' to \"+ TEXTLOCAL_PHONENUMBER + \" to register for  English. An example message is 'BORN Aarav 14-01-17' where 'Aarav' is your child's first name and '14-01-17' is your child's birthday.\"\n    elif language == \"Hindi\":\n        return u'\\u0905\\u092a\\u0928\\u0940 \\u0917\\u0930\\u094d\\u092d\\u093e\\u0935\\u0938\\u094d\\u0920\\u093e \\u0915\\u0947 \\u0926\\u094c\\u0930\\u093e\\u0928 \\u0906\\u092a\\u0928\\u0947 \\u0938\\u094d\\u0935\\u093e\\u0938\\u094d\\u0925\\u094d\\u092f \\u0938\\u094d\\u092e\\u0930\\u0923 \\u0915\\u0940 \\u0938\\u0926\\u0938\\u094d\\u092f\\u0924\\u093e \\u0932\\u0940 \\u0925\\u0940. \\u092f\\u0926\\u093f \\u0906\\u092a\\u0915\\u093e \\u092c\\u091a\\u094d\\u091a\\u093e \\u091c\\u0928\\u094d\\u092e \\u0932\\u0947 \\u091a\\u0942\\u0915\\u093e \\u0939\\u0948 \\u0924\\u094b \\u0932\\u093f\\u0916\\u0947 \\u201c \\u091c\\u0928\\u094d\\u092e \\u0928\\u093e\\u092e DD-MM-YY \\u201d \\u0914\\u0930 \\u092d\\u0947\\u0902\\u091c \\u0926\\u0947 \\u201c ' + TEXTLOCAL_PHONENUMBER + u' \\u201d \\u092a\\u0930 \\u0939\\u093f\\u0902\\u0926\\u0940 \\u092e\\u0947\\u0902 \\u092a\\u0902\\u091c\\u0940\\u0915\\u0930\\u0923 \\u0915\\u0947 \\u0932\\u093f\\u090f.'\nmodules/i18n.py\ndef fourteen_week_reminder_seven_days(language):\n    if language == \"English\":\n        return \"Thank you for being a responsible mother. {name} is due for their important vaccinations in 7 days. Please do so then.\"\n    elif language == \"Hindi\":\n        return u'{name} \\u0915\\u0947 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 7 \\u0926\\u093f\\u0928\\u094b\\u0902 \\u092e\\u0947\\u0902 \\u0905\\u0935\\u0936\\u094d\\u092f \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'\\u0a8f\\u0a95 \\u0a9c\\u0ab5 \\u0aac\\u0abf \\u0ab0 \\u0aae \\u0aa4 \\u0ab9\\u0acb\\u0ab5 \\u0aac\\u0abf\\u0ab2 \\u0aa7\\u0aa8\\u0acd\\u0aaf\\u0ab5 \\u0abf. {name} \\u0aa8 \\u0ac1\\u0a82\\u0aed \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae \\u0ac1\\u0a82\\u0aae\\u0ab9\\u0aa4\\u0acd\\u0ab5\\u0aaa\\u0ac2\\u0aa3\\u0aa3\\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aa6\\u0aa8\\u0aaf\\u0aa4 \\u0a9b\\u0ac7. \\u0aa4\\u0acb \\u0a95\\u0ac3\\u0aaa \\u0a95\\u0ab0\\u0ac0\\u0ac1\\u0a82\\u0aa8\\u0ac7\\u0aaa\\u0a9b\\u0ac0 \\u0a8f \\u0a95\\u0ab0\\u0a9c\\u0acb.'\nmodules/i18n.py\ndef sixteen_month_reminder_one_day(language):\n    return ten_week_reminder_one_day(language)\nmodules/utils.py\ndef phone_number_is_valid(phone_number):\n    \"\"\"Match any number starting with 91 or +91 that has another\n        9 to 15 digits\"\"\"\n    pattern = '^\\+?91?\\d{9,15}$'\n    prepared_phone_number = prepare_phone_number(phone_number)\n    return re.match(pattern, prepared_phone_number)\nmodules/date_helper.py\ndef date_to_date_string(date):\n    return '{d}/{m}/{y}'.format(d = date.day,\n                                m = date.month,\n                                y = date.year)\nmodules/utils.py\ndef quote(word):\n    return u\"`{}`\".format(word)\nmodules/i18n.py\ndef six_week_reminder_seven_days(language):\n    if language == \"English\":\n        return \"{name} has their scheduled vaccination in 7 days. Without this vaccination your child will be vulnerable to deadly diseases.\"\n    elif language == \"Hindi\":\n        return u'7 \\u0926\\u093f\\u0928\\u094b\\u0902 \\u092e\\u0947\\u0902 {name} \\u0915\\u093e \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901 \\u090f\\u0935\\u0902 \\u0916\\u093c\\u0924\\u0930\\u0928\\u093e\\u0915 \\u092c\\u0940\\u092e\\u093e\\u0930\\u093f\\u0913\\u0902 \\u0938\\u0947 \\u092c\\u091a\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'{name} \\u0aa8 \\u0ac1\\u0a82\\u0aed \\u0aa6\\u0abf\\u0ab5\\u0ab8 \\u0aae \\u0ac1\\u0aa8 \\u0ac1\\u0a82\\u0aed \\u0aa6\\u0abf\\u0ab5\\u0ab8 \\u0aae \\u0ac1\\u0a82\\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0ab8 \\u0aa6\\u0aa8\\u0aa6\\u0abf\\u0aa4 \\u0a9b\\u0ac7. \\u0a86 \\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0ab5\\u0a97\\u0ab0 \\u0aa4\\u0aae \\u0ab0\\u0ac1\\u0a82 \\u0aac \\u0ab3\\u0a95 \\u0a9c\\u0ac0\\u0ab5\\u0ab2\\u0ac7\\u0aa3 \\u0ab0\\u0acb\\u0a97\\u0acb \\u0aae \\u0a9f\\u0ac7\\u0ab8\\u0ac1\\u0a82\\u0ab5\\u0ac7\\u0abf\\u0aa8\\u0ab6\\u0ac0\\u0ab2 \\u0ab0\\u0ab9\\u0ac7\\u0ab6\\u0ac7.'\nmodules/date_helper.py\ndef date_string_dmy_to_date(date_string):\n\tfor fmt in [\"%d-%m-%Y\", \"%d/%m/%Y\"]:\n\t\ttry:\n\t\t\treturn  datetime_from_date_string(date_string, fmt).date()\n\t\texcept ValueError:\n\t\t\tpass\n\traise ValueError(\"No valid day-month-year date format\")\nmodules/i18n.py\ndef five_year_reminder_one_day(language):\n    return fourteen_week_reminder_one_day(language)\nmodules/i18n.py\ndef ten_week_reminder_seven_days(language):\n    if language == \"English\":\n        return \"{name} is eligible for a free vaccination in 7 days. Without this vaccination your child will be vulnerable to deadly diseases.\"\n    elif language == \"Hindi\":\n        return u'7 \\u0926\\u093f\\u0928\\u094b\\u0902 \\u092e\\u0947\\u0902 {name} \\u0915\\u0940 \\u0928\\u093f\\u0903\\u0936\\u0941\\u0932\\u094d\\u0915 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901 \\u090f\\u0935\\u0902 \\u0916\\u093c\\u0924\\u0930\\u0928\\u093e\\u0915 \\u092c\\u0940\\u092e\\u093e\\u0930\\u093f\\u0913\\u0902 \\u0938\\u0947 \\u092c\\u091a\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'{name} \\u0aed \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae \\u0ac1\\u0a82\\u0aae\\u0aab\\u0aa4 \\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aae \\u0a9f\\u0ac7\\u0aaa \\u0aa4\\u0acd\\u0ab0 \\u0a9b\\u0ac7. \\u0a86 \\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0ab5\\u0a97\\u0ab0 \\u0aa4\\u0aae \\u0ab0\\u0ac2 \\u0aac \\u0ab3\\u0a95 \\u0a9c\\u0ac0\\u0ab5\\u0ab2\\u0ac7\\u0aa3 \\u0ab0\\u0acb\\u0a97\\u0acb \\u0aae \\u0a9f\\u0ac7\\u0ab8\\u0ac1\\u0a82\\u0ab5\\u0ac7\\u0abf\\u0aa8\\u0ab6\\u0ac0\\u0ab2 \\u0ab0\\u0ab9\\u0ac7\\u0ab6\\u0ac7.'\nmodules/i18n.py\ndef sixteen_month_reminder_seven_days(language):\n    return ten_week_reminder_seven_days(language)\nmodules/i18n.py\ndef msg_unsubscribe(language):\n    if language == \"English\":\n        return \"You have been unsubscribed from CSH health reminders.\"\n    elif language == \"Hindi\":\n        return u'\\u0906\\u092a\\u0915\\u0940 \\u0938\\u0926\\u0938\\u094d\\u092f\\u0924\\u093e \\u0938\\u092e\\u093e\\u092a\\u094d\\u0924 \\u0915\\u0930 \\u0926\\u0940 \\u0917\\u092f\\u0940 \\u0939\\u0948.'\nmodules/i18n.py\ndef six_week_reminder_one_day(language):\n    if language == \"English\":\n        return \"{name} is due for their important vaccinations tomorrow. Please do so then.\"\n    elif language == \"Hindi\":\n        return u'\\u0905\\u0917\\u0932\\u0947 1 \\u0926\\u093f\\u0928 \\u092e\\u0947\\u0902 {name} \\u0915\\u0940 \\u091c\\u093c\\u0930\\u0942\\u0930\\u0940 \\u091f\\u0940\\u0915\\u093e\\u0915\\u0930\\u0923 \\u0905\\u0935\\u0936\\u094d\\u092f \\u0915\\u0930\\u0935\\u093e\\u090f\\u0901.'\n    elif language == \"Gujarati\":\n        return u'{name} \\u0aa8 \\u0ac1\\u0a82\\u0ae7 \\u0aa6\\u0abf\\u0ab5\\u0ab8\\u0aae \\u0ac1\\u0a82\\u0aae\\u0ab9\\u0aa4\\u0acd\\u0ab5\\u0aaa\\u0ac2\\u0aa3\\u0aa3\\u0ab0\\u0ab8\\u0ac0\\u0a95\\u0ab0\\u0aa3 \\u0aa6\\u0aa8\\u0aaf\\u0aa4 \\u0a9b\\u0ac7. \\u0aa4\\u0acb \\u0a95\\u0ac3\\u0aaa \\u0a95\\u0ab0\\u0ac0\\u0ac1\\u0a82\\u0aa8\\u0ac7\\u0aaa\\u0a9b\\u0ac0 \\u0a8f \\u0a95\\u0ab0\\u0a9c\\u0acb.'\nmodules/date_helper.py\ndef try_parsing_partner_date(date_string):\n\ttry:\n\t\treturn date_string_dmy_to_date(date_string)\n\texcept ValueError:\n\t\treturn date_string_ymd_to_date(date_string)\nmodules/date_helper.py\ndef date_string_mdy_to_date(date_string):\n\tfor fmt in [\"%m-%d-%Y\", \"%m/%d/%Y\"]:\n\t\ttry:\n\t\t\treturn  datetime_from_date_string(date_string, fmt).date()\n\t\texcept ValueError:\n\t\t\tpass\n\traise ValueError(\"No valid month-day-year date format\")\nmodules/date_helper.py\ndef date_is_valid(date_string):\n    try:\n        date = date_string_to_date(date_string)\n        too_old = date.year < datetime.now().year - 18\n        too_young = date.year > datetime.now().year + 2\n        return (not too_old and not too_young)\n    except ValueError:\n        return False\n", "answers": ["        self.assertFalse(is_not_ascii(sixteen_month_reminder_one_day(\"English\")))"], "length": 1549, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "1713a1e7e70dfae6b241613191c5027d45803111e94d3630"}
{"input": "import numpy as np\nimport nibabel as nib\nimport argparse as ap\nimport matplotlib.pyplot as plt\nfrom tfce_mediation.pyfunc import convert_mni_object, convert_fs, convert_gifti, convert_ply, convert_fslabel, save_waveform, save_stl, save_fs, save_ply, convert_redtoyellow, convert_bluetolightblue, convert_mpl_colormaps, convert_fsannot, convert_voxel\nfrom tfce_mediation.tm_io import savemgh_v2\n#!/usr/bin/env python\n\n#    convert-surface\n#    Copyright (C) 2017  Tristram Lett\n\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\n\nDESCRIPTION = \"\"\"\nConversion of surfaces (freesurfer, gifti *.gii, mni *.obj, ply *.ply) to freesurfer surface or other objects (Waveform *obj, STereoLithography *stl, Polygon File Format *ply) for analysis with TFCE_mediation. *mgh files can also be imported and converted to PLY files.\n\"\"\"\n\n#arguments parser\ndef getArgumentParser(ap = ap.ArgumentParser(description = DESCRIPTION, formatter_class=ap.RawTextHelpFormatter)):\n\t#input type\n\tigroup = ap.add_mutually_exclusive_group(required=True)\n\tigroup.add_argument(\"-i_fs\", \"--inputfreesurfer\",\n\t\thelp=\"Input a freesurfer surface (e.g., -i_fs $SUBJECTS_DIR/fsaverage/surf/lh.midthickness)\", \n\t\tnargs=1, \n\t\tmetavar=('*'))\n\tigroup.add_argument(\"-i_gifti\", \"--inputgifti\",\n\t\thelp=\"Input a gifti surface file (e.g., --i_gifti average.surf.gii)\", \n\t\tnargs=1, \n\t\tmetavar=('*.surf.gii'))\n\tigroup.add_argument(\"-i_mni\", \"--inputmniobj\",\n\t\thelp=\"Input a MNI object file (e.g., --i_mni l_hemi.obj)\", \n\t\tnargs=1, \n\t\tmetavar=('*.obj'))\n\tigroup.add_argument(\"-i_ply\", \"--inputply\",\n\t\thelp=\"Input a MNI object file (e.g., --i_ply l_hemi.ply). Note, vertex colors will be stripped.\", \n\t\tnargs=1, \n\t\tmetavar=('*.ply'))\n\t# voxel to surface conversion\n\tigroup.add_argument(\"-i_voxel\", \"--inputvoxel\",\n\t\thelp=\"Input a voxel (nifti, minc, mgh). e.g. -i_voxel tstat_pFWER_corr.nii.gz\", \n\t\tnargs=1)\n\tap.add_argument(\"-vol\", \"--specifyvolume\",\n\t\thelp=\"Specify volume if -i_voxel is 4D (the first volume is 0)\", \n\t\tnargs=1)\n\tap.add_argument(\"-vt\", \"--voxelthreshold\",\n\t\thelp=\"Apply a threshold to -i_voxel image (zeros everything below value). e.g. -vt 0.95\", \n\t\tnargs=1)\n\tap.add_argument(\"-vb\", \"--voxelbackbone\",\n\t\thelp=\"Add binary mask backbone to the voxel image. e.g. -vb binary_mask_skeleton.nii.gz\", \n\t\tnargs=1)\n\tap.add_argument(\"-vp\", \"--paintvoxelsurface\",\n\t\thelp=\"Must be used with -i_voxel and -o_ply options. Input the sigificance threshold (low and high), and either: red-yellow (r_y), blue-lightblue (b_lb) or any matplotlib colorschemes (https://matplotlib.org/examples/color/colormaps_reference.html). Note, thresholds must be postive. e.g., -vp 0.95 1 r_y\", \n\t\tnargs=3, \n\t\tmetavar=('float','float', 'colormap'))\n\tap.add_argument(\"-ov_mgh\", \"--outputvoxelsurfmgh\",\n\t\thelp=\"Output a mgh file of the surface. This is only useful for visualization purposes.\", \n\t\tnargs=1)\n\n\togroup = ap.add_mutually_exclusive_group(required=True)\n\togroup.add_argument(\"-o_fs\", \"--outputfreesurfer\",\n\t\thelp=\"Output file name for freesurfer surface (e.g., -o_fs lh.32k.midthickness)\", \n\t\tnargs=1, \n\t\tmetavar=('*'))\n\togroup.add_argument(\"-o_obj\", \"--outputwaveform\",\n\t\thelp=\"Output file name for waveform object file for visualization with blender (or any other 3D viewer). This is NOT an MNI object file.\", \n\t\tnargs=1, \n\t\tmetavar=('*'))\n\togroup.add_argument(\"-o_stl\", \"--outputstl\",\n\t\thelp=\"Output file name for STereoLithography (STL) object file for visualization with blender (or any other 3D viewer).\", \n\t\tnargs=1, \n\t\tmetavar=('*'))\n\togroup.add_argument(\"-o_ply\", \"--outputply\",\n\t\thelp=\"Output file name for Polygon File Format (PYL) object file for visualization with blender (or any other 3D viewer).\", \n\t\tnargs=1, \n\t\tmetavar=('*'))\n\n\tap.add_argument(\"-p\", \"--paintsurface\",\n\t\thelp=\"Projects surface file onto a ply mesh for visualization of results using a 3D viewer. Must be used with -o_ply option. Input the surface file (*.mgh), the sigificance threshold (low and high), and either: red-yellow (r_y), blue-lightblue (b_lb) or any matplotlib colorschemes (https://matplotlib.org/examples/color/colormaps_reference.html). Note, thresholds must be postive. e.g., -p image.mgh 0.95 1 r_y\", \n\t\tnargs=4, \n\t\tmetavar=('*.mgh','float','float', 'colormap'))\n\tap.add_argument(\"-s\", \"--paintsecondsurface\",\n\t\thelp=\"Projects a second surface file onto a ply mesh for visualization of resutls using a 3D viewer. Must be used with -o_ply and -p options. Input the surface file (*.mgh), the sigificance threshold (low and high), and either: red-yellow (r_y), blue-lightblue (b_lb) or any matplotlib colorschemes (https://matplotlib.org/examples/color/colormaps_reference.html). Note, thresholds must be postive. e.g., -s negimage.mgh 0.95 1 b_lb\", \n\t\tnargs=4, \n\t\tmetavar=('*.mgh','float','float', 'colormap'))\n\n\tap.add_argument(\"-l\", \"--paintfslabel\",\n\t\thelp=\"Projects freesurface label file onto a ply mesh for visualization of resutls using a 3D viewer. Must be used with -o_ply option. Input the label (*.label or *.label-????) and either: red-yellow (r_y), blue-lightblue (b_lb) or any matplotlib colorschemes (https://matplotlib.org/examples/color/colormaps_reference.html). More than one label can be included. e.g. -l label1.label rainbow label2.label Reds\", \n\t\tnargs='+', \n\t\tmetavar=('*.label colormap'))\n\tap.add_argument(\"-a\", \"--paintfsannot\",\n\t\thelp=\"Projects freesurface annotation file onto a ply mesh for visualization of resutls using a 3D viewer. Must be used with -o_ply option. The legend is outputed\", \n\t\tnargs=1, \n\t\tmetavar=('*.annot'))\n\n\n\treturn ap\n\ndef run(opts):\n\t#input\n\tif opts.inputfreesurfer:\n", "context": "tfce_mediation/pyfunc.py\ndef convert_fs(fs_surface):\n\tv, f = nib.freesurfer.read_geometry(fs_surface)\n\treturn v, f\ntfce_mediation/pyfunc.py\ndef save_stl(v,f, outname):\n\tif not outname.endswith('stl'):\n\t\toutname += '.stl'\n\toutname=check_outname(outname)\n\tv = np.array(v, dtype=np.float32, order = \"C\")\n\tf = np.array(f, dtype=np.int32, order = \"C\")\n\ttris = v[f]\n\tn = np.cross( tris[::,1 ] - tris[::,0]  , tris[::,2 ] - tris[::,0] )\n\tn = normalize_v3(n)\n\twith open(outname, \"a\") as o:\n\t\to.write(\"solid surface\\n\")\n\t\tfor i in range(tris.shape[0]):\n\t\t\to.write(\"facet normal %1.6f %1.6f %1.6f\\n\"% (n[i,0],n[i,0],n[i,0]))\n\t\t\to.write(\"outer loop\\n\")\n\t\t\to.write(\"vertex %1.6f %1.6f %1.6f\\n\" % (tris[i,0,0],tris[i,0,1],tris[i,0,2]))\n\t\t\to.write(\"vertex %1.6f %1.6f %1.6f\\n\" % (tris[i,1,0],tris[i,1,1],tris[i,1,2]))\n\t\t\to.write(\"vertex %1.6f %1.6f %1.6f\\n\" % (tris[i,2,0],tris[i,2,1],tris[i,2,2]))\n\t\t\to.write(\"endloop\\n\")\n\t\t\to.write(\"endfacet\\n\")\n\t\to.write(\"endfacet\\n\")\n\t\to.close()\ntfce_mediation/pyfunc.py\ndef convert_bluetolightblue(threshold, img_data, baseColour=[227,218,201], save_colorbar = True):\n\tcolor_array = np.zeros((img_data.shape[0],3))\n\tcolor_cutoffs = np.linspace(threshold[0],threshold[1],256)\n\tcolored_img_data = np.zeros_like(img_data)\n\tcV=0\n\tfor k in img_data:\n\t\tcolored_img_data[cV] = np.searchsorted(color_cutoffs, k, side=\"left\")\n\t\tcV+=1\n\tcolor_array[:,1]=np.copy(colored_img_data)\n\tcolor_array[:,2]=255\n\tcolor_array[img_data<threshold[0]] = baseColour\n\tcolor_array[img_data>threshold[1]] = [0,255,255]\n\n\tcmap_name = 'blue_lightblue'\n\tcmap_array = np.array(( np.zeros(256), np.linspace(0,255,256), (np.ones(256)*255))).T\n\tblb_cmap = colors.ListedColormap(cmap_array/255)\n\tif save_colorbar:\n\t\twrite_colorbar(threshold, blb_cmap, cmap_name, 'png')\n\t\tplt.clf()\n\treturn color_array\ntfce_mediation/pyfunc.py\ndef convert_mni_object(obj_file):\n\t# adapted from Jon Pipitone's script https://gist.github.com/pipitone/8687804\n\tobj = open(obj_file)\n\t_, _, _, _, _, _, numpoints = obj.readline().strip().split()\n\tnumpoints = int(numpoints)\n\tvertices=[]\n\tnormals=[]\n\ttriangles=[]\n\n\tfor i in range(numpoints):\n\t\tx, y, z = list(map(float,obj.readline().strip().split())) \n\t\tvertices.append((x, y, z))\n\tassert obj.readline().strip() == \"\"\n\t# numpoints normals as (x,y,z)\n\tfor i in range(numpoints):\n\t\tnormals.append(tuple(map(float,obj.readline().strip().split())))\n\n\tassert obj.readline().strip() == \"\"\n\tnt=int(obj.readline().strip().split()[0]) # number of triangles\n\t_, _, _, _, _ = obj.readline().strip().split()\n\tassert obj.readline().strip() == \"\"\n\t# rest of the file is a list of numbers\n\tpoints = list(map(int, \"\".join(obj.readlines()).strip().split()))\n\tpoints = points[nt:]\t# ignore these.. (whatever they are)\n\tfor i in range(nt): \n\t\ttriangles.append((points.pop(0), points.pop(0), points.pop(0)))\n\treturn np.array(vertices), np.array(triangles)\ntfce_mediation/pyfunc.py\ndef convert_fsannot(annot_name):\n\tlabels, ctab, names  = nib.freesurfer.read_annot(annot_name)\n\tlabels[labels==-1] = 0 # why is this necessary?????\n\tcolor_array = ctab[labels]\n\tcolor_array = color_array[:,:3]\n\twrite_annot_legend(ctab, names, annot_name)\n\treturn color_array\ntfce_mediation/pyfunc.py\ndef convert_gifti(gifti_surface):\n\timg = nib.load(gifti_surface)\n\tv, f = img.darrays[0].data, img.darrays[1].data\n\treturn v, f\ntfce_mediation/pyfunc.py\ndef convert_redtoyellow(threshold,img_data, baseColour=[227,218,201], save_colorbar = True):\n\tcolor_array = np.zeros((img_data.shape[0],3))\n\tcolor_cutoffs = np.linspace(threshold[0],threshold[1],256)\n\tcolored_img_data = np.zeros_like(img_data)\n\tcV=0\n\tfor k in img_data:\n\t\tcolored_img_data[cV] = np.searchsorted(color_cutoffs, k, side=\"left\")\n\t\tcV+=1\n\tcolor_array[:,0]=255\n\tcolor_array[:,1]=np.copy(colored_img_data)\n\tcolor_array[img_data<threshold[0]] = baseColour\n\tcolor_array[img_data>threshold[1]] = [255,255,0]\n\n\tcmap_name = 'red_yellow'\n\tcmap_array = np.array(( (np.ones(256)*255), np.linspace(0,255,256), np.zeros(256))).T\n\trl_cmap = colors.ListedColormap(cmap_array/255)\n\tif save_colorbar:\n\t\twrite_colorbar(threshold, rl_cmap, cmap_name, 'png')\n\t\tplt.clf()\n\treturn color_array\ntfce_mediation/pyfunc.py\ndef convert_mpl_colormaps(threshold,img_data, cmapName, baseColour=[227,218,201], save_colorbar = True):\n\tcmapFunc = plt.get_cmap(str(cmapName))\n\tcolor_array = np.zeros((img_data.shape[0],3))\n\tcolor_cutoffs = np.linspace(threshold[0],threshold[1],256)\n\tcV=0\n\tfor k in img_data:\n\t\ttemp_ = np.array(cmapFunc(np.searchsorted(color_cutoffs, k, side=\"left\")))*255\n\t\tcolor_array[cV,:] = ((np.around(temp_[0]), np.around(temp_[1]), np.around(temp_[2])))\n\t\tcV+=1\n\tcolor_array[img_data<threshold[0]] = baseColour\n\ttemp_ = np.array(cmapFunc(np.searchsorted(color_cutoffs, color_cutoffs[255], side=\"left\")))*255 # safer\n\tcolor_array[img_data>=threshold[1]] = ((int(temp_[0]), int(temp_[1]), int(temp_[2])))\n\tif save_colorbar:\n\t\twrite_colorbar(threshold, cmapFunc, cmapName, 'png')\n\t\tplt.clf()\n\treturn color_array\ntfce_mediation/pyfunc.py\ndef save_waveform(v,f, outname):\n\tif not outname.endswith('obj'):\n\t\toutname += '.obj'\n\toutname=check_outname(outname)\n\twith open(outname, \"a\") as o:\n\t\tfor i in range(len(v)):\n\t\t\to.write(\"v %1.6f %1.6f %1.6f\\n\" % (v[i,0],v[i,1], v[i,2]) )\n\t\tfor j in range(len(f)):\n\t\t\to.write(\"f %d %d %d\\n\" % (f[j,0],f[j,1], f[j,2]) )\n\t\to.close()\ntfce_mediation/pyfunc.py\ndef convert_fslabel(name_fslabel):\n\tobj = open(name_fslabel)\n\treader = obj.readline().strip().split()\n\treader = np.array(obj.readline().strip().split())\n\tif reader.ndim == 1:\n\t\tnum_vertex = reader[0].astype(np.int)\n\telse:\n\t\tprint('Error reading header')\n\tv_id = np.zeros((num_vertex)).astype(np.int)\n\tv_ras = np.zeros((num_vertex,3)).astype(np.float)\n\tv_value = np.zeros((num_vertex)).astype(np.float)\n\tfor i in range(num_vertex):\n\t\treader = obj.readline().strip().split()\n\t\tv_id[i] = np.array(reader[0]).astype(np.int)\n\t\tv_ras[i] = np.array(reader[1:4]).astype(np.float)\n\t\tv_value[i] = np.array(reader[4]).astype(np.float)\n\treturn (v_id, v_ras, v_value)\ntfce_mediation/pyfunc.py\ndef save_ply(v, f, outname, color_array=None, output_binary=True):\n\t# check file extension\n\tif not outname.endswith('ply'):\n\t\tif output_binary:\n\t\t\toutname += '.ply'\n\t\telse:\n\t\t\toutname += '.ascii.ply'\n\toutname=check_outname(outname)\n\n\t# write header \n\theader = (\"ply\\n\")\n\tif output_binary:\n\t\theader += (\"format binary_%s_endian 1.0\\n\" % (sys.byteorder))\n\t\tif sys.byteorder == 'little':\n\t\t\toutput_fmt = '<'\n\t\telse:\n\t\t\toutput_fmt = '>'\n\telse:\n\t\theader += (\"format ascii 1.0\\n\")\n\theader += (\"comment made with TFCE_mediation\\n\")\n\theader += (\"element vertex %d\\n\" % len(v))\n\theader += (\"property float x\\n\")\n\theader += (\"property float y\\n\")\n\theader += (\"property float z\\n\")\n\tif color_array is not None:\n\t\theader += (\"property uchar red\\n\")\n\t\theader += (\"property uchar green\\n\")\n\t\theader += (\"property uchar blue\\n\")\n\theader += (\"element face %d\\n\" % len(f))\n\theader += (\"property list uchar int vertex_index\\n\")\n\theader += (\"end_header\\n\")\n\n\t# write to file\n\twith open(outname, \"a\") as o:\n\t\to.write(header)\n\t\tfor i in range(len(v)):\n\t\t\tif output_binary:\n\t\t\t\tif color_array is not None:\n\t\t\t\t\to.write(\n\t\t\t\t\t\tstruct.pack(output_fmt + 'fffBBB', v[i, 0], v[i, 1], v[i, 2], color_array[i, 0], color_array[i, 1], color_array[i, 2]))\n\t\t\t\telse:\n\t\t\t\t\to.write(struct.pack(output_fmt + 'fff', v[i, 0], v[i, 1], v[i, 2]))\n\t\t\telse:\n\t\t\t\tif color_array is not None:\n\t\t\t\t\to.write(\"%1.6f %1.6f %1.6f %d %d %d\\n\" % (v[i, 0], v[i, 1], v[i, 2], color_array[i, 0], color_array[i, 1], color_array[i, 2]))\n\t\t\t\telse:\n\t\t\t\t\to.write(\"%1.6f %1.6f %1.6f\\n\" % (v[i, 0], v[i, 1], v[i, 2]))\n\t\tfor j in range(len(f)):\n\t\t\tif output_binary:\n\t\t\t\to.write(struct.pack('<Biii', 3, f[j, 0], f[j, 1], f[j, 2]))\n\t\t\telse:\n\t\t\t\to.write(\"3 %d %d %d\\n\" % (f[j, 0], f[j, 1], f[j, 2]))\ntfce_mediation/pyfunc.py\ndef convert_ply(name_ply):\n\telement = []\n\tsize = []\n\tvertex_info = []\n\tvertex_dtype = []\n\tface_dtype = []\n\tface_info = []\n\tvertex_property = 0\n\tface_property = 0\n\tply_ascii = False\n\n\tobj = open(name_ply)\n\treader = obj.readline().strip().split()\n\tfirstword = reader[0]\n\n\t# READ HEADER\n\twhile firstword != 'end_header':\n\t\treader = obj.readline().strip().split()\n\t\tfirstword = reader[0]\n\t\tif firstword == 'format':\n\t\t\tply_format = reader[1]\n\t\t\tif ply_format == 'binary_little_endian':\n\t\t\t\tply_format = '<'\n\t\t\telif ply_format == 'binary_big_endian':\n\t\t\t\tply_format = '>'\n\t\t\telse:\n\t\t\t\tply_ascii = True\n\t\tif firstword == 'element':\n\t\t\telement.append((reader[1]))\n\t\t\tsize.append((reader[2]))\n\t\t\tif reader[1] == 'vertex':\n\t\t\t\tvertex_property = 1\n\t\t\telse:\n\t\t\t\tvertex_property = 0\n\t\t\tif reader[1] == 'face':\n\t\t\t\tface_property = 1\n\t\t\telse:\n\t\t\t\tface_property = 0\n\t\tif reader[0] == 'property':\n\t\t\tif vertex_property == 1:\n\t\t\t\tvertex_dtype.append((reader[1]))\n\t\t\t\tvertex_info.append((reader[2]))\n\t\t\telif face_property == 1:\n\t\t\t\tface_dtype.append((reader[2]))\n\t\t\t\tface_dtype.append((reader[3]))\n\t\t\t\tface_info.append((reader[4]))\n\t\t\telse:\n\t\t\t\tprint(\"Unknown property\")\n\n\t# READ ELEMENTS\n\tfor e in range(len(element)):\n\t\t# VERTEX DATA\n\t\tif element[e] == 'vertex':\n\t\t\tv = np.zeros((int(size[e]), 3), dtype=np.float32)\n\t\t\tc = np.zeros((int(size[e]), 3), dtype=np.uint8)\n\t\t\tif ply_ascii:\n\t\t\t\tfor i in range(int(size[e])):\n\t\t\t\t\treader = obj.readline().strip().split()\n\t\t\t\t\tv[i, 0] = np.array(reader[0]).astype(np.float)\n\t\t\t\t\tv[i, 1] = np.array(reader[1]).astype(np.float)\n\t\t\t\t\tv[i, 2] = np.array(reader[2]).astype(np.float)\n\t\t\t\t\tif len(vertex_info) == 6:\n\t\t\t\t\t\tc[i, 0] = np.array(reader[3]).astype(np.uint8)\n\t\t\t\t\t\tc[i, 1] = np.array(reader[4]).astype(np.uint8)\n\t\t\t\t\t\tc[i, 2] = np.array(reader[5]).astype(np.uint8)\n\t\t\telse:\n\t\t\t\tstruct_fmt = ply_format\n\t\t\t\tfor i in range(len(vertex_dtype)):\n\t\t\t\t\tif vertex_dtype[i] == 'float':\n\t\t\t\t\t\tstruct_fmt += 'f'\n\t\t\t\t\tif vertex_dtype[i] == 'uchar':\n\t\t\t\t\t\tstruct_fmt += 'B'\n\t\t\t\t\tif vertex_dtype[i] == 'int':\n\t\t\t\t\t\tstruct_fmt += 'i'\n\t\t\t\tstruct_len = struct.calcsize(struct_fmt)\n\t\t\t\tstruct_unpack = struct.Struct(struct_fmt).unpack_from\n\t\t\t\tvcounter = 0\n\t\t\t\twhile vcounter != int(size[e]):\n\t\t\t\t\tif len(vertex_dtype) > 3:\n\t\t\t\t\t\ts = struct_unpack(obj.read(struct_len))\n\t\t\t\t\t\tv[vcounter] = s[:3]\n\t\t\t\t\t\tc[vcounter] = s[3:]\n\t\t\t\t\t\tvcounter += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\ts = struct_unpack(obj.read(struct_len))\n\t\t\t\t\t\tv[vcounter] = s[:3]\n\t\t\t\t\t\tvcounter += 1\n\t\t# FACE DATA\n\t\tif element[e] == 'face':\n\t\t\tif ply_ascii:\n\t\t\t\treader = obj.readline().strip().split()\n\t\t\t\tnumf = int(reader[0])\n\t\t\t\tf = np.zeros((int(size[e]), numf), dtype=np.int32)\n\t\t\t\tf[0] = reader[1:]\n\t\t\t\tfcounter = 1\n\t\t\t\twhile fcounter != int(size[e]):\n\t\t\t\t\treader = obj.readline().strip().split()\n\t\t\t\t\tf[fcounter] = reader[1:]\n\t\t\t\t\tfcounter += 1\n\t\t\telse:\n\t\t\t\tif face_dtype[0] == 'uchar':\n\t\t\t\t\tfcounter = 0\n\t\t\t\t\twhile fcounter != int(size[e]):\n\t\t\t\t\t\tstruct_unpack = struct.Struct(ply_format + 'B').unpack_from\n\t\t\t\t\t\tnumf = struct_unpack(obj.read(1))[0]\n\t\t\t\t\t\t# creates empty face array if it doesn't exists\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tf\n\t\t\t\t\t\texcept NameError:\n\t\t\t\t\t\t\tf = np.zeros((int(size[e]), numf), dtype=np.int32)\n\t\t\t\t\t\tstruct_fmt = ply_format\n\t\t\t\t\t\tfor i in range(int(numf)):\n\t\t\t\t\t\t\tstruct_fmt += 'i'\n\t\t\t\t\t\tstruct_len = struct.calcsize(struct_fmt)\n\t\t\t\t\t\tstruct_unpack = struct.Struct(struct_fmt).unpack_from\n\t\t\t\t\t\ts = struct_unpack(obj.read(struct_len))\n\t\t\t\t\t\tf[fcounter] = s\n\t\t\t\t\t\tfcounter += 1\n\treturn (v, f, c)\ntfce_mediation/pyfunc.py\ndef save_fs(v,f, outname):\n\tif not outname.endswith('srf'):\n\t\toutname += '.srf'\n\toutname=check_outname(outname)\n\tnib.freesurfer.io.write_geometry(outname, v, f)\ntfce_mediation/pyfunc.py\ndef convert_voxel(img_data, affine = None, threshold = None, data_mask = None, absthreshold = None):\n\t\"\"\"\n\tConverts a voxel image to a surface including outputs voxel values to paint vertex surface.\n\t\n\tParameters\n\t----------\n\timg_data : array\n\t\timage array\n\taffine : array\n\t\t affine [4x4] to convert vertices values to native space (Default = None)\n\tdata_mask : array\n\t\tuse a mask to create a surface backbone (Default = None)\n\tthreshold : float\n\t\tthreshold for output of voxels (Default = None)\n\tabsthreshold : float\n\t\tthreshold for output of abs(voxels) (Default = None)\n\t\t\n\tReturns\n\t-------\n\t\tv : array\n\t\t\tvertices\n\t\tf : array\n\t\t\tfaces\n\t\tvalues : array\n\t\t\tscalar values\n\t\n\t\"\"\"\n\ttry:\n\t\tfrom skimage import measure\n\texcept:\n\t\tprint(\"Error skimage is required\")\n\t\tquit()\n\n\tif threshold is not None:\n\t\tprint(\"Zeroing data less than threshold = %1.2f\" % threshold)\n\t\timg_data[img_data<threshold] = 0\n\tif absthreshold is not None:\n\t\tprint(\"Zeroing absolute values less than threshold = %1.2f\" % absthreshold)\n\t\timg_data[np.abs(img_data)<absthreshold] = 0\n\tif data_mask is not None:\n\t\tprint(\"Including mask\")\n\t\tdata_mask *= .1\n\t\tdata_mask[img_data!=0] = img_data[img_data!=0]\n\t\tdel img_data\n\t\timg_data = np.copy(data_mask)\n\ttry:\n\t\tv, f, _, values = measure.marching_cubes_lewiner(img_data)\n\t\tif affine is not None:\n\t\t\tprint(\"Applying affine transformation\")\n\t\t\tv = nib.affines.apply_affine(affine,v)\n\texcept:\n\t\tprint(\"No voxels above threshold\")\n\t\tv = f = values = []\n\treturn v, f, values\ntfce_mediation/tm_io.py\ndef savemgh_v2(image_array, index, imagename, affine=None):\n\tif not imagename.endswith('mgh'):\n\t\timagename += '.mgh'\n\toutdata = image_array.astype(np.float32, order = \"C\")\n\tif image_array.ndim == 1:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2]))\n\t\timgout[index]=outdata\n\telif image_array.shape[1] > 1:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2],image_array.shape[1]))\n\t\timgout[index]=outdata\n\telse:\n\t\timgout = np.zeros((index.shape[0],index.shape[1],index.shape[2]))\n\t\timgout[index]=outdata[:,0]\n\tnib.save(nib.freesurfer.mghformat.MGHImage(imgout.astype(np.float32, order = \"C\"),affine=affine),imagename)\n", "answers": ["\t\tv,f = convert_fs(str(opts.inputfreesurfer[0]))"], "length": 2047, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "4827ff2b613068a75697610c1c3d4ac77a8befeba28544ef"}
{"input": "import functools\nimport random\n  from gevent.lock import RLock # pylint: disable=E0611\n  from gevent.coros import RLock\nfrom .base import (\n  LoadBalancerSink,\n  NoMembersError\n)\nfrom ..asynchronous import AsyncResult\nfrom ..constants import (\n  ChannelState,\n  Int,\n  MessageProperties,\n  SinkProperties,\n  SinkRole\n)\nfrom ..sink import (\n  FailingMessageSink,\n  SinkProvider,\n)\nfrom ..varz import (\n  Counter,\n  Gauge,\n  Source,\n  VarzBase\n)\n\n    heap[i], heap[j] = heap[j], heap[i]\n    heap[i].index = i\n    heap[j].index = j\n\n  @staticmethod\n  def FixUp(heap, i):\n    \"\"\"Traverse up the heap, ensuring the invariant is maintained.\n\n    Args:\n      heap - The heap array.\n      i - The index to start at.\n    \"\"\"\n    while True:\n      if i != 1 and heap[i] < heap[i//2]:\n        Heap.Swap(heap, i, i//2)\n        i //= 2 # FixUp(heap, i/2)\n      else:\n        break\n\n  @staticmethod\n  def FixDown(heap, i, j):\n    \"\"\"Traverse down the heap, ensuring the invariant is maintained.\n\n    Args:\n      heap - The heap array.\n      i, j - The node index to traverse from -> to.\n    \"\"\"\n    while True:\n      if j < i * 2: break\n\n      m = 2 * i if (j == i * 2 or heap[2*i] < heap[2*i+1]) else 2*i+1\n      if heap[m] < heap[i]:\n        Heap.Swap(heap, i, m)\n        i = m  # FixDown(heap, m, j)\n      else:\n        break\n\n\ndef synchronized(fn):\n  \"\"\"Runs the wrapped method under a lock.\n  The self parameter to the wrapped function is expected to have a __heap_lock\n  attribute.\n  \"\"\"\n  @functools.wraps(fn)\n  def wrapper(self, *args, **kwargs):\n    with self._heap_lock:\n      return fn(self, *args, **kwargs)\n  return wrapper\n\n\nclass HeapBalancerSink(LoadBalancerSink):\n  \"\"\"A sink that implements a heap load balancer.\"\"\"\n  Penalty = Int.MaxValue\n  Idle = Int.MinValue + 1\n\n  class HeapVarz(VarzBase):\n    \"\"\"\n    size - The number of nodes in the pool\n    no_members - The number of times the balancer served a failing requests\n                 because there were no members in the pool.\n    \"\"\"\n    _VARZ_BASE_NAME = 'scales.loadbalancer.Heap'\n    _VARZ = {\n      'size': Gauge,\n      'no_members': Counter\n    }\n\n  class Node(object):\n    __slots__ = ('load', 'index', 'downq', 'avg_load', 'channel', 'endpoint')\n\n    def __init__(self, channel, load, index, endpoint):\n      self.channel = channel\n      self.avg_load = 0\n      self.load = load\n      self.index = index\n      self.downq = None\n      self.endpoint = endpoint\n\n    def __lt__(self, other):\n      \"\"\"Compare to other, return true if (load, index) < other.(load, index)\"\"\"\n      if self.load > other.load:\n        return False\n      elif self.load < other.load:\n        return True\n      else:\n        return self.index < other.index\n\n  def __init__(self, next_provider, sink_properties, global_properties):\n    self._heap = [self.Node(\n        FailingMessageSink(functools.partial(Exception, \"this sink should never be used\")),\n        self.Idle, 0, None)]\n    self._no_members = FailingMessageSink(NoMembersError)\n    self._downq = None\n    self._size = 0\n    self._open = False\n    self._heap_lock = RLock()\n    service_name = global_properties[SinkProperties.Label]\n    self.__varz = self.HeapVarz(Source(service=service_name))\n    super(HeapBalancerSink, self).__init__(next_provider, sink_properties, global_properties)\n\n  def _AsyncProcessRequestImpl(self, sink_stack, msg, stream, headers):\n    if self._size == 0:\n      channel = self._no_members\n      self.__varz.no_members()\n    else:\n      with self._heap_lock:\n        n = self.__Get()\n        n.load += 1\n        Heap.FixDown(self._heap, n.index, self._size)\n        self._OnGet(n)\n\n      put_called = [False]\n      def PutWrapper():\n        if not put_called[0]:\n          with self._heap_lock:\n            put_called[0] = True\n            self.__Put(n)\n      sink_stack.Push(self, PutWrapper)\n\n", "context": "scales/loadbalancer/base.py\nclass NoMembersError(Exception): pass\nscales/constants.py\nclass SinkProperties(object):\r\n  Endpoint = 'endpoint'\r\n  ServiceInterface = 'service_iface'\r\n  Label = 'label'\r\nscales/constants.py\nclass ChannelState(object):\r\n  Idle = 1\r\n  Open = 2\r\n  Busy = 3\r\n  Closed = 4\r\nscales/sink.py\nclass FailingMessageSink(ClientMessageSink):\n  \"\"\"A sink that always returns a failure message.\"\"\"\n\n  def __init__(self, ex):\n    self._ex = ex\n    super(FailingMessageSink, self).__init__()\n\n  def AsyncProcessRequest(self, sink_stack, msg, stream, headers):\n    msg = MethodReturnMessage(error=self._ex())\n    sink_stack.AsyncProcessResponseMessage(msg)\n\n  def AsyncProcessResponse(self, sink_stack, context, stream, msg):\n    raise NotImplementedError(\"This should never be called\")\n\n  @property\n  def state(self):\n    return ChannelState.Open\n\n  @property\n  def endpoint(self):\n    return None\nscales/loadbalancer/base.py\nclass LoadBalancerSink(ClientMessageSink):\n  \"\"\"Base class for all load balancer sinks.\"\"\"\n  Role = SinkRole.LoadBalancer\n\n  def __init__(self, next_provider, sink_properties, global_properties):\n    self._properties = global_properties\n    service_name = global_properties[SinkProperties.Label]\n    server_set_provider = sink_properties.server_set_provider\n    log_name = self.__class__.__name__.replace('ChannelSink', '')\n    self._log = ROOT_LOG.getChild('%s.[%s]' % (log_name, service_name))\n    self.__init_done = Event()\n    self.__open_ar = None\n    self.__open_greenlet = None\n    self._server_set_provider = server_set_provider\n    self._endpoint_name = server_set_provider.endpoint_name\n    self._next_sink_provider = next_provider\n    self._state = ChannelState.Idle\n    self._servers = {}\n    super(LoadBalancerSink, self).__init__()\n\n  @property\n  def state(self):\n    return self._state\n\n  def Open(self):\n    if self.__open_ar:\n      return self.__open_ar\n\n    self.__open_ar = AsyncResult()\n    self.__open_greenlet = gevent.spawn(self._OpenImpl)\n    return self.__open_ar\n\n  def _OpenImpl(self):\n    while self._state != ChannelState.Closed:\n      try:\n        self._server_set_provider.Initialize(\n            self.__OnServerSetJoin,\n            self.__OnServerSetLeave)\n        server_set = self._server_set_provider.GetServers()\n      except gevent.GreenletExit:\n        return\n      except:\n        self._log.exception(\"Unable to initialize serverset, retrying in 5 seconds.\")\n        gevent.sleep(5)\n        continue\n\n      random.shuffle(server_set)\n      self._servers = {}\n      [self.__AddServer(m) for m in server_set]\n      self.__init_done.set()\n      self._OpenInitialChannels()\n      self._open_greenlet = None\n      self._state = ChannelState.Open\n      return True\n\n  @abstractmethod\n  def _OpenInitialChannels(self):\n    \"\"\"To be overriden by subclasses.  Called after the ServerSet is initialized\n    and the initial set of servers has been loaded.\n    \"\"\"\n    pass\n\n  def _OnOpenComplete(self):\n    \"\"\"To be called by subclasses when they've completed (successfully or not)\n    opening their sinks.\n    \"\"\"\n    self.__open_ar.set(True)\n\n  def WaitForOpenComplete(self, timeout=None):\n    self.__open_ar.wait(timeout)\n\n  def Close(self):\n    self._server_set_provider.Close()\n    self._state = ChannelState.Closed\n    self.__init_done.clear()\n    if self.__open_greenlet:\n      self.__open_greenlet.kill(block=False)\n      self.__open_greenlet = None\n    self.__open_ar = None\n\n  @abstractmethod\n  def _AsyncProcessRequestImpl(self, sink_stack, msg, stream, headers):\n    pass\n\n  def AsyncProcessRequest(self, sink_stack, msg, stream, headers):\n    if not self.__open_ar.ready():\n      def _on_open_done(_):\n        timeout_event = msg.properties.get(Deadline.EVENT_KEY, None)\n        # Either there is no timeout, or the timeout hasn't expired yet.\n        if not timeout_event or not timeout_event.Get():\n          self._AsyncProcessRequestImpl(sink_stack, msg, stream, headers)\n      self.__open_ar.rawlink(_on_open_done)\n    else:\n      self._AsyncProcessRequestImpl(sink_stack, msg, stream, headers)\n\n  def __GetEndpoint(self, instance):\n    if self._endpoint_name:\n      aeps = instance.additional_endpoints\n      ep = aeps.get(self._endpoint_name, None)\n      if not ep:\n        raise ValueError(\n            \"Endpoint name %s not found in endpoints\", self._endpoint_name)\n      return ep\n    else:\n      return instance.service_endpoint\n\n  def _OnServersChanged(self, endpoint, channel_factory, added):\n    \"\"\"Overridable by child classes.  Invoked when servers in the server set are\n    added or removed.\n\n    Args:\n      instance - The server set member being added or removed.\n      added - True if the instance is being added, False if it's being removed.\n    \"\"\"\n    pass\n\n  def __AddServer(self, instance):\n    \"\"\"Adds a servers to the set of servers available to the load balancer.\n    Note: The new sink is not opened at this time.\n\n    Args:\n      instance - A Member object to be added to the pool.\n    \"\"\"\n    ep = self.__GetEndpoint(instance)\n    if not ep in self._servers:\n      new_props = self._properties.copy()\n      new_props.update({ SinkProperties.Endpoint: ep })\n      channel_factory = functools.partial(self._next_sink_provider.CreateSink, new_props)\n      self._servers[ep] = channel_factory\n      self._log.info(\"Instance %s joined (%d members)\" % (\n        ep, len(self._servers)))\n      self._OnServersChanged(ep, channel_factory, True)\n\n  def __RemoveServer(self, instance):\n    \"\"\"Removes a server from the load balancer.\n\n    Args:\n      instance - A Member object to be removed from the pool.\n    \"\"\"\n    ep = self.__GetEndpoint(instance)\n    channel_factory = self._servers.pop(ep, None)\n    self._OnServersChanged(ep, channel_factory, False)\n\n  def __OnServerSetJoin(self, instance):\n    \"\"\"Invoked when an instance joins the server set.\n\n    Args:\n      instance - Instance added to the cluster.\n    \"\"\"\n    # callbacks from the ServerSet are delivered serially, so we can guarantee\n    # that once this unblocks, we'll still get the notifications delivered in\n    # the order that they arrived.  Ex: OnJoin(a) -> OnLeave(a)\n    self.__init_done.wait()\n    # OnJoin notifications are delivered at startup, however we already\n    # pre-populate our copy of the ServerSet, so it's fine to ignore duplicates.\n    if self.__GetEndpoint(instance) in self._servers:\n      return\n\n    self.__AddServer(instance)\n\n  def __OnServerSetLeave(self, instance):\n    \"\"\"Invoked when an instance leaves the server set.\n\n    Args:\n      instance - Instance leaving the cluster.\n    \"\"\"\n    self.__init_done.wait()\n    self.__RemoveServer(instance)\n\n    self._log.info(\"Instance %s left (%d members)\" % (\n        self.__GetEndpoint(instance), len(self._servers)))\nscales/constants.py\nclass SinkRole(object):\r\n  Transport = 'transport'\r\n  Pool = 'pool'\r\n  LoadBalancer = 'loadbalancer'\r\n  Formatter = 'formatter'\r\nscales/constants.py\nclass Int(object):\r\n  MaxValue = 2147483647\r\n  MinValue = -2147483648\r\nscales/varz.py\nclass VarzType(object):\nclass Source(object):\nclass VarzMetric(object):\nclass Gauge(VarzMetric): VARZ_TYPE = VarzType.Gauge\nclass Rate(VarzMetric): VARZ_TYPE = VarzType.Rate\nclass AverageRate(VarzMetric): VARZ_TYPE = VarzType.AverageRate\nclass Counter(Rate): VARZ_TYPE = VarzType.Counter\nclass VarzTimerBase(VarzMetric):\nclass AverageTimer(VarzTimerBase): VARZ_TYPE = VarzType.AverageTimer\nclass AggregateTimer(VarzTimerBase): VARZ_TYPE = VarzType.AggregateTimer\nclass VarzMeta(type):\nclass _VarzBase(object):\nclass _SampleSet(object):\nclass VarzReceiver(object):\nclass VarzAggregator(object):\n  class _Agg(object):\nclass VarzSocketWrapper(object):\n  class Varz(VarzBase):\nclass MonoClock(object):\nclass Ema(object):\n  def __init__(self, method=None, service=None, endpoint=None, client_id=None):\n  def to_tuple(self):\n  def to_dict(self):\n  def __cmp__(self, other):\n  def __hash__(self):\n  def _Adapt(fn):\n    def __Adapt(metric, source, amount=1):\n  def __init__(self, metric, source):\n  def __call__(self, *args):\n  def ForSource(self, source):\n  def Measure(self, source=None):\n  def __new__(mcs, name, bases, dct):\ndef VerifySource(source):\n  def __init__(self, source):\n  def __getattr__(self, item):\n  def __init__(self, max_size, data=None, p=.1):\n  def Sample(self, value):\n  def RegisterMetric(metric, varz_type):\n  def IncrementVarz(source, metric, amount=1):\n  def SetVarz(source, metric, value):\n  def RecordPercentileSample(cls, source, metric, value):\ndef DefaultKeySelector(k):\n    def __init__(self):\n  def CalculatePercentile(values, pct):\n  def _Downsample(lst, target_size):\n  def Aggregate(varz, metrics, key_selector=None):\n  def __init__(self, socket, varz_tag):\n  def host(self):\n  def port(self):\n  def isOpen(self):\n  def read(self, sz):\n  def recv_into(self, buf, sz):\n  def flush(self):\n  def write(self, buff):\n  def open(self):\n  def close(self):\n  def readAll(self, sz):\n  def __init__(self):\n  def Sample(self):\n  def __init__(self, window):\n  def Update(self, ts, sample):\n  VARZ_TYPE = None\nclass Gauge(VarzMetric): VARZ_TYPE = VarzType.Gauge\nclass Rate(VarzMetric): VARZ_TYPE = VarzType.Rate\nclass AverageRate(VarzMetric): VARZ_TYPE = VarzType.AverageRate\nclass Counter(Rate): VARZ_TYPE = VarzType.Counter\nclass AverageTimer(VarzTimerBase): VARZ_TYPE = VarzType.AverageTimer\nclass AggregateTimer(VarzTimerBase): VARZ_TYPE = VarzType.AggregateTimer\n  _VARZ = {}\n  _VARZ_BASE_NAME = None\n  VARZ_METRICS = {}\n  VARZ_DATA = defaultdict(lambda: defaultdict(int))\n  VARZ_PERCENTILES = [.5, .90, .99, .999, .9999]\n  _MAX_PERCENTILE_SIZE = 1000\n  MAX_AGG_AGE = 5 * 60\n    _VARZ_BASE_NAME = 'scales.socket'\n    _VARZ = {\n      'bytes_recv': Rate,\n      'bytes_sent': Rate,\n      'num_connections': Counter,\n      'tests_failed': Counter,\n      'connects': Rate,\n      'open_latency': AverageTimer\n    }\nscales/sink.py\ndef SinkProvider(sink_cls, role=None, **defaults):\n  \"\"\"Factory for creating simple sink providers.\n\n  Args:\n    sink_cls - The type of sink to provide.\n  Returns:\n    A SinkProvider that provides sinks of type 'sink_cls'.\n  \"\"\"\n  field_names = ' '.join(defaults.keys())\n  params_cls = namedtuple('Params', field_names)\n\n  def CreateSink(self, properties):\n    return self.SINK_CLASS(self.next_provider, self.sink_properties, properties)\n\n  def sink_class(self):\n    return self.SINK_CLASS\n\n  provider = type(\n    sink_cls.__name__ + 'Provider',\n    (SinkProviderBase, ),\n    {\n      'SINK_CLASS': sink_cls,\n      'PARAMS_CLASS': params_cls,\n      'Role': role,\n      'CreateSink': CreateSink,\n      'sink_class': property(sink_class),\n      '_defaults': defaults\n    }\n  )\n  return provider\nscales/constants.py\nclass MessageProperties(object):\r\n  Endpoint = '__Endpoint'\r\nscales/asynchronous.py\nclass AsyncResult(g_AsyncResult):\n  @staticmethod\n  def WhenAll(ars):\n    \"\"\"Returns an AsyncResult representing the state of all AsyncResults passed.\n\n    Args:\n      ars - An enumerable of AsyncResults.\n    Returns:\n      An AsyncResult representing the completion of all ars passed in.  When all\n      complete, the AsyncResult will be set to an array of the results of each\n      AsyncResult, in the order they were enumerated in.\n      If any AsyncResult fails, the return result will fail.\n    \"\"\"\n\n    ret = AsyncResult()\n    num_ars = len(ars)\n    total = [num_ars]\n    results = [None] * num_ars\n    def complete(_n, _ar):\n      if _ar.exception:\n        ret.set_exception(_ar.exception)\n      elif not ret.ready():\n        total[0] -= 1\n        results[_n] = _ar.value\n        if total[0] == 0:\n          ret.set(results)\n\n    for n, ar in enumerate(ars):\n      ar.rawlink(functools.partial(complete, n))\n    return ret\n\n  @staticmethod\n  def WhenAny(ars):\n    \"\"\"Returns an AsyncResult representing the state of any AsyncResult passed in.\n    The return value represents the state of the first AsyncResult to complete, or,\n    if all fail, the last to fail.\n\n    Args:\n      ars - An enumerable of AsyncResults.\n    Returns:\n      An AsyncResult representing the state of the first AsyncResult to complete.\n      The AsyncResult's value will be set to the value of the first result to\n      complete, or, if all fail, the exception thrown by the last to fail.\n    \"\"\"\n    ready_ars = [ar for ar in ars if ar.ready()]\n    if ready_ars:\n      return ready_ars[0]\n\n    ret = AsyncResult()\n    total = [len(ars)]\n    def complete(_ar):\n      total[0] -= 1\n      if total[0] == 0 and _ar.exception:\n        ret.set_exception(_ar.exception)\n      elif not ret.ready() and _ar.successful():\n        ret.set(_ar.value)\n\n    for ar in ars:\n      ar.rawlink(complete)\n    return ret\n\n  @staticmethod\n  def FromValue(val):\n    if val is None:\n      return AsyncResult.Complete()\n    else:\n      ar = AsyncResult()\n      ar.set(val)\n      return ar\n\n  @staticmethod\n  def Complete():\n    \"\"\"Return an AsyncResult that has completed.\"\"\"\n    return _COMPLETE\n\n  @staticmethod\n  def CompleteIn(n):\n    \"\"\"Returns an AsyncResult that completes in <n> seconds\n\n    Args:\n      n - The number of seconds to wait before completing.\n    \"\"\"\n    ar = AsyncResult()\n    def helper():\n      ar.set()\n    g = Greenlet(helper)\n    g.start_later(float(n))\n    return ar\n\n  def _SafeLinkHelper(self, fn):\n    try:\n      self.set(fn())\n    except:\n      self.set_exception(sys.exc_info()[1])\n\n  def SafeLink(self, fn):\n    \"\"\"Propagate the result of calling fn() on a new greenlet to ar\n\n    Args:\n      ar - An AsyncResult.\n      fn - The function to execute.\n    \"\"\"\n    gevent.spawn(self._SafeLinkHelper, fn)\n\n  def ContinueWith(self, fn, on_hub=True):\n    cw_ar = AsyncResult()\n    def continue_with_callback(_ar):\n      def run():\n        try:\n          val = fn(_ar)\n          cw_ar.set(val)\n        except:\n          cw_ar.set_exception(sys.exc_info()[1])\n      if on_hub:\n        run()\n      else:\n        gevent.spawn(run)\n    self.rawlink(continue_with_callback)\n    return cw_ar\n\n  def Map(self, fn):\n    def mapper(_):\n      if self.exception:\n        return self\n      else:\n        return fn(self.value)\n    return self.ContinueWith(mapper).Unwrap()\n\n  def _UnwrapHelper(self, target):\n    if self.ready():\n      # We're ready, propagate the result\n      if self.exception:\n        target.set_exception(self.exception)\n      else:\n        if isinstance(self.value, AsyncResult):\n          self.value._UnwrapHelper(target)\n        else:\n          target.set(self.value)\n    else:\n      self.rawlink(\n        functools.partial(AsyncResult._UnwrapHelper, target=target))\n\n  def Unwrap(self):\n    unwrapped_ar = AsyncResult()\n    self._UnwrapHelper(unwrapped_ar)\n    return unwrapped_ar\n\n  @staticmethod\n  def TryGet(val):\n    if isinstance(val, AsyncResult):\n      return val.get()\n    else:\n      return val\n\n  @staticmethod\n  def Run(fn):\n    ar = AsyncResult()\n    ar.SafeLink(fn)\n    return ar\n\n  @staticmethod\n  def RunInline(fn):\n    ar = AsyncResult()\n    ar._SafeLinkHelper(fn)\n    return ar\n", "answers": ["      msg.properties[MessageProperties.Endpoint] = n.endpoint"], "length": 1863, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "d3e06b7c06b53895a9f8832f583702defd61235a3fb53cf6"}
{"input": "import struct\nimport sys\nfrom ..exceptions import PyOrientBadMethodCallException, \\\n    PyOrientCommandException, PyOrientNullRecordException\nfrom ..otypes import OrientRecord, OrientRecordLink, OrientNode\nfrom ..hexdump import hexdump\nfrom ..constants import BOOLEAN, BYTE, BYTES, CHAR, FIELD_BOOLEAN, FIELD_BYTE, \\\n    FIELD_INT, FIELD_RECORD, FIELD_SHORT, FIELD_STRING, FIELD_TYPE_LINK, INT, \\\n    LINK, LONG, RECORD, SHORT, STRING, STRINGS\nfrom ..utils import is_debug_active\nfrom ..orient import OrientSocket\nfrom ..serializations import OrientSerialization\n        from .connection import ConnectMessage\n        from .database import DbOpenMessage\n\n            # this flag can be set more than once\n            while end_flag == 3:\n                self._decode_field( FIELD_INT )  # FAKE SESSION ID = 2^-31\n                op_code = self._decode_field( FIELD_BYTE )  # 80: 0x50 Request Push\n\n                # REQUEST_PUSH_RECORD\t        79\n                # REQUEST_PUSH_DISTRIB_CONFIG\t80\n                # REQUEST_PUSH_LIVE_QUERY\t    81\n                if op_code == 80:\n                    # for node in\n                    payload = self.get_serializer().decode(\n                        self._decode_field( FIELD_STRING )\n                    )  # JSON WITH THE NEW CLUSTER CFG\n\n                    # reset the nodelist\n                    self._node_list = []\n                    for node in payload['members']:\n                        self._node_list.append( OrientNode( node ) )\n\n                end_flag = self._decode_field( FIELD_BYTE )\n\n            # Try to set the new session id???\n            self._header[1] = self._decode_field( FIELD_INT )  # REAL SESSION ID\n            pass\n\n        \"\"\"\n        #  Token authentication handling\n        #  we must recognize ConnectMessage and DbOpenMessage messages\n            TODO: change this check avoiding cross import,\n            importing a subclass in a super class is bad\n        \"\"\"\n        if not isinstance(self, (ConnectMessage, DbOpenMessage)) \\\n                and self._request_token is True:\n            token_refresh = self._decode_field(FIELD_STRING)\n            if token_refresh != b'':\n                self._auth_token = token_refresh\n                self._update_socket_token()\n\n    def _decode_body(self):\n        # read body\n        for field in self._fields_definition:\n            self._body.append( self._decode_field( field ) )\n\n        # clear field stack\n        self._reset_fields_definition()\n        return self\n\n    def _decode_all(self):\n        self._decode_header()\n        self._decode_body()\n\n    def fetch_response(self, *_continue):\n        \"\"\"\n        # Decode header and body\n        # If flag continue is set( Header already read ) read only body\n        :param _continue:\n        :return:\n        \"\"\"\n        if len(_continue) is not 0:\n            self._body = []\n            self._decode_body()\n            self.dump_streams()\n        # already fetched, get last results as cache info\n        elif len(self._body) is 0:\n            self._decode_all()\n            self.dump_streams()\n        return self._body\n\n    def dump_streams(self):\n        if is_debug_active():\n            if len( self._output_buffer ):\n                print(\"\\nRequest :\")\n                hexdump( self._output_buffer )\n                # print(repr(self._output_buffer))\n            if len( self._input_buffer ):\n                print(\"\\nResponse:\")\n                hexdump( self._input_buffer )\n                # print(repr(self._input_buffer))\n\n    def _append(self, field):\n        \"\"\"\n        @:rtype self: BaseMessage\n        @type field: object\n        \"\"\"\n        self._fields_definition.append( field )\n        return self\n\n    def __str__(self):\n\n        return \"\\n_output_buffer: \\n\" + hexdump( self._output_buffer, 'return' ) \\\n               + \"\\n\\n_input_buffer: \\n\" + hexdump( self._input_buffer, 'return' )\n\n    def send(self):\n        if self._orientSocket.in_transaction is False:\n            self._orientSocket.write( self._output_buffer )\n            self._reset_fields_definition()\n        if is_debug_active():\n            self.dump_streams()\n            # reset output buffer\n            self._output_buffer = b\"\"\n\n        return self\n\n    def close(self):\n        self._orientSocket.close()\n\n    @staticmethod\n    def _encode_field(field):\n\n        # tuple with type\n        t, v = field\n        _content = None\n\n        if t['type'] == INT:\n            _content = struct.pack(\"!i\", v)\n        elif t['type'] == SHORT:\n            _content = struct.pack(\"!h\", v)\n        elif t['type'] == LONG:\n            _content = struct.pack(\"!q\", v)\n", "context": "pyorient/constants.py\nRECORD  = 8\npyorient/constants.py\nINT     = 4\npyorient/constants.py\nFIELD_BOOLEAN = {\"type\": BOOLEAN, \"bytes\": 1, \"struct\": None}\npyorient/constants.py\nFIELD_STRING = {\"type\": STRING, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nFIELD_TYPE_LINK = {\"type\": LINK, \"bytes\": None, \"struct\": [\n    FIELD_SHORT,  # record_clusterID\n    FIELD_LONG,   # record_position\n]}\npyorient/otypes.py\nclass OrientRecord(object):\n    \"\"\"\n    Object that represent an Orient Document / Record\n\n    \"\"\"\n    oRecordData = property(lambda self: self.__o_storage)\n\n    def __str__(self):\n        rep = \"\"\n        if self.__o_storage:\n            rep = str( self.__o_storage )\n        if self.__o_class is not None:\n            rep = \"'@\" + str(self.__o_class) + \"':\" + rep + \"\"\n        if self.__version is not None:\n            rep = rep + \",'version':\" + str(self.__version)\n        if self.__rid is not None:\n            rep = rep + \",'rid':'\" + str(self.__rid) + \"'\"\n        return '{' + rep + '}'\n\n    @staticmethod\n    def addslashes(string):\n        l = [ \"\\\\\", '\"', \"'\", \"\\0\", ]\n        for i in l:\n            if i in string:\n                string = string.replace( i, '\\\\' + i )\n        return string\n\n    def __init__(self, content=None):\n\n        self.__rid = None\n        self.__version = None\n        self.__o_class = None\n        self.__o_storage = {}\n\n        if not content:\n            content = {}\n        for key in content.keys():\n            if key == '__rid':  # Ex: select @rid, field from v_class\n                self.__rid = content[ key ]\n                # self.__rid = OrientRecordLink( content[ key ][ 1: ] )\n            elif key == '__version':  # Ex: select @rid, @version from v_class\n                self.__version = content[key]\n            elif key == '__o_class':\n                self.__o_class = content[ key ]\n            elif key[0:1] == '@':\n                # special case dict\n                # { '@my_class': { 'accommodation': 'hotel' } }\n                self.__o_class = key[1:]\n                for _key, _value in content[key].items():\n                    if isinstance(_value, basestring):\n                        self.__o_storage[_key] = self.addslashes( _value )\n                    else:\n                        self.__o_storage[_key] = _value\n            elif key == '__o_storage':\n                self.__o_storage = content[key]\n            else:\n                self.__o_storage[key] = content[key]\n\n    def _set_keys(self, content=dict):\n        for key in content.keys():\n                self._set_keys( content[key] )\n\n    @property\n    def _in(self):\n        try:\n            return self.__o_storage['in']\n        except KeyError:\n            return None\n\n    @property\n    def _out(self):\n        try:\n            return self.__o_storage['out']\n        except KeyError:\n            return None\n\n    @property\n    def _rid(self):\n        return self.__rid\n\n    @property\n    def _version(self):\n        return self.__version\n\n    @property\n    def _class(self):\n        return self.__o_class\n\n    def update(self, **kwargs):\n        self.__rid = kwargs.get('__rid', None)\n        self.__version = kwargs.get('__version', None)\n        if self.__o_class is None:\n            self.__o_class = kwargs.get('__o_class', None)\n\n    \"\"\" This method is for backward compatibility when someone\n        use 'getattr(record, a_key)' \"\"\"\n    def __getattr__(self, item):\n        \"\"\"\n        :param item: string\n        :return: mixed\n        :raise: AttributeError\n        \"\"\"\n        try:\n            return self.__o_storage[item]\n        except KeyError:\n            raise AttributeError( \"'OrientRecord' object has no attribute \"\n                                  \"'\" + item + \"'\" )\npyorient/exceptions.py\nclass PyOrientCommandException(PyOrientException):\n    pass\npyorient/serializations.py\nclass OrientSerialization(object):\n    \"\"\"\n    Enum representing the available serialization\n    \"\"\"\n    #: CSV the default serialization\n    CSV = \"ORecordDocument2csv\"\n\n    #: Now unimplemented\n    Binary = \"ORecordSerializerBinary\"\n\n    @classmethod\n    def get_impl(cls, impl, props=None):\n        impl_map = {\n            cls.CSV: OrientSerializationCSV,\n            cls.Binary: OrientSerializationBinary,\n        }\n        implementation = impl_map.get(impl, False)\n        if not implementation:\n            raise PyOrientBadMethodCallException(\n                impl + ' is not an available serialization type', []\n            )\n        if impl == cls.Binary:\n            if not binary_support:\n                raise Exception( \"To support Binary Serialization, pyorient_native must be installed\" )\n            return implementation(props)\n        else:\n            return implementation()\npyorient/constants.py\nBYTE    = 2\npyorient/constants.py\nFIELD_RECORD = {\"type\": RECORD, \"bytes\": None, \"struct\": [\n    FIELD_CHAR,   # record_type\n    FIELD_SHORT,  # record_clusterID\n    FIELD_LONG,   # record_position\n    FIELD_INT,    # record_version\n    FIELD_BYTES   # record_content\n]}\npyorient/hexdump.py\ndef hexdump(data, result='print'):\n    \"\"\"\n    Transform binary data to the hex dump text format:\n\n    00000000: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................\n\n      [x] data argument as a binary string\n      [x] data argument as a file like object\n\n    Returns result depending on the `result` argument:\n      'print'     - prints line by line\n      'return'    - returns single string\n      'generator' - returns generator that produces lines\n    \"\"\"\n    if PY3K and type(data) == str:\n        raise TypeError('Abstract unicode data (expected bytes sequence)')\n\n    gen = dumpgen(data)\n    if result == 'generator':\n        return gen\n    elif result == 'return':\n        return '\\n'.join(gen)\n    elif result == 'print':\n        for line in gen:\n            print(line)\n    else:\n        raise ValueError('Unknown value of `result` argument')\npyorient/constants.py\nSTRING  = 7\npyorient/constants.py\nLINK    = 11\npyorient/constants.py\nFIELD_SHORT = {\"type\": SHORT, \"bytes\": 2, \"struct\": None}\npyorient/orient.py\nclass OrientSocket(object):\n    '''Class representing the binary connection to the database, it does all the low level comunication\n    And holds information on server version and cluster map\n\n    .. DANGER::\n      Should not be used directly\n\n    :param host: hostname of the server to connect\n    :param port: integer port of the server\n\n    '''\n    def __init__(self, host, port, serialization_type=OrientSerialization.CSV ):\n\n        self.connected = False\n        self.host = host\n        self.port = port\n        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.protocol = -1\n        self.session_id = -1\n        self.auth_token = b''\n        self.db_opened = None\n        self.serialization_type = serialization_type\n        self.in_transaction = False\n        self._props = None\n\n    def get_connection(self):\n        if not self.connected:\n            self.connect()\n\n        return self._socket\n\n    def connect(self):\n        '''Connects to the inner socket\n        could raise :class:`PyOrientConnectionPoolException`\n        '''\n        dlog(\"Trying to connect...\")\n        try:\n            self._socket.settimeout( SOCK_CONN_TIMEOUT )  # 30 secs of timeout\n            self._socket.connect( (self.host, self.port) )\n            _value = self._socket.recv( FIELD_SHORT['bytes'] )\n\n            if len(_value) != 2:\n                self._socket.close()\n\n                raise PyOrientConnectionPoolException(\n                    \"Server sent empty string\", []\n                )\n\n            self.protocol = struct.unpack('!h', _value)[0]\n            if self.protocol > SUPPORTED_PROTOCOL:\n                raise PyOrientWrongProtocolVersionException(\n                    \"Protocol version \" + str(self.protocol) +\n                    \" is not supported yet by this client.\", [])\n            self.connected = True\n        except socket.error as e:\n            self.connected = False\n            raise PyOrientConnectionException( \"Socket Error: %s\" % e, [] )\n\n    def close(self):\n        '''Close the inner connection\n        '''\n        self.host = ''\n        self.port = 0\n        self.protocol = -1\n        self.session_id = -1\n        self._socket.close()\n        self.connected = False\n\n    def write(self, buff):\n        # This is a trick to detect server disconnection\n        # or broken line issues because of\n        \"\"\":see: https://docs.python.org/2/howto/sockets.html#when-sockets-die \"\"\"\n\n        try:\n            _, ready_to_write, in_error = select.select(\n                [], [self._socket], [self._socket], 1)\n        except select.error as e:\n            self.connected = False\n            self._socket.close()\n            raise e\n\n        if not in_error and ready_to_write:\n            self._socket.sendall(buff)\n            return len(buff)\n        else:\n            self.connected = False\n            self._socket.close()\n            raise PyOrientConnectionException(\"Socket error\", [])\n\n    # The man page for recv says: The receive calls normally return\n    #   any data available, up to the requested amount, rather than waiting\n    #   for receipt of the full amount requested.\n    #\n    # If you need to read a given number of bytes, you need to call recv\n    #   in a loop and concatenate the returned packets until\n    #   you have read enough.\n    def read(self, _len_to_read):\n\n        while True:\n\n            # This is a trick to detect server disconnection\n            # or broken line issues because of\n            \"\"\":see: https://docs.python.org/2/howto/sockets.html#when-sockets-die \"\"\"\n            try:\n                ready_to_read, _, in_error = \\\n                    select.select( [self._socket, ], [], [self._socket, ], 30 )\n            except select.error as e:\n                self.connected = False\n                self._socket.close()\n                raise e\n\n            if len(ready_to_read) > 0:\n\n                buf = bytearray(_len_to_read)\n                view = memoryview(buf)\n                while _len_to_read:\n                    n_bytes = self._socket.recv_into(view, _len_to_read)\n                    if not n_bytes:\n                        self._socket.close()\n                        # TODO Implement re-connection to another listener\n\n                        raise PyOrientConnectionException(\n                            \"Server seems to have went down\", [])\n\n                    view = view[n_bytes:]  # slicing views is cheap\n                    _len_to_read -= n_bytes\n                return bytes(buf)\n\n            if len(in_error) > 0:\n                self._socket.close()\n                raise PyOrientConnectionException(\n                    \"Socket error\", [])\npyorient/constants.py\nBOOLEAN = 1  # Single byte: 1 = true, 0 = false\npyorient/otypes.py\nclass OrientNode(object):\n    def __init__(self, node_dict=None):\n        \"\"\"\n        Represent a server node in a multi clusered configuration\n\n        TODO: extends this object with different listeners if we're going to support in the driver an abstarction of the HTTP protocol, for now we are not interested in that\n\n        :param node_dict: dict with starting configs (usaully from a db_open, db_reload record response)\n        \"\"\"\n        #: node name\n        self.name = None\n\n        #: node is\n        self.id = None\n\n        #: datetime object the node was started\n        self.started_on = None\n\n        #: binary listener host\n        self.host = None\n\n        #: binary lister port\n        self.port = None\n\n        if node_dict is not None:\n            self._parse_dict(node_dict)\n\n    def _parse_dict(self, node_dict):\n        self.id = node_dict['id']\n        self.name = node_dict['name']\n        self.started_on = node_dict['startedOn']\n        listener = None\n        for l in node_dict['listeners']:\n            if l['protocol'] == 'ONetworkProtocolBinary':\n                listener = l\n                break\n\n        if listener:\n            listen = listener['listen'].split(':')\n            self.host = listen[0]\n            self.port = listen[1]\n\n    def __str__(self):\n        return self.name\npyorient/constants.py\nSHORT   = 3\npyorient/constants.py\nSTRINGS = 9\npyorient/constants.py\nFIELD_BYTE = {\"type\": BYTE, \"bytes\": 1, \"struct\": None}\npyorient/otypes.py\nclass OrientRecordLink(object):\n    def __init__(self, recordlink):\n        cid, rpos = recordlink.split(\":\")\n        self.__link = recordlink\n        self.clusterID = cid\n        self.recordPosition = rpos\n\n    def __str__(self):\n        return self.get_hash()\n\n    def get(self):\n        return self.__link\n\n    def get_hash(self):\n        return \"#%s\" % self.__link\npyorient/constants.py\nCHAR    = 10\npyorient/constants.py\nLONG    = 5\npyorient/exceptions.py\nclass PyOrientBadMethodCallException(PyOrientException):\n    pass\npyorient/constants.py\nBYTES   = 6  # Used for binary data.\npyorient/constants.py\nFIELD_INT = {\"type\": INT, \"bytes\": 4, \"struct\": None}\npyorient/exceptions.py\nclass PyOrientNullRecordException(PyOrientException):\n    pass\n", "answers": ["        elif t['type'] == BOOLEAN:"], "length": 1727, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "9d912c9ff24198c839f9847ca95470d7b95e994ccf65622f"}
{"input": "package fr.insee.eno.main;\nimport java.io.File;\nimport org.junit.jupiter.api.Test;\nimport fr.insee.eno.generation.DDI2FOGenerator;\nimport fr.insee.eno.postprocessing.Postprocessor;\nimport fr.insee.eno.postprocessing.fo.FOEditStructurePagesPostprocessor;\nimport fr.insee.eno.postprocessing.fo.FOInsertAccompanyingMailsPostprocessor;\nimport fr.insee.eno.postprocessing.fo.FOInsertCoverPagePostprocessor;\nimport fr.insee.eno.postprocessing.fo.FOInsertEndQuestionPostprocessor;\nimport fr.insee.eno.postprocessing.fo.FOMailingPostprocessor;\nimport fr.insee.eno.postprocessing.fo.FOSpecificTreatmentPostprocessor;\nimport fr.insee.eno.postprocessing.fo.FOTableColumnPostprocessorFake;\nimport fr.insee.eno.service.GenerationService;\nimport fr.insee.eno.preprocessing.DDICleaningPreprocessor;\nimport fr.insee.eno.preprocessing.DDIDereferencingPreprocessor;\nimport fr.insee.eno.preprocessing.DDIMarkdown2XhtmlPreprocessor;\nimport fr.insee.eno.preprocessing.DDIMultimodalSelectionPreprocessor;\nimport fr.insee.eno.preprocessing.DDITitlingPreprocessor;\nimport fr.insee.eno.preprocessing.Preprocessor;\n\n\n\n\npublic class DummyTestDDI2FO {\n\t\n\tprivate DDI2FOGenerator ddi2fo = new DDI2FOGenerator();\n\t\n\t@Test\n\tpublic void mainTest() {\t\t\n\t\tString basePathDDI2FO = \"src/test/resources/ddi-to-fo\";\n\t\t\n\t\tPreprocessor[] preprocessors = {\n\n\t\t\t\tnew DDIMultimodalSelectionPreprocessor(),\n\t\t\t\tnew DDIMarkdown2XhtmlPreprocessor(),\n\t\t\t\tnew DDIDereferencingPreprocessor(),\n\t\t\t\tnew DDICleaningPreprocessor(),\n\t\t\t\tnew DDITitlingPreprocessor()};\n\t\t\n\t\tPostprocessor[] postprocessors = { \n\t\t\t\tnew FOMailingPostprocessor(),\n\t\t\t\tnew FOTableColumnPostprocessorFake(),\n\t\t\t\tnew FOInsertEndQuestionPostprocessor(),\n\t\t\t\tnew FOEditStructurePagesPostprocessor(),\n\t\t\t\tnew FOSpecificTreatmentPostprocessor(),\n\t\t\t\tnew FOInsertCoverPagePostprocessor(),", "context": "src/main/java/fr/insee/eno/postprocessing/Postprocessor.java\npublic interface Postprocessor {\n\n\tFile process(File input, byte[] parametersFile, String survey) throws Exception;\n\n\tdefault File process(File input, byte[] parametersFile, byte[] metadata, String survey) throws Exception{\n\t\treturn this.process(input,parametersFile,survey);\n\t}\n\t\n\tdefault File process(File input, byte[] parametersFile, byte[] metadata, byte[] specificTreatmentXsl, String survey) throws Exception{\n\t\treturn this.process(input,parametersFile,metadata,survey);\n\t}\n\t\n\tdefault File process(File input, byte[] parametersFile, byte[] metadata, byte[] specificTreatmentXsl, byte[] mapping, String survey) throws Exception{\n\t\treturn this.process(input,parametersFile,metadata,specificTreatmentXsl,survey);\n\t}\n\t\n\tpublic String toString();\n}\nsrc/main/java/fr/insee/eno/preprocessing/DDIMarkdown2XhtmlPreprocessor.java\npublic class DDIMarkdown2XhtmlPreprocessor implements Preprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(DDIMarkdown2XhtmlPreprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.UTIL_DDI_MD2XHTML_XSL;\n\n\t@Override\n\tpublic File process(File input, byte[] parameters, String survey, String in2out) throws Exception {\n\n\t\tlogger.info(\"DDIMarkdown2XhtmlPreprocessor Target : START\");\n\t\tString md2xhtmlOutput = FilenameUtils.removeExtension(input.getPath()) + Constants.MD_EXTENSION;\n\t\t// ----- mw2xhtml\n\t\tlogger.debug(\"Markdown to XHTML : -Input : \" + input + \" -Output : \" + md2xhtmlOutput + \" -Stylesheet : \"\n\t\t\t\t+ Constants.UTIL_DDI_MD2XHTML_XSL + \" -Parameters : \" + Constants.sUB_TEMP_FOLDER(survey));\n\n\t\tInputStream isDDI_MW2XHTML_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\t\tInputStream isInputFile = FileUtils.openInputStream(input);\n\n\t\tOutputStream osTEMP_NULL_TMP = FileUtils.openOutputStream(new File(md2xhtmlOutput));\n\n\t\ttry {\n\t\t\tsaxonService.transformMw2XHTML(isInputFile, isDDI_MW2XHTML_XSL, osTEMP_NULL_TMP,\n\t\t\t\t\tConstants.SUB_TEMP_FOLDER_FILE(survey));\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the Markdown2Xhtml transformation. %s : %s\",\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\t\tisInputFile.close();\n\t\tisDDI_MW2XHTML_XSL.close();\n\t\tosTEMP_NULL_TMP.close();\n\n\t\t// ----- tweak-xhtml-for-ddi\n\t\t// tweak-xhtml-for-ddi-input = mw2xhtml-output\n\n\t\tString outputTweakXhtmlForDdi = FilenameUtils.removeExtension(input.getPath()) + Constants.MD2_EXTENSION;\n\n\t\tlogger.debug(\"Tweak-xhtml-for-ddi : -Input : \" + md2xhtmlOutput + \" -Output : \" + outputTweakXhtmlForDdi\n\t\t\t\t+ \" -Stylesheet : \" + Constants.UTIL_DDI_TWEAK_XHTML_FOR_DDI_XSL + \" -Parameters : \"\n\t\t\t\t+ (parameters == null ? \"Default parameters\" : \"Provided parameters\"));\n\n\t\tInputStream isTweakXhtmlForDdi = FileUtils.openInputStream(new File(md2xhtmlOutput));\n\t\tInputStream isUTIL_DDI_TWEAK_XHTML_FOR_DDI_XSL = Constants\n\t\t\t\t.getInputStreamFromPath(Constants.UTIL_DDI_TWEAK_XHTML_FOR_DDI_XSL);\n\t\tOutputStream osTweakXhtmlForDdi = FileUtils.openOutputStream(new File(outputTweakXhtmlForDdi));\n\t\ttry {\n\t\t\tsaxonService.transformTweakXhtmlForDdi(isTweakXhtmlForDdi, isUTIL_DDI_TWEAK_XHTML_FOR_DDI_XSL,\n\t\t\t\t\tosTweakXhtmlForDdi, Constants.SUB_TEMP_FOLDER_FILE(survey));\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = \"An error has occurred during the Markdown2Xhtml transformation. \"+e.getMessage();\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\t\tisTweakXhtmlForDdi.close();\n\t\tisUTIL_DDI_TWEAK_XHTML_FOR_DDI_XSL.close();\n\t\tosTweakXhtmlForDdi.close();\n\n\t\tlogger.debug(\"DDIMarkdown2XhtmlPreprocessor : END\");\n\t\treturn new File(outputTweakXhtmlForDdi);\n\n\t}\n\n}\nsrc/main/java/fr/insee/eno/preprocessing/DDIDereferencingPreprocessor.java\npublic class DDIDereferencingPreprocessor implements Preprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(DDIDereferencingPreprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.UTIL_DDI_DEREFERENCING_XSL;\n\n\t@Override\n\tpublic File process(File inputFile, byte[] parametersFile, String survey, String in2out) throws Exception {\n\t\tlogger.info(\"DDIPreprocessing Target : START\");\n\n\t\tString sUB_TEMP_FOLDER = Constants.sUB_TEMP_FOLDER(survey);\n\t\t// ----- Dereferencing\n\t\tlogger.debug(\"Dereferencing : -Input : \" + inputFile + \" -Output : \" + Constants.tEMP_NULL_TMP(sUB_TEMP_FOLDER)\n\t\t+ \" -Stylesheet : \" + styleSheetPath + \" -Parameters : \" + sUB_TEMP_FOLDER);\n\n\t\tInputStream isDDI_DEREFERENCING_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\t\tInputStream isInputFile = FileUtils.openInputStream(inputFile);\n\t\tOutputStream osTEMP_NULL_TMP = FileUtils.openOutputStream(Constants.tEMP_NULL_TMP(sUB_TEMP_FOLDER));\n\n\t\ttry {\n\t\t\tsaxonService.transformDereferencing(isInputFile, isDDI_DEREFERENCING_XSL, osTEMP_NULL_TMP,\n\t\t\t\t\tConstants.SUB_TEMP_FOLDER_FILE(survey));\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\ttoString(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\n\t\tisInputFile.close();\n\t\tisDDI_DEREFERENCING_XSL.close();\n\t\tosTEMP_NULL_TMP.close();\n\t\t// ----- Cleaning\n\t\tlogger.debug(\"Cleaning target\");\n\t\tFile f = Constants.SUB_TEMP_FOLDER_FILE(survey);\n\t\tFile[] matchCleaningInput = f.listFiles(new FilenameFilter() {\n\n\t\t\t@Override\n\t\t\tpublic boolean accept(File dir, String name) {\n\t\t\t\treturn !(name.startsWith(\"null\")||name.contains(\"-modal\")) && name.endsWith(\".tmp\");\n\t\t\t}\n\t\t});\n\n\t\tString cleaningInput = null;\n\n\t\tlogger.debug(\"Searching matching files in : \" + sUB_TEMP_FOLDER);\n\t\tfor (File file : matchCleaningInput) {\n\t\t\tif(!file.isDirectory()) {\n\t\t\t\tcleaningInput = file.getAbsolutePath();\n\t\t\t\tlogger.debug(\"Found : \" + cleaningInput);\n\t\t\t}\n\t\t}\n\t\tif(cleaningInput==null) {\n\t\t\tthrow new EnoGenerationException(\"DDIDereferencing produced no file.\");\n\t\t}\n\n\t\tlogger.debug(\"DDIPreprocessing Dereferencing : END\");\n\t\treturn new File(cleaningInput);\n\t}\n\n\tpublic String toString() {\n\t\treturn PreProcessing.DDI_DEREFERENCING.name();\n\t}\n\n\n}\nsrc/main/java/fr/insee/eno/generation/DDI2FOGenerator.java\npublic class DDI2FOGenerator implements Generator {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(DDI2FOGenerator.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.TRANSFORMATIONS_DDI2FO_DDI2FO_XSL;\n\n\t@Override\n\tpublic File generate(File finalInput, byte[] parameters, String surveyName) throws Exception {\n\t\tlogger.info(\"DDI2FO Target : START\");\n\t\tlogger.debug(\"Arguments : finalInput : \" + finalInput + \" surveyName \" + surveyName);\n\t\tString formNameFolder = null;\n\t\tString outputBasicFormPath = null;\n\n\t\tformNameFolder = getFormNameFolder(finalInput);\n\n\t\tlogger.debug(\"formNameFolder : \" + formNameFolder);\n\n\t\toutputBasicFormPath = Constants.TEMP_FOLDER_PATH + \"/\" + surveyName + \"/\" + formNameFolder + \"/form\";\n\t\tlogger.debug(\"Output folder for basic-form : \" + outputBasicFormPath);\n\n\t\tString outputForm = outputBasicFormPath + \"/form.fo\";\n\n\n\t\ttry (InputStream isTRANSFORMATIONS_DDI2FO_DDI2PDF_XSL = Constants\n\t\t\t\t.getInputStreamFromPath(styleSheetPath);\n\t\t\t InputStream isFinalInput = FileUtils.openInputStream(finalInput);\n\t\t\t\tOutputStream osOutputForm = FileUtils.openOutputStream(new File(outputForm));) {\n\t\t\t\n\t\t\tsaxonService.transformDDI2FO(isFinalInput, osOutputForm, isTRANSFORMATIONS_DDI2FO_DDI2PDF_XSL, parameters);\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\tin2out(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\n\t\treturn new File(outputForm);\n\t}\n\n\t/**\n\t * @param finalInput\n\t * @return\n\t */\n\tprivate String getFormNameFolder(File finalInput) {\n\t\tString formNameFolder;\n\t\tformNameFolder = FilenameUtils.getBaseName(finalInput.getAbsolutePath());\n\t\tformNameFolder = FilenameUtils.removeExtension(formNameFolder);\n\t\tformNameFolder = formNameFolder.replace(XslParameters.TITLED_EXTENSION, \"\");\n\t\treturn formNameFolder;\n\t}\n\n\tpublic String in2out() {\n\t\treturn \"ddi2fo\";\n\t}\n\n}\nsrc/main/java/fr/insee/eno/preprocessing/DDIMultimodalSelectionPreprocessor.java\npublic class DDIMultimodalSelectionPreprocessor implements Preprocessor {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(DDIMultimodalSelectionPreprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.UTIL_DDI_MULTIMODAL_SELECTION_XSL;\n\n\t@Override\n\tpublic File process(File inputFile, byte[] parametersFile, String survey, String in2out) throws Exception {\n\t\tlogger.info(\"DDIPreprocessing Target : START\");\n\n\t\tString sUB_TEMP_FOLDER = Constants.sUB_TEMP_FOLDER(survey);\n\t\tString modalSelectionOutput=null;\n\t\tString multimodalInput = inputFile.getAbsolutePath();\n\t\tmodalSelectionOutput = sUB_TEMP_FOLDER + \"\\\\\" + FilenameUtils.getBaseName(multimodalInput) + Constants.MULTIMODAL_EXTENSION;\n\n\t\tlogger.debug(\"Modal DDI output file to be created : \" + modalSelectionOutput);\n\t\tlogger.debug(\"Multimodal Selection : -Input : \" + multimodalInput + \" -Output : \" + modalSelectionOutput + \" -Stylesheet : \"\n\t\t\t\t+ styleSheetPath + \" -Parameters : \" + (parametersFile == null ? \"Default parameters\" : \"Provided parameters\"));\n\n\t\tInputStream isMultimodalIn = FileUtils.openInputStream(new File(multimodalInput));\n\t\tOutputStream osModalSelection = FileUtils.openOutputStream(new File(modalSelectionOutput));\n\t\tInputStream isUTIL_DDI_MULTIMODAL_SELECTION_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\n\t\ttry {\n\t\t\tsaxonService.transformModalSelection(isMultimodalIn, isUTIL_DDI_MULTIMODAL_SELECTION_XSL, osModalSelection, parametersFile);\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error has occurred during the %s transformation. %s : %s\",\n\t\t\t\t\ttoString(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\n\t\tisMultimodalIn.close();\n\t\tisUTIL_DDI_MULTIMODAL_SELECTION_XSL.close();\n\t\tosModalSelection.close();\n\n\t\tlogger.debug(\"DDIPreprocessing Multimodal Selection: END\");\n\t\treturn new File(modalSelectionOutput);\n\t}\n\n\tpublic String toString() {\n\t\treturn PreProcessing.DDI_MULTIMODAL_SELECTION.name();\n\t}\n\n\t\n}\nsrc/main/java/fr/insee/eno/preprocessing/DDITitlingPreprocessor.java\npublic class DDITitlingPreprocessor implements Preprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(DDITitlingPreprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.UTIL_DDI_TITLING_XSL;\n\n\t@Override\n\tpublic File process(File inputFile, byte[] parametersFile, String survey, String in2out) throws Exception {\n\t\tlogger.info(\"DDIPreprocessing Target : START\");\n\n\t\tString outputTitling = null;\n\t\tString titlingInput = inputFile.getAbsolutePath();\n\n\t\toutputTitling = titlingInput.replace(Constants.CLEANED_EXTENSION, Constants.FINAL_EXTENSION);\n\n\t\tlogger.debug(\"Titling : -Input : \" + titlingInput + \" -Output : \" + outputTitling + \" -Stylesheet : \"\n\t\t\t\t+ styleSheetPath + \" -Parameters : \"\n\t\t\t\t+ (parametersFile == null ? \"Default parameters\" : \"Provided parameters\"));\n\n\t\tInputStream isCleaningTitling = FileUtils.openInputStream(new File(titlingInput));\n\t\tInputStream isUTIL_DDI_TITLING_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\t\tOutputStream osTitling = FileUtils.openOutputStream(new File(outputTitling));\n\n\t\ttry {\n\t\t\tsaxonService.transformTitling(isCleaningTitling, isUTIL_DDI_TITLING_XSL, osTitling, parametersFile);\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\ttoString(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\n\t\tisCleaningTitling.close();\n\t\tisUTIL_DDI_TITLING_XSL.close();\n\t\tosTitling.close();\n\t\tlogger.debug(\"DDIPreprocessing titling: END\");\n\t\treturn new File(outputTitling);\n\t}\n\n\tpublic String toString() {\n\t\treturn PreProcessing.DDI_TITLING.name();\n\t}\n\n}\nsrc/main/java/fr/insee/eno/postprocessing/fo/FOSpecificTreatmentPostprocessor.java\npublic class FOSpecificTreatmentPostprocessor implements Postprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(FOSpecificTreatmentPostprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\t@Override\n\tpublic File process(File input, byte[] parameters, String survey) throws Exception {\n\t\treturn this.process(input, parameters, null, null, survey);\n\t}\n\n\t@Override\n\tpublic File process(File input, byte[] parametersFile, byte[] metadata, String survey) throws Exception {\n\t\treturn this.process(input, parametersFile, metadata, null, survey);\n\t}\n\n\t@Override\n\tpublic File process(File input, byte[] parametersFile, byte[] metadata, byte[] specificTreatmentXsl, String survey) throws Exception {\n\n\t\tFile outputForFOFile = new File(input.getParent(),\n\t\t\t\tConstants.BASE_NAME_FORM_FILE +\n\t\t\t\tConstants.SPECIFIC_TREAT_PDF_EXTENSION);\n\t\tlogger.debug(\"Output folder for basic-form : \" + outputForFOFile.getAbsolutePath());\n\n\t\tInputStream specificTreatmentXslIS = null;\n\n\t\tif(specificTreatmentXsl!=null) {\n\t\t\tspecificTreatmentXslIS = new ByteArrayInputStream(specificTreatmentXsl);\n\t\t\tInputStream inputStream = FileUtils.openInputStream(input);\n\t\t\tOutputStream outputStream = FileUtils.openOutputStream(outputForFOFile);\n\n\t\t\ttry {\n\t\t\t\tsaxonService.transformWithPDFSpecificTreatment(inputStream, outputStream, specificTreatmentXslIS, parametersFile);\n\t\t\t}catch(Exception e) {\n\t\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\t\ttoString(),\n\t\t\t\t\t\te.getMessage(),\n\t\t\t\t\t\tUtils.getErrorLocation(\"specific file passed in params\",e));\n\t\t\t\tlogger.error(errorMessage);\n\t\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t\t}\n\t\t\tinputStream.close();\n\t\t\toutputStream.close();\n\t\t\tspecificTreatmentXslIS.close();\n\n\t\t}\n\t\telse {\n\t\t\tlogger.info(\"Not specific treatment in params : simply copying this file\" + input.getAbsolutePath());\n\t\t\tFileUtils.copyFile(input, outputForFOFile);\n\t\t}\n\t\tlogger.info(\"End of specific treatment post-processing \" + outputForFOFile.getAbsolutePath());\n\n\t\treturn outputForFOFile;\n\t}\n\n\tpublic String toString() {\n\t\treturn PostProcessing.FO_SPECIFIC_TREATMENT.name();\n\t}\n\n}\nsrc/main/java/fr/insee/eno/service/GenerationService.java\npublic class GenerationService {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(GenerationService.class);\n\n\tprivate final Preprocessor[] preprocessors;\n\tprivate final Generator generator;\n\tprivate final Postprocessor[] postprocessors;\n\n\tprivate byte[] parameters;\n\tprivate byte[] metadata;\n\tprivate byte[] specificTreatment;\n\tprivate byte[] mapping;\n\t\n\tprivate boolean cleaningFolder;\n\n\t@Inject\n\tpublic GenerationService(final Preprocessor[] preprocessors, final Generator generator,\n\t\t\tfinal Postprocessor[] postprocessors) {\n\t\tthis.preprocessors = preprocessors;\n\t\tthis.generator = generator;\n\t\tthis.postprocessors = postprocessors;\n\t\tthis.cleaningFolder = true;\n\t}\n\n\t@Inject\n\tpublic GenerationService(final Preprocessor preprocessor, final Generator generator,\n\t\t\tfinal Postprocessor[] postprocessors) {\n\t\tthis.preprocessors = new Preprocessor[] { preprocessor };\n\t\tthis.generator = generator;\n\t\tthis.postprocessors = postprocessors;\n\t\tthis.cleaningFolder = true;\n\t}\n\n\t@Inject\n\tpublic GenerationService(final Preprocessor preprocessor, final Generator generator,\n\t\t\tfinal Postprocessor postprocessor) {\n\t\tthis.preprocessors = new Preprocessor[] { preprocessor };\n\t\tthis.generator = generator;\n\t\tthis.postprocessors = new Postprocessor[] { postprocessor };\n\t\tthis.cleaningFolder = true;\n\t}\n\n\t/**\n\t * Launch every step needed in order to generate the target questionnaire.\n\t * \n\t * @param inputFile\n\t *            The source file\n\t * \n\t * @return The generated file\n\t * @throws Exception\n\t *             bim\n\t */\n\tpublic File generateQuestionnaire(File inputFile, String surveyName) throws Exception {\n\t\tlogger.info(this.toString());\n\t\tlogger.info(\"Generating questionnaire for: \" + surveyName);\n\n\t\tString tempFolder = System.getProperty(\"java.io.tmpdir\") + \"/\" + surveyName;\n\t\tlogger.debug(\"Temp folder: \" + tempFolder);\n\t\tif(cleaningFolder) {\n\t\t\tcleanTempFolder(surveyName);\n\t\t}\n\t\tFile preprocessResultFileName = null;\n\t\t\n\t\tpreprocessResultFileName = this.preprocessors[0].process(inputFile, parameters, surveyName,generator.in2out());\t\n\t\t\n\t\tfor (int i = 1; i < preprocessors.length; i++) {\n\t\t\tpreprocessResultFileName = this.preprocessors[i].process(preprocessResultFileName, parameters, surveyName,\n\t\t\t\t\tgenerator.in2out());\n\t\t}\n\n\t\tFile generatedForm = this.generator.generate(preprocessResultFileName, parameters, surveyName);\n\t\tFile outputForm = this.postprocessors[0].process(generatedForm, parameters, metadata, specificTreatment, mapping, surveyName);\n\t\tfor (int i = 1; i < postprocessors.length; i++) {\n\t\t\toutputForm = this.postprocessors[i].process(outputForm, parameters, metadata, specificTreatment, mapping,surveyName);\n\t\t}\n\t\tFile finalForm = new File(outputForm.getParent()+Constants.BASE_NAME_FORM_FILE+\".\"+FilenameUtils.getExtension(outputForm.getAbsolutePath()));\n\t\tif(!finalForm.equals(outputForm)) {\n\t\t\tFiles.move(outputForm, finalForm);\n\t\t}\n\t\tlogger.debug(\"Path to generated questionnaire: \" + finalForm.getAbsolutePath());\n\n\t\treturn finalForm;\n\t}\n\t\n\t\n\tpublic void setParameters(ByteArrayOutputStream parametersBAOS) {\n\t\tthis.parameters = parametersBAOS.toByteArray();\n\t}\t\n\n\tpublic void setParameters(InputStream parametersIS) throws IOException {\n\t\tif(parametersIS!=null) {\n\t\t\tthis.parameters = IOUtils.toByteArray(parametersIS);\n\t\t}\n\t}\n\t\n\tpublic void setMetadata(InputStream metadataIS) throws IOException {\n\t\tif(metadataIS!=null) {\n\t\t\tthis.metadata = IOUtils.toByteArray(metadataIS);\n\t\t}\n\t}\n\t\n\tpublic void setSpecificTreatment(InputStream specificTreatmentIS) throws IOException {\n\t\tif(specificTreatmentIS!=null) {\n\t\t\tthis.specificTreatment = IOUtils.toByteArray(specificTreatmentIS);\n\t\t}\n\t}\n\t\n\tpublic void setMapping(InputStream mappingIS) throws IOException {\n\t\tif(mappingIS!=null) {\n\t\t\tthis.mapping = IOUtils.toByteArray(mappingIS);\n\t\t}\n\t}\n\n\tpublic byte[] getParameters() {\n\t\treturn parameters;\n\t}\n\tpublic byte[] getMetadata() {\n\t\treturn metadata;\n\t}\n\tpublic byte[] getSpecificTreatment() {\n\t\treturn specificTreatment;\n\t}\n\tpublic byte[] getMapping() {\n\t\treturn mapping;\n\t}\n\t\n\tpublic void setCleaningFolder(boolean cleaning) {\n\t\tthis.cleaningFolder = cleaning;\n\t}\n\t\n\n\n\t/**\n\t * Clean the temp dir if it exists\n\t * \n\t * @throws IOException\n\t * \n\t */\n\tpublic void cleanTempFolder(String name) throws IOException {\n\t\tif (Constants.TEMP_FOLDER_PATH != null) {\n\t\t\tFile folderTemp = new File(Constants.TEMP_FOLDER_PATH + \"/\" + name);\n\t\t\tcleanTempFolder(folderTemp);\n\t\t} else {\n\t\t\tlogger.debug(\"Temp Folder is null\");\n\t\t}\n\t}\n\n\t/**\n\t * Clean the temp dir if it exists\n\t * \n\t * @throws IOException\n\t * \n\t */\n\tpublic void cleanTempFolder() throws IOException {\n\t\tif (Constants.TEMP_FOLDER_PATH != null) {\n\t\t\tFile folderTemp = new File(Constants.TEMP_FOLDER_PATH);\n\t\t\tcleanTempFolder(folderTemp);\n\t\t} else {\n\t\t\tlogger.debug(\"Temp Folder is null\");\n\t\t}\n\t}\n\n\t/**\n\t * Clean the temp dir if it exists\n\t * \n\t * @throws IOException\n\t * \n\t */\n\tprivate void cleanTempFolder(File folder) throws IOException {\n\t\tFolderCleaner cleanService = new FolderCleaner();\n\t\tif (folder != null) {\n\t\t\tcleanService.cleanOneFolder(folder);\n\t\t} else {\n\t\t\tlogger.debug(\"Temp Folder is null\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"GenerationService [preprocessors=\" + Arrays.toString(preprocessors) + \", generator=\" + generator.in2out()\n\t\t\t\t+ \", postprocessors=\" + Arrays.toString(postprocessors) + \"]\";\n\t}\n\t\n\t\n\n}\nsrc/main/java/fr/insee/eno/postprocessing/fo/FOMailingPostprocessor.java\npublic class FOMailingPostprocessor implements Postprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(FOMailingPostprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.TRANSFORMATIONS_CUSTOMIZATION_FO_4PDF_2;\n\n\t@Override\n\tpublic File process(File input, byte[] parameters, String surveyName) throws Exception {\n\n\t\tFile outputForFOFile = new File(input.getParent(),\n\t\t\t\tConstants.BASE_NAME_FORM_FILE +\n\t\t\t\tConstants.MAILING_FO_EXTENSION);\n\t\tlogger.debug(\"Output folder for basic-form : \" + outputForFOFile.getAbsolutePath());\t\n\t\t\n\n\t\tInputStream FO_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\t\t\n\t\tInputStream inputStream = FileUtils.openInputStream(input);\n\t\tOutputStream outputStream = FileUtils.openOutputStream(outputForFOFile);\n\t\ttry {\n\t\t\tsaxonService.transformFOToStep1FO(inputStream, outputStream, FO_XSL);\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\ttoString(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\t\t\n\t\tinputStream.close();\n\t\toutputStream.close();\n\t\tFO_XSL.close();\n\t\tlogger.info(\"End of Mailing post-processing : \");\n\n\t\treturn outputForFOFile;\n\t}\n\n\tpublic String toString() {\n\t\treturn PostProcessing.FO_MAILING.name();\n\t}\n\n}\nsrc/main/java/fr/insee/eno/postprocessing/fo/FOEditStructurePagesPostprocessor.java\npublic class FOEditStructurePagesPostprocessor implements Postprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(FOEditStructurePagesPostprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.TRANSFORMATIONS_EDIT_STRUCTURE_PAGES_FO_4PDF;\n\n\t@Override\n\tpublic File process(File input, byte[] parameters, String survey) throws Exception {\n\n\t\tFile outputForFOFile = new File(input.getParent(),\n\t\t\t\tConstants.BASE_NAME_FORM_FILE +\n\t\t\t\tConstants.EDIT_STRUCTURE_FO_EXTENSION);\n\t\tlogger.debug(\"Output folder for basic-form : \" + outputForFOFile.getAbsolutePath());\n\n\t\tString surveyName = survey;\n\t\tString formName = getFormName(input);\n\t\tInputStream FO_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\n\t\tInputStream inputStream = FileUtils.openInputStream(input);\n\t\tOutputStream outputStream = FileUtils.openOutputStream(outputForFOFile);\n\n\t\ttry {\n\t\t\tsaxonService.transformFOToStep4FO(inputStream, outputStream, FO_XSL, surveyName, formName, parameters);\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\ttoString(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\n\t\tinputStream.close();\n\t\toutputStream.close();\n\t\tFO_XSL.close();\n\t\tlogger.info(\"End of EditStructurePages post-processing \" + outputForFOFile.getAbsolutePath());\n\n\t\treturn outputForFOFile;\n\t}\n\n\tprivate String getFormName(File input) {\n\t\treturn FilenameUtils.getBaseName(input.getParentFile().getParent());\n\t}\n\n\tpublic String toString() {\n\t\treturn PostProcessing.FO_EDIT_STRUCTURE_PAGES.name();\n\t}\n\n}\nsrc/main/java/fr/insee/eno/postprocessing/fo/FOInsertAccompanyingMailsPostprocessor.java\npublic class FOInsertAccompanyingMailsPostprocessor implements Postprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(FOInsertAccompanyingMailsPostprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.TRANSFORMATIONS_ACCOMPANYING_MAILS_FO_4PDF;\n\n\t@Override\n\tpublic File process(File input, byte[] parameters, String survey) throws Exception {\n\n\t\tFile outputForFOFile = new File(input.getParent(),\n\t\t\t\tConstants.BASE_NAME_FORM_FILE +\n\t\t\t\tConstants.FINAL_PDF_EXTENSION);\n\t\tlogger.debug(\"Output folder for basic-form : \" + outputForFOFile.getAbsolutePath());\n\n\t\tString surveyName = survey;\n\t\tString formName = getFormName(input);\n\n\t\tInputStream FO_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\n\t\tInputStream inputStream = FileUtils.openInputStream(input);\n\t\tOutputStream outputStream = FileUtils.openOutputStream(outputForFOFile);\n\n\t\ttry {\n\t\t\tsaxonService.transformFOToStep4FO(inputStream, outputStream, FO_XSL, surveyName, formName, parameters);\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\ttoString(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\n\t\tinputStream.close();\n\t\toutputStream.close();\n\t\tFO_XSL.close();\n\t\tlogger.info(\"End of InsertAccompanyingMails post-processing \" + outputForFOFile.getAbsolutePath());\n\n\t\treturn outputForFOFile;\n\t}\n\n\tprivate String getFormName(File input) {\n\t\treturn FilenameUtils.getBaseName(input.getParentFile().getParent());\n\t}\n\n\tpublic String toString() {\n\t\treturn PostProcessing.FO_INSERT_ACCOMPANYING_MAILS.name();\n\t}\n\n}\nsrc/main/java/fr/insee/eno/postprocessing/fo/FOTableColumnPostprocessorFake.java\npublic class FOTableColumnPostprocessorFake implements Postprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(FOTableColumnPostprocessorFake.class);\n\n\t@Override\n\tpublic File process(File input, byte[] parameters, String survey) throws Exception {\n\n\t\tFile outputForFOFile = new File(input.getParent(),\n\t\t\t\tConstants.BASE_NAME_FORM_FILE +\n\t\t\t\tConstants.TABLE_COL_SIZE_PDF_EXTENSION);\n\t\tlogger.debug(\"Output folder for basic-form : \" + outputForFOFile.getAbsolutePath());\n\n\t\tFileUtils.copyFile(input, outputForFOFile);\n\n\t\tlogger.debug(\"End of TableColumn post-processing (Fake)\");\n\t\treturn outputForFOFile;\n\n\t}\n\n\tpublic String toString() {\n\t\treturn PostProcessing.FO_TABLE_COLUMN.name();\n\t}\n}\nsrc/main/java/fr/insee/eno/preprocessing/Preprocessor.java\npublic interface Preprocessor {\n\n\t/**\n\t * This method handles the preprocessing of an input file. TODO Exception is\n\t * also weak, change to a more robust Exception\n\t * \n\t * @param inputFile\n\t *            The file to preprocess\n\t * @param parameters\n\t *            An optional parameters file\n\t * @param survey\n\t *            An optional parameters file\n\t * @return the preprocessed file\n\t * @throws Exception\n\t *             when it goes wrong\n\t */\n\tpublic File process(File inputFile, byte[] parameters, String survey, String in2out) throws Exception;\n\n\tpublic String toString();\n}\nsrc/main/java/fr/insee/eno/preprocessing/DDICleaningPreprocessor.java\npublic class DDICleaningPreprocessor implements Preprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(DDICleaningPreprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.UTIL_DDI_CLEANING_XSL;\n\n\t@Override\n\tpublic File process(File inputFile, byte[] parametersFile, String survey, String in2out) throws Exception {\n\t\tlogger.info(\"DDIPreprocessing Target : START\");\n\n\t\tString cleaningOutput=null;\n\t\tString cleaningInput = inputFile.getAbsolutePath();\n\t\tcleaningOutput = FilenameUtils.removeExtension(cleaningInput) + Constants.CLEANED_EXTENSION;\n\n\t\tlogger.debug(\"Cleaned output file to be created : \" + cleaningOutput);\n\t\tlogger.debug(\"Cleaning : -Input : \" + cleaningInput + \" -Output : \" + cleaningOutput + \" -Stylesheet : \"\n\t\t\t\t+ styleSheetPath);\n\n\t\tInputStream isCleaningIn = FileUtils.openInputStream(new File(cleaningInput));\n\t\tOutputStream osCleaning = FileUtils.openOutputStream(new File(cleaningOutput));\n\t\tInputStream isUTIL_DDI_CLEANING_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\n\t\ttry {\n\t\t\tsaxonService.transformCleaning(isCleaningIn, isUTIL_DDI_CLEANING_XSL, osCleaning, in2out);\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\ttoString(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\n\t\tisCleaningIn.close();\n\t\tisUTIL_DDI_CLEANING_XSL.close();\n\t\tosCleaning.close();\n\n\t\tlogger.debug(\"DDIPreprocessing Cleaning: END\");\n\t\treturn new File(cleaningOutput);\n\t}\n\n\tpublic String toString() {\n\t\treturn PreProcessing.DDI_CLEANING.name();\n\t}\n\n\n}\nsrc/main/java/fr/insee/eno/postprocessing/fo/FOInsertEndQuestionPostprocessor.java\npublic class FOInsertEndQuestionPostprocessor implements Postprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(FOInsertEndQuestionPostprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.TRANSFORMATIONS_END_QUESTION_FO_4PDF;\n\n\t@Override\n\tpublic File process(File input, byte[] parameters, String survey) throws Exception {\n\n\t\tFile outputForFOFile = new File(input.getParent(),\n\t\t\t\tConstants.BASE_NAME_FORM_FILE +\n\t\t\t\tConstants.END_QUESTION_FO_EXTENSION);\n\t\tlogger.debug(\"Output folder for basic-form : \" + outputForFOFile.getAbsolutePath());\n\n\t\tString surveyName = survey;\n\t\tString formName = getFormName(input);\n\n\t\tInputStream FO_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\n\t\tInputStream inputStream = FileUtils.openInputStream(input);\n\t\tOutputStream outputStream = FileUtils.openOutputStream(outputForFOFile);\n\n\t\ttry {\n\t\t\tsaxonService.transformFOToStep4FO(inputStream, outputStream, FO_XSL, surveyName, formName, parameters);\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\ttoString(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\n\t\tinputStream.close();\n\t\toutputStream.close();\n\t\tFO_XSL.close();\n\t\tlogger.info(\"End of InsertEndQuestion post-processing \" + outputForFOFile.getAbsolutePath());\n\n\t\treturn outputForFOFile;\n\t}\n\n\tprivate String getFormName(File input) {\n\t\treturn FilenameUtils.getBaseName(input.getParentFile().getParent());\n\t}\n\n\tpublic String toString() {\n\t\treturn PostProcessing.FO_INSERT_END_QUESTION.name();\n\t}\n\n}\nsrc/main/java/fr/insee/eno/postprocessing/fo/FOInsertCoverPagePostprocessor.java\npublic class FOInsertCoverPagePostprocessor implements Postprocessor {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(FOInsertCoverPagePostprocessor.class);\n\n\tprivate XslTransformation saxonService = new XslTransformation();\n\n\tprivate static final String styleSheetPath = Constants.TRANSFORMATIONS_COVER_PAGE_FO_4PDF;\n\n\t@Override\n\tpublic File process(File input, byte[] parameters, String survey) throws Exception {\n\n\t\tFile outputForFOFile = new File(input.getParent(),\n\t\t\t\tConstants.BASE_NAME_FORM_FILE +\n\t\t\t\tConstants.COVER_PAGE_FO_EXTENSION);\n\t\tlogger.debug(\"Output folder for basic-form : \" + outputForFOFile.getAbsolutePath());\n\t\tString surveyName = survey;\n\t\tString formName = getFormName(input);\n\n\t\tInputStream FO_XSL = Constants.getInputStreamFromPath(styleSheetPath);\n\n\t\tInputStream inputStream = FileUtils.openInputStream(input);\n\t\tOutputStream outputStream = FileUtils.openOutputStream(outputForFOFile);\n\n\t\ttry {\n\t\t\tsaxonService.transformFOToStep4FO(inputStream, outputStream, FO_XSL, surveyName, formName, parameters);\n\t\t}catch(Exception e) {\n\t\t\tString errorMessage = String.format(\"An error was occured during the %s transformation. %s : %s\",\n\t\t\t\t\ttoString(),\n\t\t\t\t\te.getMessage(),\n\t\t\t\t\tUtils.getErrorLocation(styleSheetPath,e));\n\t\t\tlogger.error(errorMessage);\n\t\t\tthrow new EnoGenerationException(errorMessage);\n\t\t}\n\n\t\tinputStream.close();\n\t\toutputStream.close();\n\t\tFO_XSL.close();\n\t\tlogger.info(\"End of InsertCoverPage post-processing \" + outputForFOFile.getAbsolutePath());\n\n\t\treturn outputForFOFile;\n\t}\n\n\tprivate String getFormName(File input) {\n\t\treturn FilenameUtils.getBaseName(input.getParentFile().getParent());\n\t}\n\n\tpublic String toString() {\n\t\treturn PostProcessing.FO_INSERT_COVER_PAGE.name();\n\t}\n\n}\n", "answers": ["\t\t\t\tnew FOInsertAccompanyingMailsPostprocessor()};"], "length": 2783, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "12f13f14cd495b2645aef74b13719393fa6ce6c656a6504d"}
{"input": "import os\nimport shutil\nimport sys\nimport tempfile\nfrom os.path import isfile, dirname\nfrom cffi import FFI\nfrom mock import patch\nfrom pywincffi.core import dist\nfrom pywincffi.core.dist import (\n    MODULE_NAME, HEADER_FILES, SOURCE_FILES, LIBRARIES, LibraryWrapper, Loader,\n    _import_path, _ffi, _compile, _read, load)\nfrom pywincffi.dev.testutil import TestCase\nfrom pywincffi.exceptions import ResourceNotFoundError, InternalError\nfrom __future__ import print_function\n\n\n\n\n\nclass TestDistConstants(TestCase):\n    def test_module_name(self):\n        self.assertEqual(MODULE_NAME, \"_pywincffi\")\n\n    def test_header_files_exist(self):\n        for path in HEADER_FILES:\n            self.assertTrue(isfile(path))\n\n    def test_source_files_exist(self):\n        for path in SOURCE_FILES:\n            self.assertTrue(isfile(path))\n\n\nclass TestLibraryWrapper(TestCase):\n    \"\"\"\n    Tests for :class:`pywincffi.core.dist.LibraryWrapper`\n    \"\"\"\n    def setUp(self):\n        super(TestLibraryWrapper, self).setUp()\n        _, library = load()\n        self.library = library._library\n        self.wrapper = LibraryWrapper(self.library)\n\n    def test_meta_dir(self):\n        self.assertEqual(\n            set(dir(self.wrapper)),\n            set(dir(self.library) +\n                list(self.wrapper._RUNTIME_CONSTANTS.keys()))\n        )\n\n    def test_meta_dict(self):\n        library_dict = self.library.__dict__.copy()\n        library_dict.update(self.wrapper._RUNTIME_CONSTANTS)\n        self.assertEqual(self.wrapper.__dict__, library_dict)\n\n    def test_meta_getattr_on_library(self):\n        for attribute in dir(self.wrapper):\n            if attribute in self.wrapper._RUNTIME_CONSTANTS:\n                continue\n\n            self.assertEqual(\n                getattr(self.wrapper, attribute),\n                getattr(self.library, attribute))\n\n    def test_meta_getattr_on_wrapper(self):\n        for attribute in self.wrapper._RUNTIME_CONSTANTS:\n            self.assertEqual(\n                getattr(self.wrapper, attribute),\n                self.wrapper._RUNTIME_CONSTANTS[attribute])\n\n    def test_meta_getattr_failure(self):\n        with self.assertRaises(AttributeError):\n            self.wrapper.FOOBAR  # pylint: disable=pointless-statement\n\n\nclass TestLoader(TestCase):\n    \"\"\"\n    Tests for :class:`pywincffi.core.dist.Loader`\n    \"\"\"\n    def setUp(self):\n        super(TestLoader, self).setUp()\n", "context": "pywincffi/core/dist.py\ndef load():\n    \"\"\"\n    The main function used by pywincffi to load an instance of\n    :class:`FFI` and the underlying library.\n    \"\"\"\n    try:\n        return Loader.get()\n    except InternalError:\n        try:\n            import _pywincffi as pywincffi\n        except ImportError:\n            pywincffi = _compile(_ffi())\n\n        # pylint: disable=no-member\n        Loader.set(pywincffi.ffi, LibraryWrapper(pywincffi.lib))\n\n    return Loader.get()\npywincffi/core/dist.py\ndef _read(*paths):\n    \"\"\"\n    Iterates over ``files`` and produces string which combines all inputs\n    into a single string.\n\n    :raises ResourceNotFoundError:\n        Raised if one of the files in ``files`` is missing.\n    \"\"\"\n    output = \"\"\n    for path in paths:\n        try:\n            with open(path, \"r\") as file_:\n                output += file_.read()\n        except (OSError, IOError, WindowsError) as error:\n            if error.errno == ENOENT:\n                raise ResourceNotFoundError(\"Failed to locate %s\" % path)\n            raise  # pragma: no cover\n\n    return output\npywincffi/core/dist.py\nMODULE_NAME = \"_pywincffi\"\npywincffi/core/dist.py\ndef _ffi(\n        module_name=MODULE_NAME, headers=HEADER_FILES, sources=SOURCE_FILES,\n        libraries=LIBRARIES):\n    \"\"\"\n    Returns an instance of :class:`FFI` without compiling\n    the module.  This function is used internally but also\n    as an entrypoint in the setup.py for `cffi_modules`.\n\n    :keyword str module_name:\n        Optional module name to use when setting the source.\n\n    :keyword tuple headers:\n        Optional path(s) to the header files.\n\n    :keyword tuple sources:\n        Optional path(s) to the source files.\n    \"\"\"\n    header = _read(*headers)\n    source = _read(*sources)\n\n    ffi = FFI()\n    ffi.set_unicode(True)\n    ffi.set_source(module_name, source, libraries=libraries)\n\n    # Windows uses SAL annotations which can provide some helpful information\n    # about the inputs and outputs to a function.  Rather than require these\n    # to be stripped out manually we should strip them out programmatically.\n    ffi.cdef(REGEX_SAL_ANNOTATION.sub(\" \", header))\n\n    return ffi\npywincffi/core/dist.py\nLIBRARIES = (\"kernel32\", \"user32\", \"Ws2_32\")\npywincffi/core/dist.py\nSOURCE_FILES = (\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"sources\", \"main.c\")), )\npywincffi/core/dist.py\nHEADER_FILES = (\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"headers\", \"typedefs.h\")),\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"headers\", \"constants.h\")),\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"headers\", \"structs.h\")),\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"headers\", \"functions.h\")))\npywincffi/core/dist.py\nclass LibraryWrapper(object):  # pylint: disable=too-few-public-methods\n    \"\"\"\n    Because of differences between Windows versions and some issues with cffi\n    we need to wrap the library that cffi produces.  Without this certain\n    constants can't be included in the lib, such as INVALID_HANDLE_VALUE which\n    has a negative value.  Other constants, such as FILE_FLAG_SESSION_AWARE,\n    are not available on all Windows versions so this class helps to provide\n    a uniform interface.\n\n    .. warning::\n\n        Please do not define constants here unless absolutely necessary.  By\n        default, constants should be defined in\n        :blob:`pywincffi/core/cdefs/headers/constants.h` unless some conditions\n        are met:\n            * cffi cannot compile the requested constant.\n            * The constant is only defined in a few Windows SDK versions and\n              it can't be conditionally defined in main.c.\n    \"\"\"\n    _RUNTIME_CONSTANTS = dict(\n        # Defined here because cffi can't handle negative values\n        # in constants yet.\n        INVALID_HANDLE_VALUE=-1,\n\n        # The maximum length of the lpCommandLine input to a CreateProcess\n        # call:\n        #  https://msdn.microsoft.com/en-us/library/ms682425\n        # Technically, this is not a Windows constant.  It's something that\n        # pywincffi defines for ease of use and to limit the possibility of\n        # typos.\n        MAX_COMMAND_LINE=32768\n    )\n\n    def __init__(self, library):\n        self._library = library\n\n    def __dir__(self):\n        \"\"\"\n        Overrides the default ``__dir__`` function so functions such as\n        :func:`dir` return the attributes of the underlying library plus\n        the runtime constants.\n        \"\"\"\n        return dir(self._library) + list(self._RUNTIME_CONSTANTS.keys())\n\n    def __getattribute__(self, item):\n        \"\"\"\n        Overrides the default ``__getattribute__`` function so that we\n        can provide more useful results for certain attributes.\n        \"\"\"\n        if item == \"__dict__\":\n            library_dict = self._library.__dict__.copy()\n            library_dict.update(self._RUNTIME_CONSTANTS)\n            return library_dict\n\n        return object.__getattribute__(self, item)\n\n    def __getattr__(self, item):\n        \"\"\"\n        Attempts to retrieve the requested attribute.  This will first look\n        for the attribute on the library we're wrapping then try to look\n        for a runtime constant defined on this class.\n        \"\"\"\n        # Most likely we're looking for an attribute on the\n        # compiled library.\n        try:\n            return getattr(self._library, item)\n        except AttributeError as initial_exception:\n            # Maybe it's a predefined constant?\n            try:\n                return self._RUNTIME_CONSTANTS[item]\n            except KeyError:\n                pass\n\n            # It's not an attribute in either the library or the\n            # runtime constants so it shouldn't exist.\n            raise initial_exception\n\n    def __repr__(self):  # pragma: no cover\n        return \"%s(%r)\" % (self.__class__.__name__, self._library)\npywincffi/exceptions.py\nclass ResourceNotFoundError(InternalError):\n    \"\"\"Raised when we fail to locate a specific resource\"\"\"\npywincffi/dev/testutil.py\nclass TestCase(_TestCase):  # pylint: disable=too-many-public-methods\n    \"\"\"\n    A base class for all test cases.  By default the\n    core test case just provides some extra functionality.\n    \"\"\"\n    # A list of hosts and port to check for internet access on.  If we fail\n    # to reach any of the hosts in `INTERNET_HOSTS` on `INTERNET_PORT` then\n    # `HAS_INTERNET` will be set to False.\n    INTERNET_PORT = 80\n    INTERNET_HOSTS = (\"github.com\", \"readthedocs.org\", \"example.com\")\n    REQUIRES_INTERNET = False\n    HAS_INTERNET = None\n\n    # Class level attributes used to access some specific Windows API\n    # functions when testing.  This is kept separate from what `dist.load()`\n    # produces so problems in the build don't break parts of the base TestCase.\n    ffi = None\n    kernel32 = None\n    ws2_32 = None\n\n    @classmethod\n    def setUpClass(cls):\n        # Reset everything back to the default values first.\n        cls.ffi = None\n        cls.kernel32 = None\n        cls.ws2_32 = None\n        cls.HAS_INTERNET = None\n\n        # First run and this test case requires internet access.  Determine\n        # if we have access to the internet then cache the value.\n        if cls.REQUIRES_INTERNET and SharedState.HAS_INTERNET is None:\n            original_timeout = socket.getdefaulttimeout()\n            socket.setdefaulttimeout(1)\n\n            try:\n                for hostname in cls.INTERNET_HOSTS:\n                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    try:\n                        sock.connect((hostname, cls.INTERNET_PORT))\n                        SharedState.HAS_INTERNET = True\n                        break\n\n                    # pylint: disable=broad-except\n                    except Exception:  # pragma: no cover\n                        pass\n\n                    finally:\n                        sock.close()\n                else:  # pragma: no cover\n                    SharedState.HAS_INTERNET = False\n            finally:\n                socket.setdefaulttimeout(original_timeout)\n\n        if os.name == \"nt\" and SharedState.ffi is None:\n            try:\n                ffi = FFI()\n                ffi.set_unicode(True)\n                ffi.cdef(dedent(\"\"\"\n                // kernel32 functions\n                DWORD GetLastError(void);\n                void SetLastError(DWORD);\n\n                // ws2_32 functions\n                void WSASetLastError(int);\n                int WSAGetLastError(void);\n                \"\"\"))\n                SharedState.ffi = ffi\n                SharedState.kernel32 = ffi.dlopen(\"kernel32\")\n                SharedState.ws2_32 = ffi.dlopen(\"ws2_32\")\n\n            # pylint: disable=broad-except\n            except Exception as error:  # pragma: no cover\n                if os.name == \"nt\":\n                    SharedState.ffi = error\n\n        cls.HAS_INTERNET = SharedState.HAS_INTERNET\n        cls.ffi = SharedState.ffi\n        cls.kernel32 = SharedState.kernel32\n        cls.ws2_32 = SharedState.ws2_32\n\n    def setUp(self):  # pragma: no cover\n        if self.REQUIRES_INTERNET and not self.HAS_INTERNET:\n            if os.environ.get(\"CI\"):\n                self.fail(\n                    \"%s requires internet but we do not seem to be \"\n                    \"connected.\" % self.__class__.__name__)\n\n            self.skipTest(\"Internet unavailable\")\n\n        if os.name != \"nt\":\n            return\n\n        if isinstance(self.ffi, Exception):\n            self.fail(\"FFI module setup failed: %s\" % self.ffi)\n\n        self.assertIsNotNone(\n            self.kernel32, \"setUp() failed: missing kernel32\")\n        self.assertIsNotNone(\n            self.ws2_32, \"setUp() failed: missing ws2_32\")\n\n        self.addCleanup(self.unhandled_error_check)\n\n        # Always reset the last error to 0 between tests.  This ensures\n        # that if an unhandled API error occurs it won't impact the\n        # currently running test.  The cleanup step above will ensure that\n        # tests that do not exit cleanly will cause a failure.\n        self.kernel32.SetLastError(0)\n        self.ws2_32.WSASetLastError(0)\n\n    def GetLastError(self):  # pylint: disable=invalid-name\n        \"\"\"\n        Returns a tuple containing output from the Windows GetLastError\n        function and the associated error message.  The error message will\n        be None if GetLastError() returns 0.\n        \"\"\"\n        errno = self.kernel32.GetLastError()\n        return errno, self.ffi.getwinerror(errno) if errno != 0 else None\n\n    def WSAGetLastError(self):  # pylint: disable=invalid-name\n        \"\"\"\n        Returns a tuple containing output from the Windows WSAGetLastError\n        function and the associated error message.  The error message will\n        be None if WSAGetLastError() returns 0.\n        \"\"\"\n        errno = self.ws2_32.WSAGetLastError()\n        return errno, self.ffi.getwinerror(errno) if errno != 0 else None\n\n    def WSASetLastError(self, errno):  # pylint: disable=invalid-name\n        \"\"\"Wrapper for WSASetLastError()\"\"\"\n        self.ws2_32.WSASetLastError(errno)\n\n    def SetLastError(self, errno):  # pylint: disable=invalid-name\n        \"\"\"Wrapper for SetLastError()\"\"\"\n        self.kernel32.SetLastError(errno)\n\n    def unhandled_error_check(self):\n        \"\"\"\n        A cleanup step which ensures that there are not any uncaught API\n        errors left over.  Unhandled errors could be a sign of an unhandled\n        testing artifact, improper API usage or other problem.  In any case,\n        unhandled errors are often a source of test flake.\n        \"\"\"\n        # Check for kernel32 errors.\n        k32_errno, k32_message = self.GetLastError()\n        self.assertEqual(\n            k32_errno, 0,\n            msg=\"Unhandled kernel32 error. Errno: %r. Message: %r\" % (\n                k32_errno, k32_message))\n\n        # Check for ws2_32 errors.\n        ws2_errno, ws2_message = self.WSAGetLastError()\n        self.assertEqual(\n            ws2_errno, 0,\n            msg=\"Unhandled ws2_32 error. Errno: %r. Message: %r\" % (\n                ws2_errno, ws2_message))\n\n    def _terminate_process(self, process):  # pylint: disable=no-self-use\n        \"\"\"\n        Calls terminnate() on ``process`` and ignores any errors produced.\n        \"\"\"\n        try:\n            process.terminate()\n\n        # pylint: disable=broad-except\n        except Exception:  # pragma: no cover\n            pass\n\n    def create_python_process(self, command):\n        \"\"\"Creates a Python process that run ``command``\"\"\"\n        process = subprocess.Popen(\n            [sys.executable, \"-c\", command],\n            stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        self.addCleanup(self._terminate_process, process)\n        return process\n\n    def random_string(self, length):\n        \"\"\"\n        Returns a random string as long as ``length``.  The first character\n        will always be a letter.  All other characters will be A-F,\n        A-F or 0-9.\n        \"\"\"\n        if length < 1:  # pragma: no cover\n            self.fail(\"Length must be at least 1.\")\n\n        # First character should always be a letter so the string\n        # can be used in object names.\n        output = choice(ascii_lowercase)\n        length -= 1\n\n        while length:\n            length -= 1\n            output += choice(ascii_lowercase + ascii_uppercase + \"0123456789\")\n\n        return output\n\n    def assert_last_error(self, errno):\n        \"\"\"\n        This function will assert that the last unhandled error\n        was ``errno``.  After the check the last error will be reset to\n        zero.\n\n        :param int errno:\n            The expected value from GetLastError.\n        \"\"\"\n        last_error, _ = self.GetLastError()\n        self.assertEqual(last_error, errno)\n        self.SetLastError(0)\n\n    def maybe_assert_last_error(self, errno):\n        \"\"\"\n        This function is similar to :meth:`assert_last_error` except\n        it won't fail if the current error number is already 0.\n        \"\"\"\n        last_error, _ = self.GetLastError()\n        self.assertIn(last_error, (0, errno))\n        self.SetLastError(0)\npywincffi/exceptions.py\nclass InternalError(PyWinCFFIError):\n    \"\"\"\n    Raised if we encounter an internal error.  Most likely this is an\n    indication of a bug in pywincffi but it could also be a problem caused by\n    an unexpected use case.\n    \"\"\"\npywincffi/core/dist.py\nMODULE_NAME = \"_pywincffi\"\nHEADER_FILES = (\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"headers\", \"typedefs.h\")),\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"headers\", \"constants.h\")),\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"headers\", \"structs.h\")),\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"headers\", \"functions.h\")))\nSOURCE_FILES = (\n    resource_filename(\n        \"pywincffi\", join(\"core\", \"cdefs\", \"sources\", \"main.c\")), )\nLIBRARIES = (\"kernel32\", \"user32\", \"Ws2_32\")\nREGEX_SAL_ANNOTATION = re.compile(\n    r\"\\b(_In_|_Inout_|_Out_|_Outptr_|_Reserved_)(opt_)?\\b\")\n    _RUNTIME_CONSTANTS = dict(\n        # Defined here because cffi can't handle negative values\n        # in constants yet.\n        INVALID_HANDLE_VALUE=-1,\n\n        # The maximum length of the lpCommandLine input to a CreateProcess\n        # call:\n        #  https://msdn.microsoft.com/en-us/library/ms682425\n        # Technically, this is not a Windows constant.  It's something that\n        # pywincffi defines for ease of use and to limit the possibility of\n        # typos.\n        MAX_COMMAND_LINE=32768\n    )\nclass LibraryWrapper(object):  # pylint: disable=too-few-public-methods\nclass Loader(object):\n    def __init__(self, library):\n    def __dir__(self):\n    def __getattribute__(self, item):\n    def __getattr__(self, item):\n    def __repr__(self):  # pragma: no cover\n    def set(cls, ffi, library):\n    def get(cls):\ndef _import_path(path, module_name=MODULE_NAME):\ndef _read(*paths):\ndef _ffi(\n        module_name=MODULE_NAME, headers=HEADER_FILES, sources=SOURCE_FILES,\n        libraries=LIBRARIES):\ndef _compile(ffi, tmpdir=None, module_name=MODULE_NAME):\ndef load():\npywincffi/core/dist.py\nclass Loader(object):\n    \"\"\"\n    A class which provides a cache for :func:`load`.\n    \"\"\"\n    cache = None\n\n    @classmethod\n    def set(cls, ffi, library):\n        \"\"\"\n        Establishes the cache.\n\n        :raises pywincffi.exceptions.InternalError:\n            Raised if the cache was already setup once.\n        \"\"\"\n        if cls.cache is not None:\n            # Setting up the cache multiple times is an indication of a\n            # possible bug.\n            raise InternalError(\"The cache has already been established\")\n\n        cls.cache = (ffi, library)\n\n    @classmethod\n    def get(cls):\n        \"\"\"\n        Retrieves the current cache.\n\n        :raises pywincffi.exceptions.InternalError:\n            Raised if an attempt is made to retrieve the cache when it\n            has not been setup yet.\n        \"\"\"\n        if cls.cache is None:\n            raise InternalError(\"The cache has not been established yet\")\n        return cls.cache\npywincffi/core/dist.py\ndef _import_path(path, module_name=MODULE_NAME):\n    \"\"\"\n    Function which imports ``path`` and returns it as a module.  This is\n    meant to import pyd files produced by :meth:`Distribution._build` in\n    a Python 2/3 agnostic fashion.\n\n    :param str path:\n        The path to the file to import\n\n    :keyword str module_name:\n        Optional name of the module being imported.  By default\n        this will use ``_pywincffi`` if no value is provided.\n\n    :raises ResourceNotFoundError:\n        Raised if ``path`` does not exist.\n    \"\"\"\n    if not isfile(path):\n        raise ResourceNotFoundError(\"Module path %r does not exist\" % path)\n\n    elif ExtensionFileLoader is not None:\n        loader = ExtensionFileLoader(module_name, path)\n        # pylint: disable=deprecated-method\n        return loader.load_module(module_name)\n\n    elif imp is not None:  # pragma: no cover\n        return imp.load_dynamic(module_name, path)\n\n    else:  # pragma: no cover\n        raise NotImplementedError(\n            \"Neither `imp` or `ExtensionFileLoader` were imported\")\npywincffi/core/dist.py\ndef _compile(ffi, tmpdir=None, module_name=MODULE_NAME):\n    \"\"\"\n    Performs the compile step, loads the resulting module and then\n    return it.\n\n    :param cffi.FFI ffi:\n        An instance of :class:`FFI` which you wish to compile and load\n        the resulting module for.\n\n    :keyword str tmpdir:\n        The path to compile the module to.  By default this will be\n        constructed using ``tempfile.mkdtemp(prefix=\"pywincffi-\")``.\n\n    :keyword str module_name:\n        Optional name of the module to be imported.\n\n    :returns:\n        Returns the module built by compiling the ``ffi`` object.\n    \"\"\"\n    if tmpdir is None:\n        tmpdir = tempfile.mkdtemp(prefix=\"pywincffi-\")\n\n    pyd_path = ffi.compile(tmpdir=tmpdir)\n    module = _import_path(pyd_path, module_name=module_name)\n\n    # Try to cleanup the temp directory that was created\n    # for compiling the module.  In most cases this will\n    # remove everything but the built .pyd file.\n    shutil.rmtree(tmpdir, ignore_errors=True)\n\n    return module\n", "answers": ["        mock = patch.object(Loader, \"cache\", None)"], "length": 2141, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "3a98a3f1b3ee260ac74cd5bc1e04e9f88bdaa51a3018ae14"}
{"input": "from logging import getLogger\nfrom flask import request\nfrom flask_restful import Resource, reqparse, marshal_with, abort\nfrom tinydb import Query\nfrom huginn.schemas import (AccelerationsSchema, VelocitiesSchema,\n                            OrientationSchema, AtmosphereShema, ForcesSchema,\n                            InitialConditionSchema, PositionSchema,\n                            AirspeedIndicatorSchema, AltimeterSchema,\n                            AttitudeIndicatorSchema, HeadingIndicatorSchema,\n                            VerticalSpeedIndicatorSchema)\nfrom huginn.fdm import (Accelerations, Velocities, Orientation, Atmosphere,\n                        Forces, InitialCondition, Position)\nfrom huginn import request_models\nfrom huginn import request_parsers\n\n            response = {\"result\": \"ok\",\n                        \"command\": command}\n        elif command == \"pause\":\n            self.simulator.pause()\n\n            response = {\"result\": \"ok\",\n                        \"command\": command}\n        elif command == \"resume\":\n            self.simulator.resume()\n\n            response = {\"result\": \"ok\",\n                        \"command\": command}\n        elif command == \"step\":\n            self.simulator.step()\n\n            response = {\"result\": \"ok\",\n                        \"command\": command}\n        elif command == \"run_for\":\n            if params:\n                time_to_run = params[\"time_to_run\"]\n            else:\n                time_to_run = None\n\n            if not time_to_run:\n                response = {\"error\": \"no time to run provided\",\n                            \"command\": command}\n            else:\n                self.simulator.run_for(time_to_run)\n\n                response = {\"result\": \"ok\",\n                            \"command\": \"run_for\"}\n        elif command == \"start_paused\":\n            self.simulator.start_paused = True\n\n            response = {\"result\": \"ok\",\n                        \"command\": \"start_paused\"}\n        elif command == \"start_running\":\n            self.simulator.start_paused = False\n\n            response = {\"result\": \"ok\",\n                        \"command\": \"start_running\"}\n        else:\n            response = {\"error\": \"unknown command\",\n                        \"command\": command}\n\n        return response\n\n    def post(self):\n        \"\"\"Execute a command on the simulator\"\"\"\n        parser = reqparse.RequestParser()\n\n        parser.add_argument(\"command\", type=str, required=True)\n        parser.add_argument(\"time_to_run\", type=float)\n        parser.add_argument(\"paused\", type=bool)\n\n        args = parser.parse_args()\n\n        command = args.command\n\n        params = {}\n\n        if args.time_to_run:\n            params[\"time_to_run\"] = args.time_to_run\n\n        if args.paused:\n            params[\"paused\"] = args.paused\n\n        return self.execute_command(command, params)\n\n\nclass ObjectResource(Resource):\n    \"\"\"The ObjectResource is using an object and a marshmallow schema to return\n    the representation of an object\"\"\"\n\n    def __init__(self, obj, schema):\n        \"\"\"Create a new ObjectResource object\n\n        Arguments:\n        obj: the object to encode\n        schema: the marshmallow schema object\n        \"\"\"\n        self.obj = obj\n        self.schema = schema\n\n    def get(self):\n        \"\"\"return the object data when a GET request is executed\"\"\"\n        result = self.schema.dump(self.obj)\n\n        return result.data\n\n\nclass AccelerationsResource(ObjectResource):\n    \"\"\"The AccelerationsResource object returns the fdm accelerations\"\"\"\n\n    def __init__(self, fdmexec):\n        \"\"\"Create a new AccelerationsResource object\n\n        Arguments:\n        fdmexec: a jsbsim FGFDMExec object\n        \"\"\"\n        self.fdmexec = fdmexec\n        self.accelerations = Accelerations(self.fdmexec)\n        self.acceleration_schema = AccelerationsSchema()\n\n        super(AccelerationsResource, self).__init__(self.accelerations,\n                                                    self.acceleration_schema)\n\n\nclass VelocitiesResource(ObjectResource):\n    \"\"\"The VelocitiesResource object returns the fdm velocities\"\"\"\n\n    def __init__(self, fdmexec):\n        \"\"\"Create a new VelocitiesResource object\n\n        Arguments:\n        fdmexec: a jsbsim FGFDMExec object\n        \"\"\"\n        self.fdmexec = fdmexec\n        self.velocities = Velocities(self.fdmexec)\n", "context": "huginn/fdm.py\nclass Atmosphere(object):\n    \"\"\"The Atmosphere contains the fdm data about the atmosphere\"\"\"\n\n    def __init__(self, fdmexec):\n        \"\"\"Create a new Atmosphere object\n\n        Arguments:\n        fdmexec: a JSBSim FGFDMExec object\n        \"\"\"\n        self.fdmexec = fdmexec\n\n    @property\n    def pressure(self):\n        \"\"\"Returns the pressure at the current altitude. The value will be in\n        Pascal\"\"\"\n        pressure = self.fdmexec.GetAtmosphere().GetPressure()\n\n        return convert_jsbsim_pressure(pressure)\n\n    @property\n    def sea_level_pressure(self):\n        \"\"\"Returns the pressure at the sea level. The value will be in\n        Pascal\"\"\"\n        pressure = self.fdmexec.GetAtmosphere().GetPressureSL()\n\n        return convert_jsbsim_pressure(pressure)\n\n    @property\n    def temperature(self):\n        \"\"\"Returns the temperature in kelvin at the current altitude\"\"\"\n        temperature = self.fdmexec.GetAtmosphere().GetTemperature()\n\n        return convert_jsbsim_temperature(temperature)\n\n    @property\n    def sea_level_temperature(self):\n        \"\"\"Returns the temperature in kelvin at the sea level\"\"\"\n        temperature = self.fdmexec.GetAtmosphere().GetTemperatureSL()\n\n        return convert_jsbsim_temperature(temperature)\n\n    @property\n    def density(self):\n        \"\"\"Returns the atmospheric density at the current altitude in\n        kg/meters^3\"\"\"\n        density = self.fdmexec.GetAtmosphere().GetDensity()\n\n        return convert_jsbsim_density(density)\n\n    @property\n    def sea_level_density(self):\n        \"\"\"Returns the atmospheric density at sea level in kg/meters^3\"\"\"\n        density = self.fdmexec.GetAtmosphere().GetDensitySL()\n\n        return convert_jsbsim_density(density)\nhuginn/schemas.py\nclass OrientationSchema(Schema):\n    phi = fields.Float()\n    theta = fields.Float()\n    psi = fields.Float()\nhuginn/fdm.py\nclass Position(object):\n    \"\"\"The Position class contains data about the position of the aircraft\"\"\"\n    def __init__(self, fdmexec):\n        self.fdmexec = fdmexec\n\n    @property\n    def latitude(self):\n        \"\"\"Returns the latitude in degrees\"\"\"\n        return self.fdmexec.GetPropagate().GetLatitudeDeg()\n\n    @property\n    def longitude(self):\n        \"\"\"Returns the longitude in degrees\"\"\"\n        return self.fdmexec.GetPropagate().GetLongitudeDeg()\n\n    @property\n    def altitude(self):\n        \"\"\"Returns the altitude in meters\"\"\"\n        return self.fdmexec.GetPropagate().GetAltitudeASLmeters()\n\n    @property\n    def heading(self):\n        \"\"\"Returns the heading in degrees\"\"\"\n        return degrees(self.fdmexec.GetPropagate().GetEuler(3))\nhuginn/schemas.py\nclass AltimeterSchema(Schema):\n    altitude = fields.Float()\n    pressure = fields.Float()\nhuginn/schemas.py\nclass HeadingIndicatorSchema(Schema):\n    heading = fields.Float()\nhuginn/schemas.py\nclass InitialConditionSchema(Schema):\n    latitude = fields.Float()\n    longitude = fields.Float()\n    airspeed = fields.Float()\n    altitude = fields.Float()\n    heading = fields.Float()\nhuginn/schemas.py\nclass AtmosphereShema(Schema):\n    pressure = fields.Float()\n    sea_level_pressure = fields.Float()\n    temperature = fields.Float()\n    sea_level_temperature = fields.Float()\n    density = fields.Float()\n    sea_level_density = fields.Float()\nhuginn/fdm.py\nclass InitialCondition(object):\n    \"\"\"The InitialCondition class gets/sets the simulator initial conditions\"\"\"\n\n    def __init__(self, fdmexec):\n        \"\"\"Create a new InitialCondition object\n\n        Arguments:\n        fdmexec: a JSBSim FGFDMExec object\n        \"\"\"\n        self.fdmexec = fdmexec\n\n    @property\n    def latitude(self):\n        \"\"\"Get the starting position latitude in degrees\"\"\"\n        return self.fdmexec.GetIC().GetLatitudeDegIC()\n\n    @latitude.setter\n    def latitude(self, value):\n        \"\"\"Set the starting position latitude\n\n        Arguments:\n        value: the latitude in degrees\n        \"\"\"\n        self.fdmexec.GetIC().SetLatitudeDegIC(value)\n\n    @property\n    def longitude(self):\n        \"\"\"Get the starting position longitude in degrees\"\"\"\n        return self.fdmexec.GetIC().GetLongitudeDegIC()\n\n    @longitude.setter\n    def longitude(self, value):\n        \"\"\"Set the starting position longitude\n\n        Arguments:\n        value: the longitude in degrees\n        \"\"\"\n\n        self.fdmexec.GetIC().SetLongitudeDegIC(value)\n\n    @property\n    def altitude(self):\n        \"\"\"Get the altitude in meters\"\"\"\n        altitude = self.fdmexec.GetIC().GetAltitudeASLFtIC() * ur.foot\n\n        altitude.ito(ur.meter)\n\n        return altitude.magnitude\n\n    @altitude.setter\n    def altitude(self, value):\n        \"\"\"Set the starting altitude\n\n        Arguments:\n        value: the altitude in meters\n        \"\"\"\n        altitude = value * ur.meter\n\n        altitude.ito(ur.foot)\n\n        self.fdmexec.GetIC().SetAltitudeASLFtIC(altitude.magnitude)\n\n    @property\n    def heading(self):\n        \"\"\"Get the heading in degrees\"\"\"\n        return self.fdmexec.GetIC().GetPsiDegIC()\n\n    @heading.setter\n    def heading(self, value):\n        \"\"\"Set the heading\n\n        Arguments:\n        value: the heading in degrees\n        \"\"\"\n        self.fdmexec.GetIC().SetPsiDegIC(value)\n\n    @property\n    def airspeed(self):\n        \"\"\"Get the airspeed in meters/second\"\"\"\n        airspeed = self.fdmexec.GetIC().GetVtrueKtsIC() * ur.knot\n\n        airspeed.ito(ur.meters_per_second)\n\n        return airspeed.magnitude\n\n    @airspeed.setter\n    def airspeed(self, value):\n        \"\"\"Set the airspeed\n\n        Arguments:\n        value: the airspeed in meters/second\n        \"\"\"\n        airspeed = value * ur.meters_per_second\n\n        airspeed.ito(ur.knot)\n\n        self.fdmexec.GetIC().SetVtrueKtsIC(airspeed.magnitude)\nhuginn/fdm.py\nclass Accelerations(object):\n    def __init__(self, fdmexec):\n        self.fdmexec = fdmexec\n\n    @property\n    def x(self):\n        \"\"\"Returns the acceleration along the x axis of the aircraft in\n        meters/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAuxiliary().GetPilotAccel(1)\n\n        return convert_jsbsim_acceleration(acceleration)\n\n    @property\n    def y(self):\n        \"\"\"Returns the acceleration along the y axis of the aircraft in\n        meters/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAuxiliary().GetPilotAccel(2)\n\n        return convert_jsbsim_acceleration(acceleration)\n\n    @property\n    def z(self):\n        \"\"\"Returns the acceleration along the z axis of the aircraft in\n        meters/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAuxiliary().GetPilotAccel(3)\n\n        return convert_jsbsim_acceleration(acceleration)\n\n    @property\n    def p_dot(self):\n        \"\"\"Returns the p value of the body axis angular acceleration in\n        degress/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAccelerations().GetPQRdot(1)\n\n        return convert_jsbsim_angular_acceleration(acceleration)\n\n    @property\n    def q_dot(self):\n        \"\"\"Returns the q value of the body axis angular acceleration in\n        degress/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAccelerations().GetPQRdot(2)\n\n        return convert_jsbsim_angular_acceleration(acceleration)\n\n    @property\n    def r_dot(self):\n        \"\"\"Returns the r value of the body axis angular acceleration in\n        degress/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAccelerations().GetPQRdot(3)\n\n        return convert_jsbsim_angular_acceleration(acceleration)\n\n    @property\n    def u_dot(self):\n        \"\"\"Returns the u item of the the body axis acceleration in\n        meters/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAccelerations().GetUVWdot(1)\n\n        return convert_jsbsim_acceleration(acceleration)\n\n    @property\n    def v_dot(self):\n        \"\"\"Returns the v item of the the body axis acceleration in\n        meters/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAccelerations().GetUVWdot(2)\n\n        return convert_jsbsim_acceleration(acceleration)\n\n    @property\n    def w_dot(self):\n        \"\"\"Returns the w item of the the body axis acceleration in\n        meters/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAccelerations().GetUVWdot(3)\n\n        return convert_jsbsim_acceleration(acceleration)\n\n    @property\n    def gravity(self):\n        \"\"\"Returns the acceleration of the gravity in meters/sec^2\"\"\"\n        acceleration = self.fdmexec.GetAccelerations().GetGravAccelMagnitude()\n\n        return convert_jsbsim_acceleration(acceleration)\nhuginn/schemas.py\nclass ForcesSchema(Schema):\n    x_body = fields.Float()\n    y_body = fields.Float()\n    z_body = fields.Float()\n    x_wind = fields.Float()\n    y_wind = fields.Float()\n    z_wind = fields.Float()\n    x_total = fields.Float()\n    y_total = fields.Float()\n    z_total = fields.Float()\nhuginn/request_parsers.py\n\nhuginn/schemas.py\nclass PositionSchema(Schema):\n    latitude = fields.Float()\n    longitude = fields.Float()\n    altitude = fields.Float()\n    heading = fields.Float()\nhuginn/schemas.py\nclass VerticalSpeedIndicatorSchema(Schema):\n    climb_rate = fields.Float()\nhuginn/fdm.py\nclass Forces(object):\n    \"\"\"The Forces objects contains the aerodynamics forces\"\"\"\n\n    def __init__(self, fdmexec):\n        self.fdmexec = fdmexec\n\n    @property\n    def x_body(self):\n        \"\"\"Return the force along the x axis in the body frame. The value\n        is in Newtons\"\"\"\n        force = self.fdmexec.GetAerodynamics().GetForces(1)\n\n        return convert_jsbsim_force(force)\n\n    @property\n    def y_body(self):\n        \"\"\"Return the force along the y axis in the body frame. The value\n        is in Newtons\"\"\"\n        force = self.fdmexec.GetAerodynamics().GetForces(2)\n\n        return convert_jsbsim_force(force)\n\n    @property\n    def z_body(self):\n        \"\"\"Return the force along the z axis in the body frame. The value\n        is in Newtons\"\"\"\n        force = self.fdmexec.GetAerodynamics().GetForces(3)\n\n        return convert_jsbsim_force(force)\n\n    @property\n    def x_wind(self):\n        \"\"\"Return the force along the x axis in the wind frame. The value\n        is in Newtons\"\"\"\n        force = self.fdmexec.GetAerodynamics().GetvFw(1)\n\n        return convert_jsbsim_force(force)\n\n    @property\n    def y_wind(self):\n        \"\"\"Return the force along the y axis in the wind frame. The value\n        is in Newtons\"\"\"\n        force = self.fdmexec.GetAerodynamics().GetvFw(2)\n\n        return convert_jsbsim_force(force)\n\n    @property\n    def z_wind(self):\n        \"\"\"Return the force along the z axis in the wind frame. The value\n        is in Newtons\"\"\"\n        force = self.fdmexec.GetAerodynamics().GetvFw(3)\n\n        return convert_jsbsim_force(force)\n\n    @property\n    def x_total(self):\n        \"\"\"Return the total force along the x axis in the body frame. The\n        value is in Newtons\"\"\"\n        force = self.fdmexec.GetAccelerations().GetForces(1)\n\n        return convert_jsbsim_force(force)\n\n    @property\n    def y_total(self):\n        \"\"\"Return the total force along the y axis in the body frame. The\n        value is in Newtons\"\"\"\n        force = self.fdmexec.GetAccelerations().GetForces(2)\n\n        return convert_jsbsim_force(force)\n\n    @property\n    def z_total(self):\n        \"\"\"Return the total force along the z axis in the body frame. The\n        value is in Newtons\"\"\"\n        force = self.fdmexec.GetAccelerations().GetForces(3)\n\n        return convert_jsbsim_force(force)\nhuginn/schemas.py\nclass AttitudeIndicatorSchema(Schema):\n    roll = fields.Float()\n    pitch = fields.Float()\nhuginn/schemas.py\nclass AirspeedIndicatorSchema(Schema):\n    airspeed = fields.Float()\nhuginn/schemas.py\nclass VelocitiesSchema(Schema):\n    p = fields.Float()\n    q = fields.Float()\n    r = fields.Float()\n    u = fields.Float()\n    v = fields.Float()\n    w = fields.Float()\n    true_airspeed = fields.Float()\n    climb_rate = fields.Float()\n    calibrated_airspeed = fields.Float()\n    equivalent_airspeed = fields.Float()\n    ground_speed = fields.Float()\nhuginn/request_models.py\n\nhuginn/fdm.py\nclass Velocities(object):\n    def __init__(self, fdmexec):\n        self.fdmexec = fdmexec\n\n    @property\n    def p(self):\n        \"\"\"Return the p item of the body angular rates in degrees/sec\"\"\"\n        velocity = self.fdmexec.GetPropagate().GetPQR(1)\n\n        return convert_jsbsim_angular_velocity(velocity)\n\n    @property\n    def q(self):\n        \"\"\"Return the q item of the body angular rates in degrees/sec\"\"\"\n        velocity = self.fdmexec.GetPropagate().GetPQR(2)\n\n        return convert_jsbsim_angular_velocity(velocity)\n\n    @property\n    def r(self):\n        \"\"\"Return the r item of the body angular rates in degrees/sec\"\"\"\n        velocity = self.fdmexec.GetPropagate().GetPQR(3)\n\n        return convert_jsbsim_angular_velocity(velocity)\n\n    @property\n    def true_airspeed(self):\n        \"\"\"Return the true airspeed in meters/second\"\"\"\n        airspeed = self.fdmexec.GetAuxiliary().GetVtrueFPS()\n\n        return convert_jsbsim_velocity(airspeed)\n\n    @property\n    def climb_rate(self):\n        \"\"\"Return the vertical velocity in meters/seconds\"\"\"\n        # climb_rate = self.fdmexec.GetPropertyValue(\"velocities/v-down-fps\")\n        climb_rate = -self.fdmexec.GetPropagate().GetVel(3)\n\n        return convert_jsbsim_velocity(climb_rate)\n\n    @property\n    def u(self):\n        \"\"\"Returns the u item of the body frame velocity vector in\n        meters/sec\"\"\"\n        velocity = self.fdmexec.GetPropagate().GetUVW(1)\n\n        return convert_jsbsim_velocity(velocity)\n\n    @property\n    def v(self):\n        \"\"\"Returns the v item of the body frame velocity vector in\n        meters/sec\"\"\"\n        velocity = self.fdmexec.GetPropagate().GetUVW(2)\n\n        return convert_jsbsim_velocity(velocity)\n\n    @property\n    def w(self):\n        \"\"\"Returns the w item of the body frame velocity vector in\n        meters/sec\"\"\"\n        velocity = self.fdmexec.GetPropagate().GetUVW(3)\n\n        return convert_jsbsim_velocity(velocity)\n\n    @property\n    def calibrated_airspeed(self):\n        \"\"\"Returns the calibrated airspeed in meters/sec\"\"\"\n        airspeed = self.fdmexec.GetAuxiliary().GetVcalibratedFPS()\n\n        return convert_jsbsim_velocity(airspeed)\n\n    @property\n    def equivalent_airspeed(self):\n        \"\"\"Returns the equivalent airspeed in meters/sec\"\"\"\n        airspeed = self.fdmexec.GetAuxiliary().GetVequivalentFPS()\n\n        return convert_jsbsim_velocity(airspeed)\n\n    @property\n    def ground_speed(self):\n        \"\"\"Returns the ground speed in meters/sec\"\"\"\n        airspeed = self.fdmexec.GetAuxiliary().GetVground()\n\n        return convert_jsbsim_velocity(airspeed)\nhuginn/fdm.py\nclass Orientation(object):\n    \"\"\"The Orientation class contains data about the orientation of the\n    aircraft\"\"\"\n    def __init__(self, fdmexec):\n        self.fdmexec = fdmexec\n\n    @property\n    def phi(self):\n        \"\"\"Return the phi euler angle angle in degrees\"\"\"\n        return self.fdmexec.GetPropagate().GetEulerDeg(1)\n\n    @property\n    def theta(self):\n        \"\"\"Return the theta euler angle angle in degrees\"\"\"\n        return self.fdmexec.GetPropagate().GetEulerDeg(2)\n\n    @property\n    def psi(self):\n        \"\"\"Return the psi euler angle angle in degrees\"\"\"\n        return self.fdmexec.GetPropagate().GetEulerDeg(3)\nhuginn/schemas.py\nclass AccelerationsSchema(Schema):\n    x = fields.Float()\n    y = fields.Float()\n    z = fields.Float()\n    p_dot = fields.Float()\n    q_dot = fields.Float()\n    r_dot = fields.Float()\n    u_dot = fields.Float()\n    v_dot = fields.Float()\n    w_dot = fields.Float()\n    gravity = fields.Float()\n", "answers": ["        self.velocities_schema = VelocitiesSchema()"], "length": 1623, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "af9cba93ba2b9008e40f16ce750a28454b8fea8d315e87fa"}
{"input": "import com.google.common.io.Resources;\nimport org.n52.youngs.impl.SourceRecordHelper;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport org.apache.http.client.fluent.Request;\nimport static org.hamcrest.CoreMatchers.allOf;\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.ClassRule;\nimport org.junit.Test;\nimport org.n52.youngs.harvest.SourceRecord;\nimport org.n52.youngs.impl.XPathHelper;\nimport org.n52.youngs.load.Sink;\nimport org.n52.youngs.load.SinkRecord;\nimport org.n52.youngs.load.impl.ElasticsearchClientSink;\nimport org.n52.youngs.transform.MappingConfiguration;\nimport org.n52.youngs.transform.impl.CswToBuilderMapper;\nimport org.n52.youngs.transform.impl.YamlMappingConfiguration;\nimport static org.n52.youngs.util.JsonMatchers.hasJsonPath;\n/*\n * Copyright 2015-2019 52°North Initiative for Geospatial Open Source\n * Software GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.n52.youngs.test;\n\n\n/**\n *\n * @author <a href=\"mailto:d.nuest@52north.org\">Daniel Nüst</a>\n */\npublic class ElasticsearchSinkCswMappingIT {\n\n    private Sink sink;\n\n    private MappingConfiguration mapping;\n\n    // set to (true); to run focussed test methods from Netbeans\n    @ClassRule\n    public static ElasticsearchServer server = new ElasticsearchServer(); // FIXME (true);\n\n    private CswToBuilderMapper mapper;\n\n    @Before\n    public void createMappingAndSink() throws IOException {\n        mapping = new YamlMappingConfiguration(Resources.asByteSource(\n                Resources.getResource(\"mappings/csw-record.yml\")).openStream(),\n                new XPathHelper());\n        sink = new ElasticsearchClientSink(server.getClient(), \"elasticsearch\", mapping.getIndex(), mapping.getType());\n\n        boolean prepare = sink.prepare(mapping);\n        assertThat(\"sink is prepared\", prepare, is(true));\n        mapper = new CswToBuilderMapper(mapping);\n    }\n\n    @After\n    public void clearSink() throws IOException {\n        boolean result = sink.clear(mapping);\n        assertThat(\"sink is cleared\", result, is(true));\n    }\n\n    @Test\n    public void store() throws Exception {\n        Collection<SourceRecord> records = SourceRecordHelper.loadGetRecordsResponse(Resources.asByteSource(Resources.getResource(\"responses/dab-records-csw.xml\")).openStream());\n        List<SinkRecord> mappedRecords = records.stream().map(mapper::map).collect(Collectors.toList());\n\n        boolean stored = sink.store(mappedRecords);\n        Thread.sleep(1000);\n        assertThat(\"all records stored\", stored);\n\n        String query = \"http://localhost:9200/\" + mapping.getIndex() + \"/\" + mapping.getType()\n                + \"/_search?q=*&size=100\";\n        String searchAllResponse = Request\n                .Get(query).execute()\n                .returnContent().asString();\n        assertThat(\"all records were added to the index\", searchAllResponse,", "context": "src/main/java/org/n52/youngs/transform/impl/CswToBuilderMapper.java\npublic class CswToBuilderMapper implements Mapper {\n\n    private static final Logger log = LoggerFactory.getLogger(CswToBuilderMapper.class);\n\n    private final MappingConfiguration mapper;\n\n    private Optional<Transformer> stripspaceTransformer = Optional.empty();\n    private Transformer defaultTransformer;\n\n    public CswToBuilderMapper(MappingConfiguration mapper) {\n        this.mapper = mapper;\n\n        TransformerFactory tFactory = TransformerFactory.newInstance();\n\n        try (InputStream is = Resources.getResource(\"xslt/stripspace.xslt\").openStream();) {\n            Source xslt = new StreamSource(is);\n            stripspaceTransformer = Optional.of(tFactory.newTransformer(xslt));\n            log.trace(\"Will apply stripspace XSLT.\");\n        } catch (TransformerConfigurationException | IOException e) {\n            log.error(\"Problem loading strip-space XSLT file.\", e);\n        }\n\n        try {\n            defaultTransformer = tFactory.newTransformer();\n        } catch (TransformerConfigurationException ex) {\n            log.error(\"Problem loading deault Transformer.\", ex);\n        }\n    }\n\n    @Override\n    public MappingConfiguration getMapper() {\n        return mapper;\n    }\n\n    /**\n     * @param sourceRecord the record to map\n     * @return a record containing a builder of the provided SourceRecord, or null if the mapper could not be completed.\n     */\n    @Override\n    public BuilderRecord map(SourceRecord sourceRecord) {\n        Objects.nonNull(sourceRecord);\n        BuilderRecord record = null;\n\n        if (sourceRecord instanceof NodeSourceRecord) {\n            try {\n                NodeSourceRecord object = (NodeSourceRecord) sourceRecord;\n                IdAndBuilder mappedRecord = mapNodeToBuilder(object.getRecord());\n\n                if (mappedRecord == null) {\n                    return null;\n                }\n\n                record = new BuilderRecord(mappedRecord.id, mappedRecord.builder);\n                return record;\n            } catch (IOException e) {\n                log.warn(\"Error mapping the source {}\", sourceRecord, e);\n                return null;\n            }\n        } else {\n            log.warn(\"The SourceRecord class {} is not supported\", sourceRecord.getClass().getName());\n        }\n\n        return record;\n    }\n\n    private IdAndBuilder mapNodeToBuilder(final Node node) throws IOException {\n        XContentBuilder builder = XContentFactory.jsonBuilder()\n                .humanReadable(true)\n                .prettyPrint()\n                .startObject();\n\n        // evaluate xpaths and save the results in the builder\n        Collection<MappingEntry> entries = mapper.getEntries();\n        log.trace(\"Mapping node {} using {} entries\", node, entries.size());\n\n        String id = null;\n        try {\n            Optional<MappingEntry> idEntry = entries.stream().filter(MappingEntry::isIdentifier).findFirst();\n            if (idEntry.isPresent()) {\n                id = idEntry.get().getXPath().evaluate(node);\n                id = (id == null || id.trim().isEmpty()) ? null : id.trim();\n            }\n            if (id == null) {\n                log.warn(\"No ID present, skipping\");\n                return null;\n            }\n\n            log.trace(\"Found id for node: {}\", id);\n        } catch (XPathExpressionException e) {\n            log.warn(\"Error selecting id field from node\", e);\n        }\n\n        // handle non-geo entries\n        List<EvalResult> mappedEntries = entries.stream().filter(e -> !e.hasCoordinates() && !e.isRawXml())\n                .map(entry -> mapEntry(entry, node, builder))\n                .filter(entry -> entry.isPresent())\n                .map(entry -> entry.get())\n                .collect(Collectors.toList());\n\n        mappedEntries.stream()\n                .forEach(er -> {\n                    try {\n                        Object value = er.value;\n                        builder.field(er.name);\n                        builder.value(value);\n                        log.debug(\"Added field: {} = {}\", er.name, (value instanceof Object[]) ? Arrays.toString((Object[]) value) : value);\n                    } catch (IOException e) {\n                        log.warn(\"Error adding field {}: {}\", er.name, e);\n                    }\n                });\n\n        // handle geo types\n        entries.stream().filter(e -> e.hasCoordinates() && !e.isRawXml()).forEach(entry -> {\n            mapSpatialEntry(entry, node, builder);\n        });\n\n        // handle raw types\n        entries.stream().filter(e -> e.isRawXml()).forEach(entry -> {\n            mapRawEntry(entry, node, builder);\n        });\n\n        if (mapper.hasSuggest()) {\n            handleSuggest(builder, mapper.getSuggest(), mappedEntries);\n        }\n\n        builder.endObject();\n        builder.close();\n\n        log.trace(\"Created content for id '{}':\\n{}\", id, builder.string());\n\n        return new IdAndBuilder(id, builder);\n    }\n\n    private void mapSpatialEntry(MappingEntry entry, final Node node, XContentBuilder builder) {\n        log.trace(\"Applying field mapping '{}' to node: {}\", entry.getFieldName(), node);\n        try {\n            Object coordsNode = entry.getXPath().evaluate(node, XPathConstants.NODE);\n            if (coordsNode != null) {\n                String geoType = (String) entry.getIndexPropery(MappingEntry.IndexProperties.TYPE);\n                String field = entry.getFieldName();\n\n                List<XPathExpression[]> pointsXPaths = entry.getCoordinatesXPaths();\n\n                if (!pointsXPaths.isEmpty() && !geoType.isEmpty() && !field.isEmpty() && entry.hasCoordinatesType()) {\n                    List<Number[]> pointsDoubles = pointsXPaths.stream().map(p -> {\n                        try {\n                            Number lat = (Number) p[0].evaluate(coordsNode, XPathConstants.NUMBER);\n                            Number lon = (Number) p[1].evaluate(coordsNode, XPathConstants.NUMBER);\n                            return new Number[]{lon, lat}; // in arrays: GeoJSON conform as [lon, lat], see https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-geo-point-type.html\n                        } catch (XPathExpressionException e) {\n                            log.warn(\"Error evaluating XPath {} for coordinate: {}\", p, e);\n                            return null;\n                        }\n                    })\n                            .filter(Objects::nonNull)\n                            .collect(Collectors.toList());\n                    log.trace(\"Evaluated {} expressions and got {} points: {}\", pointsXPaths.size(),\n                            pointsDoubles.size(), Arrays.deepToString(pointsDoubles.toArray()));\n\n                    builder.startObject(field)\n                            .field(MappingEntry.IndexProperties.TYPE, entry.getCoordinatesType())\n                            .field(\"coordinates\", pointsDoubles)\n                            .endObject();\n                    log.debug(\"Added points '{}' as {} of type {}\", Arrays.deepToString(pointsDoubles.toArray()),\n                            geoType, entry.getCoordinatesType());\n                } else {\n                    log.warn(\"Mapping '{}' has coordinates but is missing one of the other required settings, not adding field: \"\n                            + \"node = {}, index_name = {}, coordinates_type = {}, type = {}, points = {}\",\n                            entry.getFieldName(), coordsNode, field, entry.getCoordinatesType(), geoType,\n                            Arrays.deepToString(pointsXPaths.toArray()));\n                }\n            } else {\n                log.warn(\"Coords node is null, no result evaluating {} on {]\", entry.getXPath(), node);\n            }\n        } catch (XPathExpressionException | IOException e) {\n            log.warn(\"Error selecting coordinate-field {} as node. Error was: {}\", entry.getFieldName(), e.getMessage());\n            log.trace(\"Error selecting field {} as nodeset\", entry.getFieldName(), e);\n        }\n    }\n\n    private Optional<EvalResult> mapEntry(MappingEntry entry, final Node node, XContentBuilder builder) {\n        Optional<EntryMapper.EvalResult> result = new EntryMapper().mapEntry(entry, node);\n\n        return result;\n    }\n\n    private void mapRawEntry(MappingEntry entry, Node node, XContentBuilder builder) {\n        try {\n            String xmldoc = new EntryMapper(stripspaceTransformer, defaultTransformer).mapRawEntry(entry, node);\n            builder.field(entry.getFieldName(), xmldoc);\n        } catch (IOException | XPathExpressionException e) {\n            log.warn(\"Error adding field {}: {}\", entry.getFieldName(), e);\n        }\n    }\n\n\n    @Override\n    public String toString() {\n        return MoreObjects.toStringHelper(this)\n                .add(\"mapping\", this.mapper)\n                .add(\"defaultTransformer\", this.defaultTransformer)\n                .omitNullValues()\n                .toString();\n    }\n\n    private void handleSuggest(XContentBuilder builder, Map<String, Object> suggestDef, List<EvalResult> mappingEntries) throws IOException {\n        Map<String, Object> suggest = (Map<String, Object>) suggestDef.get(\"mappingConfiguration\");\n        List<String> inputs = new ArrayList<>();\n\n        Boolean singleWords = extractValue(suggest, \"input_as_single_words\", true);\n        String splitSep = extractValue(suggest, \"split\", \" \");\n        Boolean fullOutput = extractValue(suggest, \"full_output\", true);\n        List<String> inputExlucdes = extractValue(suggest, \"input_exlucdes\", Collections.emptyList());\n        List<String> inputRemoves = extractValue(suggest, \"input_remove\", Collections.emptyList());\n        Integer weight = extractValue(suggest, \"weight\", 1);\n        List<String> entries = extractValue(suggest, \"entries\", Collections.emptyList());\n\n        List<Map<String, Object>> suggestEntries = entries.stream()\n                .map(fieldName -> {\n                    Optional<Object> fieldValue = mappingEntries.stream()\n                            .filter(me -> fieldName.equals(me.getName()))\n                            .map(me -> me.getValue())\n                            .findFirst();\n\n                    if (!fieldValue.isPresent() || !(fieldValue.get() instanceof String)) {\n                        return null;\n                    }\n\n                    String[] fieldArray = fieldValue.get().toString().split(splitSep);\n                    List<String> inputList = Arrays.asList(fieldArray).stream()\n                            .filter(s -> {\n                                return inputExlucdes.stream().noneMatch((ex) -> (s.equalsIgnoreCase(ex) || s.matches(ex)));\n                            })\n                            .map(s -> {\n                                for (String inputRemove : inputRemoves) {\n                                    s = s.replace(inputRemove, \"\");\n                                }\n                                return s.trim();\n                            })\n                            .collect(Collectors.toList());\n                    Map<String, Object> map = new HashMap<>();\n                    map.put(\"inputs\", inputList);\n                    map.put(\"weight\", weight);\n                    map.put(\"output\", fieldValue.get());\n                    return map;\n                })\n                .filter(e -> e != null)\n                .collect(Collectors.toList());\n\n        if (suggestEntries.isEmpty()) {\n            return;\n        }\n\n        if (suggestEntries.size() > 1) {\n            builder.startArray(\"suggest\");\n        }\n        else {\n            builder.field(\"suggest\");\n        }\n        for (Map<String, Object> suggestEntry : suggestEntries) {\n            builder.startObject();\n            builder.field(\"input\", suggestEntry.get(\"inputs\"));\n            builder.field(\"output\", suggestEntry.get(\"output\"));\n            builder.field(\"weight\", suggestEntry.get(\"weight\"));\n            builder.endObject();\n        }\n        if (suggestEntries.size() > 1) {\n            builder.endArray();\n        }\n    }\n\n    private <V> V extractValue(Map<String, Object> map, String key, V defaultValue) {\n        V value = (V) map.get(key);\n        return value == null ? defaultValue : value;\n    }\n\n    private static class IdAndBuilder {\n\n        protected final String id;\n\n        protected final XContentBuilder builder;\n\n        public IdAndBuilder(String id, XContentBuilder builder) {\n            Objects.nonNull(builder);\n            this.id = id;\n            this.builder = builder;\n        }\n    }\n\n}\nsrc/main/java/org/n52/youngs/load/Sink.java\npublic interface Sink {\n\n    /**\n     * Do whatever is required for the sink to be used, such as testing connections, inserting schemas, ...\n     *\n     * @param mapping the mapping that contains the configuration for the sink, such as data types and field names\n     * @return true if the sink is now ready to be used\n     */\n    public boolean prepare(MappingConfiguration mapping) throws SinkError;\n\n    /**\n     * @param record the record to store\n     * @return true if record is stored\n     * @throws SinkError on no-recoverable errors\n     */\n    public boolean store(SinkRecord record) throws SinkError;\n\n    /**\n     * @param records the records to store\n     * @return true if _all_ records are stored\n     * @throws SinkError on no-recoverable errors\n     */\n    public boolean store(Collection<SinkRecord> records) throws SinkError;\n\n    /**\n     * remove all traces of any loading that took or might have taken place for the provided mapping\n     *\n     * @param mapping the mapping providing the information that shall be cleared from the sink\n     * @return false if there were problems with clearing, true otherwise\n     */\n    public boolean clear(MappingConfiguration mapping);\n\n}\nsrc/main/java/org/n52/youngs/load/impl/ElasticsearchClientSink.java\npublic class ElasticsearchClientSink extends ElasticsearchSink {\n\n    private static final Logger log = LoggerFactory.getLogger(ElasticsearchClientSink.class);\n\n    private final Client client;\n\n    public ElasticsearchClientSink(Client client, String cluster, String index, String type) {\n        super(cluster, index, type);\n        this.client = client;\n        log.info(\"Created new client with client {}\", client);\n    }\n\n    @Override\n    public Client getClient() {\n        return this.client;\n    }\n\n}\nsrc/test/java/org/n52/youngs/util/JsonMatchers.java\npublic static <T> Matcher<String> hasJsonPath(\n        final String jsonPath, final Matcher<T> matches) {\n\n    return new TypeSafeMatcher<String>() {\n        @Override\n        protected boolean matchesSafely(String json) {\n            try {\n                JsonAssert.with(json).assertThat(jsonPath, matches);\n                return true;\n            } catch (AssertionError | Exception e) {\n                return false;\n            }\n        }\n\n        @Override\n        public void describeTo(Description description) {\n            description\n                    .appendText(\" JSON object with a value at node \")\n                    .appendValue(jsonPath)\n                    .appendText(\" that is \")\n                    .appendDescriptionOf(matches);\n        }\n    };\n}\nsrc/main/java/org/n52/youngs/transform/impl/YamlMappingConfiguration.java\npublic class YamlMappingConfiguration extends NamespacedYamlConfiguration implements MappingConfiguration {\n\n    private static final Logger log = LoggerFactory.getLogger(YamlMappingConfiguration.class);\n\n    List<MappingEntry> entries = Lists.newArrayList();\n\n    private String xpathVersion = DEFAULT_XPATH_VERSION;\n\n    private int version;\n\n    private String name = DEFAULT_NAME;\n\n    private XPathFactory xpathFactory;\n\n    private Optional<XPathExpression> applicabilityExpression = Optional.empty();\n\n    private String type = DEFAULT_TYPE;\n\n    private String index = DEFAULT_INDEX;\n\n    private boolean indexCreationEnabled = DEFAULT_INDEX_CREATION;\n\n    private boolean dynamicMappingEnabled;\n\n    private Optional<String> indexCreationRequest = Optional.empty();\n\n    private final XPathHelper xpathHelper;\n\n    private String identifierField;\n\n    private Optional<String> locationField = Optional.empty();\n    private Map<String, Object> suggest;\n\n    public YamlMappingConfiguration(String fileName, XPathHelper xpathHelper) throws IOException {\n        this(Resources.asByteSource(Resources.getResource(fileName)).openStream(), xpathHelper);\n        log.info(\"Created configuration from filename {}\", fileName);\n    }\n\n    public YamlMappingConfiguration(InputStream input, XPathHelper xpathHelper) {\n        this.xpathHelper = xpathHelper;\n        this.xpathFactory = xpathHelper.newXPathFactory();\n\n        Yaml yaml = new Yaml();\n        YamlNode configurationNodes = yaml.load(input);\n        if (configurationNodes == null) {\n            log.error(\"Could not load configuration from {}, nodes: {}\", input, configurationNodes);\n        } else {\n            log.trace(\"Read configuration file with the root elements {}\", Joiner.on(\" \").join(configurationNodes));\n\n            NamespaceContext nsContext = parseNamespaceContext(configurationNodes);\n            init(configurationNodes, nsContext);\n        }\n\n        log.info(\"Created configuration from stream {} with {} entries\", input, entries.size());\n    }\n\n    private void init(YamlNode configurationNodes, NamespaceContext nsContext) {\n        // read the entries from the config file\n        this.name = configurationNodes.path(\"name\").asTextValue(DEFAULT_NAME);\n        this.version = configurationNodes.path(\"version\").asIntValue(DEFAULT_VERSION);\n        this.xpathVersion = configurationNodes.path(\"xpathversion\").asTextValue(DEFAULT_XPATH_VERSION);\n        if (configurationNodes.hasNotNull(\"index\")) {\n            YamlNode indexField = configurationNodes.get(\"index\");\n            this.index = indexField.path(\"name\").asTextValue(DEFAULT_INDEX);\n            this.indexCreationEnabled = indexField.path(\"create\").asBooleanValue(DEFAULT_INDEX_CREATION);\n            this.dynamicMappingEnabled = indexField.path(\"dynamic_mapping\").asBooleanValue(DEFAULT_DYNAMIC_MAPPING);\n            this.type = indexField.path(\"type\").asTextValue(DEFAULT_TYPE);\n            if (indexField.hasNotNull(\"settings\")) {\n                this.indexCreationRequest = Optional.of(indexField.get(\"settings\").asTextValue());\n            }\n        }\n\n        if (!this.xpathHelper.isVersionSupported(xpathFactory, xpathVersion)) {\n            throw new MappingError(\"Provided factory {} does not support version {}\", xpathFactory, xpathVersion);\n        }\n        log.debug(\"Using XPathFactory {}\", xpathFactory);\n\n        String applicabilityXPathString = configurationNodes\n                .path(\"applicability_xpath\").asTextValue(DEFAULT_APPLICABILITY_PATH);\n        XPath path = newXPath(nsContext);\n        try {\n            applicabilityExpression = Optional.of(path.compile(applicabilityXPathString));\n        } catch (XPathExpressionException e) {\n            log.error(\"Could not compile applicability xpath, will always evalute to true\", e);\n        }\n\n        if (configurationNodes.hasNotNull(\"mappings\")) {\n            YamlMapNode mappingsNode = configurationNodes.path(\"mappings\").asMap();\n            this.entries = Lists.newArrayList();\n            for (Entry<YamlNode, YamlNode> entry : mappingsNode.entries()) { // use old-style loop to forward exception\n                MappingEntry e = createEntry(entry.getKey().asTextValue(),\n                        entry.getValue(), nsContext);\n                log.trace(\"Created entry: {}\", e);\n                this.entries.add(e);\n            }\n\n            // ensure exactly one field is identifier\n            long idCount = this.entries.stream().filter(MappingEntry::isIdentifier).count();\n            if (idCount > 1) {\n                List<String> entriesWithId = this.entries.stream().filter(MappingEntry::isIdentifier)\n                        .map(MappingEntry::getFieldName).collect(Collectors.toList());\n                log.error(\"Found more than one entries marked as 'identifier': {}\", Arrays.toString(entriesWithId.toArray()));\n                throw new MappingError(\"More than one field are marked as 'identifier'. Found {}: {}\", idCount,\n                        Arrays.toString(entriesWithId.toArray()));\n            }\n            Optional<MappingEntry> identifier = this.entries.stream().filter(MappingEntry::isIdentifier).findFirst();\n            if (identifier.isPresent()) {\n                this.identifierField = identifier.get().getFieldName();\n                log.trace(\"Found identifier field '{}'\", this.identifierField);\n            } else {\n                throw new MappingError(\"No field is marked as 'identifier', exactly one must be.\");\n            }\n\n            // ensure not more than one field is location\n            long locationCount = this.entries.stream().filter(MappingEntry::isLocation).count();\n            if (locationCount > 1) {\n                List<String> entriesWithLocation = this.entries.stream().filter(MappingEntry::isIdentifier)\n                        .map(MappingEntry::getFieldName).collect(Collectors.toList());\n                log.error(\"Found more than one entries marked as 'location': {}\", Arrays.toString(entriesWithLocation.toArray()));\n                throw new MappingError(\"More than one field are marked as 'location'. Found {}: {}\", idCount,\n                        Arrays.toString(entriesWithLocation.toArray()));\n            }\n            Optional<MappingEntry> location = this.entries.stream().filter(MappingEntry::isLocation).findFirst();\n            if (location.isPresent()) {\n                this.locationField = Optional.of(location.get().getFieldName());\n                log.trace(\"Found location field '{}'\", this.locationField.get());\n            } else {\n                log.warn(\"No field is marked as 'location'.\");\n            }\n\n            // sort list by field name\n            Collections.sort(entries, (me1, me2) -> {\n                return me1.getFieldName().compareTo(me2.getFieldName());\n            });\n        }\n\n        if (configurationNodes.hasNotNull(\"suggest\")) {\n            YamlMapNode suggestNode = configurationNodes.path(\"suggest\").asMap();\n            this.suggest = Maps.newHashMap();\n            for (Entry<YamlNode, YamlNode> entry : suggestNode.entries()) {\n                YamlNode tmp = entry.getValue();\n                Object val = extractObjectValue(tmp);\n                if (val != null) {\n                    this.suggest.put(entry.getKey().asTextValue(), val);\n                }\n            }\n        }\n    }\n\n    private Map<String, Object> createSuggestConfiguration(YamlNode node) {\n        if (node.hasNotNull(\"suggest\")) {\n            final YamlMapNode suggestMap = node.path(\"suggest\").asMap();\n            Map<YamlNode, YamlNode> suggestProps = suggestMap.entries().stream().collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n\n            Map<String, Object> result = new HashMap<>(suggestProps.size());\n            suggestProps.forEach((YamlNode k, YamlNode v) -> {\n                Object val = extractObjectValue(v);\n\n                if (val != null) {\n                    result.put(k.asTextValue(), val);\n                }\n            });\n\n            return result;\n        }\n\n        return Collections.emptyMap();\n    }\n\n    private Object extractObjectValue(YamlNode yn) {\n        Object val;\n        if (yn.isText()) {\n            val = yn.asTextValue();\n        }\n        else if (yn.isInt()) {\n            val = yn.intValue();\n        }\n        else if (yn.isBoolean()) {\n            val = yn.booleanValue();\n        }\n        else if (yn.isSequence()) {\n            val = yn.asSequence().stream()\n                    .map(y -> extractObjectValue(y))\n                    .collect(Collectors.toList());\n        }\n        else if (yn.isMap()) {\n            val = yn.asMap().entries().stream()\n                    .collect(Collectors.toMap(e -> {\n                        return extractObjectValue(e.getKey());\n                    }, e -> {\n                        return extractObjectValue(e.getValue());\n                    }));\n        }\n        else {\n            val = null;\n        }\n        return val;\n    }\n\n\n    private MappingEntry createEntry(String id, YamlNode node, NamespaceContext nsContext) throws MappingError {\n        log.trace(\"Parsing mapping '{}'\", id);\n        if (node instanceof YamlMapNode) {\n            YamlMapNode mapNode = (YamlMapNode) node;\n\n            Map<String, Object> indexProperties = createIndexProperties(id, node);\n\n            boolean isIdentifier = mapNode.path(\"identifier\").asBooleanValue(false);\n            boolean isLocation = mapNode.path(\"location\").asBooleanValue(false);\n            boolean isXml = mapNode.path(\"raw_xml\").asBooleanValue(false);\n\n            String expression = mapNode.path(\"xpath\").asTextValue();\n\n            XPath xPath = newXPath(nsContext);\n            try {\n                XPathExpression compiledExpression = xPath.compile(expression);\n\n                XPathExpression condition = null;\n                if (mapNode.has(\"condition\")) {\n                    String conditionString = mapNode.path(\"condition\").asTextValue();\n                    condition = newXPath(nsContext).compile(conditionString);\n                }\n\n                List<MappingEntry> children = createChildren(node, expression, nsContext);\n\n                MappingEntryImpl entry = new MappingEntryImpl(id,\n                        compiledExpression,\n                        indexProperties,\n                        isIdentifier,\n                        isLocation,\n                        isXml,\n                        condition,\n                        children);\n                log.trace(\"Starting new entry: {}\", entry);\n\n                // geo types\n                if (mapNode.hasNotNull(\"coordinates\")) {\n                    String coordsType = mapNode.path(\"coordinates_type\").asTextValue();\n                    boolean points = mapNode.path(\"coordinates\").has(\"points\");\n                    if (coordsType == null || !points) {\n                        log.error(\"Missing properties for field {} for coordinates type: coordinates_type = {}, coordinates.points contained = {}\",\n                                entry.getFieldName(), coordsType, points);\n                        throw new MappingError(\"Missing properties in field %s for coordinates type: coordinates_type = %s, coordinatesEyxpression = %s, coordinates contained = {}\",\n                                entry.getFieldName(), coordsType, points);\n                    }\n\n                    YamlSeqNode pointsMap = (YamlSeqNode) mapNode.path(\"coordinates\").path(\"points\");\n\n//                    log.trace(\"Adding type '{}' coordinates xpath: {}\", coordsType, coordsExpression);\n                    List<XPathExpression[]> pointExpressions = pointsMap.value().stream().filter(n -> n instanceof YamlMapNode)\n                            .map(n -> (YamlMapNode) n)\n                            .map(mn -> {\n                                String expressionStringLat = mn.path(\"lat\").asTextValue();\n                                String expressionStringLon = mn.path(\"lon\").asTextValue();\n                                try {\n                                    XPathExpression compiledLat = newXPath(nsContext).compile(expressionStringLat);\n                                    XPathExpression compiledLon = newXPath(nsContext).compile(expressionStringLon);\n                                    return new XPathExpression[]{compiledLat, compiledLon};\n                                } catch (XPathExpressionException e) {\n                                    log.warn(\"Error creating xpath '{}' or '{}' for point in field {}: {}\",\n                                            expressionStringLat, expressionStringLon, id, e.getMessage());\n                                    return null;\n                                }\n                            })\n                            .filter(Objects::nonNull)\n                            .collect(Collectors.toList());\n\n                    log.trace(\"Created {} points for {}\", pointExpressions.size(), id);\n                    entry.setCoordinatesXPaths(pointExpressions).setCoordinatesType(coordsType);\n                }\n\n                if (mapNode.hasNotNull(\"replacements\")) {\n                    YamlSeqNode rMap = (YamlSeqNode) mapNode.path(\"replacements\");\n                    Map<String, String> replacements = Maps.newHashMap();\n                    rMap.value().stream().filter(n -> n instanceof YamlMapNode)\n                            .map(n -> (YamlMapNode) n)\n                            .map(mn -> {\n                                String replace = mn.path(\"replace\").asTextValue();\n                                String with = mn.path(\"with\").asTextValue();\n                                return new String[]{replace, with};\n                            })\n                            .forEach(e -> replacements.put(e[0], e[1]));\n                    log.trace(\"Parsed replacements: {}\", Arrays.toString(replacements.entrySet().toArray()));\n                    entry.setReplacements(replacements);\n                }\n\n                if (mapNode.hasNotNull(\"split\")) {\n                    YamlNode sNode = mapNode.path(\"split\");\n                    String split = sNode.asTextValue();\n                    log.trace(\"Parsed split: {}\", split);\n                    entry.setSplit(split);\n                }\n\n                // for raw types\n                if (mapNode.hasNotNull(\"output_properties\")) {\n                    YamlSeqNode rMap = (YamlSeqNode) mapNode.path(\"output_properties\");\n                    Map<String, String> op = Maps.newHashMap();\n                    rMap.value().stream().filter(n -> n instanceof YamlMapNode)\n                            .map(n -> (YamlMapNode) n)\n                            .map(mn -> {\n                                String replace = mn.path(\"name\").asTextValue();\n                                String with = mn.path(\"value\").asTextValue();\n                                return new String[]{replace, with};\n                            })\n                            .forEach(e -> op.put(e[0], e[1]));\n                    log.trace(\"Parsed outputProperties: {}\", Arrays.toString(op.entrySet().toArray()));\n                    entry.setOutputProperties(op);\n                }\n\n                return entry;\n            } catch (XPathExpressionException e) {\n                log.error(\"Could not create XPath for provided expression '{}' in field {}\", expression, id, e);\n                throw new MappingError(e, \"Could not create XPath for provided expression '%s' in field %s\",\n                        expression, id);\n            }\n        }\n        throw new MappingError(\"The provided node class %s is not supported in the mapping '%s': %s\",\n                node.getClass().toString(), id, node.toString());\n    }\n\n    private XPath newXPath(NamespaceContext nsContext) {\n        XPath xPath = xpathFactory.newXPath();\n        xPath.setNamespaceContext(nsContext);\n        return xPath;\n    }\n\n    private Map<String, Object> createIndexProperties(String id, YamlNode node) {\n        Map<String, Object> props = Maps.newHashMap();\n\n        if (node.hasNotNull(\"properties\")) {\n            final YamlMapNode valueMap = node.path(\"properties\").asMap();\n            Map<YamlNode, YamlNode> indexProperties = valueMap.entries().stream().collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n\n            indexProperties.forEach((YamlNode k, YamlNode v) -> {\n                log.trace(\"Adding property {} = {}, type: {}\", k, v, v.getClass());\n                String key = k.asTextValue();\n                Optional<Object> value = Optional.empty();\n                if (v instanceof YamlBooleanNode) {\n                    value = Optional.of(v.asBooleanValue());\n                } else if (v instanceof YamlTextNode) {\n                    value = Optional.of(v.asTextValue());\n                } else if (v instanceof YamlDecimalNode) {\n                    value = Optional.of(v.asDoubleValue());\n                } else if (v instanceof YamlIntegralNode) {\n                    value = Optional.of(v.asLongValue());\n                }\n                else {\n                    // multi fields (e.g. for sorting _and_ analyzing)\n                    if (k.isText() && k.asTextValue().equals(\"fields\")) {\n                        Map<String, Object> subFields = new HashMap<>();\n                        YamlNode fieldsNode = v;\n                        if (v.isMap()) {\n                            YamlMapNode fieldsNodeMap = v.asMap();\n\n                            // walk through each entry in the fields\n                            fieldsNodeMap.entries().stream()\n                                .forEach((Entry<YamlNode, YamlNode> fieldNode) -> {\n                                    String subFieldName = fieldNode.getKey().asTextValue();\n                                    if (fieldNode.getValue().isMap()) {\n                                        YamlMapNode subFieldValues = fieldNode.getValue().asMap();\n                                        // add the string values of the subField\n                                        Map<String, String> subFieldProperties = new HashMap<>();\n                                        subFieldValues.entries().stream()\n                                                .filter((Entry<YamlNode, YamlNode> fieldNodeProperties) -> {\n                                                    String propertyKey = fieldNodeProperties.getKey().asTextValue();\n                                                    if (\"type\".equals(propertyKey) || \"index\".equals(propertyKey)) {\n                                                        YamlNode propertyValue = fieldNodeProperties.getValue();\n                                                        if (propertyValue.isText()) {\n                                                            return true;\n                                                        }\n                                                    }\n\n                                                    return false;\n                                                })\n                                                .forEach((Entry<YamlNode, YamlNode> fieldNodeProperties) -> {\n                                                    String propertyKey = fieldNodeProperties.getKey().asTextValue();\n                                                    String propertyValue = fieldNodeProperties.getValue().asTextValue();\n                                                    subFieldProperties.put(propertyKey, propertyValue);\n                                                });\n                                        subFields.put(subFieldName, subFieldProperties);\n                                    }\n                                });\n                            value = Optional.of(subFields);\n                        }\n                    }\n                }\n\n                if (value.isPresent()) {\n                    props.put(key, value.get());\n                } else {\n                    log.error(\"Could not parse property {}={} because of unhandled type {}\", k, v, v.getClass());\n                }\n            });\n        }\n\n        // set default type\n        if (!props.containsKey(MappingEntry.IndexProperties.TYPE)) {\n            props.put(MappingEntry.IndexProperties.TYPE, DEFAULT_INDEXPROPERTY_TYPE);\n        }\n\n        return props;\n    }\n\n    @Override\n    public Collection<MappingEntry> getEntries() {\n        return entries;\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n\n    @Override\n    public int getVersion() {\n        return this.version;\n    }\n\n    @Override\n    public String getXPathVersion() {\n        return this.xpathVersion;\n    }\n\n    @Override\n    public String getType() {\n        return this.type;\n    }\n\n    @Override\n    public String getIndex() {\n        return index;\n    }\n\n    @Override\n    public boolean isApplicable(Document doc) {\n        if (!this.applicabilityExpression.isPresent()) {\n            log.debug(\"No applicability xpath provided, returning TRUE.\");\n            return true;\n        }\n\n        boolean result;\n        try {\n            XPathExpression expr = this.applicabilityExpression.get();\n            result = (boolean) expr.evaluate(doc, XPathConstants.BOOLEAN);\n        } catch (XPathExpressionException | RuntimeException e) {\n            log.warn(\"Error executing applicability xpath on document, returning false: {}\", doc, e);\n            return false;\n        }\n\n        return result;\n    }\n\n    @Override\n    public boolean isIndexCreationEnabled() {\n        return indexCreationEnabled;\n    }\n\n    @Override\n    public boolean isDynamicMappingEnabled() {\n        return dynamicMappingEnabled;\n    }\n\n    @Override\n    public boolean hasIndexCreationRequest() {\n        return indexCreationRequest.isPresent();\n    }\n\n    @Override\n    public String getIndexCreationRequest() {\n        return indexCreationRequest.get();\n    }\n\n    @Override\n    public MappingEntry getEntry(String name) {\n        return this.entries.stream().filter(e -> e.getFieldName().equals(name)).findFirst().get();\n    }\n\n    @Override\n    public String getIdentifierField() {\n        return this.identifierField;\n    }\n\n    @Override\n    public boolean hasLocationField() {\n        return this.locationField.isPresent();\n    }\n\n    @Override\n    public String getLocationField() {\n        return this.locationField.get();\n    }\n\n    @Override\n    public String toString() {\n        MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this)\n                .add(\"version\", this.version)\n                .add(\"index\", this.index)\n                .add(\"name\", this.name)\n                .add(\"type\", this.type)\n                .add(\"XPath version\", this.xpathVersion);\n        if (this.applicabilityExpression.isPresent()) {\n            s.add(\"applicability\", this.applicabilityExpression.get());\n        }\n\n        return s.omitNullValues().toString();\n    }\n\n    private List<MappingEntry> createChildren(YamlNode node, String xpath, NamespaceContext nsContext) {\n        if (node.hasNotNull(\"children\")) {\n            final YamlMapNode childrenMap = node.path(\"children\").asMap();\n            Map<YamlNode, YamlNode> children = childrenMap.entries().stream().collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n\n            List<MappingEntry> result = new ArrayList<>(children.size());\n            children.forEach((YamlNode k, YamlNode v) -> {\n                log.trace(\"Parsing children {} = {}, type: {}\", k, v, v.getClass());\n                result.add(createEntry(k.asTextValue(), v, nsContext));\n            });\n\n            return result;\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public boolean hasSuggest() {\n        return this.suggest != null && !this.suggest.isEmpty();\n    }\n\n    @Override\n    public Map<String, Object> getSuggest() {\n        return this.suggest;\n    }\n\n}\nsrc/main/java/org/n52/youngs/impl/SourceRecordHelper.java\npublic class SourceRecordHelper {\n\n    public static Collection<SourceRecord> loadGetRecordsResponse(InputStream input) throws Exception {\n        JAXBContext context = JAXBContext.newInstance(\"net.opengis.csw.v_2_0_2\");\n        Unmarshaller unmarshaller = context.createUnmarshaller();\n        Collection<SourceRecord> records = Lists.newArrayList();\n\n        JAXBElement<GetRecordsResponseType> jaxb_response = unmarshaller.unmarshal(new StreamSource(input), GetRecordsResponseType.class);\n\n        List<Object> nodes = jaxb_response.getValue().getSearchResults().getAny();\n        if (!nodes.isEmpty()) {\n            AtomicInteger streamIndex = new AtomicInteger(0);\n            nodes.stream()\n                    .filter(n -> n instanceof Node)\n                    .map(n -> (Node) n)\n                    .map(n -> new NodeSourceRecord(n, \"csw-record-\" + streamIndex.getAndIncrement()))\n                    .forEach(records::add);\n        }\n        List<JAXBElement<? extends AbstractRecordType>> jaxb_records = jaxb_response.getValue().getSearchResults().getAbstractRecord();\n        if (!jaxb_records.isEmpty()) {\n            AtomicInteger streamIndex = new AtomicInteger(0);\n            jaxb_records.stream()\n                    .map(type -> {\n                        return getNode(type, context);\n                    })\n                    .filter(Objects::nonNull)\n                    .map(n -> new NodeSourceRecord(n, \"csw-record-\" + streamIndex.getAndIncrement()))\n                    .forEach(records::add);\n        }\n\n        return records;\n    }\n\n    private static Node getNode(JAXBElement<? extends AbstractRecordType> record, JAXBContext context) {\n        try {\n            DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            Document document = db.newDocument();\n            Marshaller marshaller = context.createMarshaller();\n            marshaller.marshal(record, document);\n            Element elem = document.getDocumentElement();\n            return elem;\n        } catch (JAXBException | ParserConfigurationException e) {\n            System.out.println(String.format(\"Error getting node from record %s: %s > %s\", record, e, e.getMessage()));\n            return null;\n        }\n    }\n\n    public static SourceRecord getSourceRecordFromFile(String filename) throws Exception {\n        try (InputStream is = Resources.asByteSource(Resources.getResource(filename)).openStream();) {\n            DocumentBuilder documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            Document doc = documentBuilder.parse(is);\n            Element elem = doc.getDocumentElement();\n            elem.normalize();\n            NodeSourceRecord record = new NodeSourceRecord(elem, filename);\n            return record;\n        }\n    }\n\n}\nsrc/main/java/org/n52/youngs/transform/MappingConfiguration.java\npublic interface MappingConfiguration {\n\n    public static final String DEFAULT_XPATH_VERSION = XPathConstants.XPATH_20;\n\n    public static final int DEFAULT_VERSION = 1;\n\n    public static final String DEFAULT_NAME = \"<unnamed>\";\n\n    public static final String DEFAULT_APPLICABILITY_PATH = \"true()\";\n\n    public static final String DEFAULT_TYPE = \"record\";\n\n    public static final String DEFAULT_INDEX = \"elasticsearch\";\n\n    public static final boolean DEFAULT_INDEX_CREATION = false;\n\n    public static final boolean DEFAULT_STORE_XML = true;\n\n    public static final String DEFAULT_STORE_XML_FIELDNAME = \"xmldoc\";\n\n    public static final boolean DEFAULT_DYNAMIC_MAPPING = false;\n\n    public static final String DEFAULT_INDEXPROPERTY_TYPE = \"text\";\n\n    /**\n     *\n     * @return a sorted list of mapping entries, ordered by the field name\n    */\n    public Collection<MappingEntry> getEntries();\n\n    public MappingEntry getEntry(String name);\n\n    public String getName();\n\n    public int getVersion();\n\n    public String getIndex();\n\n    public String getType();\n\n    public String getIdentifierField();\n\n    public boolean hasLocationField();\n\n    public String getLocationField();\n\n    public String getXPathVersion();\n\n    public boolean isApplicable(Document doc);\n\n    public boolean isIndexCreationEnabled();\n\n    public boolean isDynamicMappingEnabled();\n\n    public boolean hasIndexCreationRequest();\n\n    public String getIndexCreationRequest();\n\n    default boolean hasSuggest() {\n        return false;\n    }\n\n    default Map<String, Object> getSuggest() {\n        return Collections.emptyMap();\n    }\n\n}\nsrc/main/java/org/n52/youngs/impl/XPathHelper.java\npublic class XPathHelper {\n\n    private static final Logger log = LoggerFactory.getLogger(XPathHelper.class);\n\n    private final String systemSettingKey;\n\n    private final String systemSettingValue;\n\n    private final String objectModel;\n\n    public XPathHelper() {\n        this(\"javax.xml.xpath.XPathFactory:\"\n                //+ NamespaceConstant.OBJECT_MODEL_SAXON;\n                + \"http://saxon.sf.net/jaxp/xpath/om\",\n                \"net.sf.saxon.xpath.XPathFactoryImpl\",\n                \"http://saxon.sf.net/jaxp/xpath/om\");\n    }\n\n    public XPathHelper(String systemSettingKey, String systemSettingValue, String objectModel) {\n        this.systemSettingKey = systemSettingKey;\n        this.systemSettingValue = systemSettingValue;\n        this.objectModel = objectModel;\n    }\n\n    private void setSystemSetting() {\n        System.setProperty(systemSettingKey, systemSettingValue);\n        log.info(\"Setting system property {} to {}\", systemSettingKey, systemSettingValue);\n    }\n\n    private void unsetSystemSetting() {\n        System.clearProperty(systemSettingKey);\n        log.info(\"Unsetting system property {}\", systemSettingKey);\n    }\n\n    public synchronized XPathFactory newXPathFactory() {\n        setSystemSetting();\n        XPathFactory factory = null;\n        try {\n            factory = XPathFactory.newInstance(objectModel);\n            //NamespaceConstant.OBJECT_MODEL_SAXON);\n        } catch (XPathFactoryConfigurationException e) {\n            log.error(\"Could not create new instance of XPathFactory\", e);\n        }\n        unsetSystemSetting();\n        return factory;\n    }\n\n    public boolean isVersionSupported(XPathFactory factory, String version) {\n        switch (version) {\n            case XPathConstants.XPATH_20:\n                return isXPath20Supported(factory);\n            case XPathConstants.XPATH_10:\n                return isXPath10Supported(factory);\n            default:\n                throw new IllegalArgumentException(String.format(\"Unknown XSLT version %s\", version));\n        }\n    }\n\n    /**\n     * http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html\n     * @param factory the factory to be checked\n     * @return always true\n     */\n    public boolean isXPath10Supported(XPathFactory factory) {\n        return true;\n    }\n\n    /**\n     * see http://stackoverflow.com/questions/7951879/which-version-of-xpath-and-xslt-am-i-using and http://stackoverflow.com/questions/926222/using-saxon-xpath-engine-in-java\n     *\n     * @param factory the factory to be checked\n     * @return true if the provided factory supports XPath 2.0\n     */\n    public boolean isXPath20Supported(XPathFactory factory) {\n        try {\n            XPath xpath = factory.newXPath();\n            @SuppressWarnings(\"MalformedXPath\") // is in fact not malformed but recognized by SAXON\n            String evaluate = xpath.evaluate(\"current-date()\", new InputSource(\n                    new StringReader(\"<empty />\")));\n            log.trace(\"Evaluated current-date() to {} as a quick check for XSLT 2.0 support\", evaluate);\n            return !evaluate.isEmpty();\n        } catch (XPathExpressionException e) {\n            log.debug(\"Error evaluating test expression, 2.0 not supported.\", e.getMessage());\n            return false;\n        }\n    }\n\n}\nsrc/main/java/org/n52/youngs/harvest/SourceRecord.java\npublic interface SourceRecord extends Record {\n\n    default String getProtocolIdentifier() {\n        return toString();\n    };\n\n    //\n}\nsrc/main/java/org/n52/youngs/load/SinkRecord.java\npublic interface SinkRecord extends Record {\n\n    abstract boolean hasId();\n\n    abstract String getId();\n\n}\n", "answers": ["                hasJsonPath(\"hits.total\", is(mappedRecords.size())));"], "length": 3764, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "27cd0a16be37c12e0e06753c69a76d29a06204fb969890c3"}
{"input": "import android.app.AlertDialog;\nimport android.app.ProgressDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.PackageManager;\nimport android.graphics.Bitmap;\nimport android.graphics.Rect;\nimport android.hardware.Camera;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Vibrator;\nimport android.text.TextUtils;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceHolder.Callback;\nimport android.view.SurfaceView;\nimport android.view.View;\nimport android.view.ViewStub;\nimport android.view.Window;\nimport android.widget.Button;\nimport android.widget.CompoundButton;\nimport android.widget.Switch;\nimport android.widget.Toast;\nimport com.google.zxing.Result;\nimport com.zl.tesseract.R;\nimport com.zl.tesseract.scanner.camera.CameraManager;\nimport com.zl.tesseract.scanner.decode.CaptureActivityHandler;\nimport com.zl.tesseract.scanner.decode.DecodeManager;\nimport com.zl.tesseract.scanner.decode.InactivityTimer;\nimport com.zl.tesseract.scanner.tess.TesseractCallback;\nimport com.zl.tesseract.scanner.tess.TesseractThread;\nimport com.zl.tesseract.scanner.utils.Tools;\nimport com.zl.tesseract.scanner.view.ImageDialog;\nimport com.zl.tesseract.scanner.view.ScannerFinderView;\nimport java.io.IOException;\nimport androidx.annotation.NonNull;\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.core.app.ActivityCompat;\nimport androidx.core.content.ContextCompat;\nimport static android.Manifest.permission.CAMERA;\nimport static android.Manifest.permission.READ_EXTERNAL_STORAGE;\n            }\n        } catch (IOException e) {\n            // 基本不会出现相机不存在的情况\n            Toast.makeText(this, getString(R.string.camera_not_found), Toast.LENGTH_SHORT).show();\n            finish();\n            return;\n        } catch (RuntimeException re) {\n            re.printStackTrace();\n            return;\n        }\n        mQrCodeFinderView.setVisibility(View.VISIBLE);\n        findViewById(R.id.qr_code_view_background).setVisibility(View.GONE);\n        if (mCaptureActivityHandler == null) {\n            mCaptureActivityHandler = new CaptureActivityHandler(this);\n        }\n    }\n\n    public void restartPreview() {\n        if (null != mCaptureActivityHandler) {\n            try {\n                mCaptureActivityHandler.restartPreviewAndDecode();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {}\n\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {\n        if (!mHasSurface) {\n            mHasSurface = true;\n            initCamera(holder);\n        }\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        mHasSurface = false;\n    }\n\n    public Handler getCaptureActivityHandler() {\n        return mCaptureActivityHandler;\n    }\n\n    private void handleResult(Result result) {\n        if (TextUtils.isEmpty(result.getText())) {\n            mDecodeManager.showCouldNotReadQrCodeFromScanner(this, new DecodeManager.OnRefreshCameraListener() {\n                @Override\n                public void refresh() {\n                    restartPreview();\n                }\n            });\n        } else {\n            Vibrator vibrator = (Vibrator) this.getSystemService(Context.VIBRATOR_SERVICE);\n            vibrator.vibrate(200L);\n            if (switch1.isChecked()) {\n                qrSucceed(result.getText());\n            } else {\n                phoneSucceed(result.getText(), result.getBitmap());\n            }\n        }\n    }\n\n    @Override\n    public void onPictureTaken(byte[] data, Camera camera) {\n        if (data == null) {\n            return;\n        }\n        mCaptureActivityHandler.onPause();\n        bmp = null;\n        bmp = Tools.getFocusedBitmap(this, camera, data, getCropRect());\n\n        TesseractThread mTesseractThread = new TesseractThread(bmp, new TesseractCallback() {\n\n            @Override\n            public void succeed(String result) {\n                Message message = Message.obtain();\n                message.what = 0;\n                message.obj = result;\n                mHandler.sendMessage(message);\n            }\n\n            @Override\n            public void fail() {\n                Message message = Message.obtain();\n                message.what = 1;\n                mHandler.sendMessage(message);\n            }\n        });\n\n        Thread thread = new Thread(mTesseractThread);\n        thread.start();\n    }\n\n    @Override\n    public void onShutter() {}\n\n    private void qrSucceed(String result){\n        AlertDialog dialog = new AlertDialog.Builder(this).setTitle(R.string.notification)\n                .setMessage(result)\n                .setPositiveButton(R.string.positive_button_confirm, new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        dialog.dismiss();\n                        restartPreview();\n                    }\n                })\n                .show();\n        dialog.setOnDismissListener(new DialogInterface.OnDismissListener() {\n            @Override\n            public void onDismiss(DialogInterface dialog) {\n                restartPreview();\n            }\n        });\n    }\n\n    private void phoneSucceed(String result, Bitmap bitmap){", "context": "app/src/main/java/com/zl/tesseract/scanner/camera/CameraManager.java\npublic final class CameraManager {\n\n    private static CameraManager sCameraManager;\n\n    private final CameraConfigurationManager mConfigManager;\n    /**\n     * Preview frames are delivered here, which we pass on to the registered handler. Make sure to clear the handler so\n     * it will only receive one message.\n     */\n    private final PreviewCallback mPreviewCallback;\n    /** Auto-focus callbacks arrive here, and are dispatched to the Handler which requested them. */\n    private final AutoFocusCallback mAutoFocusCallback;\n    private Camera mCamera;\n    private boolean mInitialized;\n    private boolean mPreviewing;\n    private boolean useAutoFocus;\n\n    private CameraManager() {\n        this.mConfigManager = new CameraConfigurationManager();\n        mPreviewCallback = new PreviewCallback(mConfigManager);\n        mAutoFocusCallback = new AutoFocusCallback();\n    }\n\n    /**\n     * Initializes this static object with the Context of the calling Activity.\n     */\n    public static void init() {\n        if (sCameraManager == null) {\n            sCameraManager = new CameraManager();\n        }\n    }\n\n    /**\n     * Gets the CameraManager singleton instance.\n     *\n     * @return A reference to the CameraManager singleton.\n     */\n    public static CameraManager get() {\n        return sCameraManager;\n    }\n\n    /**\n     * Opens the mCamera driver and initializes the hardware parameters.\n     *\n     * @param holder The surface object which the mCamera will draw preview frames into.\n     * @throws IOException Indicates the mCamera driver failed to open.\n     */\n    public boolean openDriver(SurfaceHolder holder) throws IOException {\n        if (mCamera == null) {\n            try {\n                mCamera = Camera.open();\n                if (mCamera != null) {\n                    // setParameters 是针对魅族MX5做的。MX5通过Camera.open()拿到的Camera 对象不为null\n                    Camera.Parameters mParameters = mCamera.getParameters();\n                    mCamera.setParameters(mParameters);\n                    mCamera.setPreviewDisplay(holder);\n\n                    String currentFocusMode = mCamera.getParameters().getFocusMode();\n                    useAutoFocus = FOCUS_MODES_CALLING_AF.contains(currentFocusMode);\n\n                    if (!mInitialized) {\n                        mInitialized = true;\n                        mConfigManager.initFromCameraParameters(mCamera);\n                    }\n                    mConfigManager.setDesiredCameraParameters(mCamera);\n                    return true;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Closes the camera driver if still in use.\n     */\n    public boolean closeDriver() {\n        if (mCamera != null) {\n            try {\n                mCamera.release();\n                mInitialized = false;\n                mPreviewing = false;\n                mCamera = null;\n                return true;\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 打开或关闭闪光灯\n     *\n     * @param open 控制是否打开\n     * @return 打开或关闭失败，则返回false。\n     */\n    public boolean setFlashLight(boolean open) {\n        if (mCamera == null || !mPreviewing) {\n            return false;\n        }\n        Camera.Parameters parameters = mCamera.getParameters();\n        if (parameters == null) {\n            return false;\n        }\n        List<String> flashModes = parameters.getSupportedFlashModes();\n        // Check if camera flash exists\n        if (null == flashModes || 0 == flashModes.size()) {\n            // Use the screen as a flashlight (next best thing)\n            return false;\n        }\n        String flashMode = parameters.getFlashMode();\n        if (open) {\n            if (Camera.Parameters.FLASH_MODE_TORCH.equals(flashMode)) {\n                return true;\n            }\n            // Turn on the flash\n            if (flashModes.contains(Camera.Parameters.FLASH_MODE_TORCH)) {\n                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);\n                mCamera.setParameters(parameters);\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (Camera.Parameters.FLASH_MODE_OFF.equals(flashMode)) {\n                return true;\n            }\n            // Turn on the flash\n            if (flashModes.contains(Camera.Parameters.FLASH_MODE_OFF)) {\n                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);\n                mCamera.setParameters(parameters);\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Asks the mCamera hardware to begin drawing preview frames to the screen.\n     */\n    public boolean startPreview() {\n        if (mCamera != null && !mPreviewing) {\n            try {\n                mCamera.startPreview();\n                mPreviewing = true;\n                return true;\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Tells the mCamera to stop drawing preview frames.\n     */\n    public boolean stopPreview() {\n        if (mCamera != null && mPreviewing) {\n            try {\n                // 停止预览时把callback移除.\n                mCamera.setOneShotPreviewCallback(null);\n                mCamera.stopPreview();\n                mPreviewCallback.setHandler(null, 0);\n                mAutoFocusCallback.setHandler(null, 0);\n                mPreviewing = false;\n                return true;\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return false;\n    }\n\n    /**\n     * A single preview frame will be returned to the handler supplied. The data will arrive as byte[] in the\n     * message.obj field, with width and height encoded as message.arg1 and message.arg2, respectively.\n     *\n     * @param handler The handler to send the message to.\n     * @param message The what field of the message to be sent.\n     */\n    public void requestPreviewFrame(Handler handler, int message) {\n        if (mCamera != null && mPreviewing) {\n            mPreviewCallback.setHandler(handler, message);\n            mCamera.setOneShotPreviewCallback(mPreviewCallback);\n        }\n    }\n\n    /**\n     * Asks the mCamera hardware to perform an autofocus.\n     *\n     * @param handler The Handler to notify when the autofocus completes.\n     * @param message The message to deliver.\n     */\n    public void requestAutoFocus(Handler handler, int message) {\n        if (mCamera != null && mPreviewing) {\n            mAutoFocusCallback.setHandler(handler, message);\n            // Log.d(TAG, \"Requesting auto-focus callback\");\n            if (useAutoFocus) {\n                try {\n                    mCamera.autoFocus(mAutoFocusCallback);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void takeShot(Camera.ShutterCallback shutterCallback,\n                         Camera.PictureCallback rawPictureCallback,\n                         Camera.PictureCallback jpegPictureCallback ){\n\n        mCamera.takePicture(shutterCallback, rawPictureCallback, jpegPictureCallback);\n    }\n\n    private static final Collection<String> FOCUS_MODES_CALLING_AF;\n\n    static {\n        FOCUS_MODES_CALLING_AF = new ArrayList<String>(2);\n        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_AUTO);\n        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_MACRO);\n    }\n}\napp/src/main/java/com/zl/tesseract/scanner/decode/InactivityTimer.java\npublic final class InactivityTimer {\n\n    private static final int INACTIVITY_DELAY_SECONDS = 5 * 60;\n\n    private final ScheduledExecutorService inactivityTimer =\n            Executors.newSingleThreadScheduledExecutor(new DaemonThreadFactory());\n    private final Activity activity;\n    private ScheduledFuture<?> inactivityFuture = null;\n\n    public InactivityTimer(Activity activity) {\n        this.activity = activity;\n        onActivity();\n    }\n\n    public void onActivity() {\n        cancel();\n        inactivityFuture =\n                inactivityTimer.schedule(new FinishListener(activity), INACTIVITY_DELAY_SECONDS, TimeUnit.SECONDS);\n    }\n\n    private void cancel() {\n        if (inactivityFuture != null) {\n            inactivityFuture.cancel(true);\n            inactivityFuture = null;\n        }\n    }\n\n    public void shutdown() {\n        cancel();\n        inactivityTimer.shutdown();\n    }\n\n    private static final class DaemonThreadFactory implements ThreadFactory {\n        public Thread newThread(@NonNull Runnable runnable) {\n            Thread thread = new Thread(runnable);\n            thread.setDaemon(true);\n            return thread;\n        }\n    }\n}\napp/src/main/java/com/zl/tesseract/scanner/view/ImageDialog.java\npublic class ImageDialog extends Dialog {\n\n    private Bitmap bmp;\n\n    private String title;\n\n    public ImageDialog(@NonNull Context context) {\n        super(context);\n    }\n\n    public ImageDialog addBitmap(Bitmap bmp) {\n        if (bmp != null){\n            this.bmp = bmp;\n        }\n        return this;\n    }\n\n    public ImageDialog addTitle(String title) {\n        if (title != null){\n            this.title = title;\n        }\n        return this;\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.image_dialog);\n\n        ImageView imageView = (ImageView)findViewById(R.id.image_dialog_imageView);\n        TextView textView = (TextView)findViewById(R.id.image_dialog_textView);\n\n        if (bmp != null){\n            imageView.setImageBitmap(bmp);\n        }\n\n        if(title!=null){\n            textView.setText(this.title);\n        }\n    }\n\n    @Override\n    public void dismiss() {\n        bmp.recycle();\n        bmp = null;\n        System.gc();\n        super.dismiss();\n    }\n}\napp/src/main/java/com/zl/tesseract/scanner/decode/DecodeManager.java\npublic class DecodeManager {\n\n    public void showCouldNotReadQrCodeFromScanner(Context context, final OnRefreshCameraListener listener) {\n        new AlertDialog.Builder(context).setTitle(R.string.notification)\n                .setMessage(R.string.could_not_read_qr_code_from_scanner)\n                .setPositiveButton(R.string.close, new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        dialog.dismiss();\n                        if (listener != null) {\n                            listener.refresh();\n                        }\n                    }\n                })\n                .show();\n    }\n\n    public interface OnRefreshCameraListener {\n        void refresh();\n    }\n}\napp/src/main/java/com/zl/tesseract/scanner/view/ScannerFinderView.java\npublic final class ScannerFinderView extends RelativeLayout {\n\n    private static final int[] SCANNER_ALPHA = { 0, 64, 128, 192, 255, 192, 128, 64 };\n    private static final long ANIMATION_DELAY = 100L;\n    private static final int OPAQUE = 0xFF;\n\n    private static final int MIN_FOCUS_BOX_WIDTH = 50;\n    private static final int MIN_FOCUS_BOX_HEIGHT = 50;\n    private static final int MIN_FOCUS_BOX_TOP = 200;\n\n    private static Point ScrRes;\n    private int top;\n\n    private Paint mPaint;\n    private int mScannerAlpha;\n    private int mMaskColor;\n    private int mFrameColor;\n    private int mLaserColor;\n    private int mTextColor;\n    private int mFocusThick;\n    private int mAngleThick;\n    private int mAngleLength;\n\n    private Rect mFrameRect; //绘制的Rect\n    private Rect mRect; //返回的Rect\n\n    public ScannerFinderView(Context context) {\n        this(context, null);\n    }\n\n    public ScannerFinderView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public ScannerFinderView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        mPaint = new Paint();\n        mPaint.setAntiAlias(true);\n        Resources resources = getResources();\n        mMaskColor = resources.getColor(R.color.finder_mask);\n        mFrameColor = resources.getColor(R.color.finder_frame);\n        mLaserColor = resources.getColor(R.color.finder_laser);\n        mTextColor = resources.getColor(R.color.white);\n\n        mFocusThick = 1;\n        mAngleThick = 8;\n        mAngleLength = 40;\n        mScannerAlpha = 0;\n        init(context);\n        this.setOnTouchListener(getTouchListener());\n    }\n\n    private void init(Context context) {\n        if (isInEditMode()) {\n            return;\n        }\n        // 需要调用下面的方法才会执行onDraw方法\n        setWillNotDraw(false);\n\n        if (mFrameRect == null) {\n\n            ScrRes = ScreenUtils.getScreenResolution(context);\n\n            int width = ScrRes.x * 3 / 5;\n            int height = width;\n\n            width = width == 0\n                    ? MIN_FOCUS_BOX_WIDTH\n                    : width < MIN_FOCUS_BOX_WIDTH ? MIN_FOCUS_BOX_WIDTH : width;\n\n            height = height == 0\n                    ? MIN_FOCUS_BOX_HEIGHT\n                    : height < MIN_FOCUS_BOX_HEIGHT ? MIN_FOCUS_BOX_HEIGHT : height;\n\n            int left = (ScrRes.x - width) / 2;\n            int top = (ScrRes.y - height) / 5;\n            this.top = top; //记录初始距离上方距离\n\n            mFrameRect = new Rect(left, top, left + width, top + height);\n            mRect = mFrameRect;\n        }\n    }\n\n    public Rect getRect() {\n        return mRect;\n    }\n\n    @Override\n    public void onDraw(Canvas canvas) {\n        if (isInEditMode()) {\n            return;\n        }\n        Rect frame = mFrameRect;\n        if (frame == null) {\n            return;\n        }\n        int width = canvas.getWidth();\n        int height = canvas.getHeight();\n\n        // 绘制焦点框外边的暗色背景\n        mPaint.setColor(mMaskColor);\n        canvas.drawRect(0, 0, width, frame.top, mPaint);\n        canvas.drawRect(0, frame.top, frame.left, frame.bottom + 1, mPaint);\n        canvas.drawRect(frame.right + 1, frame.top, width, frame.bottom + 1, mPaint);\n        canvas.drawRect(0, frame.bottom + 1, width, height, mPaint);\n\n        drawFocusRect(canvas, frame);\n        drawAngle(canvas, frame);\n        drawText(canvas, frame);\n        drawLaser(canvas, frame);\n    }\n\n    /**\n     * 画聚焦框，白色的\n     *\n     * @param canvas\n     * @param rect\n     */\n    private void drawFocusRect(Canvas canvas, Rect rect) {\n        // 绘制焦点框（黑色）\n        mPaint.setColor(mFrameColor);\n        // 上\n        canvas.drawRect(rect.left + mAngleLength, rect.top, rect.right - mAngleLength, rect.top + mFocusThick, mPaint);\n        // 左\n        canvas.drawRect(rect.left, rect.top + mAngleLength, rect.left + mFocusThick, rect.bottom - mAngleLength,\n                mPaint);\n        // 右\n        canvas.drawRect(rect.right - mFocusThick, rect.top + mAngleLength, rect.right, rect.bottom - mAngleLength,\n                mPaint);\n        // 下\n        canvas.drawRect(rect.left + mAngleLength, rect.bottom - mFocusThick, rect.right - mAngleLength, rect.bottom,\n                mPaint);\n    }\n\n    /**\n     * 画四个角\n     *\n     * @param canvas\n     * @param rect\n     */\n    private void drawAngle(Canvas canvas, Rect rect) {\n        mPaint.setColor(mLaserColor);\n        mPaint.setAlpha(OPAQUE);\n        mPaint.setStyle(Paint.Style.FILL);\n        mPaint.setStrokeWidth(mAngleThick);\n        int left = rect.left;\n        int top = rect.top;\n        int right = rect.right;\n        int bottom = rect.bottom;\n        // 左上角\n        canvas.drawRect(left, top, left + mAngleLength, top + mAngleThick, mPaint);\n        canvas.drawRect(left, top, left + mAngleThick, top + mAngleLength, mPaint);\n        // 右上角\n        canvas.drawRect(right - mAngleLength, top, right, top + mAngleThick, mPaint);\n        canvas.drawRect(right - mAngleThick, top, right, top + mAngleLength, mPaint);\n        // 左下角\n        canvas.drawRect(left, bottom - mAngleLength, left + mAngleThick, bottom, mPaint);\n        canvas.drawRect(left, bottom - mAngleThick, left + mAngleLength, bottom, mPaint);\n        // 右下角\n        canvas.drawRect(right - mAngleLength, bottom - mAngleThick, right, bottom, mPaint);\n        canvas.drawRect(right - mAngleThick, bottom - mAngleLength, right, bottom, mPaint);\n    }\n\n    private void drawText(Canvas canvas, Rect rect) {\n        int margin = 40;\n        mPaint.setColor(mTextColor);\n        mPaint.setTextSize(getResources().getDimension(R.dimen.text_size_13sp));\n        String text = getResources().getString(R.string.auto_scan_notification);\n        Paint.FontMetrics fontMetrics = mPaint.getFontMetrics();\n        float fontTotalHeight = fontMetrics.bottom - fontMetrics.top;\n        float offY = fontTotalHeight / 2 - fontMetrics.bottom;\n        float newY = rect.bottom + margin + offY;\n        float left = (ScreenUtils.getScreenWidth() - mPaint.getTextSize() * text.length()) / 2;\n        canvas.drawText(text, left, newY, mPaint);\n    }\n\n    private void drawLaser(Canvas canvas, Rect rect) {\n        // 绘制焦点框内固定的一条扫描线\n        mPaint.setColor(mLaserColor);\n        mPaint.setAlpha(SCANNER_ALPHA[mScannerAlpha]);\n        mScannerAlpha = (mScannerAlpha + 1) % SCANNER_ALPHA.length;\n        int middle = rect.height() / 2 + rect.top;\n        canvas.drawRect(rect.left + 2, middle - 1, rect.right - 1, middle + 2, mPaint);\n\n        mHandler.sendEmptyMessageDelayed(1, ANIMATION_DELAY);\n    }\n\n    private Handler mHandler = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n            invalidate();\n        }\n    };\n\n    private OnTouchListener touchListener;\n\n    private OnTouchListener getTouchListener() {\n\n        if (touchListener == null){\n            touchListener = new OnTouchListener() {\n\n                int lastX = -1;\n                int lastY = -1;\n\n                @Override\n                public boolean onTouch(View v, MotionEvent event) {\n                    switch (event.getAction()) {\n                        case MotionEvent.ACTION_DOWN:\n                            lastX = -1;\n                            lastY = -1;\n                            return true;\n                        case MotionEvent.ACTION_MOVE:\n                            int currentX = (int) event.getX();\n                            int currentY = (int) event.getY();\n                            try {\n                                Rect rect = mFrameRect;\n                                final int BUFFER = 60;\n                                if (lastX >= 0) {\n                                    \n                                    boolean currentXLeft = currentX >= rect.left - BUFFER && currentX <= rect.left + BUFFER;\n                                    boolean currentXRight = currentX >= rect.right - BUFFER && currentX <= rect.right + BUFFER;\n                                    boolean lastXLeft = lastX >= rect.left - BUFFER && lastX <= rect.left + BUFFER;\n                                    boolean lastXRight = lastX >= rect.right - BUFFER && lastX <= rect.right + BUFFER;\n                                    \n                                    boolean currentYTop = currentY <= rect.top + BUFFER && currentY >= rect.top - BUFFER;\n                                    boolean currentYBottom = currentY <= rect.bottom + BUFFER && currentY >= rect.bottom - BUFFER;\n                                    boolean lastYTop = lastY <= rect.top + BUFFER && lastY >= rect.top - BUFFER;\n                                    boolean lastYBottom = lastY <= rect.bottom + BUFFER && lastY >= rect.bottom - BUFFER;\n                                    \n                                    boolean XLeft = currentXLeft || lastXLeft;\n                                    boolean XRight = currentXRight || lastXRight;\n                                    boolean YTop = currentYTop || lastYTop;\n                                    boolean YBottom = currentYBottom || lastYBottom;\n                                    \n                                    boolean YTopBottom = (currentY <= rect.bottom && currentY >= rect.top)\n                                            || (lastY <= rect.bottom && lastY >= rect.top);\n\n                                    boolean XLeftRight = (currentX <= rect.right && currentX >= rect.left)\n                                            || (lastX <= rect.right && lastX >= rect.left);\n                                            \n                                        //右上角\n                                    if (XLeft && YTop) { \n                                        updateBoxRect(2 * (lastX - currentX), (lastY - currentY), true); \n                                        //左上角\n                                    } else if (XRight && YTop) {\n                                        updateBoxRect(2 * (currentX - lastX), (lastY - currentY), true);\n                                        //右下角\n                                    } else if (XLeft && YBottom) {\n                                        updateBoxRect(2 * (lastX - currentX), (currentY - lastY), false);\n                                        //左下角\n                                    } else if (XRight && YBottom) {\n                                        updateBoxRect(2 * (currentX - lastX), (currentY - lastY), false);\n                                        //左侧\n                                    } else if (XLeft && YTopBottom) { \n                                        updateBoxRect(2 * (lastX - currentX), 0, false);\n                                        //右侧\n                                    } else if (XRight && YTopBottom) { \n                                        updateBoxRect(2 * (currentX - lastX), 0, false);\n                                        //上方\n                                    } else if (YTop && XLeftRight) { \n                                        updateBoxRect(0, (lastY - currentY), true);\n                                        //下方\n                                    } else if (YBottom && XLeftRight) {\n                                        updateBoxRect(0, (currentY - lastY), false);\n                                    }\n                                }\n                            } catch (NullPointerException e) {\n                                e.printStackTrace();\n                            }\n                            v.invalidate();\n                            lastX = currentX;\n                            lastY = currentY;\n                            return true;\n                        case MotionEvent.ACTION_UP:\n                            //移除之前的刷新\n                            mHandler.removeMessages(1);\n                            //松手时对外更新\n                            mRect = mFrameRect; \n                            lastX = -1;\n                            lastY = -1;\n                            return true;\n                        default:\n                            \n                    }\n                    return false;\n                }\n            };\n        }\n\n        return touchListener;\n    }\n\n    private void updateBoxRect(int dW, int dH, boolean isUpward) {\n\n        int newWidth = (mFrameRect.width() + dW > ScrRes.x - 4 || mFrameRect.width() + dW < MIN_FOCUS_BOX_WIDTH)\n                ? 0 : mFrameRect.width() + dW;\n\n        //限制扫描框最大高度不超过屏幕宽度\n        int newHeight = (mFrameRect.height() + dH > ScrRes.x || mFrameRect.height() + dH < MIN_FOCUS_BOX_HEIGHT)\n                ? 0 : mFrameRect.height() + dH;\n\n        int leftOffset = (ScrRes.x - newWidth) / 2;\n\n        if (isUpward){\n            this.top -= dH;\n        }\n\n        int topOffset = this.top;\n\n        if (topOffset < MIN_FOCUS_BOX_TOP){\n            this.top = MIN_FOCUS_BOX_TOP;\n            return;\n        }\n\n        if (topOffset + newHeight > MIN_FOCUS_BOX_TOP + ScrRes.x){\n            return;\n        }\n\n        if (newWidth < MIN_FOCUS_BOX_WIDTH || newHeight < MIN_FOCUS_BOX_HEIGHT){\n            return;\n        }\n\n        mFrameRect = new Rect(leftOffset, topOffset, leftOffset + newWidth, topOffset + newHeight);\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mHandler.removeMessages(1);\n    }\n}\napp/src/main/java/com/zl/tesseract/scanner/tess/TesseractThread.java\npublic class TesseractThread implements Runnable {\n\n    private Bitmap mBitmap;\n    private TesseractCallback mCallback;\n\n    public TesseractThread(Bitmap mBitmap, TesseractCallback callback) {\n        this.mBitmap = mBitmap;\n        this.mCallback = callback;\n    }\n\n    @Override\n    public void run() {\n        if (mBitmap == null && null != mCallback) {\n            mCallback.fail();\n            return;\n        }\n        mCallback.succeed(TessEngine.Generate().detectText(mBitmap));\n    }\n}\napp/src/main/java/com/zl/tesseract/scanner/tess/TesseractCallback.java\npublic interface TesseractCallback {\n\n    void succeed(String result);\n\n    void fail();\n}\napp/src/main/java/com/zl/tesseract/scanner/decode/CaptureActivityHandler.java\npublic final class CaptureActivityHandler extends Handler {\n    private static final String TAG = CaptureActivityHandler.class.getName();\n\n    private final ScannerActivity mActivity;\n    private final DecodeThread mDecodeThread;\n    private State mState;\n\n    public CaptureActivityHandler(ScannerActivity activity) {\n        this.mActivity = activity;\n        mDecodeThread = new DecodeThread(activity);\n        mDecodeThread.start();\n        mState = State.SUCCESS;\n        // Start ourselves capturing previews and decoding.\n        restartPreviewAndDecode();\n    }\n\n    @Override\n    public void handleMessage(Message message) {\n        switch (message.what) {\n            case R.id.auto_focus:\n                // Log.d(TAG, \"Got auto-focus message\");\n                // When one auto focus pass finishes, start another. This is the closest thing to\n                // continuous AF. It does seem to hunt a bit, but I'm not sure what else to do.\n                if (mState == State.PREVIEW) {\n                    CameraManager.get().requestAutoFocus(this, R.id.auto_focus);\n                }\n                break;\n            case R.id.decode_succeeded:\n                Log.e(TAG, \"Got decode succeeded message\");\n                mState = State.SUCCESS;\n                mActivity.handleDecode((Result) message.obj);\n                break;\n            case R.id.decode_failed:\n                // We're decoding as fast as possible, so when one decode fails, start another.\n                mState = State.PREVIEW;\n                CameraManager.get().requestPreviewFrame(mDecodeThread.getHandler(), R.id.decode);\n                break;\n        }\n    }\n\n    public void quitSynchronously() {\n        mState = State.DONE;\n        CameraManager.get().stopPreview();\n        Message quit = Message.obtain(mDecodeThread.getHandler(), R.id.quit);\n        quit.sendToTarget();\n        try {\n            mDecodeThread.join();\n        } catch (InterruptedException e) {\n            // continue\n        }\n\n        // Be absolutely sure we don't send any queued up messages\n        removeMessages(R.id.decode_succeeded);\n        removeMessages(R.id.decode_failed);\n    }\n\n    public void restartPreviewAndDecode() {\n        if (mState != State.PREVIEW) {\n            CameraManager.get().startPreview();\n            mState = State.PREVIEW;\n            CameraManager.get().requestPreviewFrame(mDecodeThread.getHandler(), R.id.decode);\n            CameraManager.get().requestAutoFocus(this, R.id.auto_focus);\n        }\n    }\n\n    private enum State {\n        PREVIEW, SUCCESS, DONE\n    }\n\n    public void onPause() {\n        mState = State.DONE;\n        CameraManager.get().stopPreview();\n    }\n}\napp/src/main/java/com/zl/tesseract/scanner/utils/Tools.java\npublic class Tools {\n\n    public static Bitmap rotateBitmap(Bitmap source, float angle) {\n        Matrix matrix = new Matrix();\n        matrix.postRotate(angle);\n        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);\n    }\n\n    public static Bitmap preRotateBitmap(Bitmap source, float angle) {\n        Matrix matrix = new Matrix();\n        matrix.preRotate(angle);\n        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, false);\n    }\n\n    public enum ScalingLogic {\n        CROP, FIT\n    }\n\n    public static int calculateSampleSize(int srcWidth, int srcHeight, int dstWidth, int dstHeight,\n                                          ScalingLogic scalingLogic) {\n        if (scalingLogic == ScalingLogic.FIT) {\n            final float srcAspect = (float) srcWidth / (float) srcHeight;\n            final float dstAspect = (float) dstWidth / (float) dstHeight;\n\n            if (srcAspect > dstAspect) {\n                return srcWidth / dstWidth;\n            } else {\n                return srcHeight / dstHeight;\n            }\n        } else {\n            final float srcAspect = (float) srcWidth / (float) srcHeight;\n            final float dstAspect = (float) dstWidth / (float) dstHeight;\n\n            if (srcAspect > dstAspect) {\n                return srcHeight / dstHeight;\n            } else {\n                return srcWidth / dstWidth;\n            }\n        }\n    }\n\n    public static Bitmap decodeByteArray(byte[] bytes, int dstWidth, int dstHeight,\n                                        ScalingLogic scalingLogic) {\n        BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options);\n        options.inJustDecodeBounds = false;\n        options.inSampleSize = calculateSampleSize(options.outWidth, options.outHeight, dstWidth,\n                dstHeight, scalingLogic);\n        Bitmap unscaledBitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options);\n\n        return unscaledBitmap;\n    }\n\n    public static Rect calculateSrcRect(int srcWidth, int srcHeight, int dstWidth, int dstHeight,\n                                        ScalingLogic scalingLogic) {\n        if (scalingLogic == ScalingLogic.CROP) {\n            final float srcAspect = (float) srcWidth / (float) srcHeight;\n            final float dstAspect = (float) dstWidth / (float) dstHeight;\n\n            if (srcAspect > dstAspect) {\n                final int srcRectWidth = (int) (srcHeight * dstAspect);\n                final int srcRectLeft = (srcWidth - srcRectWidth) / 2;\n                return new Rect(srcRectLeft, 0, srcRectLeft + srcRectWidth, srcHeight);\n            } else {\n                final int srcRectHeight = (int) (srcWidth / dstAspect);\n                final int scrRectTop = (int) (srcHeight - srcRectHeight) / 2;\n                return new Rect(0, scrRectTop, srcWidth, scrRectTop + srcRectHeight);\n            }\n        } else {\n            return new Rect(0, 0, srcWidth, srcHeight);\n        }\n    }\n\n    public static Rect calculateDstRect(int srcWidth, int srcHeight, int dstWidth, int dstHeight,\n                                        ScalingLogic scalingLogic) {\n        if (scalingLogic == ScalingLogic.FIT) {\n            final float srcAspect = (float) srcWidth / (float) srcHeight;\n            final float dstAspect = (float) dstWidth / (float) dstHeight;\n\n            if (srcAspect > dstAspect) {\n                return new Rect(0, 0, dstWidth, (int) (dstWidth / srcAspect));\n            } else {\n                return new Rect(0, 0, (int) (dstHeight * srcAspect), dstHeight);\n            }\n        } else {\n            return new Rect(0, 0, dstWidth, dstHeight);\n        }\n    }\n\n    public static Bitmap createScaledBitmap(Bitmap unscaledBitmap, int dstWidth, int dstHeight,\n                                            ScalingLogic scalingLogic) {\n        Rect srcRect = calculateSrcRect(unscaledBitmap.getWidth(), unscaledBitmap.getHeight(),\n                dstWidth, dstHeight, scalingLogic);\n        Rect dstRect = calculateDstRect(unscaledBitmap.getWidth(), unscaledBitmap.getHeight(),\n                dstWidth, dstHeight, scalingLogic);\n        Bitmap scaledBitmap = Bitmap.createBitmap(dstRect.width(), dstRect.height(),\n                Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(scaledBitmap);\n        canvas.drawBitmap(unscaledBitmap, srcRect, dstRect, new Paint(Paint.FILTER_BITMAP_FLAG));\n\n        return scaledBitmap;\n    }\n\n    public static Bitmap getFocusedBitmap(Context context, Camera camera, byte[] data, Rect box){\n        Point ScrRes = ScreenUtils.getScreenResolution(context);\n        Point CamRes = CameraConfigurationUtils.findBestPreviewSizeValue(camera.getParameters(), ScrRes);\n\n        int SW = ScrRes.x;\n        int SH = ScrRes.y;\n\n        int RW = box.width();\n        int RH = box.height();\n        int RL = box.left;\n        int RT = box.top;\n\n        float RSW = (float) (RW * Math.pow(SW, -1));\n        float RSH = (float) (RH * Math.pow(SH, -1));\n\n        float RSL = (float) (RL * Math.pow(SW, -1));\n        float RST = (float) (RT * Math.pow(SH, -1));\n\n        float k = 0.5f;\n\n        int CW = CamRes.x;\n        int CH = CamRes.y;\n\n        int X = (int) (k * CW);\n        int Y = (int) (k * CH);\n\n        Bitmap unscaledBitmap = Tools.decodeByteArray(data, X, Y, ScalingLogic.CROP);\n        Bitmap bmp = Tools.createScaledBitmap(unscaledBitmap, X, Y, ScalingLogic.CROP);\n        unscaledBitmap.recycle();\n\n        if (CW > CH){\n            bmp = Tools.rotateBitmap(bmp, 90);\n        }\n\n        int BW = bmp.getWidth();\n        int BH = bmp.getHeight();\n\n        int RBL = (int) (RSL * BW);\n        int RBT = (int) (RST * BH);\n\n        int RBW = (int) (RSW * BW);\n        int RBH = (int) (RSH * BH);\n\n        Bitmap res = Bitmap.createBitmap(bmp, RBL, RBT, RBW, RBH);\n        bmp.recycle();\n\n        return res;\n    }\n\n    private static Pattern pattern = Pattern.compile(\"(1|861)\\\\d{10}$*\");\n\n    private static StringBuilder bf = new StringBuilder();\n\n    public static String getTelNum(String sParam){\n        if(TextUtils.isEmpty(sParam)){\n            return \"\";\n        }\n        \n        Matcher matcher = pattern.matcher(sParam.trim());\n        bf.delete(0, bf.length());\n\n        while (matcher.find()) {\n            bf.append(matcher.group()).append(\"\\n\");\n        }\n        int len = bf.length();\n        if (len > 0) {\n            bf.deleteCharAt(len - 1);\n        }\n        return bf.toString();\n    }\n}\nzxing/src/main/java/com/google/zxing/Result.java\npublic final class Result {\n\n  private final String text;\n  private final byte[] rawBytes;\n  private final int numBits;\n  private ResultPoint[] resultPoints;\n  private final BarcodeFormat format;\n  private Map<ResultMetadataType,Object> resultMetadata;\n  private final long timestamp;\n  private Bitmap bitmap;\n\n  public Result(String text,\n                byte[] rawBytes,\n                ResultPoint[] resultPoints,\n                BarcodeFormat format) {\n    this(text, rawBytes, resultPoints, format, System.currentTimeMillis());\n  }\n\n  public Result(String text,\n                byte[] rawBytes,\n                ResultPoint[] resultPoints,\n                BarcodeFormat format,\n                long timestamp) {\n    this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,\n         resultPoints, format, timestamp);\n  }\n\n  public Result(String text,\n                byte[] rawBytes,\n                int numBits,\n                ResultPoint[] resultPoints,\n                BarcodeFormat format,\n                long timestamp) {\n    this.text = text;\n    this.rawBytes = rawBytes;\n    this.numBits = numBits;\n    this.resultPoints = resultPoints;\n    this.format = format;\n    this.resultMetadata = null;\n    this.timestamp = timestamp;\n  }\n\n  /**\n   * @return raw text encoded by the barcode\n   */\n  public String getText() {\n    return text;\n  }\n\n  /**\n   * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}\n   */\n  public byte[] getRawBytes() {\n    return rawBytes;\n  }\n\n  /**\n   * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n   * @since 3.3.0\n   */\n  public int getNumBits() {\n    return numBits;\n  }\n\n  /**\n   * @return points related to the barcode in the image. These are typically points\n   *         identifying finder patterns or the corners of the barcode. The exact meaning is\n   *         specific to the type of barcode that was decoded.\n   */\n  public ResultPoint[] getResultPoints() {\n    return resultPoints;\n  }\n\n  /**\n   * @return {@link BarcodeFormat} representing the format of the barcode that was decoded\n   */\n  public BarcodeFormat getBarcodeFormat() {\n    return format;\n  }\n\n  /**\n   * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be\n   *   {@code null}. This contains optional metadata about what was detected about the barcode,\n   *   like orientation.\n   */\n  public Map<ResultMetadataType,Object> getResultMetadata() {\n    return resultMetadata;\n  }\n\n  public void putMetadata(ResultMetadataType type, Object value) {\n    if (resultMetadata == null) {\n      resultMetadata = new EnumMap<>(ResultMetadataType.class);\n    }\n    resultMetadata.put(type, value);\n  }\n\n  public void putAllMetadata(Map<ResultMetadataType,Object> metadata) {\n    if (metadata != null) {\n      if (resultMetadata == null) {\n        resultMetadata = metadata;\n      } else {\n        resultMetadata.putAll(metadata);\n      }\n    }\n  }\n\n  public void addResultPoints(ResultPoint[] newPoints) {\n    ResultPoint[] oldPoints = resultPoints;\n    if (oldPoints == null) {\n      resultPoints = newPoints;\n    } else if (newPoints != null && newPoints.length > 0) {\n      ResultPoint[] allPoints = new ResultPoint[oldPoints.length + newPoints.length];\n      System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);\n      System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);\n      resultPoints = allPoints;\n    }\n  }\n\n  public long getTimestamp() {\n    return timestamp;\n  }\n\n  @Override\n  public String toString() {\n    return text;\n  }\n\n  public Bitmap getBitmap() {\n    return bitmap;\n  }\n\n  public void setBitmap(Bitmap bitmap) {\n    this.bitmap = bitmap;\n  }\n}\n", "answers": ["        ImageDialog dialog = new ImageDialog(this);"], "length": 3804, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "28cc0558deb112476f35aadd40309503e6fd131e89a9bcf2"}
{"input": "package aurelienribon.bodyeditor.canvas.rigidbodies;\nimport aurelienribon.bodyeditor.Ctx;\nimport aurelienribon.bodyeditor.RigidBodiesManager;\nimport aurelienribon.bodyeditor.Settings;\nimport aurelienribon.bodyeditor.canvas.Assets;\nimport aurelienribon.bodyeditor.canvas.Canvas;\nimport aurelienribon.bodyeditor.canvas.Label;\nimport aurelienribon.bodyeditor.canvas.Label.Anchor;\nimport aurelienribon.bodyeditor.canvas.rigidbodies.input.CreationInputProcessor;\nimport aurelienribon.bodyeditor.canvas.rigidbodies.input.EditionInputProcessor;\nimport aurelienribon.bodyeditor.canvas.rigidbodies.input.TestInputProcessor;\nimport aurelienribon.bodyeditor.maths.Tracer;\nimport aurelienribon.bodyeditor.models.CircleModel;\nimport aurelienribon.bodyeditor.models.PolygonModel;\nimport aurelienribon.bodyeditor.models.RigidBodyModel;\nimport aurelienribon.bodyeditor.models.ShapeModel;\nimport aurelienribon.bodyeditor.ui.AutoTraceParamsDialog;\nimport aurelienribon.bodyeditor.utils.ShapeUtils;\nimport aurelienribon.tweenengine.BaseTween;\nimport aurelienribon.tweenengine.Tween;\nimport aurelienribon.tweenengine.TweenCallback;\nimport aurelienribon.tweenengine.TweenManager;\nimport aurelienribon.utils.gdx.PolygonUtils;\nimport aurelienribon.utils.notifications.ChangeListener;\nimport aurelienribon.utils.notifications.ObservableList;\nimport com.badlogic.gdx.Gdx;\nimport com.badlogic.gdx.Input;\nimport com.badlogic.gdx.InputAdapter;\nimport com.badlogic.gdx.InputProcessor;\nimport com.badlogic.gdx.graphics.Color;\nimport com.badlogic.gdx.graphics.Texture;\nimport com.badlogic.gdx.graphics.g2d.Sprite;\nimport com.badlogic.gdx.graphics.g2d.TextureRegion;\nimport com.badlogic.gdx.math.MathUtils;\nimport com.badlogic.gdx.math.Vector2;\nimport com.badlogic.gdx.physics.box2d.Body;\nimport com.badlogic.gdx.physics.box2d.BodyDef;\nimport com.badlogic.gdx.physics.box2d.BodyDef.BodyType;\nimport com.badlogic.gdx.physics.box2d.Box2DDebugRenderer;\nimport com.badlogic.gdx.physics.box2d.CircleShape;\nimport com.badlogic.gdx.physics.box2d.FixtureDef;\nimport com.badlogic.gdx.physics.box2d.PolygonShape;\nimport com.badlogic.gdx.physics.box2d.World;\nimport com.badlogic.gdx.utils.Array;\nimport javax.swing.*;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\n\n\npublic class RigidBodiesScreen {\n    private final Canvas canvas;\n    private final RigidBodiesScreenDrawer drawer;\n    private final Box2DDebugRenderer debugRdr = new Box2DDebugRenderer();\n    private final TweenManager tweenManager = new TweenManager();\n    private float timeAcc = 0;\n\n    private final List<Sprite> ballsSprites = new ArrayList<Sprite>();\n    private final List<Body> ballsBodies = new ArrayList<Body>();\n    private final World world = new World(new Vector2(0, 0), true);\n    private Sprite bodySprite;\n\n    private final InputProcessor creationInputProcessor;\n    private final InputProcessor editionInputProcessor;\n    private final InputProcessor testInputProcessor;\n", "context": "editor/src/main/java/aurelienribon/bodyeditor/canvas/rigidbodies/input/TestInputProcessor.java\npublic class TestInputProcessor extends InputAdapter {\n    private final Canvas canvas;\n    private final RigidBodiesScreen screen;\n    private boolean touchDown = false;\n\n    public TestInputProcessor(Canvas canvas, RigidBodiesScreen screen) {\n        this.canvas = canvas;\n        this.screen = screen;\n    }\n\n    @Override\n    public boolean touchDown(int x, int y, int pointer, int button) {\n        touchDown = button == Buttons.LEFT;\n        if (!touchDown) return false;\n\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        if (model == null) return false;\n\n        Vector2 p = canvas.screenToWorld(x, y);\n        screen.ballThrowP1 = p;\n        screen.ballThrowP2 = p;\n        return false;\n    }\n\n    @Override\n    public boolean touchUp(int x, int y, int pointer, int button) {\n        if (!touchDown) return false;\n        touchDown = false;\n\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        if (model == null) return false;\n\n        Vector2 p1 = screen.ballThrowP1;\n        Vector2 p2 = screen.ballThrowP2;\n        Vector2 delta = new Vector2(p2).sub(p1);\n        screen.fireBall(p1, delta.scl(3f));\n\n        screen.ballThrowP1 = null;\n        screen.ballThrowP2 = null;\n        return false;\n    }\n\n    @Override\n    public boolean touchDragged(int x, int y, int pointer) {\n        if (!touchDown) return false;\n\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        if (model == null) return false;\n\n        Vector2 p = canvas.screenToWorld(x, y);\n        screen.ballThrowP2 = p;\n        return false;\n    }\n}\neditor/src/main/java/aurelienribon/utils/notifications/ChangeListener.java\npublic interface ChangeListener {\n    public void propertyChanged(Object source, String propertyName);\n}\neditor/src/main/java/aurelienribon/bodyeditor/ui/AutoTraceParamsDialog.java\npublic class AutoTraceParamsDialog extends javax.swing.JDialog {\n    private boolean result = false;\n\n    public AutoTraceParamsDialog(javax.swing.JFrame parent) {\n        super(parent, true);\n\n        setContentPane(new PaintedPanel());\n        initComponents();\n\n        Style.registerCssClasses(getContentPane(), \".rootPanel\", \".configPanel\");\n        Style.registerCssClasses(commentLabel, \".brightcomment\");\n        Style.apply(getContentPane(), new Style(Res.getUrl(\"/css/style.css\")));\n\n        hullToleranceSlider.setValue((int) (Settings.autoTraceHullTolerance * 100));\n        alphaToleranceSlider.setValue(Settings.autoTraceAlphaTolerance);\n        multiPartDetectionChk.setSelected(Settings.autoTraceMultiPartDetection);\n        holeDetectionChk.setSelected(Settings.autoTraceHoleDetection);\n\n        okBtn.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                Settings.autoTraceHullTolerance = hullToleranceSlider.getValue() / 100f;\n                Settings.autoTraceAlphaTolerance = alphaToleranceSlider.getValue();\n                Settings.autoTraceMultiPartDetection = multiPartDetectionChk.isSelected();\n                Settings.autoTraceHoleDetection = holeDetectionChk.isSelected();\n                dispose();\n                result = true;\n            }\n        });\n\n        cancelBtn.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                dispose();\n            }\n        });\n    }\n\n    public boolean prompt() {\n        setVisible(true);\n        dispose();\n        return result;\n    }\n\n    // -------------------------------------------------------------------------\n    // Generated stuff\n    // -------------------------------------------------------------------------\n\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        paintedPanel1 = new aurelienribon.ui.components.PaintedPanel();\n        hullToleranceSlider = new javax.swing.JSlider();\n        alphaToleranceSlider = new javax.swing.JSlider();\n        multiPartDetectionChk = new javax.swing.JCheckBox();\n        holeDetectionChk = new javax.swing.JCheckBox();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        okBtn = new javax.swing.JButton();\n        cancelBtn = new javax.swing.JButton();\n        commentLabel = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        setTitle(\"Auto-trace parameters\");\n        setResizable(false);\n\n        hullToleranceSlider.setMajorTickSpacing(100);\n        hullToleranceSlider.setMaximum(400);\n        hullToleranceSlider.setMinimum(100);\n        hullToleranceSlider.setMinorTickSpacing(10);\n        hullToleranceSlider.setPaintTicks(true);\n        hullToleranceSlider.setValue(400);\n\n        alphaToleranceSlider.setMaximum(255);\n        alphaToleranceSlider.setMinorTickSpacing(5);\n        alphaToleranceSlider.setPaintTicks(true);\n        alphaToleranceSlider.setValue(128);\n\n        multiPartDetectionChk.setText(\"Multi-part detection\");\n\n        holeDetectionChk.setText(\"Hole detection\");\n\n        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);\n        jLabel1.setText(\"Hull tolerance: \");\n\n        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);\n        jLabel2.setText(\"Alpha tolerance: \");\n\n        okBtn.setText(\"Ok\");\n\n        cancelBtn.setText(\"Cancel\");\n\n        javax.swing.GroupLayout paintedPanel1Layout = new javax.swing.GroupLayout(paintedPanel1);\n        paintedPanel1.setLayout(paintedPanel1Layout);\n        paintedPanel1Layout.setHorizontalGroup(\n                paintedPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                        .addGroup(paintedPanel1Layout.createSequentialGroup()\n                                .addContainerGap()\n                                .addGroup(paintedPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addGroup(paintedPanel1Layout.createSequentialGroup()\n                                                .addComponent(jLabel1)\n                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                                .addComponent(hullToleranceSlider, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, paintedPanel1Layout.createSequentialGroup()\n                                                .addComponent(jLabel2)\n                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                                .addComponent(alphaToleranceSlider, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                                        .addGroup(paintedPanel1Layout.createSequentialGroup()\n                                                .addComponent(multiPartDetectionChk)\n                                                .addGap(0, 0, Short.MAX_VALUE))\n                                        .addGroup(paintedPanel1Layout.createSequentialGroup()\n                                                .addComponent(holeDetectionChk)\n                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                                .addComponent(okBtn)\n                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                                .addComponent(cancelBtn)))\n                                .addContainerGap())\n        );\n\n        paintedPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[]{jLabel1, jLabel2});\n\n        paintedPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[]{cancelBtn, okBtn});\n\n        paintedPanel1Layout.setVerticalGroup(\n                paintedPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                        .addGroup(paintedPanel1Layout.createSequentialGroup()\n                                .addContainerGap()\n                                .addGroup(paintedPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addComponent(hullToleranceSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addComponent(jLabel1))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(paintedPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addComponent(alphaToleranceSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addComponent(jLabel2))\n                                .addGap(18, 18, 18)\n                                .addComponent(multiPartDetectionChk)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(paintedPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                        .addComponent(holeDetectionChk)\n                                        .addComponent(okBtn)\n                                        .addComponent(cancelBtn))\n                                .addContainerGap())\n        );\n\n        paintedPanel1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[]{alphaToleranceSlider, hullToleranceSlider, jLabel1, jLabel2});\n\n        commentLabel.setText(\"<html>\\nOnly check multi-part detection or hole detection if your image needs it.<br/>\\nRemember that auto-trace is less precise than manually placed points.\");\n        commentLabel.setVerticalAlignment(javax.swing.SwingConstants.TOP);\n\n        jLabel3.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/gfx/autoTrace.png\"))); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                        .addGroup(layout.createSequentialGroup()\n                                .addComponent(jLabel3)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addComponent(paintedPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                        .addComponent(commentLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 388, Short.MAX_VALUE))\n                                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                        .addGroup(layout.createSequentialGroup()\n                                .addContainerGap()\n                                .addComponent(paintedPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(commentLabel)\n                                .addContainerGap())\n                        .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n\n        pack();\n    }// </editor-fold>//GEN-END:initComponents\n\n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    private javax.swing.JSlider alphaToleranceSlider;\n    private javax.swing.JButton cancelBtn;\n    private javax.swing.JLabel commentLabel;\n    private javax.swing.JCheckBox holeDetectionChk;\n    private javax.swing.JSlider hullToleranceSlider;\n    private javax.swing.JLabel jLabel1;\n    private javax.swing.JLabel jLabel2;\n    private javax.swing.JLabel jLabel3;\n    private javax.swing.JCheckBox multiPartDetectionChk;\n    private javax.swing.JButton okBtn;\n    private aurelienribon.ui.components.PaintedPanel paintedPanel1;\n    // End of variables declaration//GEN-END:variables\n}\neditor/src/main/java/aurelienribon/utils/gdx/PolygonUtils.java\npublic class PolygonUtils {\n    public static float getPolygonSignedArea(Vector2[] points) {\n        if (points.length < 3)\n            return 0;\n\n        float sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            Vector2 p1 = points[i];\n            Vector2 p2 = i != points.length - 1 ? points[i + 1] : points[0];\n            sum += (p1.x * p2.y) - (p1.y * p2.x);\n        }\n        return 0.5f * sum;\n    }\n\n    public static float getPolygonArea(Vector2[] points) {\n        return Math.abs(getPolygonSignedArea(points));\n    }\n\n    public static boolean isPolygonCCW(Vector2[] points) {\n        return getPolygonSignedArea(points) > 0;\n    }\n}\neditor/src/main/java/aurelienribon/bodyeditor/utils/ShapeUtils.java\npublic class ShapeUtils {\n    public static ShapeModel getShape(RigidBodyModel model, Vector2 v) {\n        for (ShapeModel shape : model.getShapes()) {\n            if (shape.getVertices().contains(v)) return shape;\n        }\n\n        return null;\n    }\n}\neditor/src/main/java/aurelienribon/bodyeditor/canvas/Label.java\npublic static enum Anchor {TOP_LEFT, BOTTOM_LEFT, TOP_RIGHT, BOTTOM_RIGHT}\neditor/src/main/java/aurelienribon/bodyeditor/Settings.java\npublic class Settings {\n    public static boolean isImageDrawn = true;\n    public static boolean isShapeDrawn = true;\n    public static boolean isPolygonDrawn = true;\n    public static boolean isPhysicsDebugEnabled = false;\n    public static boolean isSnapToGridEnabled = false;\n    public static boolean isAxisShown = true;\n    public static boolean isGridShown = false;\n    public static float gridGap = 0.03f;\n    public static Polygonizer polygonizer = Polygonizer.BAYAZIT;\n    public static float autoTraceHullTolerance = 2.5f;\n    public static int autoTraceAlphaTolerance = 128;\n    public static boolean autoTraceMultiPartDetection = false;\n    public static boolean autoTraceHoleDetection = false;\n}\neditor/src/main/java/aurelienribon/bodyeditor/models/ShapeModel.java\npublic class ShapeModel {\n    public enum Type {POLYGON, CIRCLE}\n\n    private final List<Vector2> vertices = new ArrayList<Vector2>();\n    private final Type type;\n    private boolean isClosed = false;\n\n    public ShapeModel(Type type) {\n        this.type = type;\n    }\n\n    public List<Vector2> getVertices() {\n        return vertices;\n    }\n\n    public Type getType() {\n        return type;\n    }\n\n    public void close() {\n        isClosed = true;\n    }\n\n    public boolean isClosed() {\n        return isClosed;\n    }\n}\neditor/src/main/java/aurelienribon/bodyeditor/canvas/rigidbodies/input/CreationInputProcessor.java\npublic class CreationInputProcessor extends InputAdapter {\n    private final Canvas canvas;\n    private final RigidBodiesScreen screen;\n    private boolean touchDown = false;\n\n    public CreationInputProcessor(Canvas canvas, RigidBodiesScreen screen) {\n        this.canvas = canvas;\n        this.screen = screen;\n    }\n\n    @Override\n    public boolean touchDown(int x, int y, int pointer, int button) {\n        touchDown = button == Buttons.LEFT;\n        if (!touchDown) return false;\n\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        if (model == null) return false;\n\n        List<ShapeModel> shapes = model.getShapes();\n        ShapeModel lastShape = shapes.isEmpty() ? null : shapes.get(shapes.size() - 1);\n\n        if (lastShape == null || lastShape.isClosed()) {\n            ShapeModel.Type type = InputHelper.isCtrlDown() ? ShapeModel.Type.CIRCLE : ShapeModel.Type.POLYGON;\n            lastShape = new ShapeModel(type);\n            lastShape.getVertices().add(canvas.alignedScreenToWorld(x, y));\n            shapes.add(lastShape);\n\n        } else {\n            List<Vector2> vs = lastShape.getVertices();\n            Vector2 np = screen.nearestPoint;\n            ShapeModel.Type type = lastShape.getType();\n\n            if (type == ShapeModel.Type.POLYGON && vs.size() >= 3 && np == vs.get(0)) {\n                lastShape.close();\n                model.computePhysics();\n                screen.buildBody();\n            } else if (type == ShapeModel.Type.CIRCLE) {\n                vs.add(canvas.alignedScreenToWorld(x, y));\n                lastShape.close();\n                model.computePhysics();\n                screen.buildBody();\n            } else {\n                vs.add(canvas.alignedScreenToWorld(x, y));\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean touchUp(int x, int y, int pointer, int button) {\n        touchDown = false;\n        return false;\n    }\n\n    @Override\n    public boolean touchDragged(int x, int y, int pointer) {\n        if (!touchDown) return false;\n        mouseMoved(x, y);\n        return false;\n    }\n\n    @Override // possibly mouseMoved?\n    public boolean mouseMoved(int x, int y) {\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        if (model == null) return false;\n\n        // Nearest point computation\n\n        screen.nearestPoint = null;\n        Vector2 p = canvas.screenToWorld(x, y);\n\n        List<ShapeModel> shapes = model.getShapes();\n        ShapeModel lastShape = shapes.isEmpty() ? null : shapes.get(shapes.size() - 1);\n\n        if (lastShape != null) {\n            List<Vector2> vs = lastShape.getVertices();\n            float zoom = canvas.worldCamera.zoom;\n\n            if (!lastShape.isClosed() && vs.size() >= 3)\n                if (vs.get(0).dst(p) < 0.025f * zoom)\n                    screen.nearestPoint = vs.get(0);\n        }\n\n        // Next point assignment\n\n        screen.nextPoint = canvas.alignedScreenToWorld(x, y);\n        return false;\n    }\n\n    @Override\n    public boolean keyDown(int keycode) {\n        switch (keycode) {\n            case Input.Keys.ESCAPE:\n                RigidBodyModel model = Ctx.bodies.getSelectedModel();\n                if (model == null) break;\n                if (model.getShapes().isEmpty()) break;\n                if (model.getShapes().get(model.getShapes().size() - 1).isClosed()) break;\n                model.getShapes().remove(model.getShapes().size() - 1);\n                break;\n        }\n        return false;\n    }\n}\neditor/src/main/java/aurelienribon/bodyeditor/canvas/Label.java\npublic class Label {\n    static {\n        Tween.registerAccessor(Label.class, new Accessor());\n    }\n\n    public static enum Anchor {TOP_LEFT, BOTTOM_LEFT, TOP_RIGHT, BOTTOM_RIGHT}\n\n    private static enum State {SHOWN, HIDDEN, HIDDEN_SEMI}\n\n    private String text;\n    private Sprite icon;\n    private TouchCallback callback;\n    private final BitmapFont font;\n    private final Color color;\n    private final Anchor anchor;\n    private GlyphLayout layout = new GlyphLayout();\n\n    private final TweenManager tweenManager = new TweenManager();\n    private final Sprite bg;\n    private final float y, w, h;\n    private float offsetX;\n    private boolean isTouchOver = false;\n    private State state = State.HIDDEN;\n\n    public Label(float y, float w, float h, String text, BitmapFont font, Color color, Anchor anchor) {\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        this.text = text;\n        this.font = font;\n        this.color = color;\n        this.anchor = anchor;\n\n        this.bg = new Sprite(Assets.inst().get(\"data/white.png\", Texture.class));\n        bg.setSize(w * 11 / 10, h);\n        bg.setColor(color);\n\n        offsetX = -w;\n    }\n\n    // -------------------------------------------------------------------------\n    // Callback\n    // -------------------------------------------------------------------------\n\n    public static interface TouchCallback {\n        public void touchDown(Label source);\n\n        public void touchEnter(Label source);\n\n        public void touchExit(Label source);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public API\n    // -------------------------------------------------------------------------\n\n    public void setText(String text) {\n        this.text = text;\n    }\n\n    public void setIcon(String path) {\n        this.icon = new Sprite(Assets.inst().get(path, Texture.class));\n    }\n\n    public void setCallback(TouchCallback callback) {\n        this.callback = callback;\n    }\n\n    public void hide() {\n        if (state == State.HIDDEN) return;\n        tweenManager.killTarget(this);\n        Tween.to(this, Accessor.OFFSET_X, 0.3f).target(-w).start(tweenManager);\n        Tween.to(this, Accessor.ALPHA, 0.3f).target(color.a).start(tweenManager);\n        isTouchOver = false;\n        state = State.HIDDEN;\n    }\n\n    public void hideSemi() {\n        if (state == State.HIDDEN_SEMI) return;\n        tweenManager.killTarget(this);\n        Tween.to(this, Accessor.OFFSET_X, 0.3f).target(w / 10 - w).start(tweenManager);\n        Tween.to(this, Accessor.ALPHA, 0.3f).target(color.a).start(tweenManager);\n        isTouchOver = false;\n        state = State.HIDDEN_SEMI;\n    }\n\n    public void show() {\n        if (state == State.SHOWN) return;\n        tweenManager.killTarget(this);\n        Tween.to(this, Accessor.OFFSET_X, 0.3f).target(0).start(tweenManager);\n        Tween.to(this, Accessor.ALPHA, 0.3f).target(color.a).start(tweenManager);\n        state = State.SHOWN;\n    }\n\n    public void tiltOn() {\n        float tx;\n\n        switch (state) {\n            case SHOWN:\n                tx = w / 10;\n                break;\n            case HIDDEN_SEMI:\n                tx = -w + w / 10 + w / 10;\n                break;\n            default:\n                return;\n        }\n\n        tweenManager.killTarget(this);\n        Tween.to(this, Accessor.ALPHA, 0.2f).target(1).start(tweenManager);\n        Tween.to(this, Accessor.OFFSET_X, 0.2f).target(tx).start(tweenManager);\n    }\n\n    public void tiltOff() {\n        float tx;\n\n        switch (state) {\n            case SHOWN:\n                tx = 0;\n                break;\n            case HIDDEN_SEMI:\n                tx = -w + w / 10;\n                break;\n            default:\n                return;\n        }\n\n        tweenManager.killTarget(this);\n        Tween.to(this, Accessor.ALPHA, 0.2f).target(color.a).start(tweenManager);\n        Tween.to(this, Accessor.OFFSET_X, 0.2f).target(tx).start(tweenManager);\n    }\n\n    public void draw(SpriteBatch batch) {\n        tweenManager.update(Gdx.graphics.getDeltaTime());\n\n        float sw = Gdx.graphics.getWidth();\n        float sh = Gdx.graphics.getHeight();\n        float x = isAnchorLeft() ? offsetX : sw - w - offsetX;\n        float bgX = isAnchorLeft() ? x - w / 10 : x;\n\n        layout.setText(font, text);\n        float width = layout.width;// contains the width of the current set text\n        float textH = layout.height; // contains the height of the current set text\n\n        bg.setPosition(bgX, sh - y);\n        bg.draw(batch);\n\n        if (icon != null) {\n            icon.setPosition(x + 10, sh - y + h / 2 - icon.getHeight() / 2);\n            icon.draw(batch);\n            font.setColor(Color.WHITE);\n            font.draw(batch, text, x + 10 + icon.getWidth() + 10, sh - y + h / 2 + textH / 2);\n        } else {\n            font.setColor(Color.WHITE);\n            font.draw(batch, text, x + 10, sh - y + h / 2 + textH / 2);\n        }\n    }\n\n    public boolean touchMoved(int x, int y) {\n        y = Gdx.graphics.getHeight() - y - 1;\n        if (isOver(x, y) && !isTouchOver && state == State.SHOWN) {\n            isTouchOver = true;\n            tiltOn();\n            if (callback != null) callback.touchEnter(this);\n        } else if (!isOver(x, y) && isTouchOver) {\n            isTouchOver = false;\n            tiltOff();\n            if (callback != null) callback.touchExit(this);\n        }\n        return isOver(x, y);\n    }\n\n    public boolean touchDown(int x, int y) {\n        y = Gdx.graphics.getHeight() - y - 1;\n        if (isOver(x, y) && callback != null) callback.touchDown(this);\n        return isOver(x, y);\n    }\n\n    // -------------------------------------------------------------------------\n    // Helpers\n    // -------------------------------------------------------------------------\n\n    private boolean isOver(float x, float y) {\n        return SpriteUtils.isOver(bg, x, y);\n    }\n\n    private boolean isAnchorLeft() {\n        return anchor == Anchor.BOTTOM_LEFT || anchor == Anchor.TOP_LEFT;\n    }\n\n    // -------------------------------------------------------------------------\n    // Tween Accessor\n    // -------------------------------------------------------------------------\n\n    private static class Accessor implements TweenAccessor<Label> {\n        public static final int OFFSET_X = 1;\n        public static final int ALPHA = 2;\n\n        @Override\n        public int getValues(Label target, int tweenType, float[] returnValues) {\n            switch (tweenType) {\n                case OFFSET_X:\n                    returnValues[0] = target.offsetX;\n                    return 1;\n                case ALPHA:\n                    returnValues[0] = target.bg.getColor().a;\n                    return 1;\n                default:\n                    assert false;\n                    return -1;\n            }\n        }\n\n        @Override\n        public void setValues(Label target, int tweenType, float[] newValues) {\n            switch (tweenType) {\n                case OFFSET_X:\n                    target.offsetX = newValues[0];\n                    break;\n                case ALPHA:\n                    Color c = target.bg.getColor();\n                    target.bg.setColor(c.r, c.g, c.b, newValues[0]);\n                    break;\n                default:\n                    assert false;\n            }\n        }\n    }\n\n    ;\n}\neditor/src/main/java/aurelienribon/bodyeditor/canvas/Assets.java\npublic class Assets extends AssetManager {\n    private static Assets instance = new Assets();\n\n    public static Assets inst() {\n        return instance;\n    }\n\n    private final Map<RigidBodyModel, TextureRegion> rigidBodiesRegions = new HashMap<RigidBodyModel, TextureRegion>();\n    private TextureRegion unknownRegion;\n\n    public void initialize() {\n        String[] texturesNearest = new String[]{\n                \"data/transparent-light.png\",\n                \"data/transparent-dark.png\",\n                \"data/white.png\"\n        };\n\n        String[] texturesLinear = new String[]{\n                \"data/ball.png\",\n                \"data/v00.png\",\n                \"data/v01.png\",\n                \"data/v10.png\",\n                \"data/unknown.png\"\n        };\n\n        for (String tex : texturesNearest) load(tex, Texture.class);\n        for (String tex : texturesLinear) load(tex, Texture.class);\n\n        while (update() == false) {\n        }\n\n        for (String tex : texturesLinear) {\n            get(tex, Texture.class).setFilter(Texture.TextureFilter.Linear, Texture.TextureFilter.Linear);\n        }\n\n        unknownRegion = new TextureRegion(get(\"data/unknown.png\", Texture.class));\n\n        Ctx.bodies.getModels().addListChangedListener(new ObservableList.ListChangeListener<RigidBodyModel>() {\n            @Override\n            public void changed(Object source, List<RigidBodyModel> added, List<RigidBodyModel> removed) {\n                for (RigidBodyModel body : removed) {\n                    TextureRegion region = rigidBodiesRegions.remove(body);\n                    if (region != null) region.getTexture().dispose();\n                }\n\n                for (RigidBodyModel body : added) {\n                    load(body);\n                }\n            }\n        });\n    }\n\n    public TextureRegion getRegion(RigidBodyModel body) {\n        if (!body.isImagePathValid()) return unknownRegion;\n        if (body.getImagePath() == null) return null;\n        if (!rigidBodiesRegions.containsKey(body)) load(body);\n        return rigidBodiesRegions.get(body);\n    }\n\n    private void load(RigidBodyModel body) {\n        if (!body.isImagePathValid()) return;\n        if (body.getImagePath() == null) return;\n\n        File file = Ctx.io.getImageFile(body.getImagePath());\n        TextureRegion region = TextureUtils.getPOTTexture(file.getPath());\n        rigidBodiesRegions.put(body, region);\n    }\n}\neditor/src/main/java/aurelienribon/utils/notifications/ObservableList.java\npublic class ObservableList<T> extends ArrayList<T> {\n    private final Object source;\n    private final List<T> evtList1 = new ArrayList<T>();\n    private final List<T> evtList2 = new ArrayList<T>();\n\n    public ObservableList() {\n        this.source = null;\n    }\n\n    public ObservableList(Object source) {\n        this.source = source;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public API\n    // -------------------------------------------------------------------------\n\n    @Override\n    public boolean add(T e) {\n        boolean ret = super.add(e);\n        evtList1.clear();\n        evtList1.add(e);\n        fireElementsAdded(evtList1);\n        return ret;\n    }\n\n    @Override\n    public void add(int index, T element) {\n        super.add(index, element);\n        evtList1.clear();\n        evtList1.add(element);\n        fireElementsAdded(evtList1);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> c) {\n        boolean ret = super.addAll(c);\n        evtList1.clear();\n        evtList1.addAll(c);\n        fireElementsAdded(evtList1);\n        return ret;\n    }\n\n    @Override\n    public boolean addAll(int index, Collection<? extends T> c) {\n        boolean ret = super.addAll(index, c);\n        evtList1.clear();\n        evtList1.addAll(c);\n        fireElementsAdded(evtList1);\n        return ret;\n    }\n\n    @Override\n    public boolean remove(Object o) {\n        boolean ret = super.remove(o);\n        if (ret == true) {\n            evtList1.clear();\n            evtList1.add((T) o);\n            fireElementsRemoved(evtList1);\n        }\n        return ret;\n    }\n\n    @Override\n    public T remove(int index) {\n        T e = super.remove(index);\n        if (e != null) {\n            evtList1.clear();\n            evtList1.add(e);\n            fireElementsRemoved(evtList1);\n        }\n        return e;\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        evtList1.clear();\n        for (Object o : c) if (contains(o)) evtList1.add((T) o);\n        boolean ret = super.removeAll(c);\n        if (ret == true) fireElementsRemoved(evtList1);\n        return ret;\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        evtList1.clear();\n        for (T e : this) if (!c.contains(e)) evtList1.add(e);\n        boolean ret = super.retainAll(c);\n        if (ret == true) fireElementsRemoved(evtList1);\n        return ret;\n    }\n\n    @Override\n    public void clear() {\n        evtList1.clear();\n        evtList1.addAll(this);\n        super.clear();\n        fireElementsRemoved(evtList1);\n    }\n\n    @Override\n    public T set(int index, T element) {\n        T e = super.set(index, element);\n        evtList1.clear();\n        evtList1.add(e);\n        fireElementsRemoved(evtList1);\n        evtList1.clear();\n        evtList1.add(element);\n        fireElementsAdded(evtList1);\n        return e;\n    }\n\n    public void replaceBy(T element) {\n        evtList1.clear();\n        evtList2.clear();\n        if (!contains(element)) evtList1.add(element);\n        for (T e : this) if (e != element) evtList2.add(e);\n        super.clear();\n        super.add(element);\n        if (!evtList1.isEmpty() || !evtList2.isEmpty()) fireChanged(evtList1, evtList2);\n    }\n\n    public void replaceBy(Collection<T> c) {\n        evtList1.clear();\n        evtList2.clear();\n        for (T e : c) if (!contains(e)) evtList1.add(e);\n        for (T e : this) if (!c.contains(e)) evtList2.add(e);\n        super.clear();\n        super.addAll(c);\n        if (!evtList1.isEmpty() || !evtList2.isEmpty()) fireChanged(evtList1, evtList2);\n    }\n\n    // -------------------------------------------------------------------------\n    // Events\n    // -------------------------------------------------------------------------\n\n    private final EventListenerList listeners = new EventListenerList();\n\n    public static interface ListChangeListener<T> extends EventListener {\n        public void changed(Object source, List<T> added, List<T> removed);\n    }\n\n    public void addListChangedListener(ListChangeListener<T> listener) {\n        listeners.add(ListChangeListener.class, listener);\n    }\n\n    public void removeListChangedListener(ListChangeListener<T> listener) {\n        listeners.remove(ListChangeListener.class, listener);\n    }\n\n    private void fireElementsAdded(List<T> elems) {\n        if (elems.isEmpty()) return;\n        for (ListChangeListener<T> listener : listeners.getListeners(ListChangeListener.class))\n            listener.changed(source != null ? source : this, elems, new ArrayList<T>());\n    }\n\n    private void fireElementsRemoved(List<T> elems) {\n        if (elems.isEmpty()) return;\n        for (ListChangeListener<T> listener : listeners.getListeners(ListChangeListener.class))\n            listener.changed(source != null ? source : this, new ArrayList<T>(), elems);\n    }\n\n    private void fireChanged(List<T> added, List<T> removed) {\n        if (added.isEmpty() && removed.isEmpty()) return;\n        for (ListChangeListener<T> listener : listeners.getListeners(ListChangeListener.class))\n            listener.changed(source != null ? source : this, added, removed);\n    }\n}\neditor/src/main/java/aurelienribon/bodyeditor/canvas/rigidbodies/input/EditionInputProcessor.java\npublic class EditionInputProcessor extends InputAdapter {\n    private final Canvas canvas;\n    private final RigidBodiesScreen screen;\n    private boolean touchDown = false;\n    private Vector2 draggedPoint;\n\n    public EditionInputProcessor(Canvas canvas, RigidBodiesScreen screen) {\n        this.canvas = canvas;\n        this.screen = screen;\n    }\n\n    @Override\n    public boolean touchDown(int x, int y, int pointer, int button) {\n        touchDown = button == Buttons.LEFT;\n        if (!touchDown) return false;\n\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        if (model == null) return false;\n\n        draggedPoint = screen.nearestPoint;\n\n        if (draggedPoint == null) {\n            screen.mouseSelectionP1 = canvas.screenToWorld(x, y);\n\n        } else {\n            if (draggedPoint == model.getOrigin()) {\n                screen.selectedPoints.clear();\n            } else if (InputHelper.isCtrlDown()) {\n                if (screen.selectedPoints.contains(draggedPoint)) screen.selectedPoints.remove(draggedPoint);\n                else screen.selectedPoints.add(draggedPoint);\n            } else if (!screen.selectedPoints.contains(draggedPoint)) {\n                screen.selectedPoints.replaceBy(draggedPoint);\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean touchUp(int x, int y, int pointer, int button) {\n        if (!touchDown) return false;\n        touchDown = false;\n\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        if (model == null) return false;\n\n        if (draggedPoint != null) {\n            draggedPoint = null;\n            model.computePhysics();\n            screen.buildBody();\n\n        } else if (screen.mouseSelectionP2 != null) {\n            if (InputHelper.isCtrlDown()) {\n                for (Vector2 p : getPointsInSelection()) {\n                    if (screen.selectedPoints.contains(p)) screen.selectedPoints.remove(p);\n                    else screen.selectedPoints.add(p);\n                }\n            } else {\n                screen.selectedPoints.replaceBy(getPointsInSelection());\n            }\n\n        } else {\n            screen.selectedPoints.clear();\n        }\n\n        screen.mouseSelectionP1 = null;\n        screen.mouseSelectionP2 = null;\n        return false;\n    }\n\n    @Override\n    public boolean touchDragged(int x, int y, int pointer) {\n        if (!touchDown) return false;\n\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        if (model == null) return false;\n\n        if (draggedPoint != null) {\n            Vector2 p = canvas.alignedScreenToWorld(x, y);\n            model.clearPhysics();\n\n            float dx = p.x - draggedPoint.x;\n            float dy = p.y - draggedPoint.y;\n            draggedPoint.add(dx, dy);\n\n            for (int i = 0; i < screen.selectedPoints.size(); i++) {\n                Vector2 sp = screen.selectedPoints.get(i);\n                if (sp != draggedPoint) sp.add(dx, dy);\n            }\n\n        } else {\n            screen.mouseSelectionP2 = canvas.screenToWorld(x, y);\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean mouseMoved(int x, int y) {\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        if (model == null) return false;\n\n        // Nearest point computation\n\n        Vector2 p = canvas.screenToWorld(x, y);\n        screen.nearestPoint = null;\n        float dist = 0.025f * canvas.worldCamera.zoom;\n\n        for (Vector2 v : getAllPoints()) {\n            if (v.dst(p) < dist) screen.nearestPoint = v;\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean keyDown(int keycode) {\n        switch (keycode) {\n            case Keys.ENTER:\n                screen.insertPointsBetweenSelected();\n                break;\n            case Keys.BACKSPACE:\n                screen.removeSelectedPoints();\n                break;\n        }\n\n        return false;\n    }\n\n    // -------------------------------------------------------------------------\n\n    private List<Vector2> getPointsInSelection() {\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n        List<Vector2> points = new ArrayList<Vector2>();\n        Vector2 p1 = screen.mouseSelectionP1;\n        Vector2 p2 = screen.mouseSelectionP2;\n\n        if (p1 != null && p2 != null) {\n            Rectangle rect = new Rectangle(\n                    Math.min(p1.x, p2.x),\n                    Math.min(p1.y, p2.y),\n                    Math.abs(p2.x - p1.x),\n                    Math.abs(p2.y - p1.y)\n            );\n\n            for (Vector2 p : getAllPoints()) {\n                if (p == model.getOrigin()) continue;\n                if (rect.contains(p.x, p.y)) points.add(p);\n            }\n        }\n\n        return Collections.unmodifiableList(points);\n    }\n\n    private List<Vector2> getAllPoints() {\n        List<Vector2> points = new ArrayList<Vector2>();\n        RigidBodyModel model = Ctx.bodies.getSelectedModel();\n\n        for (ShapeModel shape : model.getShapes()) {\n            points.addAll(shape.getVertices());\n        }\n\n        points.add(model.getOrigin());\n        return Collections.unmodifiableList(points);\n    }\n}\neditor/src/main/java/aurelienribon/bodyeditor/canvas/Canvas.java\npublic class Canvas extends ApplicationAdapter {\n    public OrthographicCamera worldCamera;\n    public OrthographicCamera screenCamera;\n    public SpriteBatch batch;\n    public BitmapFont font;\n    public CanvasDrawer drawer;\n    public InputMultiplexer input;\n\n    public enum Mode {BODIES, OBJECTS}\n\n    private Mode mode = Mode.BODIES;\n\n    private RigidBodiesScreen rigidBodiesScreen;\n    private DynamicObjectsScreen dynamicObjectsScreen;\n\n    private Sprite infoLabel;\n    private Texture backgroundTexture;\n\n    @Override\n    public void create() {\n        Assets.inst().initialize();\n        Tween.registerAccessor(Sprite.class, new SpriteAccessor());\n\n        worldCamera = new OrthographicCamera();\n        screenCamera = new OrthographicCamera();\n        resetCameras();\n\n        batch = new SpriteBatch();\n        font = new BitmapFont();\n        drawer = new CanvasDrawer(batch, worldCamera);\n\n        backgroundTexture = Assets.inst().get(\"data/transparent-light.png\", Texture.class);\n        backgroundTexture.setWrap(Texture.TextureWrap.Repeat, Texture.TextureWrap.Repeat);\n\n        infoLabel = new Sprite(Assets.inst().get(\"data/white.png\", Texture.class));\n        infoLabel.setPosition(0, 0);\n        infoLabel.setSize(120, 60);\n        infoLabel.setColor(new Color(0x2A / 255f, 0x3B / 255f, 0x56 / 255f, 180 / 255f));\n\n        input = new InputMultiplexer();\n        input.addProcessor(new PanZoomInputProcessor(this));\n        Gdx.input.setInputProcessor(input);\n\n        rigidBodiesScreen = new RigidBodiesScreen(this);\n        dynamicObjectsScreen = new DynamicObjectsScreen(this);\n\n        initializeSelectionListeners();\n    }\n\n    // -------------------------------------------------------------------------\n    // Init\n    // -------------------------------------------------------------------------\n\n    private void initializeSelectionListeners() {\n        Ctx.bodies.addChangeListener(new ChangeListener() {\n            @Override\n            public void propertyChanged(Object source, String propertyName) {\n                if (propertyName.equals(RigidBodiesManager.PROP_SELECTION)) {\n                    if (Ctx.bodies.getSelectedModel() != null) {\n                        Mode oldMode = mode;\n                        mode = Mode.BODIES;\n                        if (mode != oldMode) fireModeChanged(mode);\n                    }\n                }\n            }\n        });\n\n        Ctx.objects.addChangeListener(new ChangeListener() {\n            @Override\n            public void propertyChanged(Object source, String propertyName) {\n                if (propertyName.equals(RigidBodiesManager.PROP_SELECTION)) {\n                    if (Ctx.objects.getSelectedModel() != null) {\n                        Mode oldMode = mode;\n                        mode = Mode.OBJECTS;\n                        if (mode != oldMode) fireModeChanged(mode);\n                    }\n                }\n            }\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Render\n    // -------------------------------------------------------------------------\n\n    @Override\n    public void render() {\n        float w = Gdx.graphics.getWidth();\n        float h = Gdx.graphics.getHeight();\n\n        Gdx.gl30.glClearColor(1, 1, 1, 1);\n        Gdx.gl30.glClear(Gdx.gl30.GL_COLOR_BUFFER_BIT);\n\n        batch.setProjectionMatrix(screenCamera.combined);\n        batch.begin();\n        batch.disableBlending();\n        float tw = backgroundTexture.getWidth();\n        float th = backgroundTexture.getHeight();\n        batch.draw(backgroundTexture, 0f, 0f, w, h, 0f, 0f, w / tw, h / th);\n        batch.enableBlending();\n        batch.end();\n\n        rigidBodiesScreen.render();\n        dynamicObjectsScreen.render();\n\n        batch.setProjectionMatrix(screenCamera.combined);\n        batch.begin();\n        infoLabel.draw(batch);\n        font.setColor(Color.WHITE);\n        font.draw(batch, String.format(Locale.US, \"Zoom: %.0f %%\", 100f / worldCamera.zoom), 10, 45);\n        font.draw(batch, \"Fps: \" + Gdx.graphics.getFramesPerSecond(), 10, 25);\n        batch.end();\n    }\n\n    @Override\n    public void resize(int width, int height) {\n        Gdx.gl30.glViewport(0, 0, width, height);\n        resetCameras();\n    }\n\n    // -------------------------------------------------------------------------\n    // Public API\n    // -------------------------------------------------------------------------\n\n    public Vector2 screenToWorld(int x, int y) {\n        Vector3 v3 = new Vector3(x, y, 0);\n        worldCamera.unproject(v3);\n        return new Vector2(v3.x, v3.y);\n    }\n\n    public Vector2 alignedScreenToWorld(int x, int y) {\n        Vector2 p = screenToWorld(x, y);\n        if (Settings.isSnapToGridEnabled) {\n            float gap = Settings.gridGap;\n            p.x = Math.round(p.x / gap) * gap;\n            p.y = Math.round(p.y / gap) * gap;\n        }\n        return p;\n    }\n\n    // -------------------------------------------------------------------------\n    // Events\n    // -------------------------------------------------------------------------\n\n    private final List<Listener> listeners = new CopyOnWriteArrayList<Listener>();\n\n    public static interface Listener {\n        public void modeChanged(Mode mode);\n    }\n\n    public void addListener(Listener listener) {\n        listeners.add(listener);\n    }\n\n    private void fireModeChanged(Mode mode) {\n        for (Listener listener : listeners) listener.modeChanged(mode);\n    }\n\n    // -------------------------------------------------------------------------\n    // Internals\n    // -------------------------------------------------------------------------\n\n    private void resetCameras() {\n        float w = Gdx.graphics.getWidth();\n        float h = Gdx.graphics.getHeight();\n\n        worldCamera.viewportWidth = w / 400;\n        worldCamera.viewportHeight = w / 400 * h / w;\n        worldCamera.position.set(0.5f, 0.5f, 0);\n        worldCamera.update();\n\n        screenCamera.viewportWidth = w;\n        screenCamera.viewportHeight = h;\n        screenCamera.position.set(w / 2, h / 2, 0);\n        screenCamera.update();\n    }\n}\neditor/src/main/java/aurelienribon/bodyeditor/models/CircleModel.java\npublic class CircleModel {\n    public final Vector2 center = new Vector2();\n    public float radius;\n\n    public CircleModel() {\n    }\n\n    public CircleModel(Vector2 center, float radius) {\n        this.center.set(center);\n        this.radius = radius;\n    }\n}\neditor/src/main/java/aurelienribon/bodyeditor/models/RigidBodyModel.java\npublic class RigidBodyModel extends ChangeableObject {\n    public static final String PROP_NAME = \"name\";\n    public static final String PROP_IMAGEPATH = \"imagePath\";\n    public static final String PROP_PHYSICS = \"physics\";\n\n    private final Vector2 origin = new Vector2(0, 0);\n    private final List<ShapeModel> shapes = new ArrayList<ShapeModel>();\n    private final List<PolygonModel> polygons = new ArrayList<PolygonModel>();\n    private final List<CircleModel> circles = new ArrayList<CircleModel>();\n    private String name = \"unamed\";\n    private String imagePath;\n    private boolean isImagePathValid = true;\n\n    public Vector2 getOrigin() {\n        return origin;\n    }\n\n    public List<ShapeModel> getShapes() {\n        return shapes;\n    }\n\n    public List<PolygonModel> getPolygons() {\n        return polygons;\n    }\n\n    public List<CircleModel> getCircles() {\n        return circles;\n    }\n\n    public void setName(String name) {\n        assert name != null;\n        this.name = name;\n        firePropertyChanged(PROP_NAME);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setImagePath(String imagePath) {\n        this.imagePath = imagePath;\n        this.isImagePathValid = imagePath == null ? true : Ctx.io.getImageFile(imagePath).isFile();\n        firePropertyChanged(PROP_IMAGEPATH);\n    }\n\n    public String getImagePath() {\n        return imagePath;\n    }\n\n    public boolean isImagePathValid() {\n        return isImagePathValid;\n    }\n\n    public void clear() {\n        shapes.clear();\n        polygons.clear();\n        circles.clear();\n        firePropertyChanged(PROP_PHYSICS);\n    }\n\n    public void clearPhysics() {\n        polygons.clear();\n        circles.clear();\n        firePropertyChanged(PROP_PHYSICS);\n    }\n\n    public void computePhysics() {\n        polygons.clear();\n        circles.clear();\n\n        for (ShapeModel shape : shapes) {\n            if (!shape.isClosed()) continue;\n\n            if (shape.getType() == ShapeModel.Type.POLYGON) {\n                Vector2[] vertices = shape.getVertices().toArray(new Vector2[0]);\n                Vector2[][] polys = Clipper.polygonize(Settings.polygonizer, vertices);\n                if (polys != null) for (Vector2[] poly : polys) polygons.add(new PolygonModel(poly));\n\n            }\n            if (shape.getType() == ShapeModel.Type.CIRCLE) {\n                Vector2 center = shape.getVertices().get(0);\n                float radius = Math.abs(shape.getVertices().get(1).cpy().sub(center).len());\n                circles.add(new CircleModel(center, radius));\n            }\n        }\n\n        firePropertyChanged(PROP_PHYSICS);\n    }\n}\n", "answers": ["    private final List<Label> labels = new ArrayList<Label>();"], "length": 3762, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "44dc5f3f2f9865c0cfc54a1183f7ada12efc6a75990e2858"}
{"input": "package com.rashwan.reactive_popular_movies;\nimport android.app.Application;\nimport com.rashwan.reactive_popular_movies.dI.ApplicationComponent;\nimport com.rashwan.reactive_popular_movies.dI.ApplicationModule;\nimport com.rashwan.reactive_popular_movies.dI.DaggerApplicationComponent;\nimport com.rashwan.reactive_popular_movies.data.di.CastRepositoryModule;\nimport com.rashwan.reactive_popular_movies.data.di.MoviesRepositoryModule;\nimport com.rashwan.reactive_popular_movies.feature.actorDetails.actorInfo.injection.ActorInfoComponent;\nimport com.rashwan.reactive_popular_movies.feature.actorDetails.actorInfo.injection.ActorInfoModule;\nimport com.rashwan.reactive_popular_movies.feature.actorDetails.actorMovies.injection.ActorMoviesComponent;\nimport com.rashwan.reactive_popular_movies.feature.actorDetails.actorMovies.injection.ActorMoviesModule;\nimport com.rashwan.reactive_popular_movies.feature.actorDetails.injection.ActorDetailsComponent;\nimport com.rashwan.reactive_popular_movies.feature.discoverMovies.di.BrowseMoviesComponent;\nimport com.rashwan.reactive_popular_movies.feature.discoverMovies.di.BrowseMoviesModule;\nimport com.rashwan.reactive_popular_movies.feature.discoverMovies.nearbyMovies.di.NearbyMoviesComponent;\nimport com.rashwan.reactive_popular_movies.feature.discoverMovies.nearbyMovies.di.NearbyMoviesModule;\nimport com.rashwan.reactive_popular_movies.feature.favoriteMovies.di.FavoriteMoviesComponent;\nimport com.rashwan.reactive_popular_movies.feature.favoriteMovies.di.FavoriteMoviesModule;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.di.MovieDetailsComponent;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.movieCast.di.MovieCastComponent;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.movieCast.di.MovieCastModule;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.movieInfo.di.MovieInfoComponent;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.movieInfo.di.MovieInfoModule;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.movieReviews.di.MovieReviewsComponent;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.movieReviews.di.MovieReviewsModule;\nimport com.rashwan.reactive_popular_movies.feature.watchlistMovies.di.WatchlistComponent;\nimport com.rashwan.reactive_popular_movies.feature.watchlistMovies.di.WatchlistModule;\nimport com.squareup.leakcanary.LeakCanary;\nimport timber.log.Timber;\n\n\n\n\n/**\n * Created by rashwan on 6/23/16.\n */\n\npublic class PopularMoviesApplication extends Application {\n    private static ApplicationComponent applicationComponent;\n    private BrowseMoviesComponent browseMoviesComponent;\n    private MovieDetailsComponent movieDetailsComponent;\n    private MovieInfoComponent movieInfoComponent;\n    private NearbyMoviesComponent nearbyMoviesComponent;\n    private FavoriteMoviesComponent favoriteMoviesComponent;\n    private WatchlistComponent watchlistComponent;\n    private MovieReviewsComponent movieReviewsComponent;\n    private MovieCastComponent movieCastComponent;\n    private ActorInfoComponent actorInfoComponent;\n    private ActorMoviesComponent actorMoviesComponent;\n    private ActorDetailsComponent actorDetailsComponent;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        if (LeakCanary.isInAnalyzerProcess(this)) {\n            // This process is dedicated to LeakCanary for heap analysis.\n            // You should not init your app in this process.\n            return;\n        }\n        LeakCanary.install(this);\n        applicationComponent = createAppComponent();\n\n        Timber.plant(new Timber.DebugTree() {\n            @Override\n            protected String createStackElementTag(StackTraceElement element) {\n                return super.createStackElementTag(element) + ':' + element.getLineNumber();\n            }\n        });\n\n\n    }\n\n    private ApplicationComponent createAppComponent() {\n        return DaggerApplicationComponent.builder().applicationModule(new ApplicationModule(this))", "context": "app/src/main/java/com/rashwan/reactive_popular_movies/feature/actorDetails/actorMovies/injection/ActorMoviesComponent.java\n@PerFragment\n@Subcomponent(modules = ActorMoviesModule.class)\npublic interface ActorMoviesComponent {\n    void inject(ActorMoviesFragment target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/discoverMovies/nearbyMovies/di/NearbyMoviesModule.java\n@Module\npublic class NearbyMoviesModule {\n    @Provides\n    BrowseMoviesAdapter provideBrowseMoviesAdapter(){\n        return new BrowseMoviesAdapter();\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/actorDetails/actorMovies/injection/ActorMoviesModule.java\n@Module\npublic class ActorMoviesModule {\n    @Provides\n    ActorMoviesAdapter provideActorMoviesAdapter(){\n        return new ActorMoviesAdapter();\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/dI/ApplicationComponent.java\n@Singleton\n@Component(modules = {ApplicationModule.class, CastRepositoryModule.class, MoviesRepositoryModule.class})\npublic interface ApplicationComponent {\n    void inject(PopularMoviesApplication target);\n    void inject(Movie target);\n    void inject(Trailer target);\n    void inject(Cast target);\n    void inject(ActorTaggedImage target);\n    void inject(ActorProfileImage target);\n\n    BrowseMoviesComponent plus(BrowseMoviesModule browseMoviesModule);\n    MovieDetailsComponent plusMovieDetailsComponent();\n    MovieInfoComponent plus(MovieInfoModule movieInfoModule);\n    MovieReviewsComponent plus(MovieReviewsModule movieReviewsModule);\n    NearbyMoviesComponent plus(NearbyMoviesModule nearbyMoviesModule);\n    FavoriteMoviesComponent plus(FavoriteMoviesModule favoriteMoviesModule);\n    WatchlistComponent plus(WatchlistModule watchlistModule);\n    MovieCastComponent plus(MovieCastModule movieCastModule);\n    ActorDetailsComponent plusActorDetailsComponent();\n    ActorInfoComponent plus(ActorInfoModule actorInfoModule);\n    ActorMoviesComponent plus(ActorMoviesModule actorMoviesModule);\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/di/MovieDetailsComponent.java\n@PerFragment\n@Subcomponent\npublic interface MovieDetailsComponent {\n    void inject(MovieDetailsActivity target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/watchlistMovies/di/WatchlistComponent.java\n@PerFragment\n@Subcomponent(modules = WatchlistModule.class)\npublic interface WatchlistComponent {\n    void inject(WatchlistFragment target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/discoverMovies/di/BrowseMoviesComponent.java\n@PerFragment\n@Subcomponent(modules = {BrowseMoviesModule.class})\npublic interface BrowseMoviesComponent {\n    void inject(BrowseMoviesFragment target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/dI/ApplicationModule.java\n@Module\npublic class ApplicationModule {\n    private Application application;\n\n    public ApplicationModule(Application application) {\n        this.application = application;\n    }\n\n    @Provides @Singleton\n    public Application provideApplication(){\n        return application;\n    }\n\n    @Provides @Singleton\n    public OkHttpClient provideTmdbOkhttpClient(){\n        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();\n        logging.setLevel(HttpLoggingInterceptor.Level.BASIC);\n        return new OkHttpClient.Builder().addInterceptor(chain -> {\n            Request originalRequest = chain.request();\n            HttpUrl originalUrl = originalRequest.url();\n            Timber.d(originalUrl.host());\n            if (originalUrl.host().equals(application.getString(R.string.tmdb_api_host_url))) {\n                HttpUrl newUrl = originalUrl.newBuilder()\n                        .addQueryParameter(\"api_key\", BuildConfig.TMDB_API_KEY)\n                        .build();\n                Request.Builder newRequestBuilder = originalRequest.newBuilder().url(newUrl);\n                Request newRequest = newRequestBuilder.build();\n                return chain.proceed(newRequest);\n            }else if (application.getString(R.string.omdb_api_base_url).contains(originalUrl.host())){\n                HttpUrl newUrl = originalUrl.newBuilder()\n                        .addQueryParameter(\"apikey\", BuildConfig.OMDB_API_KEY)\n                        .build();\n                Request.Builder newRequestBuilder = originalRequest.newBuilder().url(newUrl);\n                Request newRequest = newRequestBuilder.build();\n                return chain.proceed(newRequest);\n            }else {\n                return chain.proceed(originalRequest);\n            }\n        }).addInterceptor(logging).build();\n    }\n\n\n\n\n    @Provides @Singleton\n    public Moshi provideMoshi(){\n        return new Moshi.Builder().add(MyAdapterFactory.create()).build();\n    }\n    @Provides @Singleton @Named(\"Movie Converter\")\n    public Converter.Factory provideTmdbResponseConverterFactory(Moshi moshi){\n        return new TmdbResultsResponseConverterFactory(MoshiConverterFactory.create(moshi));\n    }\n\n    @Provides @Singleton @Named(\"Cast Converter\")\n    public Converter.Factory provideTmdbCastResponseConverterFactory(Moshi moshi){\n        return new TmdbCastResponseConverterFactory(MoshiConverterFactory.create(moshi));\n    }\n\n    @Provides @Singleton @Named(\"TMDBRetrofit\")\n    public Retrofit provideTMDBRetrofit(OkHttpClient okHttpClient\n            ,RetrofitUniversalConverter retrofitUniversalConverter) {\n        RxJavaCallAdapterFactory rxAdapter = RxJavaCallAdapterFactory.createWithScheduler(Schedulers.io());\n        return new Retrofit.Builder()\n                .baseUrl(application.getString(R.string.tmdb_api_base_url))\n                .client(okHttpClient)\n                .addCallAdapterFactory(rxAdapter)\n                .addConverterFactory(retrofitUniversalConverter)\n                .build();\n    }\n    @Provides @Singleton @Named(\"OMDBRetrofit\")\n    public Retrofit provideOMDBRetrofit(OkHttpClient okHttpClient\n            ,RetrofitUniversalConverter retrofitUniversalConverter){\n        RxJavaCallAdapterFactory rxAdapter = RxJavaCallAdapterFactory.createWithScheduler(Schedulers.io());\n        return new Retrofit.Builder()\n                .baseUrl(application.getString(R.string.omdb_api_base_url))\n                .client(okHttpClient)\n                .addCallAdapterFactory(rxAdapter)\n                .addConverterFactory(retrofitUniversalConverter)\n                .build();\n    }\n\n    @Provides @Singleton\n    public MovieDatabaseHelper provideOpenHelper(Application application){\n        return new MovieDatabaseHelper(application);\n    }\n    @Provides @Singleton\n    public SqlBrite provideSqlBrite(){\n        return new SqlBrite.Builder().logger(message -> Timber.tag(\"Database\").d(message)).build();\n    }\n\n    @Provides @Singleton\n    public BriteDatabase provideDatabase(SqlBrite sqlBrite,MovieDatabaseHelper databaseHelper){\n        BriteDatabase db =  sqlBrite.wrapDatabaseHelper(databaseHelper,Schedulers.io());\n        db.setLoggingEnabled(true);\n        return db;\n    }\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/favoriteMovies/di/FavoriteMoviesModule.java\n@Module\npublic class FavoriteMoviesModule {\n    @Provides\n    public BrowseMoviesAdapter provideBrowseMoviesAdapter(){\n        return new BrowseMoviesAdapter();\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/di/MoviesRepositoryModule.java\n@Module\npublic class MoviesRepositoryModule {\n    @Provides @Singleton @Local\n    public MoviesDataSource provideMoviesLocalDataSource(BriteDatabase db){\n        return new MoviesLocalDataSource(db);\n    }\n    @Provides @Singleton @Remote\n    public MoviesDataSource provideMoviesRemoteDataSource(Application application\n            , @Named(\"TMDBRetrofit\") Retrofit tmdbRetrofit\n            , @Named(\"OMDBRetrofit\") Retrofit omdbRetrofit){\n        return new MoviesRemoteDataSource(application,tmdbRetrofit,omdbRetrofit);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/movieCast/di/MovieCastComponent.java\n@PerFragment\n@Subcomponent(modules = {MovieCastModule.class})\npublic interface MovieCastComponent {\n    void inject(MovieCastFragment target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/movieInfo/di/MovieInfoComponent.java\n@PerFragment\n@Subcomponent(modules = MovieInfoModule.class)\npublic interface MovieInfoComponent {\n    void inject(MovieInfoFragment target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/movieReviews/di/MovieReviewsModule.java\n@Module\npublic class MovieReviewsModule {\n    @Provides\n    public MovieReviewsAdapter provideMovieReviewsAdapter(){\n        return new MovieReviewsAdapter();\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/movieInfo/di/MovieInfoModule.java\n@Module\npublic class MovieInfoModule {\n    @Provides\n    MovieTrailersAdapter providesMovieTrailersAdapter(){\n        return new MovieTrailersAdapter();\n    }\n    @Provides\n    SimilarMoviesAdapter providesSimilarMoviesAdapter(){\n        return new SimilarMoviesAdapter();\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/di/CastRepositoryModule.java\n@Module\npublic class CastRepositoryModule {\n    @Local\n    @Provides @Singleton\n    CastDataSource provideCastLocalDataSource(){\n        return new CastLocalDataSource();\n    }\n\n    @Remote\n    @Provides @Singleton\n    CastDataSource provideCastRemoteDataSource(Application application,@Named(\"TMDBRetrofit\") Retrofit retrofit){\n        return new CastRemoteDataSource(application,retrofit);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/actorDetails/actorInfo/injection/ActorInfoComponent.java\n@PerFragment\n@Subcomponent(modules = ActorInfoModule.class)\npublic interface ActorInfoComponent {\n    void inject(ActorInfoFragment target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/movieReviews/di/MovieReviewsComponent.java\n@PerFragment\n@Subcomponent(modules = MovieReviewsModule.class)\npublic interface MovieReviewsComponent {\n    void inject(MovieReviewsFragment target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/actorDetails/injection/ActorDetailsComponent.java\n@PerFragment\n@Subcomponent\npublic interface ActorDetailsComponent {\n    void inject(ActorDetailsActivity target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/discoverMovies/di/BrowseMoviesModule.java\n@Module\npublic class BrowseMoviesModule {\n\n    @Provides\n    public BrowseMoviesAdapter provideBrowseMoviesAdapter(){\n        return new BrowseMoviesAdapter();\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/actorDetails/actorInfo/injection/ActorInfoModule.java\n@Module\npublic class ActorInfoModule {\n\n    @Provides\n    ActorProfileImagesAdapter provideActorProfileImagesAdapter(){\n        return new ActorProfileImagesAdapter();\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/watchlistMovies/di/WatchlistModule.java\n@Module\npublic class WatchlistModule {\n\n    @Provides\n    BrowseMoviesAdapter provideBrowseMoviesAdapter(){\n        return new BrowseMoviesAdapter();\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/discoverMovies/nearbyMovies/di/NearbyMoviesComponent.java\n@PerFragment\n@Subcomponent(modules = NearbyMoviesModule.class)\npublic interface NearbyMoviesComponent {\n    void inject(NearbyMoviesFragment target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/favoriteMovies/di/FavoriteMoviesComponent.java\n@PerFragment\n@Subcomponent(modules = FavoriteMoviesModule.class)\npublic interface FavoriteMoviesComponent {\n    void inject(FavoriteMoviesFragment target);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/movieCast/di/MovieCastModule.java\n@Module\npublic class MovieCastModule {\n    @Provides\n    public MovieCastAdapter provideMovieCastAdapter(){\n        return new MovieCastAdapter();\n    }\n}\n", "answers": ["                .castRepositoryModule(new CastRepositoryModule())"], "length": 785, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "75a520ca63f7d7b62dfa6a66173ae4a11cb566c02c56da16"}
{"input": "import OpenGL.GL as gl\n    import xml.etree.ElementTree\n    import elementtree.ElementTree\nimport re\nimport math\nimport string\nimport traceback\nimport gzip\n    from xml.etree.cElementTree import parse\n    from elementtree.ElementTree import parse\nfrom .svg_constants import *\nfrom .glutils import *\nfrom .vector_math import *\nfrom .svg_parser_utils import parse_color, parse_float, parse_style, parse_list\nfrom .gradient import *\nfrom .svg_path import SVGPath, SVGGroup, SVGDefs, SVGUse, SVGMarker, SVGContainer\nfrom .svg_pattern import *\nfrom glsvg import graphics\nfrom .render_target import CanvasManager\n            `anchor_x`: float\n                The horizontal anchor position for scaling and rotations. Defaults to 0. The symbolic\n                values 'left', 'center' and 'right' are also accepted.\n            `anchor_y`: float\n                The vertical anchor position for scaling and rotations. Defaults to 0. The symbolic\n                values 'bottom', 'center' and 'top' are also accepted.\n        \"\"\"\n\n        SVGContainer.__init__(self, parent)\n\n        if not config:\n            self.config = SVGConfig()\n        else:\n            self.config = config\n        self._stencil_mask = 0\n\n        # drawing information\n        self.x = 0\n        self.y = 0\n        self.height = 0\n        self.width = 0\n\n        self.preserve_aspect_ratio = 'none'\n\n        self.opacity = 1.0\n\n        #: Number of triangles in document\n        self.n_tris = 0\n\n        #: Number of lines in document\n        self.n_lines = 0\n\n        #: Map from id to path\n        self.path_lookup = {}\n\n        #: SVG paths\n        self._paths = []\n\n        #: Maps from pattern id to pattern\n        self.patterns = {}\n\n        #: Maps from id to marker def\n        self.markers = {}\n\n        #: Maps from id to path definition\n        self.defs = {}\n\n        #: Filename of original SVG file\n        self.filename = filename_or_element if isinstance(filename_or_element, str) else None\n        self._gradients = GradientContainer()\n\n        if self.filename:\n            is_svg = False\n\n            with open(self.filename, 'rb') as f:\n                is_svg = (f.read(3) == b'\\x1f\\x8b\\x08')\n\n            if is_svg:  # gzip magic numbers\n                with gzip.open(self.filename, 'rb') as f:\n                    self.root = parse(f)._root\n            else:\n                with open(self.filename, 'rb') as f:\n                    self.root = parse(f)._root\n        else:\n            self.root = filename_or_element\n\n        self.parse_root(self.root)\n\n        self._generate_disp_list()\n\n        self.anchor_x = anchor_x\n        self.anchor_y = anchor_y\n\n    def parse_root(self, root):\n        self._paths = []\n\n        wm = root.get(\"width\", '0')\n        hm = root.get(\"height\", '0')\n\n        self.x = 0\n        self.y = 0\n\n        self.width = parse_float(wm)\n        self.height = parse_float(hm)\n\n        self.preserve_aspect_ratio = root.get('preserveAspectRatio', 'none')\n\n        if self.root.get(\"viewBox\"):\n            x, y, w, h = (parse_float(x) for x in parse_list(root.get(\"viewBox\")))\n            self.x = x\n            self.y = y\n            self.height = h\n            self.width = w\n\n        self.opacity = 1.0\n        for e in root.getchildren():\n            try:\n                self._parse_element(e)\n            except Exception as ex:\n                print('Exception while parsing element ' + str(e))\n                raise\n\n    @staticmethod\n    def _is_path_tag(e):\n        return (e.tag.endswith('path')\n                or e.tag.endswith('rect')\n                or e.tag.endswith('polyline') or e.tag.endswith('polygon')\n                or e.tag.endswith('line')\n                or e.tag.endswith('circle') or e.tag.endswith('ellipse'))\n\n    def _parse_element(self, e, parent=None):\n        renderable = None\n        if self._is_path_tag(e):\n            renderable = SVGPath(self, e, parent)\n            if not parent:\n                self._paths.append(renderable)\n\n            if renderable.id:\n                self.path_lookup[renderable.id] = renderable\n        elif e.tag.endswith('}g') or e.tag == 'g':\n", "context": "glsvg/svg_path.py\nclass SVGPath(SVGRenderableElement):\n    \"\"\"\n    Represents a single SVG path. This is usually\n    a distinct shape with a fill pattern,\n    an outline, or both.\n    \"\"\"\n\n    def __init__(self, svg, element, parent):\n\n        SVGRenderableElement.__init__(self, svg, element, parent)\n\n        #: The original SVG file\n        self.svg = svg\n\n        if not self.is_pattern_part:\n            self.config = svg.config\n        else:\n            self.config = svg.config.super_detailed()\n\n        #: The actual path elements, as a list of vertices\n        self.outlines = None\n\n        #: The triangles that comprise the inner fill\n        self.triangles = None\n\n        #: The base shape. Possible values: path, rect, circle, ellipse, line, polygon, polyline\n        self.shape = None\n\n        #: The bounding box\n        self._bounding_box = None\n\n        self.marker_start = element.get('marker-start', None)\n        self.marker_mid = element.get('marker-mid', None)\n        self.marker_end = element.get('marker-end', None)\n\n        if self.marker_start: self.marker_start = self.marker_start[5:-1]\n        if self.marker_mid: self.marker_mid = self.marker_mid[5:-1]\n        if self.marker_end: self.marker_end = self.marker_end[5:-1]\n\n        path_builder = SVGPathBuilder()\n\n        path_builder.read_xml_svg_element(\n                        self,\n                        element,\n                        self.config)\n\n        self.outlines = path_builder.path\n\n        self.triangles = path_builder.polygon\n\n        self.display_list = None\n\n    def _render_stroke(self):\n        stroke = self.style.stroke\n        stroke_width = self.style.stroke_width\n\n        is_miter = self.style.stroke_linejoin == 'miter'\n\n        miter_limit = self.style.stroke_miterlimit if is_miter else 0\n\n        for loop in self.outlines:\n            self.svg.n_lines += len(loop) - 1\n            loop_plus = []\n\n            for i in range(len(loop) - 1):\n                loop_plus += [loop[i], loop[i+1]]\n\n            if isinstance(stroke, str):\n                g = self.svg._gradients[stroke]\n                strokes = [g.sample(x, self) for x in loop_plus]\n            else:\n                strokes = [stroke for x in loop_plus]\n\n            if len(loop_plus) == 0:\n                continue\n\n            if len(self.style.stroke_dasharray):\n                ls = lines.split_line_by_pattern(loop_plus, self.style.stroke_dasharray)\n\n                if ls[0][0] == ls[-1][-1]:\n                    #if the last line end point equals the first line start point,\n                    #this is a \"closed\" line, so combine the first and the last line\n                    combined_line = ls[-1] + ls[0]\n                    ls[0] = combined_line\n                    del ls[-1]\n\n                for l in ls:\n                    lines.draw_polyline(\n                        l,\n                        stroke_width,\n                        color=strokes[0],\n                        line_cap=self.style.stroke_linecap,\n                        join_type=self.style.stroke_linejoin,\n                        miter_limit=miter_limit)\n\n                if self.marker_start:\n                    end_point = vec2(loop_plus[0])\n                    almost_end_point = vec2(loop_plus[1])\n                    marker = self.svg.defs[self.marker_start]\n                    self._render_marker(end_point, almost_end_point, marker, True)\n                if self.marker_end:\n                    end_point = vec2(loop_plus[-1])\n                    almost_end_point = vec2(loop_plus[-2])\n                    marker = self.svg.defs[self.marker_end]\n                    self._render_marker(end_point, almost_end_point, marker)\n\n            else:\n                lines.draw_polyline(\n                    loop_plus,\n                    stroke_width,\n                    color=strokes[0],\n                    line_cap=self.style.stroke_linecap,\n                    join_type=self.style.stroke_linejoin,\n                    miter_limit=miter_limit)\n\n                if self.marker_start:\n                    end_point = vec2(loop_plus[0])\n                    almost_end_point = vec2(loop_plus[1])\n                    marker = self.svg.defs[self.marker_start]\n                    self._render_marker(end_point, almost_end_point, marker, True)\n                if self.marker_end:\n                    end_point = vec2(loop_plus[-1])\n                    almost_end_point = vec2(loop_plus[-2])\n                    marker = self.svg.defs[self.marker_end]\n                    self._render_marker(end_point, almost_end_point, marker)\n\n    def _render_marker(self, a, b, marker, reverse=False):\n        if marker.orient == 'auto':\n            angle = (a - b).angle()\n        else:\n            angle = marker.orient\n\n        if reverse:\n            angle += math.pi\n\n        sx = (marker.marker_width / marker.vb_w) * self.style.stroke_width\n        sy = (marker.marker_height / marker.vb_h) * self.style.stroke_width\n\n        rx = marker.ref_x\n        ry = marker.ref_y\n\n        with Matrix.transform(a.x, a.y, theta=angle):\n            with Matrix.scale(sx, sy):\n                with Matrix.translation(-rx, -ry):\n                    marker.render()\n\n    def _render_gradient_fill(self):\n        fill = self.style.fill\n        tris = self.triangles\n        self.svg.n_tris += len(tris) / 3\n        g = None\n        if isinstance(fill, str):\n            g = self.svg._gradients[fill]\n            fills = [g.sample(x, self) for x in tris]\n        else:\n            fills = [fill] * len(tris)  # for x in tris]\n\n        if g:\n            g.apply_shader(self, self.transform, self.style.opacity * self.style.fill_opacity)\n\n        graphics.draw_colored_triangles(\n            flatten_list(tris),\n            flatten_list(fills)\n        )\n\n        if g:\n            g.unapply_shader()\n\n    def bounding_box(self):\n        '''\n        returns a tuple describing the bounding box:\n\n        (min_x, min_y, max_x, max_y)\n        '''\n        if not self._bounding_box:\n            self._bounding_box = BoundingBox()\n\n            if self.triangles:\n                self._bounding_box.expand(self.triangles)\n            if self.outlines:\n                for o in self.outlines:\n                    self._bounding_box.expand(o)\n        return self._bounding_box.extents()\n\n    def _render_pattern_fill(self):\n        fill = self.style.fill\n        tris = self.triangles\n        pattern = None\n        if fill in self.svg.patterns:\n            pattern = self.svg.patterns[fill]\n            pattern.bind_texture()\n\n        min_x, min_y, max_x, max_y = self.bounding_box()\n\n        tex_coords = []\n\n        for vtx in tris:\n            tex_coords.append((vtx[0]-min_x)/(max_x-min_x)/pattern.width)\n            tex_coords.append((vtx[1]-min_y)/(max_y-min_y)/pattern.width)\n\n        graphics.draw_textured_triangles(\n            flatten_list(tris),\n            tex_coords\n        )\n\n        if pattern:\n            pattern.unbind_texture()\n\n    def on_render(self):\n        \"\"\"Render immediately to screen (no display list). Slow! Consider\n        using SVG.draw(...) instead.\"\"\"\n\n        gl.glClear(gl.GL_DEPTH_BUFFER_BIT)\n\n        gl.glEnable(gl.GL_DEPTH_TEST)\n\n        if self.style.stroke and self.outlines:\n            self._render_stroke()\n\n        gl.glPushMatrix()\n        gl.glTranslatef(0, 0, -0.1)\n        if self.triangles:\n            try:\n                if isinstance(self.style.fill, str) and self.style.fill in self.svg.patterns:\n                    self._render_pattern_fill()\n                else:\n                    self._render_gradient_fill()\n            except Exception as exception:\n                traceback.print_exc(exception)\n        gl.glPopMatrix()\n        gl.glDisable(gl.GL_DEPTH_TEST)\n\n\n\n    def __repr__(self):\n        return \"<SVGPath id=%s title='%s' description='%s' transform=%s>\" % (\n            self.id, self.title, self.description, self.transform\n        )\nglsvg/graphics.py\ndef clear_stats():\ndef add_triangle_stats(tris):\ndef draw_triangle_strip(vertices, color):\ndef draw_round_cap(center, radius, angle):\ndef draw_colored_triangles(tris, colors):\ndef draw_textured_triangles(tris, tex_coords):\ndef draw_quad(x, y, w, h):\nglsvg/svg_path.py\nclass SVGDefs(SVGRenderableElement):\n    \"\"\"Represents an SVG \"defs\" directive, to define paths without drawing them\"\"\"\n\n    def __init__(self, svg, element, parent):\n        SVGRenderableElement.__init__(self, svg, element, parent)\n        self.svg = svg\n        self.is_def = True\n\n    def add_child(self, child):\n        if hasattr(child, 'id'):\n            self.svg.defs[child.id] = child\n        self.children.append(child)\nglsvg/render_target.py\nclass CanvasManager:\n    instance = None\n\n    def __init__(self):\n        self.canvas = {}\n        vp = list(gl.glGetFloatv(gl.GL_VIEWPORT))\n        self.w = int(vp[2])\n        self.h = int(vp[3])\n\n    def resize(self, w, h):\n        self.w = w\n        self.h = h\n\n        for c in self.canvas.values():\n            c.resize(w, h)\n\n    def get(self, name):\n        if name not in self.canvas:\n            self.canvas[name] = RenderTarget(self.w, self.h)\n        return self.canvas[name]\n\n    def temp(self):\n        return self.get('temp' + str(len(RenderTarget.id_stack)))\n\n    def update(self):\n        vp = list(gl.glGetFloatv(gl.GL_VIEWPORT))\n\n        if self.w != int(vp[2]) and self.h != int(vp[3]):\n            self.resize(int(vp[2]), int(vp[3]))\n\n    @classmethod\n    def inst(cls):\n        if not cls.instance:\n            cls.instance = CanvasManager()\n        return cls.instance\nglsvg/svg_path.py\nclass SVGContainer(object):\n\n    def __init__(self, parent):\n\n        self.parent = parent\n\n        self.children = []\n\n        self.is_def = False\n\n        if parent:\n            parent.add_child(self)\n\n    def add_child(self, child):\n        self.children.append(child)\nglsvg/svg_path.py\nclass SVGGroup(SVGRenderableElement):\n    pass\nglsvg/svg_path.py\nclass SVGMarker(SVGRenderableElement):\n\n    def __init__(self, svg, element, parent):\n        SVGRenderableElement.__init__(self, svg, element, parent)\n\n        self.units = element.get('markerUnits', 'strokeWidth')\n        self.marker_width = parse_float(element.get('markerWidth', '3'))\n        self.marker_height = parse_float(element.get('markerHeight', '3'))\n        self.orient = element.get('orient', 'auto')\n        self.ref_x = parse_float(element.get('refX', '0'))\n        self.ref_y = parse_float(element.get('refY', '0'))\n\n        vb = element.get('viewBox', None)\n\n        if vb:\n            x, y, w, h = (parse_float(x) for x in parse_list(element.get(\"viewBox\")))\n            self.vb_x, self.vb_y, self.vb_w, self.vb_h = x, y, w, h\n        else:\n            self.vb_x = 0\n            self.vb_y = 0\n            self.vb_w = 1\n            self.vb_h = 1\nglsvg/svg_parser_utils.py\ndef parse_color(c, default=None):\n    if not c:\n        return default\n    if c == 'none':\n        return None\n\n    c = c.strip()\n\n    if c in svg_constants.named_colors:\n        c = svg_constants.named_colors[c]\n\n    if c.startswith('rgb'):\n        start = c.index('(')\n        end = c.index(')')\n        parts = c[start+1:end].split(',')\n        r, g, b = tuple(int(p.strip()) for p in parts)\n        return [r,g,b,255]\n\n    if c[0] == '#': c = c[1:]\n    if c.startswith('url(#'):\n        return c[5:-1]\n    try:\n        a=255\n        if len(c) == 8:\n            r = int(c[0:2], 16)\n            g = int(c[2:4], 16)\n            b = int(c[4:6], 16)\n            a = int(c[6:8], 16)\n        elif len(c) == 6:\n            r = int(c[0:2], 16)\n            g = int(c[2:4], 16)\n            b = int(c[4:6], 16)\n        elif len(c) == 3:\n            r = int(c[0], 16) * 17\n            g = int(c[1], 16) * 17\n            b = int(c[2], 16) * 17\n        else:\n            raise Exception(\"Incorrect length for color \" + str(c) + \" length \" + str(len(c)))\n        return [r,g,b,a]\n    except Exception as ex:\n        print('Exception parsing color ' + str(ex))\n        return None\nglsvg/svg_parser_utils.py\ndef parse_list(string):\n    return re_list_parser.findall(string)\nglsvg/svg_path.py\nclass SVGUse(SVGRenderableElement):\n    \"\"\"Represents an SVG \"use\" directive, to reuse a predefined path\"\"\"\n\n    def __init__(self, svg, element, parent):\n        SVGRenderableElement.__init__(self, svg, element, parent)\n        self.svg = svg\n        self.target = element.get(XLINK_NS + \"href\", None)\n        self.x = parse_float(element.get('x', '0'))\n        self.y = parse_float(element.get('y', '0'))\n\n        self.transform = self.transform * Matrix.translation(self.x, self.y)\n\n        #clip off \"#\"\n        if self.target:\n            self.target = self.target[1:]\n\n    def render(self):\n        with self.transform:\n            defn = self.svg.defs[self.target]\n            defn.render()\nglsvg/svg_parser_utils.py\ndef parse_style(string):\n    s_dict = {}\n    for item in string.split(';'):\n        if ':' in item:\n            key, value = item.split(':')\n            s_dict[key.strip()] = value.strip()\n    return s_dict\nglsvg/svg_parser_utils.py\ndef parse_float(txt):\n    #assume 90 dpi\n    if txt.endswith('%'):\n        pct = float(txt[:-1])/100.0\n        return pct\n    elif txt.endswith('px'):\n        return float(txt[:-2])\n    elif txt.endswith('pt'):\n        return float(txt[:-2]) * 1.25\n    elif txt.endswith('pc'):\n        return float(txt[:-2]) * 15\n    elif txt.endswith('mm'):\n        return float(txt[:-2]) * 3.543307\n    elif txt.endswith('cm'):\n        return float(txt[:-2]) * 35.43307\n    elif txt.endswith('in'):\n        return float(txt[:-2]) * 90\n    elif txt.endswith('em') or txt.endswith('ex'):\n        return float(txt[:-2]) * 10\n    else:\n        return float(txt)\n", "answers": ["            renderable = SVGGroup(self, e, parent)"], "length": 1523, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "d9c599f39fb4ea5788fbdf8739f5ab2ea9e25b411c1e2bdd"}
{"input": "package de.fau.cs.mad.yasme.android.asyncTasks.server;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.os.AsyncTask;\nimport java.io.IOException;\nimport de.fau.cs.mad.yasme.android.connection.UserTask;\nimport de.fau.cs.mad.yasme.android.controller.FragmentObservable;\nimport de.fau.cs.mad.yasme.android.controller.Log;\nimport de.fau.cs.mad.yasme.android.controller.ObservableRegistry;\nimport de.fau.cs.mad.yasme.android.controller.SpinnerObservable;\nimport de.fau.cs.mad.yasme.android.entities.User;\nimport de.fau.cs.mad.yasme.android.exception.RestServiceException;\nimport de.fau.cs.mad.yasme.android.storage.DatabaseManager;\nimport de.fau.cs.mad.yasme.android.storage.PictureManager;\nimport de.fau.cs.mad.yasme.android.ui.fragments.SearchContactFragment;\n\n\n\n\n/**\n * Created by robert on 27.09.14.\n */\npublic class GetImageWithoutSavingTask extends AsyncTask<Long, Void, Boolean> {\n\n    private BitmapDrawable profilePicture;\n    private Class classToNotify;\n    private boolean isSelf;\n    private User user;\n\n    public GetImageWithoutSavingTask(Class classToNotify, User user) {\n        this.classToNotify = classToNotify;\n        this.user = user;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n    }\n\n    /**\n     * @return true on success, false on error\n     */\n    @Override\n    protected Boolean doInBackground(Long... params) {\n        long userId = user.getId();\n\n        try {\n            profilePicture = UserTask.getInstance().getProfilePicture(userId);\n        } catch (RestServiceException e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return false;\n        }\n        if (profilePicture == null) {\n            Log.d(this.getClass().getSimpleName(), \"profilePicture was null\");\n            user.setProfilePicture(null);\n            return true;\n        }\n\n        isSelf = (userId == DatabaseManager.INSTANCE.getUserId());\n\n        String path;\n        try {\n            path = PictureManager.INSTANCE.storePicture(user, profilePicture.getBitmap());\n        } catch (IOException e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return false;\n        }\n        if (path != null && !path.isEmpty()) {\n            user.setProfilePicture(path);\n        } else {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    protected void onPostExecute(Boolean success) {\n        SpinnerObservable.getInstance().removeBackgroundTask(this);\n        if (success) {\n            if (classToNotify == null) {\n                //No one to notify\n                return;\n            }\n            // Notify registered fragments", "context": "yasme/src/main/java/de/fau/cs/mad/yasme/android/storage/DatabaseManager.java\npublic enum DatabaseManager {\n    INSTANCE;\n\n    private boolean mInitialized = false;\n    private boolean mDBInitialized = false;\n    private DatabaseHelper mHelper;\n    private Context mContext;\n    private long mUserId = -1;\n    private long mDeviceId = -1;\n    private String mAccessToken = null;\n    private long serverInfoUpdateTime = -1;\n    private ServerInfo serverInfo = null;\n    private SharedPreferences mSharedPreferences, mSettings;\n    private String mUserEmail;\n    private NewMessageNotificationManager notifier = null;\n\n    private UserDAO userDAO;\n    private ChatDAO chatDAO;\n    private MessageDAO messageDAO;\n    private MessageKeyDAO messageKeyDAO;\n    private DeviceDAO deviceDAO;\n\n\n    public void init(Context context, SharedPreferences sharedPreferences,\n                     SharedPreferences settings, long userId) {\n        mContext = context;\n        mSharedPreferences = sharedPreferences;\n        mSettings = settings;\n        mUserId = userId;\n        initDB(context, userId);\n        initializeDAOs();\n        mInitialized = true;\n    }\n\n    public void initDB(Context context, long userId) {\n        mHelper = new DatabaseHelper(context, userId);\n        mDBInitialized = true;\n    }\n\n    public boolean isInitialized() {\n        return mInitialized;\n    }\n\n    public boolean isDBInitialized() {\n        return mDBInitialized;\n    }\n\n    private DatabaseHelper getHelper() {\n        return mHelper;\n    }\n\n    public SharedPreferences getSharedPreferences() {\n        return mSharedPreferences;\n    }\n\n    public SharedPreferences getSettings() {\n        return mSettings;\n    }\n\n    public Context getContext() {\n        return mContext;\n    }\n\n    private void initializeDAOs() {\n        UserDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        userDAO = UserDAOImpl.INSTANCE;\n\n        ChatDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        chatDAO = ChatDAOImpl.INSTANCE;\n\n        MessageDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        messageDAO = MessageDAOImpl.INSTANCE;\n\n        MessageKeyDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        messageKeyDAO = MessageKeyDAOImpl.INSTANCE;\n\n        DeviceDAOImpl.INSTANCE.setDatabaseHelper(mHelper);\n        deviceDAO = DeviceDAOImpl.INSTANCE;\n    }\n\n    public UserDAO getUserDAO() {\n        return userDAO;\n    }\n\n    public ChatDAO getChatDAO() {\n        return chatDAO;\n    }\n\n    public MessageDAO getMessageDAO() {\n        return messageDAO;\n    }\n\n    public MessageKeyDAO getMessageKeyDAO() {\n        return messageKeyDAO;\n    }\n\n    public DeviceDAO getDeviceDAO() {\n        return deviceDAO;\n    }\n\n    public long getUserId() {\n        if (-1 == mUserId) {\n            mUserId = getSharedPreferences().getLong(AbstractYasmeActivity.USER_ID, -1);\n        }\n        return mUserId;\n    }\n\n    public void setUserId(long mUserId) {\n        this.mUserId = mUserId;\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putLong(AbstractYasmeActivity.USER_ID, mUserId);\n        editor.apply();\n    }\n\n    public long getDeviceId() {\n        if (-1 == mDeviceId) {\n            mDeviceId = getSharedPreferences().getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n        }\n        return mDeviceId;\n    }\n\n    public void setDeviceId(long mDeviceId) {\n        this.mDeviceId = mDeviceId;\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putLong(AbstractYasmeActivity.DEVICE_ID, mDeviceId);\n        editor.apply();\n    }\n\n    public String getAccessToken() {\n        if (null == mAccessToken) {\n            mAccessToken = getSharedPreferences().getString(AbstractYasmeActivity.ACCESSTOKEN, null);\n        }\n        return mAccessToken;\n    }\n\n    public void setAccessToken(String accessToken) {\n        this.mAccessToken = accessToken;\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putString(AbstractYasmeActivity.ACCESSTOKEN, mAccessToken);\n        editor.commit();\n    }\n\n    public long getServerInfoUpdateTime() {\n        if (-1 == serverInfoUpdateTime) {\n            serverInfoUpdateTime = getSharedPreferences().getLong(AbstractYasmeActivity.SERVERINFOUPDATETIME, -1);\n        }\n        return serverInfoUpdateTime;\n    }\n\n    public void setServerInfoUpdateTime() {\n        this.serverInfoUpdateTime = System.currentTimeMillis();\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putLong(AbstractYasmeActivity.SERVERINFOUPDATETIME, serverInfoUpdateTime);\n        editor.commit();\n    }\n\n    public ServerInfo getServerInfo() {\n        return serverInfo;\n    }\n\n    public void setServerInfo(ServerInfo serverInfo) {\n        this.serverInfo = serverInfo;\n    }\n\n    public String getUserEmail() {\n        if (null == mUserEmail || \"\" == mUserEmail) {\n            mUserEmail = getSharedPreferences().getString(AbstractYasmeActivity.USER_MAIL, null);\n        }\n        return mUserEmail;\n    }\n\n    public void setUserEmail(String mUserEmail) {\n        this.mUserEmail = mUserEmail;\n        SharedPreferences.Editor editor = getSharedPreferences().edit();\n        editor.putString(AbstractYasmeActivity.USER_MAIL, mUserEmail);\n        editor.commit();\n    }\n\n    public NewMessageNotificationManager getNotifier() {\n        if (notifier == null) {\n            notifier = new NewMessageNotificationManager();\n        }\n        return notifier;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/exception/RestServiceException.java\npublic class RestServiceException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate int code;\n\n\tpublic RestServiceException(ErrorCode error) {\n\n\t\tthis(error.getDescription(), error.getNumber());\n\n\t}\n\n\tpublic RestServiceException(String message, int code) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\n\t\tSystem.err.println(\"Code: \" + this.code + \"  \" + \"Message: \"\n\t\t\t\t+ this.getMessage());\n\t}\n\n    public int getCode() {\n        return code;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/connection/UserTask.java\npublic class UserTask extends ConnectionTask {\n\n    private static UserTask instance;\n\n    public static synchronized UserTask getInstance() {\n        if (instance == null) {\n            synchronized (UserTask.class) {\n                if (null == instance) {\n                    instance = new UserTask();\n                }\n            }\n        }\n        return instance;\n    }\n\n    private UserTask() {\n        try {\n            this.uri = new URIBuilder(baseURI).setPath(ConnectionTask.APIVERSION + \"/usr\").build();\n        } catch (URISyntaxException e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n        }\n    }\n\n    public Long registerUser(User user) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.POST, \"\", user);\n            JSONObject json = new JSONObject((new BufferedReader(\n                    new InputStreamReader(httpResponse.getEntity()\n                            .getContent(), \"UTF-8\")\n            )).readLine());\n\n            return Long.parseLong(json.getString(\"message\"));\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            throw new RestServiceException(Error.ERROR);\n        }\n    }\n\n    public void changeUserData(User user) throws RestServiceException {\n        executeRequest(Request.PUT, \"\", user);\n        Log.d(this.getClass().getSimpleName(), \"User name was: \" + user.getName());\n        Log.d(this.getClass().getSimpleName(), \"User data changed\");\n    }\n\n\n    public User getUser(long userId) throws RestServiceException {\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, String.valueOf(userId));\n            return new ObjectMapper().readValue(((new BufferedReader(new InputStreamReader(\n                    httpResponse.getEntity().getContent(), \"UTF-8\"))).readLine()), User.class);\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        }\n    }\n\n    public User getUserData() throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, \"\");\n            return new ObjectMapper().readValue(((new BufferedReader(new InputStreamReader(\n                    httpResponse.getEntity().getContent(), \"UTF-8\"))).readLine()), User.class);\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        }\n    }\n\n    public void uploadProfilePicture(Bitmap bitmap) throws RestServiceException {\n\n        HttpEntity multipartEntity = MultipartEntityBuilder.create()\n                .addBinaryBody(\"file\", PictureManager.INSTANCE.scaledBitmapToByteArray(bitmap, 500),\n                        ContentType.create(\"image/jpeg\"), \"\")\n                .build();\n\n        executeUpload(Request.POST, \"profile\", multipartEntity, null);\n    }\n\n    public BitmapDrawable getProfilePicture(long userId) throws RestServiceException {\n        try {\n            String path = \"profile/\" + userId;\n            Map<String, String> headers = new HashMap<>();\n            headers.put(\"Accept\", \"image/jpeg; q=0.5, image/png\");\n            HttpEntity response = (executeRequest(Request.GET, path, headers)).getEntity();\n            if (null == response) {\n                return null;\n            }\n            InputStream stream = response.getContent();\n            Bitmap picture = BitmapFactory.decodeStream(stream);\n            return new BitmapDrawable(DatabaseManager.INSTANCE.getContext().getResources(), picture);\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        }\n    }\n\n    public void requirePasswordToken(User user) throws RestServiceException {\n        Log.d(getClass().getSimpleName(), \"Require password token\");\n        HttpResponse httpResponse = executeRequest(Request.POST, \"password/token/\" + language, user);\n    }\n\n    public void changePassword(User user, String token) throws RestServiceException {\n        Log.d(getClass().getSimpleName(), \"Change password\");\n        HttpResponse httpResponse = executeRequest(Request.POST, \"password/\" + token, user);\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/fragments/SearchContactFragment.java\npublic class SearchContactFragment\n        extends Fragment\n        implements View.OnClickListener,\n        AdapterView.OnItemClickListener,\n        NotifiableFragment<SearchContactFragment.DataClass> {\n\n    private List<User> users;\n    private Spinner searchSpinner;\n    private Button searchButton;\n    private ListView searchResultView;\n    private TextView searchText;\n\n    //private AtomicInteger bgTasksRunning = new AtomicInteger(0);\n    private UserAdapter mAdapter;\n    private OnSearchFragmentInteractionListener mListener;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        FragmentObservable<SearchContactFragment, DataClass> obs\n                = ObservableRegistry.getObservable(SearchContactFragment.class);\n        obs.register(this);\n    }\n\n    @Override\n    public void onStop() {\n        FragmentObservable<SearchContactFragment, DataClass> obs\n                = ObservableRegistry.getObservable(SearchContactFragment.class);\n        obs.remove(this);\n        super.onStop();\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        View layout = inflater.inflate(R.layout.fragment_search_contact, null);\n\n        mListener = (OnSearchFragmentInteractionListener) getActivity();\n\n        searchSpinner = (Spinner) layout.findViewById(R.id.search_spinner);\n        searchButton = (Button) layout.findViewById(R.id.search_button);\n        searchText = (TextView) layout.findViewById(R.id.search_text);\n        searchResultView = (ListView) layout.findViewById(R.id.search_listView);\n\n        this.loadSearchSpinner();\n\n        users = new ArrayList<>();\n\n        mAdapter = new UserAdapter(getActivity(), R.layout.user_item, users);\n\n        searchResultView.setAdapter(mAdapter);\n        searchResultView.setOnItemClickListener(this);\n\n        searchButton.setOnClickListener(this);\n\n        return layout;\n    }\n\n\n    private void loadSearchSpinner() {\n        ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(getActivity(),\n                R.array.search_spinner_content, android.R.layout.simple_spinner_item);\n        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\n        searchSpinner.setAdapter(adapter);\n    }\n\n    @Override\n    public void onClick(View v) {\n        CharSequence text = searchText.getText();\n        if (text.toString().equals(\"\")) {\n            return;\n        } else {\n            mAdapter.clear();\n            mAdapter.notifyDataSetChanged();\n            new SearchUserTask(\n                    SearchUserTask.SearchBy.getSearchBy(\n                            searchSpinner.getSelectedItemPosition()),\n                    text.toString(), this.getClass())\n                    .execute();\n\n            // Hide keyboard\n            InputMethodManager inputManager =\n                    (InputMethodManager) DatabaseManager.INSTANCE.getContext().\n                            getSystemService(Context.INPUT_METHOD_SERVICE);\n            View currentFocus = getActivity().getCurrentFocus();\n            if (null != currentFocus) {\n                // If keyboard was displayed\n                inputManager.hideSoftInputFromWindow(\n                        currentFocus.getWindowToken(),\n                        InputMethodManager.HIDE_NOT_ALWAYS);\n            }\n        }\n    }\n\n    @Override\n    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n        if (mListener != null && !users.get(position).equals(\"null\")) {\n            mListener.onSearchFragmentInteraction(users.get(position));\n        }\n    }\n\n    // Steps:\n    // 1. get the picture for every single user\n    // 2. when the GetImageWithoutSavingTask returns, add the user to the adapter\n    // 3. call notifyDateSetChanged()\n    @Override\n    public void notifyFragment(DataClass data) {\n        if (data instanceof UsersClass) {\n            notifyFragment(((UsersClass) data).getUsers());\n        } else if (data instanceof ImageClass) {\n            mAdapter.add(((ImageClass) data).getUser());\n            mAdapter.notifyDataSetChanged();\n        } else {\n            // do nothing\n        }\n    }\n\n    public void notifyFragment(ArrayList<User> userList) {\n        Log.d(getClass().getSimpleName(), \"SearchContactFragment has been notified!\");\n        for (User user : users) {\n            // TODO maybe async\n            PictureManager.INSTANCE.deletePicture(user);\n        }\n        users = userList;\n        mAdapter.clear();\n        mAdapter.notifyDataSetChanged();\n        if (userList != null && userList.size() != 0) {\n            //get profile pictures\n            for (User user : userList) {\n                new GetImageWithoutSavingTask(this.getClass(), user).execute();\n            }\n        } else {\n            Toaster.getInstance().toast(R.string.search_no_results, Toast.LENGTH_SHORT);\n        }\n    }\n\n    public static class DataClass {\n\n        public DataClass() {\n\n        }\n    }\n\n    public static class ImageClass extends DataClass {\n        private BitmapDrawable bitmap;\n        private User user;\n\n        public ImageClass(BitmapDrawable bitmap, User user) {\n            this.bitmap = bitmap;\n            this.user = user;\n        }\n\n        public BitmapDrawable getBitmap() {\n            return bitmap;\n        }\n\n        public User getUser() {\n            return user;\n        }\n    }\n\n    public static class UsersClass extends DataClass {\n        private List<User> users;\n\n        public UsersClass(List<User> users) {\n            this.users = users;\n        }\n\n        public ArrayList<User> getUsers() {\n            return new ArrayList<>(users);\n        }\n    }\n\n    public interface OnSearchFragmentInteractionListener {\n        public void onSearchFragmentInteraction(User user);\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/ObservableRegistry.java\npublic class ObservableRegistry {\n\n    private static ArrayList<ObservableRegistryEntry> entries = new ArrayList<ObservableRegistryEntry>();\n\n    public static <T extends NotifiableFragment<P>, P> FragmentObservable<T, P> getObservable(Class fragmentClass) {\n        for (ObservableRegistryEntry entry : entries) {\n            if (entry.check(fragmentClass)) {\n                Log.d(\"ObserverRegistry\",\"Returned existing observable\");\n                return (FragmentObservable<T,P>) entry.getObs(); // no idea how to solve this... \n            }\n        }\n\n        FragmentObservable<T, P> res = new FragmentObservable<T, P>();\n        Log.d(\"ObserverRegistry\",\"Created new observable\");\n        entries.add(new ObservableRegistryEntry<P>(res,fragmentClass));\n        return res;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/SpinnerObservable.java\npublic class SpinnerObservable {\r\n    private Set<AsyncTask> backgroundTasks;\r\n    private Set<AbstractYasmeActivity> activities;\r\n    private boolean spinning = false;\r\n\r\n    private static SpinnerObservable instance;\r\n\r\n    public static SpinnerObservable getInstance() {\r\n        if (instance == null) {\r\n            instance = new SpinnerObservable();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    private SpinnerObservable() {\r\n        backgroundTasks = new HashSet<>();\r\n        activities = new HashSet<>();\r\n    }\r\n\r\n    public void registerActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Register activity\");\r\n        activities.add(activity);\r\n        if (spinning) {\r\n            Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n            activity.startSpinning();\r\n        } else {\r\n            Log.d(getClass().getSimpleName(), \"No spinning\");\r\n        }\r\n    }\r\n\r\n    public void removeActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Remove activity\");\r\n        activities.remove(activity);\r\n    }\r\n\r\n    public void registerBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Register backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.add(backgroundTask);\r\n        spinning = true;\r\n        startSpinning();\r\n    }\r\n\r\n    public void removeBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Remove backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.remove(backgroundTask);\r\n        if (backgroundTasks.size() == 0) {\r\n            spinning = false;\r\n            stopSpinning();\r\n        }\r\n    }\r\n\r\n    public void startSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.startSpinning();\r\n        }\r\n    }\r\n\r\n    public void stopSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Stop spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.stopSpinning();\r\n        }\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/storage/PictureManager.java\npublic enum PictureManager {\n    INSTANCE;\n\n    private Context mContext = DatabaseManager.INSTANCE.getContext();\n\n    private Bitmap scaleBitmap(Bitmap bigBitmap, int newMaxSize) {\n        float picScale = ((float) newMaxSize)\n                / ((float) Math.max(bigBitmap.getHeight(), bigBitmap.getWidth()));\n        int newHeight = (int) (bigBitmap.getHeight() * picScale);\n        int newWidth = (int) (bigBitmap.getWidth() * picScale);\n        Bitmap bitmap = Bitmap.createScaledBitmap(bigBitmap, newWidth, newHeight, false);\n        return bitmap;\n    }\n\n    public byte[] scaledBitmapToByteArray(Bitmap bitmap, int newMaxSize) {\n        float picScale = ((float) newMaxSize)\n                / ((float) Math.max(bitmap.getHeight(), bitmap.getWidth()));\n        int newHeight = (int) (bitmap.getHeight() * picScale);\n        int newWidth = (int) (bitmap.getWidth() * picScale);\n        Bitmap scaledBitmap = Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, false);\n\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        scaledBitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream);\n        return stream.toByteArray();\n    }\n\n    /**\n     * Stores a given bitmap on internal storage\n     *\n     * @param user   for generating the filename\n     * @param bitmap bitmap to be stored\n     * @return path of the stored picture\n     */\n    public String storePicture(User user, Bitmap bitmap) throws IOException {\n        // TODO Remove old picture\n        // I think it will be replaced automatically\n\n        // Create directory userPictures\n        ContextWrapper cw = new ContextWrapper(mContext);\n        File directory = cw.getDir(\"userPictures\", Context.MODE_PRIVATE);\n\n        // Generate file name\n        String filename = user.getId() + \"_profilePicture.jpg\";\n\n        // Concatenate directory and filename to path\n        File path = new File(directory, filename);\n\n        FileOutputStream fileOutputStream = new FileOutputStream(path);\n        BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream);\n\n        // scale down bitmap\n        Bitmap scaledBitmap = scaleBitmap(bitmap, 300);\n\n        // Use the compress method on the BitMap object to write image to the OutputStream\n        scaledBitmap.compress(Bitmap.CompressFormat.JPEG, 100, bos);\n\n        bos.flush();\n        bos.close();\n        fileOutputStream.close();\n\n        Log.d(this.getClass().getSimpleName(), \"Picture stored under: \" + path.getAbsolutePath());\n        return path.getAbsolutePath();\n    }\n\n\n    public static int calculateInSampleSize(\n            BitmapFactory.Options options, int reqWidth, int reqHeight) {\n        // Raw height and width of image\n        final int height = options.outHeight;\n        final int width = options.outWidth;\n        int inSampleSize = 1;\n\n        if (height > reqHeight || width > reqWidth) {\n\n            final int halfHeight = height / 2;\n            final int halfWidth = width / 2;\n\n            // Calculate the largest inSampleSize value that is a power of 2 and keeps both\n            // height and width larger than the requested height and width.\n            while ((halfHeight / inSampleSize) > reqHeight\n                    && (halfWidth / inSampleSize) > reqWidth) {\n                inSampleSize *= 2;\n            }\n        }\n        return inSampleSize;\n    }\n\n    /**\n     * Fetches the profilePicture from the storage sampled to a smaller size\n     *\n     * @param user      User\n     * @param reqHeight int\n     * @param reqWidth  int\n     * @return profilePicture as a bitmap\n     */\n    public Bitmap getPicture(User user, int reqHeight, int reqWidth) {\n        String path = user.getProfilePicture();\n        if (path == null || path.isEmpty()) {\n            return null;\n        }\n        File file = new File(path);\n        if (!file.exists()) {\n            return null;\n        }\n\n        // First decode with inJustDecodeBounds=true to check dimensions\n        final BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeFile(path, options);\n\n        // Calculate inSampleSize\n        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);\n\n        // Decode bitmap with inSampleSize set\n        options.inJustDecodeBounds = false;\n        return BitmapFactory.decodeFile(path, options);\n    }\n\n    public boolean deletePicture(User user) {\n        String path = user.getProfilePicture();\n        if (path == null || path.isEmpty()) {\n            return false;\n        }\n        File file = new File(path);\n        if (!file.exists()) {\n            return false;\n        }\n        return file.delete();\n    }\n\n    /**\n     * @param bitmap\n     * @return converting bitmap and return a string\n     */\n    public String bitMapToString(Bitmap bitmap) {\n        Bitmap btmp = scaleBitmap(bitmap, 512);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        btmp.compress(Bitmap.CompressFormat.PNG, 100, baos);\n        byte[] b = baos.toByteArray();\n        String temp = Base64.encodeToString(b, Base64.DEFAULT);\n        return temp;\n    }\n\n    /**\n     * @param encodedString\n     * @return bitmap (from given string)\n     */\n    public Bitmap stringToBitMap(String encodedString) {\n        try {\n            byte[] encodeByte = Base64.decode(encodedString, Base64.DEFAULT);\n            Bitmap bitmap = BitmapFactory.decodeByteArray(encodeByte, 0, encodeByte.length);\n            return bitmap;\n        } catch (Exception e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * Create a file Uri for saving an image or video\n     */\n    public static File getOutputMediaFilePath() throws IOException {\n        File mediaStorageDir = new File(\n                Environment.getExternalStorageDirectory(),\n                \"Yasme Pictures\");\n\n        // Create the storage directory if it does not exist\n        if (!mediaStorageDir.exists()) {\n            if (!mediaStorageDir.mkdirs()) {\n                Log.d(\"MyCameraApp\", \"failed to create directory\");\n                return null;\n            }\n        }\n\n        // Create a media file name\n        String timeStamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n        File mediaFile = new File(mediaStorageDir.getPath() + File.separator +\n                \"IMG_\" + timeStamp + \".jpg\");\n\n        return mediaFile;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/User.java\n@JsonIgnoreProperties(ignoreUnknown = true)\n@DatabaseTable(tableName = DatabaseConstants.USER_TABLE)\npublic class User implements Serializable {\n\n    @DatabaseField(columnName = DatabaseConstants.USER_ID, id = true)\n    private long id;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_NAME)\n    private String name;\n\n    //@DatabaseField(columnName = DatabaseConstants.USER_EMAIL)\n    private String email;\n\n    private String pw;\n\n    @JsonIgnore\n    private List<Device> devices;   // Just for convenience\n\n    @DatabaseField(columnName = DatabaseConstants.USER_LAST_MODIFIED)\n    private Date lastModified;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_CREATED)\n    private Date created;\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.USER_PICTURE)\n    private String profilePicture;\n\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.CONTACT)\n    private int contactFlag = 0;\n\n\n    public User(String pw, String name, String email) {\n        this.pw = pw;\n        this.name = name;\n        this.email = email;\n    }\n\n    public User(String email, String pw) {\n        this.email = email;\n        this.pw = pw;\n    }\n\n    public User(String name, long id) {\n        this.name = name;\n        this.id = id;\n    }\n\n    public User(long id) {\n        this.id = id;\n    }\n\n    public User(String name, String email, long id) {\n        this.name = name;\n        this.email = email;\n        this.id = id;\n    }\n\n    public User() {\n        // ORMLite needs a no-arg constructor\n    }\n\n    /*\n     * Getters\n     */\n\n    @JsonIgnoreProperties({\"id\", \"user\", \"publicKey\", \"product\", \"lastModified\"})\n    public List<Device> getDevices() {\n        return devices;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPw() {\n        return pw;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Date getLastModified() {\n        return lastModified;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public String getProfilePicture() {\n        return profilePicture;\n    }\n\n    /*\n     * Setters\n     */\n\n    public void setDevices(List<Device> devices) {\n        this.devices = devices;\n    }\n\n    public void setPw(String pw) {\n        this.pw = pw;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setProfilePicture(String profilePicture) {\n        this.profilePicture = profilePicture;\n    }\n\n    @JsonIgnore\n    public void addToContacts() {\n        contactFlag = 1;\n    }\n\n    @JsonIgnore\n    public void removeFromContacts() {\n        contactFlag = 0;\n    }\n\n    @JsonIgnore\n    public boolean isContact() {\n        return contactFlag == 1;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/Log.java\npublic class Log {\r\n    static final boolean LOG_I = BuildConfig.DEBUG;\r\n    static final boolean LOG_E = BuildConfig.DEBUG;\r\n    static final boolean LOG_D = BuildConfig.DEBUG;\r\n    static final boolean LOG_V = BuildConfig.DEBUG;\r\n    static final boolean LOG_W = BuildConfig.DEBUG;\r\n\r\n    public static void i(String tag, String string) {\r\n        if (LOG_I) android.util.Log.i(tag, string);\r\n    }\r\n    public static void e(String tag, String string) {\r\n        if (LOG_E) android.util.Log.e(tag, string);\r\n    }\r\n    public static void d(String tag, String string) {\r\n        if (LOG_D) android.util.Log.d(tag, string);\r\n    }\r\n    public static void v(String tag, String string) {\r\n        if (LOG_V) android.util.Log.v(tag, string);\r\n    }\r\n    public static void w(String tag, String string) {\r\n        if (LOG_W) android.util.Log.w(tag, string);\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/FragmentObservable.java\npublic class FragmentObservable<T extends NotifiableFragment<P>,  P> {\r\n    private Set<T> fragments;\r\n    private P buffer;\r\n\r\n    public FragmentObservable() {\r\n        fragments = new HashSet<T>();\r\n    }\r\n\r\n    public void register(T fragment) {\r\n        fragments.add(fragment);\r\n        if (buffer != null) {\r\n            notifyFragments(buffer);\r\n        }\r\n    }\r\n\r\n    public void remove(T fragment) {\r\n        fragments.remove(fragment);\r\n    }\r\n\r\n    //addIfNotExists\r\n    public void notifyFragments(P parameter) {\r\n        buffer = parameter;\r\n        for (T fragment : fragments) {\r\n            try {\r\n                Log.d(this.getClass().getSimpleName(), \"Notify fragment: \" + fragment.getClass().getSimpleName());\r\n                fragment.notifyFragment(parameter);\r\n                buffer = null;\r\n            } catch (Exception e) {\r\n                Log.e(this.getClass().getSimpleName(), \"Notify fragment failed: \" + fragment.getClass().getSimpleName());\r\n            }\r\n        }\r\n    }\r\n}\r\n", "answers": ["            FragmentObservable<SearchContactFragment, SearchContactFragment.DataClass> obs ="], "length": 2784, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "c9cf3a57b672fc6cd15147185d157bf8b9c55f73e82d70dc"}
{"input": "from boole.core.info import *\nfrom boole.core.context import *\nfrom boole.core.expr import Const, Sub, Pair, Fst, Snd, Box, root_app, \\\n  root_clause, root_pi, subst_expr\nfrom boole.elaboration.color import *\nfrom boole.elaboration.elab import app_expr, mvar_infer, sub_mvar\nfrom boole.semantics.value import Value\nfrom config import current_ctxt, push_ctxt\nimport boole.core.expr as e\nimport boole.core.typing as typing\nimport elab as elab_tools\nimport boole.core.tactics as tac\nimport unif as u\nimport boole.semantics.value as v\nimport config as conf\nimport boole.user_conf as user_conf\n# -*- coding: utf-8 -*-\n\n###############################################################################\n#\n# terms.py\n#\n# description: a module with functions to build terms and types at the\n# top level.\n#\n#\n# Authors:\n# Cody Roux\n# Jeremy Avigad\n#\n###############################################################################\n\n\n\n###############################################################################\n#\n# Exceptions associated with expressions\n#\n###############################################################################\n\nclass TermError(Exception):\n    \"\"\"Errors for expressions\n    \"\"\"\n    def __init__(self, mess):\n        Exception.__init__(self, mess)\n\n\n###############################################################################\n#\n# String methods for terms\n#\n###############################################################################\n\ndef print_const(expr):\n    \"\"\"Pretty prints constants: if there is a unicode name\n    in the info field, return that, otherwise return the ascii name.\n    \"\"\"\n    if not (expr.info.unicode is None) and conf.print_unicode:\n        return expr.info.unicode\n    elif not (expr.info.sage_name is None) and user_conf.in_sage:\n        return expr.info.sage_name\n    else:\n        return expr.name\n\n# TODO: wouldn't it be clearer to inline most of these in the definitions\n# of term_str and typ_str?\n\n# TODO: print_app uses info fields 'print_iterable' and 'print_implies' to\n# determine if special print methods are needed for application.\n# Is that o.k.?\n\n# TODO: right now the str method uses the name of the constant to print out\n# a value. Should the value class instead determine how values are printed out?\n\n\ndef print_app(expr):\n    \"\"\"Takes an application and prints it in the following manner:\n    if the application is of the form (..(f a0)... an), print\n    f(a0,...,an), or (a0 f a1) if f is infix.\n    \n    Arguments:\n    - `expr`: an expression\n    \"\"\"\n    if conf.implicit:\n        root, args = root_app_implicit(expr)\n        if root.is_const() and root.info.print_iterable_app:\n            return print_iterable_app(expr, root)\n        elif root.is_const() and root.info.print_implies:\n            return print_implies(expr)\n        elif root.info.infix and len(args) == 2:\n            return \"({0!s} {1!s} {2!s})\".format(args[0], root, args[1])\n        else:\n            args_str = map(str, args)\n            args_str = \", \".join(args_str)\n            return \"{0!s}({1!s})\".format(root, args_str)\n    else:\n", "context": "boole/core/expr.py\nclass Box(Expr):\n    \"\"\"Boxed epressions: a boxed expression\n    carries a an expression, a type and a witness that the type of\n    the expression is a subtype of the given type.\n    \"\"\"\n    \n    def __init__(self, conv, expr, type):\n        \"\"\"\n        \n        Arguments:\n        - `conv`: A witness to the equality between the type\n        of expr and type\n        - `expr`: The expression denoted by the box\n        - `type`: The type assigned to expr\n        \"\"\"\n        Expr.__init__(self)\n        self.conv = conv\n        self.expr = expr\n        self.type = type\n        self._hash = hash((\"Box\", self.expr))\n\n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_box(self, *args, **kwargs)\n\n    def to_string(self):\n        return \"Box({0!s},{1!s},{2!s})\".format(self.conv, self.expr, self.type)\n\n    def is_box(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_box():\n            return self.expr.equals(expr.expr)\n        else:\n            return False\nboole/core/expr.py\ndef subst_expr(exprs, expr, is_open=None):\n    \"\"\"Instantiate DB indices in expr according\n    to expr_list\n    \n    Arguments:\n    - `expr_list`: a list of expressions\n    - `expr`: an expression\n    \"\"\"\n    if is_open != None:\n        subster = SubstExpr(exprs, is_open=is_open)\n    else:\n        subster = SubstExpr(exprs)\n    return subster.visit(expr, 0)\nboole/core/expr.py\ndef root_app(expr):\n    \"\"\"Returns the pair (r, args)\n    such that expr = r(*args)\n    \n    Arguments:\n    - `expr`: an expression\n    \"\"\"\n    root = expr\n    args = []\n    while root.is_app():\n        args.append(root.arg)\n        root = root.fun\n        #The arguments were collected in reverse order\n    args.reverse()\n    return (root, args)\nboole/core/expr.py\nclass Const(Expr):\n    \"\"\"A constant declaration. Variables\n    and constants are identified.\n    \"\"\"\n\n    def __init__(self, name, type, value=None, **kwargs):\n        \"\"\"\n        \n        Arguments:\n        - `name`: A name representing the constant\n        - `type`: an expression representing its type\n        - `value`: possibly a semantic value, making this an interpreted\n        constant\n        \"\"\"\n        Expr.__init__(self)\n        self.name = name\n        self.type = type\n        self.value = value\n        for k in kwargs:\n            self.info[k] = kwargs[k]\n        self._hash = hash(('Const', self.name, self.type))\n\n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_const(self, *args, **kwargs)\n\n    def to_string(self):\n        return self.name\n\n    def is_const(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality. Simply compares names.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_const():\n            return self.name == expr.name\n        else:\n            return False\nboole/elaboration/elab.py\ndef app_expr(f, f_ty, cast, args):\n    \"\"\"Applies a function to a list of\n    arguments, some of which are implicit.\n    \n    Arguments:\n    - `f`: an expression denoting the function\n    - `f_ty`: the function type\n    - `cast`: list of evidence terms for the type conversions\n    of each argument\n    - `args`: a list of arguments\n    \"\"\"\n    tm = f\n    rem_args = args\n    rem_cast = cast\n    rem_ty = f_ty\n\n    #TODO: This is a bit of a hack. We need \"maximally inserted arguments\"\n    #as in Coq to do this cleanly\n    if len(args) == 0:\n        while rem_ty.is_pi()\\\n              and rem_ty.info.implicit:\n            mvar = mk_meta(rem_ty.binder.var, rem_ty.dom)\n            #At this point we give the trivial evidence.\n            #after the term is created, we go through the whole\n            #term to collect local information (variables) and to add them\n            #the evidence term\n            mcast = trivial()\n            tm = t.App(mcast, tm, mvar)\n            rem_ty = e.subst_expr([mvar], rem_ty.body)\n    else:\n        while len(rem_args) != 0:\n            if rem_ty.is_pi()\\\n               and rem_ty.info.implicit:\n                mvar = mk_meta(rem_ty.binder.var, rem_ty.dom)\n                mcast = trivial()\n                tm = t.App(mcast, tm, mvar)\n                rem_ty = e.subst_expr([mvar], rem_ty.body)\n            elif rem_ty.is_pi():\n                tm = t.App(rem_cast[0], tm, rem_args[0])\n                rem_ty = e.subst_expr([rem_args[0]], rem_ty.body)\n                rem_cast = rem_cast[1:]\n                rem_args = rem_args[1:]\n            else:\n                #In this case, something is wrong with the type\n                #of f, and we simply blindly apply all the remaining\n                #arguments.\n                tm = t.App(rem_cast[0], tm, rem_args[0])\n                rem_cast = rem_cast[1:]\n                rem_args = rem_args[1:]\n    return tm\nboole/elaboration/elab.py\ndef mvar_infer(expr, ctxt=None):\n    \"\"\"Infer the type of an expression and return the pair\n    (type, proof obligations) or raise an exception of type\n    ExprTypeError.\n    \n    Arguments:\n    - `expr`: an expression\n    \"\"\"\n    if ctxt == None:\n        ty_ctxt_name = meta_var_gen.get_name('_unif_ctxt')\n        ty_ctxt = context.Context(ty_ctxt_name)\n    else:\n        ty_ctxt = ctxt\n    prf_obl_name = meta_var_gen.get_name('_unif_goals')\n    prf_obl = goals.empty_goals(prf_obl_name, ty_ctxt)\n    ty = t.ExprInfer().visit(expr, prf_obl)\n    return (ty, prf_obl)\nboole/core/expr.py\nclass Snd(Expr):\n    \"\"\"Second projection for Sigma types\n    \"\"\"\n    \n    def __init__(self, expr):\n        \"\"\"\n        \n        Arguments:\n        - `expr`: the expression to which is applied the projection.\n        \"\"\"\n        Expr.__init__(self)\n        self.expr = expr\n        self._hash = hash((\"Snd\", self.expr))\n    \n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_snd(self, *args, **kwargs)\n\n    def to_string(self):\n        \"\"\"\n        \n        Arguments:\n        - `self`:\n        \"\"\"\n        return \"Snd({0!s})\".format(self.expr)\n\n    def is_snd(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_snd():\n            return self.expr.equals(expr.expr)\n        else:\n            return False\nboole/core/expr.py\nclass Sub(Expr):\n    \"\"\"The subtype relation. Makes sense regardless\n    of the type of the expressions.\n    \"\"\"\n    \n    def __init__(self, lhs, rhs):\n        \"\"\"\n        \n        Arguments:\n        - `lhs`: an expression\n        - `rhs`: an expression\n        \"\"\"\n        Expr.__init__(self)\n        self.lhs = lhs\n        self.rhs = rhs\n        self._hash = hash((\"Sub\", self.lhs, self.rhs))\n\n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_sub(self, *args, **kwargs)\n\n    def to_string(self):\n        \"\"\"\n        \n        Arguments:\n        - `self`:\n        \"\"\"\n        return \"Sub({0!s}, {1!s})\".format(self.lhs, self.rhs)\n\n    def is_sub(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_sub():\n            return (self.lhs.equals(expr.lhs)) and (self.rhs.equals(expr.rhs))\n        else:\n            return False\nboole/elaboration/elab.py\ndef sub_mvar(expr, undef=None):\n    \"\"\"Replace all meta-variables by their\n    value in a term.\n    \n    Arguments:\n    - `undef`: if this flag is set to True,\n    fail on unresolved meta-vars.\n    \"\"\"\n    return SubMvar(undef=undef).visit(expr)\nboole/core/expr.py\nclass Fst(Expr):\n    \"\"\"First projection for Sigma types\n    \"\"\"\n    \n    def __init__(self, expr):\n        \"\"\"\n        \n        Arguments:\n        - `expr`: the expression to which is applied the projection.\n        \"\"\"\n        Expr.__init__(self)\n        self.expr = expr\n        self._hash = hash((\"Fst\", self.expr))\n    \n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_fst(self, *args, **kwargs)\n\n    def to_string(self):\n        \"\"\"\n        \n        Arguments:\n        - `self`:\n        \"\"\"\n        return \"Fst({0!s})\".format(self.expr)\n\n    def is_fst(self):\n        return True\n\n    def equals(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_fst():\n            return self.expr.equals(expr.expr)\n        else:\n            return False\nboole/core/expr.py\nclass Pair(Expr):\n    \"\"\"Elements of Sigma types. They need to carry around their type,\n    for type-checking to be decidable.\n    \"\"\"\n    \n    def __init__(self, fst, snd, type):\n        \"\"\"\n        \n        Arguments:\n        - `fst`: an expression denoting the first component\n        - `snd`: an expression denoting the second component\n        - `type`: an expression\n        \"\"\"\n        Expr.__init__(self)\n        self.fst = fst\n        self.snd = snd\n        self.type = type\n        self._hash = hash((\"Pair\", self.type, self.fst, self.snd))\n\n    def accept(self, visitor, *args, **kwargs):\n        \"\"\"The accept method allows the definition of\n        recursive functions over objects of type expr.\n        \n        Arguments:\n        - `visitor`: an object of class ExprVisitor\n        - `*args`: arguments to the visitor instance\n        - `**kwargs`: named arguments to the visitor instance\n        \"\"\"\n        return visitor.visit_pair(self, *args, **kwargs)\n\n    def to_string(self):\n        return \"Pair({0!s},{1!s},{2!s})\".\\\n               format(self.fst, self.snd, self.type)\n        \n    def is_pair(self):\n        return True\n\n    def eq(self, expr):\n        \"\"\"Structural equality.\n        \n        Arguments:\n        - `expr`: an expression\n        \"\"\"\n        if expr.is_pair():\n            return self.fst.equals(expr.fst) and \\\n                   self.snd.equals(expr.snd) and \\\n                   self.type.equals(expr.type)\n        else:\n            return False\nboole/core/expr.py\ndef root_pi(expr):\n    \"\"\"Returns the pair (r, [an,..,a0])\n    such that expr = Pi(a0, Pi(.. Pi(an, r)..)\n    \n    Arguments:\n    - `expr`: an expression\n    \"\"\"\n    root = expr\n    args = []\n    while root.is_pi():\n        args.append(root.dom)\n        _, root = open_bound_fresh(root)\n    return (root, args)\nboole/core/expr.py\ndef root_clause(expr):\n    \"\"\"Returns r such that expr is of the form\n    forall(x1,...,forall(xn, p1 >= (p2 >= ... (pm >= r))))\n    replacing xi with fresh variables\n    \n    Arguments:\n    - `expr`: an expression\n    \"\"\"\n    root = expr\n    while root.is_forall():\n        _, root = open_bound_fresh(root)\n    while is_impl(root):\n        root = arg_i(root, 1)\n    return root\nboole/semantics/value.py\nclass Value(object):\n    \"\"\"The class of semantic values\n    \n    Arguments:\n    - `pyval`: a python value\n    - `desc`: a boole expression that, together with the pyval,\n    gives a description of the object in question\n    - `is_num`: a boolean, indicates that pyval supports numeric operations\n    \"\"\"\n\n    def __init__(self, pyval=None, desc=None, is_num=False):\n        \"\"\"Creats the object\n        \"\"\"\n        self.pyval = pyval\n        self.desc = desc\n        self._is_num = is_num\n        \n    # TODO: what should the string method do? For now, just take the Python\n    # object\n    def __str__(self):\n        return str(self.pyval)\n    \n    def is_num(self):\n        return self._is_num\n", "answers": ["        root, args = root_app(expr)"], "length": 1696, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "bee428fb7bb5ddfeac36cb9792f82abae80eae1b8c9df850"}
{"input": "from itertools import chain\nfrom contextlib import contextmanager\nfrom collections import namedtuple, deque, defaultdict\nfrom .refs import ArgRef, FieldRef, ItemRef, Reference, is_from_arg, CtxRef\nfrom .nodes import Tuple, Number, Keyword, String, List, Symbol, Placeholder\nfrom .nodes import NodeVisitor, NodeTransformer\nfrom .types import IntType, NamedArgMeta, StringType, ListType, VarArgsMeta\nfrom .types import TypeVarMeta, TypeVar, Func, NamedArg, Record, TypeRefMeta\nfrom .types import RecordMeta, BoolType, Union, ListTypeMeta, DictTypeMeta\nfrom .types import TypingMeta, UnionMeta, Nothing, Option, VarArgs, FuncMeta\nfrom .types import TypeTransformer, Markup, VarNamedArgs, VarNamedArgsMeta\nfrom .types import MarkupMeta\nfrom .utils import VarsGen\nfrom .errors import Errors, UserError\nfrom .compat import zip_longest\nfrom .constant import HTML_ELEMENTS\n                             .format(t1, t2))\n\n\ndef split_args(args):\n    pos_args, kw_args = [], {}\n    i = enumerate(args)\n    try:\n        while True:\n            arg_pos, arg = next(i)\n            if isinstance(arg, Keyword):\n                try:\n                    value_pos, _ = next(i)\n                except StopIteration:\n                    raise TypeError('Missing named argument value')\n                else:\n                    kw_args[arg.name] = value_pos\n            else:\n                pos_args.append(arg_pos)\n    except StopIteration:\n        return pos_args, kw_args\n\n\ndef normalize_args(fn_type, args, pos_args, kw_args):\n    pos_args, kw_args = list(pos_args), dict(kw_args)\n    norm_args = []\n    norm_args_pos = []\n    missing_arg = False\n    for arg_type in fn_type.__args__:\n        if isinstance(arg_type, NamedArgMeta):\n            try:\n                value_pos = kw_args.pop(arg_type.__arg_name__)\n            except KeyError:\n                missing_arg = True\n                break\n            else:\n                norm_args.append(args[value_pos])\n                norm_args_pos.append(value_pos)\n        elif isinstance(arg_type, VarArgsMeta):\n            norm_args.append([args[pos] for pos in pos_args])\n            norm_args_pos.append(list(pos_args))\n            del pos_args[:]\n        elif isinstance(arg_type, VarNamedArgsMeta):\n            norm_args.append({k: args[v] for k, v in kw_args.items()})\n            norm_args_pos.append(kw_args.copy())\n            kw_args.clear()\n        else:\n            try:\n                value_pos = pos_args.pop(0)\n            except IndexError:\n                missing_arg = True\n                break\n            else:\n                norm_args.append(args[value_pos])\n                norm_args_pos.append(value_pos)\n    if pos_args or kw_args or missing_arg:\n        raise SignatureMismatch\n    else:\n        return norm_args, norm_args_pos\n\n\ndef match_fn(fn_types, args):\n    pos_args, kw_args = split_args(args)\n    for fn_type in fn_types:\n        try:\n            norm_args, norm_args_pos = \\\n                normalize_args(fn_type, args, pos_args, kw_args)\n        except SignatureMismatch:\n            continue\n        else:\n            return fn_type, norm_args, norm_args_pos\n    else:\n        raise TypeCheckError('Function signature mismatch')\n\n\ndef restore_args(fn_type, args, norm_args, norm_args_pos):\n    args_map = {}\n    _norm_args = list(norm_args)\n    _norm_args_pos = list(norm_args_pos)\n    for arg_type in fn_type.__args__:\n        if isinstance(arg_type, NamedArgMeta):\n            value = _norm_args.pop(0)\n            value_pos = _norm_args_pos.pop(0)\n            args_map[value_pos - 1] = args[value_pos - 1]  # keyword\n            args_map[value_pos] = value\n        elif isinstance(arg_type, VarArgsMeta):\n            values = _norm_args.pop(0)\n            values_pos = _norm_args_pos.pop(0)\n            for v, v_pos in zip(values, values_pos):\n                args_map[v_pos] = v\n        elif isinstance(arg_type, VarNamedArgsMeta):\n            values_map = _norm_args.pop(0)\n            values_pos = _norm_args_pos.pop(0)\n            for key in values_map.keys():\n                value = values_map[key]\n                value_pos = values_pos[key]\n                args_map[value_pos - 1] = args[value_pos - 1]  # keyword\n                args_map[value_pos] = value\n        else:\n            value = _norm_args.pop(0)\n            value_pos = _norm_args_pos.pop(0)\n            args_map[value_pos] = value\n    assert not _norm_args\n    assert len(args_map) == len(args)\n    return [args_map[i] for i in range(len(args))]\n\n\ndef check_arg(arg, type_, env):\n    arg = check(arg, env)\n    with env.errors.location(arg.location):\n        unify(arg.__type__, type_)\n    return arg\n\n\n_StringLike = Union[Nothing, IntType, StringType]\n\n_MarkupLike = Union[_StringLike, Markup]\n\n\n__var = VarsGen()\n\n", "context": "kinko/types.py\nclass Union(with_metaclass(UnionMeta, object)):\n    pass\nkinko/refs.py\nclass ItemRef(Reference):\n\n    def __repr__(self):\n        return '{!r} > []'.format(self.backref)\nkinko/refs.py\nclass ArgRef(Reference):\n\n    def __init__(self, name):\n        super(ArgRef, self).__init__(None)\n        self.name = name\n\n    def __repr__(self):\n        return \"#{}\".format(self.name)\nkinko/nodes.py\nclass NodeTransformer(object):\n\n    def visit(self, node):\n        return node.accept(self)\n\n    def visit_tuple(self, node):\n        return node.clone_with(self.visit(i) for i in node.values)\n\n    def visit_list(self, node):\n        return node.clone_with(self.visit(i) for i in node.values)\n\n    def visit_dict(self, node):\n        return node.clone_with(self.visit(i) for i in node.values)\n\n    def visit_symbol(self, node):\n        return node.clone()\n\n    def visit_keyword(self, node):\n        return node.clone()\n\n    def visit_placeholder(self, node):\n        return node.clone()\n\n    def visit_number(self, node):\n        return node.clone()\n\n    def visit_string(self, node):\n        return node.clone()\nkinko/nodes.py\nclass String(Node):\n\n    def __init__(self, value, **kw):\n        self.value = text_type(value)\n        super(String, self).__init__(**kw)\n\n    def __repr__(self):\n        return encode_basestring_ascii(self.value)\n\n    def accept(self, visitor):\n        return visitor.visit_string(self)\nkinko/types.py\nclass NamedArgMeta(TypingMeta):\n\n    def __cls_init__(cls, params):\n        cls.__arg_name__, cls.__arg_type__ = params\n\n    def __repr__(cls):\n        return ':{} {!r}'.format(cls.__arg_name__, cls.__arg_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_namedarg(cls)\nkinko/types.py\nclass VarArgsMeta(TypingMeta):\n\n    def __cls_init__(cls, arg_type):\n        cls.__arg_type__ = arg_type\n\n    def __repr__(cls):\n        return '*{!r}'.format(cls.__arg_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_varargs(cls)\nkinko/nodes.py\nclass Tuple(Node):\n\n    def __init__(self, values, **kw):\n        self.values = tuple(values)\n        super(Tuple, self).__init__(**kw)\n\n    def __repr__(self):\n        return '({})'.format(' '.join(map(repr, self.values)))\n\n    def accept(self, visitor):\n        return visitor.visit_tuple(self)\nkinko/types.py\nclass RecordMeta(TypingMeta):\n\n    def __cls_init__(cls, items):\n        cls.__items__ = dict(items)\n\n    def __repr__(cls):\n        return '{}{{{}}}'.format(\n            cls.__name__,\n            ' '.join(':{} {!r}'.format(*i) for i in cls.__items__.items()),\n        )\n\n    def accept(cls, visitor):\n        return visitor.visit_record(cls)\nkinko/types.py\nclass TypingMeta(GenericMeta):\n\n    def __cls_init__(cls, *args):\n        raise NotImplementedError\n\n    def __getitem__(cls, parameters):\n        type_ = cls.__class__(cls.__name__, cls.__bases__, dict(cls.__dict__))\n        type_.__cls_init__(parameters)\n        return type_\nkinko/nodes.py\nclass List(Node):\n\n    def __init__(self, values, **kw):\n        self.values = tuple(values)\n        super(List, self).__init__(**kw)\n\n    def __repr__(self):\n        return '[{}]'.format(' '.join(map(repr, self.values)))\n\n    def accept(self, visitor):\n        return visitor.visit_list(self)\nkinko/constant.py\nHTML_ELEMENTS = frozenset((\n    # root\n    'html',\n\n    # metadata\n    'head', 'title', 'base', 'link', 'meta', 'style',\n\n    # sections\n    'body', 'article', 'section', 'nav', 'aside', 'h1', 'h2', 'h3', 'h4', 'h5',\n    'h6', 'hgroup', 'headers', 'footer', 'address',\n\n    # grouping content\n    'p', 'hr', 'pre', 'blockquote', 'ol', 'ul', 'li', 'dl', 'dt', 'dd',\n    'figure', 'figcaption', 'main', 'div',\n\n    # text-level semantics\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'ruby', 'rt',\n    'rp', 'data', 'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b',\n    'u', 'mark', 'bdi', 'bdo', 'span', 'br', 'wbr',\n\n    # links\n    'a', 'area',\n\n    # edits\n    'ins', 'del',\n\n    # embedded content\n    'picture', 'source', 'img', 'iframe', 'embed', 'object', 'param', 'video',\n    'audio', 'track', 'map',\n\n    # tabular data\n    'table', 'caption', 'colgroup', 'col', 'tbody', 'thead', 'tfoot', 'tr',\n    'td', 'th',\n\n    # forms\n    'form', 'label', 'input', 'button', 'select', 'datalist', 'optgroup',\n    'option', 'textarea', 'keygen', 'output', 'progress', 'meter', 'fieldset',\n    'legend',\n\n    # interactive elements\n    'details', 'summary', 'menu', 'menuitem', 'dialog',\n\n    # scripting\n    'script', 'noscript', 'template', 'canvas',\n))\nkinko/types.py\nclass VarNamedArgs(with_metaclass(VarNamedArgsMeta, object)):\n    pass\nkinko/refs.py\nclass FieldRef(Reference):\n\n    def __init__(self, backref, name):\n        super(FieldRef, self).__init__(backref)\n        self.name = name\n\n    def __repr__(self):\n        return '{!r} > [{!r}]'.format(self.backref, self.name)\nkinko/types.py\nclass TypeRefMeta(TypingMeta):\n    __ref__ = None\n\n    def __cls_init__(cls, name):\n        cls.__ref_name__ = name\n\n    def __repr__(cls):\n        if cls.__ref__ is None:\n            return '<{}[-]>'.format(cls.__ref_name__)\n        else:\n            return '<{}[*]>'.format(cls.__ref_name__)\n\n    def accept(cls, visitor):\n        return visitor.visit_typeref(cls)\nkinko/types.py\nclass ListType(with_metaclass(ListTypeMeta, object)):\n    pass\nkinko/types.py\nclass Nothing(with_metaclass(NothingMeta, object)):\n    pass\nkinko/utils.py\nclass VarsGen(object):\n\n    def __init__(self):\n        self.vars = {}\n\n    def __getattr__(self, name):\n        if name not in self.vars:\n            self.vars[name] = TypeVar[None]\n        return self.vars[name]\nkinko/types.py\nclass VarNamedArgsMeta(TypingMeta):\n\n    def __cls_init__(cls, arg_type):\n        cls.__arg_type__ = arg_type\n\n    def __repr__(cls):\n        return '**{!r}'.format(cls.__arg_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_varnamedargs(cls)\nkinko/compat.py\nPY3 = sys.version_info[0] == 3\nPY35 = sys.version_info >= (3, 5)\ndef with_metaclass(meta, *bases):\n        def __new__(cls, name, this_bases, d):\n    def _exec_in(source, globals_dict):\n    def _exec_in(source, globals_dict):\n    class metaclass(meta):\nkinko/types.py\nclass DictTypeMeta(TypingMeta):\n\n    def __cls_init__(cls, params):\n        cls.__key_type__, cls.__value_type__ = params\n\n    def __repr__(cls):\n        return '{{:{!r} {!r}}}'.format(cls.__key_type__, cls.__value_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_dict(cls)\nkinko/types.py\nclass Func(with_metaclass(FuncMeta, object)):\n    pass\nkinko/types.py\nclass StringType(with_metaclass(StringTypeMeta, object)):\n    pass\nkinko/nodes.py\nclass Keyword(Node):\n\n    def __init__(self, name, **kw):\n        self.name = name\n        super(Keyword, self).__init__(**kw)\n\n    def __repr__(self):\n        return ':{}'.format(self.name)\n\n    def accept(self, visitor):\n        return visitor.visit_keyword(self)\nkinko/errors.py\nclass Errors(object):\n\n    def __init__(self):\n        self.list = []\n        self._stack = [None]\n\n    @contextmanager\n    def module_ctx(self, module):\n        self._stack.append(Func(module, None))\n        try:\n            yield\n        finally:\n            self._stack.pop()\n\n    @contextmanager\n    def func_ctx(self, module, name):\n        self._stack.append(Func(module, name))\n        try:\n            yield\n        finally:\n            self._stack.pop()\n\n    @contextmanager\n    def location(self, location):\n        try:\n            yield\n        except UserError as e:\n            self.error(location, text_type(e))\n            raise\n\n    def warn(self, location, message):\n        self.list.append(Error(self._stack[-1], location, message, WARNING))\n\n    def error(self, location, message):\n        self.list.append(Error(self._stack[-1], location, message, ERROR))\nkinko/types.py\nclass Markup(with_metaclass(MarkupMeta, object)):\n    pass\nkinko/types.py\nclass TypeTransformer(object):\n\n    def visit(self, type_):\n        return type_.accept(self)\n\n    def visit_bool(self, type_):\n        return type_\n\n    def visit_nothing(self, type_):\n        return type_\n\n    def visit_string(self, type_):\n        return type_\n\n    def visit_int(self, type_):\n        return type_\n\n    def visit_markup(self, type_):\n        return type_\n\n    def visit_typevar(self, type_):\n        return TypeVar[self.visit(type_.__instance__)\n                       if type_.__instance__ is not None else None]\n\n    def visit_typeref(self, type_):\n        return TypeRef[type_.__ref_name__]\n\n    def visit_union(self, type_):\n        return Union[(self.visit(t) for t in type_.__types__)]\n\n    def visit_option(self, type_):\n        t = (type_.__types__ - {Nothing}).pop()\n        return Option[self.visit(t)]\n\n    def visit_func(self, type_):\n        return Func[[self.visit(t) for t in type_.__args__],\n                    self.visit(type_.__result__)]\n\n    def visit_varargs(self, type_):\n        return VarArgs[self.visit(type_.__arg_type__)]\n\n    def visit_namedarg(self, type_):\n        return NamedArg[type_.__arg_name__, self.visit(type_.__arg_type__)]\n\n    def visit_varnamedargs(self, type_):\n        return VarNamedArgs[self.visit(type_.__arg_type__)]\n\n    def visit_list(self, type_):\n        return ListType[self.visit(type_.__item_type__)]\n\n    def visit_dict(self, type_):\n        return DictType[self.visit(type_.__key_type__),\n                        self.visit(type_.__value_type__)]\n\n    def visit_record(self, type_):\n        return Record[{key: self.visit(value)\n                       for key, value in type_.__items__.items()}]\nkinko/refs.py\ndef is_from_arg(ref):\n    return isinstance(get_origin(ref), ArgRef)\nkinko/types.py\nclass BoolType(with_metaclass(BoolTypeMeta, object)):\n    pass\nkinko/types.py\nclass VarArgs(with_metaclass(VarArgsMeta, object)):\n    pass\nkinko/refs.py\nclass Reference(object):\n\n    def __init__(self, backref):\n        self.backref = backref\nkinko/nodes.py\nclass NodeVisitor(object):\n\n    def visit(self, node):\n        node.accept(self)\n\n    def visit_tuple(self, node):\n        for value in node.values:\n            self.visit(value)\n\n    def visit_list(self, node):\n        for value in node.values:\n            self.visit(value)\n\n    def visit_dict(self, node):\n        for value in node.values:\n            self.visit(value)\n\n    def visit_symbol(self, node):\n        pass\n\n    def visit_keyword(self, node):\n        pass\n\n    def visit_placeholder(self, node):\n        pass\n\n    def visit_number(self, node):\n        pass\n\n    def visit_string(self, node):\n        pass\nkinko/types.py\nclass TypeVarMeta(TypingMeta):\n    __backref__ = None\n\n    def __cls_init__(cls, instance):\n        cls.__instance__ = instance\n\n    def __repr__(cls):\n        return '<{}:{}>'.format(\n            hex(id(cls))[-3:].upper(),\n            repr(cls.__instance__) if cls.__instance__ is not None else '?',\n        )\n\n    def accept(cls, visitor):\n        return visitor.visit_typevar(cls)\nkinko/types.py\nclass MarkupMeta(GenericMeta):\n\n    def __repr__(cls):\n        return 'markup'\n\n    def accept(cls, visitor):\n        return visitor.visit_markup(cls)\nkinko/types.py\nclass Record(with_metaclass(RecordMeta, object)):\n    pass\nkinko/types.py\nclass Option(with_metaclass(OptionMeta, object)):\n    pass\nkinko/nodes.py\nclass Number(Node):\n\n    def __init__(self, value, **kw):\n        self.value = value\n        super(Number, self).__init__(**kw)\n\n    def __repr__(self):\n        return repr(self.value)\n\n    def accept(self, visitor):\n        return visitor.visit_number(self)\nkinko/types.py\nclass UnionMeta(TypingMeta):\n\n    def __cls_init__(cls, types):\n        cls.__types__ = set(types)\n\n    def __repr__(cls):\n        return '|'.join(map(repr, cls.__types__))\n\n    def accept(cls, visitor):\n        return visitor.visit_union(cls)\nkinko/refs.py\nclass CtxRef(Reference):\n\n    def __init__(self, name):\n        super(CtxRef, self).__init__(None)\n        self.name = name\n\n    def __repr__(self):\n        return 'ctx[{!r}]'.format(self.name)\nkinko/nodes.py\nclass Symbol(Node):\n\n    def __init__(self, name, **kw):\n        self.name = name\n        head, sep, tail = name.partition('/')\n        if sep:\n            self.ns, self.rel = head, tail\n        else:\n            self.ns, self.rel = None, name\n        super(Symbol, self).__init__(**kw)\n\n    def __repr__(self):\n        return self.name\n\n    def accept(self, visitor):\n        return visitor.visit_symbol(self)\nkinko/errors.py\nclass UserError(Exception):\n    pass\nkinko/types.py\nclass ListTypeMeta(TypingMeta):\n\n    def __cls_init__(cls, item_type):\n        cls.__item_type__ = item_type\n\n    def __repr__(cls):\n        return '[{!r}]'.format(cls.__item_type__)\n\n    def accept(cls, visitor):\n        return visitor.visit_list(cls)\nkinko/nodes.py\nclass Placeholder(Node):\n\n    def __init__(self, name, **kw):\n        self.name = name\n        super(Placeholder, self).__init__(**kw)\n\n    def __repr__(self):\n        return '#{}'.format(self.name)\n\n    def accept(self, visitor):\n        return visitor.visit_placeholder(self)\nkinko/types.py\nclass FuncMeta(TypingMeta):\n\n    def __cls_init__(cls, params):\n        cls.__args__, cls.__result__ = params\n\n    def __repr__(cls):\n        return '({} -> {!r})'.format(\n            ' '.join(map(repr, cls.__args__)),\n            cls.__result__,\n        )\n\n    def accept(cls, visitor):\n        return visitor.visit_func(cls)\nkinko/types.py\nclass TypeVar(with_metaclass(TypeVarMeta, object)):\n    pass\nkinko/types.py\nclass NamedArg(with_metaclass(NamedArgMeta, object)):\n    pass\nkinko/types.py\nclass IntType(with_metaclass(IntTypeMeta, object)):\n    pass\n", "answers": ["LET_TYPE = Func[[__var.bindings, __var.expr], __var.result]"], "length": 1468, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "88f4d3b90d76a35d06c424d2eeb431e044023108dde98a97"}
{"input": "import json\nimport pytz\nfrom datetime import datetime\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.core.cache import cache\nfrom django.core.urlresolvers import reverse\nfrom django.db import transaction\nfrom django.http import HttpResponse\nfrom django.utils.six.moves.urllib.parse import urlsplit\nfrom django.utils.timezone import now\nfrom django.utils.translation import ugettext as _\nfrom django.views.generic import FormView\nfrom django.views.generic import View\nfrom core.exceptions import RegistrationRateException\nfrom core.views import ConfirmationView\nfrom core.views import ConfirmedView\nfrom .constants import PURPOSE_DELETE\nfrom .constants import PURPOSE_REGISTER\nfrom .constants import PURPOSE_SET_EMAIL\nfrom .constants import PURPOSE_SET_PASSWORD\nfrom .constants import REGISTRATION_WEBSITE\nfrom .forms import DeleteConfirmationForm\nfrom .forms import DeleteForm\nfrom .forms import RegistrationConfirmationForm\nfrom .forms import RegistrationForm\nfrom .forms import ResetEmailConfirmationForm\nfrom .forms import ResetEmailForm\nfrom .forms import ResetPasswordConfirmationForm\nfrom .forms import ResetPasswordForm\nfrom .mixins import AntiSpamMixin\nfrom .mixins import ConfirmationMixin\nfrom .mixins import ConfirmedMixin\nfrom django_xmpp_backends import backend\nfrom xmpp_backends.base import UserNotFound\n# -*- coding: utf-8 -*-\n# vim: expandtab:tabstop=4:hlsearch\n#\n# This file is part of django-xmpp-account (https://github.com/mathiasertl/django-xmpp-account/).\n#\n# django-xmpp-account is free software: you can redistribute it and/or modify it under the terms of\n# the GNU General Public License as published by the Free Software Foundation, either version 3 of\n# the License, or (at your option) any later version.\n#\n# django-xmpp-account is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n# the GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along with django-xmpp-account.\n# If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import unicode_literals, absolute_import\n\n\n\n\n\n\n\n\nUser = get_user_model()\ntzinfo = pytz.timezone(settings.TIME_ZONE)\n_messages = {\n    PURPOSE_REGISTER: {\n        'opengraph_title': _('%(DOMAIN)s: Register a new account'),\n        'opengraph_description': _('Register on %(DOMAIN)s, a reliable and secure Jabber server. Jabber is a free and open instant messaging protocol used by millions of people worldwide.'),\n    },\n    PURPOSE_SET_EMAIL: {\n        'opengraph_title': _('%(DOMAIN)s: Set a new email address'),\n        'opengraph_description': _('Set a new email address for your Jabber account on %(DOMAIN)s. You must have a valid email address set to be able to reset your password.'),\n    },\n    PURPOSE_SET_PASSWORD: {\n        'opengraph_title': _('%(DOMAIN)s: Reset your password'),\n        'opengraph_description': _('Reset the password for your %(DOMAIN)s account.'),\n    },\n    PURPOSE_DELETE: {\n        'opengraph_title': _('%(DOMAIN)s: Delete your account'),\n        'opengraph_description': _('Delete your account on %(DOMAIN)s. WARNING: Once your account is deleted, it can never be restored.'),\n    },\n}\n\n\nclass XMPPAccountView(AntiSpamMixin, FormView):\n    \"\"\"Base class for all other views in this module.\"\"\"\n\n    purpose = None\n\n    def get_context_data(self, **kwargs):\n        context = super(XMPPAccountView, self).get_context_data(**kwargs)\n        context['menuitem'] = self.purpose\n\n        # Social media\n        action_path = reverse('xmpp_accounts:%s' % self.purpose)\n        context['ACTION_URL'] = self.request.build_absolute_uri(action_path)\n        context['REGISTER_URL'] = self.request.build_absolute_uri(\n            reverse('xmpp_accounts:register'))\n        context['OPENGRAPH_TITLE'] = _messages[self.purpose]['opengraph_title'] % self.request.site\n        context['OPENGRAPH_DESCRIPTION'] = _messages[self.purpose]['opengraph_description'] \\\n                                            % self.request.site\n        context['TWITTER_TEXT'] = _messages[self.purpose].get('twitter_text',\n                                                              context['OPENGRAPH_TITLE'])\n\n        if 'CANONICAL_HOST' in self.request.site:\n            context['ACTION_URL'] = urlsplit(context['ACTION_URL'])._replace(\n                netloc=self.request.site['CANONICAL_HOST']).geturl()\n            context['REGISTER_URL'] = urlsplit(context['REGISTER_URL'])._replace(\n                netloc=self.request.site['CANONICAL_HOST']).geturl()\n\n        # TODO: Yes, that's ugly!\n        form = context['form']\n        if settings.GPG and hasattr(form, 'cleaned_data') and 'gpg_key' in form.fields:\n            if form['gpg_key'].errors or form['fingerprint'].errors or \\\n                    form.cleaned_data.get('fingerprint') or form.cleaned_data.get('gpg_key'):\n                context['show_gpg'] = True\n        return context\n\n    def form_valid(self, form):\n        return self.render_to_response(self.get_context_data(form=form))\n\n\nclass RegistrationView(ConfirmationMixin, XMPPAccountView):\n", "context": "xmpp_accounts/forms.py\nclass ResetPasswordForm(AntiSpamForm):\n    username = XMPPAccountJIDField()\ncore/views.py\nclass ConfirmationView(AntiSpamFormView):\n    user_not_found_error = _(\"User not found (or false password provided)!\")\n\n    def handle_valid(self, form, user):\n        \"\"\"By default, the users current fingerprint is the payload.\"\"\"\n\n        return {\n            'gpg_fingerprint': user.gpg_fingerprint,\n            'username': user.node,\n            'domain': user.domain,\n        }\n\n    def handle_gpg(self, form, user):\n        if not settings.GPG:\n            return {}  # shortcut\n\n        if form.cleaned_data.get('fingerprint'):\n            fingerprint = form.cleaned_data['fingerprint']\n\n            return {'gpg_fingerprint': fingerprint, }\n        elif 'gpg_key' in self.request.FILES:\n            path = self.request.FILES['gpg_key'].temporary_file_path()\n            with open(path) as stream:\n                data = stream.read()\n            return {'gpg_key': data, }\n        else:\n            return {'gpg_fingerprint': None, }\n\n    def form_valid(self, form):\n        try:\n            user = self.get_user(form.cleaned_data)\n            payload = self.handle_valid(form, user)\n        except GpgError as e:\n            form.add_error(e.field, e.message)\n            return self.form_invalid(form)\n        except User.DoesNotExist:\n            form.add_error(None, self.user_not_found_error)\n            return self.form_invalid(form)\n        except UserNotFound as e:\n            if e.args and e.args[0]:\n                form.add_error(None, e.args[0].encode('utf-8'))\n            else:\n                form.add_error(None, self.user_not_found_error)\n            return self.form_invalid(form)\n\n        # log user address:\n        address = Address.objects.get_or_create(address=self.request.META['REMOTE_ADDR'])[0]\n        UserAddresses.objects.create(address=address, user=user, purpose=self.purpose)\n\n        # Send confirmation email to the user\n        key, kwargs = confirm(self.request, user, purpose=self.purpose, payload=payload)\n        if settings.BROKER_URL is None:\n            key.send(**kwargs)\n        else:\n            send_email.delay(key_id=key.pk, **kwargs)\n\n        return super(ConfirmationView, self).form_valid(form)\ncore/views.py\nclass ConfirmedView(AntiSpamFormView):\n    user = None\n\n    def dispatch(self, request, *args, **kwargs):\n        if request.META.get('HTTP_USER_AGENT', '').startswith('Twitterbot'):\n            return HttpResponseRedirect(reverse(self.action_url))\n        return super(ConfirmedView, self).dispatch(request, *args, **kwargs)\n\n    def after_delete(self, data):\n        pass\n\n    def get_context_data(self, **kwargs):\n        context = super(ConfirmedView, self).get_context_data(**kwargs)\n        if self.user is not None:\n            context['username'] = self.user.node\n            context['domain'] = self.user.domain\n            context['jid'] = self.user.jid\n        return context\n\n    def form_valid(self, form):\n        try:\n            key = Confirmation.objects.valid().filter(\n                purpose=self.purpose).get(key=self.kwargs['key'])\n        except Confirmation.DoesNotExist:\n            form.add_error(None, _(\"Confirmation key expired or not found.\"))\n            return self.form_invalid(form)\n        self.user = key.user\n\n        try:\n            self.handle_key(key, form)\n            key.delete()\n            self.after_delete(form.cleaned_data)\n        except UserNotFound as e:\n            if e.message:\n                form.add_error(None, _(\"User not found: %s\") % e.message)\n            else:\n                form.add_error(None, _(\"User not found!\"))\n            return self.form_invalid(form)\n        except UserExists:\n            form.add_error(None, _(\"User already exists!\"))\n            return self.form_invalid(form)\n\n        return super(ConfirmedView, self).form_valid(form)\nxmpp_accounts/constants.py\nPURPOSE_SET_PASSWORD = 'password'\nxmpp_accounts/mixins.py\nclass ConfirmationMixin(object):\n    # TODO: Very ugly here (should be part of the form or so)\n    user_not_found_error = _(\"User not found (or false password provided)!\")\n\n    def get_template_names(self):\n        return ['xmpp_accounts/%s/main.html' % self.purpose]\n\n    def gpg_from_form(self, form):\n        if not settings.GPG:\n            return {}  # shortcut\n\n        if form.cleaned_data.get('fingerprint'):\n            return {'gpg_encrypt': form.cleaned_data.get('fingerprint'), }\n        elif 'gpg_key' in self.request.FILES:\n            path = self.request.FILES['gpg_key'].temporary_file_path()\n            with open(path) as stream:\n                data = stream.read()\n            return {'gpg_key': data, }\n        return {}\n\n    def gpg_from_user(self, user):\n        if not settings.GPG or not user.gpg_fingerprint:\n            return {}\n        return {'gpg_encrypt': user.gpg_fingerprint}\n\n    def form_valid(self, form):\n        try:\n            user = self.get_user(form.cleaned_data)\n            payload = self.handle_valid(form, user)\n        except User.DoesNotExist:\n            form.add_error(None, self.user_not_found_error)\n            return self.form_invalid(form)\n        except UserNotFound as e:\n            if e.args and e.args[0]:\n                form.add_error(None, e.args[0].encode('utf-8'))\n            else:\n                form.add_error(None, self.user_not_found_error)\n            return self.form_invalid(form)\n\n        # log user address:\n        address = Address.objects.get_or_create(address=self.request.META['REMOTE_ADDR'])[0]\n        # TODO: this is still an int in the db\n        UserAddresses.objects.create(address=address, user=user, purpose=self.purpose)\n\n        # Send confirmation email to the user\n        key, kwargs = confirm(self.request, user, purpose=self.purpose, payload=payload)\n        if settings.BROKER_URL is None:\n            key.send(**kwargs)\n        else:\n            send_email.delay(key_id=key.pk, **kwargs)\n\n        return super(ConfirmationMixin, self).form_valid(form)\nxmpp_accounts/constants.py\nPURPOSE_DELETE = 'delete'\nxmpp_accounts/forms.py\nclass ResetPasswordConfirmationForm(PasswordConfirmationMixin, AntiSpamForm):\n    password = XMPPAccountPasswordField()\nxmpp_accounts/forms.py\nclass RegistrationConfirmationForm(PasswordConfirmationMixin, AntiSpamForm):\n    password = XMPPAccountPasswordField()\nxmpp_accounts/mixins.py\nclass AntiSpamMixin(object):\n    def dispatch(self, request, *args, **kwargs):\n        remote_ip = get_client_ip(request)\n\n        if settings.DEBUG is False and remote_ip not in settings.RATELIMIT_WHITELIST:\n            # create a dummy function and dynamically set its name. This way,\n            # the ratelimit decorator is specific to the method in each class.\n            def func(request):\n                pass\n            func.__name__ = str('%s_dispatch' % self.__class__.__name__)\n            func = ratelimit(method='POST', rate='15/m')(func)\n            ratelimit(method='GET', rate='40/m')(func)(request)\n\n            if getattr(request, 'limited', False):\n                raise RateException()\n\n        # We sometimes get requests *without* a user agent. We assume these are automated requests.\n        if not request.META.get('HTTP_USER_AGENT'):\n            raise SpamException(\"No user agent passed.\")\n\n        return super(AntiSpamMixin, self).dispatch(request, *args, **kwargs)\nxmpp_accounts/forms.py\nclass DeleteConfirmationForm(AntiSpamForm):\n    password = XMPPAccountPasswordField()\nxmpp_accounts/forms.py\nclass DeleteForm(AntiSpamForm):\n    username = XMPPAccountJIDField()\n    password = XMPPAccountPasswordField()\nxmpp_accounts/forms.py\nclass ResetEmailConfirmationForm(AntiSpamForm):\n    password = XMPPAccountPasswordField()\nxmpp_accounts/constants.py\nPURPOSE_SET_EMAIL = 'email'\nxmpp_accounts/forms.py\nclass ResetEmailForm(GPGMixin, AntiSpamForm):\n    username = XMPPAccountJIDField()\n    email = XMPPAccountEmailField(label=_('New email address'))\n    password = XMPPAccountPasswordField()\n\n    def clean(self):\n        data = super(ResetEmailForm, self).clean()\n        username = data['username']\n        password = data['password']\n        node, domain = username.split('@', 1)\n        if not backend.check_password(username=node, domain=domain, password=password):\n            self.add_error('password', _('Password incorrect.'))\nxmpp_accounts/mixins.py\nclass ConfirmedMixin(object):\n    user = None\n\n    def get_template_names(self):\n        return ['xmpp_accounts/%s/confirm.html' % self.purpose]\n\n    def dispatch(self, request, *args, **kwargs):\n        if request.META.get('HTTP_USER_AGENT', '').startswith('Twitterbot'):\n            return HttpResponseRedirect(reverse('xmpp_accounts:%s' % self.purpose))\n        return super(ConfirmedMixin, self).dispatch(request, *args, **kwargs)\n\n    def after_delete(self, user, form):\n        pass\n\n    def get_context_data(self, **kwargs):\n        context = super(ConfirmedMixin, self).get_context_data(**kwargs)\n        if self.user is not None:\n            context['username'] = self.user.node\n            context['domain'] = self.user.domain\n            context['jid'] = self.user.jid\n        return context\n\n    def form_valid(self, form):\n        try:\n            key = Confirmation.objects.valid().purpose(self.purpose).get(key=self.kwargs['key'])\n        except Confirmation.DoesNotExist:\n            form.add_error(None, _(\"Confirmation key expired or not found.\"))\n            return self.form_invalid(form)\n        self.user = key.user\n\n        try:\n            self.handle_key(key, self.user, form)\n            key.delete()\n            self.after_delete(self.user, form)\n        except UserNotFound as e:\n            if hasattr(e, 'message') and e.message:\n                form.add_error(None, _(\"User not found: %s\") % e.message)\n            else:\n                form.add_error(None, _(\"User not found!\"))\n            return self.form_invalid(form)\n        except UserExists:\n            form.add_error(None, _(\"User already exists!\"))\n            return self.form_invalid(form)\n\n        return super(ConfirmedMixin, self).form_valid(form)\nxmpp_accounts/constants.py\nREGISTRATION_WEBSITE = 0\nxmpp_accounts/constants.py\nPURPOSE_REGISTER = 'register'\ncore/exceptions.py\nclass RegistrationRateException(RateException):\n    \"\"\"Raised when the user exceeds rate for registrations.\"\"\"\nxmpp_accounts/forms.py\nclass RegistrationForm(GPGMixin, AntiSpamForm):\n    email = XMPPAccountEmailField()\n    username = XMPPAccountJIDField(register=True, help_text=\n        _('At least %(MIN_LENGTH)s and up to %(MAX_LENGTH)s characters. No \"@\" or spaces.') % {\n            'MIN_LENGTH': settings.MIN_USERNAME_LENGTH,\n            'MAX_LENGTH': settings.MAX_USERNAME_LENGTH,\n        }\n    )\n\n    def clean(self):\n        data = super(RegistrationForm, self).clean()\n\n        if data.get('username'):\n            node, domain = data['username'].split('@')\n            if User.objects.filter(jid=data['username']).exists() \\\n                    or backend.user_exists(username=node, domain=domain):\n                self.add_error('username', _(\"User already exists.\"))\n        return data\n", "answers": ["    form_class = RegistrationForm"], "length": 1292, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "dc61536f13d40f843c5651cf0c7057d8d1cfed4d72fafafa"}
{"input": "package com.dev.blogs.dao.impl;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport org.apache.commons.logging.Log;\r\nimport org.apache.commons.logging.LogFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.jdbc.support.GeneratedKeyHolder;\r\nimport org.springframework.jdbc.support.KeyHolder;\r\nimport org.springframework.stereotype.Component;\r\nimport com.dev.blogs.dao.ProviderDao;\r\nimport com.dev.blogs.jdbc.DeleteProvider;\r\nimport com.dev.blogs.jdbc.InsertItem;\r\nimport com.dev.blogs.jdbc.InsertItemProvider;\r\nimport com.dev.blogs.jdbc.InsertProvider;\r\nimport com.dev.blogs.jdbc.SelectAllProviders;\r\nimport com.dev.blogs.jdbc.SelectProviderById;\r\nimport com.dev.blogs.jdbc.UpdateProvider;\r\nimport com.dev.blogs.model.Item;\r\nimport com.dev.blogs.model.Provider;\r\n\r\n\r\n@Component\r\npublic class ProviderDaoImpl implements ProviderDao {\r\n\tprotected final Log logger = LogFactory.getLog(getClass());\r\n\t\r\n\t@Autowired\r\n\tprivate SelectAllProviders selectAllProviders;\r\n\t@Autowired\r\n\tprivate SelectProviderById selectProviderById;\r\n\t@Autowired\r\n\tprivate InsertProvider insertProvider;\r\n\t@Autowired\r", "context": "simple-spring-database/src/main/java/com/dev/blogs/jdbc/DeleteProvider.java\n@Component\r\npublic class DeleteProvider extends SqlUpdate {\r\n\tpublic static final String ID_PARAMETER = \"id\";\r\n\t\r\n\tprivate static final String PARAMETERIZED_SQL_DELETE_PROVDER = \"DELETE FROM \"\r\n\t\t\t+ Provider.TABLE_NAME\r\n\t\t\t+ \" WHERE \" + Provider.ID_COLUMN + \" = :\" + ID_PARAMETER;\r\n\t\r\n\t@Autowired\r\n\tprivate DataSource dataSource;\r\n\t\r\n\t@PostConstruct\r\n\tpublic void init() {\r\n\t\tsetDataSource(dataSource);\r\n\t\tsetSql(PARAMETERIZED_SQL_DELETE_PROVDER);\r\n\t\tdeclareParameter(new SqlParameter(ID_PARAMETER, Types.INTEGER));\r\n\t}\r\n}\nsimple-jdbc-database/src/main/java/com/dev/blogs/model/Item.java\npublic class Item {\r\n\tpublic static final String TABLE_NAME = \"items\";\r\n\tpublic static final String ID_COLUMN = \"id\";\r\n\tpublic static final String NAME_COLUMN = \"name\";\r\n\tpublic static final String WAREHOUSE_ID_COLUMN = \"warehouse_id\";\r\n\t\r\n\tprivate Long id;\r\n    private String name;\r\n    private Long warehouse_id;\r\n    private Set<Provider> providers = new HashSet<Provider>();\r\n \r\n    public Long getId() {\r\n        return id;\r\n    }\r\n \r\n    public void setId(Long id) {\r\n        this.id = id;\r\n    }\r\n \r\n    public String getName() {\r\n        return name;\r\n    }\r\n \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n \r\n    public Set<Provider> getProviders() {\r\n        return providers;\r\n    }\r\n \r\n    public void setProviders(Set<Provider> providers) {\r\n        this.providers = providers;\r\n    }\r\n    \r\n    public Long getWarehouse_id() {\r\n\t\treturn warehouse_id;\r\n\t}\r\n\r\n\tpublic void setWarehouse_id(Long warehouse_id) {\r\n\t\tthis.warehouse_id = warehouse_id;\r\n\t}\r\n\r\n\tpublic String toString() {\r\n    \treturn \"Item[id=\" + this.id + \", name=\" + this.name + \"]\";\r\n    }\r\n}\nsimple-spring-database/src/main/java/com/dev/blogs/jdbc/InsertItemProvider.java\n@Component\r\npublic class InsertItemProvider extends BatchSqlUpdate {\r\n\tpublic static final String TABLE_NAME = \"items_providers\";\r\n\tpublic static final String ITEM_ID_COLUMN = \"item_id\";\r\n\tpublic static final String PROVIDER_ID_COLUMN = \"provider_id\";\r\n\t\r\n\tpublic static final String ITEM_ID_PARAMETER = \"item_id\";\r\n\tpublic static final String PROVIDER_ID_PARAMETER = \"provider_id\";\r\n\t\r\n\tprivate static final String SQL_INSERT_ITEMS_PROVIDERS = \"INSERT INTO \" + TABLE_NAME\r\n\t\t\t+ \" (\" + ITEM_ID_COLUMN + \", \" + PROVIDER_ID_COLUMN + \")\"\r\n\t\t\t+ \" VALUES (:\" + ITEM_ID_PARAMETER + \", :\" + PROVIDER_ID_PARAMETER + \")\";\r\n\t\r\n\tprivate static final int BATCH_SIZE = 10;\r\n\t\r\n\t@Autowired\r\n\tprivate DataSource dataSource;\r\n\t\r\n\t@PostConstruct\r\n\tpublic void init() {\r\n\t\tsetDataSource(dataSource);\r\n\t\tsetSql(SQL_INSERT_ITEMS_PROVIDERS);\r\n\t\tsetBatchSize(BATCH_SIZE);\r\n\t\tdeclareParameter(new SqlParameter(ITEM_ID_PARAMETER, Types.INTEGER));\r\n\t\tdeclareParameter(new SqlParameter(PROVIDER_ID_PARAMETER, Types.INTEGER));\r\n\t}\r\n}\nsimple-spring-database/src/main/java/com/dev/blogs/jdbc/InsertItem.java\n@Component\r\npublic class InsertItem extends BatchSqlUpdate {\r\n\tpublic static final String NAME_PARAMETER = \"name\";\r\n\tprivate static final String SQL_INSERT_ITEMS = \"INSERT INTO \" + Item.TABLE_NAME\r\n\t\t\t+ \" (\" + Item.NAME_COLUMN + \")\"\r\n\t\t\t+ \" VALUES (:\" + NAME_PARAMETER + \")\";\r\n\tprivate static final int BATCH_SIZE = 10;\r\n\t\r\n\t@Autowired\r\n\tprivate DataSource dataSource;\r\n\t\r\n\t@PostConstruct\r\n\tpublic void init() {\r\n\t\tsetDataSource(dataSource);\r\n\t\tsetSql(SQL_INSERT_ITEMS);\r\n\t\tdeclareParameter(new SqlParameter(NAME_PARAMETER, Types.VARCHAR));\r\n\t\tsetBatchSize(BATCH_SIZE);\r\n\t\t// Объявляем имя столбца для которого СУРБД генерирует ключ\r\n\t\tsetGeneratedKeysColumnNames(new String[] { Item.ID_COLUMN });\r\n\t\t// Заставить лежащий в основе драйвер JDBC извлечь сгенерированный ключ\r\n\t\tsetReturnGeneratedKeys(true);\r\n\t}\r\n}\nsimple-spring-database/src/main/java/com/dev/blogs/jdbc/InsertProvider.java\n@Component\r\npublic class InsertProvider extends SqlUpdate {\r\n\tpublic static final String NAME_PARAMETER = \"name\";\r\n\t\r\n\tprivate static final String PARAMETERIZED_SQL_INSERT_PROVDER = \"INSERT INTO \"\r\n\t\t\t+ Provider.TABLE_NAME + \" (\" + Provider.NAME_COLUMN\r\n\t\t\t+ \") VALUES (:\" + NAME_PARAMETER + \")\";\t\r\n\t\r\n\t@Autowired\r\n\tprivate DataSource dataSource;\r\n\t\r\n\t@PostConstruct\r\n\tpublic void init() {\r\n\t\tsetDataSource(dataSource);\r\n\t\tsetSql(PARAMETERIZED_SQL_INSERT_PROVDER);\r\n\t\tdeclareParameter(new SqlParameter(NAME_PARAMETER, Types.VARCHAR));\r\n\t\t// Объявляем имя столбца для которого СУРБД генерирует ключ\r\n\t\tsetGeneratedKeysColumnNames(new String[] { Provider.ID_COLUMN });\r\n\t\t// Заставить лежащий в основе драйвер JDBC извлечь сгенерированный ключ\r\n\t\tsetReturnGeneratedKeys(true);\r\n\t}\r\n}\nsimple-spring-database/src/main/java/com/dev/blogs/model/Provider.java\npublic class Provider {\r\n\tpublic static final String TABLE_NAME = \"providers\";\r\n\t\r\n\tpublic static final String ID_COLUMN = \"id\";\r\n\tpublic static final String NAME_COLUMN = \"name\";\r\n\t\r\n\tprivate Long id;\r\n    private String name;\r\n    private Set<Item> items = new HashSet<Item>();\r\n \r\n    public Long getId() {\r\n        return id;\r\n    }\r\n \r\n    public void setId(Long id) {\r\n        this.id = id;\r\n    }\r\n \r\n    public String getName() {\r\n        return name;\r\n    }\r\n \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n \r\n    public Set<Item> getItems() {\r\n        return items;\r\n    }\r\n \r\n    public void setItems(Set<Item> items) {\r\n        this.items = items;\r\n    }\r\n    \r\n    public void addItem(Item item) {\r\n    \tif (items == null) {\r\n    \t\titems = new HashSet<Item>();\r\n    \t}\r\n    \titems.add(item);\r\n    }\r\n    \r\n    @Override\r\n    public boolean equals(Object obj) {\r\n    \tif (this == obj) return true;\r\n\t\tif (obj == null || getClass() != obj.getClass()) return false;\r\n\t\tProvider that = (Provider) obj;\r\n\t\tif (!name.equals(that.name)) return false;\r\n\t\treturn true;\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n    \treturn \"Provider[id=\" + this.id + \", name=\" + this.name + \"]\";\r\n    }\r\n}\nsimple-spring-database/src/main/java/com/dev/blogs/jdbc/UpdateProvider.java\n@Component\r\npublic class UpdateProvider extends SqlUpdate {\r\n\tpublic static final String ID_PARAMETER = \"id\";\r\n\tpublic static final String NAME_PARAMETER = \"name\";\r\n\t\r\n\tprivate static final String PARAMETERIZED_SQL_UPDATE_PROVIDER = \"UPDATE \"\r\n\t\t\t+ Provider.TABLE_NAME\r\n\t\t\t+ \" SET \" + Provider.NAME_COLUMN + \" = :\" + NAME_PARAMETER\r\n\t\t\t+ \" WHERE \" + Provider.ID_COLUMN + \" = :\" + ID_PARAMETER;\r\n\t\r\n\t@Autowired\r\n\tprivate DataSource dataSource;\r\n\t\r\n\t@PostConstruct\r\n\tpublic void init() {\r\n\t\tsetDataSource(dataSource);\r\n\t\tsetSql(PARAMETERIZED_SQL_UPDATE_PROVIDER);\r\n\t\tdeclareParameter(new SqlParameter(ID_PARAMETER, Types.INTEGER));\r\n\t\tdeclareParameter(new SqlParameter(NAME_PARAMETER, Types.VARCHAR));\r\n\t}\r\n}\nsimple-spring-database/src/main/java/com/dev/blogs/dao/ProviderDao.java\npublic interface ProviderDao {\r\n\tpublic List<Provider> findAll();\r\n\tpublic Provider findById(Long id);\r\n\tpublic Long insert(Provider provider);\r\n\tpublic Long insertWithItems(Provider provider);\r\n\tpublic void update(Provider provider);\r\n\tpublic void delete(Provider provider);\r\n}\nsimple-spring-database/src/main/java/com/dev/blogs/jdbc/SelectProviderById.java\n@Component\r\npublic class SelectProviderById extends MappingSqlQuery<Provider> {\r\n\tpublic static final String ID_PARAMETER = \"id\";\r\n\tprivate static final String SQL_SELECT_ALL_PROVIDERS_BY_ID = \"SELECT * FROM \" + Provider.TABLE_NAME + \" WHERE \" + Provider.ID_COLUMN + \" = :\" + ID_PARAMETER;\r\n\t\r\n\t@Autowired\r\n\tprivate DataSource dataSource;\r\n\r\n\t@PostConstruct\r\n\tpublic void init() {\r\n\t\tsetDataSource(dataSource);\r\n\t\tsetSql(SQL_SELECT_ALL_PROVIDERS_BY_ID);\r\n\t\tdeclareParameter(new SqlParameter(ID_PARAMETER, Types.INTEGER));\r\n\t}\r\n\r\n\t@Override\r\n\tprotected Provider mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n\t\tProvider provider = new Provider();\r\n\t\tprovider.setId(rs.getLong(Provider.ID_COLUMN));\r\n\t\tprovider.setName(rs.getString(Provider.NAME_COLUMN));\r\n\t\treturn provider;\r\n\t}\r\n}\nsimple-spring-database/src/main/java/com/dev/blogs/jdbc/SelectAllProviders.java\n@Component\r\npublic class SelectAllProviders extends MappingSqlQuery<Provider> {\r\n\tprivate static final String SQL_SELECT_ALL_PROVIDERS = \"SELECT * FROM \" + Provider.TABLE_NAME;\r\n\t\r\n\t@Autowired\r\n\tprivate DataSource dataSource;\r\n\r\n\t@PostConstruct\r\n\tpublic void init() {\r\n\t\tsetDataSource(dataSource);\r\n\t\tsetSql(SQL_SELECT_ALL_PROVIDERS);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected Provider mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n\t\tProvider provider = new Provider();\r\n\t\tprovider.setId(rs.getLong(Provider.ID_COLUMN));\r\n\t\tprovider.setName(rs.getString(Provider.NAME_COLUMN));\r\n\t\treturn provider;\r\n\t}\r\n}\n", "answers": ["\tprivate InsertItem insertItem;\r"], "length": 917, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "3cc7b1e8bb5e60cc54f7b53afb7dac2a38b2dea35ff9a17f"}
{"input": "import org.assertj.core.api.AbstractBigDecimalAssert;\nimport org.assertj.core.api.AbstractBigIntegerAssert;\nimport org.assertj.core.api.AbstractBooleanAssert;\nimport org.assertj.core.api.AbstractByteAssert;\nimport org.assertj.core.api.AbstractCharSequenceAssert;\nimport org.assertj.core.api.AbstractCharacterAssert;\nimport org.assertj.core.api.AbstractClassAssert;\nimport org.assertj.core.api.AbstractDateAssert;\nimport org.assertj.core.api.AbstractDoubleAssert;\nimport org.assertj.core.api.AbstractFileAssert;\nimport org.assertj.core.api.AbstractFloatAssert;\nimport org.assertj.core.api.AbstractFutureAssert;\nimport org.assertj.core.api.AbstractInputStreamAssert;\nimport org.assertj.core.api.AbstractInstantAssert;\nimport org.assertj.core.api.AbstractIntegerAssert;\nimport org.assertj.core.api.AbstractLocalDateAssert;\nimport org.assertj.core.api.AbstractLocalDateTimeAssert;\nimport org.assertj.core.api.AbstractLocalTimeAssert;\nimport org.assertj.core.api.AbstractLongAssert;\nimport org.assertj.core.api.AbstractObjectArrayAssert;\nimport org.assertj.core.api.AbstractObjectAssert;\nimport org.assertj.core.api.AbstractPathAssert;\nimport org.assertj.core.api.AbstractShortAssert;\nimport org.assertj.core.api.AbstractUriAssert;\nimport org.assertj.core.api.AbstractUrlAssert;\nimport org.assertj.core.api.AtomicBooleanAssert;\nimport org.assertj.core.api.AtomicIntegerArrayAssert;\nimport org.assertj.core.api.AtomicIntegerAssert;\nimport org.assertj.core.api.AtomicLongArrayAssert;\nimport org.assertj.core.api.AtomicLongAssert;\nimport org.assertj.core.api.CompletableFutureAssert;\nimport org.assertj.core.api.DoublePredicateAssert;\nimport org.assertj.core.api.IntPredicateAssert;\nimport org.assertj.core.api.IterableAssert;\nimport org.assertj.core.api.ListAssert;\nimport org.assertj.core.api.LongPredicateAssert;\nimport org.assertj.core.api.MapAssert;\nimport org.assertj.core.api.OptionalAssert;\nimport org.assertj.core.api.OptionalDoubleAssert;\nimport org.assertj.core.api.OptionalIntAssert;\nimport org.assertj.core.api.OptionalLongAssert;\nimport org.assertj.core.api.PredicateAssert;\nimport testasyouthink.GivenWhenThenDsl.PreparationStage.AndGiven;\nimport testasyouthink.GivenWhenThenDsl.PreparationStage.Given;\nimport testasyouthink.GivenWhenThenDsl.VerificationStage.Then;\nimport testasyouthink.GivenWhenThenDsl.VerificationStage.ThenFailure;\nimport testasyouthink.GivenWhenThenDsl.VerificationStage.ThenWithoutResult;\nimport testasyouthink.execution.Execution;\nimport testasyouthink.function.CheckedConsumer;\nimport testasyouthink.function.CheckedFunction;\nimport testasyouthink.function.CheckedRunnable;\nimport testasyouthink.function.CheckedSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedArraySupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedAtomicBooleanSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedAtomicIntegerArraySupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedAtomicIntegerSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedAtomicLongArraySupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedAtomicLongSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedBigDecimalSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedBigIntegerSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedBooleanSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedByteSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedCharSequenceSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedCharacterSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedClassSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedCompletableFutureSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedDateSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedDoublePredicateSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedDoubleSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedFileSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedFloatSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedFutureSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedInputStreamSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedInstantSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedIntPredicateSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedIntegerSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedIterableSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedIteratorSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedListSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedLocalDateSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedLocalDateTimeSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedLocalTimeSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedLongPredicateSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedLongSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedMapSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedOptionalDoubleSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedOptionalIntSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedOptionalLongSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedOptionalSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedPathSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedPredicateSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedShortSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedStringSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedUriSupplier;\nimport testasyouthink.function.CheckedSuppliers.CheckedUrlSupplier;\nimport testasyouthink.function.Functions;\nimport java.io.InputStream;\nimport java.util.concurrent.Future;\nimport static org.assertj.core.api.Assertions.assertThat;\n        return assertThat(result(whenStep));\n    }\n\n    public static <$Value> OptionalAssert<$Value> resultOf(CheckedOptionalSupplier<$Value> whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static OptionalIntAssert resultOf(CheckedOptionalIntSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static OptionalLongAssert resultOf(CheckedOptionalLongSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static OptionalDoubleAssert resultOf(CheckedOptionalDoubleSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractBooleanAssert<?> resultOf(CheckedBooleanSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractDateAssert<?> resultOf(CheckedDateSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractLocalDateAssert<?> resultOf(CheckedLocalDateSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractLocalDateTimeAssert<?> resultOf(CheckedLocalDateTimeSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractLocalTimeAssert<?> resultOf(CheckedLocalTimeSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractInstantAssert<?> resultOf(CheckedInstantSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractFileAssert<?> resultOf(CheckedFileSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractPathAssert<?> resultOf(CheckedPathSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractUriAssert<?> resultOf(CheckedUriSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractUrlAssert<?> resultOf(CheckedUrlSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static <$Element> IterableAssert<$Element> resultOf(CheckedIterableSupplier<$Element> whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static <$Element> IterableAssert<$Element> resultOf(CheckedIteratorSupplier<$Element> whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static <$Element> ListAssert<$Element> resultOf(CheckedListSupplier<$Element> whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static <$Key, $Value> MapAssert<$Key, $Value> resultOf(CheckedMapSupplier<$Key, $Value> whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AtomicBooleanAssert resultOf(CheckedAtomicBooleanSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AtomicIntegerAssert resultOf(CheckedAtomicIntegerSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AtomicIntegerArrayAssert resultOf(CheckedAtomicIntegerArraySupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AtomicLongAssert resultOf(CheckedAtomicLongSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AtomicLongArrayAssert resultOf(CheckedAtomicLongArraySupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static <$Value> AbstractFutureAssert<?, ? extends Future<? extends $Value>, $Value> resultOf(\n            CheckedFutureSupplier<$Value> whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static <$Value> CompletableFutureAssert<$Value> resultOf(CheckedCompletableFutureSupplier<$Value> whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static AbstractClassAssert<?> resultOf(CheckedClassSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static <$Value> PredicateAssert<$Value> resultOf(CheckedPredicateSupplier<$Value> whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static IntPredicateAssert resultOf(CheckedIntPredicateSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n\n    public static LongPredicateAssert resultOf(CheckedLongPredicateSupplier whenStep) {\n        return assertThat(result(whenStep));\n    }\n", "context": "test-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedAtomicLongArraySupplier extends CheckedSupplier<AtomicLongArray> {}\ntest-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface AndGiven<$SystemUnderTest> extends GivenArgument<$SystemUnderTest>, When<$SystemUnderTest> {\n\n    AndGiven<$SystemUnderTest> and(String fixtureSpecification, CheckedRunnable givenStep);\n\n    AndGiven<$SystemUnderTest> and(String fixtureSpecification, CheckedConsumer<$SystemUnderTest> givenStep);\n}\ntest-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface ThenWithoutResult<$SystemUnderTest> {\n\n    AndThenWithoutResult<$SystemUnderTest> then(CheckedRunnable thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> then(String expectationSpecification, CheckedRunnable thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> then(CheckedConsumer<$SystemUnderTest> thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> then(String expectationSpecification,\n            CheckedConsumer<$SystemUnderTest> thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> then(CheckedBooleanSupplier thenStep);\n\n    AndThenWithoutResult<$SystemUnderTest> thenSutRepliesWithin(long timeLimit);\n\n    AndThenWithoutResult<$SystemUnderTest> thenSutRepliesWithin(Duration durationLimit);\n\n    void thenItSucceeds();\n\n    AndThenWithoutResultStandardOutputCaptured<$SystemUnderTest> thenStandardOutput(\n            CheckedConsumer<File> thenStep);\n\n    AndThenWithoutResultStandardOutputCaptured<$SystemUnderTest> thenStandardOutput(\n            String expectationSpecification, CheckedConsumer<File> thenStep);\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedFileSupplier extends CheckedSupplier<File> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedListSupplier<$Element> extends CheckedSupplier<List<$Element>> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedOptionalSupplier<$Value> extends CheckedSupplier<Optional<$Value>> {}\ntest-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface ThenFailure {\n\n    AndThenFailure thenItFails();\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedLongSupplier extends CheckedSupplier<Long> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedOptionalIntSupplier extends CheckedSupplier<OptionalInt> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedCompletableFutureSupplier<$Value> extends CheckedSupplier<CompletableFuture<$Value>> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedAtomicLongSupplier extends CheckedSupplier<AtomicLong> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedRunnable.java\n@FunctionalInterface\npublic interface CheckedRunnable {\n\n    void run() throws Throwable;\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedCharacterSupplier extends CheckedSupplier<Character> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedDoublePredicateSupplier extends CheckedSupplier<DoublePredicate> {}\ntest-as-you-think-core/src/main/java/testasyouthink/execution/Execution.java\npublic class Execution<$SystemUnderTest, $Result> {\n\n    public static final String EXECUTION_FAILURE_MESSAGE = \"Fails to execute the target method \" //\n            + \"of the system under test because of an unexpected failure!\";\n    private static final Functions FUNCTIONS = Functions.INSTANCE;\n    private final Event<$SystemUnderTest, $Result> event;\n\n    public Execution(Supplier<$SystemUnderTest> givenSutStep, CheckedFunction<$SystemUnderTest, $Result> whenStep) {\n        event = new Event<>(givenSutStep, whenStep);\n    }\n\n    public Execution(Supplier<$SystemUnderTest> givenSutStep, CheckedConsumer<$SystemUnderTest> whenStep) {\n        event = new Event<>(givenSutStep, FUNCTIONS.toFunction(whenStep));\n    }\n\n    public static <$Result> Execution<Void, $Result> of(CheckedSupplier<$Result> whenStep) {\n        return new Execution<>(noExplicitSut(), FUNCTIONS.toCheckedFunction(whenStep));\n    }\n\n    public static <$Element> Execution<Void, $Element[]> of(CheckedArraySupplier<$Element> whenStep) {\n        return new Execution<>(noExplicitSut(), FUNCTIONS.toCheckedFunction(whenStep));\n    }\n\n    private static Supplier<Void> noExplicitSut() {\n        return () -> null;\n    }\n\n    public Optional<$Result> run() {\n        try {\n            return Optional.ofNullable(event.happen());\n        } catch (PreparationError preparationError) {\n            throw preparationError;\n        } catch (Throwable throwable) {\n            throw new ExecutionError(EXECUTION_FAILURE_MESSAGE, throwable);\n        }\n    }\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedIteratorSupplier<$Element> extends CheckedSupplier<Iterator<$Element>> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedStringSupplier extends CheckedSupplier<String> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedDateSupplier extends CheckedSupplier<Date> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedDoubleSupplier extends CheckedSupplier<Double> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedLocalTimeSupplier extends CheckedSupplier<LocalTime> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedCharSequenceSupplier extends CheckedSupplier<CharSequence> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedConsumer.java\n@FunctionalInterface\npublic interface CheckedConsumer<T> {\n\n    void accept(T t) throws Throwable;\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSupplier.java\npublic interface CheckedSupplier<R> {\n\n    R get() throws Throwable;\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedOptionalLongSupplier extends CheckedSupplier<OptionalLong> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedByteSupplier extends CheckedSupplier<Byte> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedAtomicIntegerSupplier extends CheckedSupplier<AtomicInteger> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedInstantSupplier extends CheckedSupplier<Instant> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedUrlSupplier extends CheckedSupplier<URL> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedIterableSupplier<$Element> extends CheckedSupplier<Iterable<$Element>> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedBooleanSupplier extends CheckedSupplier<Boolean> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedOptionalDoubleSupplier extends CheckedSupplier<OptionalDouble> {}\ntest-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface Given<$SystemUnderTest> extends GivenArgument<$SystemUnderTest>, When<$SystemUnderTest> {\n\n    AndGiven<$SystemUnderTest> given(CheckedRunnable givenStep);\n\n    AndGiven<$SystemUnderTest> given(CheckedConsumer<$SystemUnderTest> givenStep);\n\n    AndGiven<$SystemUnderTest> given(String fixtureSpecification, CheckedRunnable givenStep);\n\n    AndGiven<$SystemUnderTest> given(String fixtureSpecification, CheckedConsumer<$SystemUnderTest> givenStep);\n}\ntest-as-you-think-core/src/main/java/testasyouthink/GivenWhenThenDsl.java\ninterface Then<$SystemUnderTest, $Result> {\n\n    AndThen<$SystemUnderTest, $Result> then(CheckedConsumer<$Result> thenStep);\n\n    AndThen<$SystemUnderTest, $Result> then(String expectationSpecification, CheckedConsumer<$Result> thenStep);\n\n    AndThen<$SystemUnderTest, $Result> then(CheckedRunnable thenStep);\n\n    AndThen<$SystemUnderTest, $Result> then(String expectationSpecification, CheckedRunnable thenStep);\n\n    AndThen<$SystemUnderTest, $Result> then(CheckedPredicate<$Result> thenStep);\n\n    AndThen<$SystemUnderTest, $Result> thenSutRepliesWithin(long timeLimit);\n\n    AndThen<$SystemUnderTest, $Result> thenSutRepliesWithin(Duration durationLimit);\n\n    void then(List<CheckedPredicate<$Result>> thenSteps);\n\n    void then(CheckedConsumer<$Result> thenStepAboutResult,\n            CheckedConsumer<$SystemUnderTest> thenStepAboutSystemUnderTest);\n\n    void then(CheckedPredicate<$Result> thenStepAboutResult,\n            CheckedPredicate<$SystemUnderTest> thenStepAboutSystemUnderTest);\n\n    AndThenStandardOutputCaptured<$SystemUnderTest, $Result> thenStandardOutput(CheckedConsumer<File> thenStep);\n\n    AndThenStandardOutputCaptured<$SystemUnderTest, $Result> thenStandardOutput(String expectationSpecification,\n            CheckedConsumer<File> thenStep);\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedFloatSupplier extends CheckedSupplier<Float> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedAtomicIntegerArraySupplier extends CheckedSupplier<AtomicIntegerArray> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedPredicateSupplier<$Value> extends CheckedSupplier<Predicate<$Value>> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedFutureSupplier<$Value> extends CheckedSupplier<Future<$Value>> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedInputStreamSupplier extends CheckedSupplier<InputStream> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedPathSupplier extends CheckedSupplier<Path> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedIntegerSupplier extends CheckedSupplier<Integer> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedLongPredicateSupplier extends CheckedSupplier<LongPredicate> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedShortSupplier extends CheckedSupplier<Short> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedLocalDateSupplier extends CheckedSupplier<LocalDate> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedLocalDateTimeSupplier extends CheckedSupplier<LocalDateTime> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedArraySupplier<R> {\n\n    R[] get() throws Throwable;\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedBigIntegerSupplier extends CheckedSupplier<BigInteger> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedMapSupplier<$Key, $Value> extends CheckedSupplier<Map<$Key, $Value>> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedUriSupplier extends CheckedSupplier<URI> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/Functions.java\npublic enum Functions {\n\n    INSTANCE;\n\n    public <T> Consumer<T> toConsumer(Runnable runnable) {\n        return toBeConsumed -> runnable.run();\n    }\n\n    public CheckedConsumer<Void> toCheckedConsumer(CheckedRunnable runnable) {\n        return toBeConsumed -> runnable.run();\n    }\n\n    public <T, R> CheckedFunction<T, R> toFunction(CheckedConsumer<T> checkedConsumer) {\n        return toBeConsumed -> {\n            checkedConsumer.accept(toBeConsumed);\n            return null;\n        };\n    }\n\n    public <R> CheckedFunction<Void, R> toCheckedFunction(CheckedSupplier<R> supplier) {\n        return Void -> supplier.get();\n    }\n\n    public <R> CheckedFunction<Void, R[]> toCheckedFunction(CheckedArraySupplier<R> supplier) {\n        return Void -> supplier.get();\n    }\n\n    public <T> CheckedFunction<T, Throwable> toFunctionWithThrowableAsResult(CheckedConsumer<T> checkedConsumer) {\n        return toBeConsumed -> {\n            Throwable result = null;\n            try {\n                checkedConsumer.accept(toBeConsumed);\n            } catch (Throwable thrown) {\n                result = thrown;\n            }\n            return result;\n        };\n    }\n\n    public CheckedFunction<Void, Throwable> toFunctionWithThrowableAsResult(CheckedRunnable whenStep) {\n        return Void -> {\n            try {\n                whenStep.run();\n            } catch (Throwable thrown) {\n                return thrown;\n            }\n            return null;\n        };\n    }\n\n    public <$Value> CheckedSupplier<$Value> toCheckedSupplier($Value value) {\n        return () -> value;\n    }\n\n    public <$Target, $Argument, $Result> CheckedFunction<$Target, $Result> toFunction(\n            CheckedBiFunction<$Target, $Argument, $Result> biFunction, Queue<Supplier> arguments) {\n        return target -> biFunction.apply(target, ($Argument) arguments\n                .remove()\n                .get());\n    }\n\n    public <$Target, $Argument1, $Argument2, $Result> CheckedFunction<$Target, $Result> toFunction(\n            CheckedTriFunction<$Target, $Argument1, $Argument2, $Result> triFunction, Queue<Supplier> arguments) {\n        return toFunction(toBiFunction(triFunction, arguments), arguments);\n    }\n\n    public <$Target, $Argument1, $Argument2, $Argument3, $Result> CheckedFunction<$Target, $Result> toFunction(\n            CheckedQuadriFunction<$Target, $Argument1, $Argument2, $Argument3, $Result> quadriFunction,\n            Queue<Supplier> arguments) {\n        return toFunction(toBiFunction(toTriFunction(quadriFunction, arguments), arguments), arguments);\n    }\n\n    public <$Target, $Argument> CheckedConsumer<$Target> toConsumer(CheckedBiConsumer<$Target, $Argument> biConsumer,\n            Queue<Supplier> arguments) {\n        return target -> biConsumer.accept(target, ($Argument) arguments\n                .remove()\n                .get());\n    }\n\n    public <$Target, $Argument1, $Argument2> CheckedConsumer<$Target> toConsumer(\n            CheckedTriConsumer<$Target, $Argument1, $Argument2> triConsumer, Queue<Supplier> arguments) {\n        return toConsumer(toBiConsumer(triConsumer, arguments), arguments);\n    }\n\n    public <$Target, $Argument1, $Argument2, $Argument3> CheckedConsumer<$Target> toConsumer(\n            CheckedQuadriConsumer<$Target, $Argument1, $Argument2, $Argument3> quadriConsumer,\n            Queue<Supplier> arguments) {\n        return toConsumer(toBiConsumer(toTriConsumer(quadriConsumer, arguments), arguments), arguments);\n    }\n\n    static class ConsumerUnitTransformation {\n\n        static <$Target, $Argument1, $Argument2> CheckedBiConsumer<$Target, $Argument1> toBiConsumer(\n                CheckedTriConsumer<$Target, $Argument1, $Argument2> triConsumer, Queue<Supplier> arguments) {\n            return (target, argument1) -> triConsumer.accept(target, argument1, ($Argument2) arguments\n                    .remove()\n                    .get());\n        }\n\n        static <$Target, $Argument1, $Argument2, $Argument3> CheckedTriConsumer<$Target, $Argument1, $Argument2>\n        toTriConsumer(\n                CheckedQuadriConsumer<$Target, $Argument1, $Argument2, $Argument3> quadriConsumer,\n                Queue<Supplier> arguments) {\n            return (target, argument1, argument2) -> quadriConsumer.accept(target, argument1, argument2,\n                    ($Argument3) arguments\n                            .remove()\n                            .get());\n        }\n    }\n\n    static class FunctionUnitTransformation {\n\n        static <$Target, $Argument1, $Argument2, $Result> CheckedBiFunction<$Target, $Argument1, $Result> toBiFunction(\n                CheckedTriFunction<$Target, $Argument1, $Argument2, $Result> triFunction, Queue<Supplier> arguments) {\n            return (target, argument1) -> triFunction.apply(target, argument1, ($Argument2) arguments\n                    .remove()\n                    .get());\n        }\n\n        static <$Target, $Argument1, $Argument2, $Argument3, $Result> CheckedTriFunction<$Target, $Argument1,\n                $Argument2, $Result> toTriFunction(\n                CheckedQuadriFunction<$Target, $Argument1, $Argument2, $Argument3, $Result> quadriFunction,\n                Queue<Supplier> arguments) {\n            return (target, argument1, argument2) -> quadriFunction.apply(target, argument1, argument2,\n                    ($Argument3) arguments\n                            .remove()\n                            .get());\n        }\n    }\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedClassSupplier extends CheckedSupplier<Class> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedFunction.java\n@FunctionalInterface\npublic interface CheckedFunction<T, R> {\n\n    R apply(T t) throws Throwable;\n}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedBigDecimalSupplier extends CheckedSupplier<BigDecimal> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedIntPredicateSupplier extends CheckedSupplier<IntPredicate> {}\ntest-as-you-think-core/src/main/java/testasyouthink/function/CheckedSuppliers.java\ninterface CheckedAtomicBooleanSupplier extends CheckedSupplier<AtomicBoolean> {}\n", "answers": ["    public static DoublePredicateAssert resultOf(CheckedDoublePredicateSupplier whenStep) {"], "length": 1467, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "691073ae373f94981965a86263715485057df4c64956fce7"}
{"input": "import logging\nimport operator\nimport pytest\nfrom bloop.conditions import ConditionRenderer\nfrom bloop.exceptions import InvalidModel, InvalidStream\nfrom bloop.models import (\n    BaseModel,\n    Column,\n    GlobalSecondaryIndex,\n    IMeta,\n    Index,\n    LocalSecondaryIndex,\n    bind_column,\n    bind_index,\n    model_created,\n    object_modified,\n    unbind,\n    unpack_from_dynamodb,\n)\nfrom bloop.types import (\n    UUID,\n    Boolean,\n    DateTime,\n    Integer,\n    String,\n    Timestamp,\n    Type,\n)\nfrom ..helpers.models import User, VectorModel\n\n\n\n\n\noperations = [\n    (operator.ne, \"!=\"),\n    (operator.eq, \"==\"),\n    (operator.lt, \"<\"),\n    (operator.le, \"<=\"),\n    (operator.gt, \">\"),\n    (operator.ge, \">=\")\n]\n\n\n@pytest.fixture\ndef unpack_kwargs(engine):\n    return {\n        \"attrs\": {\"name\": {\"S\": \"numberoverzero\"}},\n        \"expected\": {User.name, User.joined},\n        \"model\": User,\n        \"engine\": engine,\n        \"context\": {\"engine\": engine, \"extra\": \"foo\"},\n    }\n\n\n# BASE MODEL =============================================================================================== BASE MODEL\n\n\ndef test_default_model_init():\n    \"\"\"Missing attributes are set to `None`\"\"\"\n    user = User(id=\"user_id\", email=\"user@domain.com\")\n    assert user.id == \"user_id\"\n    assert user.email == \"user@domain.com\"\n    assert not hasattr(user, \"name\")\n\n\ndef test_load_default_init(engine):\n    \"\"\"The default model loader uses cls.__new__(cls) method\"\"\"\n    init_called = False\n\n", "context": "bloop/types.py\nclass Boolean(Type):\n    python_type = bool\n    backing_type = BOOLEAN\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\nbloop/models.py\nclass IMeta:\nclass BaseModel:\n    class Meta(IMeta):\nclass Index:\nclass GlobalSecondaryIndex(Index):\nclass LocalSecondaryIndex(Index):\nclass Column(ComparisonMixin):\n    class UNBOUND:\n        class Meta(IMeta):\n    def __init__(self, **attrs):\n    def __init_subclass__(cls: type, **kwargs):\n    def __repr__(self):\n    def __init__(self, *, projection, hash_key=None, range_key=None, dynamo_name=None, **kwargs):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\n    def hash_key(self):\n    def range_key(self):\n    def keys(self):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __init__(\n            self, *, projection,\n            hash_key, range_key=None,\n            read_units=None, write_units=None,\n            dynamo_name=None, **kwargs):\n    def __init__(self, *, projection, range_key, dynamo_name=None, strict=True, **kwargs):\n    def hash_key(self):\n    def read_units(self):\n    def read_units(self, value):\n    def write_units(self):\n    def write_units(self, value):\n    def __init__(self, typedef, hash_key=False, range_key=False, dynamo_name=None, default=missing):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\ndef subclassof(obj, classinfo):\ndef instanceof(obj, classinfo):\ndef loaded_columns(obj: BaseModel):\ndef unpack_from_dynamodb(*, attrs, expected, model=None, obj=None, engine=None, context=None, **kwargs):\ndef validate_projection(projection):\ndef validate_stream(meta):\ndef validate_encryption(meta):\ndef validate_backups(meta):\ndef validate_billing(meta):\ndef validate_ttl(meta):\ndef unbound_repr(obj):\ndef setdefault(obj, field, default):\ndef ensure_hash(cls) -> None:\ndef initialize_meta(cls: type):\ndef bind_column(model, name, column, force=False, recursive=False, copy=False) -> Column:\ndef bind_index(model, name, index, force=False, recursive=True, copy=False) -> Index:\ndef refresh_index(meta, index) -> None:\ndef unbind(meta, name=None, dynamo_name=None) -> None:\nbloop/types.py\nclass Integer(Number):\n    \"\"\"Truncates values when loading or dumping.\n\n    For example, ``3.14`` in DynamoDB is loaded as ``3``. If a value is ``7.5``\n    locally, it's stored in DynamoDB as ``7``.\n    \"\"\"\n    python_type = int\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        number = super().dynamo_load(value, context=context, **kwargs)\n        return int(number)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = int(value)\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/exceptions.py\nclass InvalidModel(BloopException, ValueError):\n    \"\"\"This is not a valid Model.\"\"\"\nbloop/types.py\nclass DateTime(String):\n    \"\"\"Always stored in DynamoDB using the :data:`~bloop.types.FIXED_ISO8601_FORMAT` format.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(DateTime)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import DateTime  # becomes:\n            from bloop.ext.pendulum import DateTime\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        dt = datetime.datetime.strptime(value, FIXED_ISO8601_FORMAT)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return dt.replace(tzinfo=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        dt = value.astimezone(tz=datetime.timezone.utc)\n        return dt.strftime(FIXED_ISO8601_FORMAT)\nbloop/exceptions.py\nclass InvalidStream(BloopException, ValueError):\n    \"\"\"This is not a valid stream definition.\"\"\"\nbloop/types.py\nclass UUID(String):\n    python_type = uuid.UUID\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return uuid.UUID(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return str(value)\ntests/helpers/models.py\nclass VectorModel(BaseModel):\n    name = Column(String, hash_key=True)\n    list_str = Column(List(String))\n    set_str = Column(Set(String))\n    map_nested = Column(Map(**{\n        \"bytes\": Binary,\n        \"str\": String,\n        \"map\": Map(**{\n            \"int\": Integer,\n            \"str\": String\n        })\n    }))\n    some_int = Column(Integer)\n    some_bytes = Column(Binary)\nbloop/types.py\nclass Type:\n    \"\"\"Abstract base type.\"\"\"\n\n    python_type = None\n    backing_type = None\n\n    def supports_operation(self, operation: str) -> bool:\n        \"\"\"\n        Used to ensure a conditional operation is supported by this type.\n\n        By default, uses a hardcoded table of operations that maps to each backing DynamoDB type.\n\n        You can override this method to implement your own conditional operators, or to dynamically\n        adjust which operations your type supports.\n        \"\"\"\n        return operation in OPERATION_SUPPORT_BY_TYPE[self.backing_type]\n\n    def __init__(self):\n        if not hasattr(self, \"inner_typedef\"):\n            self.inner_typedef = self\n        super().__init__()\n\n    def __getitem__(self, key):\n        raise RuntimeError(f\"{self!r} does not support document paths\")\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        \"\"\"Converts a local value into a DynamoDB value.\n\n        For example, to store a string enum as an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors.index(value.lower())\n        \"\"\"\n        raise NotImplementedError\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        \"\"\"Converts a DynamoDB value into a local value.\n\n        For example, to load a string enum from an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors[value]\n        \"\"\"\n        raise NotImplementedError\n\n    def _dump(self, value, **kwargs):\n        \"\"\"Entry point for serializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_dump`.\n\n        This wraps the return value of :func:`~bloop.types.Type.dynamo_dump` in DynamoDB's wire format.\n        For example, serializing a string enum to an int:\n\n        .. code-block:: python\n\n            value = \"green\"\n            # dynamo_dump(\"green\") = 2\n            _dump(value) == {\"N\": 2}\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_dump`.  This can happen when dumping eg. a sparse\n        :class:`~.bloop.types.Map`, or a missing (not set) value.\n        \"\"\"\n        wrapped = actions.wrap(value)\n        value = self.dynamo_dump(wrapped.value, **kwargs)\n        if value is None:\n            return actions.wrap(None)\n        else:\n            value = {self.backing_type: value}\n            return wrapped.type.new_action(value)\n\n    def _load(self, value, **kwargs):\n        \"\"\"Entry point for deserializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_load`.\n\n        This unpacks DynamoDB's wire format and calls :func:`~bloop.types.Type.dynamo_load` on the inner value.\n        For example, deserializing an int to a string enum:\n\n        .. code-block:: python\n\n            value = {\"N\": 2}\n            # dynamo_load(2) = \"green\"\n            _load(value) == \"green\"\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_load`.  This can happen when loading eg. a sparse :class:`~bloop.types.Map`.\n        \"\"\"\n        if value is not None:\n            value = next(iter(value.values()))\n        return self.dynamo_load(value, **kwargs)\n\n    def __repr__(self):\n        # Render class python types by name\n        python_type = self.python_type\n        if isinstance(python_type, type):\n            python_type = python_type.__name__\n\n        return \"<{}[{}:{}]>\".format(\n            self.__class__.__name__,\n            self.backing_type, python_type\n        )\ntests/helpers/models.py\nclass User(BaseModel):\n    id = Column(String, hash_key=True)\n    age = Column(Integer)\n    name = Column(String)\n    email = Column(String)\n    joined = Column(DateTime, dynamo_name=\"j\")\n    by_email = GlobalSecondaryIndex(hash_key=\"email\", projection=\"all\")\nbloop/types.py\nclass Timestamp(Integer):\n    \"\"\"Stores the unix (epoch) time in seconds.  Milliseconds are truncated to 0 on load and save.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(Timestamp)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import Timestamp  # becomes:\n            from bloop.ext.pendulum import Timestamp\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = super().dynamo_load(value, context=context, **kwargs)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return datetime.datetime.fromtimestamp(value, tz=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        value = value.timestamp()\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/conditions.py\nclass ConditionRenderer:\n    # noinspection PyUnresolvedReferences\n    \"\"\"Renders collections of :class:`~bloop.conditions.BaseCondition` into DynamoDB's wire format for expressions,\n    including:\n\n    * ``\"ConditionExpression\"`` -- used in conditional operations\n    * ``\"FilterExpression\"`` -- used in queries and scans to ignore results that don't match the filter\n    * ``\"KeyConditionExpressions\"`` -- used to describe a query's hash (and range) key(s)\n    * ``\"ProjectionExpression\"`` -- used to include a subset of possible columns in the results of a query or scan\n    * ``\"UpdateExpression\"`` -- used to save objects\n\n    Normally, you will only need to call :func:`~bloop.conditions.ConditionRenderer.render` to handle any combination\n    of conditions.  You can also call each individual ``render_*`` function to control how multiple conditions of\n    each type are applied.\n\n    You can collect the rendered condition at any time through :attr:`~bloop.conditions.ConditionRenderer.rendered`.\n\n    .. code-block:: python\n\n        >>> renderer.render(obj=user, atomic=True)\n        >>> renderer.output\n        {'ConditionExpression': '((#n0 = :v1) AND (attribute_not_exists(#n2)) AND (#n4 = :v5))',\n         'ExpressionAttributeNames': {'#n0': 'age', '#n2': 'email', '#n4': 'id'},\n         'ExpressionAttributeValues': {':v1': {'N': '3'}, ':v5': {'S': 'some-user-id'}}}\n\n\n    :param engine: Used to dump values in conditions into the appropriate wire format.\n    :type engine: :class:`~bloop.engine.Engine`\n    \"\"\"\n    def __init__(self, engine):\n        self.refs = ReferenceTracker(engine)\n        self.engine = engine\n        self.expressions = {}\n\n    def render(self, obj=None, condition=None, update=False, filter=None, projection=None, key=None):\n        \"\"\"Main entry point for rendering multiple expressions.  All parameters are optional, except obj when\n        atomic or update are True.\n\n        :param obj: *(Optional)* An object to render an atomic condition or update expression for.  Required if\n            update or atomic are true.  Default is False.\n        :param condition: *(Optional)* Rendered as a \"ConditionExpression\" for a conditional operation.\n            If atomic is True, the two are rendered in an AND condition.  Default is None.\n        :type condition: :class:`~bloop.conditions.BaseCondition`\n        :param bool update: *(Optional)*  True if an \"UpdateExpression\" should be rendered for ``obj``.\n            Default is False.\n        :param filter: *(Optional)* A filter condition for a query or scan, rendered as a \"FilterExpression\".\n            Default is None.\n        :type filter: :class:`~bloop.conditions.BaseCondition`\n        :param projection: *(Optional)* A set of Columns to include in a query or scan, rendered as a\n            \"ProjectionExpression\".  Default is None.\n        :type projection: set :class:`~bloop.models.Column`\n        :param key: *(Optional)* A key condition for queries, rendered as a \"KeyConditionExpression\".  Default is None.\n        :type key: :class:`~bloop.conditions.BaseCondition`\n        \"\"\"\n        if update and not obj:\n            raise InvalidCondition(\"An object is required to render updates.\")\n\n        if filter:\n            self.filter_expression(filter)\n\n        if projection:\n            self.projection_expression(projection)\n\n        if key:\n            self.key_expression(key)\n\n        # Condition requires a bit of work, because either one can be empty/false\n        if condition:\n            self.condition_expression(condition)\n\n        if update:\n            self.update_expression(obj)\n\n    def condition_expression(self, condition):\n        self.expressions[\"ConditionExpression\"] = condition.render(self)\n\n    def filter_expression(self, condition):\n        self.expressions[\"FilterExpression\"] = condition.render(self)\n\n    def key_expression(self, condition):\n        self.expressions[\"KeyConditionExpression\"] = condition.render(self)\n\n    def projection_expression(self, columns):\n        included = set()\n        ref_names = []\n        for column in columns:\n            if column in included:\n                continue\n            included.add(column)\n            ref = self.refs.any_ref(column=column)\n            ref_names.append(ref.name)\n        self.expressions[\"ProjectionExpression\"] = \", \".join(ref_names)\n\n    def update_expression(self, obj):\n        updates = {\n            ActionType.Add: [],\n            ActionType.Delete: [],\n            ActionType.Remove: [],\n            ActionType.Set: [],\n        }\n        for column in sorted(\n                # Don't include key columns in an UpdateExpression\n                filter(lambda c: c not in obj.Meta.keys, global_tracking[obj]),\n                key=lambda c: c.dynamo_name):\n            name_ref = self.refs.any_ref(column=column)\n            value_ref = self.refs.any_ref(column=column, value=getattr(obj, column.name, None))\n            update_type = value_ref.action.type\n            # Can't set to an empty value, force to a Remove\n            if is_empty(value_ref) or update_type is ActionType.Remove:\n                self.refs.pop_refs(value_ref)\n                update_type = ActionType.Remove\n                value_ref = None\n            updates[update_type].append((name_ref, value_ref))\n\n        expressions = []\n        for update_type, refs in updates.items():\n            if not refs:\n                continue\n            k = update_type.wire_key.upper()\n            r = update_type.render\n            expressions.append(f\"{k} \" + \", \".join(r(*ref) for ref in refs))\n        if expressions:\n            self.expressions[\"UpdateExpression\"] = \" \".join(e.strip() for e in expressions)\n\n    @property\n    def output(self):\n        \"\"\"The wire format for all conditions that have been rendered.\n        A new :class:`~bloop.conditions.ConditionRenderer` should be used for each operation.\"\"\"\n        expressions = {k: v for (k, v) in self.expressions.items() if v is not None}\n        if self.refs.attr_names:\n            expressions[\"ExpressionAttributeNames\"] = self.refs.attr_names\n        if self.refs.attr_values:\n            expressions[\"ExpressionAttributeValues\"] = self.refs.attr_values\n        return expressions\nbloop/types.py\nclass String(Type):\n    python_type = str\n    backing_type = STRING\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if not value:\n            return \"\"\n        return value\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if not value:\n            return None\n        return value\n", "answers": ["    class Blob(BaseModel):"], "length": 2045, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "8857338affe2d9fe32dc189b478b4aa891b3905618953f5b"}
{"input": "from .property import *\nfrom .exceptions import ReservedWordError\nfrom .declarative import DeclarativeMeta, DeclarativeType\nfrom .vertex import Vertex\nfrom .edge import Edge\nfrom .broker import get_broker\nfrom .query import Query\nfrom .batch import Batch\nfrom .commands import VertexCommand, CreateEdgeCommand\nfrom ..utils import to_unicode\nfrom collections import namedtuple\nfrom os.path import isfile\nimport pyorient\n            self.client.db_create(db_name\n                                  , pyorient.DB_TYPE_GRAPH\n                                  , storage)\n\n        if not (user and cred):\n            user = config.user\n            cred = config.cred\n        self._last_user = user\n        self._last_cred = cred\n        self._last_db = db_name\n\n        cluster_map = self.client.db_open(db_name, user, cred)\n\n\n        self.server_version = ServerVersion(\n            self.client.version.major, self.client.version.minor, self.client.version.build)\n\n        return cluster_map\n\n    def drop(self, db_name=None, storage=None):\n        \"\"\"Drop entire database.\"\"\"\n        config = self.config\n        self.client.connect(config.user, config.cred)\n        try:\n            dropped_db = db_name or config.db_name\n            self.client.db_drop(db_name or config.db_name\n                                   , storage or config.storage)\n        except:\n            return False\n        finally:\n            last_db = self._last_db\n            if last_db and last_db is not dropped_db:\n                # In case we aren't dropping the currently-configured database,\n                # ensure we are still able to use it.\n                self.client.db_open(last_db\n                                    , self._last_user, self._last_cred)\n        return True\n\n    def include(self, registry):\n        \"\"\"Update Graph's registry, when database schema already exists.\n\n        Faster than a full create_all() when it's not required.\n        \"\"\"\n        for cls in registry.values():\n            db_to_element = Graph.compute_all_properties(cls)\n            self.props_from_db[cls] = Graph.create_props_mapping(db_to_element)\n            self.init_broker_for_class(cls)\n            self.registry[cls.registry_name] = cls\n\n    def build_mapping(self, vertex, edge, auto_plural=False):\n        \"\"\"Use database schema to dynamically build mapping classes.\n\n        Returns a registry suitable for passing to include()\n\n        :param vertex: Base class for vertexes. Always pass new declarative_node.\n        :param edge: Base class for edges. Always pass new declarative_relationship.\n        :param auto_plural: If True, will automatically set registry_plural\n        on classes. For convenience when include() should set brokers.\n        \"\"\"\n\n        registry = {}\n\n        schema = self.client.command(\n            'SELECT FROM (SELECT expand(classes) FROM metadata:schema)'\n            ' WHERE name NOT IN [\\'ORole\\', \\'ORestricted\\', \\'OTriggered\\','\n            ' \\'ORIDs\\', \\'OUser\\', \\'OIdentity\\', \\'OSchedule\\', \\'OFunction\\']')\n\n        def resolve_class(name, registries):\n            for r in registries:\n                if name in r:\n                    return r[name]\n            return None\n\n        def extract_properties(property_schema, is_edge):\n            props = {}\n            for p in property_schema:\n                linked_class = None\n                if 'linkedClass' in p:\n                    linked_class = resolve_class(p['linkedClass'], registries)\n\n                prop_name = p['name']\n                # Special-case in property, mainly on edges\n                if is_edge:\n                    if p['name'] == 'in':\n                        prop_name = 'in_'\n                    elif p['name'] == 'out':\n                        prop_name = 'out_'\n\n                props[prop_name] = Graph.property_from_schema(p, linked_class)\n            return props\n\n        # We need to topologically sort classes, since we cannot rely on any ordering\n        # in the database. In particular defaultClusterId is set to -1 for all abstract\n        # classes. Additionally, superclass(es) can be changed post-create, changing the\n        # dependency ordering.\n        schema = Graph.toposort_classes([c.oRecordData for c in schema])\n        registries = [registry, self.registry]\n        # We will keep properties of non-graph types here, just in case vertex/edge\n        # types derive from them.\n        non_graph_properties = {}\n\n        for class_def in schema:\n            class_name = class_def['name']\n            props = {}\n            # Resolve all of the base classes\n            base_names = Graph.list_superclasses(class_def)\n            bases = []\n            for base_name in base_names:\n                if base_name == 'V':\n                    bases.append(vertex)\n                elif base_name == 'E':\n                    bases.append(edge)\n                else:\n                    base = resolve_class(base_name, registries)\n                    if base:\n                        bases.append(base)\n                    else:\n                        # Worst-case scenario -- the base is not a graph type\n                        props.update(non_graph_properties.get(base_name, {}))\n\n", "context": "pyorient/ogm/edge.py\nclass Edge(GraphElement):\n    Broker = EdgeBroker\n\n    def __init__(self, **kwargs):\n        super(Edge, self).__init__(**kwargs)\n\n        self._in = None\n        self._out = None\n\n    @classmethod\n    def from_graph(cls, graph, element_id, in_hash, out_hash, props):\n        edge = super(Edge, cls).from_graph(graph, element_id, props);\n        edge._in = in_hash\n        edge._out = out_hash\n\n        return edge\n\n    def outV(self):\n        g = self._graph\n        return g.get_vertex(self._out) if g else None\n\n    def inV(self):\n        g = self._graph\n        return g.get_vertex(self._in) if g else None\npyorient/ogm/broker.py\ndef get_broker(cls):\n    for v in cls.__dict__.values():\n        if isinstance(v, Broker):\n            return v\n    return None\npyorient/ogm/commands.py\nclass CreateEdgeCommand(object):\n    def __init__(self, command_text):\n        self.command_text = command_text\n        self.retries = None\n\n    def __str__(self):\n        return to_str(self.__unicode__())\n\n    def __unicode__(self):\n        if self.retries:\n            return u'{} RETRY {}'.format(self.command_text, self.retries)\n        else:\n            return u'{}'.format(self.command_text)\n\n    def retry(self, retries):\n        self.retries = retries\n        return self\npyorient/ogm/exceptions.py\nclass ReservedWordError(Exception):\n    pass\npyorient/ogm/vertex.py\nclass Vertex(GraphElement):\n    Broker = VertexBroker\n\n    # TODO\n    # Edge information is carried in vertexes retrieved from database,\n    # as OrientBinaryObject. Can likely optimise these traversals\n    # when we know how to parse these.\n    def outE(self, *edge_classes):\n        g = self._graph\n        return g.outE(self._id, *edge_classes) if g else None\n\n    def inE(self, *edge_classes):\n        g = self._graph\n        return g.inE(self._id, *edge_classes) if g else None\n\n    def bothE(self, *edge_classes):\n        g = self._graph\n        return g.bothE(self._id, *edge_classes) if g else None\n\n    def out(self, *edge_classes):\n        g = self._graph\n        return g.out(self._id, *edge_classes) if g else None\n\n    def in_(self, *edge_classes):\n        g = self._graph\n        return g.in_(self._id, *edge_classes) if g else None\n\n    def both(self, *edge_classes):\n        g = self._graph\n        return g.both(self._id, *edge_classes) if g else None\n\n    def __call__(self, edge_or_broker):\n        \"\"\"Provides syntactic sugar for creating edges.\"\"\"\n        if hasattr(edge_or_broker, 'broker'):\n            edge_or_broker = edge_or_broker.broker.element_cls\n        elif hasattr(edge_or_broker, 'element_cls'):\n            edge_or_broker = edge_or_broker.element_cls\n\n        if edge_or_broker.decl_type == 1:\n            return VertexVector(self, edge_or_broker.objects)\npyorient/ogm/batch.py\nclass Batch(object):\n    READ_COMMITTED = 0\n    REPEATABLE_READ = 1\n\n    def __init__(self, graph, isolation_level=READ_COMMITTED):\n        self.graph = graph\n        self.objects = {}\n        self.variables = {}\n\n        if isolation_level == Batch.REPEATABLE_READ:\n            self.commands = 'BEGIN ISOLATION REPEATABLE_READ\\n'\n        else:\n            self.commands = 'BEGIN\\n'\n\n        for name,cls in graph.registry.items():\n            broker = get_broker(cls)\n            if broker:\n                self.objects[cls] = broker = BatchBroker(broker)\n            else:\n                self.objects[cls] = broker = BatchBroker(cls.objects)\n\n            broker_name = getattr(cls, 'registry_plural', None)\n            if broker_name is not None:\n                setattr(self, broker_name, broker)\n\n    def __setitem__(self, key, value):\n        command = str(value)\n        if isinstance(key, slice):\n            self.commands += '{}\\n'.format(command)\n        else:\n            key = Batch.clean_name(key) if Batch.clean_name else key\n\n            self.commands += 'LET {} = {}\\n'.format(key, command)\n\n            VarType = BatchVariable\n            if isinstance(value, VertexCommand):\n                VarType = BatchVertexVariable\n            self.variables[key] = VarType('${}'.format(key), value)\n\n    def sleep(self, ms):\n        self.commands += 'sleep {}'.format(ms)\n\n    def clear(self):\n        self.objects.clear()\n        self.variables.clear()\n\n        self.commands = self.commands[:self.commands.index('\\n') + 1]\n\n    def __getitem__(self, key):\n        \"\"\"Commit batch with return value, or reference a previously defined\n        variable.\n\n        Using a plain string as a key commits and returns the named variable.\n\n        Slicing with only a 'stop' value does not commit - it is the syntax for\n        using a variable. Otherwise slicing can give finer control over commits;\n        step values give a retry limit, and a start value denotes the returned\n        variable.\n        \"\"\"\n\n        returned = None\n        if isinstance(key, slice):\n            if key.step:\n                if key.start:\n                    returned = Batch.return_string(key.start)\n                    self.commands += \\\n                        'COMMIT RETRY {}\\nRETURN {}'.format(key.step, returned)\n                else:\n                    self.commands += 'COMMIT RETRY {}'.format(key.step)\n            elif key.stop:\n                # No commit.\n\n                if Batch.clean_name:\n                    return self.variables[Batch.clean_name(key.stop)]\n                elif any(c in Batch.INVALID_CHARS for c in key.stop):\n                    raise ValueError(\n                        'Variable name \\'{}\\' contains invalid character(s).'\n                            .format(key.stop))\n\n                return self.variables[key.stop]\n            else:\n                if key.start:\n                    returned = Batch.return_string(key.start)\n                    self.commands += 'COMMIT\\nRETURN {}'.format(returned)\n                else:\n                    self.commands += 'COMMIT'\n        else:\n            returned = Batch.return_string(key)\n            self.commands += 'COMMIT\\nRETURN {}'.format(returned)\n\n        g = self.graph\n        if returned:\n            response = g.client.batch(self.commands)\n            self.clear()\n\n            if returned[0] in ('[','{'):\n                return g.elements_from_records(response) if response else None\n            else:\n                return g.element_from_record(response[0]) if response else None\n        else:\n            g.client.batch(self.commands)\n            self.clear()\n\n    def commit(self, retries=None):\n        \"\"\"Commit batch with no return value.\"\"\"\n        self.commands += 'COMMIT' + (' RETRY {}'.format(retries) if retries else '')\n\n        g = self.graph\n        g.client.batch(self.commands)\n        self.clear()\n\n    @staticmethod\n    def return_string(variables):\n        cleaned = Batch.clean_name or (lambda s:s)\n\n        if isinstance(variables, (list, tuple)):\n            return '[' + ','.join(\n                '${}'.format(cleaned(var)) for var in variables) + ']'\n        elif isinstance(variables, dict):\n            return '{' + ','.join(\n                '{}:${}'.format(repr(k),cleaned(v))\n                    for k,v in variables.items()) + '}'\n        else:\n            # Since any value can be returned from a batch,\n            # '$' must be used when a variable is referenced\n            if isinstance(variables, str):\n                if variables[0] == '$':\n                    return '{}'.format('$' + cleaned(variables[1:]))\n                else:\n                    return repr(variables)\n            else:\n                return '{}'.format(variables)\n\n    INVALID_CHARS = set(string.punctuation + string.whitespace)\n\n    @staticmethod\n    def default_name_cleaner(name):\n        rx = '[' + re.escape(''.join(Batch.INVALID_CHARS)) + ']'\n        return re.sub(rx, '_', name)\n\n    clean_name = None\n    @classmethod\n    def use_name_cleaner(cls, cleaner=default_name_cleaner):\n        cls.clean_name = cleaner\npyorient/ogm/declarative.py\nclass DeclarativeMeta(type):\n    \"\"\"Metaclass for registering node and relationship types.\n\n    Node and relationship metadata is mostly ignored until their classes are\n    created in a Graph. The main benefit is to allow 'self-referencing'\n    properties with LinkedClassProperty subclasses.\n    \"\"\"\n    def __init__(cls, class_name, bases, attrs):\n        if not hasattr(cls, 'registry'):\n            cls.registry = OrderedDict()\n            cls.decl_root = cls\n        else:\n            decl_bases = set(\n                base.decl_root for base in bases\n                    if hasattr(base, 'decl_root') and base is not base.decl_root)\n            if len(decl_bases) > 1:\n                raise TypeError(\n                    'When multiply-inheriting graph elements, they must share '\n                    'the same declarative base class. '\n                    'Note: Each call to declarative_*() returns a new base class.')\n\n            if cls.decl_type is DeclarativeType.Vertex:\n                cls.registry_name = attrs.get('element_type'\n                                              , cls.__name__.lower())\n\n                plural = attrs.get('element_plural')\n                if plural:\n                    cls.registry_plural = plural\n            else:\n                label = attrs.get('label')\n                if label:\n                    cls.registry_name = cls.registry_plural = label\n                else:\n                    cls.registry_name = cls.__name__.lower()\n\n            # See also __setattr__ for properties added after class definition\n            for prop in cls.__dict__.values():\n                if not isinstance(prop, Property):\n                    continue\n                prop._context = cls\n\n            # FIXME Only want bases that correspond to vertex/edge classes.\n            cls.registry[cls.registry_name] = cls\n\n        return super(DeclarativeMeta, cls).__init__(class_name, bases, attrs)\n\n    def __setattr__(self, name, value):\n        if isinstance(value, Property):\n            if value.context:\n                raise ValueError(\n                    'Attempt to add a single Property to multiple classes.')\n            value.context = self\n        return super(DeclarativeMeta, self).__setattr__(name, value)\n\n    def __format__(self, format_spec):\n        \"\"\"Quoted class-name for specifying class as string argument.\n\n        Use 'registry_name' when it is possible to refer to schema entities\n        directly.\n        \"\"\"\n        return repr(self.registry_name)\npyorient/ogm/commands.py\nclass VertexCommand(object):\n    def __init__(self, command_text):\n        self.command_text = command_text\n\n    def __str__(self):\n        return to_str(self.__unicode__())\n\n    def __unicode__(self):\n        return u'{}'.format(self.command_text)\npyorient/ogm/query.py\nclass Query(object):\n    def __init__(self, graph, entities):\n        \"\"\"Query against a class or a selection of its properties.\n\n        :param graph: Graph to query\n        :param entities: Vertex/Edge class/a collection of its properties,\n        an instance of such a class, or a subquery.\n        \"\"\"\n        self._graph = graph\n        self._subquery = None\n\n        first_entity = entities[0]\n\n        if isinstance(first_entity, Property):\n            self.source_name = first_entity._context.registry_name\n            self._class_props = entities\n        elif isinstance(first_entity, GraphElement):\n            # Vertex or edge instance\n            self.source_name = first_entity._id\n            self._class_props = tuple()\n            pass\n        elif isinstance(first_entity, Query):# \\\n                #or isinstance(first_entity, Traverse):\n            # Subquery\n            self._subquery = first_entity\n            self.source_name = first_entity.source_name\n            self._class_props = tuple()\n            pass\n        elif isinstance(first_entity, QV):\n            self.source_name = self.build_what(first_entity)\n            self._class_props = tuple()\n        else:\n            self.source_name = first_entity.registry_name\n            self._class_props = tuple(entities[1:])\n\n        self._params = {}\n\n    @classmethod\n    def sub(cls, source):\n        \"\"\"Shorthand for defining a sub-query, which does not need a Graph\"\"\"\n        return cls(None, (source, ))\n\n    def __iter__(self):\n        params = self._params\n\n        # TODO Don't ignore initial skip value\n        with TempParams(params, skip='#-1:-1', limit=1):\n            optional_clauses = self.build_optional_clauses(params, None)\n\n            prop_names = []\n            props, lets = self.build_props(params, prop_names, for_iterator=True)\n            if len(prop_names) > 1:\n                prop_prefix = self.source_name.translate(sanitise_ids)\n\n                selectuple = namedtuple(prop_prefix + '_props',\n                    [Query.sanitise_prop_name(name)\n                        for name in prop_names])\n            wheres = self.build_wheres(params)\n\n            g = self._graph\n            while True:\n                current_skip = params['skip']\n                where = u'WHERE {0}'.format(\n                    u' and '.join(\n                        [self.rid_lower(current_skip)] + wheres))\n\n                select = self.build_select(props, lets + [where] + optional_clauses)\n\n                response = g.client.command(select)\n                if response:\n                    response = response[0]\n\n                    if prop_names:\n                        next_skip = response.oRecordData.get('rid')\n                        if next_skip:\n                            self.skip(next_skip)\n\n                            if len(prop_names) > 1:\n                                yield selectuple(\n                                    *tuple(self.parse_record_prop(\n                                            response.oRecordData.get(name))\n                                        for name in prop_names))\n                            else:\n                                yield self.parse_record_prop(\n                                        response.oRecordData[prop_names[0]])\n                        else:\n                            yield g.element_from_record(response)\n                            break\n                    else:\n                        if '-' in response._rid:\n                            # Further queries would yield the same\n                            # TODO Find out if any single iteration queries\n                            #      return multiple values\n                            yield next(iter(response.oRecordData.values()))\n                            break\n                        elif response._rid == current_skip:\n                            # OrientDB bug?\n                            # expand() makes for strange responses\n                            break\n                        else:\n                            self.skip(response._rid)\n\n                        yield g.element_from_record(response)\n                else:\n                    break\n\n    def __getitem__(self, key):\n        \"\"\"Set query slice, or just get result by index.\"\"\"\n        if isinstance(key, slice):\n            if key.stop is None:\n                if key.start is not None:\n                    self._params['skip'] = key.start\n                return self\n            elif key.start is None:\n                key.start = 0\n\n            return self.slice(key.start, key.stop)\n\n        with TempParams(self._params, skip=key, limit=1):\n            response = self.all()\n            return response[0] if response else None\n\n    def __str__(self):\n        props, lets, where, optional_clauses = self.prepare()\n        return self.build_select(props, lets + where + optional_clauses)\n\n    def __len__(self):\n        return self.count()\n\n    def prepare(self, prop_names=None):\n        params = self._params\n        props, lets = self.build_props(params, prop_names)\n        skip = params.get('skip')\n        if skip and ':' in str(skip):\n            rid_clause = [self.rid_lower(skip)]\n            skip = None\n        else:\n            rid_clause = []\n        optional_clauses = self.build_optional_clauses(params, skip)\n\n        wheres = rid_clause + self.build_wheres(params)\n        where = [u'WHERE {0}'.format(u' and '.join(wheres))] if wheres else []\n\n        return props, lets, where, optional_clauses\n\n    def all(self):\n        prop_names = []\n        props, lets, where, optional_clauses = self.prepare(prop_names)\n        if len(prop_names) > 1:\n            prop_prefix = self.source_name.translate(sanitise_ids)\n\n            selectuple = namedtuple(prop_prefix + '_props',\n                [Query.sanitise_prop_name(name)\n                    for name in prop_names])\n        select = self.build_select(props, lets + where + optional_clauses)\n\n        g = self._graph\n\n        response = g.client.command(select)\n        if response:\n            # TODO Determine which other queries always take only one iteration\n            list_query = 'count' not in self._params\n\n            if list_query:\n                if prop_names:\n                    if len(prop_names) > 1:\n                        return [\n                            selectuple(*tuple(\n                                self.parse_record_prop(\n                                    record.oRecordData.get(name))\n                                for name in prop_names))\n                            for record in response]\n                    else:\n                        prop_name = prop_names[0]\n                        return [\n                            self.parse_record_prop(\n                                record.oRecordData[prop_name])\n                            for record in response]\n                else:\n                    if self._params.get('reify', False) and len(response) == 1:\n                        # Simplify query for subsequent uses\n                        del self._params['kw_filters']\n                        self.source_name = response[0]._rid\n\n                    return g.elements_from_records(response)\n            else:\n                return next(iter(response[0].oRecordData.values()))\n        else:\n            return []\n\n    def first(self, reify=False):\n        with TempParams(self._params, limit=1, reify=reify):\n            response = self.all()\n            return response[0] if response else None\n\n    def one(self, reify=False):\n        with TempParams(self._params, limit=2):\n            responses = self.all()\n            num_responses = len(responses)\n            if num_responses > 1:\n                raise MultipleResultsFound(\n                    'Expecting one result for query; got more.')\n            elif num_responses < 1:\n                raise NoResultFound('Expecting one result for query; got none.')\n            else:\n                return responses[0]\n\n    def scalar(self):\n        try:\n            response = self.one()\n        except NoResultFound:\n            return None\n        else:\n            return response[0] if isinstance(response, tuple) else response\n\n    def count(self, field=None):\n        params = self._params\n\n        if not field:\n            whats = params.get('what')\n            if whats and len(whats) == 1:\n                field = self.build_what(whats[0])\n            elif len(self._class_props) == 1:\n                field = self._class_props[0]\n            else:\n                field = '*'\n\n        with TempParams(params, count=field):\n            return self.all()\n\n    def what(self, *whats):\n        self._params['what'] = whats\n        return self\n\n    def let(self, **kwargs):\n        self._params['let'] = kwargs\n        return self\n\n    def filter(self, expression):\n        self._params['filter'] = expression\n        return self\n\n    def filter_by(self, **kwargs):\n        self._params['kw_filters'] = kwargs\n        return self\n\n    def group_by(self, *criteria):\n        self._params['group_by'] = criteria\n        return self\n\n    def order_by(self, *criteria, **kwargs):\n        self._params['order_by'] = (criteria, kwargs.get('reverse', False))\n        return self\n\n    def unwind(self, field):\n        self._params['unwind'] = field\n        return self\n\n    def skip(self, skip):\n        self._params['skip'] = skip\n        return self\n\n    def limit(self, limit):\n        self._params['limit'] = limit\n        return self\n\n    def slice(self, start, stop):\n        \"\"\"Give bounds on how many records to retrieve\n\n        :param start: If a string, must denote the id of the record _preceding_\n        that to be retrieved next, or '#-1:-1'. Otherwise denotes how many\n        records to skip.\n\n        :param stop: If 'start' was a string, denotes a limit on how many\n        records to retrieve. Otherwise, the index one-past-the-last\n        record to retrieve.\n        \"\"\"\n        self._params['skip'] = start\n        if isinstance(start, str):\n            self._params['limit'] = stop\n        else:\n            self._params['limit'] = stop - start\n        return self\n\n    def lock(self):\n        self._params['lock'] = True\n\n    @classmethod\n    def filter_string(cls, expression_root):\n        op = expression_root.operator\n\n        left = expression_root.operands[0]\n        right = expression_root.operands[1]\n        if isinstance(left, IdentityOperand):\n            if isinstance(left, Property):\n                left_str = left.context_name()\n            elif isinstance(left, ArithmeticOperation):\n                left_str = u'({})'.format(cls.arithmetic_string(left))\n            elif isinstance(left, ChainableWhat):\n                left_str = cls.build_what(left)\n            else:\n                raise ValueError(\n                    'Operator {} not supported as a filter'.format(op))\n\n            if op is Operator.Equal:\n                return u'{0} = {1}'.format(\n                    left_str, ArgConverter.convert_to(ArgConverter.Vertex\n                                                      , right, cls))\n            elif op is Operator.GreaterEqual:\n                return u'{0} >= {1}'.format(\n                    left_str, ArgConverter.convert_to(ArgConverter.Value\n                                                      , right, cls))\n            elif op is Operator.Greater:\n                return u'{0} > {1}'.format(\n                    left_str, ArgConverter.convert_to(ArgConverter.Value\n                                                      , right, cls))\n            elif op is Operator.LessEqual:\n                return u'{0} <= {1}'.format(\n                    left_str, ArgConverter.convert_to(ArgConverter.Value\n                                                      , right, cls))\n            elif op is Operator.Less:\n                return u'{0} < {1}'.format(\n                    left_str, ArgConverter.convert_to(ArgConverter.Value\n                                                      , right, cls))\n            elif op is Operator.NotEqual:\n                return u'{0} <> {1}'.format(\n                    left_str, ArgConverter.convert_to(ArgConverter.Vertex\n                                                      , right, cls))\n            elif op is Operator.Between:\n                far_right = PropertyEncoder.encode_value(expression_root.operands[2])\n                return u'{0} BETWEEN {1} and {2}'.format(\n                    left_str, PropertyEncoder.encode_value(right), far_right)\n            elif op is Operator.Contains:\n                if isinstance(right, LogicalConnective):\n                    return u'{0} contains({1})'.format(\n                        left_str, cls.filter_string(right))\n                else:\n                    return u'{} in {}'.format(\n                        PropertyEncoder.encode_value(right), left_str)\n            elif op is Operator.EndsWith:\n                return u'{0} like {1}'.format(left_str, PropertyEncoder.encode_value('%' + right))\n            elif op is Operator.Is:\n                if not right: # :)\n                    return '{0} is null'.format(left_str)\n            elif op is Operator.IsNot:\n                if not right:\n                    return '{} is not null'.format(left_str)\n            elif op is Operator.Like:\n                return u'{0} like {1}'.format(\n                    left_str, PropertyEncoder.encode_value(right))\n            elif op is Operator.Matches:\n                return u'{0} matches {1}'.format(\n                    left_str, PropertyEncoder.encode_value(right))\n            elif op is Operator.StartsWith:\n                return u'{0} like {1}'.format(\n                    left_str, PropertyEncoder.encode_value(right + '%'))\n            elif op is Operator.InstanceOf:\n                return u'{0} instanceof {1}'.format(\n                    left_str, repr(right.registry_name))\n            else:\n                raise AssertionError('Unhandled Operator type: {}'.format(op))\n        else:\n            return u'{0} {1} {2}'.format(\n                cls.filter_string(left)\n                , 'and' if op is Operator.And else 'or'\n                , cls.filter_string(right))\n\n    @classmethod\n    def arithmetic_string(cls, operation_root):\n        if isinstance(operation_root, ArithmeticOperation):\n            op = operation_root.operator\n            if operation_root.paren:\n                lp = '('\n                rp = ')'\n            else:\n                lp = rp = ''\n\n            left = operation_root.operands[0]\n            # Unary operators not yet supported?\n            right = operation_root.operands[1]\n\n            if op is Operator.Add:\n                exp = '{} + {}'.format(\n                        cls.arithmetic_string(left)\n                        , cls.arithmetic_string(right))\n            elif op is Operator.Sub:\n                exp = '{} - {}'.format(\n                        cls.arithmetic_string(left)\n                        , cls.arithmetic_string(right))\n            elif op is Operator.Mul:\n                exp = '{} * {}'.format(\n                        cls.arithmetic_string(left)\n                        , cls.arithmetic_string(right))\n            elif op is Operator.Div:\n                exp = '{} / {}'.format(\n                        cls.arithmetic_string(left)\n                        , cls.arithmetic_string(right))\n            elif op is Operator.Mod:\n                exp = '{} % {}'.format(\n                        cls.arithmetic_string(left)\n                        , cls.arithmetic_string(right))\n\n            return '{}{}{}'.format(lp,exp,rp)\n        elif isinstance(operation_root, Property):\n            return operation_root.context_name()\n        else:\n            return operation_root\n\n\n    def build_props(self, params, prop_names=None, for_iterator=False):\n        let = params.get('let')\n        if let:\n            lets = ['LET {}'.format(\n                ','.join('${} = {}'.format(\n                    PropertyEncoder.encode_name(k),\n                    u'({})'.format(v) if isinstance(v, Query) else\n                    self.build_what(v)) for k,v in let.items()))]\n        else:\n            lets = []\n\n        count_field = params.get('count')\n        if count_field:\n            if isinstance(count_field, Property):\n                count_field = count_field.context_name()\n\n            # Record response will use the same (lower-)case as the request\n            return ['count({})'.format(count_field or '*')], lets\n\n        whats = params.get('what')\n        if whats:\n            props = [self.build_what(what, prop_names) for what in whats]\n\n            if prop_names is not None:\n                # Multiple, distinct what's can alias to the same name\n                # Make unique; consistent with what OrientDB assumes\n                used_names = {}\n                for idx, name in enumerate(prop_names):\n                    prop_names[idx] = Query.unique_prop_name(name, used_names)\n        else:\n            props = [e.context_name() for e in self._class_props]\n            if prop_names is not None:\n                prop_names.extend(props)\n\n        if props and for_iterator:\n            props[0:0] = ['@rid']\n\n        return props, lets\n\n    def build_wheres(self, params):\n        kw_filters = params.get('kw_filters')\n        kw_where = [u' and '.join(u'{0}={1}'\n            .format(PropertyEncoder.encode_name(k), PropertyEncoder.encode_value(v))\n                for k,v in kw_filters.items())] if kw_filters else []\n\n        filter_exp = params.get('filter')\n        exp_where = [self.filter_string(filter_exp)] if filter_exp else []\n\n        return kw_where + exp_where\n\n    def rid_lower(self, skip):\n        return '@rid > {}'.format(skip)\n\n    def build_optional_clauses(self, params, skip):\n        '''LET, while being an optional clause, must precede WHERE\n        and is therefore handled separately.'''\n        optional_clauses = []\n\n        group_by = params.get('group_by')\n        if group_by:\n            group_clause = 'GROUP BY {}'.format(\n                ','.join([by.context_name() for by in group_by]))\n            optional_clauses.append(group_clause)\n\n        order_by = params.get('order_by')\n        if order_by:\n            order_clause = 'ORDER BY {0} {1}'.format(\n                ','.join([by.context_name() for by in order_by[0]])\n                , 'DESC' if order_by[1] else 'ASC')\n            optional_clauses.append(order_clause)\n\n        unwind = params.get('unwind')\n        if unwind:\n           unwind_clause = 'UNWIND {}'.format(\n                    unwind.context_name()\n                    if isinstance(unwind, Property) else unwind)\n           optional_clauses.append(unwind_clause)\n\n        if skip:\n            optional_clauses.append('SKIP {}'.format(skip))\n\n        # TODO Determine other functions for which limit is useless\n        if 'count' not in params:\n            limit = params.get('limit')\n            if limit:\n                optional_clauses.append('LIMIT {}'.format(limit))\n\n        lock = params.get('lock')\n        if lock:\n            optional_clauses.append('LOCK RECORD')\n\n        return optional_clauses\n\n    WhatFunction = namedtuple('what', ['max_args', 'fmt', 'expected'])\n    WhatFunctions = {\n        # TODO handle GraphElement args\n        What.Out: WhatFunction(1, 'out({})', (ArgConverter.Label,))\n        , What.In: WhatFunction(1, 'in({})', (ArgConverter.Label,))\n        , What.Both: WhatFunction(1, 'both({})', (ArgConverter.Label,))\n        , What.OutE: WhatFunction(1, 'outE({})', (ArgConverter.Label,))\n        , What.InE: WhatFunction(1, 'inE({})', (ArgConverter.Label,))\n        , What.BothE: WhatFunction(1, 'bothE({})', (ArgConverter.Label,))\n        , What.OutV: WhatFunction(0, 'outV()', tuple())\n        , What.InV: WhatFunction(0, 'inV()', tuple())\n        , What.Eval: WhatFunction(1, 'eval({})', (ArgConverter.Expression,))\n        , What.Coalesce: WhatFunction(None, 'coalesce({})'\n                                      , (ArgConverter.Field,))\n        , What.If: WhatFunction(3, 'if({})'\n                                , (ArgConverter.Boolean, ArgConverter.Value\n                                   , ArgConverter.Value))\n        , What.IfNull: WhatFunction(2, 'ifnull({})'\n                                    , (ArgConverter.Field, ArgConverter.Value))\n        , What.Expand: WhatFunction(1, 'expand({})', (ArgConverter.Field,))\n        , What.First: WhatFunction(1, 'first({})', (ArgConverter.Field,))\n        , What.Last: WhatFunction(1, 'last({})', (ArgConverter.Field,))\n        , What.Count: WhatFunction(1, 'count({})', (ArgConverter.Field,))\n        , What.Min: WhatFunction(None, 'min({})', (ArgConverter.Field,))\n        , What.Max: WhatFunction(None, 'max({})', (ArgConverter.Field,))\n        , What.Avg: WhatFunction(1, 'avg({})', (ArgConverter.Field,))\n        , What.Mode: WhatFunction(1, 'mode({})', (ArgConverter.Field,))\n        , What.Median: WhatFunction(1, 'median({})', (ArgConverter.Field,))\n        , What.Percentile: WhatFunction(None, 'percentile({})'\n                                        , (ArgConverter.Field,))\n        , What.Variance: WhatFunction(1, 'variance({})', (ArgConverter.Field,))\n        , What.StdDev: WhatFunction(1, 'stddev({})', (ArgConverter.Field,))\n        , What.Sum: WhatFunction(1, 'sum({})', (ArgConverter.Field,))\n        , What.Date: WhatFunction(3, 'date({})'\n                                  , (ArgConverter.String, ArgConverter.String\n                                     , ArgConverter.String))\n        , What.SysDate: WhatFunction(2, 'sysdate({})'\n                                     , (ArgConverter.String\n                                        , ArgConverter.String))\n        , What.Format: WhatFunction(None, 'format({})'\n                                    , (ArgConverter.Format, ArgConverter.Field))\n        , What.Dijkstra:\n            WhatFunction(4, 'dijkstra({})'\n                         , (ArgConverter.Vertex, ArgConverter.Vertex\n                         , ArgConverter.Label, ArgConverter.Value))\n        , What.ShortestPath:\n            WhatFunction(4, 'shortestPath({})'\n                         , (ArgConverter.Vertex, ArgConverter.Vertex\n                            , ArgConverter.Value, ArgConverter.Label))\n        , What.Distance:\n            WhatFunction(4, 'distance({})'\n                         , (ArgConverter.Field, ArgConverter.Field\n                            , ArgConverter.Value, ArgConverter.Value))\n        , What.Distinct: WhatFunction(1, 'distinct({})', (ArgConverter.Field,))\n        , What.UnionAll: WhatFunction(None, 'unionall({})'\n                                      , (ArgConverter.Field,))\n        , What.Intersect: WhatFunction(None, 'intersect({})'\n                                       , (ArgConverter.Field,))\n        , What.Difference: WhatFunction(None, 'difference({})'\n                                        , (ArgConverter.Field,))\n        , What.SymmetricDifference:\n            WhatFunction(None, 'symmetricDifference({})', (ArgConverter.Field,))\n        # FIXME Don't understand usage of these, yet.\n        , What.Set: WhatFunction(1, 'set({})', (ArgConverter.Field,))\n        , What.List: WhatFunction(1, 'list({})', (ArgConverter.Field,))\n        , What.Map: WhatFunction(2, 'map({})', (ArgConverter.Field\n                                                , ArgConverter.Field))\n        , What.TraversedElement:\n            WhatFunction(2, 'traversedElement({})'\n                         , (ArgConverter.Value, ArgConverter.Value))\n        , What.TraversedEdge:\n            WhatFunction(2, 'traversedEdge({})'\n                         , (ArgConverter.Value, ArgConverter.Value))\n        , What.TraversedVertex:\n            WhatFunction(2, 'traversedVertex({})'\n                         , (ArgConverter.Value, ArgConverter.Value))\n        , What.Any: WhatFunction(0, 'any()', tuple())\n        , What.All: WhatFunction(0, 'all()', tuple())\n        # Methods\n        , What.Append: WhatFunction(1, 'append({})', (ArgConverter.Value,))\n        , What.AsBoolean: WhatFunction(0, 'asBoolean()', tuple())\n        , What.AsDate: WhatFunction(0, 'asDate()', tuple())\n        , What.AsDatetime: WhatFunction(0, 'asDatetime()', tuple())\n        , What.AsDecimal: WhatFunction(0, 'asDecimal()', tuple())\n        , What.AsFloat: WhatFunction(0, 'asFloat()', tuple())\n        , What.AsInteger: WhatFunction(0, 'asInteger()', tuple())\n        , What.AsList: WhatFunction(0, 'asList()', tuple())\n        , What.AsLong: WhatFunction(0, 'asLong()', tuple())\n        , What.AsMap: WhatFunction(0, 'asMap()', tuple())\n        , What.AsSet: WhatFunction(0, 'asSet()', tuple())\n        , What.AsString: WhatFunction(0, 'asString()', tuple())\n        , What.CharAt: WhatFunction(1, 'charAt({})', (ArgConverter.Field,))\n        , What.Convert: WhatFunction(1, 'convert({})', (ArgConverter.Value,))\n        , What.Exclude: WhatFunction(None, 'exclude({})', (ArgConverter.Value,))\n        , What.FormatMethod: WhatFunction(1, 'format({})', (ArgConverter.Value,))\n        , What.Hash: WhatFunction(1, 'hash({})', (ArgConverter.Value,))\n        , What.Include: WhatFunction(None, 'include({})', (ArgConverter.Value,))\n        , What.IndexOf: WhatFunction(2, 'indexOf({})', (ArgConverter.Value, ArgConverter.Value))\n        , What.JavaType: WhatFunction(0, 'javaType()', tuple())\n        , What.Keys: WhatFunction(0, 'keys()', tuple())\n        , What.Left: WhatFunction(1, 'left({})', (ArgConverter.Value,))\n        , What.Length: WhatFunction(0, 'length()', tuple())\n        , What.Normalize: WhatFunction(2, 'normalize({})', (ArgConverter.Value, ArgConverter.Value))\n        , What.Prefix: WhatFunction(1, 'prefix({})', (ArgConverter.Value,))\n        , What.Remove: WhatFunction(None, 'remove({})', (ArgConverter.Value,))\n        , What.RemoveAll: WhatFunction(None, 'removeAll({})', (ArgConverter.Value,))\n        , What.Replace: WhatFunction(2, 'replace({})', (ArgConverter.Value, ArgConverter.Value))\n        , What.Right: WhatFunction(1, 'right({})', (ArgConverter.Value,))\n        , What.Size: WhatFunction(0, 'size()', tuple())\n        , What.SubString: WhatFunction(2, 'substring({})', (ArgConverter.Value, ArgConverter.Value))\n        , What.Trim: WhatFunction(0, 'trim()', tuple())\n        , What.ToJSON: WhatFunction(0, 'toJSON()', tuple()) # FIXME TODO Figure out format argument\n        , What.ToLowerCase: WhatFunction(0, 'toLowerCase()', tuple())\n        , What.ToUpperCase: WhatFunction(0, 'toUpperCase()', tuple())\n        , What.Type: WhatFunction(0, 'type()', tuple())\n        , What.Values: WhatFunction(0, 'values()', tuple())\n        , What.WhatLet: WhatFunction(1, '${}', (ArgConverter.Name, ))\n        , What.AtThis: WhatFunction(0, '@this', tuple())\n        , What.AtRid: WhatFunction(0, '@rid', tuple())\n        , What.AtClass: WhatFunction(0, '@class', tuple())\n        , What.AtVersion: WhatFunction(0, '@version', tuple())\n        , What.AtSize: WhatFunction(0, '@size', tuple())\n        , What.AtType: WhatFunction(0, '@type', tuple())\n    }\n\n    @classmethod\n    def append_what_function(cls, chain, func_key, func_args):\n        what_function = Query.WhatFunctions[func_key]\n        max_args = what_function.max_args\n        if max_args > 0 or max_args is None:\n            chain.append(\n                what_function.fmt.format(\n                    ','.join(cls.what_args(what_function.expected,\n                                            func_args[1]))))\n        else:\n            chain.append(what_function.fmt)\n\n    @classmethod\n    def build_what(cls, what, prop_names=None):\n        if isinstance(what, Property):\n            prop_name = what.context_name()\n            if prop_names is not None:\n                prop_names.append(prop_name)\n            return prop_name\n        elif not isinstance(what, What):\n            if isinstance(what, str):\n                what_str = json.dumps(what)\n            else:\n                what_str = str(what)\n\n            if prop_names is not None:\n                period = what_str.find('.')\n                if period >= 0:\n                    prop_names.append(what_str[0:period])\n                else:\n                    prop_names.append(what_str.replace('\"', ''))\n            return what_str\n\n        name_override = what.name_override\n        as_str = ' AS {}'.format(name_override) if name_override else ''\n\n        if isinstance(what, FunctionWhat):\n            func = what.chain[0][0]\n            what_function = Query.WhatFunctions[func]\n\n            if prop_names is not None:\n                # Projections not allowed with Expand\n                counted = func is not What.Expand\n                if counted:\n                    prop_names.append(\n                        cls.parse_prop_name(what_function.fmt, name_override))\n\n            return '{}{}'.format(\n                what_function.fmt.format(\n                    ','.join(cls.what_args(what_function.expected,\n                                            what.chain[0][1]))), as_str)\n        elif isinstance(what, ChainableWhat):\n            chain = []\n            for func_args in what.chain:\n                func_key = func_args[0]\n                if func_key == What.WhatFilter:\n                    filter_exp = func_args[1]\n                    chain[-1] += '[{}]'.format(ArgConverter.convert_to(ArgConverter.Filter, filter_exp, cls))\n                    continue\n                elif func_key == What.WhatCustom:\n                    chain.append('{}({})'.format(func_args[1], ','.join(cls.what_args(func_args[2], func_args[3]))))\n                    continue\n\n                cls.append_what_function(chain, func_key, func_args)\n\n            for prop in what.props:\n                if isinstance(prop, tuple):\n                    func_key = prop[0]\n                    cls.append_what_function(chain, func_key, prop)\n                else:\n                    chain.append(prop)\n\n            if prop_names is not None:\n                prop_names.append(\n                    cls.parse_prop_name(chain[0], name_override))\n            return '{}{}'.format('.'.join(chain), as_str)\n\n    @staticmethod\n    def unique_prop_name(name, used_names):\n        used = used_names.get(name, None)\n        if used is None:\n            used_names[name] = 1\n            return name\n        else:\n            used_names[name] += 1\n            return name + str(used_names[name])\n\n    @staticmethod\n    def sanitise_prop_name(name):\n        if iskeyword(name):\n            return name + '_'\n        elif name[0] == '$':\n            return 'qv_'+ name[1:]\n        else:\n            return name\n\n    @staticmethod\n    def parse_prop_name(from_str, override):\n        if override:\n            return override\n        else:\n            paren_idx = from_str.find('(')\n            if paren_idx < 0:\n                return from_str\n            else:\n                return from_str[:paren_idx]\n\n    @classmethod\n    def what_args(cls, expected, args):\n        if args:\n            return [ArgConverter.convert_to(conversion, arg, cls)\n                    for arg, conversion in\n                        zip_longest(args, expected\n                                    , fillvalue=expected[-1])\n                        if arg is not None]\n        else:\n            return []\n\n    def build_select(self, props, optional_clauses):\n        # This 'is not None' is important; don't want to implicitly call\n        # __len__ (which invokes count()) on subquery.\n        if self._subquery is not None:\n            src = u'({})'.format(self._subquery)\n        else:\n            src = self.source_name\n\n        optional_string = ' '.join(optional_clauses)\n        if props:\n            return u'SELECT {} FROM {} {}'.format(\n                ','.join(props), src, optional_string)\n        else:\n            return u'SELECT FROM {} {}'.format(src, optional_string)\n\n    def parse_record_prop(self, prop):\n        if isinstance(prop, list):\n            g = self._graph\n            return g.elements_from_links(prop) if len(prop) > 0 and isinstance(prop[0], pyorient.OrientRecordLink) else prop\n        elif isinstance(prop, pyorient.OrientRecordLink):\n            return self._graph.element_from_link(prop)\n        return prop\npyorient/ogm/declarative.py\nclass DeclarativeType(object):\n    \"\"\"Marker for graph database element types\"\"\"\n    Vertex = 0\n    Edge = 1\n", "answers": ["            is_edge = bases and bases[0].decl_type == DeclarativeType.Edge"], "length": 3757, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "306a6e06089f2be5a32c6f2b6ca575cff54ca90f6b05f205"}
{"input": "import dis\nimport opcode\nimport marshal\nimport time\nimport struct\nimport types\nimport operator\nimport traceback\nimport imp\nfrom dis import findlinestarts, findlabels\nfrom ..utils.log import logger\nfrom .utils import show_bytecode\nfrom .decl import ModuleDeclaration, \\\n                  TypeDeclaration,   \\\n                  MethodDeclaration, \\\n                  FieldDeclaration,  \\\n                  ImportDeclaration\nfrom ..visitors import BytecodeVisitor, \\\n                       ClassVisitor,    \\\n                       MethodVisitor,   \\\n                       ModuleVisitor,   \\\n                       BlockVisitor\nfrom ..analysis.python.opcodes import *\n    from ..analysis import ControlFlow\n    from ..rewriter.simple import SimpleRewriter\n    from ..rewriter.simple import SimpleRewriter\n\n  :copyright: (c) 2014 by Romain Gaucher (@rgaucher)\n  :license: Apache 2, see LICENSE for more details.\n\"\"\"\n\n\n\n\n\n# Flags from code.h\nCO_OPTIMIZED              = 0x0001      # use LOAD/STORE_FAST instead of _NAME\nCO_NEWLOCALS              = 0x0002      # only cleared for module/exec code\nCO_VARARGS                = 0x0004\nCO_VARKEYWORDS            = 0x0008\nCO_NESTED                 = 0x0010      # ???\nCO_GENERATOR              = 0x0020\nCO_NOFREE                 = 0x0040      # set if no free or cell vars\nCO_GENERATOR_ALLOWED      = 0x1000      # unused\n# The future flags are only used on code generation, so we can ignore them.\n# (It does cause some warnings, though.)\nCO_FUTURE_DIVISION        = 0x2000\nCO_FUTURE_ABSOLUTE_IMPORT = 0x4000\nCO_FUTURE_WITH_STATEMENT  = 0x8000\n\n\nclass BytecodeObject(object):\n  \"\"\"\n    This class parses the bytecode from a file and constructs the representation from it.\n    The result is:\n\n    * One module (type: ``ModuleDeclaration``)\n    * The bytecode expanded into intelligible structure.\n    * Construction of nested declarations, and hierarchy of declaration types.\n  \"\"\"\n\n  def __init__(self, pyc_file, lazy_load=True):\n    \"\"\"\n      Builds the representation of the bytecode, as well as the nested ``Declaration``\n      structures based on the bytecode contained in the binary file.\n\n      :param pyc_file: The compiled python file that contains the bytecode.\n    \"\"\"\n    self.code = None\n    self.magic = None\n    self.moddate = None\n    self.modif_date = None\n    self.pyc_file = pyc_file\n    if not lazy_load:\n      self.parse()\n    self.main_module = None\n    self.bytecode = []\n    self.all_decls = set()\n\n\n  def parse(self):\n    \"\"\"\n      Parses the binary file (pyc) and extract the bytecode out of it. Keeps the magic number\n      as well as the timestamp for serialization.\n    \"\"\"\n    fd = open(self.pyc_file, 'rb')\n    self.magic = fd.read(4)\n    self.moddate = fd.read(4)\n    self.modif_date = long(struct.unpack('<l', self.moddate)[0])\n    co = marshal.load(fd)\n    self.parse_code(co)\n\n\n  def parse_code(self, co):\n    \"\"\"\n      Parses a Python code object. Mostly useful for testing.\n    \"\"\"\n    self.code = co\n    self.bytecode = []\n\n    try:\n      self.load_bytecode(self.code)\n      self.build_representation()\n    except Exception, ex:\n      logger.error(\"parse error: %s\", repr(ex), exc_info=ex)\n\n\n  def get_module(self):\n    \"\"\"\n      Returns the ModuleDeclaration associated with the current bytecode.\n    \"\"\"\n    return self.main_module\n\n\n  def get_bytecode(self):\n    \"\"\"\n      Returns the current translated bytecode.\n    \"\"\"\n    return self.bytecode\n\n\n  @property\n  def declarations(self):\n    \"\"\"\n      Returns a set of all the declarations found in the current bytecode.\n    \"\"\"\n    return self.all_decls\n\n\n  @property\n  def has_changes(self):\n    \"\"\"\n      Returns `True` if any change was performed on the module. This is used\n      to know if we need to rewrite or not a pyc file.\n    \"\"\"\n    return self.main_module.has_changes\n\n\n  def accept(self, visitor):\n    \"\"\"\n      Runs the visitor over the nested declarations found in the this module, or\n      the entire bytecode if it's a `BytecodeVisitor`.\n    \"\"\"\n    if not self.code:\n      self.parse()\n\n", "context": "equip/bytecode/decl.py\nclass MethodDeclaration(Declaration):\n  \"\"\"\n    The declaration of a method or a function.\n  \"\"\"\n\n  def __init__(self, method_name, code_object):\n    Declaration.__init__(self, Declaration.METHOD, code_object)\n    self._method_name = method_name\n    self._formal_parameters = []\n    self._body = None\n    self._labels = dis.findlabels(code_object.co_code)\n    self._nested_types = []\n\n  @property\n  def body(self):\n    return self._body\n\n  @body.setter\n  def body(self, value):\n    self._body = value\n\n  @property\n  def labels(self):\n    return self._labels\n\n  @property\n  def is_lambda(self):\n    return self.method_name == '<lambda>'\n\n  @property\n  def formal_parameters(self):\n    return self._formal_parameters\n\n  @formal_parameters.setter\n  def formal_parameters(self, value):\n    self._formal_parameters = value\n\n  @property\n  def method_name(self):\n    return self._method_name\n\n  @property\n  def nested_types(self):\n    return self._nested_types\n\n  def __repr__(self):\n    return 'MethodDeclaration#%d(name=%s, args=%s, co=%s)' \\\n           % (self.start_lineno, self.method_name, self.formal_params, self.code_object)\nequip/bytecode/decl.py\nclass ModuleDeclaration(Declaration):\n  \"\"\"\n    The module is the object that captures everything under one pyc file.\n    It contains nested classes and functions, as well as import statements.\n  \"\"\"\n\n  def __init__(self, module_path, code_object):\n    Declaration.__init__(self, Declaration.MODULE, code_object)\n    self._module_path = module_path\n\n    self._imports = []\n    self._classes = None\n    self._functions = None\n\n  def add_import(self, importDecl):\n    if importDecl not in self._imports:\n      self._imports.append(importDecl)\n\n  @property\n  def imports(self):\n    return self._imports\n\n  @property\n  def module_path(self):\n    return self._module_path\n\n  @property\n  def classes(self):\n    if self._classes is None:\n      self._classes = [ c for c in self.children if c.is_type() ]\n    return self._classes\n\n  @property\n  def functions(self):\n    if self._functions is None:\n      self._functions = [ f for f in self.children if f.is_method() ]\n    return self._functions\n\n  def __repr__(self):\n    return 'ModuleDeclaration(path=%s, co=%s)' % (self.module_path, self.code_object)\nequip/bytecode/decl.py\nclass ImportDeclaration(Declaration):\n  \"\"\"\n    Models an import statement. It handles relatives/absolute\n    imports, as well as aliases.\n  \"\"\"\n\n  def __init__(self, code_object):\n    Declaration.__init__(self, Declaration.IMPORT, code_object)\n    self._root = None\n    self._aliases = None\n    self._live_names = None\n    self._dots = -1\n    self._star = False\n\n  @property\n  def star(self):\n      return self._star\n\n  @star.setter\n  def star(self, value):\n      self._star = value\n\n  @property\n  def aliases(self):\n    return self._aliases\n\n  @aliases.setter\n  def aliases(self, value):\n    self._aliases = value\n\n  @property\n  def live_names(self):\n    if self._live_names is None:\n      self._live_names = set()\n      for (name, alias) in self.aliases:\n        if alias is None:\n          if '.' not in name:\n            self._live_names.add(name)\n          else:\n            live_name = name[:name.rfind('.')]\n            self._live_names.add(live_name)\n        else:\n          self._live_names.add(alias)\n    return self._live_names\n\n  @property\n  def dots(self):\n    return self._dots\n\n  @dots.setter\n  def dots(self, value):\n    self._dots = value\n\n  @property\n  def root(self):\n    return self._root\n\n  @root.setter\n  def root(self, value):\n    self._root = value\n\n  def __eq__(self, obj):\n    return self.root == obj.root and self.aliases == obj.aliases and self.dots == obj.dots\n\n  def __repr__(self):\n    skip_import_root = False\n    import_buffer = ''\n    if self.dots > 0:\n      import_buffer += 'from ' + '.' * self.dots\n      if self.root:\n        import_buffer += self.root\n        skip_import_root = True\n      import_buffer += ' import '\n\n    elif self.root:\n      import_buffer += 'from '\n    else:\n      import_buffer += 'import '\n\n    if self.root and not skip_import_root:\n      import_buffer += self.root + ' import '\n\n    if self.star:\n      import_buffer += '*'\n\n    import_list = []\n    for aliased_name in self.aliases:\n      local_import = aliased_name[0]\n      if aliased_name[1]:\n        local_import += ' as ' + aliased_name[1]\n      import_list.append(local_import)\n\n    if import_list:\n      import_buffer += ', '.join(import_list)\n\n    return 'Import(%s)' % import_buffer\nequip/visitors/bytecode.py\nclass BytecodeVisitor(object):\n  \"\"\"\n    A visitor to visit each instruction in the bytecode. For example,\n    the following code::\n\n      class CallFunctionVisitor(BytecodeVisitor):\n        def __init__(self):\n          BytecodeVisitor.__init__(self)\n\n        def visit_call_function(self, oparg):\n          print \"Function call with %d args\" % oparg\n\n    Prints whenever a ``CALL_FUNCTION`` opcode is visited and prints out\n    its number of arguments (the oparg for this opcode).\n  \"\"\"\n\n  def __init__(self):\n    pass\n\n  @staticmethod\n  def toMethodName(name):\n    return 'visit_' + name.lower().replace('+', '_')\n\n\n  def visit(self, index, op, arg=None, lineno=None, cflow_in=False):\n    \"\"\"\n      Callback of the visitor. It dynamically constructs the name\n      of the specialized visitor to call based on the name of the opcode.\n\n      :param index: Bytecode index.\n      :param op: The opcode that is currently visited.\n      :param arg: The expanded oparg (i.e., constants, names, etc. are resolved).\n      :param lineno: The line number associated with the opcode.\n      :param cflow_in: ``True`` if the current ``index`` is the target of a jump.\n    \"\"\"\n    # Let's start with a slow impl of the jump table, with\n    # reflection\n    method_name = BytecodeVisitor.toMethodName(opcode.opname[op])\n    if hasattr(self, method_name):\n      meth = getattr(self, method_name)\n      if op < opcode.HAVE_ARGUMENT:\n        logger.debug(\"%03d %26s\" % (lineno, method_name))\n        return meth()\n      else:\n        logger.debug(\"%03d %26s( %s )\" % (lineno, method_name, repr(arg)))\n        return meth(arg)\n    else:\n      logger.error(\"Method not found: %s\" % method_name)\n\n\n  # 2.7 specific visitors. See https://docs.python.org/2/library/dis.html\n\n  def visit_stop_code(self):\n    pass\n\n  def visit_pop_top(self):\n    pass\n\n  def visit_rot_two(self):\n    pass\n\n  def visit_rot_three(self):\n    pass\n\n  def visit_dup_top(self):\n    pass\n\n  def visit_rot_four(self):\n    pass\n\n  def visit_nop(self):\n    pass\n\n  def visit_unary_positive(self):\n    pass\n\n  def visit_unary_negative(self):\n    pass\n\n  def visit_unary_not(self):\n    pass\n\n  def visit_unary_convert(self):\n    pass\n\n  def visit_unary_invert(self):\n    pass\n\n  def visit_binary_power(self):\n    pass\n\n  def visit_binary_multiply(self):\n    pass\n\n  def visit_binary_divide(self):\n    pass\n\n  def visit_binary_modulo(self):\n    pass\n\n  def visit_binary_add(self):\n    pass\n\n  def visit_binary_subtract(self):\n    pass\n\n  def visit_binary_subscr(self):\n    pass\n\n  def visit_binary_floor_divide(self):\n    pass\n\n  def visit_binary_true_divide(self):\n    pass\n\n  def visit_inplace_floor_divide(self):\n    pass\n\n  def visit_inplace_true_divide(self):\n    pass\n\n  def visit_slice_0(self):\n    pass\n\n  def visit_slice_1(self):\n    pass\n\n  def visit_slice_2(self):\n    pass\n\n  def visit_slice_3(self):\n    pass\n\n  def visit_store_slice_0(self):\n    pass\n\n  def visit_store_slice_1(self):\n    pass\n\n  def visit_store_slice_2(self):\n    pass\n\n  def visit_store_slice_3(self):\n    pass\n\n  def visit_delete_slice_0(self):\n    pass\n\n  def visit_delete_slice_1(self):\n    pass\n\n  def visit_delete_slice_2(self):\n    pass\n\n  def visit_delete_slice_3(self):\n    pass\n\n  def visit_store_map(self):\n    pass\n\n  def visit_inplace_add(self):\n    pass\n\n  def visit_inplace_subtract(self):\n    pass\n\n  def visit_inplace_multiply(self):\n    pass\n\n  def visit_inplace_divide(self):\n    pass\n\n  def visit_inplace_modulo(self):\n    pass\n\n  def visit_store_subscr(self):\n    pass\n\n  def visit_delete_subscr(self):\n    pass\n\n  def visit_binary_lshift(self):\n    pass\n\n  def visit_binary_rshift(self):\n    pass\n\n  def visit_binary_and(self):\n    pass\n\n  def visit_binary_xor(self):\n    pass\n\n  def visit_binary_or(self):\n    pass\n\n  def visit_inplace_power(self):\n    pass\n\n  def visit_get_iter(self):\n    pass\n\n  def visit_print_expr(self):\n    pass\n\n  def visit_print_item(self):\n    pass\n\n  def visit_print_newline(self):\n    pass\n\n  def visit_print_item_to(self):\n    pass\n\n  def visit_print_newline_to(self):\n    pass\n\n  def visit_inplace_lshift(self):\n    pass\n\n  def visit_inplace_rshift(self):\n    pass\n\n  def visit_inplace_and(self):\n    pass\n\n  def visit_inplace_xor(self):\n    pass\n\n  def visit_inplace_or(self):\n    pass\n\n  def visit_break_loop(self):\n    pass\n\n  def visit_with_cleanup(self):\n    pass\n\n  def visit_load_locals(self):\n    pass\n\n  def visit_return_value(self):\n    pass\n\n  def visit_import_star(self):\n    pass\n\n  def visit_exec_stmt(self):\n    pass\n\n  def visit_yield_value(self):\n    pass\n\n  def visit_pop_block(self):\n    pass\n\n  def visit_end_finally(self):\n    pass\n\n  def visit_build_class(self):\n    pass\n\n  #\n  # Opcode with arguments bellow\n  #\n\n  def visit_store_name(self, name): # name_op\n    pass\n\n  def visit_delete_name(self, name): # name_op\n    pass\n\n  def visit_unpack_sequence(self, oparg):\n    pass\n\n  def visit_for_iter(self, jump_rel): # jrel\n    pass\n\n  def visit_list_append(self, oparg):\n    pass\n\n  def visit_store_attr(self, name): # name_op\n    pass\n\n  def visit_delete_attr(self, name): # name_op\n    pass\n\n  def visit_store_global(self, name): # name_op\n    pass\n\n  def visit_delete_global(self, name): # name_op\n    pass\n\n  def visit_dup_topx(self, oparg):\n    pass\n\n  def visit_load_const(self, constant): # hasconst\n    pass\n\n  def visit_load_name(self, name): # name_op\n    pass\n\n  def visit_build_tuple(self, oparg):\n    pass\n\n  def visit_build_list(self, oparg):\n    pass\n\n  def visit_build_set(self, oparg):\n    pass\n\n  def visit_build_map(self, oparg):\n    pass\n\n  def visit_load_attr(self, name): # name attr\n    pass\n\n  def visit_compare_op(self, compare): # hascompare\n    pass\n\n  def visit_import_name(self, name): # name_op\n    pass\n\n  def visit_import_from(self, name): # name_op\n    pass\n\n  def visit_jump_forward(self, jump_rel): # jrel\n    pass\n\n  def visit_jump_if_false_or_pop(self, jump_abs): # jabs\n    pass\n\n  def visit_jump_if_true_or_pop(self, jump_abs): # jabs\n    pass\n\n  def visit_jump_absolute(self, jump_abs): # jabs\n    pass\n\n  def visit_pop_jump_if_false(self, jump_abs): # jabs\n    pass\n\n  def visit_pop_jump_if_true(self, jump_abs): # jabs\n    pass\n\n  def visit_load_global(self, name): # name_op\n    pass\n\n  def visit_continue_loop(self, jump_abs): # jabs\n    pass\n\n  def visit_setup_loop(self, jump_rel): # jrel\n    pass\n\n  def visit_setup_except(self, jump_rel): # jrel\n    pass\n\n  def visit_setup_finally(self, jump_rel): # jrel\n    pass\n\n  def visit_load_fast(self, local): # haslocal\n    pass\n\n  def visit_store_fast(self, local): # haslocal\n    pass\n\n  def visit_delete_fast(self, local): # haslocal\n    pass\n\n  def visit_raise_varargs(self, oparg):\n    pass\n\n  def visit_call_function(self, oparg):\n    pass\n\n  def visit_make_function(self, oparg):\n    pass\n\n  def visit_build_slice(self, oparg):\n    pass\n\n  def visit_make_closure(self, oparg):\n    pass\n\n  def visit_load_closure(self, free): # hasfree\n    pass\n\n  def visit_load_deref(self, free): # hasfree\n    pass\n\n  def visit_store_deref(self, free): # hasfree\n    pass\n\n  def visit_call_function_var(self, oparg):\n    pass\n\n  def visit_call_function_kw(self, oparg):\n    pass\n\n  def visit_call_function_var_kw(self, oparg):\n    pass\n\n  def visit_setup_with(self, jump_rel): # jrel\n    pass\n\n  def visit_extended_arg(self, oparg):\n    pass\n\n  def visit_set_add(self, oparg):\n    pass\n\n  def visit_map_add(self, oparg):\n    pass\nequip/visitors/classes.py\nclass ClassVisitor(object):\n  \"\"\"\n    A class visitor that is triggered for all encountered ``TypeDeclaration``.\n\n    Example, listing all types declared in the bytecode::\n\n      class TypeDeclVisitor(ClassVisitor):\n        def __init__(self):\n          ClassVisitor.__init__(self)\n\n        def visit(self, typeDecl):\n          print \"New type: %s (parentDecl=%s)\" \\\\\n                % (typeDecl.type_name, typeDecl.parent)\n  \"\"\"\n\n  def __init__(self):\n    pass\n\n  def visit(self, typeDecl):\n    pass\nequip/bytecode/utils.py\ndef show_bytecode(bytecode, start=0, end=2**32):\n  from ..analysis.python.effects import get_stack_effect\n\n  if bytecode is None:\n    return ''\n  buffer = []\n  j = start\n  end = min(end, len(bytecode) - 1)\n  while j <= end:\n    index, lineno, op, arg, _, co = bytecode[j]\n    uid = hex(id(co))[-5:]\n\n    pop_push_str = ''\n    try:\n      pop, push = get_stack_effect(op, arg)\n      pop_push_str = ' (-%d +%d) ' % (pop, push)\n    except ValueError, ex:\n      pop_push_str = '         '\n\n    if op >= opcode.HAVE_ARGUMENT:\n      rts = repr(arg)\n      if len(rts) > 40:\n        rts = rts[:40] + '[...]'\n      jump_target = ''\n      if op in opcode.hasjrel or op in opcode.hasjabs:\n        jump_address = arg if op in opcode.hasjabs else index + arg + 3\n        jump_target = ' -------------> (%4d)' % jump_address\n\n      buffer.append(\"[%5s]%4d(%4d) %20s(%3d)%s (%s)%s\"\n                    % (uid, lineno, index, opcode.opname[op], op, pop_push_str, rts, jump_target))\n    else:\n      buffer.append(\"[%5s]%4d(%4d) %20s(%3d)%s\"\n                    % (uid, lineno, index, opcode.opname[op], op, pop_push_str))\n    j += 1\n  return '\\n'.join(buffer)\nequip/bytecode/decl.py\nclass FieldDeclaration(Declaration):\n  def __init__(self, field_name, code_object):\n    Declaration.__init__(self, Declaration.FIELD, code_object)\n    self._field_name = field_name\n\n  @property\n  def field_name(self):\n    return self._field_name\nequip/visitors/blocks.py\nclass BlockVisitor(object):\n  \"\"\"\n    A basic block visitor. It first receives the control-flow graph,\n    and then the ``visit`` method is called with all basic blocks in\n    the CFG.\n\n    The blocks are not passed to the ``visit`` method with a particular\n    order.\n  \"\"\"\n  def __init__(self):\n    self._control_flow = None\n\n  @property\n  def control_flow(self):\n    return self._control_flow\n\n  @control_flow.setter\n  def control_flow(self, value):\n    self._control_flow = value\n\n  def new_control_flow(self):\n    pass\n\n  def visit(self, block):\n    pass\nequip/bytecode/decl.py\nclass TypeDeclaration(Declaration):\n  \"\"\"\n    Represent a class declaration. It has a name, as well as a hierarchy\n    (superclass). The type contains several methods and fields, and can\n    have nested types.\n  \"\"\"\n\n  def __init__(self, type_name, code_object):\n    Declaration.__init__(self, Declaration.TYPE, code_object)\n    self._type_name = type_name\n\n    self._superclasses = set()\n    self._methods = None\n    self._fields = None\n    self._nested_types = None\n\n  @property\n  def type_name(self):\n    \"\"\"\n      Returns the name of the type.\n    \"\"\"\n    return self._type_name\n\n  @property\n  def superclasses(self):\n    return self._superclasses\n\n  def add_superclass(self, type_name):\n    self._superclasses.add(type_name)\n\n  @property\n  def methods(self):\n    \"\"\"\n      Returns a list of ``MethodDeclaration`` that belong to this type.\n    \"\"\"\n    if self._methods is None:\n      self._methods = [ f for f in self.children if f.is_method() ]\n    return self._methods\n\n  @property\n  def fields(self):\n    return self.fields\n\n  @property\n  def nested_types(self):\n    \"\"\"\n      Returns a list of ``TypeDeclaration`` that belong to this type.\n    \"\"\"\n    if self._nested_types is None:\n      self._nested_types = [ c for c in self.children if c.is_type() ]\n    return self._nested_types\n\n  def __repr__(self):\n    return 'TypeDeclaration#%d(name=%s, co=%s, super=%s)' \\\n           % (self.start_lineno, self.type_name, self.code_object, self.superclasses)\nequip/visitors/modules.py\nclass ModuleVisitor(object):\n  def __init__(self):\n    pass\n\n  def visit(self, moduleDecl):\n    pass\nequip/utils/log.py\nLOGGING_FMT = '%(asctime)s - %(levelname)3s] %(filename)s::%(funcName)s(%(lineno)d) - %(message)s'\ndef removeOtherHandlers(to_keep=None):\ndef enableLogger(to_file=None):\nequip/visitors/methods.py\nclass MethodVisitor(object):\n  \"\"\"\n    A method visitor that is triggered for all encountered ``MethodDeclaration``.\n\n    Example, listing all methods declared in the bytecode::\n\n      class MethodDeclVisitor(MethodVisitor):\n        def __init__(self):\n          MethodVisitor.__init__(self)\n\n        def visit(self, methDecl):\n          print \"New method: %s:%d (parentDecl=%s)\" \\\\\n                % (methDecl.method_name, methDecl.start_lineno, methDecl.parent)\n  \"\"\"\n  def __init__(self):\n    pass\n\n  def visit(self, methodDecl):\n    pass\n", "answers": ["    if isinstance(visitor, BytecodeVisitor):"], "length": 2071, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "f0ca080f15d553f478512eac08fa2e780178a73fa091b569"}
{"input": "import logging\nimport operator\nimport pytest\nfrom bloop.conditions import ConditionRenderer\nfrom bloop.exceptions import InvalidModel, InvalidStream\nfrom bloop.models import (\n    BaseModel,\n    Column,\n    GlobalSecondaryIndex,\n    IMeta,\n    Index,\n    LocalSecondaryIndex,\n    bind_column,\n    bind_index,\n    model_created,\n    object_modified,\n    unbind,\n    unpack_from_dynamodb,\n)\nfrom bloop.types import (\n    UUID,\n    Boolean,\n    DateTime,\n    Integer,\n    String,\n    Timestamp,\n    Type,\n)\nfrom ..helpers.models import User, VectorModel\n        other = Column(Integer)\n        by_other = GlobalSecondaryIndex(projection=\"all\", hash_key=\"other\")\n    obj = Model(by_other=2)\n    assert not hasattr(obj, \"by_other\")\n\n    with pytest.raises(AttributeError) as excinfo:\n        getattr(obj, \"by_other\")\n    assert \"Model.by_other\" in str(excinfo.value)\n\n    with pytest.raises(AttributeError) as excinfo:\n        setattr(obj, \"by_other\", \"value\")\n    assert \"Model.by_other\" in str(excinfo.value)\n\n    with pytest.raises(AttributeError) as excinfo:\n        delattr(obj, \"by_other\")\n    assert \"Model.by_other\" in str(excinfo.value)\n\n\ndef test_lsi_specifies_hash_key():\n    with pytest.raises(InvalidModel):\n        LocalSecondaryIndex(hash_key=\"blah\", range_key=\"foo\", projection=\"keys\")\n\n\ndef test_lsi_init_throughput():\n    \"\"\"Can't set throughput when creating an LSI\"\"\"\n    with pytest.raises(InvalidModel):\n        LocalSecondaryIndex(range_key=\"range\", projection=\"keys\", write_units=1)\n\n    with pytest.raises(InvalidModel):\n        LocalSecondaryIndex(range_key=\"range\", projection=\"keys\", read_units=1)\n\n\ndef test_lsi_delegates_throughput():\n    \"\"\"LSI read_units, write_units delegate to model.Meta\"\"\"\n    class Model(BaseModel):\n        name = Column(String, hash_key=True)\n        other = Column(String, range_key=True)\n        joined = Column(String)\n        by_joined = LocalSecondaryIndex(range_key=\"joined\", projection=\"keys\")\n\n    meta = Model.Meta\n    lsi = Model.by_joined\n\n    # Getters pass through\n    meta.write_units = \"meta.write_units\"\n    meta.read_units = \"meta.read_units\"\n    assert lsi.write_units == meta.write_units\n    assert lsi.read_units == meta.read_units\n\n    # Setters pass through\n    lsi.write_units = \"lsi.write_units\"\n    lsi.read_units = \"lsi.read_units\"\n    assert lsi.write_units == meta.write_units\n    assert lsi.read_units == meta.read_units\n\n\ndef test_gsi_default_throughput():\n    \"\"\"When not specified, GSI read_units and write_units are None\"\"\"\n    class Model(BaseModel):\n        name = Column(String, hash_key=True)\n        other = Column(String)\n        by_joined = GlobalSecondaryIndex(hash_key=\"other\", projection=\"keys\")\n    gsi = Model.by_joined\n    assert gsi.read_units is gsi.write_units is None\n\n\n@pytest.mark.parametrize(\"projection\", [\"all\", \"keys\", [\"foo\"]])\ndef test_index_repr(projection):\n    index = Index(projection=projection, dynamo_name=\"f\")\n    index.model = User\n    index._name = \"by_foo\"\n    if isinstance(projection, list):\n        projection = \"include\"\n    assert repr(index) == \"<Index[User.by_foo={}]>\".format(projection)\n\n\ndef test_lsi_repr():\n    index = LocalSecondaryIndex(projection=\"all\", range_key=\"key\", dynamo_name=\"f\")\n    index.model = User\n    index._name = \"by_foo\"\n    assert repr(index) == \"<LSI[User.by_foo=all]>\"\n\n\ndef test_gsi_repr():\n    index = GlobalSecondaryIndex(projection=\"all\", hash_key=\"key\", dynamo_name=\"f\")\n    index.model = User\n    index._name = \"by_foo\"\n    assert repr(index) == \"<GSI[User.by_foo=all]>\"\n\n\n# END INDEX ================================================================================================= END INDEX\n\n\n# BINDING ===================================================================================================== BINDING\n\n\ndef new_abstract_model(indexes=False):\n    class MyModel(BaseModel):\n        class Meta(IMeta):\n            abstract = True\n        data = Column(String, dynamo_name=\"dynamo-data\")\n        if indexes:\n            my_index_hash = Column(Integer, hash_key=True)\n            by_data = GlobalSecondaryIndex(\n                projection=\"all\", hash_key=\"data\", dynamo_name=\"dynamo-by-data\")\n            email = Column(String, range_key=True)\n            by_email = LocalSecondaryIndex(projection=\"all\", range_key=data)\n    return MyModel\n\n\ndef test_bind_non_model():\n    \"\"\"bind_column, bind_index take subclass of Model\"\"\"\n    column = Column(String, dynamo_name=\"other\")\n    index = GlobalSecondaryIndex(projection=\"keys\", hash_key=\"foo\")\n\n    class NotAModel:\n        class Meta:\n            pass\n\n    with pytest.raises(InvalidModel):\n", "context": "bloop/types.py\nclass Boolean(Type):\n    python_type = bool\n    backing_type = BOOLEAN\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\nbloop/types.py\nclass String(Type):\n    python_type = str\n    backing_type = STRING\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if not value:\n            return \"\"\n        return value\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if not value:\n            return None\n        return value\nbloop/models.py\nclass IMeta:\nclass BaseModel:\n    class Meta(IMeta):\nclass Index:\nclass GlobalSecondaryIndex(Index):\nclass LocalSecondaryIndex(Index):\nclass Column(ComparisonMixin):\n    class UNBOUND:\n        class Meta(IMeta):\n    def __init__(self, **attrs):\n    def __init_subclass__(cls: type, **kwargs):\n    def __repr__(self):\n    def __init__(self, *, projection, hash_key=None, range_key=None, dynamo_name=None, **kwargs):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\n    def hash_key(self):\n    def range_key(self):\n    def keys(self):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __init__(\n            self, *, projection,\n            hash_key, range_key=None,\n            read_units=None, write_units=None,\n            dynamo_name=None, **kwargs):\n    def __init__(self, *, projection, range_key, dynamo_name=None, strict=True, **kwargs):\n    def hash_key(self):\n    def read_units(self):\n    def read_units(self, value):\n    def write_units(self):\n    def write_units(self, value):\n    def __init__(self, typedef, hash_key=False, range_key=False, dynamo_name=None, default=missing):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\ndef subclassof(obj, classinfo):\ndef instanceof(obj, classinfo):\ndef loaded_columns(obj: BaseModel):\ndef unpack_from_dynamodb(*, attrs, expected, model=None, obj=None, engine=None, context=None, **kwargs):\ndef validate_projection(projection):\ndef validate_stream(meta):\ndef validate_encryption(meta):\ndef validate_backups(meta):\ndef validate_billing(meta):\ndef validate_ttl(meta):\ndef unbound_repr(obj):\ndef setdefault(obj, field, default):\ndef ensure_hash(cls) -> None:\ndef initialize_meta(cls: type):\ndef bind_column(model, name, column, force=False, recursive=False, copy=False) -> Column:\ndef bind_index(model, name, index, force=False, recursive=True, copy=False) -> Index:\ndef refresh_index(meta, index) -> None:\ndef unbind(meta, name=None, dynamo_name=None) -> None:\nbloop/types.py\nclass Integer(Number):\n    \"\"\"Truncates values when loading or dumping.\n\n    For example, ``3.14`` in DynamoDB is loaded as ``3``. If a value is ``7.5``\n    locally, it's stored in DynamoDB as ``7``.\n    \"\"\"\n    python_type = int\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        number = super().dynamo_load(value, context=context, **kwargs)\n        return int(number)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = int(value)\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/types.py\nclass UUID(String):\n    python_type = uuid.UUID\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return uuid.UUID(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return str(value)\nbloop/exceptions.py\nclass InvalidModel(BloopException, ValueError):\n    \"\"\"This is not a valid Model.\"\"\"\ntests/helpers/models.py\nclass User(BaseModel):\n    id = Column(String, hash_key=True)\n    age = Column(Integer)\n    name = Column(String)\n    email = Column(String)\n    joined = Column(DateTime, dynamo_name=\"j\")\n    by_email = GlobalSecondaryIndex(hash_key=\"email\", projection=\"all\")\nbloop/types.py\nclass Type:\n    \"\"\"Abstract base type.\"\"\"\n\n    python_type = None\n    backing_type = None\n\n    def supports_operation(self, operation: str) -> bool:\n        \"\"\"\n        Used to ensure a conditional operation is supported by this type.\n\n        By default, uses a hardcoded table of operations that maps to each backing DynamoDB type.\n\n        You can override this method to implement your own conditional operators, or to dynamically\n        adjust which operations your type supports.\n        \"\"\"\n        return operation in OPERATION_SUPPORT_BY_TYPE[self.backing_type]\n\n    def __init__(self):\n        if not hasattr(self, \"inner_typedef\"):\n            self.inner_typedef = self\n        super().__init__()\n\n    def __getitem__(self, key):\n        raise RuntimeError(f\"{self!r} does not support document paths\")\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        \"\"\"Converts a local value into a DynamoDB value.\n\n        For example, to store a string enum as an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors.index(value.lower())\n        \"\"\"\n        raise NotImplementedError\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        \"\"\"Converts a DynamoDB value into a local value.\n\n        For example, to load a string enum from an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors[value]\n        \"\"\"\n        raise NotImplementedError\n\n    def _dump(self, value, **kwargs):\n        \"\"\"Entry point for serializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_dump`.\n\n        This wraps the return value of :func:`~bloop.types.Type.dynamo_dump` in DynamoDB's wire format.\n        For example, serializing a string enum to an int:\n\n        .. code-block:: python\n\n            value = \"green\"\n            # dynamo_dump(\"green\") = 2\n            _dump(value) == {\"N\": 2}\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_dump`.  This can happen when dumping eg. a sparse\n        :class:`~.bloop.types.Map`, or a missing (not set) value.\n        \"\"\"\n        wrapped = actions.wrap(value)\n        value = self.dynamo_dump(wrapped.value, **kwargs)\n        if value is None:\n            return actions.wrap(None)\n        else:\n            value = {self.backing_type: value}\n            return wrapped.type.new_action(value)\n\n    def _load(self, value, **kwargs):\n        \"\"\"Entry point for deserializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_load`.\n\n        This unpacks DynamoDB's wire format and calls :func:`~bloop.types.Type.dynamo_load` on the inner value.\n        For example, deserializing an int to a string enum:\n\n        .. code-block:: python\n\n            value = {\"N\": 2}\n            # dynamo_load(2) = \"green\"\n            _load(value) == \"green\"\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_load`.  This can happen when loading eg. a sparse :class:`~bloop.types.Map`.\n        \"\"\"\n        if value is not None:\n            value = next(iter(value.values()))\n        return self.dynamo_load(value, **kwargs)\n\n    def __repr__(self):\n        # Render class python types by name\n        python_type = self.python_type\n        if isinstance(python_type, type):\n            python_type = python_type.__name__\n\n        return \"<{}[{}:{}]>\".format(\n            self.__class__.__name__,\n            self.backing_type, python_type\n        )\nbloop/types.py\nclass Timestamp(Integer):\n    \"\"\"Stores the unix (epoch) time in seconds.  Milliseconds are truncated to 0 on load and save.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(Timestamp)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import Timestamp  # becomes:\n            from bloop.ext.pendulum import Timestamp\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = super().dynamo_load(value, context=context, **kwargs)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return datetime.datetime.fromtimestamp(value, tz=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        value = value.timestamp()\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/types.py\nclass DateTime(String):\n    \"\"\"Always stored in DynamoDB using the :data:`~bloop.types.FIXED_ISO8601_FORMAT` format.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(DateTime)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import DateTime  # becomes:\n            from bloop.ext.pendulum import DateTime\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        dt = datetime.datetime.strptime(value, FIXED_ISO8601_FORMAT)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return dt.replace(tzinfo=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        dt = value.astimezone(tz=datetime.timezone.utc)\n        return dt.strftime(FIXED_ISO8601_FORMAT)\ntests/helpers/models.py\nclass VectorModel(BaseModel):\n    name = Column(String, hash_key=True)\n    list_str = Column(List(String))\n    set_str = Column(Set(String))\n    map_nested = Column(Map(**{\n        \"bytes\": Binary,\n        \"str\": String,\n        \"map\": Map(**{\n            \"int\": Integer,\n            \"str\": String\n        })\n    }))\n    some_int = Column(Integer)\n    some_bytes = Column(Binary)\nbloop/conditions.py\nclass ConditionRenderer:\n    # noinspection PyUnresolvedReferences\n    \"\"\"Renders collections of :class:`~bloop.conditions.BaseCondition` into DynamoDB's wire format for expressions,\n    including:\n\n    * ``\"ConditionExpression\"`` -- used in conditional operations\n    * ``\"FilterExpression\"`` -- used in queries and scans to ignore results that don't match the filter\n    * ``\"KeyConditionExpressions\"`` -- used to describe a query's hash (and range) key(s)\n    * ``\"ProjectionExpression\"`` -- used to include a subset of possible columns in the results of a query or scan\n    * ``\"UpdateExpression\"`` -- used to save objects\n\n    Normally, you will only need to call :func:`~bloop.conditions.ConditionRenderer.render` to handle any combination\n    of conditions.  You can also call each individual ``render_*`` function to control how multiple conditions of\n    each type are applied.\n\n    You can collect the rendered condition at any time through :attr:`~bloop.conditions.ConditionRenderer.rendered`.\n\n    .. code-block:: python\n\n        >>> renderer.render(obj=user, atomic=True)\n        >>> renderer.output\n        {'ConditionExpression': '((#n0 = :v1) AND (attribute_not_exists(#n2)) AND (#n4 = :v5))',\n         'ExpressionAttributeNames': {'#n0': 'age', '#n2': 'email', '#n4': 'id'},\n         'ExpressionAttributeValues': {':v1': {'N': '3'}, ':v5': {'S': 'some-user-id'}}}\n\n\n    :param engine: Used to dump values in conditions into the appropriate wire format.\n    :type engine: :class:`~bloop.engine.Engine`\n    \"\"\"\n    def __init__(self, engine):\n        self.refs = ReferenceTracker(engine)\n        self.engine = engine\n        self.expressions = {}\n\n    def render(self, obj=None, condition=None, update=False, filter=None, projection=None, key=None):\n        \"\"\"Main entry point for rendering multiple expressions.  All parameters are optional, except obj when\n        atomic or update are True.\n\n        :param obj: *(Optional)* An object to render an atomic condition or update expression for.  Required if\n            update or atomic are true.  Default is False.\n        :param condition: *(Optional)* Rendered as a \"ConditionExpression\" for a conditional operation.\n            If atomic is True, the two are rendered in an AND condition.  Default is None.\n        :type condition: :class:`~bloop.conditions.BaseCondition`\n        :param bool update: *(Optional)*  True if an \"UpdateExpression\" should be rendered for ``obj``.\n            Default is False.\n        :param filter: *(Optional)* A filter condition for a query or scan, rendered as a \"FilterExpression\".\n            Default is None.\n        :type filter: :class:`~bloop.conditions.BaseCondition`\n        :param projection: *(Optional)* A set of Columns to include in a query or scan, rendered as a\n            \"ProjectionExpression\".  Default is None.\n        :type projection: set :class:`~bloop.models.Column`\n        :param key: *(Optional)* A key condition for queries, rendered as a \"KeyConditionExpression\".  Default is None.\n        :type key: :class:`~bloop.conditions.BaseCondition`\n        \"\"\"\n        if update and not obj:\n            raise InvalidCondition(\"An object is required to render updates.\")\n\n        if filter:\n            self.filter_expression(filter)\n\n        if projection:\n            self.projection_expression(projection)\n\n        if key:\n            self.key_expression(key)\n\n        # Condition requires a bit of work, because either one can be empty/false\n        if condition:\n            self.condition_expression(condition)\n\n        if update:\n            self.update_expression(obj)\n\n    def condition_expression(self, condition):\n        self.expressions[\"ConditionExpression\"] = condition.render(self)\n\n    def filter_expression(self, condition):\n        self.expressions[\"FilterExpression\"] = condition.render(self)\n\n    def key_expression(self, condition):\n        self.expressions[\"KeyConditionExpression\"] = condition.render(self)\n\n    def projection_expression(self, columns):\n        included = set()\n        ref_names = []\n        for column in columns:\n            if column in included:\n                continue\n            included.add(column)\n            ref = self.refs.any_ref(column=column)\n            ref_names.append(ref.name)\n        self.expressions[\"ProjectionExpression\"] = \", \".join(ref_names)\n\n    def update_expression(self, obj):\n        updates = {\n            ActionType.Add: [],\n            ActionType.Delete: [],\n            ActionType.Remove: [],\n            ActionType.Set: [],\n        }\n        for column in sorted(\n                # Don't include key columns in an UpdateExpression\n                filter(lambda c: c not in obj.Meta.keys, global_tracking[obj]),\n                key=lambda c: c.dynamo_name):\n            name_ref = self.refs.any_ref(column=column)\n            value_ref = self.refs.any_ref(column=column, value=getattr(obj, column.name, None))\n            update_type = value_ref.action.type\n            # Can't set to an empty value, force to a Remove\n            if is_empty(value_ref) or update_type is ActionType.Remove:\n                self.refs.pop_refs(value_ref)\n                update_type = ActionType.Remove\n                value_ref = None\n            updates[update_type].append((name_ref, value_ref))\n\n        expressions = []\n        for update_type, refs in updates.items():\n            if not refs:\n                continue\n            k = update_type.wire_key.upper()\n            r = update_type.render\n            expressions.append(f\"{k} \" + \", \".join(r(*ref) for ref in refs))\n        if expressions:\n            self.expressions[\"UpdateExpression\"] = \" \".join(e.strip() for e in expressions)\n\n    @property\n    def output(self):\n        \"\"\"The wire format for all conditions that have been rendered.\n        A new :class:`~bloop.conditions.ConditionRenderer` should be used for each operation.\"\"\"\n        expressions = {k: v for (k, v) in self.expressions.items() if v is not None}\n        if self.refs.attr_names:\n            expressions[\"ExpressionAttributeNames\"] = self.refs.attr_names\n        if self.refs.attr_values:\n            expressions[\"ExpressionAttributeValues\"] = self.refs.attr_values\n        return expressions\nbloop/exceptions.py\nclass InvalidStream(BloopException, ValueError):\n    \"\"\"This is not a valid stream definition.\"\"\"\n", "answers": ["        bind_column(NotAModel, \"c\", column)"], "length": 2265, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "575cb85f0d0daced2e3372a6afa034adfcf4a6545208c89c"}
{"input": "import org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\nimport peapod.classes.AnnotatedClassTest;\nimport peapod.inheritance.InheritanceTest;\nimport peapod.linkededge.LinkedEdgeTest;\nimport peapod.linkedvertex.LinkedVertexTest;\nimport peapod.manytomany.ManyToManyTest;\nimport peapod.manytomanyedge.ManyToManyEdgeTest;\nimport peapod.manytoone.ManyToOneTest;\nimport peapod.multiproperties.MultiPropertiesTest;\nimport peapod.property.DatePropertyTest;\nimport peapod.property.PropertyTest;\nimport peapod.vertexproperty.VertexPropertyTest;\n/*\n * Copyright 2015-Bay of Many\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n *\n * This project is derived from code in the TinkerPop project under the following licenses:\n *\n * TinkerPop3\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the TinkerPop nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL TINKERPOP BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage peapod;\n\n\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        AnnotatedClassTest.class,\n        DatePropertyTest.class,\n        InheritanceTest.class,\n        FramedElementTest.class,\n        FramedGraphTest.class,", "context": "core/src/test/java/peapod/vertexproperty/VertexPropertyTest.java\npublic class VertexPropertyTest extends GraphTest {\n\n    private Person alice;\n    private Vertex v;\n\n    @Before\n    public void init() {\n        assumeTrue(g.features().vertex().supportsMetaProperties());\n        assumeTrue(g.features().vertex().supportsMultiProperties());\n\n        v = g.addVertex(T.label, \"Person\", \"name\", \"Alice\");\n        v.property(VertexProperty.Cardinality.list, \"location\", \"Brussels\", \"startTime\", 2010, \"endTime\", 2012);\n        v.property(VertexProperty.Cardinality.list, \"location\", \"Antwerp\", \"startTime\", 2012);\n\n        FramedGraph graph = new FramedGraph(g, Person.class.getPackage());\n        this.alice = graph.v(v.id());\n    }\n\n    @Test\n    public void testGetLocations() {\n        assertThat(alice.getLocations().stream().map(Location::getValue).toArray(), arrayContainingInAnyOrder(\"Brussels\", \"Antwerp\"));\n    }\n\n    @Test\n    public void testGetLocation() {\n        Location brussels = alice.getLocation(\"Brussels\");\n        assertEquals(\"Brussels\", brussels.getValue());\n        assertEquals(new Integer(2010), brussels.getStartTime());\n        assertEquals(new Integer(2012), brussels.getEndTime());\n\n        Location antwerp = alice.getLocation(\"Antwerp\");\n        assertEquals(\"Antwerp\", antwerp.getValue());\n        assertEquals(new Integer(2012), antwerp.getStartTime());\n        assertNull(antwerp.getEndTime());\n    }\n\n    @Test\n    public void testAddLocation() {\n        Location location = alice.addLocation(\"London\");\n        assertEquals(\"London\", location.getValue());\n\n        location.setStartTime(2015);\n\n        Iterator<VertexProperty<String>> it = v.properties(\"location\");\n        VertexProperty london = null;\n        while (it.hasNext()) {\n            VertexProperty property = it.next();\n            if (property.value().equals(\"London\")) {\n                london = property;\n            }\n        }\n        assertNotNull(\"London\", london);\n        assertEquals(new Integer(2015), london.value(\"startTime\"));\n    }\n\n    @Test\n    public void testRemoveLocation() {\n        alice.removeLocation(\"Brussels\");\n        assertFalse(Lists.newArrayList(v.values(\"location\")).contains(\"Brussels\"));\n    }\n}\ncore/src/test/java/peapod/classes/AnnotatedClassTest.java\npublic class AnnotatedClassTest extends GraphTest {\n\n    private Person alice;\n    private Person bob;\n    private Person charlie;\n\n    @Before\n    public void init() {\n        Vertex alice = g.addVertex(T.label, \"Person\", \"p-name\", \"alice\");\n        Vertex bob = g.addVertex(T.label, \"Person\", \"p-name\", \"bob\");\n        Vertex charlie = g.addVertex(T.label, \"Person\", \"p-name\", \"charlie\");\n\n        alice.addEdge(\"e-friend\", bob);\n\n        FramedGraph graph = new FramedGraph(g, Person.class.getPackage());\n        this.alice = graph.v(alice.id());\n        this.bob = graph.v(bob.id());\n        this.charlie = graph.v(charlie.id());\n    }\n\n    @Test\n    public void testGetProperty() {\n        assertEquals(\"alice\", alice.getName());\n    }\n\n    @Test\n    public void testSetProperty() {\n        alice.setName(\"diane\");\n        assertEquals(\"diane\", alice.vertex().value(\"p-name\"));\n    }\n\n    @Test\n    public void testGetList() {\n        assertEquals(1, alice.getFriends().size());\n    }\n\n    @Test\n    public void testAdd() {\n        alice.addFriend(charlie);\n        List<Vertex> f = out(alice.vertex(), \"e-friend\");\n        assertThat(f, containsInAnyOrder(bob.vertex(), charlie.vertex()));\n    }\n\n    @Test\n    public void testRemove() {\n        alice.removeFriend(bob);\n        assertTrue(alice.out(\"e-friend\").toList().isEmpty());\n    }\n}\ncore/src/test/java/peapod/multiproperties/MultiPropertiesTest.java\npublic class MultiPropertiesTest extends GraphTest {\n\n    private Person alice;\n    private Vertex v;\n\n    @Before\n    public void init() {\n        assumeTrue(g.features().vertex().supportsMultiProperties());\n\n        v = g.addVertex(T.label, \"Person\", \"firstName\", \"Alice\", \"firstName\", \"Alicia\");\n\n        FramedGraph graph = new FramedGraph(g, Person.class.getPackage());\n        alice = graph.v(v.id());\n    }\n\n    @Test\n    public void testGetNames() {\n        assertThat(alice.getFirstNames(), containsInAnyOrder(\"Alice\", \"Alicia\"));\n    }\n\n    @Test\n    public void testAddName() {\n        alice.addFirstName(\"Allison\");\n        assertThat(Lists.newArrayList(v.values(\"firstName\")), containsInAnyOrder(\"Alice\", \"Alicia\", \"Allison\"));\n    }\n\n    @Test\n    public void testRemoveName() {\n        alice.removeFirstName(\"Alicia\");\n        assertThat(Lists.newArrayList(v.values(\"firstName\")), containsInAnyOrder(\"Alice\"));\n    }\n\n\n}\ncore/src/test/java/peapod/manytomanyedge/ManyToManyEdgeTest.java\npublic class ManyToManyEdgeTest extends GraphTest {\n\n    private Person alice;\n    private Person bob;\n    private Person charlie;\n\n    @Before\n    public void init() {\n        Vertex alice = g.addVertex(T.label, \"Person\", \"name\", \"alice\");\n        Vertex bob = g.addVertex(T.label, \"Person\", \"name\", \"bob\");\n        Vertex charlie = g.addVertex(T.label, \"Person\", \"name\", \"charlie\");\n\n        alice.addEdge(\"friend\", bob);\n\n        FramedGraph graph = new FramedGraph(g, Person.class.getPackage());\n        this.alice = graph.v(alice.id());\n        this.bob = graph.v(bob.id());\n        this.charlie = graph.v(charlie.id());\n    }\n\n    @Test\n    public void testGetList() {\n        assertEquals(1, alice.getFriends().size());\n    }\n\n    @Test\n    public void testGetFiltered() {\n        Friend friend = alice.getFriend(bob);\n        assertNotNull(friend);\n        assertEquals(bob, friend.getFriend());\n    }\n\n\n    @Test\n    public void testAdd() {\n        Friend friend = alice.addFriend(charlie);\n        assertNotNull(friend);\n\n        assertEquals(alice, friend.getPerson());\n        assertEquals(charlie, friend.getFriend());\n\n        List<Vertex> f = out(alice.vertex(), \"friend\");\n        assertThat(f, containsInAnyOrder(bob.vertex(), charlie.vertex()));\n    }\n\n    @Test\n    public void testRemove() {\n        Friend friend = alice.getFriends().get(0);\n        alice.removeFriend(friend);\n        assertTrue(alice.out(\"friend\").toList().isEmpty());\n    }\n}\ncore/src/test/java/peapod/linkededge/LinkedEdgeTest.java\npublic class LinkedEdgeTest extends GraphTest {\n\n    private Person alice;\n    private Person bob;\n    private Person charlie;\n\n    @Before\n    public void init() {\n        Vertex alice = g.addVertex(T.label, \"Person\", \"value\", \"alice\");\n        Vertex bob = g.addVertex(T.label, \"Person\", \"value\", \"bob\");\n        Vertex charlie = g.addVertex(T.label, \"Person\", \"value\", \"charlie\");\n        alice.addEdge(\"friend\", bob, \"startYear\", 2004);\n        alice.addEdge(\"friend\", charlie, \"startYear\", 2012);\n\n        FramedGraph graph = new FramedGraph(g, Person.class.getPackage());\n        this.alice = graph.v(alice.id());\n        this.bob = graph.v(bob.id());\n        this.charlie = graph.v(charlie.id());\n    }\n\n    @Test\n    public void testLinkedEdgeDefault() {\n        assertEquals(2, alice.getFriendsWithAnnotationDefault().size());\n\n        Optional<Friend> friendBob = alice.getFriendsWithAnnotationDefault().stream().filter(f -> f.getFriend().equals(bob)).findFirst();\n        assertTrue(friendBob.isPresent());\n        assertEquals(2004, friendBob.get().getStartYear());\n\n        assertEquals(bob, friendBob.get().getFriend());\n        assertEquals(0, bob.getFriendsWithAnnotationDefault().size());\n    }\n\n    @Test\n    public void testLinkedEdgeAnnotationOut() {\n        List<Person> friends = alice.getFriendsWithAnnotationOut().stream().map(Friend::getFriend).collect(Collectors.toList());\n        assertThat(friends, containsInAnyOrder(bob, charlie));\n\n        friends = bob.getFriendsWithAnnotationOut().stream().map(Friend::getFriend).collect(Collectors.toList());\n        assertThat(friends, empty());\n    }\n\n    @Test\n    public void testLinkedEdgeAnnotationIn() {\n        List<Person> friends = bob.getFriendsWithAnnotationIn().stream().map(Friend::getPerson).collect(Collectors.toList());\n        assertThat(friends, containsInAnyOrder(alice));\n\n        friends = alice.getFriendsWithAnnotationIn().stream().map(Friend::getPerson).collect(Collectors.toList());\n        assertThat(friends, empty());\n    }\n\n    @Test\n    public void testLinkedEdgeAnnotationBoth() {\n        List<Person> friends = bob.getFriendsWithAnnotationBoth().stream().map(Friend::getPerson).collect(Collectors.toList());\n        assertThat(friends, containsInAnyOrder(alice));\n\n        friends = alice.getFriendsWithAnnotationBoth().stream().map(Friend::getFriend).collect(Collectors.toList());\n        assertThat(friends, containsInAnyOrder(bob, charlie));\n    }\n\n}\ncore/src/test/java/peapod/inheritance/InheritanceTest.java\npublic class InheritanceTest extends GraphTest {\n\n    private FramedGraph graph;\n    private Vertex vertex;\n\n    @Before\n    public void init() {\n        g.addVertex(T.label, \"Person\", \"name\", \"alice\");\n        vertex = g.addVertex(T.label, \"Programmer\", \"name\", \"bob\", \"yearsExperience\", 10);\n\n        Vertex v1 = g.addVertex(T.label, \"Dog\", \"name\", \"Shepherd\", \"numberOfLegs\", 4, \"hairColor\", \"brown\");\n        g.addVertex(T.label, \"Mammal\", \"name\", \"Tiger\", \"numberOfLegs\", 4);\n        g.addVertex(T.label, \"Salmon\", \"name\", \"Atlantic Salmon\", \"numberOfLegs\", 0, \"saltWater\", true);\n        g.addVertex(T.label, \"Fish\", \"name\", \"Goldfish\", \"numberOfLegs\", 0, \"saltWater\", false);\n        Vertex v2 = g.addVertex(T.label, \"GOM\", \"name\", \"WeirdAnimal\", \"numberOfLegs\", 2, \"saltWater\", true);\n\n        v2.addEdge(\"relatedto\", v1, \"relation\", \"same color\");\n\n        graph = new FramedGraph(g, Person.class.getPackage());\n    }\n\n    @Test\n    public void testFind() {\n        List<Person> persons = graph.V(Person.class).toList();\n        assertEquals(2, persons.size());\n        assertEquals(1, persons.stream().filter(p -> p instanceof Programmer).count());\n    }\n\n    @Test\n    public void testLoad() {\n        Person person = graph.v(vertex.id());\n        assertTrue(person instanceof Programmer);\n        assertEquals(10, ((Programmer) person).getYearsExperience());\n    }\n\n    @Test\n    public void testFindWithInterfaces() {\n        assertEquals(5, graph.V(Animal.class).toList().size());\n        assertEquals(3, graph.V(Mammal.class).toList().size());\n        assertEquals(3, graph.V(Fish.class).toList().size());\n        assertEquals(2, graph.V(Salmon.class).toList().size());\n        assertEquals(2, graph.V(Dog.class).toList().size());\n\n        Dog dog = graph.V(Dog.class).has(\"name\", \"Shepherd\").next();\n        assertEquals(4, dog.getNumberOfLegs());\n        assertEquals(\"brown\", dog.getHairColor());\n\n        Salmon salmon = graph.V(Salmon.class).has(\"name\", \"Atlantic Salmon\").next();\n        assertEquals(0, salmon.getNumberOfLegs());\n        assertTrue(salmon.getSaltWater());\n\n        Fish fish = graph.V(Fish.class).has(\"saltWater\", false).next();\n        assertEquals(\"Goldfish\", fish.getName());\n\n        Animal gom = graph.V(Animal.class).has(\"name\", \"WeirdAnimal\").next();\n        assertTrue(gom instanceof GeneticallyModifiedOrganism);\n\n        assertEquals(1, gom.getRelatedTo().size());\n        RelatedTo relatedTo = gom.getRelatedTo().get(0);\n        assertEquals(gom, relatedTo.getMe());\n        assertEquals(dog, relatedTo.getOther());\n        assertEquals(\"same color\", relatedTo.getRelation());\n    }\n\n}\ncore/src/test/java/peapod/property/PropertyTest.java\npublic class PropertyTest extends GraphTest {\n\n    private Person p;\n    private Vertex v;\n\n    @Before\n    public void init() {\n        v = g.addVertex(T.label, \"Person\",\n                \"s\", \"hello\",\n                \"b1\", true, \"b2\", true,\n                \"s1\", (short) 42, \"s2\", (short) 43,\n                \"i1\", 42, \"i2\", 43,\n                \"l1\", 42L, \"l2\", 43L,\n                \"f1\", 42.0f, \"f2\", 43.0f,\n                \"d1\", 42.0d, \"d2\", 43.0d,\n                \"c1\", 'a', \"c2\", 'b',\n                \"by1\", (byte) 0x11, \"by2\", (byte) 0x21);\n\n        FramedGraph graph = new FramedGraph(g, Person.class.getPackage());\n        p = graph.v(v.id());\n    }\n\n    @Test\n    public void testGetString() {\n        assertEquals(\"hello\", p.getS());\n    }\n\n    @Test\n    public void testSetString() {\n        p.setS(\"goodbye\");\n        assertEquals(\"goodbye\", p.getS());\n        assertEquals(\"goodbye\", v.value(\"s\"));\n    }\n\n    @Test\n    public void testSetStringNull() {\n        p.setS(null);\n        assertEquals(null, p.getS());\n        assertFalse(v.property(\"s\").isPresent());\n    }\n\n    @Test\n    public void testSetDateNull() {\n        p.setDate(null);\n        assertEquals(null, p.getDate());\n        assertFalse(v.property(\"date\").isPresent());\n    }\n\n    @Test\n    public void testGetBoolean() {\n        assertEquals(TRUE, p.getB1());\n    }\n\n    @Test\n    public void testSetBoolean() {\n        p.setB1(false);\n        assertEquals(FALSE, p.getB1());\n        assertEquals(FALSE, v.value(\"b1\"));\n    }\n\n    @Test\n    public void testSetBooleanNull() {\n        p.setB1(null);\n        assertEquals(null, p.getB1());\n        assertFalse(v.property(\"b1\").isPresent());\n    }\n\n    @Test\n    public void testGetPrimitiveBoolean() {\n        assertEquals(true, p.getB2());\n    }\n\n    @Test\n    public void testSetPrimitiveBoolean() {\n        p.setB2(false);\n        assertEquals(false, p.getB2());\n        assertTrue(v.property(\"b2\").isPresent());\n        assertEquals(FALSE, v.value(\"b2\"));\n    }\n\n    @Test\n    public void testGetShort() {\n        assertEquals(new Short((short) 42), p.getS1());\n    }\n\n    @Test\n    public void testSetShort() {\n        p.setS1((short) 142);\n        assertEquals(new Short((short) 142), p.getS1());\n        assertEquals(new Short((short) 142), v.value(\"s1\"));\n    }\n\n    @Test\n    public void testSetShortNull() {\n        p.setS1(null);\n        assertEquals(null, p.getS1());\n        assertFalse(v.property(\"s1\").isPresent());\n    }\n\n    @Test\n    public void testGetPrimitiveShort() {\n        assertEquals(43, p.getS2());\n    }\n\n    @Test\n    public void testSetPrimitiveShort() {\n        p.setS2((short) 143);\n        assertEquals(143, p.getS2());\n        assertTrue(v.property(\"s2\").isPresent());\n        assertEquals(new Short((short) 143), v.value(\"s2\"));\n    }\n\n    @Test\n    public void testGetInteger() {\n        assertEquals(new Integer(42), p.getI1());\n    }\n\n    @Test\n    public void testSetInteger() {\n        p.setI1(142);\n        assertEquals(new Integer(142), p.getI1());\n        assertEquals(new Integer(142), v.value(\"i1\"));\n    }\n\n    @Test\n    public void testSetIntegerNull() {\n        p.setI1(null);\n        assertEquals(null, p.getI1());\n        assertFalse(v.property(\"i1\").isPresent());\n    }\n\n    @Test\n    public void testGetPrimitiveInteger() {\n        assertEquals(43, p.getI2());\n    }\n\n    @Test\n    public void testSetPrimitiveInteger() {\n        p.setI2(143);\n        assertEquals(143, p.getI2());\n        assertTrue(v.property(\"i2\").isPresent());\n        assertEquals(new Integer(143), v.value(\"i2\"));\n    }\n\n    @Test\n    public void testGetLong() {\n        assertEquals(new Long(42L), p.getL1());\n    }\n\n    @Test\n    public void testSetLong() {\n        p.setL1(142L);\n        assertEquals(new Long(142), p.getL1());\n        assertEquals(new Long(142), v.value(\"l1\"));\n    }\n\n    @Test\n    public void testSetLongNull() {\n        p.setL1(null);\n        assertEquals(null, p.getL1());\n        assertFalse(v.property(\"l1\").isPresent());\n    }\n\n    @Test\n    public void testGetPrimitiveLong() {\n        assertEquals(43L, p.getL2());\n    }\n\n    @Test\n    public void testSetPrimitiveLong() {\n        p.setL2(143L);\n        assertEquals(143L, p.getL2());\n        assertTrue(v.property(\"l2\").isPresent());\n        assertEquals(new Long(143), v.value(\"l2\"));\n    }\n\n    @Test\n    public void testGetFloat() {\n        assertEquals(new Float(42f), p.getF1());\n    }\n\n    @Test\n    public void testSetFloat() {\n        p.setF1(142.0f);\n        assertEquals(new Float(142.0f), p.getF1());\n        assertEquals(new Float(142.0f), v.value(\"f1\"));\n    }\n\n    @Test\n    public void testSetFloatNull() {\n        p.setF1(null);\n        assertEquals(null, p.getF1());\n        assertFalse(v.property(\"f1\").isPresent());\n    }\n\n    @Test\n    public void testGetPrimitiveFloat() {\n        assertEquals(43.0f, p.getF2());\n    }\n\n    @Test\n    public void testSetPrimitiveFloat() {\n        p.setF2(143.0f);\n        assertEquals(143.0f, p.getF2());\n        assertTrue(v.property(\"f2\").isPresent());\n        assertEquals(new Float(143.0f), v.value(\"f2\"));\n    }\n\n    @Test\n    public void testGetDouble() {\n        assertEquals(new Double(42d), p.getD1());\n    }\n\n    @Test\n    public void testSetDouble() {\n        p.setD1(142d);\n        assertEquals(new Double(142d), p.getD1());\n        assertEquals(new Double(142d), v.value(\"d1\"));\n    }\n\n    @Test\n    public void testSetDoubleNull() {\n        p.setD1(null);\n        assertEquals(null, p.getD1());\n        assertFalse(v.property(\"d1\").isPresent());\n    }\n\n    @Test\n    public void testGetPrimitiveDouble() {\n        assertEquals(43d, p.getD2());\n    }\n\n    @Test\n    public void testSetPrimitiveDouble() {\n        p.setD2(143d);\n        assertEquals(143d, p.getD2());\n        assertTrue(v.property(\"d2\").isPresent());\n        assertEquals(new Double(143d), v.value(\"d2\"));\n    }\n\n    @Test\n    public void testGetCharacter() {\n        assertEquals(new Character('a'), p.getC1());\n    }\n\n    @Test\n    public void testSetCharacter() {\n        p.setC1('c');\n        assertEquals(new Character('c'), p.getC1());\n        assertEquals(new Character('c'), v.value(\"c1\"));\n    }\n\n    @Test\n    public void testSetCharacterNull() {\n        p.setC1(null);\n        assertEquals(null, p.getC1());\n        assertFalse(v.property(\"c1\").isPresent());\n    }\n\n    @Test\n    public void testGetPrimitiveCharacter() {\n        assertEquals('b', p.getC2());\n    }\n\n    @Test\n    public void testSetPrimitiveCharacter() {\n        p.setC2('d');\n        assertEquals('d', p.getC2());\n        assertTrue(v.property(\"c2\").isPresent());\n        assertEquals(new Character('d'), v.value(\"c2\"));\n    }\n\n    @Test\n    public void testGetByte() {\n        assertEquals(new Byte((byte) 0x11), p.getBy1());\n    }\n\n    @Test\n    public void testSetByte() {\n        p.setBy1((byte) 0x12);\n        assertEquals(new Byte((byte) 0x12), p.getBy1());\n        assertEquals(new Byte((byte) 0x12), v.value(\"by1\"));\n    }\n\n    @Test\n    public void testSetByteNull() {\n        p.setBy1(null);\n        assertEquals(null, p.getBy1());\n        assertFalse(v.property(\"by1\").isPresent());\n    }\n\n    @Test\n    public void testGetPrimitiveByte() {\n        assertEquals((byte) 0x21, p.getBy2());\n    }\n\n    @Test\n    public void testSetPrimitiveByte() {\n        p.setBy2((byte) 0x22);\n        assertEquals((byte) 0x22, p.getBy2());\n        assertTrue(v.property(\"by2\").isPresent());\n        assertEquals(new Byte((byte) 0x22), v.value(\"by2\"));\n    }\n}\ncore/src/test/java/peapod/property/DatePropertyTest.java\npublic class DatePropertyTest extends GraphTest {\n\n    private Person p;\n    private Vertex v;\n\n    @Before\n    public void init() {\n        v = g.addVertex(T.label, \"Person\", \"date\", new Date(1000));\n\n        FramedGraph graph = new FramedGraph(g, Person.class.getPackage());\n        p = graph.v(v.id());\n    }\n\n\n    @Test\n    public void testGetDate() {\n        assertEquals(new Date(1000), p.getDate());\n    }\n\n    @Test\n    public void testSetDate() {\n        p.setDate(new Date(2000));\n        assertEquals(new Date(2000), p.getDate());\n        assertEquals(new Date(2000), v.value(\"date\"));\n    }\n\n\n}\ncore/src/test/java/peapod/manytomany/ManyToManyTest.java\npublic class ManyToManyTest extends GraphTest {\n\n    private Person alice;\n    private Person bob;\n    private Person charlie;\n\n    @Before\n    public void init() {\n        Vertex alice = g.addVertex(T.label, \"Person\", \"name\", \"alice\");\n        Vertex bob = g.addVertex(T.label, \"Person\", \"name\", \"bob\");\n        Vertex charlie = g.addVertex(T.label, \"Person\", \"name\", \"charlie\");\n\n        alice.addEdge(\"friend\", bob);\n\n        FramedGraph graph = new FramedGraph(g, Person.class.getPackage());\n        this.alice = graph.v(alice.id());\n        this.bob = graph.v(bob.id());\n        this.charlie = graph.v(charlie.id());\n    }\n\n    @Test\n    public void testGetList() {\n        assertEquals(1, alice.getFriends().size());\n    }\n\n    @Test\n    public void testAdd() {\n        alice.addFriend(charlie);\n        List<Vertex> f = out(alice.vertex(), \"friend\");\n        assertThat(f, containsInAnyOrder(bob.vertex(), charlie.vertex()));\n    }\n\n    @Test\n    public void testRemove() {\n        alice.removeFriend(bob);\n        assertTrue(alice.out(\"friend\").toList().isEmpty());\n    }\n}\ncore/src/test/java/peapod/linkedvertex/LinkedVertexTest.java\npublic class LinkedVertexTest extends GraphTest {\n\n    private Person alice;\n    private Person bob;\n    private Person charlie;\n\n    @Before\n    public void init() {\n        Vertex alice = g.addVertex(T.label, \"Person\", \"name\", \"alice\");\n        Vertex bob = g.addVertex(T.label, \"Person\", \"name\", \"bob\");\n        Vertex charlie = g.addVertex(T.label, \"Person\", \"name\", \"charlie\");\n\n        alice.addEdge(\"friend\", bob);\n        alice.addEdge(\"friend\", charlie);\n\n        FramedGraph graph = new FramedGraph(g, Person.class.getPackage());\n        this.alice = graph.v(alice.id());\n        this.bob = graph.v(bob.id());\n        this.charlie = graph.v(charlie.id());\n    }\n\n    @Test\n    public void testOutVertices() {\n        assertEquals(2, alice.getFriends().size());\n        assertThat(alice.getFriends(), hasItems(bob, charlie));\n        assertEquals(0, bob.getFriends().size());\n    }\n\n    @Test\n    public void testLinkedVerticesWithDefaultAnnotation() {\n        assertEquals(2, alice.getFriendsWithAnnotationDefault().size());\n        assertThat(alice.getFriends(), hasItems(bob, charlie));\n    }\n\n    @Test\n    public void testLinkedVerticesWithDefaultAnnotationOut() {\n        assertEquals(2, alice.getFriendsWithAnnotationOut().size());\n        assertThat(alice.getFriends(), hasItems(bob, charlie));\n    }\n\n    @Test\n    public void testLinkedVerticesWithDefaultAnnotationIn() {\n        assertEquals(0, alice.getFriendsWithAnnotationIn().size());\n\n        assertEquals(1, bob.getFriendsWithAnnotationIn().size());\n        assertThat(bob.getFriendsWithAnnotationIn(), hasItems(alice));\n    }\n\n    @Test\n    public void testLinkedVerticesWithDefaultAnnotationBoth() {\n        assertThat(alice.getFriendsWithAnnotationBoth(), hasItems(bob, charlie));\n        assertThat(bob.getFriendsWithAnnotationBoth(), hasItems(alice));\n        assertThat(charlie.getFriendsWithAnnotationBoth(), hasItems(alice));\n    }\n\n    @Test\n    public void testVertexOut() {\n        assertThat(alice.out(\"friend\", Person.class).toList(), containsInAnyOrder(bob, charlie));\n\n        List<String> names = alice.out(\"friend\", Person.class).<String>values(\"name\").toList();\n        assertThat(names, containsInAnyOrder(\"bob\", \"charlie\"));\n\n        Set<Person> me = alice.out(\"friend\", Person.class).in(\"friend\", Person.class).toSet();\n        assertThat(me, containsInAnyOrder(alice));\n    }\n\n    @Test\n    public void testVertexIn() {\n        List<Person> friends = bob.in(\"friend\", Person.class).toList();\n        assertThat(friends, containsInAnyOrder(alice));\n\n        List<String> names = bob.in(\"friend\", Person.class).<String>values(\"name\").toList();\n        assertThat(names, containsInAnyOrder(\"alice\"));\n\n        Set<Person> me = bob.in(\"friend\", Person.class).out(\"friend\", Person.class).toSet();\n        assertThat(me, containsInAnyOrder(bob, charlie));\n    }\n\n}\n", "answers": ["        LinkedEdgeTest.class,"], "length": 2012, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "4ff1104206a9b1f6a1cb7d9678a99f21614ecc8091c224c4"}
{"input": "from .base import BaseMessage\nfrom .records import RecordUpdateMessage, RecordDeleteMessage, RecordCreateMessage\nfrom ..exceptions import PyOrientBadMethodCallException\nfrom ..constants import COMMAND_OP, FIELD_BOOLEAN, FIELD_BYTE, FIELD_CHAR, \\\n    FIELD_INT, FIELD_LONG, FIELD_SHORT, FIELD_STRING, QUERY_SYNC, FIELD_BYTES, \\\n    TX_COMMIT_OP, QUERY_GREMLIN, QUERY_ASYNC, QUERY_CMD, QUERY_TYPES, \\\n    QUERY_SCRIPT\nfrom ..utils import need_connected, need_db_opened, dlog\n            from datetime import datetime\n            'created': [],\n            'updated': [],\n            'changes': []\n        }\n\n        items = self._decode_field(FIELD_INT)\n        for x in range(0, items):\n            # (created-record-count:int)\n            # [\n            # (client-specified-cluster-id:short)\n            #     (client-specified-cluster-position:long)\n            #     (created-cluster-id:short)\n            #     (created-cluster-position:long)\n            # ]*\n            result['created'].append(\n                {\n                    'client_c_id': self._decode_field(FIELD_SHORT),\n                    'client_c_pos': self._decode_field(FIELD_LONG),\n                    'created_c_id': self._decode_field(FIELD_SHORT),\n                    'created_c_pos': self._decode_field(FIELD_LONG)\n                }\n            )\n\n            operation = self._pre_operation_records[\n                str(result['created'][-1]['client_c_pos'])\n            ]\n\n            rid = \"#\" + str(result['created'][-1]['created_c_id']) + \\\n                  \":\" + str(result['created'][-1]['created_c_pos'])\n\n            record = getattr(operation, \"_record_content\")\n            record.update(__version=1, __rid=rid)\n\n            self._operation_records[rid] = record\n\n        items = self._decode_field(FIELD_INT)\n        for x in range(0, items):\n\n            # (updated-record-count:int)\n            # [\n            # (updated-cluster-id:short)\n            #     (updated-cluster-position:long)\n            #     (new-record-version:int)\n            # ]*\n            result['updated'].append(\n                {\n                    'updated_c_id': self._decode_field(FIELD_SHORT),\n                    'updated_c_pos': self._decode_field(FIELD_LONG),\n                    'new_version': self._decode_field(FIELD_INT),\n                }\n            )\n\n            try:\n                operation = self._pre_operation_records[\n                    str(result['updated'][-1]['updated_c_pos'])\n                ]\n                record = getattr(operation, \"_record_content\")\n                rid = \"#\" + str(result['updated'][-1]['updated_c_id']) + \\\n                      \":\" + str(result['updated'][-1]['updated_c_pos'])\n                record.update(\n                    __version=result['updated'][-1]['new_version'],\n                    __rid=rid\n                )\n\n                self._operation_records[rid] = record\n\n            except KeyError:\n                pass\n\n        if self.get_protocol() > 23:\n            items = self._decode_field(FIELD_INT)\n            for x in range(0, items):\n                # (count-of-collection-changes:int)\n                # [\n                # (uuid-most-sig-bits:long)\n                #     (uuid-least-sig-bits:long)\n                #     (updated-file-id:long)\n                #     (updated-page-index:long)\n                #     (updated-page-offset:int)\n                # ]*\n                result['updated'].append(\n                    {\n                        'uuid_high': self._decode_field(FIELD_LONG),\n                        'uuid_low': self._decode_field(FIELD_LONG),\n                        'file_id': self._decode_field(FIELD_LONG),\n                        'page_index': self._decode_field(FIELD_LONG),\n                        'page_offset': self._decode_field(FIELD_INT),\n                    }\n                )\n\n        self.dump_streams()\n\n        return self._operation_records #  [self._operation_records, result]\n\n    def attach(self, operation):\n\n        if not isinstance(operation, BaseMessage):\n            # A Subclass of BaseMessage was expected\n            raise AssertionError(\"A subclass of BaseMessage was expected\")\n\n        if isinstance(operation, RecordUpdateMessage):\n            o_record_enc = self.get_serializer().encode(getattr(operation, \"_record_content\"))\n            self._operation_stack.append((\n                ( FIELD_BYTE, chr(1) ),\n                ( FIELD_SHORT, int(getattr(operation, \"_cluster_id\")) ),\n                ( FIELD_LONG, int(getattr(operation, \"_cluster_position\")) ),\n                ( FIELD_BYTE, getattr(operation, \"_record_type\") ),\n                ( FIELD_INT, int(getattr(operation, \"_record_version\")) ),\n                ( FIELD_STRING, o_record_enc ),\n            ))\n\n            if self.get_protocol() >= 23:\n                self._operation_stack[-1] = \\\n                    self._operation_stack[-1] +\\\n                    ( ( FIELD_BOOLEAN, bool(getattr(operation, \"_update_content\") ) ), )\n\n            self._pre_operation_records[\n                str(getattr(operation, \"_cluster_position\"))\n            ] = operation\n\n", "context": "pyorient/exceptions.py\nclass PyOrientBadMethodCallException(PyOrientException):\n    pass\npyorient/messages/records.py\nclass RecordDeleteMessage(BaseMessage):\n\n    def __init__(self, _orient_socket ):\n        super( RecordDeleteMessage, self ).__init__(_orient_socket)\n\n        self._cluster_id = b'0'\n        self._cluster_position = b'0'\n        self._record_version = -1\n        self._mode_async = 0  # means synchronous mode\n\n        # only needed for transactions\n        self._record_type = RECORD_TYPE_DOCUMENT\n\n        # order matters\n        self._append( ( FIELD_BYTE, RECORD_DELETE_OP ) )\n\n    @need_db_opened\n    def prepare(self, params=None):\n\n        try:\n            # mandatory if not passed by method\n            self.set_cluster_id( params[0] )\n\n            # mandatory if not passed by method\n            self.set_cluster_position( params[1] )\n\n            self._record_version = params[2]   # optional\n            self._mode_async = params[3]  # optional\n        except IndexError:\n            # Use default for non existent indexes\n            pass\n\n        self._append( ( FIELD_SHORT, int(self._cluster_id) ) )\n        self._append( ( FIELD_LONG, int(self._cluster_position) ) )\n        self._append( ( FIELD_INT, int(self._record_version) ) )\n        self._append( ( FIELD_BOOLEAN, self._mode_async ) )\n\n        return super( RecordDeleteMessage, self ).prepare()\n\n    def fetch_response(self):\n\n        # skip execution in case of transaction\n        if self._orientSocket.in_transaction is True:\n            return self\n\n        self._append( FIELD_BOOLEAN )  # payload-status\n        return super( RecordDeleteMessage, self ).fetch_response()[0]\n\n    def set_record_version(self, _record_version):\n        self._record_version = _record_version\n        return self\n\n    def set_cluster_id(self, cluster_id):\n        self._cluster_id = parse_cluster_id(cluster_id)\n        return self\n\n    def set_cluster_position(self, _cluster_position):\n        self._cluster_position = parse_cluster_position(_cluster_position)\n        return self\n\n    def set_record_type(self, _record_type):\n        self._record_type = _record_type\n        return self\n\n    def set_mode_async(self):\n        self._mode_async = 1\n        return self\npyorient/messages/records.py\nclass RecordUpdateMessage(BaseMessage):\n\n    def __init__(self, _orient_socket ):\n        super( RecordUpdateMessage, self ).__init__(_orient_socket)\n\n        self._data_segment_id = -1  # default\n        self._cluster_id = b'0'\n        self._cluster_position = 0\n        self._record_content = ''\n\n        # True:  content of record has been changed\n        #        and content should be updated in storage\n        # False: the record was modified but its own\n        #        content has not been changed.\n        #        So related collections (e.g. rid-bags) have to be updated, but\n        #        record version and content should not be.\n        # NOT USED before protocol 23\n        self._update_content = True\n\n        # > -1 default Standard document update (version control)\n        self._record_version_policy = -1\n\n        # Used for transactions\n        self._record_version = -1\n\n        self._record_type = RECORD_TYPE_DOCUMENT\n        self._mode_async = 0  # means synchronous mode\n\n        # order matters\n        self._append( ( FIELD_BYTE, RECORD_UPDATE_OP ) )\n\n    @need_db_opened\n    def prepare(self, params=None):\n\n        try:\n            # mandatory if not passed by method\n            self.set_cluster_id( params[0] )\n\n            # mandatory if not passed by method\n            self.set_cluster_position( params[1] )\n\n            # mandatory if not passed by method\n            self._record_content = params[2]\n\n            self._record_version = params[3]  # Optional|Needed for transaction\n\n            self.set_record_type( params[4] )  # optional\n\n            self._record_version_policy = params[5]  # optional\n            self._mode_async = params[6]  # optional\n\n            self._update_content = params[7]  # optional\n\n        except IndexError:\n            # Use default for non existent indexes\n            pass\n\n        record = self._record_content\n        if not isinstance( record, OrientRecord ):\n            record = self._record_content = OrientRecord( record )\n\n        o_record_enc = self.get_serializer().encode(record)\n        self._append( ( FIELD_SHORT, int(self._cluster_id) ) )\n        self._append( ( FIELD_LONG, int(self._cluster_position) ) )\n\n        if self.get_protocol() >= 23:\n            self._append( ( FIELD_BOOLEAN, self._update_content ) )\n\n        self._append( ( FIELD_STRING, o_record_enc ) )\n        self._append( ( FIELD_INT, int(self._record_version_policy) ) )\n        self._append( ( FIELD_BYTE, self._record_type ) )\n        self._append( ( FIELD_BOOLEAN, self._mode_async ) )\n\n        return super( RecordUpdateMessage, self ).prepare()\n\n    def fetch_response(self):\n\n        # skip execution in case of transaction\n        if self._orientSocket.in_transaction is True:\n            return self\n\n        self._append( FIELD_INT )  # record-version\n        result = super( RecordUpdateMessage, self ).fetch_response()\n\n        # There are some strange behaviours with protocols between 19 and 23\n        # the INT ( count-of-collection-changes ) in documentation\n        # is present, but don't know why,\n        #\n        # Not every time this INT is present!!!!\n        # On Protocol version between 21 and 23 record Upload/Create could\n        # not work\n        chng = 0\n        _changes = []\n        if self.get_protocol() > 21:\n            try:\n                chng = self._decode_field( FIELD_INT )\n                \"\"\" count-of-collection-changes \"\"\"\n            except ( PyOrientConnectionException, TypeError ):\n                pass\n\n            try:\n                if chng > 0 and self.get_protocol() > 23:\n\n                    for x in range( 0, chng ):\n                        change = [\n                            self._decode_field( FIELD_LONG ),  # (uuid-most-sig-bits:long)\n                            self._decode_field( FIELD_LONG ),  # (uuid-least-sig-bits:long)\n                            self._decode_field( FIELD_LONG ),  # (updated-file-id:long)\n                            self._decode_field( FIELD_LONG ),  # (updated-page-index:long)\n                            self._decode_field( FIELD_INT )    # (updated-page-offset:int)\n                        ]\n                        _changes.append( change )\n\n            except IndexError:\n                # append an empty field\n                result.append(None)\n\n        self._record_content.update(\n            __version=result[0]\n        )\n\n        return [ self._record_content, chng, _changes ]\n\n    def set_data_segment_id(self, data_segment_id):\n        self._data_segment_id = data_segment_id\n        return self\n\n    def set_cluster_id(self, cluster_id):\n        self._cluster_id = parse_cluster_id(cluster_id)\n        return self\n\n    def set_cluster_position(self, _cluster_position):\n        self._cluster_position = parse_cluster_position(_cluster_position)\n        return self\n\n    def set_record_content(self, record):\n        self._record_content = record\n        return self\n\n    def set_record_type(self, record_type ):\n        if record_type in RECORD_TYPES:\n            # user choice storage if present\n            self._record_type = record_type\n        else:\n            raise PyOrientBadMethodCallException(\n                record_type + ' is not a valid record type', []\n            )\n        return self\n\n    def set_mode_async(self):\n        self._mode_async = 1\n        return self\n\n    def set_record_version_policy(self, _policy):\n        self._record_version_policy = _policy\n        return self\n\n    def set_no_update_content(self):\n        self._update_content = False\n        return self\npyorient/constants.py\nFIELD_SHORT = {\"type\": SHORT, \"bytes\": 2, \"struct\": None}\npyorient/constants.py\nQUERY_CMD     = \"com.orientechnologies.orient.core.sql.OCommandSQL\"\npyorient/constants.py\nQUERY_TYPES   = (\n    QUERY_SYNC,\n    QUERY_ASYNC,\n    QUERY_CMD,\n    QUERY_GREMLIN,\n    QUERY_SCRIPT,\n)\npyorient/messages/records.py\nclass RecordCreateMessage(BaseMessage):\n\n    def __init__(self, _orient_socket ):\n        super( RecordCreateMessage, self ).__init__(_orient_socket)\n\n        self._data_segment_id = -1  # default\n        self._cluster_id = b'0'\n        self._record_content = OrientRecord\n        self._record_type = RECORD_TYPE_DOCUMENT\n        self._mode_async = 0  # means synchronous mode\n\n        # order matters\n        self._append( ( FIELD_BYTE, RECORD_CREATE_OP ) )\n\n    @need_db_opened\n    def prepare(self, params=None):\n\n        try:\n            # mandatory if not passed by method\n            self.set_cluster_id( params[0] )\n\n            # mandatory if not passed by method\n            self._record_content = params[1]\n\n            self.set_record_type( params[2] )  # optional\n\n        except IndexError:\n            # Use default for non existent indexes\n            pass\n\n        record = self._record_content\n        if not isinstance( record, OrientRecord ):\n            record = self._record_content = OrientRecord( record )\n\n        o_record_enc = self.get_serializer().encode(record)\n        if self.get_protocol() < 24:\n            self._append( ( FIELD_INT, int(self._data_segment_id) ) )\n\n        self._append( ( FIELD_SHORT, int(self._cluster_id) ) )\n        self._append( ( FIELD_STRING, o_record_enc ) )\n        self._append( ( FIELD_BYTE, self._record_type ) )\n        self._append( ( FIELD_BOOLEAN, self._mode_async ) )\n\n        return super( RecordCreateMessage, self ).prepare()\n\n    def fetch_response(self):\n\n        # skip execution in case of transaction\n        if self._orientSocket.in_transaction is True:\n            return self\n\n        if self.get_protocol() > 25:\n            self._append( FIELD_SHORT )  # cluster-id\n\n        self._append( FIELD_LONG )  # cluster-position\n        self._append( FIELD_INT )  # record-version\n        result = super( RecordCreateMessage, self ).fetch_response()\n\n        # There are some strange behaviours with protocols between 19 and 23\n        # the INT ( count-of-collection-changes ) in documentation\n        # is present, but don't know why,\n        #\n        # Not every time this INT is present!!!!\n        # On Protocol version between 21 and 23 record Upload/Create could\n        # not work\n        chng = 0\n        _changes = []\n        if self.get_protocol() > 21:\n            try:\n                chng = self._decode_field( FIELD_INT )\n                \"\"\" count-of-collection-changes \"\"\"\n            except ( PyOrientConnectionException, TypeError ):\n                pass\n\n            try:\n                if chng > 0 and self.get_protocol() > 23:\n\n                    for x in range( 0, chng ):\n                        change = [\n                            self._decode_field( FIELD_LONG ),  # (uuid-most-sig-bits:long)\n                            self._decode_field( FIELD_LONG ),  # (uuid-least-sig-bits:long)\n                            self._decode_field( FIELD_LONG ),  # (updated-file-id:long)\n                            self._decode_field( FIELD_LONG ),  # (updated-page-index:long)\n                            self._decode_field( FIELD_INT )    # (updated-page-offset:int)\n                        ]\n                        _changes.append( change )\n\n            except IndexError:\n                # Should not happen because of protocol check\n                pass\n\n        if self.get_protocol() > 25:\n            rid = \"#\" + str(result[0]) + \":\" + str(result[1])\n            version = result[2]\n        else:\n            rid = \"#\" + self._cluster_id + \":\" + str(result[0])\n            version = result[1]\n\n        self._record_content.update(\n            __version=version,\n            __rid=rid\n        )\n\n        return self._record_content  # [ self._record_content, _changes ]\n\n    def set_data_segment_id(self, data_segment_id):\n        self._data_segment_id = data_segment_id\n        return self\n\n    def set_cluster_id(self, cluster_id):\n        self._cluster_id = parse_cluster_id(cluster_id)\n        return self\n\n    def set_record_content(self, record):\n        self._record_content = record\n        return self\n\n    def set_record_type(self, record_type ):\n        if record_type in RECORD_TYPES:\n            # user choice storage if present\n            self._record_type = record_type\n        else:\n            raise PyOrientBadMethodCallException(\n                record_type + ' is not a valid record type', []\n            )\n        return self\n\n    def set_mode_async(self):\n        self._mode_async = 1\n        return self\npyorient/constants.py\nQUERY_GREMLIN = \"com.orientechnologies.orient.graph.gremlin.OCommandGremlin\"\npyorient/constants.py\nCOMMAND_OP                 = chr(41)\npyorient/constants.py\nFIELD_BYTE = {\"type\": BYTE, \"bytes\": 1, \"struct\": None}\npyorient/constants.py\nQUERY_ASYNC   = \"com.orientechnologies.orient.core.sql.query.OSQLAsynchQuery\"\npyorient/constants.py\nFIELD_BOOLEAN = {\"type\": BOOLEAN, \"bytes\": 1, \"struct\": None}\npyorient/constants.py\nQUERY_SCRIPT  = \"com.orientechnologies.orient.core.command.script.OCommandScript\"\npyorient/constants.py\nTX_COMMIT_OP               = chr(60)\npyorient/messages/base.py\nclass BaseMessage(object):\n\n    def __init__(self, sock=OrientSocket):\n        \"\"\"\n        :type sock: OrientSocket\n        \"\"\"\n        sock.get_connection()\n        self._orientSocket = sock\n        self._protocol = self._orientSocket.protocol\n        self._session_id = self._orientSocket.session_id\n\n        # handles token auth\n        self._auth_token = self._orientSocket.auth_token\n        self._request_token = False\n\n        self._header = []\n        \"\"\":type : list of [str]\"\"\"\n\n        self._body = []\n        \"\"\":type : list of [str]\"\"\"\n\n        self._fields_definition = []\n        \"\"\":type : list of [object]\"\"\"\n\n        self._command = chr(0)\n        self._db_opened = self._orientSocket.db_opened\n        self._connected = self._orientSocket.connected\n\n        self._node_list = []\n        \"\"\":type : list of [OrientNode]\"\"\"\n\n        self._serializer = None\n\n        self._output_buffer = b''\n        self._input_buffer = b''\n\n        # callback function for async queries\n        self._callback = None\n\n        # callback for push received from the server\n        self._push_callback = None\n\n        self._need_token = True\n\n        global in_transaction\n        in_transaction = False\n\n    def get_serializer(self):\n        \"\"\"\n        Lazy return of the serialization, we retrive the type from the :class: `OrientSocket <pyorient.orient.OrientSocket>` object\n        :return: an Instance of the serializer suitable for decoding or encoding\n        \"\"\"\n        if self._orientSocket.serialization_type==OrientSerialization.Binary:\n            return OrientSerialization.get_impl(self._orientSocket.serialization_type,\n                                                self._orientSocket._props)\n        else:\n            return OrientSerialization.get_impl(self._orientSocket.serialization_type)\n\n    def get_orient_socket_instance(self):\n        return self._orientSocket\n\n    def is_connected(self):\n        return self._connected is True\n\n    def database_opened(self):\n        return self._db_opened\n\n    def get_cluster_map(self):\n        \"\"\":type : list of [OrientNode]\"\"\"\n        return self._node_list\n\n\n    def set_session_token( self, token='' ):\n        \"\"\"\n        :param token: Set the request to True to use the token authentication\n        :type token: bool|string\n        :return: self\n        \"\"\"\n        if token != '' and token is not None:\n            if type(token) is bool:\n                self._request_token = token\n            elif type(token) is str or type(token) is bytes:\n                self._request_token = True\n                self._auth_token = token\n                self._db_opened = True\n                self._connected = True\n                self._update_socket_token()\n        return self\n\n    def get_session_token( self ):\n        \"\"\"\n        Retrieve the session token to reuse after\n        :return:\n        \"\"\"\n        return self._auth_token\n\n    def _update_socket_id(self):\n        \"\"\"Force update of socket id from inside the class\"\"\"\n        self._orientSocket.session_id = self._session_id\n        return self\n\n    def _update_socket_token(self):\n        \"\"\"Force update of socket token from inside the class\"\"\"\n        self._orientSocket.auth_token = self._auth_token\n        return self\n\n    def _reset_fields_definition(self):\n        self._fields_definition = []\n\n    def prepare(self, *args):\n\n        # session_id\n        self._fields_definition.insert( 1, ( FIELD_INT, self._session_id ) )\n\n\n        \"\"\"\n        #  Token authentication handling\n        #  we must recognize ConnectMessage and DbOpenMessage messages\n        \"\"\"\n        if self._need_token and self._request_token is True:\n            self._fields_definition.insert(\n                2, ( FIELD_STRING, self._auth_token )\n            )\n\n        self._output_buffer = b''.join(\n            self._encode_field( x ) for x in self._fields_definition\n        )\n        return self\n\n    def get_protocol(self):\n        if self._protocol < 0:\n            self._protocol = self._orientSocket.protocol\n        return self._protocol\n\n    def _decode_header(self):\n\n        # read header's information\n        self._header = [ self._decode_field( FIELD_BYTE ),\n                         self._decode_field( FIELD_INT ) ]\n\n        # decode message errors and raise an exception\n        if self._header[0] == 1:\n\n            # Parse the error\n            exception_class = b''\n            exception_message = b''\n\n            more = self._decode_field( FIELD_BOOLEAN )\n\n            while more:\n                # read num bytes by the field definition\n                exception_class += self._decode_field( FIELD_STRING )\n                exception_message += self._decode_field( FIELD_STRING )\n                more = self._decode_field( FIELD_BOOLEAN )\n\n                if self.get_protocol() > 18:  # > 18 1.6-snapshot\n                    # read serialized version of exception thrown on server side\n                    # useful only for java clients\n                    serialized_exception = self._decode_field( FIELD_STRING )\n                    # trash\n                    del serialized_exception\n\n            raise PyOrientCommandException(\n                exception_class.decode( 'utf8' ),\n                [ exception_message.decode( 'utf8' ) ]\n            )\n\n        elif self._header[0] == 3:\n            # Push notification, Node cluster changed\n            # TODO: UNTESTED CODE!!!\n            # FIELD_BYTE (OChannelBinaryProtocol.PUSH_DATA);  # WRITE 3\n            # FIELD_INT (Integer.MIN_VALUE);  # SESSION ID = 2^-31\n            # 80: \\x50 Request Push 1 byte: Push command id\n            push_command_id = self._decode_field(FIELD_BYTE)\n            push_message = self._decode_field( FIELD_STRING )\n            _, payload = self.get_serializer().decode(push_message)\n            if self._push_callback:\n                self._push_callback(push_command_id, payload)\n\n            end_flag = self._decode_field( FIELD_BYTE )\n\n            # this flag can be set more than once\n            while end_flag == 3:\n                self._decode_field( FIELD_INT )  # FAKE SESSION ID = 2^-31\n                op_code = self._decode_field( FIELD_BYTE )  # 80: 0x50 Request Push\n\n                # REQUEST_PUSH_RECORD\t        79\n                # REQUEST_PUSH_DISTRIB_CONFIG\t80\n                # REQUEST_PUSH_LIVE_QUERY\t    81\n                if op_code == 80:\n                    # for node in\n                    payload = self.get_serializer().decode(\n                        self._decode_field( FIELD_STRING )\n                    )  # JSON WITH THE NEW CLUSTER CFG\n\n                    # reset the nodelist\n                    self._node_list = []\n                    for node in payload['members']:\n                        self._node_list.append( OrientNode( node ) )\n\n                end_flag = self._decode_field( FIELD_BYTE )\n\n            # Try to set the new session id???\n            self._header[1] = self._decode_field( FIELD_INT )  # REAL SESSION ID\n            pass\n\n        from .connection import ConnectMessage\n        from .database import DbOpenMessage\n        \"\"\"\n        #  Token authentication handling\n        #  we must recognize ConnectMessage and DbOpenMessage messages\n            TODO: change this check avoiding cross import,\n            importing a subclass in a super class is bad\n        \"\"\"\n        if not isinstance(self, (ConnectMessage, DbOpenMessage)) \\\n                and self._request_token is True:\n            token_refresh = self._decode_field(FIELD_STRING)\n            if token_refresh != b'':\n                self._auth_token = token_refresh\n                self._update_socket_token()\n\n    def _decode_body(self):\n        # read body\n        for field in self._fields_definition:\n            self._body.append( self._decode_field( field ) )\n\n        # clear field stack\n        self._reset_fields_definition()\n        return self\n\n    def _decode_all(self):\n        self._decode_header()\n        self._decode_body()\n\n    def fetch_response(self, *_continue):\n        \"\"\"\n        # Decode header and body\n        # If flag continue is set( Header already read ) read only body\n        :param _continue:\n        :return:\n        \"\"\"\n        if len(_continue) is not 0:\n            self._body = []\n            self._decode_body()\n            self.dump_streams()\n        # already fetched, get last results as cache info\n        elif len(self._body) is 0:\n            self._decode_all()\n            self.dump_streams()\n        return self._body\n\n    def dump_streams(self):\n        if is_debug_active():\n            if len( self._output_buffer ):\n                print(\"\\nRequest :\")\n                hexdump( self._output_buffer )\n                # print(repr(self._output_buffer))\n            if len( self._input_buffer ):\n                print(\"\\nResponse:\")\n                hexdump( self._input_buffer )\n                # print(repr(self._input_buffer))\n\n    def _append(self, field):\n        \"\"\"\n        @:rtype self: BaseMessage\n        @type field: object\n        \"\"\"\n        self._fields_definition.append( field )\n        return self\n\n    def __str__(self):\n\n        return \"\\n_output_buffer: \\n\" + hexdump( self._output_buffer, 'return' ) \\\n               + \"\\n\\n_input_buffer: \\n\" + hexdump( self._input_buffer, 'return' )\n\n    def send(self):\n        if self._orientSocket.in_transaction is False:\n            self._orientSocket.write( self._output_buffer )\n            self._reset_fields_definition()\n        if is_debug_active():\n            self.dump_streams()\n            # reset output buffer\n            self._output_buffer = b\"\"\n\n        return self\n\n    def close(self):\n        self._orientSocket.close()\n\n    @staticmethod\n    def _encode_field(field):\n\n        # tuple with type\n        t, v = field\n        _content = None\n\n        if t['type'] == INT:\n            _content = struct.pack(\"!i\", v)\n        elif t['type'] == SHORT:\n            _content = struct.pack(\"!h\", v)\n        elif t['type'] == LONG:\n            _content = struct.pack(\"!q\", v)\n        elif t['type'] == BOOLEAN:\n            if sys.version_info[0] < 3:\n                _content = chr(1) if v else chr(0)\n            else:\n                _content = bytes([1]) if v else bytes([0])\n        elif t['type'] == BYTE:\n            if sys.version_info[0] < 3:\n                _content = v\n            else:\n                _content = bytes([ord(v)])\n        elif t['type'] == BYTES:\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRING:\n            if sys.version_info[0] >= 3:\n                if isinstance(v, str):\n                    v = v.encode('utf-8')\n            else:\n                if isinstance(v, unicode):\n                    v = v.encode('utf-8')\n            _content = struct.pack(\"!i\", len(v)) + v\n        elif t['type'] == STRINGS:\n            _content = b''\n            for s in v:\n                if sys.version_info[0] >= 3:\n                    if isinstance(s, str):\n                        s = s.encode('utf-8')\n                else:\n                    if isinstance(s, unicode):\n                        s = s.encode('utf-8')\n                _content += struct.pack(\"!i\", len(s)) + s\n\n        return _content\n\n    def _decode_field(self, _type):\n        _value = b\"\"\n        # read buffer length and decode value by field definition\n        if _type['bytes'] is not None:\n            _value = self._orientSocket.read( _type['bytes'] )\n        # if it is a string decode first 4 Bytes as INT\n        # and try to read the buffer\n        if _type['type'] == STRING or _type['type'] == BYTES:\n\n            _len = struct.unpack('!i', _value)[0]\n            if _len == -1 or _len == 0:\n                _decoded_string = b''\n            else:\n                _decoded_string = self._orientSocket.read( _len )\n\n            self._input_buffer += _value\n            self._input_buffer += _decoded_string\n\n            return _decoded_string\n\n        elif _type['type'] == RECORD:\n\n            # record_type\n            record_type = self._decode_field( _type['struct'][0] )\n\n            rid = \"#\" + str( self._decode_field( _type['struct'][1] ) )\n            rid += \":\" + str( self._decode_field( _type['struct'][2] ) )\n            \n            version = self._decode_field( _type['struct'][3] )\n            content = self._decode_field( _type['struct'][4] )\n            return {'rid': rid, 'record_type': record_type,\n                    'content': content, 'version': version}\n\n        elif _type['type'] == LINK:\n\n            rid = \"#\" + str( self._decode_field( _type['struct'][0] ) )\n            rid += \":\" + str( self._decode_field( _type['struct'][1] ) )\n            return rid\n\n        else:\n            self._input_buffer += _value\n\n            if _type['type'] == BOOLEAN:\n                return ord(_value) == 1\n            elif _type['type'] == BYTE:\n                return ord(_value)\n            elif _type['type'] == CHAR:\n                return _value\n            elif _type['type'] == SHORT:\n                return struct.unpack('!h', _value)[0]\n            elif _type['type'] == INT:\n                return struct.unpack('!i', _value)[0]\n            elif _type['type'] == LONG:\n                return struct.unpack('!q', _value)[0]\n\n    def _read_async_records(self):\n        \"\"\"\n        # async-result-type byte as trailing byte of a record can be:\n        # 0: no records remain to be fetched\n        # 1: a record is returned as a result set\n        # 2: a record is returned as pre-fetched to be loaded in client's\n        #       cache only. It's not part of the result set but the client\n        #       knows that it's available for later access\n        \"\"\"\n        _status = self._decode_field( FIELD_BYTE )  # status\n\n        while _status != 0:\n\n            try:\n\n                # if a callback for the cache is not set, raise exception\n                if not hasattr(self._callback, '__call__'):\n                    raise AttributeError()\n\n                _record = self._read_record()\n\n                if _status == 1:  # async record type\n                    # async_records.append( _record )  # save in async\n                    self._callback( _record )  # save in async\n                elif _status == 2:  # cache\n                    # cached_records.append( _record )  # save in cache\n                    self._callback( _record )  # save in cache\n\n            except AttributeError:\n                # AttributeError: 'RecordLoadMessage' object has\n                # no attribute '_command_type'\n                raise PyOrientBadMethodCallException(\n                    str(self._callback) + \" is not a callable function\", [])\n            finally:\n                # read new status and flush the debug buffer\n                _status = self._decode_field( FIELD_BYTE )  # status\n\n    def _read_record(self):\n        \"\"\"\n        # The format depends if a RID is passed or an entire\n            record with its content.\n\n        # In case of null record then -2 as short is passed.\n\n        # In case of RID -3 is passes as short and then the RID:\n            (-3:short)(cluster-id:short)(cluster-position:long).\n\n        # In case of record:\n            (0:short)(record-type:byte)(cluster-id:short)\n            (cluster-position:long)(record-version:int)(record-content:bytes)\n\n        :raise: PyOrientNullRecordException\n        :return: OrientRecordLink,OrientRecord\n        \"\"\"\n        marker = self._decode_field( FIELD_SHORT )  # marker\n\n        if marker is -2:\n            raise PyOrientNullRecordException('NULL Record', [])\n        elif marker is -3:\n            res = OrientRecordLink( self._decode_field( FIELD_TYPE_LINK ) )\n        else:\n            # read record\n            __res = self._decode_field( FIELD_RECORD )\n            \n            if self._orientSocket.serialization_type==OrientSerialization.Binary:\n                class_name, data = self.get_serializer().decode(__res['content'])\n            else:\n                # bug in orientdb csv serialization in snapshot 2.0\n                class_name, data = self.get_serializer().decode(__res['content'].rstrip())\n\n\n            res = OrientRecord(\n                dict(\n                    __o_storage=data,\n                    __o_class=class_name,\n                    __version=__res['version'],\n                    __rid=__res['rid']\n                )\n            )\n\n        self.dump_streams()  # debug log\n        self._output_buffer = b''\n        self._input_buffer = b''\n\n        return res\npyorient/constants.py\nFIELD_CHAR = {\"type\": CHAR, \"bytes\": 1, \"struct\": None}\npyorient/constants.py\nFIELD_STRING = {\"type\": STRING, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nQUERY_SYNC    = \"com.orientechnologies.orient.core.sql.query.OSQLSynchQuery\"\npyorient/constants.py\nFIELD_INT = {\"type\": INT, \"bytes\": 4, \"struct\": None}\npyorient/constants.py\nFIELD_LONG = {\"type\": LONG, \"bytes\": 8, \"struct\": None}\npyorient/constants.py\nFIELD_BYTES = {\"type\": BYTES, \"bytes\": 4, \"struct\": None}\n", "answers": ["        elif isinstance(operation, RecordDeleteMessage):"], "length": 3043, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "5339ec1fe1b1ff7b6215857f2518f13d4520b1bdecbb1329"}
{"input": "package com.github.felixgail.gplaymusic;\nimport static com.github.felixgail.gplaymusic.util.TestUtil.assertTracks;\nimport static com.github.felixgail.gplaymusic.util.TestUtil.assume;\nimport static com.github.felixgail.gplaymusic.util.TestUtil.containsDoubledTracks;\nimport static junit.framework.TestCase.assertEquals;\nimport static junit.framework.TestCase.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport com.github.felixgail.gplaymusic.model.Album;\nimport com.github.felixgail.gplaymusic.model.Artist;\nimport com.github.felixgail.gplaymusic.model.Station;\nimport com.github.felixgail.gplaymusic.model.Track;\nimport com.github.felixgail.gplaymusic.model.enums.ResultType;\nimport com.github.felixgail.gplaymusic.model.enums.StationSeedType;\nimport com.github.felixgail.gplaymusic.model.requests.SearchTypes;\nimport com.github.felixgail.gplaymusic.model.snippets.StationSeed;\nimport com.github.felixgail.gplaymusic.util.TestUtil;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Optional;\nimport org.junit.BeforeClass;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport svarzee.gps.gpsoauth.Gpsoauth;\n\n\n\npublic class StationTest extends TestWithLogin {\n\n  @BeforeClass\n  public static void before() throws IOException, Gpsoauth.TokenRequestFailed {\n    loginToService(TestUtil.USERNAME, TestUtil.PASSWORD, TestUtil.ANDROID_ID, TestUtil.TOKEN);\n  }\n\n  @Test\n  @Ignore\n  //Is this an error by google play? will return a broken station by 'Onlap' that contains 0 tracks\n  public void testStation() throws IOException {\n    List<Station> stations = getApi().getStationApi().listStations();\n    assertNotNull(stations);\n    assertFalse(stations.isEmpty());\n    //Prefer a non Playlist station, as they can return empty lists if created on empty playlists.\n    Optional<Station> stationOptional = stations.stream()\n        .filter(s -> !s.getSeed().getSeedType().equals(StationSeedType.PLAYLIST))\n        .filter(s -> !s.isDeleted()).findFirst();\n    Station station;\n    station = stationOptional.orElseGet(() -> stations.get(0));\n    assertNotNull(station);\n    assertNotNull(station.getName());\n    assertNotNull(station.getId());\n    List<Track> stationTracks = station.getTracks(null, true, false);\n    assertNotNull(stationTracks);\n    assertEquals(String.format(\"Expected list length 25, got '%d'\", stationTracks.size()), 25, stationTracks.size());\n    assertTracks(stationTracks);\n    List<Track> newTracks = station.getTracks(stationTracks, true, true);\n    assertNotNull(newTracks);\n    assertTrue(String.format(\"Expected list length expected <=25, got '%d'\", newTracks.size()),\n        newTracks.size() <= 25);\n    assertTracks(newTracks);\n    int doubles = containsDoubledTracks(stationTracks, newTracks);\n    assertEquals(String.format(\"Second Call contained %d doubles.\", doubles), 0, doubles);\n  }\n\n  @Test\n  public void createTrackStation() throws IOException {\n    Track track = getApi().getTrackApi().search(\"Imagine\", 1).get(0);", "context": "src/main/java/com/github/felixgail/gplaymusic/model/Station.java\npublic class Station implements Result, Serializable, Model {\n\n  public final static ResultType RESULT_TYPE = ResultType.STATION;\n  public final static String BATCH_URL = \"radio/editstation\";\n  private final static Gson gson = new GsonBuilder().setPrettyPrinting().create();\n\n  @Expose\n  private String name;\n  @Expose\n  private String imageUrl;\n  @Expose\n  private boolean deleted;\n  @Expose\n  private String lastModifiedTimestamp;\n  @Expose\n  private String recentTimestamp;\n  @Expose\n  private String clientId;\n  @Expose\n  private String sessionToken;\n  @Expose\n  private StationSeed seed;\n  @Expose\n  private List<StationSeed> stationSeeds;\n  @Expose\n  private String id;\n  @Expose\n  private String description;\n  @Expose\n  private List<Track> tracks = new LinkedList<>();\n  @Expose\n  @SerializedName(\"imageUrls\")\n  private List<ArtRef> imageArtRefs;\n  @Expose\n  private List<ArtRef> compositeArtRefs;\n  @Expose\n  private List<String> contentTypes;\n  @Expose\n  private String byline;\n\n  private GPlayMusic mainApi;\n\n  public String getName() {\n    return name;\n  }\n\n  public Optional<String> getImageUrl() {\n    return Optional.ofNullable(imageUrl);\n  }\n\n  public boolean isDeleted() {\n    return deleted;\n  }\n\n  public Optional<String> getLastModifiedTimestamp() {\n    return Optional.ofNullable(lastModifiedTimestamp);\n  }\n\n  public Optional<String> getRecentTimestamp() {\n    return Optional.ofNullable(recentTimestamp);\n  }\n\n  public Optional<String> getClientId() {\n    return Optional.ofNullable(clientId);\n  }\n\n  public StationSeed getSeed() {\n    return seed;\n  }\n\n  public List<StationSeed> getStationSeeds() {\n    return stationSeeds;\n  }\n\n  public String getId() throws IOException {\n    if (id != null) {\n      return id;\n    }\n    if (getSeed() != null) {\n      Station createOrGet = mainApi.getStationApi().create(getSeed(), getName(), false);\n      this.id = createOrGet.id;\n      this.clientId = createOrGet.clientId;\n      return id;\n    }\n    throw new NullPointerException(\"Radio does not contain ID or Seeds\");\n  }\n\n  public Optional<String> getDescription() {\n    return Optional.ofNullable(description);\n  }\n\n  /**\n   * Get Tracks for this Station.<br> <b> Keep in mind that this can return an empty list, if this\n   * station is created on an empty playlist. </b>\n   *\n   * @param recentlyPlayed a list of tracks that have recently been played. tracks from this list\n   * will, <b>most of the time</b>, be excluded from the response. For some reason this is sometimes\n   * ignored by the server. Use {@code forceRemoveDoubles} to remove doubles returned by the\n   * server.\n   * @param newCall true if a new call shall be dispatched. false if the list from a previous call\n   * is to be returned. Careful: Will return an empty list if no call has been made.\n   * @param forceRemoveDoubles see {@code recentlyPlayed}. Force remove doubles returned by the\n   * server.\n   * @return A list of 25 tracks for this station.\n   *\n   * @throws RemoteException If the result returned from google has errors.\n   */\n  public List<Track> getTracks(List<Track> recentlyPlayed, boolean newCall,\n      boolean forceRemoveDoubles)\n      throws IOException, RemoteException {\n    if (!newCall) {\n      return Optional.of(tracks).orElse(Collections.emptyList());\n    }\n    ListStationTracksRequest request = new ListStationTracksRequest(this, 25, recentlyPlayed);\n    List<Station> result = mainApi.getStationApi().getFilledStations(request);\n    if(result.isEmpty()) {\n      throw new RemoteException(\"Server returned an empty list of stations.\");\n    }\n    Station returnedStation = result.get(0);\n    Optional<List<Track>> trackOptional = Optional.ofNullable(returnedStation.tracks);\n    sessionToken = returnedStation.sessionToken;\n    List<Track> tracks = trackOptional.orElse(Collections.emptyList());\n    tracks.forEach(t -> t.setSessionToken(sessionToken));\n    if (forceRemoveDoubles) {\n      Iterator<Track> iter = tracks.iterator();\n      while (iter.hasNext()) {\n        Track track = iter.next();\n        for (Track recent : recentlyPlayed) {\n          if (track.getID().equals(recent.getID())) {\n            iter.remove();\n          }\n        }\n      }\n    }\n    return tracks;\n  }\n\n  public Optional<List<ArtRef>> getImageArtRefs() {\n    return Optional.ofNullable(imageArtRefs);\n  }\n\n  public Optional<List<ArtRef>> getCompositeArtRefs() {\n    return Optional.ofNullable(compositeArtRefs);\n  }\n\n  public Optional<List<String>> getContentTypes() {\n    return Optional.ofNullable(contentTypes);\n  }\n\n  public Optional<String> getByline() {\n    return Optional.ofNullable(byline);\n  }\n\n  public Optional<String> getSessionToken() {\n    return Optional.ofNullable(sessionToken);\n  }\n\n  @Override\n  public ResultType getResultType() {\n    return RESULT_TYPE;\n  }\n\n  public void delete()\n      throws IOException {\n    mainApi.getStationApi().deleteStations(this);\n  }\n\n  public String string() {\n    return gson.toJson(this);\n  }\n\n  @Override\n  public GPlayMusic getApi() {\n    return this.mainApi;\n  }\n\n  @Override\n  public void setApi(GPlayMusic api) {\n    this.mainApi = api;\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/requests/SearchTypes.java\npublic class SearchTypes {\n\n  private List<ResultType> types;\n\n  public SearchTypes(List<ResultType> types) {\n    this.types = types;\n  }\n\n  public SearchTypes(ResultType... types) {\n    this.types = Arrays.asList(types);\n  }\n\n  public List<ResultType> getTypes() {\n    return types;\n  }\n\n  public void setTypes(List<ResultType> types) {\n    this.types = types;\n  }\n\n  @Override\n  public String toString() {\n    return types.stream().map(t -> Integer.toString(t.getValue())).collect(Collectors.joining(\",\"));\n  }\n}\nsrc/test/java/com/github/felixgail/gplaymusic/util/TestUtil.java\npublic static void assertTracks(Track... tracks) {\n  assertTracks(Arrays.asList(tracks));\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/Album.java\npublic class Album implements Result, Serializable {\n\n  public final static ResultType RESULT_TYPE = ResultType.ALBUM;\n\n  @Expose\n  private String name;\n  @Expose\n  private String albumArtist;\n  @Expose\n  @SerializedName(\"albumArtRef\")\n  private String albumArtUrl;\n  @Expose\n  private String albumId;\n  @Expose\n  private String artist;\n  @Expose\n  private List<String> artistId;\n  @Expose\n  private int year;\n  @Expose\n  private String explicitType;\n  @Expose\n  @SerializedName(\"description_attribution\")\n  private Attribution descriptionAttribution;\n  @Expose\n  private String description;\n  @Expose\n  private String contentType;\n  @Expose\n  private List<Track> tracks;\n\n  public Album(@NotNull String name, @NotNull String albumArtist, @NotNull String albumId,\n      @NotNull String artist,\n      @NotNull List<String> artistId) {\n    this.name = name;\n    this.albumArtist = albumArtist;\n    this.albumId = albumId;\n    this.artist = artist;\n    this.artistId = artistId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public String getAlbumArtist() {\n    return albumArtist;\n  }\n\n  public Optional<String> getAlbumArtUrl() {\n    return Optional.ofNullable(albumArtUrl);\n  }\n\n  public String getAlbumId() {\n    return albumId;\n  }\n\n  public String getArtist() {\n    return artist;\n  }\n\n  public List<String> getArtistId() {\n    return artistId;\n  }\n\n  public OptionalInt getYear() {\n    return OptionalInt.of(year);\n  }\n\n  public Optional<String> getExplicitType() {\n    return Optional.ofNullable(explicitType);\n  }\n\n  public Optional<Attribution> getDescriptionAttribution() {\n    return Optional.ofNullable(descriptionAttribution);\n  }\n\n  public Optional<String> getDescription() {\n    return Optional.ofNullable(description);\n  }\n\n  public Optional<String> getContentType() {\n    return Optional.ofNullable(contentType);\n  }\n\n  public Optional<List<Track>> getTracks() {\n    return Optional.ofNullable(tracks);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    return (o instanceof Album) && ((Album) o).getAlbumId().equals(this.albumId);\n  }\n\n  @Override\n  public ResultType getResultType() {\n    return RESULT_TYPE;\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/enums/ResultType.java\npublic enum ResultType implements Serializable {\n  @SerializedName(\"1\")\n  TRACK(1, \"track\", Track.class),\n  @SerializedName(\"2\")\n  ARTIST(2, \"artist\", Artist.class),\n  @SerializedName(\"3\")\n  ALBUM(3, \"album\", Album.class),\n  @SerializedName(\"4\")\n  PLAYLIST(4, \"playlist\", Playlist.class),\n  @SerializedName(\"6\")\n  STATION(6, \"station\", Station.class),\n  @SerializedName(\"7\")\n  SITUATION(7, \"situation\", Situation.class),\n  @SerializedName(\"8\")\n  VIDEO(8, \"youtube_video\", Video.class),\n  @SerializedName(\"9\")\n  PODCAST_SERIES(9, \"podcast\", PodcastSeries.class); //Not tested, needs US vpn\n\n  private final int value;\n  private final String name;\n  private final Type type;\n\n  ResultType(final int value, final String name, final Type type) {\n    this.value = value;\n    this.name = name;\n    this.type = type;\n  }\n\n  public int getValue() {\n    return value;\n  }\n\n  public Type getType() {\n    return type;\n  }\n\n  public String getName() {\n    return name;\n  }\n}\nsrc/test/java/com/github/felixgail/gplaymusic/util/TestUtil.java\npublic class TestUtil {\n\n  public static final Property USERNAME;\n  public static final Property PASSWORD;\n  public static final Property ANDROID_ID;\n  public static final Property TOKEN;\n  public static final Property FREE_USERNAME;\n  public static final Property FREE_PASSWORD;\n  public static final Property FREE_ANDROID_ID;\n  public static final Property FREE_TOKEN;\n  private static final Properties PROPS;\n  private static final String RESOURCE = \"gplaymusic.properties\";\n\n  static {\n    PROPS = new Properties();\n    InputStream in = TestUtil.class\n        .getClassLoader()\n        .getResourceAsStream(RESOURCE);\n\n    try {\n      PROPS.load(in);\n      in.close();\n    } catch (IOException | NullPointerException e) {\n      System.out.println(\"gplaymusic.properties file not found. Most test will not be executed.\");\n    }\n    USERNAME = new Property(\"auth.username\");\n    PASSWORD = new Property(\"auth.password\");\n    ANDROID_ID = new Property(\"auth.android_id\");\n    TOKEN = new Property(\"auth.token\");\n\n    FREE_USERNAME = new Property(\"auth.free.username\");\n    FREE_PASSWORD = new Property(\"auth.free.password\");\n    FREE_ANDROID_ID = new Property(\"auth.free.android_id\");\n    FREE_TOKEN = new Property(\"auth.free.token\");\n  }\n\n  public static Property get(String s) {\n    return new Property(s);\n  }\n\n  public static void set(String key, String value) throws IOException {\n    PrintWriter writer = null;\n    try {\n      writer = new PrintWriter(TestUtil.class.getClassLoader().getResource(RESOURCE).getFile());\n      PROPS.setProperty(key, value);\n      PROPS.store(writer, null);\n    } finally {\n      if (writer != null) {\n        writer.close();\n      }\n    }\n  }\n\n  public static void assume(Property... properties) {\n    for (Property property : properties) {\n      Assume.assumeTrue(\n          String.format(\"Test has been skipped. Required value \\\"%s\\\" is missing.\",\n              property.getKey()),\n          property.isValid());\n    }\n  }\n\n  public static void assumeFilled(Property... properties) {\n    assume(properties);\n    for (Property property : properties) {\n      Assume.assumeTrue(\n          String.format(\"Test has been skipped. \\\"%s\\\" is not allowed to be an empty String.\",\n              property.getKey()),\n          !property.get().isEmpty());\n    }\n  }\n\n  public static void assume(Object... objects) {\n    for (Object object : objects) {\n      Assume.assumeNotNull(\n          String.format(\"Test has been skipped. Required object \\\"%s\\\" is null.\", object),\n          object);\n    }\n  }\n\n  public static void testPlaylistEntries(List<PlaylistEntry> entries) throws IOException {\n    for (PlaylistEntry entry : entries) {\n      assertNotNull(entry);\n      assertNotNull(entry.getAbsolutePosition());\n      assertNotNull(entry.getTrackId());\n      assertTracks(entry.getTrack());\n    }\n  }\n\n  public static void assertTracks(Track... tracks) {\n    assertTracks(Arrays.asList(tracks));\n  }\n\n  public static void assertTracks(List<Track> tracks) {\n    for (Track track : tracks) {\n      assertNotNull(track);\n      assertNotNull(track.getTitle());\n      assertNotNull(track.getArtist());\n      assertNotNull(track.getID());\n    }\n  }\n\n  public static void testStation(Station station) throws IOException {\n    assertNotNull(station);\n    List<Track> tracks = station.getTracks(null, true, false);\n    assertNotNull(tracks);\n    assertTracks(tracks);\n    assertTrue(\"Empty track list returned\", tracks.size() > 0);\n  }\n\n  public static int containsDoubledTracks(List<Track> list1, List<Track> list2) {\n    int doubledTracks = 0;\n    if (list1 != null && list2 != null) {\n      for (Track fromList1 : list1) {\n        for (Track fromList2 : list2) {\n          if (fromList1.getID().equals(fromList2.getID())) {\n            System.out.printf(\"Equal Songs:\\nSong1: %s (%s)\\nSong2: %s (%s)\",\n                fromList1.getTitle(), fromList1.getID(),\n                fromList2.getTitle(), fromList2.getID());\n            doubledTracks++;\n          }\n        }\n      }\n    }\n    return doubledTracks;\n  }\n\n  public static void testDownload(String fileName, Track track) throws IOException {\n    Path path = FileSystems.getDefault().getPath(System.getProperty(\"java.io.tmpdir\"), fileName);\n    track.download(StreamQuality.LOW, path);\n    File file = path.toFile();\n    Assert.assertTrue(\"File does not exist\", file.exists());\n    Assert.assertEquals(\"Is not an audio file\", new Tika().detect(file), \"audio/mpeg\");\n  }\n\n  public static class Property {\n\n    private String key;\n\n    public Property(String k) {\n      this.key = k;\n    }\n\n    public String getKey() {\n      return key;\n    }\n\n    @Override\n    public String toString() {\n      return get();\n    }\n\n    public boolean isValid() {\n      return (get() != null);\n    }\n\n    public String get() {\n      return PROPS.getProperty(getKey());\n    }\n  }\n\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/snippets/StationSeed.java\n@JsonAdapter(StationSeedSerializer.class)\npublic class StationSeed implements Serializable {\n\n  @Expose\n  private StationSeedType seedType;\n  @Expose\n  @SerializedName(value = \"albumId\", alternate = {\"artistId\", \"genreId\", \"trackId\",\n      \"curatedStationId\", \"playlistShareToken\"})\n  private String seedId;\n  @Expose\n  private MetadataSeed metadataSeed;\n\n  public StationSeed() {\n  }\n\n  public StationSeed(Album album) {\n    this.seedType = StationSeedType.ALBUM;\n    this.seedId = album.getAlbumId();\n  }\n\n  public StationSeed(Artist artist) {\n    this.seedType = StationSeedType.ARTIST;\n    this.seedId = artist.getArtistId()\n        .orElseThrow(\n            () -> new IllegalArgumentException(\"ArtistID not present. Unable to create seed\"));\n  }\n\n  public StationSeed(Playlist playlist) {\n    this.seedType = StationSeedType.PLAYLIST;\n    this.seedId = playlist.getShareToken();\n  }\n\n  public StationSeed(Genre genre) {\n    this.seedType = StationSeedType.GENRE;\n    this.seedId = genre.getId();\n  }\n\n  /**\n   * Creates a StationSeed from a Station created by a Curated Station. Use this with care, as this\n   * will only work on stations that meet the initial description. Deprecated since you should use\n   * the {@link Station#getSeed()} method to retrieve the seed from a curated station instead of\n   * creating a new one.\n   */\n  @Deprecated\n  public StationSeed(Station curatedStation) {\n    this.seedType = StationSeedType.CURATED_STATION;\n    this.seedId = curatedStation.getClientId()\n        .orElseThrow(() -> new IllegalArgumentException(\"Station does not contain a clientID\"));\n  }\n\n  public StationSeed(Track track) {\n    this.seedType = StationSeedType.TRACK;\n    this.seedId = track.getID();\n  }\n\n  public StationSeedType getSeedType() {\n    return seedType;\n  }\n\n  public MetadataSeed getMetadataSeed() {\n    return metadataSeed;\n  }\n\n  public void setMetadataSeed(MetadataSeed metadataSeed) {\n    this.metadataSeed = metadataSeed;\n  }\n\n  public String getSeed() {\n    return seedId;\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/Artist.java\npublic class Artist implements Result, Serializable {\n\n  public final static ResultType RESULT_TYPE = ResultType.ARTIST;\n\n  @Expose\n  private String name;\n  @Expose\n  @SerializedName(\"artistArtRef\")\n  private String artistArtUrl;\n  @Expose\n  private List<ArtRef> artistArtRefs;\n  @Expose\n  private String artistId;\n  @Expose\n  @SerializedName(\"artist_bio_attribution\")\n  private Attribution artistBioAttribution;\n  @Expose\n  private String artistBio;\n  @Expose\n  @SerializedName(\"related_artists\")\n  private List<Artist> relatedArtists;\n  @Expose\n  @SerializedName(\"total_albums\")\n  private int totalAlbums;\n  @Expose\n  private List<Track> topTracks;\n  @Expose\n  private List<Album> albums;\n\n  public Artist(@NotNull String name) {\n    this.name = name;\n  }\n\n  public Optional<List<Artist>> getRelatedArtists() {\n    return Optional.ofNullable(relatedArtists);\n  }\n\n  public OptionalInt getTotalAlbums() {\n    return OptionalInt.of(totalAlbums);\n  }\n\n  public Optional<List<Track>> getTopTracks() {\n    return Optional.ofNullable(topTracks);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public Optional<String> getArtistArtUrl() {\n    return Optional.ofNullable(artistArtUrl);\n  }\n\n  public Optional<List<ArtRef>> getArtistArtRefs() {\n    return Optional.ofNullable(artistArtRefs);\n  }\n\n  public Optional<String> getArtistId() {\n    return Optional.ofNullable(artistId);\n  }\n\n  public Optional<Attribution> getArtistBioAttribution() {\n    return Optional.ofNullable(artistBioAttribution);\n  }\n\n  public Optional<String> getArtistBio() {\n    return Optional.ofNullable(artistBio);\n  }\n\n  public Optional<List<Album>> getAlbums() {\n    return Optional.ofNullable(albums);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    return (o instanceof Artist) && ((Artist) o).getArtistId().equals(this.artistId);\n  }\n\n  @Override\n  public ResultType getResultType() {\n    return RESULT_TYPE;\n  }\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/enums/StationSeedType.java\npublic enum StationSeedType {\n  @SerializedName(\"2\")\n  TRACK(2, \"trackId\", Track.class),\n  @SerializedName(\"3\")\n  ARTIST(3, \"artistId\", Artist.class),\n  @SerializedName(\"4\")\n  ALBUM(4, \"albumId\", Album.class),\n  @SerializedName(\"5\")\n  GENRE(5, \"genreId\", Genre.class),\n  //ID 6 IS \"i'm feelin lucky radio\"\n  @SerializedName(\"8\")\n  PLAYLIST(8, \"playlistShareToken\", Playlist.class),\n  @SerializedName(\"9\")\n  CURATED_STATION(9, \"curatedStationId\", Station.class);\n\n  private int id;\n  private String key;\n  private Type seedClass;\n\n  StationSeedType(int id, String key, Type seedClass) {\n    this.id = id;\n    this.key = key;\n    this.seedClass = seedClass;\n  }\n\n  public int getId() {\n    return id;\n  }\n\n  public String getKey() {\n    return key;\n  }\n\n  public Type getSeedClass() {\n    return seedClass;\n  }\n}\nsrc/test/java/com/github/felixgail/gplaymusic/util/TestUtil.java\npublic static void assume(Property... properties) {\n  for (Property property : properties) {\n    Assume.assumeTrue(\n        String.format(\"Test has been skipped. Required value \\\"%s\\\" is missing.\",\n            property.getKey()),\n        property.isValid());\n  }\n}\nsrc/test/java/com/github/felixgail/gplaymusic/util/TestUtil.java\npublic static int containsDoubledTracks(List<Track> list1, List<Track> list2) {\n  int doubledTracks = 0;\n  if (list1 != null && list2 != null) {\n    for (Track fromList1 : list1) {\n      for (Track fromList2 : list2) {\n        if (fromList1.getID().equals(fromList2.getID())) {\n          System.out.printf(\"Equal Songs:\\nSong1: %s (%s)\\nSong2: %s (%s)\",\n              fromList1.getTitle(), fromList1.getID(),\n              fromList2.getTitle(), fromList2.getID());\n          doubledTracks++;\n        }\n      }\n    }\n  }\n  return doubledTracks;\n}\nsrc/main/java/com/github/felixgail/gplaymusic/model/Track.java\npublic class Track extends Signable implements Result, Serializable, Model {\n\n  public final static ResultType RESULT_TYPE = ResultType.TRACK;\n  private static Gson gsonPrettyPrinter = new GsonBuilder().setPrettyPrinting().create();\n\n  //TODO: Not all Attributes added (eg. PrimaryVideo, ID? where is id used).\n  @Expose\n  private String title;\n  @Expose\n  private String artist;\n  @Expose\n  private String composer;\n  @Expose\n  private String album;\n  @Expose\n  private String albumArtist;\n  @Expose\n  private int year;\n  @Expose\n  private int trackNumber;\n  @Expose\n  private String genre;\n  @Expose\n  private String durationMillis;\n  @Expose\n  private List<ArtRef> albumArtRef;\n  @Expose\n  private List<ArtRef> artistArtRef;\n  @Expose\n  private int discNumber;\n  @Expose\n  private String estimatedSize;\n  @Expose\n  private String trackType;\n  @Expose\n  private String storeId;\n  @Expose\n  private String albumId;\n  @Expose\n  private List<String> artistId;\n  @Expose\n  private String nid;\n  @Expose\n  private boolean trackAvailableForSubscription;\n  @Expose\n  private boolean trackAvailableForPurchase;\n  @Expose\n  private boolean albumAvailableForPurchase;\n  @Expose\n  private String explicitType;\n  @Expose\n  private int playCount;\n  @Expose\n  private String rating;\n  @Expose\n  private int beatsPerMinute;\n  @Expose\n  private String clientId;\n  @Expose\n  private String comment;\n  @Expose\n  private int totalTrackCount;\n  @Expose\n  private int totalDiscCount;\n  @Expose\n  private String lastRatingChangeTimestamp;\n  @Expose\n  private String lastModifiedTimestamp;\n  @Expose\n  private String contentType;\n  @Expose\n  private String creationTimestamp;\n  @Expose\n  private String recentTimestamp;\n  @Expose\n  @SerializedName(\"id\")\n  private String uuid;\n  @Expose\n  @SerializedName(\"primaryVideo\")\n  private Video video;\n\n  private String sessionToken;\n  private GPlayMusic mainApi;\n\n  //This attribute is only set when the track is retrieved from a station.\n  @Expose\n  @SerializedName(\"wentryid\")\n  private String wentryID;\n\n  private Track() {\n  }\n\n  public String getTitle() {\n    return title;\n  }\n\n  public String getArtist() {\n    return artist;\n  }\n\n  public String getComposer() {\n    return composer;\n  }\n\n  public String getAlbum() {\n    return album;\n  }\n\n  public String getAlbumArtist() {\n    return albumArtist;\n  }\n\n  public OptionalInt getYear() {\n    return OptionalInt.of(year);\n  }\n\n  public int getTrackNumber() {\n    return trackNumber;\n  }\n\n  //TODO: Return genre instead of string\n  public Optional<String> getGenre() {\n    return Optional.ofNullable(genre);\n  }\n\n  public Long getDurationMillis() {\n    return Long.parseLong(durationMillis);\n  }\n\n  public Optional<List<ArtRef>> getAlbumArtRef() {\n    return Optional.ofNullable(albumArtRef);\n  }\n\n  public Optional<List<ArtRef>> getArtistArtRef() {\n    return Optional.ofNullable(artistArtRef);\n  }\n\n  public int getDiscNumber() {\n    return discNumber;\n  }\n\n  public long getEstimatedSize() {\n    return Long.parseLong(estimatedSize);\n  }\n\n  public Optional<String> getTrackType() {\n    return Optional.ofNullable(trackType);\n  }\n\n  /**\n   * Returns how often the song has been played. Not valid, when song has been fetched via {@link\n   * TrackApi#getTrack(String)} as the server response does not contain this key.\n   */\n  public OptionalInt getPlayCount() {\n    return OptionalInt.of(playCount);\n  }\n\n  public Optional<String> getRating() {\n    return Optional.ofNullable(rating);\n  }\n\n  public OptionalInt getBeatsPerMinute() {\n    return OptionalInt.of(beatsPerMinute);\n  }\n\n  public Optional<String> getClientId() {\n    return Optional.ofNullable(clientId);\n  }\n\n  public Optional<String> getComment() {\n    return Optional.ofNullable(comment);\n  }\n\n  @Override\n  public String getID() {\n    return getStoreId().orElseGet(\n        () -> getUuid().orElseThrow(\n            () -> new NullPointerException(\"Track contains neither StoreID nor UUID.\")));\n  }\n\n  public Optional<String> getStoreId() {\n    return Optional.ofNullable(storeId);\n  }\n\n  public String getAlbumId() {\n    return albumId;\n  }\n\n  public Optional<List<String>> getArtistId() {\n    return Optional.ofNullable(artistId);\n  }\n\n  public Optional<String> getNid() {\n    return Optional.ofNullable(nid);\n  }\n\n  public boolean isTrackAvailableForSubscription() {\n    return trackAvailableForSubscription;\n  }\n\n\n  public boolean isTrackAvailableForPurchase() {\n    return trackAvailableForPurchase;\n  }\n\n  public boolean isAlbumAvailableForPurchase() {\n    return albumAvailableForPurchase;\n  }\n\n  public Optional<String> getExplicitType() {\n    return Optional.ofNullable(explicitType);\n  }\n\n  public String getWentryID() {\n    return wentryID;\n  }\n\n  public OptionalInt getTotalTrackCount() {\n    return OptionalInt.of(totalTrackCount);\n  }\n\n  public OptionalInt getTotalDiscCount() {\n    return OptionalInt.of(totalDiscCount);\n  }\n\n  public Optional<String> getLastRatingChangeTimestamp() {\n    return Optional.ofNullable(lastRatingChangeTimestamp);\n  }\n\n  public Optional<String> getLastModifiedTimestamp() {\n    return Optional.ofNullable(lastModifiedTimestamp);\n  }\n\n  public Optional<String> getContentType() {\n    return Optional.ofNullable(contentType);\n  }\n\n  public Optional<String> getCreationTimestamp() {\n    return Optional.ofNullable(creationTimestamp);\n  }\n\n  public Optional<String> getRecentTimestamp() {\n    return Optional.ofNullable(recentTimestamp);\n  }\n\n  public Optional<String> getUuid() {\n    return Optional.ofNullable(uuid);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    return (o instanceof Track) && ((Track) o).getID().equals(this.getID());\n  }\n\n  @Override\n  public Signature getSignature() {\n    return super.createSignature(this.getID());\n  }\n\n  @Override\n  public ResultType getResultType() {\n    return RESULT_TYPE;\n  }\n\n  /**\n   * Returns a URL to download the song in set quality. URL will only be valid for 1 minute. You\n   * will likely need to handle redirects. <br> <b>Please note that this function is available for\n   * Subscribers only. On free accounts use {@link #getStationTrackURL(StreamQuality)}.</b>\n   *\n   * @param quality quality of the stream\n   * @return temporary url to the title\n   * @throws IOException Throws an IOException on severe failures (no internet connection...) or a\n   * {@link NetworkException} on request failures.\n   */\n  @Override\n  public URL getStreamURL(StreamQuality quality)\n      throws IOException {\n    if (!easyDownloadPossible()) {\n      getStationTrackURL(quality);\n    }\n    return urlFetcher(mainApi, quality, Provider.STREAM, EMPTY_MAP);\n  }\n\n  /**\n   * Fetch the URL for a track from a free Station. Make sure this Track was returned by a {@link\n   * Station}. Otherwise an {@link IOException} will be thrown. <br> <b>Subscribers will be\n   * redirected to {@link #getStreamURL(StreamQuality)}</b>\n   *\n   * @param quality - quality of the stream\n   * @return a url to download songs from.\n   * @throws IOException on severe failures (no internet connection...) or a {@link\n   * NetworkException} on request failures.\n   */\n  public URL getStationTrackURL(StreamQuality quality)\n      throws IOException {\n    if (mainApi.getConfig().getSubscription() == SubscriptionType.ALL_ACCESS) {\n      return getStreamURL(quality);\n    }\n    if (getWentryID() == null || getWentryID().isEmpty()) {\n      throw new IOException(Language.get(\"track.InvalidWentryID\"));\n    }\n    if (!getSessionToken().isPresent()) {\n      throw new IOException(Language.get(\"station.InvalidSessionToken\"));\n    }\n    Map<String, String> map = new HashMap<>();\n    map.putAll(STATION_MAP);\n    map.put(\"wentryid\", getWentryID());\n    map.put(\"sesstok\", getSessionToken().get());\n    return urlFetcher(mainApi, quality, Provider.STATION, map);\n  }\n\n  /**\n   * Increments the playcount of this song by {@code count}.\n   *\n   * @param count amount of plays that will be added to the current count.\n   * @return whether the incrementation was successful.\n   */\n  public boolean incrementPlaycount(int count) throws IOException {\n    MutationResponse response = mainApi.getService().incremetPlaycount(\n        new IncrementPlaycountRequest(count, this)).execute().body();\n    if (response.checkSuccess()) {\n      playCount += count;\n      return true;\n    }\n    return false;\n  }\n\n  public String string() {\n    return gsonPrettyPrinter.toJson(this);\n  }\n\n  /**\n   * Downloads the song to the provided path. Existing files will be replaced.\n   */\n  public void download(StreamQuality quality, Path path) throws IOException {\n    URL trackUrl;\n    if (easyDownloadPossible()) {\n      trackUrl = getStreamURL(quality);\n    } else {\n      trackUrl = getStationTrackURL(quality);\n    }\n    Files.copy(trackUrl.openStream(), path, StandardCopyOption.REPLACE_EXISTING);\n  }\n\n  private boolean easyDownloadPossible() {\n    if (mainApi.getConfig().getSubscription() == SubscriptionType.ALL_ACCESS || !getID()\n        .startsWith(\"T\")) {\n      return true;\n    }\n    return false;\n  }\n\n  private Optional<String> getSessionToken() {\n    return Optional.ofNullable(sessionToken);\n  }\n\n  void setSessionToken(String token) {\n    this.sessionToken = token;\n  }\n\n  public Optional<Video> getVideo() {\n    return Optional.ofNullable(video);\n  }\n\n  @Override\n  public GPlayMusic getApi() {\n    return mainApi;\n  }\n\n  @Override\n  public void setApi(GPlayMusic api) {\n    this.mainApi = api;\n  }\n}\n", "answers": ["    assume(track);"], "length": 3038, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "f9f2f3fc1cfbc4e08ed95a2581f0c0a4065a201e9e2fb216"}
{"input": "import com.yahoo.sql4d.BaseStatementMeta;\nimport com.yahoo.sql4d.CrudProgram;\nimport com.yahoo.sql4d.CrudStatementMeta;\nimport com.yahoo.sql4d.query.RequestType;\nimport static com.yahoo.sql4d.sql4ddriver.Util.*;\nimport com.yahoo.sql4d.DCompiler;\nimport com.yahoo.sql4d.DeleteProgram;\nimport com.yahoo.sql4d.DropProgram;\nimport com.yahoo.sql4d.InsertProgram;\nimport com.yahoo.sql4d.Program;\nimport com.yahoo.sql4d.QueryProgram;\nimport com.yahoo.sql4d.delete.DeleteMeta;\nimport com.yahoo.sql4d.drop.DropMeta;\nimport com.yahoo.sql4d.insert.InsertMeta;\nimport com.yahoo.sql4d.query.QueryMeta;\nimport com.yahoo.sql4d.query.nodes.Interval;\nimport com.yahoo.sql4d.query.select.SelectQueryMeta;\nimport com.yahoo.sql4d.sql4ddriver.rowmapper.DruidBaseBean;\nimport com.yahoo.sql4d.sql4ddriver.sql.MysqlAccessor;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport org.joda.time.DateTime;\nimport org.json.JSONArray;\nimport scala.util.Either;\nimport scala.util.Left;\nimport scala.util.Right;\nimport scala.Tuple2;\n    }\n\n    /**\n     * Query and return the Json response.\n     *\n     * @param sqlQuery\n     * @param reqHeaders\n     * @return\n     */\n    public Either<String, Either<Joiner4All, Mapper4All>> query(String sqlQuery, Map<String, String> reqHeaders) {\n        return query(sqlQuery, null, reqHeaders, false, \"sql\");\n    }\n\n    /**\n     * TODO: This method is still buggy and not fully implemented.\n     * Common interface to Insert , Delete, Drop(but not coordinator commands).\n     * @param sqlOrJsonQuery\n     * @param namedParams\n     * @param reqHeaders\n     * @param printToConsole\n     * @param queryMode\n     * @param forceAsync\n     * @return \n     */\n    public String crud(String sqlOrJsonQuery, NamedParameters namedParams, Map<String, String> reqHeaders, boolean printToConsole, String queryMode, boolean forceAsync) {\n        if (\"json\".equals(queryMode)) {//TODO : #19\n        }\n        Program pgm;\n        try {\n            pgm = getCompiledAST(sqlOrJsonQuery, namedParams, reqHeaders);\n        } catch (Exception ex) {\n            return ex.getMessage();\n        }\n        if (printToConsole) {\n            println(pgm.toString());\n        }\n        if (pgm instanceof CrudProgram) {\n            CrudProgram cPgm = (CrudProgram) pgm;\n            return overlord.fireTask((CrudStatementMeta)cPgm.nthStmnt(0), reqHeaders, cPgm.waitForCompletion && !forceAsync);\n        }\n        return \"Could not execute the program \" + pgm;\n    }\n    /**\n     * Common interface to Query, Insert , Delete, Drop(but not coordinator commands).\n     * @param sqlOrJsonQuery\n     * @param namedParams\n     * @param reqHeaders\n     * @param printToConsole\n     * @param queryMode\n     * @return \n     */\n    public Either<String, Either<Joiner4All, Mapper4All>> query(String sqlOrJsonQuery, NamedParameters namedParams, Map<String, String> reqHeaders, boolean printToConsole, String queryMode) {\n        return query(sqlOrJsonQuery, namedParams, reqHeaders, printToConsole, queryMode, false);\n    }\n    \n    /**\n     * Use this to force asynchronous mode(indexer tasks). You can then call\n     * {@link DDataSource#pollIndexerTaskStatus(java.lang.String) } to poll and find\n     * status. Hard limit on any task is 2 hours. See {@link OverlordAccessor} for more.\n     * @param sqlOrJsonQuery\n     * @param namedParams\n     * @param reqHeaders\n     * @param printToConsole\n     * @param queryMode\n     * @param forceAsync\n     * @return \n     */\n    public Either<String, Either<Joiner4All, Mapper4All>> query(String sqlOrJsonQuery, NamedParameters namedParams, Map<String, String> reqHeaders, boolean printToConsole, String queryMode, boolean forceAsync) {\n        if (\"json\".equals(queryMode)) {//TODO : #19\n            Either<String, Either<Mapper4All, JSONArray>> result = broker.fireQuery(sqlOrJsonQuery, reqHeaders, true);\n            if (result.isLeft()) return new Left<>(result.left().get());\n            if (printToConsole) {\n                println(result.right().get().left().get().toString());\n            }\n            return new Right<String, Either<Joiner4All, Mapper4All>>(new Right<Joiner4All, Mapper4All>(result.right().get().left().get()));\n        }\n        Program pgm;\n        try {\n            pgm = getCompiledAST(sqlOrJsonQuery, namedParams, reqHeaders);\n        } catch (Exception ex) {\n            return new Left<>(ex.getMessage());\n        }\n        if (pgm instanceof DeleteProgram) {\n            return new Left<>(deleteRows((DeleteProgram) pgm, reqHeaders, printToConsole));\n        } else if (pgm instanceof DropProgram) {\n            return new Left<>(dropTable((DropProgram) pgm, reqHeaders, printToConsole));\n        } else if (pgm instanceof InsertProgram) {\n            InsertProgram iPgm = (InsertProgram) pgm;\n            iPgm.print(printToConsole);\n            return new Left<>(overlord.fireTask(iPgm.nthStmnt(0), reqHeaders, !forceAsync && iPgm.waitForCompletion));\n        } else {\n            return selectRows((QueryProgram) pgm, reqHeaders, printToConsole);\n        }\n    }\n    \n    public TaskStatus pollIndexerTaskStatus(String taskId) {\n        return overlord.pollTaskStatus(taskId, null);\n    }\n    \n    private String deleteRows(DeleteProgram dPgm, Map<String, String> reqHeaders, boolean printToConsole) {\n        DeleteMeta dMeta = (DeleteMeta)dPgm.nthStmnt(0);\n        dbAccessor.disableSegmentsInRange(dMeta.dataSource, dMeta.interval);\n        //TODO: Optimize the following 2 makes 1 call each to coordinator(replace with aboutDataSource single call)\n        dMeta.dimensions = coordinator.getDimensions(dMeta.dataSource, reqHeaders);\n        dMeta.metrics = coordinator.getMetrics(dMeta.dataSource, reqHeaders);\n        dPgm.print(printToConsole);\n        return overlord.fireTask((CrudStatementMeta)dMeta, reqHeaders, dPgm.waitForCompletion);\n    }\n    \n    private String dropTable(DropProgram dPgm, Map<String, String> reqHeaders, boolean printToConsole) {\n        DropMeta dMeta = (DropMeta)dPgm.nthStmnt(0);\n        try {\n            dMeta.interval = broker.getTimeBoundary(dMeta.dataSource, reqHeaders);// Set the boundary to max possible for the table.\n        } catch (IllegalAccessException ex) {\n            return ex.toString();\n        }\n        //TODO: Time boundary returns start Time of 1st segment and start time of last segment which means \n        // getting rid just that interval is insufficient, so increase the end time\n        // by 62 days this will ensure we delete the table if the max segment granularity\n        // is 2 months. For bigger segments drop will not work properly.", "context": "Sql4Ddriver/src/main/java/com/yahoo/sql4d/sql4ddriver/rowmapper/DruidBaseBean.java\npublic class DruidBaseBean<T extends DruidBaseBean> extends Serializer<T> {\n    private static final DateTimeFormatter dateOnlyFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd\");\n    private static final DateTimeFormatter dateTimeFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss\");\n    private static final DateTimeFormatter dateTimeWithSubSecFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\");\n    private static final DateTimeFormatter dateTimeAndTZFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ssZZ\");\n    private static final DateTimeFormatter dateTimeWithSubSecAndTZFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZZ\");\n\n    public static void main(String[] args) {\n        System.out.println(dateTimeFormat.parseDateTime(\"2014-05-25T16:45:49\"));\n        System.out.println(dateTimeAndTZFormat.parseDateTime(\"2014-05-25T16:45:49+00:00\"));\n        System.out.println(dateTimeAndTZFormat.parseDateTime(\"2014-05-25T16:45:49Z\"));\n        System.out.println(dateTimeWithSubSecFormat.parseDateTime(\"2014-05-25T16:45:49.100\"));\n        System.out.println(dateTimeWithSubSecAndTZFormat.parseDateTime(\"2014-05-25T16:45:49.000Z\"));\n    }\n\n    public String timestamp;// TODO: Crazy,though getDeclaredMethods can be used to access private fields, it is not possible on subclasses.\n\n    public void setTimestamp(String timestamp) {\n        this.timestamp = timestamp;\n    }\n\n    public String getTimestamp() {\n        return timestamp;\n    }\n    \n    public Map<String, Object> toMap() {\n        Map<String, Object> map = new ObjectMapper().convertValue(this, Map.class);\n        // The following 2 comes from Serializer.\n        map.remove(\"acceptsNull\");\n        map.remove(\"immutable\");\n        return map;        \n    }\n\n    @Override\n    public String toString() {\n        return toMap().toString();\n    }\n\n    @Override\n    public void write(Kryo kryo, Output output, T t) {\n        Map<String, Object> map = toMap();\n        for (String key:map.keySet()) {\n            Object value = map.get(key);\n            kryo.writeClass(output, value.getClass());\n            kryo.writeObjectOrNull(output, key, String.class);\n            kryo.writeObjectOrNull(output, value, value.getClass());\n        }\n    }\n\n    @Override\n    public T read(Kryo kryo, Input input, Class<T> type) {\n        T retValue = null;\n        try {\n            retValue = type.newInstance();\n            Registration reg = kryo.readClass(input);\n            String key = kryo.readObjectOrNull(input, String.class);\n            Object value = kryo.readObjectOrNull(input, reg.getType());\n            Util.applyKVToBean(retValue, key, value);\n        } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | IllegalArgumentException | InvocationTargetException ex) {\n            Logger.getLogger(DruidBaseBean.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return retValue;\n    }\n    \n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/InsertProgram.java\npublic class InsertProgram extends CrudProgram<InsertMeta>{\n    public static InsertProgram getInsertInstance() {\n        return new InsertProgram(Type.INSERT);\n    } \n    \n    public static InsertProgram getInsertHadoopInstance() {\n        return new InsertProgram(Type.INSERT_HADOOP);\n    } \n\n    public static InsertProgram getInsertRTInstance() {\n        return new InsertProgram(Type.INSERT_REALTIME);\n    } \n\n    private InsertProgram(Type type) {\n        this.type = type;\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n        for (InsertMeta iMeta: getAllStmnts()) {\n            System.out.println(iMeta.toString());\n        }\n        return buffer.toString();\n    }\n    \n    /**\n     * TODO: Do all semantic checks here. 1st field should be timestamp.\n     * @throws java.lang.Exception\n     */\n    @Override\n    public void isValid() throws Exception {\n    }\n\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/DCompiler.java\npublic class DCompiler {\n    /**\n     * To avoid instantiation.\n     */\n    private DCompiler() {\n    }\n    /**\n     * Sql->Json.\n     * @param query\n     * @return \n     */\n    public static Program compileSql(String query) {\n        try {\n            ANTLRStringStream in = new ANTLRStringStream(query);\n            druidGLexer lexer = new druidGLexer(in);\n            CommonTokenStream tokens = new CommonTokenStream(lexer);\n            druidGParser parser = new druidGParser(tokens);\n            Program pgm = parser.program();\n            return pgm;\n        } catch (RecognitionException ex) {\n            System.out.println(ex);\n            Logger.getLogger(DCompiler.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return null;\n    }\n    \n    public static void main(String[] args) {\n        //Program p = compileSql(\"select UNIQUE(referer) AS refe, referer FROM miab_hourly_v2 WHERE interval BETWEEN 2014-11-05T08:18:00.000Z AND 2014-11-05T08:20:00.000Z  BREAK BY 'day' GROUP BY referer;\");\n        Program p = compileSql(\"INSERT INTO abf (timestamp , provider , title, uuid, DOUBLE_SUM(click) AS click)  VALUES ('2014-10-31 00:00:00','sri','SE','fsd-sdf-dfgdf','2') WHERE interval BETWEEN '2013-08-31' AND '2023-09-01'  BREAK BY 'day';\");\n        System.out.println(p);\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/drop/DropMeta.java\npublic class DropMeta extends CrudStatementMeta {\n\n    public String id;// UUid\n    public Interval interval = null;// This should be filled with time boundary at runtime.\n    public List<String> dimensions = new ArrayList<>();// This will be determined at runtime.\n    public List<String> metrics = new ArrayList<>();// This will be determined at runtime.\n\n    public DropMeta() {\n    }\n\n    public DropMeta(String dataSource, Interval interval) {\n        super(dataSource);\n        this.interval = interval;\n    }\n\n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n\n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n\n    @Override\n    public Map<String, Object> getDataMap() {\n        // For each instance of data generation generate a new id.\n        id = String.format(\"kill_%s_%s_%s_%s\", dataSource, interval.getStartTime(), interval.getEndTime(), new DateTime().toString());\n        Map<String, Object> map = super.getDataMap();\n        map.put(\"type\", \"kill\");\n        map.put(\"dataSource\", dataSource);\n        map.put(\"interval\", interval.toString());\n        map.put(\"id\", id);\n        return map;\n    }\n\n\n    public <T> void postProcess(T anyContext) {\n\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/DropProgram.java\npublic class DropProgram extends CrudProgram<DropMeta>{\n    public DropProgram() {\n        this.type = Type.DROP;\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n        for (DropMeta dMeta: getAllStmnts()) {\n            System.out.println(dMeta.toString());\n        }\n        return buffer.toString();\n    }\n    \n    /**\n     * TODO: Do all semantic checks here. 1st field should be timestamp.\n     * @throws java.lang.Exception\n     */\n    @Override\n    public void isValid() throws Exception {\n    }\n\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/query/RequestType.java\npublic enum RequestType {\n    GROUPBY, TIMESERIES, TOPN, SEARCH, SELECT, TIMEBOUNDARY, UNKNOWN;\n\n    public String getName() {\n        if (this == TIMEBOUNDARY) {\n            return \"timeBoundary\";\n        }\n        return this.name().toLowerCase();\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/query/select/SelectQueryMeta.java\npublic class SelectQueryMeta  extends PlainDimQueryMeta {\n\n    public final PagingSpec pagingSpec = new PagingSpec(null, 5);\n    public List<String> fetchMetrics = new ArrayList<>();\n    \n    \n    private static final JSONObject EMPTY_JSON = new JSONObject();\n    \n    public SelectQueryMeta() {\n        queryType = RequestType.SELECT;\n    }\n\n    public SelectQueryMeta(QueryMeta q) {\n        super(q);\n        queryType = RequestType.SELECT;\n    }\n\n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n    \n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n    \n    @Override\n    public Map<String, Object> getDataMap() {\n        Map<String, Object> map = super.getDataMap();\n        Map<String, Object> pagingSpecMap = new LinkedHashMap<>();\n        if (pagingSpec != null) {\n            if (pagingSpec.pagingIdentifiers == null) {\n                pagingSpecMap.put(\"pagingIdentifiers\", EMPTY_JSON);\n            } else {\n                pagingSpecMap.put(\"pagingIdentifiers\", pagingSpec.pagingIdentifiers);\n            }\n            pagingSpecMap.put(\"threshold\", pagingSpec.threshold);\n        }\n        map.put(\"pagingSpec\", pagingSpecMap);\n        if (fetchMetrics != null) {\n            map.put(\"metrics\", new JSONArray(fetchMetrics));\n        }\n        return map;\n    }\n    \n    /**\n     * This method must be called prior to calling {@link SelectQueryMeta#getDataMap() }.\n     * Essentially splits columns into Dimensions and Metrics.\n     * @param <T>\n     * @param anyContext\n     */\n    @Override\n    public <T> void postProcess(T anyContext) {\n        Tuple2<List<String>, List<String>> dimsAndMetrics = (Tuple2<List<String>, List<String>>)anyContext;\n        List<String> dims = dimsAndMetrics._1();\n        List<String> metrics = dimsAndMetrics._2();\n        Iterator<Map.Entry<String, String>> colIter = fetchDimensions.entrySet().iterator();\n        while (colIter.hasNext()) {\n            Map.Entry<String, String> entry = colIter.next();\n            if (dims.contains(entry.getKey())) {\n                //No action.\n            } else if (metrics.contains(entry.getKey())) {\n                fetchMetrics.add(entry.getKey());\n                colIter.remove();\n            } else {//TODO: Handle error\n                \n            }\n        }\n    }\n    \n    public static SelectQueryMeta promote(QueryMeta qMeta) {\n        return new SelectQueryMeta(qMeta);\n    }\n    \n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/insert/InsertMeta.java\npublic abstract class InsertMeta extends CrudStatementMeta {\n\n    public String dataFormat = \"tsv\";//\n    public String delimiter = \",\";\n    public String listDelimiter = \"\\n\";\n    public List<AggItem> aggregations = new ArrayList<>();\n    public Map<String, String> fetchDimensions = new LinkedHashMap<>();\n    public Set<String> orderedColumns = new LinkedHashSet<>();//For maintaining the insert order of data columns.\n\n    public GranularitySpec granularitySpec = new GranularitySpec(\"day\");\n\n    public InsertMeta() {\n    }\n\n    public InsertMeta(String dataSource) {\n        super(dataSource);\n    }\n\n    // Could be a dimension or metric.\n    public void addColumnInOrder(String column) {\n        orderedColumns.add(column);\n    }\n        \n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n\n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n\n    @Override\n    public Map<String, Object> getDataMap() {\n        Map<String, Object> map = super.getDataMap();\n        map.put(\"dataSource\", dataSource);\n        return map;\n    }\n\n    //TODO: IOConfig should be called before dataSchema to ensure proper format values etc are filled in.\n    // See getFirehose() method to see what dependencies are being filled in. This dependency should \n    // be removed in future.\n    public Map<String, Object> getSpec() {\n        return ImmutableMap.<String, Object>of(\n                \"ioConfig\", getIoConfig(),\n                \"dataSchema\", getDataSchema(),\n                \"tuningConfig\", getTuningConfig());\n    }\n\n    public Map<String, Object> getDimensionSpec() {\n        List<String> dims = getDimensions(fetchDimensions);\n        return ImmutableMap.<String, Object>of(\n                \"dimensions\", dims.subList(1, dims.size()),\n                \"dimensionExclusions\", ImmutableList.<String>of(),\n                \"spatialDimensions\", ImmutableList.<String>of());\n    }\n    \n    public List<JSONObject> getMetricsSpec() {\n        ImmutableList.Builder<JSONObject> builder = ImmutableList.<JSONObject>builder();\n        for (AggItem item : aggregations) {\n            builder.add(item.getJson());\n        }\n        return builder.build();\n    }\n\n    public Map<String, Object> getParser() {\n        return ImmutableMap.<String, Object>of(\n                \"type\", \"string\",\n                \"parseSpec\", getParseSpec());\n    }\n\n    public Map<String, Object> getParseSpec() {\n        ImmutableMap.Builder builder = ImmutableMap.<String, Object>builder();\n        builder.put(\"format\", dataFormat).\n                put(\"timestampSpec\", getTimestampSpec()).\n                put(\"dimensionsSpec\", getDimensionSpec());\n        if (delimiter != null) {\n            builder.put(\"delimiter\", delimiter);\n        }\n        if (listDelimiter != null) {\n            builder.put(\"listDelimiter\", listDelimiter);\n        }\n        builder.put(\"columns\", orderedColumns);\n        return builder.build();\n    }\n    \n    public Map<String, Object> getDataSchema() {\n        return ImmutableMap.<String, Object>of(\n                \"dataSource\", dataSource,\n                \"parser\", getParser(),\n                \"metricsSpec\", getMetricsSpec(),\n                \"granularitySpec\", granularitySpec.getJson()\n                );\n    }\n    \n    public abstract Map<String, Object> getTimestampSpec();\n    public abstract Map<String, Object> getIoConfig();\n    public abstract Map<String, Object> getTuningConfig();\n\n    public <T> void postProcess(T anyContext) {\n\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/QueryProgram.java\npublic class QueryProgram extends Program<QueryMeta>{\n    public final List<String> primaryJoinableHooks = new ArrayList<>();// Has 'N-1' items\n    public final List<String> joinTypes = new ArrayList<>();// Has 'N-1' items\n\n    public QueryProgram() {\n        this.type = Type.QUERY;\n    }\n        \n    \n    public void addJoinHook(String hook) {\n        primaryJoinableHooks.add(hook);\n    }\n    \n    public void addJoinType(String type) {\n        joinTypes.add(type);\n    }\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n        int i = 0;\n        for (QueryMeta qMeta: getAllStmnts()) {\n            buffer.append(qMeta.toString());\n            buffer.append(\"\\n\");\n            if (i == numStmnts() - 1) {\n                break;\n            }\n            if (numStmnts() > 1) {\n                buffer.append(\" joined with \");\n                buffer.append(primaryJoinableHooks.get(i++));\n                buffer.append(\"\\n\");\n            }\n            \n        }\n        return buffer.toString();\n    }\n    \n    /**\n     * TODO: This method should be a full blown functional but right now address \n     * only partial semantics.\n     * Do all semantic checks here.\n     * @throws java.lang.Exception\n     */\n    @Override\n    public void isValid() throws Exception {\n        if (numStmnts() >= 2) {\n            if (primaryJoinableHooks.size() > 0) {\n                for (String joinField:primaryJoinableHooks) {\n                    if (joinField.equals(\"timestamp\")) {// timestamp is implicitly present in the result.\n                        continue;\n                    }\n                    for (QueryMeta query: getAllStmnts()) {\n                        boolean isPresent = false;\n                        if (query instanceof BaseAggQueryMeta) {// Since BaseAggQueryMeta is also a PlainDimQueryMeta we go with former first.\n                            for (AggItem item:((BaseAggQueryMeta)query).aggregations) {\n                                if (joinField.equals(item.fieldName) || (item.asName != null && joinField.equals(item.asName))) {\n                                    isPresent = true;\n                                }\n                            }\n                        }\n                        if (query instanceof PlainDimQueryMeta) {\n                            Map<String, String> dims = ((PlainDimQueryMeta)query).fetchDimensions;\n                            for (Map.Entry<String, String> entry :dims.entrySet()) {\n                                if (joinField.equals(entry.getKey()) || (entry.getValue() != null && joinField.equals(entry.getValue()))) {\n                                    isPresent = true;\n                                }\n                            }\n                        }\n                        if (!isPresent) {\n                            String error = joinField + \" mentioned in the composite key should appear in all the data sources being queried and joined.\";\n                            throw new Exception(error);\n                        }\n                    }\n                }\n            } else {\n                String error = \"Need atleast one field to join on\";\n                throw new Exception(error);\n            }\n        }\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/delete/DeleteMeta.java\npublic class DeleteMeta extends CrudStatementMeta {\n\n    public String id;// UUid\n    public Interval interval = null;\n    public List<Interval> segmentsToDelete = null;// This will be determined at runtime.\n    public List<String> dimensions = new ArrayList<>();// This will be determined at runtime.\n    public List<String> metrics = new ArrayList<>();// This will be determined at runtime.\n\n    public DeleteMeta() {\n    }\n\n    public DeleteMeta(String dataSource, Interval interval) {\n        super(dataSource);\n        this.interval = interval;\n    }\n\n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n\n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n    /**\n     * Retain segments only overlapping with the range.\n     * @param allSegments \n     */\n    public void filterSegments(List<Interval> allSegments) {\n        segmentsToDelete = Lists.newArrayList(Iterables.filter(allSegments, new Predicate<Interval>() {\n            @Override\n            public boolean apply(Interval i) {\n                return i.fallsIn(interval);\n            }\n        }));\n    }\n\n    @Override\n    public Map<String, Object> getDataMap() {\n        // For each instance of data generation generate a new id.\n        id = String.format(\"kill_%s_%s_%s_%s\", dataSource, interval.getStartTime(), interval.getEndTime(), new DateTime().toString());\n        Map<String, Object> map = super.getDataMap();\n        map.put(\"type\", \"kill\");\n        map.put(\"dataSource\", dataSource);\n        map.put(\"interval\", interval.toString());\n        map.put(\"id\", id);\n        return map;\n    }\n\n\n    public <T> void postProcess(T anyContext) {\n\n    }\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/CrudProgram.java\npublic abstract class CrudProgram<T extends CrudStatementMeta> extends Program<T>{\n    public boolean waitForCompletion = true;\n}\nSql4Ddriver/src/main/java/com/yahoo/sql4d/sql4ddriver/Util.java\npublic class Util {\n    public static final void newLine() {\n        System.out.println();\n    }\n    \n    public static final void print(char c) {\n        System.out.print(c);\n        System.out.flush();\n    }\n\n    public static final void print(String message) {\n        System.out.print(message);\n        System.out.flush();\n    }\n\n    public static final void println(String message) {\n        System.out.println(message);\n        System.out.flush();\n    }\n\n    public static final void printf(String format, Object ...args) {\n        System.out.printf(format, args);\n        System.out.flush();\n    }\n\n    public static final String repeat(String item, int n) {\n        StringBuilder buff = new StringBuilder();\n        for (int i = 0;i < n;i++) {\n            buff.append(item);\n        }\n        return buff.toString();\n    }\n\n    public static void printTable(JSONArray jsonArray) {\n        if (jsonArray.length() == 0) {\n            return;\n        }\n        JSONObject sample = jsonArray.getJSONObject(0);\n        if (sample.has(\"event\")) {// GroupBy\n            for (int i = 0;i < jsonArray.length();i++) {\n                JSONObject jsonItem = jsonArray.getJSONObject(i);\n                JSONObject event = jsonItem.getJSONObject(\"event\");\n                \n                // Print headers.\n                if (i == 0) {\n                    printf(\"%-10s  |\", \"timestamp\");\n                    for (Object key: event.keySet()) {\n                        printf(\"%-10s  |\", key);\n                    }\n                    newLine();\n                }\n                println(repeat(\"-\", (event.keySet().size() + 1) * 10));\n                // Print data.\n                printf(\"%-10s  |\", jsonItem.getString(\"timestamp\"));\n                for (Object key: event.keySet()) {\n                    printf(\"%-10s  |\", event.get(key.toString()));\n                }\n                newLine();\n            }\n        } else if (sample.has(\"result\")) {// Could be timeseries/topN\n            if (sample.optJSONObject(\"result\") != null) {// Timeseries\n                JSONObject sampleResult = sample.optJSONObject(\"result\");\n                // Print headers.\n                printf(\"%-10s  |\", \"timestamp\");\n                for (Object key: sampleResult.keySet()) {\n                    printf(\"%-10s  |\", key);\n                }\n                newLine();\n                println(repeat(\"-\", (sampleResult.keySet().size() + 1) * 10));\n                // Print data.\n                for (int i = 0;i < jsonArray.length();i++) {\n                    JSONObject jsonItem = jsonArray.getJSONObject(i);\n                    printf(\"%-10s  |\", jsonItem.getString(\"timestamp\"));\n                    JSONObject result = jsonItem.getJSONObject(\"result\");\n                    for (Object key: result.keySet()) {\n                        printf(\"%-10s  |\", result.get(key.toString()));\n                    }\n                    newLine();\n                }\n            } else if (sample.optJSONArray(\"result\") != null) {// TopN\n                // There should be only 1 item in here.\n                JSONObject jsonItem = jsonArray.getJSONObject(0);\n                \n                JSONArray result = jsonItem.getJSONArray(\"result\");\n                // Print headers.\n                printf(\"%-10s  |\", \"timestamp\");\n                if (result.length() == 0) {// Nothing to be printed\n                    return;\n                }\n                for (Object key: result.getJSONObject(0).keySet()) {\n                    printf(\"%-10s  |\", key);\n                }\n                newLine();\n                println(repeat(\"-\", (result.getJSONObject(0).keySet().size() + 1) * 10));\n                for (int j = 0;j < result.length();j++) {\n                    printf(\"%-10s  |\", jsonItem.getString(\"timestamp\"));\n                    JSONObject deepItem = result.getJSONObject(j);\n                    for (Object key: deepItem.keySet()) {\n                        printf(\"%-10s  |\", deepItem.get(key.toString()));\n                    }\n                    newLine();\n                }\n                newLine();\n            }\n        } \n    }\n    \n    public static void printTable(List<String> baseFieldNames, Map<Object, List<Object>> baseAllRows) {\n        for(String header:baseFieldNames) {\n            printf(\"%-10s  |\", header);\n        }\n        newLine();\n        for(List<Object> row:baseAllRows.values()) {\n            for (Object rowColValue:row) {\n                printf(\"%-10s  |\", rowColValue);\n            }\n            newLine();\n        }\n    }\n\n    public static void printTable(List<String> baseFieldNames, List<List<Object>> baseAllRows) {\n        for(String header:baseFieldNames) {\n            printf(\"%-10s  |\", header);\n        }\n        newLine();\n        for(List<Object> row:baseAllRows) {\n            for (Object rowColValue:row) {\n                printf(\"%-10s  |\", rowColValue);\n            }\n            newLine();\n        }\n    }\n\n    public static <T extends DruidBaseBean> void printTable(List<T> baseAllRows) {\n        if (baseAllRows == null || baseAllRows.isEmpty()) {\n            return;\n        }\n        List<Method> setters = getAllSetters(baseAllRows.get(0).getClass());\n        for(Method setter:setters) {\n            printf(\"%-10s  |\", setter.getName().substring(3));\n        }\n        newLine();\n        List<Method> getters = getAllGetters(baseAllRows.get(0).getClass());\n        for(T row:baseAllRows) {\n            for(Method getter:getters) {\n                try {\n                    printf(\"%-10s  |\", getter.invoke(row));\n                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\n                    Logger.getLogger(Util.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n            newLine();\n        }\n    }\n    \n    public static List<Method> getAllSetters(Class<?> clazz) {\n        Method[] allMethods = clazz.getMethods();\n        List<Method> setters = new ArrayList<>();\n        for(Method method : allMethods) {\n            if(method.getName().startsWith(\"set\")) {\n                setters.add(method);\n            }\n        }    \n        return setters;\n    }\n\n    public static List<Method> getAllGetters(Class<?> clazz) {\n        Method[] allMethods = clazz.getMethods();\n        List<Method> getters = new ArrayList<>();\n        for(Method method : allMethods) {\n            if(method.getName().startsWith(\"get\") && !method.getName().equals(\"getClass\")) {\n                getters.add(method);\n            }\n        }    \n        return getters;\n    }\n    \n    public static String getterMethodName(String key) {\n        return \"get\" + capitalize(key);\n    }\n\n    public static String setterMethodName(String key) {\n        return \"set\" + capitalize(key);\n    }\n\n    public static String capitalize(String word) {\n        StringBuilder buff = new StringBuilder(word);\n        if (word.charAt(0) != '_') {\n            buff.setCharAt(0, Character.toUpperCase(word.charAt(0)));\n        }\n        for (int i = 1; i < buff.length(); i++) {\n            if (buff.charAt(i - 1) == '_') {\n                buff.setCharAt(i, Character.toUpperCase(word.charAt(i)));\n            }\n        }\n        return buff.toString().replace(\"_\", \"\");\n    }\n\n    public static Either<JSONArray, JSONObject> asJsonType(String str) throws JSONException {\n        JSONArray possibleResArray = null;\n        try {\n            possibleResArray = new JSONArray(str);\n            return new Left<>(possibleResArray);\n        } catch (JSONException je) {\n            JSONObject possibleResObj = new JSONObject(str);\n            return new Right<>(possibleResObj);\n        }\n    }    \n    \n    /**\n     * More granular(sets the property of a bean based on a key value).\n     *\n     * @param bean\n     * @param key\n     * @param value\n     * @throws NoSuchMethodException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws InvocationTargetException\n     */\n    public static void applyKVToBean(Object bean, String key, Object value) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        Method getterMethod = bean.getClass().getMethod(Util.getterMethodName(key));\n        Method setterMethod = bean.getClass().getMethod(Util.setterMethodName(key), getterMethod.getReturnType());\n        setterMethod.invoke(bean, value);\n    }\n    \n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/DeleteProgram.java\npublic class DeleteProgram extends CrudProgram<DeleteMeta>{\n    public DeleteProgram() {\n        this.type = Type.DELETE;\n    }\n    \n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n        for (DeleteMeta dMeta: getAllStmnts()) {\n            System.out.println(dMeta.toString());\n        }\n        return buffer.toString();\n    }\n    \n    /**\n     * TODO: Do all semantic checks here. 1st field should be timestamp.\n     * @throws java.lang.Exception\n     */\n    @Override\n    public void isValid() throws Exception {\n    }\n\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/query/QueryMeta.java\npublic class QueryMeta extends BaseStatementMeta {\n    public Granularity granularity = new Granularity(\"all\");\n    public Filter filter;\n    public List<Interval> intervals = new ArrayList<>(); \n    public List<Pair<Integer, Integer>> microIntervals = new ArrayList<>(); // If empty or if intervals list size > 1 then this is not used.\n    public RequestType queryType;\n    \n    public QueryMeta() {\n    }\n\n    public QueryMeta(QueryMeta q) {\n        super(q);\n        this.granularity = q.granularity;\n        this.filter = q.filter;\n        this.intervals = q.intervals;\n        this.microIntervals = q.microIntervals;\n    }\n    \n    public QueryMeta(String dataSource, Granularity granularity, Filter filter, List<Interval> intervals, List<Pair<Integer, Integer>> microIntervals) {\n        super(dataSource);\n        this.granularity = granularity;\n        this.filter = filter;\n        this.intervals = intervals;\n        this.microIntervals = microIntervals;\n    }\n\n    \n    @Override\n    public String toString() {\n        return getJson().toString(2);\n    }\n    \n    @Override\n    public JSONObject getJson() {\n        return new JSONObject(getDataMap());\n    }\n    @Override\n    public Map<String, Object> getDataMap() {\n        Map<String, Object> map = super.getDataMap();\n        map.put(\"queryType\", queryType.getName());\n        if (queryType == RequestType.TIMEBOUNDARY) {\n            return map;\n        }\n        if (granularity != null) {\n            if (granularity.gComplex != null) {\n                map.put(\"granularity\", granularity.getJson());\n            } else {\n                map.put(\"granularity\", granularity.gSimple);\n            }\n        }\n        if (filter != null) {\n            map.put(\"filter\", filter.getJson());\n        }\n\n        JSONArray intervalsArray = new JSONArray();\n        if (!intervals.isEmpty()) {\n            if (intervals.size() == 1 && !microIntervals.isEmpty()) {\n                Interval grandInterval = intervals.get(0);\n                // Break the single interval into micro intervals.\n                for (int i = 0; i < grandInterval.getDays();i++) {\n                    for (Pair<Integer, Integer> pair:microIntervals) {\n                        Interval microInterval = grandInterval.getInterval(i, pair.a, pair.a + pair.b);// a = start hour of day, b = number of hours from there of.\n                        intervalsArray.put(microInterval.toString());\n                    }\n                }\n            } else {\n                for (Interval interval:intervals) {\n                    intervalsArray.put(interval.toString());\n                }\n            }\n            JSONObject finalIntervalJson = new JSONObject();\n            finalIntervalJson.put(\"type\", \"intervals\");\n            finalIntervalJson.put(\"intervals\", intervalsArray);\n            map.put(\"intervals\", finalIntervalJson);\n        }\n        return map;\n    }\n    \n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/query/nodes/Interval.java\npublic class Interval {\n    public String startTime;\n    public String endTime;\n    public int days;// Includes partial days as well.\n    \n    public Interval(String startTime, String endTime) {\n        this.startTime = startTime.replaceAll(\"'\", \"\");\n        this.endTime = endTime.replaceAll(\"'\", \"\");\n        days = Days.daysBetween(getStartTime().withTimeAtStartOfDay() , getEndTime().withTimeAtStartOfDay() ).getDays() + 1;\n    }\n\n    /**\n     * Interval should be of form 2014-10-31T00:00:00.000-07:00/2014-11-01T00:00:00.000-07:00\n     * @param interval \n     */\n    public Interval(String interval) {\n        String[] dates = interval.split(\"/\");\n        Preconditions.checkArgument(dates.length == 2);\n        this.startTime = dates[0].replaceAll(\"'\", \"\");\n        this.endTime = dates[1].replaceAll(\"'\", \"\");\n        days = Days.daysBetween(getStartTime().withTimeAtStartOfDay() , getEndTime().withTimeAtStartOfDay() ).getDays() + 1;\n    }\n\n    public DateTime getStartTime() {\n        return TimeUtils.getDateTime(startTime);\n    }\n\n    public DateTime getEndTime() {\n        return TimeUtils.getDateTime(endTime);\n    }\n\n    public int getDays() {\n        return days;\n    }\n    \n    public Interval getInterval(int daysOffset, int startHourOffset, int endHourOffset) {\n        DateTime baseDateTime = getStartTime().withTime(0, 0, 0, 0).plusDays(daysOffset);\n        return new Interval(baseDateTime.plusHours(startHourOffset).toString(), \n                baseDateTime.plusHours(endHourOffset).minusSeconds(1).toString());\n    }\n\n    public Interval expandIntervalByDay(int days) {\n        return new Interval(getStartTime().minusDays(days).toString(), \n                getEndTime().plusDays(days).toString());\n    }\n\n    public Interval expandEndTimeByDay(int days) {\n        return new Interval(getStartTime().toString(), \n                getEndTime().plusDays(days).toString());\n    }\n\n    public Interval expandIntervalBySec(int secs) {\n        return new Interval(getStartTime().minusSeconds(secs).toString(), \n                getEndTime().plusSeconds(secs).toString());\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%s/%s\", startTime, endTime);\n    }\n    \n    public boolean fallsIn(Interval range) {\n        return range.getStartTime().isBefore(getStartTime()) && range.getEndTime().isAfter(getEndTime());\n    }\n\n}\nSql4DCompiler/src/main/java/com/yahoo/sql4d/CrudStatementMeta.java\npublic abstract class CrudStatementMeta extends BaseStatementMeta {\n    public CrudStatementMeta() {\n    }\n\n    public CrudStatementMeta(String dataSource) {\n        this.dataSource = dataSource;\n    }\n}\nSql4Ddriver/src/main/java/com/yahoo/sql4d/sql4ddriver/sql/MysqlAccessor.java\npublic class MysqlAccessor extends BasePoolableObjectFactory<Tuple2<DataSource, Connection>> {\n\n    private final String connectorUrl = \"jdbc:mysql://%s:%d/%s?autoReconnectForPools=true\";\n    private String host = \"localhost\";\n    private int port = 3306;\n    private String id = \"druid\";//druid by default.\n    private String password = \"diurd\";//diurd by default.\n    private String db = \"druid\";//druid by default\n    private ObjectPool<Tuple2<DataSource, Connection>> pool = null ;\n\n    static {\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\").newInstance();\n        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n    public MysqlAccessor() {\n        this(\"localhost\", 3306, \"druid\", \"diurd\", \"druid\");\n    }\n\n    public MysqlAccessor(String host, int port) {\n        this(host, port, \"druid\", \"diurd\", \"druid\");\n    }\n\n    public MysqlAccessor(String host, int port, String id, String passwd) {\n        this(host, port, id, passwd, \"druid\");\n    }\n\n    public MysqlAccessor(String host, int port, String id, String passwd, String db) {\n        this.host = host;\n        this.port = port;\n        this.id = id;\n        this.password = passwd;\n        this.db = db;\n        init();\n    }\n    \n    private void init() {\n        GenericObjectPool.Config config = new GenericObjectPool.Config();\n        config.maxActive = 2;//TODO: Make this configurable.\n        config.testOnBorrow = true;\n        config.testWhileIdle = true;\n        config.timeBetweenEvictionRunsMillis = 10000;\n        config.minEvictableIdleTimeMillis = 60000;\n        GenericObjectPoolFactory genericObjectPoolFactory = new GenericObjectPoolFactory(this, config);\n        pool = genericObjectPoolFactory.createPool();\n    }\n    \n    @Override\n    public Tuple2<DataSource, Connection> makeObject() throws Exception {\n        DataSource ds = new DriverManagerDataSource(format(connectorUrl, host, port, db), id, password);\n        return new Tuple2<>(ds, ds.getConnection());\n    }\n\n    @Override\n    public void destroyObject(Tuple2<DataSource, Connection> connTuple) throws Exception {\n        connTuple._2().close();\n    }\n\n    @Override\n    public boolean validateObject(Tuple2<DataSource, Connection> conn) {\n        try {\n            return conn._2().isValid(0);\n        } catch (SQLException ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n            try {//Could be due to stale connection. Invalidate the object.\n                pool.invalidateObject(conn);\n            } catch (Exception ex1) {//TODO: Something serious with DB.\n                Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex1);\n            }\n        }\n        return false;\n    }\n    \n    public Tuple2<DataSource, Connection> getConnection() {\n        try {\n            return pool.borrowObject();\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return null;\n    }\n\n    public void returnConnection(Tuple2<DataSource, Connection> con) {\n        try {\n            if (con != null) {\n                pool.returnObject(con);\n            }\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n\n    public void shutdown() {\n        try {\n            pool.clear();\n            pool.close();\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n    \n    public List<Map<String, Object>> query(Map<String, String> params, String query) {\n        List<Map<String, Object>> result = null;\n        Tuple2<DataSource, Connection> conn = null;\n        try {\n            conn = getConnection();\n            NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(conn._1());\n            result = jdbcTemplate.queryForList(query, params);\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n        } finally {\n            returnConnection(conn);\n        }\n        return result;\n    }\n\n    /**\n     * Suitable for CRUD operations where no result set is expected.\n     * @param params\n     * @param query \n     * @return  \n     */\n    public boolean execute(Map<String, String> params, String query) {\n        final AtomicBoolean result = new AtomicBoolean(false);\n        Tuple2<DataSource, Connection> conn = null;\n        try {\n            conn = getConnection();\n            NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(conn._1());\n            jdbcTemplate.execute(query, params, new PreparedStatementCallback<Void>() {\n                @Override\n                public Void doInPreparedStatement(PreparedStatement ps) {\n                    try {\n                        result.set(ps.execute());\n                    } catch(SQLException e) {\n                        result.set(false);\n                    }\n                    return null;\n                }\n            });\n        } catch (Exception ex) {\n            Logger.getLogger(MysqlAccessor.class.getName()).log(Level.SEVERE, null, ex);\n            result.set(false);\n        } finally {\n            returnConnection(conn);\n        }\n        return result.get();\n    }\n    \n    public List<Map<String, Object>> segmentsInRange(String table, Interval interval) {\n        return query(ImmutableMap.of(\"dataSource\", table,\n                \"iStart\", interval.startTime,\n                \"iEnd\", interval.endTime), DAODictionary.SEGMENTS_IN_RANGE);\n    }\n\n    public List<Map<String, Object>> usedSegmentsInRange(String table, Interval interval) {\n        return query(ImmutableMap.of(\"dataSource\", table,\n                \"iStart\", interval.startTime,\n                \"iEnd\", interval.endTime,\n                \"used\", \"1\"), DAODictionary.USED_SEGMENTS_IN_RANGE);\n    }\n\n    public boolean disableSegmentsInRange(String table, Interval interval) {\n        return execute(ImmutableMap.of(\"dataSource\", table,\n                \"iStart\", interval.startTime,\n                \"iEnd\", interval.endTime), DAODictionary.DISABLE_SEGMENTS_IN_RANGE);\n    }\n\n    public boolean disableAllSegments(String table) {\n        return execute(ImmutableMap.of(\"dataSource\", table), DAODictionary.DISABLE_ALL_SEGMENTS);\n    }\n\n    public static void main(String[] args) {\n        MysqlAccessor accessor = new MysqlAccessor();\n        System.out.println(accessor.usedSegmentsInRange(\"abf2\", new Interval(\"2014-10-31/2014-11-01\")));\n        accessor.shutdown();\n    }\n}\n", "answers": ["        Interval expandedInterval = dMeta.interval.expandEndTimeByDay(62);"], "length": 3924, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "6f578376c647ce1e8a15c43c80c7f57b577dea55de6d3140"}
{"input": "package net.javaci.mobile.bomberman.core.server;\nimport net.javaci.mobile.bomberman.core.GameFactory;\nimport net.javaci.mobile.bomberman.core.World;\nimport net.javaci.mobile.bomberman.core.mediator.GameScreenMediator;\nimport net.javaci.mobile.bomberman.core.models.BombModel;\nimport net.javaci.mobile.bomberman.core.models.GhostModel;\nimport net.javaci.mobile.bomberman.core.models.GhostMovement;\nimport net.javaci.mobile.bomberman.core.net.NetworkInterface;\nimport net.javaci.mobile.bomberman.core.net.NetworkListenerAdapter;\nimport net.javaci.mobile.bomberman.core.net.protocol.*;\nimport net.javaci.mobile.bomberman.core.session.UserSession;\nimport net.javaci.mobile.bomberman.core.util.Log;\nimport net.javaci.mobile.bomberman.core.view.GameScreen;\nimport java.util.*;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n\n\npublic class GameServer {\n    private ScheduledExecutorService executorService;\n    private boolean isGameStarted = false;\n    private boolean isDisposed = false;\n\n    private static int WAIT_MOVE_GHOST_IN_SECOND = 3;\n    private static Map<Integer, GhostMovement> ghostMovements = new HashMap<Integer, GhostMovement>();\n\n    static {\n        int count = 0;\n        for (int i=0; i<4; i++) {\n            switch (i) {\n                case 0:\n                    for (int j=1; j<10; j++) {\n                        ghostMovements.put(count++, new GhostMovement(GameScreen.Direction.UP, j));\n                    }\n                    break;\n                case 1:\n                    for (int j=1; j<10; j++) {\n                        ghostMovements.put(count++, new GhostMovement(GameScreen.Direction.DOWN, j));\n                    }\n                    break;\n                case 2:\n                    for (int j=1; j<10; j++) {\n                        ghostMovements.put(count++, new GhostMovement(GameScreen.Direction.RIGHT, j));\n                    }\n                    break;\n                case 3:\n                    for (int j=1; j<10; j++) {\n                        ghostMovements.put(count++, new GhostMovement(GameScreen.Direction.LEFT, j));\n                    }\n                    break;\n\n            }\n\n        }\n    }\n\n    private Random rand = new Random();\n\n    private NetworkInterface networkInterface;\n    private GameScreenMediator gameScreenMediator;\n    private CommandFactory commandFactory = new CommandFactory();\n    private World world;\n\n    public GameServer(World world) {\n        this.world = world;\n    }\n\n    public void initialize(NetworkInterface networkInterface, GameScreenMediator gameScreenMediator) {\n        this.networkInterface = networkInterface;\n        this.gameScreenMediator = gameScreenMediator;\n\n        this.networkInterface.addNetworkListener(new NetworkListenerAdapter() {\n            @Override\n            public void onMessageReceived(String from, String message) {\n                Command command = commandFactory.createCommand(message);\n                if (command != null) {\n                    switch (command.getCommand()) {\n                        case Command.MOVE_START:\n                            handleStartMoveCommand((MoveCommand) command);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n        });\n\n        GameFactory.GameModel gameModel = GameFactory.getGameModel(gameScreenMediator.getLevel());\n        executorService = Executors.newScheduledThreadPool(gameModel.numGhosts);\n        executorService.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                if (!isDisposed && isGameStarted) {\n                    int waitingGhosts = 0;\n                    for (GhostModel ghostModel : GameServer.this.world.getGhostModels().values().toArray(new GhostModel[0])) {\n                        Log.d(\"Ghost State : \" + ghostModel.getState());\n                        if (ghostModel.getState() == GhostModel.State.STANDING_DOWN || ghostModel.getState() == GhostModel.State.STANDING_UP || ghostModel.getState() == GhostModel.State.STANDING_LEFT || ghostModel.getState() == GhostModel.State.STANDING_RIGHT) {\n                            waitingGhosts++;\n                            moveGhost(ghostModel.getId());\n                        }\n                    }\n                    Log.d(\"Total Waiting Ghosts : \" + waitingGhosts);\n                }\n            }\n        }, WAIT_MOVE_GHOST_IN_SECOND, WAIT_MOVE_GHOST_IN_SECOND, TimeUnit.SECONDS);\n    }\n\n    private void handleStartMoveCommand(MoveCommand command) {\n\n    }\n\n    public void startGame() {\n        StartGameCommand startGameCommand = new StartGameCommand();", "context": "core/src/main/java/net/javaci/mobile/bomberman/core/models/BombModel.java\npublic class BombModel extends GameObjectModel {\n\n    public static interface BombListener {\n        public void onBombExploded(BombModel bombModel);\n    }\n\n    public static enum State {\n        COUNT_DOWN, EXPLODE\n    }\n\n    private float remainingSeconds = 5;\n    private String owner;\n    private State state = State.COUNT_DOWN;\n    private Set<BombListener> bombListeners = new HashSet<BombListener>();\n    private int id;\n    private int gridX;\n    private int gridY;\n    private boolean activated;\n    private float activationTime;\n\n    public BombModel(int id) {\n        this.id = id;\n    }\n\n    public void addBombListener(BombListener listener) {\n        this.bombListeners.add(listener);\n    }\n\n    public void update(float deltaTime) {\n        this.remainingSeconds -= deltaTime;\n        if (remainingSeconds <= 0) {\n            this.state = State.EXPLODE;\n            for (Iterator<BombListener> iterator = bombListeners.iterator(); iterator.hasNext(); ) {\n                BombListener bombListener = iterator.next();\n                bombListener.onBombExploded(this);\n            }\n            this.bombListeners.clear();\n        }\n    }\n\n    public State getState() {\n        return this.state;\n    }\n\n    public String getOwner() {\n        return owner;\n    }\n\n    public void setOwner(String owner) {\n        this.owner = owner;\n    }\n\n    public float getRemainingSeconds() {\n        return remainingSeconds;\n    }\n\n    public void setRemainingSeconds(float remainingSeconds) {\n        this.remainingSeconds = remainingSeconds;\n    }\n\n    public int getGridX() {\n        return gridX;\n    }\n\n    public void setGridX(int gridX) {\n        this.gridX = gridX;\n    }\n\n    public int getGridY() {\n        return gridY;\n    }\n\n    public void setGridY(int gridY) {\n        this.gridY = gridY;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public boolean isActivated() {\n        return activated;\n    }\n\n    public void setActivated(boolean activated) {\n        this.activated = activated;\n    }\n\n    public float getActivationTime() {\n        return activationTime;\n    }\n\n    public void setActivationTime(float activationTime) {\n        this.activationTime = activationTime;\n    }\n\n    @Override\n    public float getOriginX() {\n        return x + (width * 0.5f);\n    }\n\n    @Override\n    public float getOriginY() {\n        return y + (height * 0.5f);\n    }\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/view/GameScreen.java\npublic class GameScreen extends BomberManScreen {\n\n    private World world = new World();\n    private GameScreenMediator gameScreenMediator;\n    private GameServer gameServer;\n    private LabyrinthModel labyrinthModel;\n\n    public LabyrinthWidget getLabyrinthWidget() {\n        return labyrinthWidget;\n    }\n\n    private LabyrinthWidget labyrinthWidget;\n    private Direction previousFlingDirection;\n    private boolean isPreferedControlGamePad = true;\n\n    public GameScreen(AbstractGame game, BomberManMediator mediator) {\n        super(game, mediator);\n        this.gameScreenMediator = (GameScreenMediator) mediator;\n        this.gameScreenMediator.setRoom(UserSession.getInstance().getRoom());\n        initializeDefaultGameBoard();\n    }\n\n    public void initializeDefaultGameBoard() {\n        labyrinthModel = new LabyrinthModel();\n        world.initialize(labyrinthModel, getStageBuilder().getResolutionHelper(), getStageBuilder().getAssets());\n        labyrinthWidget = new LabyrinthWidget(labyrinthModel, getStageBuilder().getResolutionHelper(), getStageBuilder().getAssets());\n        Group group = (Group) findActor(\"labyrinth\");\n        group.addActor(labyrinthWidget);\n    }\n\n    public void initializeGameOnServer() {\n        GameFactory.GameModel gameModel = GameFactory.getGameModel(gameScreenMediator.getLevel());\n\n        labyrinthModel.generateBricks(gameModel.numBricks);\n        PlayerModel playerModel = addPlayerModelToWorld(UserSession.getInstance().getUsername(), 1);\n        // TODO: user join notification\n\n\n\n        for (int i=0; i<gameModel.numGhosts; i++) {\n            final GhostModel ghostModel = GhostModel.createGhostModel(Math.random() > 0.5f ? GhostModel.Type.BALLOOM : GhostModel.Type.MINVO);\n            ghostModel.setWidth(world.getGridWidth());\n            ghostModel.setHeight(world.getGridHeight());\n            ghostModel.setListener(new GhostModel.GhostListener() {\n                @Override\n                public void onStop() {\n                    gameServer.moveGhost(ghostModel.getId());\n                }\n\n                @Override\n                public void onCaught(List<String> players) {\n                    gameServer.caughtPlayer(ghostModel.getId(), players);\n                }\n            });\n            world.putGhostEmptyPlace(ghostModel);\n            world.addGhostModel(ghostModel);\n\n            GhostWidget ghostWidget = new GhostWidget(getStageBuilder().getAssets().getTextureAtlas(\"Common.atlas\"), ghostModel);\n            getGameObjectsGroup().addActor(ghostWidget);\n        }\n    }\n\n    public boolean existPlayerOnWorld(String playerName) {\n        return world.getPlayerModel(playerName) != null;\n    }\n\n    private PlayerModel addPlayerModelToWorld(String username, int gameIndex) {\n        PlayerModel playerModel = new PlayerModel();\n        playerModel.setPlayerName(username);\n        playerModel.setPosition(labyrinthWidget.getPlayerInitialPosition(gameIndex));\n        playerModel.setWidth(world.getGridWidth());\n        playerModel.setHeight(world.getGridHeight());\n        playerModel.setGameIndex(gameIndex);\n        world.addPlayerModel(playerModel);\n        BombermanWidget bombermanWidget = new BombermanWidget(getStageBuilder().getAssets().getTextureAtlas(\"Common.atlas\"), gameIndex, playerModel);\n        bombermanWidget.setName(username);\n        Group group = (Group) findActor(\"gameObjectsGroup\");\n        group.addActor(bombermanWidget);\n        return playerModel;\n    }\n\n    @Override\n    public void show() {\n        super.show();\n        addBackground();\n        \n        if (UserSession.getInstance().isServer()) {\n            initializeGameOnServer();\n            gameServer = new GameServer(world);\n            gameServer.initialize(game.getClient(), gameScreenMediator);\n            gameScreenMediator.setGameServer(gameServer);\n        }\n\n        Vector2 gameAreaPos = getStageBuilder().getResolutionHelper().getGameAreaPosition();\n        getLabyrinthGroup().setPosition(-gameAreaPos.x, -gameAreaPos.y);\n        getGameObjectsGroup().setPosition(-gameAreaPos.x, -gameAreaPos.y);\n\n        prepareGamePad();\n\n        prepareBombButton();\n        \n        prepareSettingsButton();\n\n        initializeBeforeGamePanel();\n        \n        prepareStatsWidgets();\n\n        prepareInputProcessor();\n        \n        prepareDisconnectPopup();\n\n        prepareRoomOwnerLeftPopup();\n\n        prepareLostGamePopup();\n\n        prepareWinGamePopup();\n    }\n\n    private void prepareDisconnectPopup() {\n        Group group = (Group)findActor(\"disconnectPopup\");\n        Button button = (Button) group.findActor(\"backToLobbyButton\");\n        button.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                backToLobby();\n            }\n        });\n    }\n\n\n    private void prepareRoomOwnerLeftPopup() {\n        Group group = (Group)findActor(\"ownerLeftPopup\");\n        Button button = (Button) group.findActor(\"backToLobbyButton\");\n        button.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                backToLobby();\n            }\n        });\n    }\n\n    private void prepareLostGamePopup() {\n        Group group = (Group)findActor(\"lostGamePopup\");\n        Button button = (Button) group.findActor(\"backToLobbyButton\");\n        button.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                backToLobby();\n            }\n        });\n    }\n\n    private void prepareWinGamePopup() {\n        Group group = (Group)findActor(\"winGamePopup\");\n        Button button = (Button) group.findActor(\"backToLobbyButton\");\n        button.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                backToLobby();\n            }\n        });\n    }\n\n\n    public void backToLobby() {\n        game.backToPreviousScreen();\n    }\n\n    private void prepareStatsWidgets() {\n        Group player = (Group) findActor(\"player1stats\");\n        Vector2 pos = labyrinthWidget.getWallPosition(3, 12);\n        player.findActor(\"name\").setPosition(pos.x, pos.y);\n        pos = labyrinthWidget.getWallPosition(4, 12);\n        player.findActor(\"life\").setPosition(pos.x, pos.y);\n\n        player = (Group) findActor(\"player2stats\");\n        pos = labyrinthWidget.getWallPosition(7, 12);\n        player.findActor(\"name\").setPosition(pos.x, pos.y);\n        pos = labyrinthWidget.getWallPosition(8, 12);\n        player.findActor(\"life\").setPosition(pos.x, pos.y);\n\n        player = (Group) findActor(\"player3stats\");\n        pos = labyrinthWidget.getWallPosition(11, 12);\n        player.findActor(\"name\").setPosition(pos.x, pos.y);\n        pos = labyrinthWidget.getWallPosition(12, 12);\n        player.findActor(\"life\").setPosition(pos.x, pos.y);\n\n        player = (Group) findActor(\"player4stats\");\n        pos = labyrinthWidget.getWallPosition(15, 12);\n        player.findActor(\"name\").setPosition(pos.x, pos.y);\n        pos = labyrinthWidget.getWallPosition(16, 12);\n        player.findActor(\"life\").setPosition(pos.x, pos.y);\n\n    }\n\n    public void updateStats() {\n        updateStats(1);\n        updateStats(2);\n        updateStats(3);\n        updateStats(4);\n    }\n\n    public void updateStats(int playerIndex) {\n        Group playerGroup = (Group) findActor(\"player\" + playerIndex + \"stats\");\n        PlayerModel playerModel = world.getPlayerModelAtIndex(playerIndex);\n        if (playerModel != null) {\n            ((Label)playerGroup.findActor(\"life\")).setText(playerModel.getLifeCount() + \"\");\n        }\n    }\n\n    private Group getGameObjectsGroup() {\n        return (Group) findActor(\"gameObjectsGroup\");\n    }\n\n    private Group getLabyrinthGroup() {\n        return (Group) findActor(\"labyrinth\");\n    }\n\n    private void prepareSettingsButton() {\n        Button settingsButton = findButton(\"settingsButton\");\n        settingsButton.setVisible(true);\n        settingsButton.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                System.out.println(\"settings button clicked.\");\n                final Group settingsPanel = (Group) findActor(\"settingsPanel\");\n                settingsPanel.remove();\n                getRoot().addActor(settingsPanel);\n                settingsPanel.setVisible( ! settingsPanel.isVisible());\n                Button settingsGamePadButton = (Button) settingsPanel.findActor(\"settingsGamePad\");\n                settingsGamePadButton.addListener(new ClickListener() {\n                    @Override\n                    public void clicked(InputEvent event, float x, float y) {\n                        isPreferedControlGamePad = true;\n                        findActor(\"gamePad\").setVisible(isPreferedControlGamePad);\n                        settingsPanel.setVisible(false);\n                    }\n                });\n\n                Button settingsSwipeButton = (Button) settingsPanel.findActor(\"settingsSwipe\");\n                settingsSwipeButton.addListener(new ClickListener() {\n                    @Override\n                    public void clicked(InputEvent event, float x, float y) {\n                        isPreferedControlGamePad = false;\n                        findActor(\"gamePad\").setVisible(isPreferedControlGamePad);\n                        settingsPanel.setVisible(false);\n                    }\n                });\n            }\n        });\n        Vector2 pos = labyrinthWidget.getWallPosition(LabyrinthModel.NUM_COLS-1, LabyrinthModel.NUM_ROWS-1);\n        settingsButton.setPosition(pos.x, pos.y);\n    }\n\n    private void prepareInputProcessor() {\n        GestureDetector swipeGestureDetector = new GestureDetector(new GestureDetector.GestureAdapter() {\n            @Override\n            public boolean fling(final float velocityX, final float velocityY, int button) {\n                if (isPreferedControlGamePad) {\n                    return false;\n                }\n                final String username = UserSession.getInstance().getUsername();\n                final PlayerModel playerModel = world.getPlayerModel(username);\n                final Direction flingDirection = getDirection(velocityX, velocityY);\n                if (previousFlingDirection != null) {\n                    onMoveEnd(username, previousFlingDirection);\n                    playerModel.setStateChangeListener(new PlayerModel.StateChangeListener() {\n                        @Override\n                        public void onStateChange(PlayerModel.State newState) {\n                            if (newState == PlayerModel.State.STANDING_DOWN\n                                    || newState == PlayerModel.State.STANDING_UP\n                                    || newState == PlayerModel.State.STANDING_LEFT\n                                    || newState == PlayerModel.State.STANDING_RIGHT ) {\n                                System.out.println(\"STATE CHANGED : \" + newState);\n                                if (previousFlingDirection != null) {\n                                    System.out.println(\"STATE CHANGED sending move start: \" + flingDirection);\n                                    onMoveStart(username, flingDirection);\n                                    playerModel.setStateChangeListener(null);\n                                }\n                            }\n                        }\n                    });\n                } else {\n                    onMoveStart(username, flingDirection);\n                }\n                previousFlingDirection = flingDirection;\n                return true;\n            }\n\n            @Override\n            public boolean tap(float x, float y, int count, int button) {\n                if (previousFlingDirection != null) {\n                    onMoveEnd(UserSession.getInstance().getUsername(), previousFlingDirection);\n                    previousFlingDirection = null;\n                    return true;\n                }\n                return false;\n            }\n\n            private Direction getDirection(float velocityX, float velocityY) {\n                if (Math.abs(velocityX) > Math.abs(velocityY)) {\n                    //horizontal\n                    if (velocityX > 0) {\n                        return  Direction.RIGHT;\n                    } else {\n                        return Direction.LEFT;\n                    }\n                } else {\n                    //vertical\n                    if (velocityY > 0) {\n                        return Direction.DOWN;\n                    } else {\n                        return Direction.UP;\n                    }\n                }\n            }\n        });\n        InputMultiplexer inputMultiplexer = new InputMultiplexer(stage, swipeGestureDetector);\n        Gdx.input.setInputProcessor(inputMultiplexer);\n    }\n\n    private void initializeBeforeGamePanel() {\n        Group panel = (Group) findActor(\"beforeGamePanel\");\n        ((Label)panel.findActor(\"roomName\")).setText(UserSession.getInstance().getRoom().getName());\n        if (UserSession.getInstance().isServer()) {\n            setBeforeGamePanelTitle(\"Waiting for players...\");\n            Label label = (Label)panel.findActor(\"roomOwner\");\n            label.setText(\"Player 1 (Room Owner) : \" + UserSession.getInstance().getUsername());\n            label.setVisible(true);\n        } else {\n            setBeforeGamePanelTitle(\"Waiting for room owner to start the game...\");\n        }\n\n    }\n\n    private void setBeforeGamePanelTitle(String title) {\n        Group panel = (Group) findActor(\"beforeGamePanel\");\n        Label label = (Label)panel.findActor(\"title\");\n        label.setText(title);\n    }\n\n    private void prepareBombButton() {\n        Button bombButton = findButton(\"bombButton\");\n        bombButton.setVisible(false);\n        bombButton.setWidth(bombButton.getWidth() * 2f);\n        bombButton.setHeight(bombButton.getHeight() * 2f);\n        bombButton.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                gameScreenMediator.onBombButtonClicked();\n            }\n        });\n    }\n\n    private void addBackground() {\n        Image bg = new Image(createBgTexture());\n        bg.setPosition(0, 0);\n        bg.setSize(getStageBuilder().getResolutionHelper().getScreenWidth(), getStageBuilder().getResolutionHelper().getScreenHeight());\n        stage.getRoot().addActorAt(0, bg);\n    }\n\n    @Override\n    public void render(float delta) {\n        super.render(delta);\n        world.update(delta);\n    }\n\n    private void prepareGamePad() {\n        Actor gamePad = findActor(\"gamePad\");\n        gamePad.setVisible(false);\n\n        findButton(\"gamePadUpButton\").addListener(new InputListener() {\n            @Override\n            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {\n                onMoveStart(UserSession.getInstance().getUsername(), Direction.UP);\n                previousFlingDirection = null;\n                return true;\n            }\n\n            @Override\n            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {\n                onMoveEnd(UserSession.getInstance().getUsername(), Direction.UP);\n            }\n        });\n\n        findButton(\"gamePadDownButton\").addListener(new InputListener() {\n            @Override\n            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {\n                onMoveStart(UserSession.getInstance().getUsername(), Direction.DOWN);\n                previousFlingDirection = null;\n                return true;\n            }\n\n            @Override\n            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {\n                onMoveEnd(UserSession.getInstance().getUsername(), Direction.DOWN);\n            }\n        });\n\n        findButton(\"gamePadRightButton\").addListener(new InputListener() {\n            @Override\n            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {\n                onMoveStart(UserSession.getInstance().getUsername(), Direction.RIGHT);\n                previousFlingDirection = null;\n                return true;\n            }\n\n            @Override\n            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {\n                onMoveEnd(UserSession.getInstance().getUsername(), Direction.RIGHT);\n            }\n        });\n\n        findButton(\"gamePadLeftButton\").addListener(new InputListener() {\n            @Override\n            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {\n                onMoveStart(UserSession.getInstance().getUsername(), Direction.LEFT);\n                previousFlingDirection = null;\n                return true;\n            }\n\n            @Override\n            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {\n                onMoveEnd(UserSession.getInstance().getUsername(), Direction.LEFT);\n            }\n        });\n    }\n\n    public void onOpponentDropBomb(BombModel bombModel) {\n        addBombToScreen(bombModel);\n    }\n\n    public void onMoveStart(String username, Direction direction) {\n        if (UserSession.getInstance().getUsername().equals(username)) {\n            gameScreenMediator.move(direction);\n        }\n        world.movePlayer(username, direction, -1, -1);\n    }\n\n    public void onMoveStart(String username, Direction direction, int gridX, int gridY) {\n        world.movePlayer(username, direction, gridX, gridY);\n    }\n\n    public void onMoveEnd(String username, Direction direction) {\n        if (UserSession.getInstance().getUsername().equals(username)) {\n            gameScreenMediator.moveEnd(direction);\n        }\n        world.stopPlayer(username);\n    }\n\n    public void onCreateGame(byte[][] grid, List<GhostModel> ghostModels) {\n        findActor(\"beforeGamePanel\").remove();\n        labyrinthModel.setGrid(grid);\n        world.initialize(labyrinthModel, getStageBuilder().getResolutionHelper(), getStageBuilder().getAssets());\n\n        LabyrinthWidget labyrinthWidget = new LabyrinthWidget(world.getLabyrinthModel(), getStageBuilder().getResolutionHelper(), getStageBuilder().getAssets());\n        getLabyrinthGroup().addActor(labyrinthWidget);\n\n        world.addGhostModels(ghostModels);\n\n        for (GhostModel ghostModel : world.getGhostModels().values()) {\n            ghostModel.setWidth(world.getGridWidth());\n            ghostModel.setHeight(world.getGridHeight());\n            GhostWidget ghostWidget = new GhostWidget(getStageBuilder().getAssets().getTextureAtlas(\"Common.atlas\"), ghostModel);\n            getGameObjectsGroup().addActor(ghostWidget);\n        }\n    }\n\n\n    public void addBombToScreen(BombModel bombModel) {\n        BombWidget bombWidget = new BombWidget(getStageBuilder().getAssets().getTextureAtlas(\"Common.atlas\"), bombModel);\n        getGameObjectsGroup().addActor(bombWidget);\n    }\n\n    public void renderBombExplosion(BombModel bombModel) {\n        game.getAudioManager().boom();\n        List<Vector2> cellIndexes = world.calculateBombExplosionCells(bombModel);\n        List<Vector2> coords = world.convertCellIndexToScreenCoordinates(cellIndexes);\n\n        for (Vector2 pos : coords) {\n            ExplosionWidget explosionWidget = new ExplosionWidget(getStageBuilder().getAssets().getTextureAtlas(\"Common.atlas\"));\n            explosionWidget.setX(pos.x);\n            explosionWidget.setY(pos.y);\n            stage.addActor(explosionWidget);\n        }\n\n        for (Vector2 cell : cellIndexes) {\n            labyrinthModel.getGrid()[(int)cell.x][(int)cell.y] = LabyrinthModel.EMPTY;\n        }\n    }\n\n    public void onPlayerJoinedRoom(String playerName) {\n        if (!existPlayerOnWorld(playerName)) {\n            int gameIndex = world.getNextGameIndex();\n            addPlayerModelToWorld(playerName, gameIndex);\n            final Group panel = (Group) findActor(\"beforeGamePanel\");\n            if (gameIndex == 1) {\n                Label label = (Label) panel.findActor(\"roomOwner\");\n                label.setText(\"Player 1 (Room Owner) : \" + playerName);\n                label.setVisible(true);\n            } else {\n                Label playerJoinedLabel = (Label) panel.findActor(\"player\" + gameIndex + \"joined\");\n                playerJoinedLabel.setText(\"Player \" + gameIndex + \" joined room. \" + playerName);\n                playerJoinedLabel.setVisible(true);\n            }\n            if (UserSession.getInstance().isServer()) {\n                Button startButton = (Button) panel.findActor(\"startGameButton\");\n                startButton.setVisible(true);\n                startButton.addListener(new ClickListener() {\n                    @Override\n                    public void clicked(InputEvent event, float x, float y) {\n                        panel.remove();\n                        gameServer.createGame();\n                        game.getAudioManager().playStartGame();\n                    }\n                });\n\n            }\n        } else {\n            Log.e(\"Player already in room\");\n        }\n    }\n\n    public void removePlayer(String playerName) {\n        Actor bombermanWidget = stage.getRoot().findActor(playerName);\n        if (bombermanWidget != null) {\n            bombermanWidget.remove();\n        }\n        world.removePlayer(playerName);\n    }\n\n    public void displayLostGamePopup() {\n        findActor(\"lostGamePopup\").setVisible(true);\n    }\n\n    public void displayWinGamePopup() {\n        findActor(\"winGamePopup\").setVisible(true);\n    }\n\n    public void onCurrentPlayerDead() {\n        isPreferedControlGamePad = true;\n        findActor(\"gamePad\").setVisible(false);\n        findActor(\"bombButton\").setVisible(false);\n    }\n\n    public void displayRipImage(PlayerModel playerModel) {\n        Image rip = findImage(\"rip\" + playerModel.getGameIndex());\n        rip.setVisible(true);\n        rip.setOrigin(rip.getWidth() * .5f, rip.getHeight() * .05f);\n        rip.setPosition(\n                playerModel.getX() - getStageBuilder().getResolutionHelper().getGameAreaPosition().x,\n                playerModel.getY()-getStageBuilder().getResolutionHelper().getGameAreaPosition().y);\n        rip.addAction(Actions.sequence(\n                Actions.delay(2),\n                Actions.scaleTo(0, 0, 1, Interpolation.elasticIn),\n                Actions.visible(false),\n                Actions.scaleTo(1, 1)\n        ));\n    }\n\n    public static enum Direction {\n        UP, DOWN, RIGHT, LEFT\n    }\n\n    public World getWorld() {\n        return this.world;\n    }\n\n    private Texture createBgTexture() {\n        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);\n        pixmap.setColor(Color.valueOf(\"787878\"));\n        pixmap.fill();\n        Texture texture = new Texture(pixmap); // TODO dispose texture\n        pixmap.dispose();\n        return texture;\n    }\n\n    public void onMoveGhost(int ghostId, int gridX, int gridY, String direction, int distance) {\n        world.moveGhost(ghostId, gridX, gridY, Direction.valueOf(direction), distance);\n    }\n\n    public void addDeadGhost(float x, float y, int type) {\n        DeadGhostWidget deadGhostWidget = new DeadGhostWidget(getStageBuilder().getAssets().getTextureAtlas(\"Common.atlas\"), x, y, type);\n        getGameObjectsGroup().addActor(deadGhostWidget);\n    }\n\n    public void onOwnerLeft() {\n        findActor(\"ownerLeftPopup\").setVisible(true);\n    }\n\n    public void onDisconnected()  {\n        findActor(\"disconnectPopup\").setVisible(true);\n    }\n\n    @Override\n    public void dispose() {\n        super.dispose();\n        if (gameServer != null) {\n            gameServer.dispose();\n        }\n        if (gameScreenMediator.getNetworkListenerAdapter() != null) {\n            game.getClient().removeNetworkListener(gameScreenMediator.getNetworkListenerAdapter());\n        }\n        RoomModel roomModel = UserSession.getInstance().getRoom();\n        if (roomModel != null) {\n            game.getClient().leaveRoom(roomModel.getId());\n            if (UserSession.getInstance().isOwnerRoom()) {\n                game.getClient().deleteRoom(roomModel.getId());\n            }\n        }\n        else {\n            Log.e(\"Room Model is NULL. Cannot delete room from Server\");\n        }\n    }\n\n    public void resetPreviousFlingDirection() {\n        this.previousFlingDirection = null;\n    }\n\n    public void startGame() {\n        Actor gamePad = findActor(\"gamePad\");\n        gamePad.setVisible(isPreferedControlGamePad);\n\n        Button bombButton = findButton(\"bombButton\");\n        bombButton.setVisible(true);\n\n        game.getAudioManager().playStartGame();\n\n        displayMyPlayerIndicator();\n    }\n\n    private void displayMyPlayerIndicator() {\n        PlayerModel me = world.getPlayerModel(UserSession.getInstance().getUsername());\n        Vector2 playerPos = new Vector2();\n        switch (me.getGameIndex()) {\n            case 1:\n                playerPos = labyrinthWidget.getWallPosition(1, 1);\n                break;\n            case 2:\n                playerPos = labyrinthWidget.getWallPosition(19, 1);\n                break;\n            case 3:\n                playerPos = labyrinthWidget.getWallPosition(19, 11);\n                break;\n            case 4:\n                playerPos = labyrinthWidget.getWallPosition(1, 11);\n                break;\n        }\n        Image sunshine = findImage(\"sunshine\");\n        playerPos.sub(sunshine.getWidth()*.5f - world.getGridWidth()*0.5f, sunshine.getHeight()*0.5f - world.getGridHeight() * 0.5f);\n        sunshine.setPosition(playerPos.x, playerPos.y);\n        sunshine.setVisible(true);\n        sunshine.setOrigin(sunshine.getWidth() * 0.5f, sunshine.getHeight() * 0.5f);\n        sunshine.addAction(Actions.parallel(\n                Actions.forever(Actions.rotateBy(120, 1)),\n                Actions.sequence(Actions.delay(5), Actions.removeActor())\n        ));\n    }\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/session/UserSession.java\npublic class UserSession {\n    private long userId;\n    private String username;\n    private RoomModel room;\n\n    public static final UserSession INSTANCE = new UserSession();\n\n    public static UserSession getInstance() {\n        return INSTANCE;\n    }\n\n    private UserSession() {\n        this.userId = generateUserId();\n        this.username = generateUsername();\n    }\n\n    private String generateUsername() {\n        return \"Player_\" + generateUserId();\n    }\n\n    private long generateUserId() {\n        return (long)(Math.random() * 1000000);\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public long getUserId() {\n        return userId;\n    }\n\n    public void setUserId(long userId) {\n        this.userId = userId;\n    }\n\n    public RoomModel getRoom() {\n        return room;\n    }\n\n    public void setRoom(RoomModel room) {\n        this.room = room;\n    }\n\n    public boolean isOwnerRoom() {\n        if (room != null) {\n            return username.equals(room.getOwner());\n        }\n\n        return false;\n    }\n\n    public boolean isServer() {\n        return isOwnerRoom();\n    }\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/net/NetworkListenerAdapter.java\npublic class NetworkListenerAdapter implements NetworkInterface.NetworkListener {\n    @Override\n    public void onConnected() {\n\n    }\n\n    @Override\n    public void onDisconnected() {\n\n    }\n\n    @Override\n    public void onConnectionFailure(Exception e) {\n\n    }\n\n    @Override\n    public void onRoomListReceived(List<RoomModel> rooms) {\n\n    }\n\n    @Override\n    public void onRoomListRequestFailed() {\n\n    }\n\n    @Override\n    public void onRoomCreated(RoomModel room) {\n\n    }\n\n    @Override\n    public void onCreateRoomFailed() {\n\n    }\n\n    @Override\n    public void onRoomDeleted(String roomId) {\n\n    }\n\n    @Override\n    public void onDeleteRoomFailed() {\n\n    }\n\n    @Override\n    public void onJoinRoomSuccess(String roomId) {\n\n    }\n\n    @Override\n    public void onJoinRoomFailed() {\n\n    }\n\n    @Override\n    public void onMessageReceived(String from, String message) {\n\n    }\n\n    @Override\n    public void onPlayerJoinedRoom(RoomModel room, String playerName) {\n\n    }\n\n    @Override\n    public void onPlayerLeftRoom(RoomModel room, String playerName) {\n\n    }\n\n    @Override\n    public void onRoomInfoReceived(String[] players, String data) {\n    }\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/GameFactory.java\npublic class GameFactory {\n    public static class GameModel {\n        public int numGhosts;\n        public int numBricks;\n        public int numBomb;\n    }\n\n    private static Map<Integer, GameModel> gameModels = new HashMap<Integer, GameModel>();\n\n    static {\n        GameModel level1 = new GameModel();\n        level1.numGhosts = 10;\n        level1.numBricks = 10;\n        level1.numBomb = 2;\n        gameModels.put(1, level1);\n    }\n\n    public static GameModel getGameModel(int level) {\n        return gameModels.get(level);\n    }\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/util/Log.java\npublic class Log {\n\n    public static void e(String message) {\n        System.err.println(message);\n    }\n\n    public static void d(String message) {\n        System.out.println(message);\n    }\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/mediator/GameScreenMediator.java\npublic class GameScreenMediator extends BomberManMediator {\n\n    private GameServer gameServer;\n    private NetworkInterface networkInterface;\n    private NetworkListenerAdapter networkListenerAdapter;\n    private CommandFactory commandFactory = new CommandFactory();\n    private GameScreen gameScreen;\n    private GameFactory.GameModel gameModel;\n    private RoomModel room;\n    private int level = 1;\n\n    public GameScreenMediator(BomberManGame game, NetworkInterface networkInterface) {\n        super(game);\n        this.gameModel = GameFactory.getGameModel(getLevel());\n        this.networkInterface = networkInterface;\n        this.networkListenerAdapter = new NetworkListenerAdapter() {\n            @Override\n            public void onMessageReceived(String from, final String message) {\n                Gdx.app.postRunnable( new Runnable() {\n                    @Override\n                    public void run() {\n                        Command command = commandFactory.createCommand(message);\n                        if (command == null) {\n                            Log.d(\"Waiting split message\");\n                            return;\n                        }\n                        switch (command.getCommand()) {\n                            case Command.CREATE_GAME:\n                                handleCreateGameCommand((CreateGameCommand)command);\n                                break;\n                            case Command.MOVE_START:\n                                handleMoveStartCommand((MoveCommand) command);\n                                break;\n                            case Command.MOVE_END:\n                                handleMoveEndCommand((MoveEndCommand) command);\n                                break;\n                            case Command.MOVE_GHOST:\n                                handleMoveGhostCommand((MoveGhostCommand) command);\n                                break;\n                            case Command.GAME_END:\n                                handleGameEndCommand((GameEndCommand) command);\n                                break;\n                            case Command.DROP_BOMB:\n                                handleDropBombCommand((DropBombCommand) command);\n                                break;\n                            case Command.EXPLODE_BOMB:\n                                handleExplodeBombCommand((ExplodeBombCommand) command);\n                                break;\n                            case Command.CAUGHT_GHOST:\n                                handleGhostCaughtCommand((GhostCaughtCommand) command);\n                                break;\n                            case Command.START_GAME:\n                                handleStartGameCommand((StartGameCommand) command);\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n                });\n            }\n\n            @Override\n            public void onPlayerLeftRoom(RoomModel room, String playerName) {\n                super.onPlayerLeftRoom(room, playerName);\n                Log.d(\"Player : \" + playerName + \" left Room : \" + room.getId());\n                if (GameScreenMediator.this.room.equals(room) && !playerName.equals(UserSession.getInstance().getUsername())) {\n                    GameScreenMediator.this.onPlayerLeftRoom(playerName);\n                }\n            }\n\n            @Override\n            public void onPlayerJoinedRoom(RoomModel room, String playerName) {\n                super.onPlayerJoinedRoom(room, playerName);\n                if (GameScreenMediator.this.room.equals(room) && !playerName.equals(UserSession.getInstance().getUsername())) {\n                    GameScreenMediator.this.onPlayerJoinedRoom(playerName);\n                }\n            }\n\n            @Override\n            public void onRoomInfoReceived(String[] players, String data) {\n                if (players != null) {\n                    for (String player: players) {\n                        GameScreenMediator.this.onPlayerJoinedRoom(player);\n                    }\n                }\n            }\n\n            @Override\n            public void onDisconnected() {\n                gameScreen.onDisconnected();\n            }\n        };\n        networkInterface.addNetworkListener(networkListenerAdapter);\n    }\n\n    public NetworkListenerAdapter getNetworkListenerAdapter() {\n        return networkListenerAdapter;\n    }\n\n    private void handleStartGameCommand(StartGameCommand command) {\n        gameScreen.startGame();\n    }\n\n    private void handleGhostCaughtCommand(GhostCaughtCommand command) {\n        List<String> caughtPlayers = command.getCaughtPlayers();\n        if (caughtPlayers != null) {\n            for (String  caughtPlayer : caughtPlayers) {\n                PlayerModel playerModel = gameScreen.getWorld().getPlayerModel(caughtPlayer);\n                displayRipImage(playerModel);\n                if (gameScreen.getWorld().canRespawn(caughtPlayer)) {\n                    Vector2 playerInitialPosition = gameScreen.getLabyrinthWidget().getPlayerInitialPosition(playerModel.getGameIndex());\n                    gameScreen.getWorld().respawnPlayerAndDecrementLife(caughtPlayer, playerInitialPosition);\n                }\n                else {\n                    gameScreen.getWorld().killPlayer(caughtPlayer);\n                    if (caughtPlayer.equals(UserSession.getInstance().getUsername())) {\n                        gameScreen.onCurrentPlayerDead();\n                    }\n                }\n                gameScreen.updateStats();\n                gameScreen.resetPreviousFlingDirection();\n                if (caughtPlayer.equals(UserSession.getInstance().getUsername())) {\n                    game.getAudioManager().playJustDied();\n                } else {\n                    game.getAudioManager().playOpponentDying();\n                }\n\n                if (playerModel.getState()== PlayerModel.State.DEAD && playerModel.getPlayerName().equals(UserSession.getInstance().getUsername())) {\n                    //kaybettim.\n                    gameScreen.displayLostGamePopup();\n                }\n            }\n            if (UserSession.getInstance().isServer() && gameScreen.getWorld().isGameEnd()) {\n                GameEndCommand gameEndCommand = new GameEndCommand();\n                gameEndCommand.setFromUser(UserSession.getInstance().getUsername());\n                gameEndCommand.setReason(GameEndCommand.GameEndReason.GAME_END);\n                gameEndCommand.setWinner(gameScreen.getWorld().getWinnerName());\n                networkInterface.sendMessage(gameEndCommand.serialize());\n            }\n        }\n    }\n\n\n    @Override\n    protected void onScreenShow() {\n        super.onScreenShow();\n        if ( ! UserSession.getInstance().isServer()) {\n            networkInterface.getRoomInfo(UserSession.getInstance().getRoom().getId());\n        }\n    }\n\n    private void handleExplodeBombCommand(ExplodeBombCommand command) {\n        List<String> explodedPlayers = command.getExplodedPlayers();\n        if (explodedPlayers != null) {\n            for (String explodedPlayer : explodedPlayers) {\n                PlayerModel playerModel = gameScreen.getWorld().getPlayerModel(explodedPlayer);\n                displayRipImage(playerModel);\n                if (gameScreen.getWorld().canRespawn(explodedPlayer)) {\n                    Vector2 playerInitialPosition = gameScreen.getLabyrinthWidget().getPlayerInitialPosition(playerModel.getGameIndex());\n                    gameScreen.getWorld().respawnPlayerAndDecrementLife(explodedPlayer, playerInitialPosition);\n                }\n                else {\n                    gameScreen.getWorld().killPlayer(explodedPlayer);\n                    if (explodedPlayer.equals(UserSession.getInstance().getUsername())) {\n                        gameScreen.onCurrentPlayerDead();\n                    }\n                }\n                gameScreen.updateStats();\n                gameScreen.resetPreviousFlingDirection();\n                if (explodedPlayer.equals(UserSession.getInstance().getUsername())) {\n                    game.getAudioManager().playJustDied();\n                } else {\n                    game.getAudioManager().playOpponentDying();\n                }\n                if (playerModel.getState()== PlayerModel.State.DEAD && playerModel.getPlayerName().equals(UserSession.getInstance().getUsername())) {\n                    //kaybettim.\n                    gameScreen.displayLostGamePopup();\n                }\n            }\n            if (UserSession.getInstance().isServer() && gameScreen.getWorld().isGameEnd()) {\n                GameEndCommand gameEndCommand = new GameEndCommand();\n                gameEndCommand.setFromUser(UserSession.getInstance().getUsername());\n                gameEndCommand.setReason(GameEndCommand.GameEndReason.GAME_END);\n                gameEndCommand.setWinner(gameScreen.getWorld().getWinnerName());\n                networkInterface.sendMessage(gameEndCommand.serialize());\n            }\n        }\n\n        List<Integer> explodedGhosts = command.getExplodedGhosts();\n        if (explodedGhosts != null) {\n            for (Integer ghostId : explodedGhosts) {\n                GhostModel ghostModel = gameScreen.getWorld().getGhostModels().get(ghostId);\n                if (ghostModel != null) {\n                    gameScreen.addDeadGhost(ghostModel.getX(), ghostModel.getY(), ghostModel.getType().getValue());\n                }\n                else {\n                    Log.e(\"DEAD Ghost Model : \" + ghostId + \" cannot be found\");\n                }\n                gameScreen.getWorld().killGhost(ghostId);\n            }\n        }\n    }\n\n    private void displayRipImage(PlayerModel playerModel) {\n        gameScreen.displayRipImage(playerModel);\n    }\n\n    private void handleDropBombCommand(DropBombCommand command) {\n        if (command.getFromUser().equals(UserSession.getInstance().getUsername())) {\n            return;\n        }\n        BombModel bombModel = gameScreen.getWorld().dropBomb(command.getId(), command.getGridX(), command.getGridY(), command.getFromUser());\n        bombModel.addBombListener(new BombModel.BombListener() {\n            @Override\n            public void onBombExploded(BombModel bombModel) {\n                if (UserSession.getInstance().isServer()) {\n                    gameServer.sendBombExplosion(bombModel, gameScreen.getWorld());\n                }\n                gameScreen.renderBombExplosion(bombModel);\n            }\n        });\n        game.getAudioManager().dropBomb();\n        gameScreen.onOpponentDropBomb(bombModel);\n    }\n\n    private void handleGameEndCommand(GameEndCommand command) {\n        networkInterface.leaveRoom(room.getId());\n\n        if (command.getReason() == GameEndCommand.GameEndReason.OWNER_LEFT) {\n            game.getClient().deleteRoom(room.getId());\n            Gdx.app.postRunnable(new Runnable() {\n                @Override\n                public void run() {\n                    gameScreen.onOwnerLeft();\n                }\n            });\n        }\n        else if (command.getReason() == GameEndCommand.GameEndReason.GAME_END) {\n            if (UserSession.getInstance().getUsername().equals(command.getWinner())) {\n                gameScreen.displayWinGamePopup();\n            }\n        }\n    }\n\n    private void handleMoveGhostCommand(MoveGhostCommand command) {\n        gameScreen.getWorld().setPositionGhostOnGrid(command.getId(), command.getStartGridX(), command.getStartGridY());\n        gameScreen.onMoveGhost(command.getId(), command.getGridX(), command.getGridY(), command.getDirection(), command.getDistance());\n    }\n\n    private void handleCreateGameCommand(CreateGameCommand command) {\n        if (UserSession.getInstance().getUsername().equals(command.getFromUser())) {\n            return;\n        }\n\n        gameScreen.onCreateGame(command.getGrid(), command.getGhostModels());\n    }\n\n    private void handleMoveStartCommand(MoveCommand command) {\n        if (UserSession.getInstance().getUsername().equals(command.getFromUser())) {\n            return;\n        }\n        gameScreen.onMoveStart(command.getFromUser(), GameScreen.Direction.valueOf(command.getDirection()));\n    }\n\n    private void handleMoveEndCommand(MoveEndCommand command) {\n        if (UserSession.getInstance().getUsername().equals(command.getFromUser())) {\n            return;\n        }\n        gameScreen.getWorld().setPlayerTargetPosition(command.getFromUser(), command.getGridX(), command.getGridY());\n        gameScreen.onMoveEnd(command.getFromUser(), GameScreen.Direction.valueOf(command.getDirection()));\n    }\n\n    public void setGameServer(GameServer gameServer) {\n        this.gameServer = gameServer;\n    }\n\n    @Override\n    public BomberManScreen createScreen() {\n        this.screen = new GameScreen(this.game, this);\n        this.gameScreen = (GameScreen) screen;\n        return screen;\n    }\n\n    public void move(GameScreen.Direction direction) {\n        MoveCommand moveCommand = new MoveCommand();\n        moveCommand.setDirection(direction.toString());\n        moveCommand.setFromUser(UserSession.getInstance().getUsername());\n        Vector2 positionGrid = gameScreen.getWorld().getPlayerGridPosition(UserSession.getInstance().getUsername());\n        moveCommand.setGridX((int)positionGrid.x);\n        moveCommand.setGridY((int)positionGrid.y);\n        networkInterface.sendMessage(moveCommand.serialize());\n    }\n\n    public void moveEnd(GameScreen.Direction direction) {\n        MoveEndCommand moveEndCommand = new MoveEndCommand();\n        moveEndCommand.setDirection(direction.toString());\n        moveEndCommand.setFromUser(UserSession.getInstance().getUsername());\n        Vector2 targetPosition = gameScreen.getWorld().getTargetGridPosition(UserSession.getInstance().getUsername());\n        if (targetPosition != null) {\n            moveEndCommand.setGridX((int)targetPosition.x);\n            moveEndCommand.setGridY((int)targetPosition.y);\n            networkInterface.sendMessage(moveEndCommand.serialize());\n        }\n    }\n\n    public void onBombButtonClicked() {\n        if (gameScreen.getWorld().canUserDropBomb(UserSession.getInstance().getUsername(), gameModel.numBomb)) {\n            BombModel bombModel = gameScreen.getWorld().playerDroppedBomb(UserSession.getInstance().getUsername());\n            bombModel.addBombListener(new BombModel.BombListener() {\n                @Override\n                public void onBombExploded(BombModel bombModel) {\n                    if (UserSession.getInstance().isServer()) {\n                        gameServer.sendBombExplosion(bombModel, gameScreen.getWorld());\n                    }\n                    gameScreen.renderBombExplosion(bombModel);\n                }\n            });\n            DropBombCommand dropBombCommand = new DropBombCommand();\n            dropBombCommand.setFromUser(UserSession.getInstance().getUsername());\n            dropBombCommand.setId(bombModel.getId());\n            dropBombCommand.setGridX(bombModel.getGridX());\n            dropBombCommand.setGridY(bombModel.getGridY());\n            game.getClient().sendMessage(dropBombCommand.serialize());\n            gameScreen.addBombToScreen(bombModel);\n            game.getAudioManager().dropBomb();\n        }\n    }\n\n    public void onPlayerLeftRoom(String playerName) {\n        if (playerName != null && playerName.equals(room.getOwner())) {\n            onGameOwnerLeft();\n        }\n        else {\n            gameScreen.removePlayer(playerName);\n        }\n    }\n\n    public void onPlayerJoinedRoom(String playerName) {\n        gameScreen.onPlayerJoinedRoom(playerName);\n    }\n\n    private void onGameOwnerLeft() {\n        GameEndCommand gameEndCommand = new GameEndCommand();\n        gameEndCommand.setFromUser(UserSession.getInstance().getUsername());\n        gameEndCommand.setReason(GameEndCommand.GameEndReason.OWNER_LEFT);\n        networkInterface.sendMessage(gameEndCommand.serialize());\n    }\n\n    public RoomModel getRoom() {\n        return room;\n    }\n\n    public void setRoom(RoomModel room) {\n        this.room = room;\n    }\n\n    public int getLevel() {\n        return level;\n    }\n\n    public void setLevel(int level) {\n        this.level = level;\n    }\n\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/net/NetworkInterface.java\npublic interface NetworkInterface {\n\n    public static final int MAX_USERS = 4;\n\n    public static interface NetworkListener {\n        public void onConnected();\n\n        public void onDisconnected();\n\n        public void onConnectionFailure(Exception e);\n\n        public void onRoomListReceived(List<RoomModel> rooms);\n\n        public void onRoomListRequestFailed();\n\n        public void onRoomCreated(RoomModel room);\n\n        public void onCreateRoomFailed();\n\n        public void onRoomDeleted(String roomId);\n\n        public void onDeleteRoomFailed();\n\n        public void onJoinRoomSuccess(String roomId);\n\n        public void onJoinRoomFailed();\n\n        public void onMessageReceived(String from, String message);\n\n        public void onPlayerJoinedRoom(RoomModel room, String playerName);\n\n        public void onPlayerLeftRoom(RoomModel room, String playerName);\n\n        public void onRoomInfoReceived(String [] players, String data);\n    }\n\n    public void addNetworkListener(NetworkListener listener);\n\n    public void removeNetworkListener(NetworkListener listener);\n\n    public void clearNetworkListeners();\n\n    public void connect();\n\n    public void disconnect();\n\n    public void listRooms();\n\n    public void createRoom(String roomName);\n\n    public void deleteRoom(String roomId);\n\n    public void joinRoom(String roomId);\n\n    public void leaveRoom(String roomId);\n\n    public void sendMessage(String message);\n\n    public void sendMessageTo(String destination, String message);\n\n    public void startGame(String roomId);\n\n    public void getRoomInfo(String roomId);\n\n    public boolean isConnected();\n\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/models/GhostMovement.java\npublic class GhostMovement {\n\n    private GameScreen.Direction direction;\n    private int distance;\n\n    public GhostMovement(GameScreen.Direction direction, int distance) {\n        this.direction = direction;\n        this.distance = distance;\n    }\n\n    public GameScreen.Direction getDirection() {\n        return direction;\n    }\n\n    public void setDirection(GameScreen.Direction direction) {\n        this.direction = direction;\n    }\n\n    public int getDistance() {\n        return distance;\n    }\n\n    public void setDistance(int distance) {\n        this.distance = distance;\n    }\n\n    public boolean movable(GhostModel ghostModel, byte[][] grid) {\n        switch (direction) {\n            case UP:\n                return grid[ghostModel.getGridX()][ghostModel.getGridY() + 1] == LabyrinthModel.EMPTY;\n            case DOWN:\n                return grid[ghostModel.getGridX()][ghostModel.getGridY() - 1] == LabyrinthModel.EMPTY;\n            case RIGHT:\n                return grid[ghostModel.getGridX() + 1][ghostModel.getGridY()] == LabyrinthModel.EMPTY;\n            case LEFT:\n                return grid[ghostModel.getGridX() - 1][ghostModel.getGridY()] == LabyrinthModel.EMPTY;\n        }\n\n        return false;\n    }\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/models/GhostModel.java\npublic class GhostModel extends GameObjectModel {\n    public interface GhostListener {\n        public void onStop();\n        public void onCaught(List<String> players);\n    }\n\n    private GhostListener listener;\n\n    private static int ID = 1;\n\n    // http://strategywiki.org/wiki/Bomberman/How_to_play\n    public static enum Type {\n        BALLOOM(1, 100), MINVO(2, 60);\n\n        int value;\n        int speed;\n        Type(int value, int speed) {\n            this.value = value;\n            this.speed = speed;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public int getSpeed() {\n            return speed;\n        }\n    }\n\n    public static enum State {\n        STANDING_UP, STANDING_DOWN, STANDING_RIGHT, STANDING_LEFT, WALKING_UP, WALKING_DOWN, WALKING_RIGHT, WALKING_LEFT, DEAD\n    }\n\n    public static GhostModel createGhostModel(Type type) {\n        GhostModel ghostModel = new GhostModel(ID++);\n        ghostModel.setType(type);\n        return ghostModel;\n    }\n\n    private int id;\n    private float speed = 100f;\n    private int targetGridX = -1;\n    private int targetGridY = -1;\n    private int gridX;\n    private int gridY;\n    private Type type = Type.BALLOOM;\n    private State state = State.STANDING_DOWN;\n\n    public GhostModel(int id) {\n        this.id = id;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public float getSpeed() {\n        return speed;\n    }\n\n    public void setSpeed(float speed) {\n        this.speed = speed;\n    }\n\n    public Type getType() {\n        return type;\n    }\n\n    public void setType(Type type) {\n        this.type = type;\n        this.speed = type.getSpeed();\n    }\n\n    public State getState() {\n        return state;\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public float getOriginX() {\n        return this.x + this.width * 0.5f;\n    }\n\n    public float getOriginY() {\n        return this.y + this.height * 0.5f;\n    }\n\n    public int getTargetGridX() {\n        return targetGridX;\n    }\n\n    public void setTargetGridX(int targetGridX) {\n        this.targetGridX = targetGridX;\n    }\n\n    public int getTargetGridY() {\n        return targetGridY;\n    }\n\n    public void setTargetGridY(int targetGridY) {\n        this.targetGridY = targetGridY;\n    }\n\n    public int getGridX() {\n        return gridX;\n    }\n\n    public void setGridX(int gridX) {\n        this.gridX = gridX;\n    }\n\n    public int getGridY() {\n        return gridY;\n    }\n\n    public void setGridY(int gridY) {\n        this.gridY = gridY;\n    }\n\n    public void setListener(GhostListener listener) {\n        this.listener = listener;\n    }\n\n    public GhostListener getListener() {\n        return listener;\n    }\n}\ncore/src/main/java/net/javaci/mobile/bomberman/core/World.java\npublic class World implements BombModel.BombListener {\n    private Random rand = new Random();\n    private Map<String, PlayerModel> playerModels = new HashMap<String, PlayerModel>();\n    private LabyrinthModel labyrinthModel;\n    private ResolutionHelper resolutionHelper;\n    private Map<Integer, GhostModel> ghostModels = new HashMap<Integer, GhostModel>();\n    private List<BombModel> bombList = new ArrayList<BombModel>();\n    private AssetsInterface assetsInterface;\n    private float gridWidth;\n    private float gridHeight;\n    private Vector2 vector = new Vector2(0, 0);\n    private static int BOMB_ACTIVATION_TIME = 1;\n\n\n    public void initialize(LabyrinthModel labyrinthModel, ResolutionHelper resolutionHelper, AssetsInterface assets) {\n        this.labyrinthModel = labyrinthModel;\n        this.resolutionHelper = resolutionHelper;\n        this.assetsInterface = assets;\n        this.gridWidth = resolutionHelper.getGameAreaBounds().x / (float) LabyrinthModel.NUM_COLS;\n        this.gridHeight = resolutionHelper.getGameAreaBounds().y / (float) LabyrinthModel.NUM_ROWS;\n    }\n\n    public void update(float deltaTime) {\n        updatePlayerModels(deltaTime);\n        updateBombs(deltaTime);\n        updateGhostModels(deltaTime);\n    }\n\n    private void updateBombs(float deltaTime) {\n        BombModel [] array = new BombModel[this.bombList.size()];\n        //concurrent modification exception almamak icin.\n        this.bombList.toArray(array);\n        for (BombModel bomb: array) {\n            if (!bomb.isActivated()) {\n                PlayerModel playerModel = playerModels.get(bomb.getOwner());\n                if (playerModel != null) {\n                    if (Math.abs(getGridX(playerModel.getOriginX()) - bomb.getGridX()) > 1 || Math.abs(getGridY(playerModel.getOriginY()) - bomb.getGridY()) > 1) {\n                        Log.d(\"Bomb activated\");\n                        bomb.setActivated(true);\n                    }\n                    bomb.setActivationTime(bomb.getActivationTime() + deltaTime);\n                    if (bomb.getActivationTime() > BOMB_ACTIVATION_TIME) {\n                        bomb.setActivated(true);\n                    }\n                }\n            }\n            bomb.update(deltaTime);\n        }\n    }\n\n    private void updateGhostModels(float deltaTime) {\n        for (GhostModel ghostModel : ghostModels.values()) {\n            updateGhostModel(ghostModel, deltaTime);\n        }\n    }\n\n    private void updatePlayerModels(float deltaTime) {\n        for (PlayerModel playerModel : playerModels.values()) {\n            if (playerModel.getState() != PlayerModel.State.DEAD) {\n                updatePlayerModel(playerModel, deltaTime);\n            }\n        }\n    }\n\n    public Vector2 getPlayerGridPosition(String playerName) {\n        PlayerModel playerModel = playerModels.get(playerName);\n\n        if (playerModel != null) {\n            if (labyrinthModel.getGrid()[getGridX(playerModel.getOriginX())][getGridY(playerModel.getOriginY())] != LabyrinthModel.EMPTY) {\n                switch (playerModel.getState()) {\n                    case WALKING_UP:\n                    case STOPPING_UP: {\n                        return new Vector2(getGridX(playerModel.getOriginX()), getGridY(playerModel.getOriginY()) - 1);\n                    }\n                    case WALKING_DOWN:\n                    case STOPPING_DOWN: {\n                        return new Vector2(getGridX(playerModel.getOriginX()), getGridY(playerModel.getOriginY()) + 1);\n                    }\n                    case WALKING_RIGHT:\n                    case STOPPING_RIGHT: {\n                        return new Vector2(getGridX(playerModel.getOriginX()) - 1, getGridY(playerModel.getOriginY()));\n                    }\n                    case WALKING_LEFT:\n                    case STOPPING_LEFT:{\n                        return new Vector2(getGridX(playerModel.getOriginX()) + 1, getGridY(playerModel.getOriginY()));\n                    }\n                }\n            }\n\n            return new Vector2(getGridX(playerModel.getOriginX()), getGridY(playerModel.getOriginY()));\n        }\n\n        return null;\n    }\n\n    private void updateGhostModel(GhostModel ghostModel, float deltaTime) {\n        float speed = ghostModel.getSpeed() * resolutionHelper.getSizeMultiplier();\n        boolean ghostCanMove = checkGhostCanMove(ghostModel);\n        if (ghostCanMove) {\n            switch (ghostModel.getState()) {\n                case WALKING_UP:\n                    if (ghostModel.getTargetGridY() >= 0) {\n                        float diff = getGridOriginY(ghostModel.getTargetGridY()) - ghostModel.getOriginY();\n                        float distance = deltaTime * speed;\n                        if (distance >= diff) {\n                            distance = diff;\n                            stopGhost(ghostModel.getId());\n                        }\n                        ghostModel.setY(ghostModel.getY() + distance);\n                    }\n                    else {\n                        stopGhost(ghostModel.getId());\n                    }\n                    break;\n                case WALKING_DOWN:\n                    if (ghostModel.getTargetGridY() >= 0) {\n                        float diff = ghostModel.getOriginY() - getGridOriginY(ghostModel.getTargetGridY());\n                        float distance = deltaTime * speed;\n                        if (distance >= diff) {\n                            distance = diff;\n                            stopGhost(ghostModel.getId());\n                        }\n                        ghostModel.setY(ghostModel.getY() - distance);\n                    }\n                    else {\n                        stopGhost(ghostModel.getId());\n                    }\n                    break;\n                case WALKING_RIGHT:\n                    if (ghostModel.getTargetGridX() >= 0) {\n                        float diff = getGridOriginX(ghostModel.getTargetGridX()) - ghostModel.getOriginX();\n                        float distance = deltaTime * speed;\n                        if (distance >= diff) {\n                            distance = diff;\n                            stopGhost(ghostModel.getId());\n                        }\n                        ghostModel.setX(ghostModel.getX() + distance);\n                    }\n                    else {\n                        stopGhost(ghostModel.getId());\n                    }\n                    break;\n                case WALKING_LEFT:\n                    if (ghostModel.getTargetGridX() >= 0) {\n                        float diff = ghostModel.getOriginX() - getGridOriginX(ghostModel.getTargetGridX());\n                        float distance = deltaTime * speed;\n                        if (distance >= diff) {\n                            distance = diff;\n                            stopGhost(ghostModel.getId());\n                        }\n                        ghostModel.setX(ghostModel.getX() - distance);\n                    }\n                    else {\n                        stopGhost(ghostModel.getId());\n                    }\n                    break;\n            }\n        }\n        else {\n            stopGhost(ghostModel.getId());\n        }\n\n        if (ghostModel.getListener() != null) {\n            List<String> caughtPlayers = new ArrayList<String>();\n            for (PlayerModel playerModel : playerModels.values()) {\n                if (!playerModel.isCaught()) {\n                    int gridX = getGridX(playerModel.getOriginX());\n                    int gridY = getGridY(playerModel.getOriginY());\n                    int ghostGridX = getGridX(ghostModel.getOriginX());\n                    int ghostGridY = getGridY(ghostModel.getOriginY());\n                    if (gridX == ghostGridX && gridY == ghostGridY) {\n                        if (playerModel.isImmortal() == false) {\n                            playerModel.setCaught(true);\n                            caughtPlayers.add(playerModel.getPlayerName());\n                        }\n                    }\n                }\n            }\n\n            if (!caughtPlayers.isEmpty()) {\n                ghostModel.getListener().onCaught(caughtPlayers);\n            }\n        }\n    }\n\n    private void updatePlayerModel(PlayerModel playerModel, float deltaTime) {\n        if (playerModel.isImmortal()) {\n            playerModel.decrementImmortalDuration(deltaTime);\n        }\n        float x = playerModel.getX();\n        float y = playerModel.getY();\n        float speed = playerModel.getSpeed() * resolutionHelper.getSizeMultiplier();\n        boolean playerCanMove = checkPlayerCanMove(playerModel);\n        if (playerCanMove) {\n            switch (playerModel.getState()) {\n                case WALKING_UP:\n                    playerModel.setY(y + deltaTime * speed);\n                    break;\n                case STOPPING_UP: {\n                    if (playerModel.getPlayerName().equals(UserSession.getInstance().getUsername())) {\n                        Vector2 targetPosition = getTargetGridPosition(playerModel);\n                        playerModel.setTargetGridY((int)targetPosition.y);\n                    }\n                    if (playerModel.getTargetGridY() >= 0) {\n                        float diff = getGridOriginY(playerModel.getTargetGridY()) - playerModel.getOriginY();\n                        float distance = deltaTime * speed;\n                        if (distance >= diff) {\n                            distance = diff;\n                            playerModel.setTargetGridY(-1);\n                            playerModel.setState(PlayerModel.State.STANDING_UP);\n                        }\n                        playerModel.setY(playerModel.getY() + distance);\n                    }\n                    break;\n                }\n                case WALKING_DOWN:\n                    playerModel.setY(y - deltaTime * speed);\n                    break;\n                case STOPPING_DOWN: {\n                    if (playerModel.getPlayerName().equals(UserSession.getInstance().getUsername())) {\n                        Vector2 targetPosition = getTargetGridPosition(playerModel);\n                        playerModel.setTargetGridY((int)targetPosition.y);\n                    }\n                    if (playerModel.getTargetGridY() >= 0) {\n                        float diff = playerModel.getOriginY() - getGridOriginY(playerModel.getTargetGridY());\n                        float distance = deltaTime * speed;\n                        if (distance >= diff) {\n                            distance = diff;\n                            playerModel.setTargetGridY(-1);\n                            playerModel.setState(PlayerModel.State.STANDING_DOWN);\n                        }\n                        playerModel.setY(playerModel.getY() - distance);\n                    }\n                    break;\n                }\n                case WALKING_RIGHT:\n                    playerModel.setX(x + deltaTime * speed);\n                    break;\n                case STOPPING_RIGHT: {\n                    if (playerModel.getPlayerName().equals(UserSession.getInstance().getUsername())) {\n                        Vector2 targetPosition = getTargetGridPosition(playerModel);\n                        playerModel.setTargetGridX((int) targetPosition.x);\n                    }\n                    if (playerModel.getTargetGridX() >= 0) {\n                        float diff = getGridOriginX(playerModel.getTargetGridX()) - playerModel.getOriginX();\n                        float distance = deltaTime * speed;\n                        if (distance >= diff) {\n                            distance = diff;\n                            playerModel.setTargetGridX(-1);\n                            playerModel.setState(PlayerModel.State.STANDING_RIGHT);\n                        }\n                        playerModel.setX(playerModel.getX() + distance);\n                    }\n                    break;\n                }\n                case WALKING_LEFT:\n                    playerModel.setX(x - deltaTime * speed);\n                    break;\n                case STOPPING_LEFT:{\n                    if (playerModel.getPlayerName().equals(UserSession.getInstance().getUsername())) {\n                        Vector2 targetPosition = getTargetGridPosition(playerModel);\n                        playerModel.setTargetGridX((int)targetPosition.x);\n                    }\n                    if (playerModel.getTargetGridX() >= 0) {\n                        float diff = playerModel.getOriginX() - getGridOriginX(playerModel.getTargetGridX());\n                        float distance = deltaTime * speed;\n                        if (distance >= diff) {\n                            distance = diff;\n                            playerModel.setTargetGridX(-1);\n                            playerModel.setState(PlayerModel.State.STANDING_LEFT);\n                        }\n                        playerModel.setX(playerModel.getX() - distance);\n                    }\n                    break;\n                }\n            }\n        }  else {\n            switch (playerModel.getState()) {\n                case STOPPING_UP:\n                    playerModel.setState(PlayerModel.State.STANDING_UP);\n                    break;\n                case STOPPING_DOWN:\n                    playerModel.setState(PlayerModel.State.STANDING_DOWN);\n                    break;\n                case STOPPING_RIGHT:\n                    playerModel.setState(PlayerModel.State.STANDING_RIGHT);\n                    break;\n                case STOPPING_LEFT:\n                    playerModel.setState(PlayerModel.State.STANDING_LEFT);\n                    break;\n            }\n        }\n    }\n\n    public Vector2 getTargetGridPosition(String playerName) {\n        return getTargetGridPosition(playerModels.get(playerName));\n    }\n\n    public Vector2 getTargetGridPosition(PlayerModel playerModel) {\n        switch (playerModel.getState()) {\n            case WALKING_UP:\n            case STOPPING_UP: {\n                int gridY = getGridY(playerModel.getOriginY());\n                float centerGridY = getGridOriginY(gridY);\n                if ((int)playerModel.getOriginY() > (int)centerGridY) {\n                    gridY = clamp(1, (gridY + 1), LabyrinthModel.NUM_ROWS - 2);\n                }\n                vector.set(getGridX(playerModel.getOriginX()), gridY);\n                return vector;\n            }\n            case WALKING_DOWN:\n            case STOPPING_DOWN: {\n                int gridY = getGridY(playerModel.getOriginY());\n                float centerGridY = getGridOriginY(gridY);\n                if ((int)playerModel.getOriginY() < (int)centerGridY) {\n                    gridY = Math.max((gridY - 1), 1);\n                }\n                vector.set(getGridX(playerModel.getOriginX()), gridY);\n                return vector;\n            }\n\n            case WALKING_RIGHT:\n            case STOPPING_RIGHT: {\n                int gridX = getGridX(playerModel.getOriginX());\n                float centerGridX = getGridOriginX(gridX);\n                if ((int)playerModel.getOriginX() > (int)centerGridX) {\n                    gridX = clamp(1, (gridX + 1), LabyrinthModel.NUM_COLS - 2);\n                }\n                vector.set(gridX, getGridY(playerModel.getOriginY()));\n                return vector;\n            }\n\n            case WALKING_LEFT:\n            case STOPPING_LEFT: {\n                int gridX = getGridX(playerModel.getOriginX());\n                float centerGridX = getGridOriginX(gridX);\n                if ((int)playerModel.getOriginX() < (int)centerGridX) {\n                    gridX = clamp(1, (gridX - 1), LabyrinthModel.NUM_COLS - 2);\n                }\n                vector.set(gridX, getGridY(playerModel.getOriginY()));\n                return vector;\n            }\n            case STANDING_UP:\n            case STANDING_DOWN:\n            case STANDING_LEFT:\n            case STANDING_RIGHT:\n                vector.set(getGridX(playerModel.getOriginX()), getGridY(playerModel.getOriginY()));\n                return vector;\n        }\n        return null;\n    }\n\n    public void setPlayerTargetPosition(String playerName, int gridX, int gridY) {\n        PlayerModel playerModel = playerModels.get(playerName);\n        playerModel.setTargetGridX(gridX);\n        playerModel.setTargetGridY(gridY);\n    }\n\n    private float getGridOriginX(int gridX) {\n        return gridWidth * gridX + gridWidth * 0.5f + resolutionHelper.getGameAreaPosition().x;\n    }\n\n    private float getGridOriginY(int gridY) {\n        return gridHeight * gridY + gridHeight * 0.5f + resolutionHelper.getGameAreaPosition().y;\n    }\n\n    private boolean checkPlayerCanMove(PlayerModel playerModel) {\n        byte[][] grid = labyrinthModel.getGrid();\n        switch (playerModel.getState()) {\n            case WALKING_UP:\n            case STOPPING_UP:{\n                int gridX = getGridX(playerModel.getOriginX());\n                int gridY = getGridY(playerModel.getY() + playerModel.getHeight() + 2);\n                return !existBombOnGrid(playerModel.getPlayerName(), gridX, gridY) && isGridPositionEmpty(grid, gridX, gridY);\n            }\n            case WALKING_DOWN:\n            case STOPPING_DOWN:{\n                int gridX = getGridX(playerModel.getOriginX());\n                int gridY = getGridY(playerModel.getY() -  2);\n                return !existBombOnGrid(playerModel.getPlayerName(), gridX, gridY) && isGridPositionEmpty(grid, gridX, gridY);\n            }\n            case WALKING_RIGHT:\n            case STOPPING_RIGHT:{\n                int gridX = getGridX(playerModel.getX() + playerModel.getWidth() + 2);\n                int gridY = getGridY(playerModel.getOriginY());\n                return !existBombOnGrid(playerModel.getPlayerName(), gridX, gridY) && isGridPositionEmpty(grid, gridX, gridY);\n            }\n            case WALKING_LEFT:\n            case STOPPING_LEFT:{\n                int gridX = getGridX(playerModel.getX() - 2);\n                int gridY = getGridY(playerModel.getOriginY());\n                return !existBombOnGrid(playerModel.getPlayerName(), gridX, gridY) && isGridPositionEmpty(grid, gridX, gridY);\n            }\n        }\n        return true;\n    }\n\n    private boolean existBombOnGrid(String playerName, int gridX, int gridY) {\n        for (BombModel bombModel : bombList) {\n            if (bombModel.getGridX() == gridX && bombModel.getGridY() == gridY) {\n                if (playerName != null && playerName.equals(bombModel.getOwner()) && !bombModel.isActivated()) {\n                    return false;\n                }\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean existBombOnGrid(int gridX, int gridY) {\n        for (BombModel bombModel : bombList) {\n            if (bombModel.getGridX() == gridX && bombModel.getGridY() == gridY) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean checkGhostCanMove(GhostModel ghostModel) {\n        byte[][] grid = labyrinthModel.getGrid();\n\n        switch (ghostModel.getState()) {\n            case WALKING_UP: {\n                int gridX = getGridX(ghostModel.getOriginX());\n                int gridY = getGridY(ghostModel.getY() + ghostModel.getHeight() + 1);\n                return !existBombOnGrid(gridX, gridY) && isGridPositionEmpty(grid, gridX, gridY);\n            }\n            case WALKING_DOWN: {\n                int gridX = getGridX(ghostModel.getOriginX());\n                int gridY = getGridY(ghostModel.getY() - 1);\n                return !existBombOnGrid(gridX, gridY) && isGridPositionEmpty(grid, gridX, gridY);\n            }\n            case WALKING_RIGHT: {\n                int gridX = getGridX(ghostModel.getX() + ghostModel.getWidth() + 1);\n                int gridY = getGridY(ghostModel.getOriginY());\n                return !existBombOnGrid(gridX, gridY) && isGridPositionEmpty(grid, gridX, gridY);\n            }\n            case WALKING_LEFT:{\n                int gridX = getGridX(ghostModel.getX() - 1);\n                int gridY = getGridY(ghostModel.getOriginY());\n                return !existBombOnGrid(gridX, gridY) && isGridPositionEmpty(grid, gridX, gridY);\n            }\n        }\n        return true;\n    }\n\n    private boolean isGridPositionEmpty(byte[][] grid, int gridX, int gridY) {\n        if (gridX >= LabyrinthModel.NUM_COLS || gridY >= LabyrinthModel.NUM_ROWS || gridX<0 || gridY <0){\n            return false;\n        }\n        return grid[gridX][gridY] == LabyrinthModel.EMPTY;\n    }\n\n    public int getGridX(float x) {\n        return (int) ((x - resolutionHelper.getGameAreaPosition().x) / gridWidth);\n    }\n\n    public int getGridY(float y) {\n        return (int) ((y - resolutionHelper.getGameAreaPosition().y) / gridHeight);\n    }\n\n    public void setPositionGhostOnGrid(int ghostId, int gridX, int gridY) {\n        GhostModel model = ghostModels.get(ghostId);\n        if (model == null) {\n            Log.e(\"Cannot find Ghost Model : \" + ghostId);\n            return;\n        }\n\n        model.setX(getX(gridX));\n        model.setY(getY(gridY));\n    }\n\n    public void moveGhost(int ghostId, int gridX, int gridY, GameScreen.Direction direction, int distance) {\n        GhostModel model = ghostModels.get(ghostId);\n        if (model == null) {\n            Log.e(\"Cannot find Ghost Model : \" + ghostId);\n            return;\n        }\n\n        switch (direction) {\n            case UP:\n                model.setState(GhostModel.State.WALKING_UP);\n                model.setTargetGridX(gridX);\n                model.setTargetGridY(gridY + distance);\n                break;\n            case DOWN:\n                model.setState(GhostModel.State.WALKING_DOWN);\n                model.setTargetGridX(gridX);\n                model.setTargetGridY(gridY - distance);\n                break;\n            case RIGHT:\n                model.setState(GhostModel.State.WALKING_RIGHT);\n                model.setTargetGridX(gridX + distance);\n                model.setTargetGridY(gridY);\n                break;\n            case LEFT:\n                model.setState(GhostModel.State.WALKING_LEFT);\n                model.setTargetGridX(gridX - distance);\n                model.setTargetGridY(gridY);\n                break;\n        }\n    }\n\n    public void stopGhost(int ghostId) {\n        GhostModel ghost = ghostModels.get(ghostId);\n        ghost.setGridX(getGridX(ghost.getOriginX()));\n        ghost.setGridY(getGridY(ghost.getOriginY()));\n        ghost.setTargetGridX(-1);\n        ghost.setTargetGridY(-1);\n        switch (ghost.getState()) {\n            case WALKING_UP:\n                ghost.setState(GhostModel.State.STANDING_UP);\n                callGhostStopListener(ghost);\n                break;\n            case WALKING_DOWN:\n                ghost.setState(GhostModel.State.STANDING_DOWN);\n                callGhostStopListener(ghost);\n                break;\n            case WALKING_RIGHT:\n                ghost.setState(GhostModel.State.STANDING_RIGHT);\n                callGhostStopListener(ghost);\n                break;\n            case WALKING_LEFT:\n                ghost.setState(GhostModel.State.STANDING_LEFT);\n                callGhostStopListener(ghost);\n                break;\n        }\n    }\n\n    private void callGhostStopListener(GhostModel ghostModel) {\n        if (UserSession.getInstance().isServer()) {\n            if (ghostModel.getListener() != null) {\n                ghostModel.getListener().onStop();\n            }\n        }\n    }\n\n    private void callGhostCaughtListener(GhostModel ghostModel, List<String> players) {\n        if (UserSession.getInstance().isServer()) {\n            if (ghostModel.getListener() != null) {\n                ghostModel.getListener().onCaught(players);\n            }\n        }\n    }\n\n    public void movePlayer(String playerName, GameScreen.Direction direction, int gridX, int gridY) {\n        PlayerModel player = playerModels.get(playerName);\n        if (playerName.equals(UserSession.getInstance().getUsername()) == false) {\n            if (player.getTargetGridX() >= 0 && player.getTargetGridY() >= 0) {\n                player.setX(getX(player.getTargetGridX()));\n                player.setY(getY(player.getTargetGridY()));\n                player.setTargetGridX(-1);\n                player.setTargetGridY(-1);\n            }\n        }\n        if (gridX >= 0 && gridY >= 0) {\n            player.setX(getX(gridX));\n            player.setY(getY(gridY));\n        }\n        if (playerName.equals(UserSession.getInstance().getUsername()) && isMoving(player)) {\n            return;\n        }\n        switch (direction) {\n            case UP:\n                player.setState(PlayerModel.State.WALKING_UP);\n                break;\n            case DOWN:\n                player.setState(PlayerModel.State.WALKING_DOWN);\n                break;\n            case RIGHT:\n                player.setState(PlayerModel.State.WALKING_RIGHT);\n                break;\n            case LEFT:\n                player.setState(PlayerModel.State.WALKING_LEFT);\n                break;\n        }\n    }\n\n    private boolean isMoving(PlayerModel playerModel) {\n        PlayerModel.State state = playerModel.getState();\n        return ! (state == PlayerModel.State.STANDING_DOWN ||\n                state == PlayerModel.State.STANDING_LEFT ||\n                state == PlayerModel.State.STANDING_RIGHT ||\n                state == PlayerModel.State.STANDING_UP);\n    }\n\n    public void stopPlayer(String playerName) {\n        PlayerModel player = playerModels.get(playerName);\n        switch (player.getState()) {\n            case WALKING_UP:\n                player.setState(PlayerModel.State.STOPPING_UP);\n                break;\n            case WALKING_DOWN:\n                player.setState(PlayerModel.State.STOPPING_DOWN);\n                break;\n            case WALKING_RIGHT:\n                player.setState(PlayerModel.State.STOPPING_RIGHT);\n                break;\n            case WALKING_LEFT:\n                player.setState(PlayerModel.State.STOPPING_LEFT);\n                break;\n        }\n    }\n\n    public void addGhostModels(List<GhostModel> ghostModels) {\n        for (GhostModel ghostModel : ghostModels) {\n            ghostModel.setX(getX(ghostModel.getGridX()));\n            ghostModel.setY(getY(ghostModel.getGridY()));\n            this.ghostModels.put(ghostModel.getId(), ghostModel);\n        }\n    }\n\n    public void putGhostEmptyPlace(GhostModel ghostModel) {\n        Random rand = new Random();\n        int randX, randY;\n        do {\n            randX = rand.nextInt(LabyrinthModel.NUM_COLS - 4) + 2;\n            randY = rand.nextInt(LabyrinthModel.NUM_ROWS - 4) + 2;\n        } while (labyrinthModel.getGrid()[randX][randY] != LabyrinthModel.EMPTY);\n\n        ghostModel.setX(getX(randX));\n        ghostModel.setY(getY(randY));\n\n        ghostModel.setGridX(randX);\n        ghostModel.setGridY(randY);\n    }\n\n    public float getX(int gridX) {\n        float unitWidth = resolutionHelper.getGameAreaBounds().x / (float) LabyrinthModel.NUM_COLS;\n        return unitWidth * gridX + resolutionHelper.getGameAreaPosition().x;\n    }\n\n    public float getY(int gridY) {\n        float unitHeight = resolutionHelper.getGameAreaBounds().y / (float) LabyrinthModel.NUM_ROWS;\n        return unitHeight * gridY + resolutionHelper.getGameAreaPosition().y;\n    }\n\n    public void addGhostModel(GhostModel ghostModel) {\n        ghostModels.put(ghostModel.getId(), ghostModel);\n    }\n\n    public Map<Integer, GhostModel> getGhostModels() {\n        return ghostModels;\n    }\n\n    public void addPlayerModel(PlayerModel playerModel) {\n        playerModels.put(playerModel.getPlayerName(), playerModel);\n    }\n\n    public LabyrinthModel getLabyrinthModel() {\n        return labyrinthModel;\n    }\n\n    public BombModel dropBomb(int id, int gridX, int gridY, String owner) {\n        BombModel bombModel = new BombModel(id);\n        bombModel.setX(gridX * gridWidth + resolutionHelper.getGameAreaPosition().x);\n        bombModel.setY(gridY * gridHeight + resolutionHelper.getGameAreaPosition().y);\n        bombModel.setWidth(this.gridWidth);\n        bombModel.setHeight(this.gridHeight);\n        bombModel.setGridX(gridX);\n        bombModel.setGridY(gridY);\n        bombModel.setOwner(owner);\n\n        bombModel.addBombListener(this);\n        bombList.add(bombModel);\n\n        return bombModel;\n    }\n\n    public BombModel  playerDroppedBomb(String username) {\n        PlayerModel playerModel = playerModels.get(username);\n        BombModel bombModel = new BombModel(rand.nextInt(Integer.MAX_VALUE));\n        bombModel.setWidth(this.gridWidth);\n        bombModel.setHeight(this.gridHeight);\n        bombModel.setOwner(username);\n        bombModel.setRemainingSeconds(5);\n        bombModel.setActivated(false);\n\n        float unitWidth = resolutionHelper.getGameAreaBounds().x / (float) LabyrinthModel.NUM_COLS;\n        float unitHeight = resolutionHelper.getGameAreaBounds().y / (float) LabyrinthModel.NUM_ROWS;\n        int gridX = (int) ((playerModel.getOriginX() - resolutionHelper.getGameAreaPosition().x) / unitWidth);\n        int gridY = (int) ((playerModel.getOriginY() - resolutionHelper.getGameAreaPosition().y) / unitHeight);\n\n        bombModel.setX(gridX * unitWidth + resolutionHelper.getGameAreaPosition().x);\n        bombModel.setY(gridY * unitHeight + resolutionHelper.getGameAreaPosition().y);\n        bombModel.setGridX(getGridX(bombModel.getOriginX()));\n        bombModel.setGridY(getGridY(bombModel.getOriginY()));\n\n        bombModel.addBombListener(this);\n        bombList.add(bombModel);\n        return bombModel;\n    }\n\n    @Override\n    public void onBombExploded(BombModel bombModel) {\n        this.bombList.remove(bombModel);\n    }\n\n    public List<String> getExplodedPlayerNames(BombModel bombModel) {\n        List<String> result = new ArrayList<String>();\n        List<Vector2> explodedCells = calculateBombExplosionCells(bombModel);\n        if (explodedCells != null) {\n            for (Vector2 cell : explodedCells) {\n                for (PlayerModel playerModel : playerModels.values()) {\n                    if (playerModel.isImmortal()) {\n                        continue;\n                    }\n                    int playerGridX = getGridX(playerModel.getOriginX());\n                    int playerGridY = getGridY(playerModel.getOriginY());\n                    if ((int)cell.x == playerGridX && (int)cell.y == playerGridY) {\n                        result.add(playerModel.getPlayerName());\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    public List<Integer> getExplodedGhosts(BombModel bombModel) {\n        List<Integer> result = new ArrayList<Integer>();\n        List<Vector2> explodedCells = calculateBombExplosionCells(bombModel);\n        GhostModel[] ghostArray = ghostModels.values().toArray(new GhostModel[0]);\n        if (explodedCells != null) {\n            for (Vector2 cell : explodedCells) {\n                for (GhostModel ghostModel : ghostArray) {\n                    int ghostGridX = getGridX(ghostModel.getOriginX());\n                    int ghostGridY = getGridY(ghostModel.getOriginY());\n                    if ((int)cell.x == ghostGridX && (int)cell.y == ghostGridY) {\n                        result.add(ghostModel.getId());\n//                        killGhost(ghostModel);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    public void killPlayer(String playerName) {\n        playerModels.get(playerName).setState(PlayerModel.State.DEAD);\n        playerModels.get(playerName).setLifeCount(0);\n    }\n\n    public void killGhost(int ghostId) {\n        GhostModel model = ghostModels.get(ghostId);\n        if (model != null) {\n            killGhost(model);\n        }\n    }\n\n    private void killGhost(GhostModel ghostModel) {\n        if (ghostModel == null) {\n            return;\n        }\n        ghostModel.setState(GhostModel.State.DEAD);\n        // TODO: removing immediately result in by pass DEAD animation of ghost\n        ghostModels.remove(ghostModel.getId());\n    }\n\n    public List<Vector2> calculateBombExplosionCells(BombModel bombModel) {\n        List<Vector2> cells = new ArrayList<Vector2>();\n        float unitWidth = resolutionHelper.getGameAreaBounds().x / (float) LabyrinthModel.NUM_COLS;\n        float unitHeight = resolutionHelper.getGameAreaBounds().y / (float) LabyrinthModel.NUM_ROWS;\n        int gridX = (int) ((bombModel.getOriginX()  - resolutionHelper.getGameAreaPosition().x) / unitWidth);\n        int gridY = (int) ((bombModel.getOriginY() - resolutionHelper.getGameAreaPosition().y) / unitHeight);\n        byte[][] grid = labyrinthModel.getGrid();\n        //gridX, gridY etrafindaki patlayacak cell'leri bul. bossa iki cell, brick varsa 1 cell, wall varsa 0 cell. patlar.\n        //left\n        if (addToListIfCellTypeIs(LabyrinthModel.EMPTY, cells, grid, gridX + 1, gridY) ) {\n            addToListIfCellTypeIs(LabyrinthModel.EMPTY, cells, grid, gridX + 2, gridY);\n        } else {\n            addToListIfCellTypeIs(LabyrinthModel.BRICK, cells, grid, gridX + 1, gridY);\n        }\n\n        //right\n        if (addToListIfCellTypeIs(LabyrinthModel.EMPTY, cells, grid, gridX - 1, gridY) ) {\n            addToListIfCellTypeIs(LabyrinthModel.EMPTY, cells, grid, gridX - 2, gridY);\n        } else {\n            addToListIfCellTypeIs(LabyrinthModel.BRICK, cells, grid, gridX - 1, gridY);\n        }\n\n        //top\n        if (addToListIfCellTypeIs(LabyrinthModel.EMPTY, cells, grid, gridX, gridY + 1)) {\n            addToListIfCellTypeIs(LabyrinthModel.EMPTY, cells, grid, gridX, gridY + 2);\n        } else {\n            addToListIfCellTypeIs(LabyrinthModel.BRICK, cells, grid, gridX, gridY + 1);\n        }\n\n        //down\n        if (addToListIfCellTypeIs(LabyrinthModel.EMPTY, cells, grid, gridX, gridY - 1)) {\n            addToListIfCellTypeIs(LabyrinthModel.EMPTY, cells, grid, gridX, gridY - 2);\n        } else {\n            addToListIfCellTypeIs(LabyrinthModel.BRICK, cells, grid, gridX, gridY - 1);\n        }\n        cells.add(new Vector2(gridX, gridY));\n        return cells;\n    }\n\n    public List<Vector2> convertCellIndexToScreenCoordinates(List<Vector2> cells) {\n        List<Vector2> list = new ArrayList<Vector2>();\n        float unitWidth = resolutionHelper.getGameAreaBounds().x / (float) LabyrinthModel.NUM_COLS;\n        float unitHeight = resolutionHelper.getGameAreaBounds().y / (float) LabyrinthModel.NUM_ROWS;\n        for (Vector2 cellIndex : cells) {\n            int indexX = (int)cellIndex.x;\n            int indexY = (int)cellIndex.y;\n            Vector2 v = new Vector2(\n                    indexX * unitWidth + resolutionHelper.getGameAreaPosition().x,\n                    indexY * unitHeight+ resolutionHelper.getGameAreaPosition().y);\n            list.add(v);\n        }\n        return list;\n    }\n\n    private boolean addToListIfCellTypeIs(byte cellType,  List<Vector2> list, byte [][] grid, int x, int y) {\n        if (x >= LabyrinthModel.NUM_COLS || y >= LabyrinthModel.NUM_ROWS || x<0 || y <0){\n            return false;\n        }\n        if (grid[x][y] == cellType) {\n            list.add(new Vector2(x, y));\n            return true;\n        }\n        return false;\n    }\n\n    public float getGridHeight() {\n        return gridHeight;\n    }\n\n    public float getGridWidth() {\n        return gridWidth;\n    }\n\n    private int clamp(int min, int value, int max) {\n        return Math.max(min, Math.min(max, value));\n    }\n\n    public void removePlayer(String playerName) {\n        this.playerModels.remove(playerName);\n\n    }\n\n    public int getNextGameIndex() {\n        int max = 0;\n        for (PlayerModel player : playerModels.values()) {\n            if (player.getGameIndex() > max) {\n                max = player.getGameIndex();\n            }\n        }\n        return max + 1;\n    }\n\n    public boolean isGameEnd() {\n        int playingUser = 0;\n        for (PlayerModel playerModel : playerModels.values()) {\n            if (playerModel.getState() != PlayerModel.State.DEAD) {\n                playingUser++;\n            }\n        }\n        return playingUser <= 1;\n    }\n\n    public String getWinnerName() {\n        for (PlayerModel playerModel : playerModels.values()) {\n            if (playerModel.getState() != PlayerModel.State.DEAD) {\n                return playerModel.getPlayerName();\n            }\n        }\n        return null;\n    }\n\n\n    public boolean canRespawn(String playerName) {\n        PlayerModel playerModel = playerModels.get(playerName);\n        return playerModel.getLifeCount() > 1;\n    }\n\n    public void respawnPlayerAndDecrementLife(String playerName, Vector2 playerInitialPosition) {\n        PlayerModel playerModel = playerModels.get(playerName);\n        playerModel.setCaught(false);\n        playerModel.resetImmortalDuration();\n        playerModel.decrementLifeCount();\n        playerModel.setPosition(playerInitialPosition);\n        playerModel.setState(PlayerModel.State.STANDING_DOWN);\n    }\n\n    public PlayerModel getPlayerModel(String playerName) {\n        return this.playerModels.get(playerName);\n    }\n\n    public PlayerModel getPlayerModelAtIndex(int index) {\n        for (PlayerModel player: this.playerModels.values()) {\n            if (player.getGameIndex() == index) {\n                return player;\n            }\n        }\n        return null;\n    }\n\n    public boolean canUserDropBomb(String username, int maxBomb) {\n        int bombCount = 0;\n        for (BombModel bombModel : bombList) {\n            if (bombModel.getOwner().equals(username)) {\n                bombCount++;\n            }\n        }\n\n        return bombCount<maxBomb;\n    }\n}\n", "answers": ["        startGameCommand.setFromUser(UserSession.getInstance().getUsername());"], "length": 6404, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "74dd4be422031471c7a6854f35d1041be35bafaf3b30d5b9"}
{"input": "import os\nfrom urllib.parse import quote_plus, urlencode\nfrom plexapi import library, media, utils\nfrom plexapi.base import Playable, PlexPartialObject\nfrom plexapi.exceptions import BadRequest\nfrom plexapi.mixins import AdvancedSettingsMixin, ArtUrlMixin, ArtMixin, BannerMixin, PosterUrlMixin, PosterMixin\nfrom plexapi.mixins import RatingMixin, SplitMergeMixin, UnmatchMatchMixin\nfrom plexapi.mixins import CollectionMixin, CountryMixin, DirectorMixin, GenreMixin, LabelMixin, ProducerMixin, WriterMixin\n            from plexapi.sync import MediaSettings\n        from plexapi.sync import SyncItem, Policy, MediaSettings\n        \"\"\" Optimize item\n\n            locationID (int): -1 in folder with original items\n                               2 library path id\n                                 library path id is found in library.locations[i].id\n\n            target (str): custom quality name.\n                          if none provided use \"Custom: {deviceProfile}\"\n\n            targetTagID (int):  Default quality settings\n                                1 Mobile\n                                2 TV\n                                3 Original Quality\n\n            deviceProfile (str): Android, IOS, Universal TV, Universal Mobile, Windows Phone,\n                                    Windows, Xbox One\n\n            Example:\n                Optimize for Mobile\n                   item.optimize(targetTagID=\"Mobile\") or item.optimize(targetTagID=1\")\n                Optimize for Android 10 MBPS 1080p\n                   item.optimize(deviceProfile=\"Android\", videoQuality=10)\n                Optimize for IOS Original Quality\n                   item.optimize(deviceProfile=\"IOS\", videoQuality=-1)\n\n            * see sync.py VIDEO_QUALITIES for additional information for using videoQuality\n        \"\"\"\n        tagValues = [1, 2, 3]\n        tagKeys = [\"Mobile\", \"TV\", \"Original Quality\"]\n        tagIDs = tagKeys + tagValues\n\n        if targetTagID not in tagIDs and (deviceProfile is None or videoQuality is None):\n            raise BadRequest('Unexpected or missing quality profile.')\n\n        libraryLocationIDs = [location.id for location in self.section()._locations()]\n        libraryLocationIDs.append(-1)\n\n        if locationID not in libraryLocationIDs:\n            raise BadRequest('Unexpected library path ID. %s not in %s' %\n                             (locationID, libraryLocationIDs))\n\n        if isinstance(targetTagID, str):\n            tagIndex = tagKeys.index(targetTagID)\n            targetTagID = tagValues[tagIndex]\n\n        if title is None:\n            title = self.title\n\n        backgroundProcessing = self.fetchItem('/playlists?type=42')\n        key = '%s/items?' % backgroundProcessing.key\n        params = {\n            'Item[type]': 42,\n            'Item[target]': target,\n            'Item[targetTagID]': targetTagID if targetTagID else '',\n            'Item[locationID]': locationID,\n            'Item[Policy][scope]': policyScope,\n            'Item[Policy][value]': policyValue,\n            'Item[Policy][unwatched]': policyUnwatched\n        }\n\n        if deviceProfile:\n            params['Item[Device][profile]'] = deviceProfile\n\n        if videoQuality:\n            mediaSettings = MediaSettings.createVideo(videoQuality)\n            params['Item[MediaSettings][videoQuality]'] = mediaSettings.videoQuality\n            params['Item[MediaSettings][videoResolution]'] = mediaSettings.videoResolution\n            params['Item[MediaSettings][maxVideoBitrate]'] = mediaSettings.maxVideoBitrate\n            params['Item[MediaSettings][audioBoost]'] = ''\n            params['Item[MediaSettings][subtitleSize]'] = ''\n            params['Item[MediaSettings][musicBitrate]'] = ''\n            params['Item[MediaSettings][photoQuality]'] = ''\n\n        titleParam = {'Item[title]': title}\n        section = self._server.library.sectionByID(self.librarySectionID)\n        params['Item[Location][uri]'] = 'library://' + section.uuid + '/item/' + \\\n                                        quote_plus(self.key + '?includeExternalMedia=1')\n\n        data = key + urlencode(params) + '&' + urlencode(titleParam)\n        return self._server.query(data, method=self._server._session.put)\n\n    def sync(self, videoQuality, client=None, clientId=None, limit=None, unwatched=False, title=None):\n        \"\"\" Add current video (movie, tv-show, season or episode) as sync item for specified device.\n            See :func:`~plexapi.myplex.MyPlexAccount.sync` for possible exceptions.\n\n            Parameters:\n                videoQuality (int): idx of quality of the video, one of VIDEO_QUALITY_* values defined in\n                                    :mod:`~plexapi.sync` module.\n                client (:class:`~plexapi.myplex.MyPlexDevice`): sync destination, see\n                                                               :func:`~plexapi.myplex.MyPlexAccount.sync`.\n                clientId (str): sync destination, see :func:`~plexapi.myplex.MyPlexAccount.sync`.\n                limit (int): maximum count of items to sync, unlimited if `None`.\n                unwatched (bool): if `True` watched videos wouldn't be synced.\n                title (str): descriptive title for the new :class:`~plexapi.sync.SyncItem`, if empty the value would be\n                             generated from metadata of current media.\n\n            Returns:\n                :class:`~plexapi.sync.SyncItem`: an instance of created syncItem.\n        \"\"\"\n\n\n        myplex = self._server.myPlexAccount()\n        sync_item = SyncItem(self._server, None)\n        sync_item.title = title if title else self._defaultSyncTitle()\n        sync_item.rootTitle = self.title\n        sync_item.contentType = self.listType\n        sync_item.metadataType = self.METADATA_TYPE\n        sync_item.machineIdentifier = self._server.machineIdentifier\n\n        section = self._server.library.sectionByID(self.librarySectionID)\n\n        sync_item.location = 'library://%s/item/%s' % (section.uuid, quote_plus(self.key))\n        sync_item.policy = Policy.create(limit, unwatched)\n        sync_item.mediaSettings = MediaSettings.createVideo(videoQuality)\n\n        return myplex.sync(sync_item, client=client, clientId=clientId)\n\n\n@utils.registerPlexObject\nclass Movie(Video, Playable, AdvancedSettingsMixin, ArtMixin, PosterMixin, RatingMixin, SplitMergeMixin, UnmatchMatchMixin,\n", "context": "plexapi/mixins.py\nclass DirectorMixin(object):\n    \"\"\" Mixin for Plex objects that can have directors. \"\"\"\n\n    def addDirector(self, directors, locked=True):\n        \"\"\" Add a director tag(s).\n\n           Parameters:\n                directors (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('director', directors, locked=locked)\n\n    def removeDirector(self, directors, locked=True):\n        \"\"\" Remove a director tag(s).\n\n           Parameters:\n                directors (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('director', directors, locked=locked, remove=True)\nplexapi/utils.py\nSEARCHTYPES = {'movie': 1, 'show': 2, 'season': 3, 'episode': 4, 'trailer': 5, 'comic': 6, 'person': 7,\n               'artist': 8, 'album': 9, 'track': 10, 'picture': 11, 'clip': 12, 'photo': 13, 'photoalbum': 14,\n               'playlist': 15, 'playlistFolder': 16, 'collection': 18, 'optimizedVersion': 42, 'userPlaylistItem': 1001}\nPLEXOBJECTS = {}\nclass SecretsFilter(logging.Filter):\n    def __init__(self, secrets=None):\n    def add_secret(self, secret):\n    def filter(self, record):\ndef registerPlexObject(cls):\ndef cast(func, value):\ndef joinArgs(args):\ndef lowerFirst(s):\ndef rget(obj, attrstr, default=None, delim='.'):  # pragma: no cover\ndef searchType(libtype):\ndef reverseSearchType(libtype):\ndef threaded(callback, listargs):\ndef toDatetime(value, format=None):\ndef millisecondToHumanstr(milliseconds):\ndef toList(value, itemcast=None, delim=','):\ndef cleanFilename(filename, replace='_'):\ndef downloadSessionImages(server, filename=None, height=150, width=150,\n                          opacity=100, saturation=100):  # pragma: no cover\ndef download(url, token, filename=None, savepath=None, session=None, chunksize=4024,\n             unpack=False, mocked=False, showstatus=False):\ndef tag_singular(tag):\ndef tag_plural(tag):\ndef tag_helper(tag, items, locked=True, remove=False):\ndef getMyPlexAccount(opts=None):  # pragma: no cover\ndef createMyPlexDevice(headers, account, timeout=10):  # pragma: no cover\ndef choose(msg, items, attr):  # pragma: no cover\ndef getAgentIdentifier(section, agent):\ndef base64str(text):\ndef deprecated(message, stacklevel=2):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\nplexapi/mixins.py\nclass PosterMixin(PosterUrlMixin):\n    \"\"\" Mixin for Plex objects that can have posters. \"\"\"\n\n    def posters(self):\n        \"\"\" Returns list of available :class:`~plexapi.media.Poster` objects. \"\"\"\n        return self.fetchItems('/library/metadata/%s/posters' % self.ratingKey, cls=media.Poster)\n\n    def uploadPoster(self, url=None, filepath=None):\n        \"\"\" Upload a poster from a url or filepath.\n\n            Parameters:\n                url (str): The full URL to the image to upload.\n                filepath (str): The full file path the the image to upload.\n        \"\"\"\n        if url:\n            key = '/library/metadata/%s/posters?url=%s' % (self.ratingKey, quote_plus(url))\n            self._server.query(key, method=self._server._session.post)\n        elif filepath:\n            key = '/library/metadata/%s/posters?' % self.ratingKey\n            data = open(filepath, 'rb').read()\n            self._server.query(key, method=self._server._session.post, data=data)\n\n    def setPoster(self, poster):\n        \"\"\" Set the poster for a Plex object.\n        \n            Parameters:\n                poster (:class:`~plexapi.media.Poster`): The poster object to select.\n        \"\"\"\n        poster.select()\n\n    def lockPoster(self):\n        \"\"\" Lock the poster for a Plex object. \"\"\"\n        self._edit(**{'thumb.locked': 1})\n\n    def unlockPoster(self):\n        \"\"\" Unlock the poster for a Plex object. \"\"\"\n        self._edit(**{'thumb.locked': 0})\nplexapi/mixins.py\nclass RatingMixin(object):\n    \"\"\" Mixin for Plex objects that can have user star ratings. \"\"\"\n\n    def rate(self, rating=None):\n        \"\"\" Rate the Plex object. Note: Plex ratings are displayed out of 5 stars (e.g. rating 7.0 = 3.5 stars).\n\n            Parameters:\n                rating (float, optional): Rating from 0 to 10. Exclude to reset the rating.\n\n            Raises:\n                :exc:`~plexapi.exceptions.BadRequest`: If the rating is invalid.\n        \"\"\"\n        if rating is None:\n            rating = -1\n        elif not isinstance(rating, (int, float)) or rating < 0 or rating > 10:\n            raise BadRequest('Rating must be between 0 to 10.')\n        key = '/:/rate?key=%s&identifier=com.plexapp.plugins.library&rating=%s' % (self.ratingKey, rating)\n        self._server.query(key, method=self._server._session.put)\nplexapi/mixins.py\nclass GenreMixin(object):\n    \"\"\" Mixin for Plex objects that can have genres. \"\"\"\n\n    def addGenre(self, genres, locked=True):\n        \"\"\" Add a genre tag(s).\n\n           Parameters:\n                genres (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('genre', genres, locked=locked)\n\n    def removeGenre(self, genres, locked=True):\n        \"\"\" Remove a genre tag(s).\n\n           Parameters:\n                genres (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('genre', genres, locked=locked, remove=True)\nplexapi/mixins.py\nclass CountryMixin(object):\n    \"\"\" Mixin for Plex objects that can have countries. \"\"\"\n\n    def addCountry(self, countries, locked=True):\n        \"\"\" Add a country tag(s).\n\n           Parameters:\n                countries (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('country', countries, locked=locked)\n\n    def removeCountry(self, countries, locked=True):\n        \"\"\" Remove a country tag(s).\n\n           Parameters:\n                countries (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('country', countries, locked=locked, remove=True)\nplexapi/media.py\nclass Media(PlexObject):\nclass MediaPart(PlexObject):\nclass MediaPartStream(PlexObject):\nclass VideoStream(MediaPartStream):\nclass AudioStream(MediaPartStream):\nclass SubtitleStream(MediaPartStream):\nclass LyricStream(MediaPartStream):\nclass Session(PlexObject):\nclass TranscodeSession(PlexObject):\nclass TranscodeJob(PlexObject):\nclass Optimized(PlexObject):\nclass Conversion(PlexObject):\nclass MediaTag(PlexObject):\nclass Collection(MediaTag):\nclass Country(MediaTag):\nclass Director(MediaTag):\nclass Format(MediaTag):\nclass Genre(MediaTag):\nclass Label(MediaTag):\nclass Mood(MediaTag):\nclass Producer(MediaTag):\nclass Role(MediaTag):\nclass Similar(MediaTag):\nclass Style(MediaTag):\nclass Subformat(MediaTag):\nclass Tag(MediaTag):\nclass Writer(MediaTag):\nclass GuidTag(PlexObject):\nclass Guid(GuidTag):\nclass Review(PlexObject):\nclass BaseImage(PlexObject):\nclass Art(BaseImage):\nclass Banner(BaseImage):\nclass Poster(BaseImage):\nclass Chapter(PlexObject):\nclass Marker(PlexObject):\nclass Field(PlexObject):\nclass SearchResult(PlexObject):\nclass Agent(PlexObject):\nclass AgentMediaType(Agent):\n    TAG = 'Media'\n    TAG = 'Part'\n    TAG = 'Stream'\n    STREAMTYPE = 1\n    TAG = 'Stream'\n    STREAMTYPE = 2\n    TAG = 'Stream'\n    STREAMTYPE = 3\n    TAG = 'Stream'\n    STREAMTYPE = 4\n    TAG = 'Session'\n    TAG = 'TranscodeSession'\n    TAG = 'TranscodeJob'\n    TAG = 'Item'\n    TAG = 'Video'\n    TAG = 'Collection'\n    FILTER = 'collection'\n    TAG = 'Country'\n    FILTER = 'country'\n    TAG = 'Director'\n    FILTER = 'director'\n    TAG = 'Format'\n    FILTER = 'format'\n    TAG = 'Genre'\n    FILTER = 'genre'\n    TAG = 'Label'\n    FILTER = 'label'\n    TAG = 'Mood'\n    FILTER = 'mood'\n    TAG = 'Producer'\n    FILTER = 'producer'\n    TAG = 'Role'\n    FILTER = 'role'\n    TAG = 'Similar'\n    FILTER = 'similar'\n    TAG = 'Style'\n    FILTER = 'style'\n    TAG = 'Subformat'\n    FILTER = 'subformat'\n    TAG = 'Tag'\n    FILTER = 'tag'\n    TAG = 'Writer'\n    FILTER = 'writer'\n    TAG = 'Guid'\n    TAG = 'Review'\n    TAG = 'Photo'\n    TAG = 'Chapter'\n    TAG = 'Marker'\n    TAG = 'Field'\n    TAG = 'SearchResult'\n    TAG = 'Agent'\n    TAG = 'MediaType'\n    def _loadData(self, data):\n    def isOptimizedVersion(self):\n    def delete(self):\n    def _loadData(self, data):\n    def _buildStreams(self, data):\n    def hasPreviewThumbnails(self):\n    def videoStreams(self):\n    def audioStreams(self):\n    def subtitleStreams(self):\n    def lyricStreams(self):\n    def setDefaultAudioStream(self, stream):\n    def setDefaultSubtitleStream(self, stream):\n    def resetDefaultSubtitleStream(self):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def items(self):\n    def remove(self):\n    def rename(self, title):\n    def reprocess(self, ratingKey):\n    def _loadData(self, data):\n    def remove(self):\n    def move(self, after):\n    def _loadData(self, data):\n    def items(self):\n    def collection(self):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def select(self):\n    def _loadData(self, data):\n    def __repr__(self):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def __repr__(self):\n    def _loadData(self, data):\n    def __repr__(self):\n    def _loadData(self, data):\n    def languageCode(self):\n    def settings(self):\n    def _settings(self):\n    def __repr__(self):\n    def _loadData(self, data):\n    def languageCode(self):\nplexapi/mixins.py\nclass ArtUrlMixin(object):\n    \"\"\" Mixin for Plex objects that can have a background artwork url. \"\"\"\n    \n    @property\n    def artUrl(self):\n        \"\"\" Return the art url for the Plex object. \"\"\"\n        art = self.firstAttr('art', 'grandparentArt')\n        return self._server.url(art, includeToken=True) if art else None\nplexapi/library.py\nclass Library(PlexObject):\nclass LibrarySection(PlexObject):\nclass MovieSection(LibrarySection):\nclass ShowSection(LibrarySection):\nclass MusicSection(LibrarySection):\nclass PhotoSection(LibrarySection):\nclass LibraryTimeline(PlexObject):\nclass Location(PlexObject):\nclass Hub(PlexObject):\nclass HubMediaTag(PlexObject):\nclass Tag(HubMediaTag):\nclass Genre(HubMediaTag):\nclass Director(HubMediaTag):\nclass Actor(HubMediaTag):\nclass AutoTag(HubMediaTag):\nclass Place(HubMediaTag):\nclass FilteringType(PlexObject):\nclass FilteringFilter(PlexObject):\nclass FilteringSort(PlexObject):\nclass FilteringField(PlexObject):\nclass FilteringFieldType(PlexObject):\nclass FilteringOperator(PlexObject):\nclass FilterChoice(PlexObject):\nclass Folder(PlexObject):\nclass FirstCharacter(PlexObject):\nclass Path(PlexObject):\nclass File(PlexObject):\n    def _loadData(self, data):\n    def _loadSections(self):\n    def sections(self):\n    def section(self, title):\n    def sectionByID(self, sectionID):\n    def hubs(self, sectionID=None, identifier=None, **kwargs):\n    def all(self, **kwargs):\n    def onDeck(self):\n    def recentlyAdded(self):\n    def search(self, title=None, libtype=None, **kwargs):\n    def cleanBundles(self):\n    def emptyTrash(self):\n    def optimize(self):\n    def update(self):\n    def cancelUpdate(self):\n    def refresh(self):\n    def deleteMediaPreviews(self):\n    def add(self, name='', type='', agent='', scanner='', location='', language='en', *args, **kwargs):\n    def history(self, maxresults=9999999, mindate=None):\n    def _loadData(self, data):\n    def fetchItems(self, ekey, cls=None, container_start=None, container_size=None, **kwargs):\n    def totalSize(self):\n    def totalDuration(self):\n    def totalStorage(self):\n    def _getTotalDurationStorage(self):\n    def totalViewSize(self, libtype=None, includeCollections=True):\n    def delete(self):\n    def reload(self):\n    def edit(self, agent=None, **kwargs):\n    def addLocations(self, location):\n    def removeLocations(self, location):\n    def get(self, title):\n    def getGuid(self, guid):\n    def all(self, libtype=None, **kwargs):\n    def folders(self):\n    def hubs(self):\n    def agents(self):\n    def settings(self):\n    def editAdvanced(self, **kwargs):\n    def defaultAdvanced(self):\n    def _lockUnlockAllField(self, field, libtype=None, locked=True):\n    def lockAllField(self, field, libtype=None):\n    def unlockAllField(self, field, libtype=None):\n    def timeline(self):\n    def onDeck(self):\n    def recentlyAdded(self, maxresults=50, libtype=None):\n    def firstCharacter(self):\n    def analyze(self):\n    def emptyTrash(self):\n    def update(self, path=None):\n    def cancelUpdate(self):\n    def refresh(self):\n    def deleteMediaPreviews(self):\n    def _loadFilters(self):\n    def filterTypes(self):\n    def getFilterType(self, libtype=None):\n    def fieldTypes(self):\n    def getFieldType(self, fieldType):\n    def listFilters(self, libtype=None):\n    def listSorts(self, libtype=None):\n    def listFields(self, libtype=None):\n    def listOperators(self, fieldType):\n    def listFilterChoices(self, field, libtype=None):\n    def _validateFilterField(self, field, values, libtype=None):\n    def _validateFieldOperator(self, filterField, operator):\n    def _validateFieldValue(self, filterField, values, libtype=None):\n    def _validateFieldValueDate(self, value):\n    def _validateFieldValueTag(self, value, filterField, libtype):\n    def _validateSortFields(self, sort, libtype=None):\n    def _validateSortField(self, sort, libtype=None):\n    def _validateAdvancedSearch(self, filters, libtype):\n    def _buildSearchKey(self, title=None, sort=None, libtype=None, limit=None, filters=None, returnKwargs=False, **kwargs):\n    def hubSearch(self, query, mediatype=None, limit=None):\n    def search(self, title=None, sort=None, maxresults=None, libtype=None,\n               container_start=0, container_size=X_PLEX_CONTAINER_SIZE, limit=None, filters=None, **kwargs):\n    def _search(self, key, maxresults, container_start, container_size, **kwargs):\n    def _locations(self):\n    def sync(self, policy, mediaSettings, client=None, clientId=None, title=None, sort=None, libtype=None,\n             **kwargs):\n    def history(self, maxresults=9999999, mindate=None):\n    def createCollection(self, title, items=None, smart=False, limit=None,\n                         libtype=None, sort=None, filters=None, **kwargs):\n    def collection(self, title):\n    def collections(self, **kwargs):\n    def createPlaylist(self, title, items=None, smart=False, limit=None,\n                       sort=None, filters=None, **kwargs):\n    def playlist(self, title):\n    def playlists(self, sort=None, **kwargs):\n    def filterFields(self, mediaType=None):\n    def listChoices(self, category, libtype=None, **kwargs):\n    def getWebURL(self, base=None, tab=None, key=None):\n    def searchMovies(self, **kwargs):\n    def recentlyAddedMovies(self, maxresults=50):\n    def sync(self, videoQuality, limit=None, unwatched=False, **kwargs):\n    def searchShows(self, **kwargs):\n    def searchSeasons(self, **kwargs):\n    def searchEpisodes(self, **kwargs):\n    def recentlyAddedShows(self, maxresults=50):\n    def recentlyAddedSeasons(self, maxresults=50):\n    def recentlyAddedEpisodes(self, maxresults=50):\n    def sync(self, videoQuality, limit=None, unwatched=False, **kwargs):\n    def albums(self):\n    def stations(self):\n    def searchArtists(self, **kwargs):\n    def searchAlbums(self, **kwargs):\n    def searchTracks(self, **kwargs):\n    def recentlyAddedArtists(self, maxresults=50):\n    def recentlyAddedAlbums(self, maxresults=50):\n    def recentlyAddedTracks(self, maxresults=50):\n    def sync(self, bitrate, limit=None, **kwargs):\n    def all(self, libtype=None, **kwargs):\n    def collections(self, **kwargs):\n    def searchAlbums(self, title, **kwargs):\n    def searchPhotos(self, title, **kwargs):\n    def recentlyAddedAlbums(self, maxresults=50):\n    def sync(self, resolution, limit=None, **kwargs):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def __len__(self):\n    def reload(self):\n    def section(self):\n    def _loadData(self, data):\n    def items(self, *args, **kwargs):\n    def __repr__(self):\n    def _loadData(self, data):\n    def _manualSorts(self):\n    def _manualFields(self):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def __repr__(self):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def subfolders(self):\n    def allSubfolders(self):\n    def _loadData(self, data):\n    def _loadData(self, data):\n    def browse(self, includeFiles=True):\n    def walk(self):\n    def _loadData(self, data):\n    TAG = 'Directory'\n    TYPE = 'movie'\n    METADATA_TYPE = 'movie'\n    CONTENT_TYPE = 'video'\n    TAG = 'Directory'\n    TYPE = 'show'\n    METADATA_TYPE = 'episode'\n    CONTENT_TYPE = 'video'\n    TAG = 'Directory'\n    TYPE = 'artist'\n    METADATA_TYPE = 'track'\n    CONTENT_TYPE = 'audio'\n    TAG = 'Directory'\n    TYPE = 'photo'\n    METADATA_TYPE = 'photo'\n    CONTENT_TYPE = 'photo'\n    TAG = 'LibraryTimeline'\n    TAG = 'Location'\n    TAG = 'Hub'\n    TAG = 'Directory'\n    TAGTYPE = 0\n    TAGTYPE = 1\n    TAGTYPE = 4\n    TAGTYPE = 6\n    TAGTYPE = 207\n    TAGTYPE = 400\n    TAG = 'Type'\n    TAG = 'Filter'\n    TAG = 'Sort'\n    TAG = 'Field'\n    TAG = 'FieldType'\n    TAG = 'Operator'\n    TAG = 'Directory'\n    TAG = 'Path'\n    TAG = 'File'\nplexapi/mixins.py\nclass SplitMergeMixin(object):\n    \"\"\" Mixin for Plex objects that can be split and merged. \"\"\"\n\n    def split(self):\n        \"\"\" Split duplicated Plex object into separate objects. \"\"\"\n        key = '/library/metadata/%s/split' % self.ratingKey\n        return self._server.query(key, method=self._server._session.put)\n\n    def merge(self, ratingKeys):\n        \"\"\" Merge other Plex objects into the current object.\n        \n            Parameters:\n                ratingKeys (list): A list of rating keys to merge.\n        \"\"\"\n        if not isinstance(ratingKeys, list):\n            ratingKeys = str(ratingKeys).split(',')\n\n        key = '%s/merge?ids=%s' % (self.key, ','.join([str(r) for r in ratingKeys]))\n        return self._server.query(key, method=self._server._session.put)\nplexapi/mixins.py\nclass BannerMixin(BannerUrlMixin):\n    \"\"\" Mixin for Plex objects that can have banners. \"\"\"\n\n    def banners(self):\n        \"\"\" Returns list of available :class:`~plexapi.media.Banner` objects. \"\"\"\n        return self.fetchItems('/library/metadata/%s/banners' % self.ratingKey, cls=media.Banner)\n\n    def uploadBanner(self, url=None, filepath=None):\n        \"\"\" Upload a banner from a url or filepath.\n        \n            Parameters:\n                url (str): The full URL to the image to upload.\n                filepath (str): The full file path the the image to upload.\n        \"\"\"\n        if url:\n            key = '/library/metadata/%s/banners?url=%s' % (self.ratingKey, quote_plus(url))\n            self._server.query(key, method=self._server._session.post)\n        elif filepath:\n            key = '/library/metadata/%s/banners?' % self.ratingKey\n            data = open(filepath, 'rb').read()\n            self._server.query(key, method=self._server._session.post, data=data)\n\n    def setBanner(self, banner):\n        \"\"\" Set the banner for a Plex object.\n        \n            Parameters:\n                banner (:class:`~plexapi.media.Banner`): The banner object to select.\n        \"\"\"\n        banner.select()\n\n    def lockBanner(self):\n        \"\"\" Lock the banner for a Plex object. \"\"\"\n        self._edit(**{'banner.locked': 1})\n\n    def unlockBanner(self):\n        \"\"\" Unlock the banner for a Plex object. \"\"\"\n        self._edit(**{'banner.locked': 0})\nplexapi/mixins.py\nclass CollectionMixin(object):\n    \"\"\" Mixin for Plex objects that can have collections. \"\"\"\n\n    def addCollection(self, collections, locked=True):\n        \"\"\" Add a collection tag(s).\n\n           Parameters:\n                collections (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('collection', collections, locked=locked)\n\n    def removeCollection(self, collections, locked=True):\n        \"\"\" Remove a collection tag(s).\n\n           Parameters:\n                collections (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('collection', collections, locked=locked, remove=True)\nplexapi/mixins.py\nclass PosterUrlMixin(object):\n    \"\"\" Mixin for Plex objects that can have a poster url. \"\"\"\n\n    @property\n    def thumbUrl(self):\n        \"\"\" Return the thumb url for the Plex object. \"\"\"\n        thumb = self.firstAttr('thumb', 'parentThumb', 'granparentThumb')\n        return self._server.url(thumb, includeToken=True) if thumb else None\n\n    @property\n    def posterUrl(self):\n        \"\"\" Alias to self.thumbUrl. \"\"\"\n        return self.thumbUrl\nplexapi/mixins.py\nclass WriterMixin(object):\n    \"\"\" Mixin for Plex objects that can have writers. \"\"\"\n\n    def addWriter(self, writers, locked=True):\n        \"\"\" Add a writer tag(s).\n\n           Parameters:\n                writers (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('writer', writers, locked=locked)\n\n    def removeWriter(self, writers, locked=True):\n        \"\"\" Remove a writer tag(s).\n\n           Parameters:\n                writers (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('writer', writers, locked=locked, remove=True)\nplexapi/mixins.py\nclass LabelMixin(object):\n    \"\"\" Mixin for Plex objects that can have labels. \"\"\"\n\n    def addLabel(self, labels, locked=True):\n        \"\"\" Add a label tag(s).\n\n           Parameters:\n                labels (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('label', labels, locked=locked)\n\n    def removeLabel(self, labels, locked=True):\n        \"\"\" Remove a label tag(s).\n\n           Parameters:\n                labels (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('label', labels, locked=locked, remove=True)\nplexapi/base.py\nclass Playable(object):\n    \"\"\" This is a general place to store functions specific to media that is Playable.\n        Things were getting mixed up a bit when dealing with Shows, Season, Artists,\n        Albums which are all not playable.\n\n        Attributes:\n            sessionKey (int): Active session key.\n            usernames (str): Username of the person playing this item (for active sessions).\n            players (:class:`~plexapi.client.PlexClient`): Client objects playing this item (for active sessions).\n            session (:class:`~plexapi.media.Session`): Session object, for a playing media file.\n            transcodeSessions (:class:`~plexapi.media.TranscodeSession`): Transcode Session object\n                if item is being transcoded (None otherwise).\n            viewedAt (datetime): Datetime item was last viewed (history).\n            accountID (int): The associated :class:`~plexapi.server.SystemAccount` ID.\n            deviceID (int): The associated :class:`~plexapi.server.SystemDevice` ID.\n            playlistItemID (int): Playlist item ID (only populated for :class:`~plexapi.playlist.Playlist` items).\n            playQueueItemID (int): PlayQueue item ID (only populated for :class:`~plexapi.playlist.PlayQueue` items).\n    \"\"\"\n\n    def _loadData(self, data):\n        self.sessionKey = utils.cast(int, data.attrib.get('sessionKey'))            # session\n        self.usernames = self.listAttrs(data, 'title', etag='User')                 # session\n        self.players = self.findItems(data, etag='Player')                          # session\n        self.transcodeSessions = self.findItems(data, etag='TranscodeSession')      # session\n        self.session = self.findItems(data, etag='Session')                         # session\n        self.viewedAt = utils.toDatetime(data.attrib.get('viewedAt'))               # history\n        self.accountID = utils.cast(int, data.attrib.get('accountID'))              # history\n        self.deviceID = utils.cast(int, data.attrib.get('deviceID'))                # history\n        self.playlistItemID = utils.cast(int, data.attrib.get('playlistItemID'))    # playlist\n        self.playQueueItemID = utils.cast(int, data.attrib.get('playQueueItemID'))  # playqueue\n\n    def getStreamURL(self, **params):\n        \"\"\" Returns a stream url that may be used by external applications such as VLC.\n\n            Parameters:\n                **params (dict): optional parameters to manipulate the playback when accessing\n                    the stream. A few known parameters include: maxVideoBitrate, videoResolution\n                    offset, copyts, protocol, mediaIndex, platform.\n\n            Raises:\n                :exc:`~plexapi.exceptions.Unsupported`: When the item doesn't support fetching a stream URL.\n        \"\"\"\n        if self.TYPE not in ('movie', 'episode', 'track', 'clip'):\n            raise Unsupported('Fetching stream URL for %s is unsupported.' % self.TYPE)\n        mvb = params.get('maxVideoBitrate')\n        vr = params.get('videoResolution', '')\n        params = {\n            'path': self.key,\n            'offset': params.get('offset', 0),\n            'copyts': params.get('copyts', 1),\n            'protocol': params.get('protocol'),\n            'mediaIndex': params.get('mediaIndex', 0),\n            'X-Plex-Platform': params.get('platform', 'Chrome'),\n            'maxVideoBitrate': max(mvb, 64) if mvb else None,\n            'videoResolution': vr if re.match(r'^\\d+x\\d+$', vr) else None\n        }\n        # remove None values\n        params = {k: v for k, v in params.items() if v is not None}\n        streamtype = 'audio' if self.TYPE in ('track', 'album') else 'video'\n        # sort the keys since the randomness fucks with my tests..\n        sorted_params = sorted(params.items(), key=lambda val: val[0])\n        return self._server.url('/%s/:/transcode/universal/start.m3u8?%s' %\n            (streamtype, urlencode(sorted_params)), includeToken=True)\n\n    def iterParts(self):\n        \"\"\" Iterates over the parts of this media item. \"\"\"\n        for item in self.media:\n            for part in item.parts:\n                yield part\n\n    def play(self, client):\n        \"\"\" Start playback on the specified client.\n\n            Parameters:\n                client (:class:`~plexapi.client.PlexClient`): Client to start playing on.\n        \"\"\"\n        client.playMedia(self)\n\n    def download(self, savepath=None, keep_original_name=False, **kwargs):\n        \"\"\" Downloads the media item to the specified location. Returns a list of\n            filepaths that have been saved to disk.\n\n            Parameters:\n                savepath (str): Defaults to current working dir.\n                keep_original_name (bool): True to keep the original filename otherwise\n                    a friendlier filename is generated. See filenames below.\n                **kwargs (dict): Additional options passed into :func:`~plexapi.audio.Track.getStreamURL`\n                    to download a transcoded stream, otherwise the media item will be downloaded\n                    as-is and saved to disk.\n\n            **Filenames**\n\n            * Movie: ``<title> (<year>)``\n            * Episode: ``<show title> - s00e00 - <episode title>``\n            * Track: ``<artist title> - <album title> - 00 - <track title>``\n            * Photo: ``<photoalbum title> - <photo/clip title>`` or ``<photo/clip title>``\n        \"\"\"\n        filepaths = []\n        parts = [i for i in self.iterParts() if i]\n\n        for part in parts:\n            if not keep_original_name:\n                filename = utils.cleanFilename('%s.%s' % (self._prettyfilename(), part.container))\n            else:\n                filename = part.file\n\n            if kwargs:\n                # So this seems to be a alot slower but allows transcode.\n                download_url = self.getStreamURL(**kwargs)\n            else:\n                download_url = self._server.url('%s?download=1' % part.key)\n\n            filepath = utils.download(\n                download_url,\n                self._server._token,\n                filename=filename,\n                savepath=savepath,\n                session=self._server._session\n            )\n\n            if filepath:\n                filepaths.append(filepath)\n\n        return filepaths\n\n    def stop(self, reason=''):\n        \"\"\" Stop playback for a media item. \"\"\"\n        key = '/status/sessions/terminate?sessionId=%s&reason=%s' % (self.session[0].id, quote_plus(reason))\n        return self._server.query(key)\n\n    def updateProgress(self, time, state='stopped'):\n        \"\"\" Set the watched progress for this video.\n\n        Note that setting the time to 0 will not work.\n        Use `markWatched` or `markUnwatched` to achieve\n        that goal.\n\n            Parameters:\n                time (int): milliseconds watched\n                state (string): state of the video, default 'stopped'\n        \"\"\"\n        key = '/:/progress?key=%s&identifier=com.plexapp.plugins.library&time=%d&state=%s' % (self.ratingKey,\n                                                                                              time, state)\n        self._server.query(key)\n        self._reload(_autoReload=True)\n\n    def updateTimeline(self, time, state='stopped', duration=None):\n        \"\"\" Set the timeline progress for this video.\n\n            Parameters:\n                time (int): milliseconds watched\n                state (string): state of the video, default 'stopped'\n                duration (int): duration of the item\n        \"\"\"\n        durationStr = '&duration='\n        if duration is not None:\n            durationStr = durationStr + str(duration)\n        else:\n            durationStr = durationStr + str(self.duration)\n        key = '/:/timeline?ratingKey=%s&key=%s&identifier=com.plexapp.plugins.library&time=%d&state=%s%s'\n        key %= (self.ratingKey, self.key, time, state, durationStr)\n        self._server.query(key)\n        self._reload(_autoReload=True)\nplexapi/mixins.py\nclass AdvancedSettingsMixin(object):\n    \"\"\" Mixin for Plex objects that can have advanced settings. \"\"\"\n\n    def preferences(self):\n        \"\"\" Returns a list of :class:`~plexapi.settings.Preferences` objects. \"\"\"\n        data = self._server.query(self._details_key)\n        return self.findItems(data, settings.Preferences, rtag='Preferences')\n\n    def preference(self, pref):\n        \"\"\" Returns a :class:`~plexapi.settings.Preferences` object for the specified pref.\n\n            Parameters:\n                pref (str): The id of the preference to return.\n        \"\"\"\n        prefs = self.preferences()\n        try:\n            return next(p for p in prefs if p.id == pref)\n        except StopIteration:\n            availablePrefs = [p.id for p in prefs]\n            raise NotFound('Unknown preference \"%s\" for %s. '\n                           'Available preferences: %s'\n                           % (pref, self.TYPE, availablePrefs)) from None\n\n    def editAdvanced(self, **kwargs):\n        \"\"\" Edit a Plex object's advanced settings. \"\"\"\n        data = {}\n        key = '%s/prefs?' % self.key\n        preferences = {pref.id: pref for pref in self.preferences() if pref.enumValues}\n        for settingID, value in kwargs.items():\n            try:\n                pref = preferences[settingID]\n            except KeyError:\n                raise NotFound('%s not found in %s' % (value, list(preferences.keys())))\n            \n            enumValues = pref.enumValues\n            if enumValues.get(value, enumValues.get(str(value))):\n                data[settingID] = value\n            else:\n                raise NotFound('%s not found in %s' % (value, list(enumValues)))\n        url = key + urlencode(data)\n        self._server.query(url, method=self._server._session.put)\n\n    def defaultAdvanced(self):\n        \"\"\" Edit all of a Plex object's advanced settings to default. \"\"\"\n        data = {}\n        key = '%s/prefs?' % self.key\n        for preference in self.preferences():\n            data[preference.id] = preference.default\n        url = key + urlencode(data)\n        self._server.query(url, method=self._server._session.put)\nplexapi/mixins.py\nclass ArtMixin(ArtUrlMixin):\n    \"\"\" Mixin for Plex objects that can have background artwork. \"\"\"\n\n    def arts(self):\n        \"\"\" Returns list of available :class:`~plexapi.media.Art` objects. \"\"\"\n        return self.fetchItems('/library/metadata/%s/arts' % self.ratingKey, cls=media.Art)\n\n    def uploadArt(self, url=None, filepath=None):\n        \"\"\" Upload a background artwork from a url or filepath.\n        \n            Parameters:\n                url (str): The full URL to the image to upload.\n                filepath (str): The full file path the the image to upload.\n        \"\"\"\n        if url:\n            key = '/library/metadata/%s/arts?url=%s' % (self.ratingKey, quote_plus(url))\n            self._server.query(key, method=self._server._session.post)\n        elif filepath:\n            key = '/library/metadata/%s/arts?' % self.ratingKey\n            data = open(filepath, 'rb').read()\n            self._server.query(key, method=self._server._session.post, data=data)\n\n    def setArt(self, art):\n        \"\"\" Set the background artwork for a Plex object.\n        \n            Parameters:\n                art (:class:`~plexapi.media.Art`): The art object to select.\n        \"\"\"\n        art.select()\n\n    def lockArt(self):\n        \"\"\" Lock the background artwork for a Plex object. \"\"\"\n        self._edit(**{'art.locked': 1})\n\n    def unlockArt(self):\n        \"\"\" Unlock the background artwork for a Plex object. \"\"\"\n        self._edit(**{'art.locked': 0})\nplexapi/mixins.py\nclass ProducerMixin(object):\n    \"\"\" Mixin for Plex objects that can have producers. \"\"\"\n\n    def addProducer(self, producers, locked=True):\n        \"\"\" Add a producer tag(s).\n\n           Parameters:\n                producers (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('producer', producers, locked=locked)\n\n    def removeProducer(self, producers, locked=True):\n        \"\"\" Remove a producer tag(s).\n\n           Parameters:\n                producers (list): List of strings.\n                locked (bool): True (default) to lock the field, False to unlock the field.\n        \"\"\"\n        self._edit_tags('producer', producers, locked=locked, remove=True)\nplexapi/base.py\nclass PlexPartialObject(PlexObject):\n    \"\"\" Not all objects in the Plex listings return the complete list of elements\n        for the object. This object will allow you to assume each object is complete,\n        and if the specified value you request is None it will fetch the full object\n        automatically and update itself.\n    \"\"\"\n    _INCLUDES = {\n        'checkFiles': 1,\n        'includeAllConcerts': 1,\n        'includeBandwidths': 1,\n        'includeChapters': 1,\n        'includeChildren': 1,\n        'includeConcerts': 1,\n        'includeExternalMedia': 1,\n        'includeExtras': 1,\n        'includeFields': 'thumbBlurHash,artBlurHash',\n        'includeGeolocation': 1,\n        'includeLoudnessRamps': 1,\n        'includeMarkers': 1,\n        'includeOnDeck': 1,\n        'includePopularLeaves': 1,\n        'includePreferences': 1,\n        'includeRelated': 1,\n        'includeRelatedCount': 1,\n        'includeReviews': 1,\n        'includeStations': 1\n    }\n\n    def __eq__(self, other):\n        return other not in [None, []] and self.key == other.key\n\n    def __hash__(self):\n        return hash(repr(self))\n\n    def __iter__(self):\n        yield self\n\n    def __getattribute__(self, attr):\n        # Dragons inside.. :-/\n        value = super(PlexPartialObject, self).__getattribute__(attr)\n        # Check a few cases where we dont want to reload\n        if attr in _DONT_RELOAD_FOR_KEYS: return value\n        if attr in _DONT_OVERWRITE_SESSION_KEYS: return value\n        if attr in USER_DONT_RELOAD_FOR_KEYS: return value\n        if attr.startswith('_'): return value\n        if value not in (None, []): return value\n        if self.isFullObject(): return value\n        # Log the reload.\n        clsname = self.__class__.__name__\n        title = self.__dict__.get('title', self.__dict__.get('name'))\n        objname = \"%s '%s'\" % (clsname, title) if title else clsname\n        log.debug(\"Reloading %s for attr '%s'\", objname, attr)\n        # Reload and return the value\n        self._reload(_autoReload=True)\n        return super(PlexPartialObject, self).__getattribute__(attr)\n\n    def analyze(self):\n        \"\"\" Tell Plex Media Server to performs analysis on it this item to gather\n            information. Analysis includes:\n\n            * Gather Media Properties: All of the media you add to a Library has\n                properties that are useful to know–whether it's a video file, a\n                music track, or one of your photos (container, codec, resolution, etc).\n            * Generate Default Artwork: Artwork will automatically be grabbed from a\n                video file. A background image will be pulled out as well as a\n                smaller image to be used for poster/thumbnail type purposes.\n            * Generate Video Preview Thumbnails: Video preview thumbnails are created,\n                if you have that feature enabled. Video preview thumbnails allow\n                graphical seeking in some Apps. It's also used in the Plex Web App Now\n                Playing screen to show a graphical representation of where playback\n                is. Video preview thumbnails creation is a CPU-intensive process akin\n                to transcoding the file.\n            * Generate intro video markers: Detects show intros, exposing the\n                'Skip Intro' button in clients.\n        \"\"\"\n        key = '/%s/analyze' % self.key.lstrip('/')\n        self._server.query(key, method=self._server._session.put)\n\n    def isFullObject(self):\n        \"\"\" Returns True if this is already a full object. A full object means all attributes\n            were populated from the api path representing only this item. For example, the\n            search result for a movie often only contain a portion of the attributes a full\n            object (main url) for that movie would contain.\n        \"\"\"\n        return not self.key or (self._details_key or self.key) == self._initpath\n\n    def isPartialObject(self):\n        \"\"\" Returns True if this is not a full object. \"\"\"\n        return not self.isFullObject()\n\n    def _edit(self, **kwargs):\n        \"\"\" Actually edit an object. \"\"\"\n        if 'id' not in kwargs:\n            kwargs['id'] = self.ratingKey\n        if 'type' not in kwargs:\n            kwargs['type'] = utils.searchType(self.type)\n\n        part = '/library/sections/%s/all?%s' % (self.librarySectionID,\n                                                urlencode(kwargs))\n        self._server.query(part, method=self._server._session.put)\n\n    def edit(self, **kwargs):\n        \"\"\" Edit an object.\n\n            Parameters:\n                kwargs (dict): Dict of settings to edit.\n\n            Example:\n                {'type': 1,\n                 'id': movie.ratingKey,\n                 'collection[0].tag.tag': 'Super',\n                 'collection.locked': 0}\n        \"\"\"\n        self._edit(**kwargs)\n\n    def _edit_tags(self, tag, items, locked=True, remove=False):\n        \"\"\" Helper to edit tags.\n\n            Parameters:\n                tag (str): Tag name.\n                items (list): List of tags to add.\n                locked (bool): True to lock the field.\n                remove (bool): True to remove the tags in items.\n        \"\"\"\n        if not isinstance(items, list):\n            items = [items]\n        value = getattr(self, utils.tag_plural(tag))\n        existing_tags = [t.tag for t in value if t and remove is False]\n        tag_edits = utils.tag_helper(tag, existing_tags + items, locked, remove)\n        self.edit(**tag_edits)\n\n    def refresh(self):\n        \"\"\" Refreshing a Library or individual item causes the metadata for the item to be\n            refreshed, even if it already has metadata. You can think of refreshing as\n            \"update metadata for the requested item even if it already has some\". You should\n            refresh a Library or individual item if:\n\n            * You've changed the Library Metadata Agent.\n            * You've added \"Local Media Assets\" (such as artwork, theme music, external\n                subtitle files, etc.)\n            * You want to freshen the item posters, summary, etc.\n            * There's a problem with the poster image that's been downloaded.\n            * Items are missing posters or other downloaded information. This is possible if\n                the refresh process is interrupted (the Server is turned off, internet\n                connection dies, etc).\n        \"\"\"\n        key = '%s/refresh' % self.key\n        self._server.query(key, method=self._server._session.put)\n\n    def section(self):\n        \"\"\" Returns the :class:`~plexapi.library.LibrarySection` this item belongs to. \"\"\"\n        return self._server.library.sectionByID(self.librarySectionID)\n\n    def delete(self):\n        \"\"\" Delete a media element. This has to be enabled under settings > server > library in plex webui. \"\"\"\n        try:\n            return self._server.query(self.key, method=self._server._session.delete)\n        except BadRequest:  # pragma: no cover\n            log.error('Failed to delete %s. This could be because you '\n                'have not allowed items to be deleted', self.key)\n            raise\n\n    def history(self, maxresults=9999999, mindate=None):\n        \"\"\" Get Play History for a media item.\n\n            Parameters:\n                maxresults (int): Only return the specified number of results (optional).\n                mindate (datetime): Min datetime to return results from.\n        \"\"\"\n        return self._server.history(maxresults=maxresults, mindate=mindate, ratingKey=self.ratingKey)\n\n    def _getWebURL(self, base=None):\n        \"\"\" Get the Plex Web URL with the correct parameters.\n            Private method to allow overriding parameters from subclasses.\n        \"\"\"\n        return self._server._buildWebURL(base=base, endpoint='details', key=self.key)\n\n    def getWebURL(self, base=None):\n        \"\"\" Returns the Plex Web URL for a media item.\n\n            Parameters:\n                base (str): The base URL before the fragment (``#!``).\n                    Default is https://app.plex.tv/desktop.\n        \"\"\"\n        return self._getWebURL(base=base)\nplexapi/exceptions.py\nclass BadRequest(PlexApiException):\n    \"\"\" An invalid request, generally a user error. \"\"\"\n    pass\nplexapi/mixins.py\nclass UnmatchMatchMixin(object):\n    \"\"\" Mixin for Plex objects that can be unmatched and matched. \"\"\"\n\n    def unmatch(self):\n        \"\"\" Unmatches metadata match from object. \"\"\"\n        key = '/library/metadata/%s/unmatch' % self.ratingKey\n        self._server.query(key, method=self._server._session.put)\n\n    def matches(self, agent=None, title=None, year=None, language=None):\n        \"\"\" Return list of (:class:`~plexapi.media.SearchResult`) metadata matches.\n\n             Parameters:\n                agent (str): Agent name to be used (imdb, thetvdb, themoviedb, etc.)\n                title (str): Title of item to search for\n                year (str): Year of item to search in\n                language (str) : Language of item to search in\n\n            Examples:\n                1. video.matches()\n                2. video.matches(title=\"something\", year=2020)\n                3. video.matches(title=\"something\")\n                4. video.matches(year=2020)\n                5. video.matches(title=\"something\", year=\"\")\n                6. video.matches(title=\"\", year=2020)\n                7. video.matches(title=\"\", year=\"\")\n\n                1. The default behaviour in Plex Web = no params in plexapi\n                2. Both title and year specified by user\n                3. Year automatically filled in\n                4. Title automatically filled in\n                5. Explicitly searches for title with blank year\n                6. Explicitly searches for blank title with year\n                7. I don't know what the user is thinking... return the same result as 1\n\n                For 2 to 7, the agent and language is automatically filled in\n        \"\"\"\n        key = '/library/metadata/%s/matches' % self.ratingKey\n        params = {'manual': 1}\n\n        if agent and not any([title, year, language]):\n            params['language'] = self.section().language\n            params['agent'] = utils.getAgentIdentifier(self.section(), agent)\n        else:\n            if any(x is not None for x in [agent, title, year, language]):\n                if title is None:\n                    params['title'] = self.title\n                else:\n                    params['title'] = title\n\n                if year is None:\n                    params['year'] = self.year\n                else:\n                    params['year'] = year\n\n                params['language'] = language or self.section().language\n\n                if agent is None:\n                    params['agent'] = self.section().agent\n                else:\n                    params['agent'] = utils.getAgentIdentifier(self.section(), agent)\n\n        key = key + '?' + urlencode(params)\n        data = self._server.query(key, method=self._server._session.get)\n        return self.findItems(data, initpath=key)\n\n    def fixMatch(self, searchResult=None, auto=False, agent=None):\n        \"\"\" Use match result to update show metadata.\n\n            Parameters:\n                auto (bool): True uses first match from matches\n                    False allows user to provide the match\n                searchResult (:class:`~plexapi.media.SearchResult`): Search result from\n                    ~plexapi.base.matches()\n                agent (str): Agent name to be used (imdb, thetvdb, themoviedb, etc.)\n        \"\"\"\n        key = '/library/metadata/%s/match' % self.ratingKey\n        if auto:\n            autoMatch = self.matches(agent=agent)\n            if autoMatch:\n                searchResult = autoMatch[0]\n            else:\n                raise NotFound('No matches found using this agent: (%s:%s)' % (agent, autoMatch))\n        elif not searchResult:\n            raise NotFound('fixMatch() requires either auto=True or '\n                           'searchResult=:class:`~plexapi.media.SearchResult`.')\n\n        params = {'guid': searchResult.guid,\n                  'name': searchResult.name}\n\n        data = key + '?' + urlencode(params)\n        self._server.query(data, method=self._server._session.put)\n", "answers": ["        CollectionMixin, CountryMixin, DirectorMixin, GenreMixin, LabelMixin, ProducerMixin, WriterMixin):"], "length": 5015, "dataset": "repobench-p_e", "language": "python", "all_classes": null, "_id": "0f4ce9705fa57b00ac0cc35bce6b5ac343ddea20b4b1686f"}
{"input": "package br.com.brolam.oha.supervisory.ui;\nimport android.Manifest;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.annotation.NonNull;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.design.widget.Snackbar;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.app.LoaderManager;\nimport android.support.v4.content.CursorLoader;\nimport android.support.v4.content.Loader;\nimport android.support.v4.widget.SwipeRefreshLayout;\nimport android.support.v7.widget.GridLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\nimport android.support.design.widget.NavigationView;\nimport android.support.v4.view.GravityCompat;\nimport android.support.v4.widget.DrawerLayout;\nimport android.support.v7.app.ActionBarDrawerToggle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport java.io.File;\nimport java.util.Date;\nimport br.com.brolam.library.helpers.OhaHelper;\nimport br.com.brolam.oha.supervisory.OhaBroadcast;\nimport br.com.brolam.oha.supervisory.R;\nimport br.com.brolam.oha.supervisory.data.OhaEnergyUseContract;\nimport br.com.brolam.oha.supervisory.ui.adapters.OhaMainAdapter;\nimport br.com.brolam.oha.supervisory.ui.adapters.holders.OhaEnergyUseBillHolder;\nimport br.com.brolam.oha.supervisory.ui.adapters.holders.OhaMainHolder;\nimport br.com.brolam.oha.supervisory.ui.fragments.OhaEnergyUseBillFragment;\nimport br.com.brolam.oha.supervisory.ui.fragments.OhaRestoreDatabaseFragment;\nimport br.com.brolam.oha.supervisory.ui.helpers.OhaBackupHelper;\nimport static br.com.brolam.oha.supervisory.data.OhaEnergyUseContract.*;\n\n\n\n\n/**\n * Atividade principal do aplicativo para disponibilizar as seguintes funcionalidades:\n *  Exibir os cartões de utilização de energia por dia.\n *  Exibir os cartões de utilização de energia por conta.\n *  Exibir o NavigationView com o menu do aplicativo.\n *  Solicitar o backup do banco de dados.\n *  Solicitar o restore do banco de dados.\n * @author Breno Marques\n * @version 1.00\n * @since Release 01\n */\npublic class OhaMainActivity extends AppCompatActivity\n        implements\n        NavigationView.OnNavigationItemSelectedListener,\n        LoaderManager.LoaderCallbacks<Cursor>,\n        View.OnClickListener, OhaMainHolder.IOhaMainHolder,\n        OhaEnergyUseBillFragment.IOhaEnergyUseBillFragment,", "context": "Android/appSupervisory/src/main/java/br/com/brolam/oha/supervisory/ui/adapters/OhaMainAdapter.java\npublic class OhaMainAdapter extends RecyclerView.Adapter<OhaMainHolder>  {\n\n    IOhaMainHolder iOhaMainHolder;\n    private Cursor cursor;\n    //Informar o id do NavigationView MenuItem selecionado.\n    private int navId;\n\n    public OhaMainAdapter(IOhaMainHolder iOhaMainHolder) {\n        this.cursor = null;\n        this.iOhaMainHolder  = iOhaMainHolder;\n        this.navId = -1;\n    }\n\n    public void swapCursor(Cursor newCursor,  int navId ) {\n        if (( this.cursor != null) && ( this.cursor != newCursor)){\n            this.cursor.close();\n            this.cursor = newCursor;\n        }\n        this.navId = navId;\n        cursor = newCursor;\n        notifyDataSetChanged();\n    }\n\n    @Override\n    public OhaMainHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        OhaMainHolder viewHolder = null;\n        if ( this.navId == R.id.nav_energy_use_day){\n            viewHolder = new OhaEnergyUseDayHolder(LayoutInflater.from(this.iOhaMainHolder.getContext()).inflate(R.layout.holder_energy_use_day, parent, false));\n        } else if ( this.navId == R.id.nav_energy_use_bill){\n            viewHolder = new OhaEnergyUseBillHolder( LayoutInflater.from(this.iOhaMainHolder.getContext()).inflate(R.layout.holder_energy_use_bill, parent, false));\n        }\n        return viewHolder;\n    }\n\n    @Override\n    public void onBindViewHolder(OhaMainHolder ohaMainHolder, int position) {\n        this.cursor.moveToPosition(position);\n        ohaMainHolder.bindView(cursor, iOhaMainHolder);\n    }\n\n    @Override\n    public int getItemCount() {\n        return this.cursor == null? 0 : this.cursor.getCount();\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        return this.navId;\n    }\n}\nAndroid/appSupervisory/src/main/java/br/com/brolam/oha/supervisory/ui/adapters/holders/OhaEnergyUseBillHolder.java\npublic class OhaEnergyUseBillHolder extends OhaMainHolder {\n\n    TextView textViewTitle;\n    TextView textViewRead;\n    TextView textViewDailyCost;\n    TextView textViewBody;\n    TextView textViewWattsMax;\n    Toolbar toolbar;\n\n    public OhaEnergyUseBillHolder(View itemView) {\n        super(itemView);\n        this.textViewTitle = (TextView)itemView.findViewById(R.id.textViewTitle);\n        this.textViewRead = (TextView)itemView.findViewById(R.id.textViewRead);\n        this.textViewDailyCost = (TextView)itemView.findViewById(R.id.textViewDailyCost);\n        this.textViewBody = (TextView)itemView.findViewById(R.id.textViewBody);\n        this.textViewWattsMax = (TextView)itemView.findViewById(R.id.textViewWattsMax);\n        this.toolbar = (Toolbar)itemView.findViewById(R.id.toolbar);\n        this.toolbar.inflateMenu(R.menu.holder_energy_use_bill);\n    }\n\n    @Override\n    public void bindView(final Cursor cursor, final OhaMainHolder.IOhaMainHolder iOhaMainHolder) {\n\n        long billAmountDays = OhaHelper.getAmountDays(cursor.getLong(EnergyUseBillEntry.INDEX_COLUMN_FROM), cursor.getLong(EnergyUseBillEntry.INDEX_COLUMN_TO));\n        double billReadingDays = OhaHelper.convertSecondsToDays(cursor.getDouble(EnergyUseBillEntry.INDEX_COLUMN_CALC_DURATION_SUN));\n\n        Double totalKWH = OhaHelper.convertWhToKWH(cursor.getDouble(EnergyUseBillEntry.INDEX_COLUMN_CALC_WH_TOTAL_SUN));\n        Double dailyCost = totalKWH * cursor.getDouble(EnergyUseBillEntry.INDEX_COLUMN_KWH_COST);\n        Double avgKWH = totalKWH > 0 ? totalKWH / billReadingDays : 0.00;\n        Double wattsMax = cursor.getDouble(EnergyUseBillEntry.INDEX_COLUMN_CALC_WATTS_MAX);\n        this.textViewTitle.setText(getEnergyBillTitle(this.textViewTitle.getContext(), cursor.getLong(EnergyUseBillEntry.INDEX_COLUMN_FROM), cursor.getLong(EnergyUseBillEntry.INDEX_COLUMN_TO)));\n        String read = textViewRead.getContext().getString(R.string.energy_use_bill_card_read, OhaHelper.formatNumber(billReadingDays, \"#0.00\"), OhaHelper.formatNumber(billAmountDays, \"#0\") );\n        this.textViewRead.setText(read);\n        this.textViewDailyCost.setText(OhaHelper.formatMoney(dailyCost, \"#,##0.00\"));\n        String body = this.textViewBody.getContext().getString(R.string.energy_use_bill_card_body, OhaHelper.formatNumber(totalKWH, \"#0.00\"), OhaHelper.formatNumber(avgKWH, \"##0.00\"));\n        this.textViewBody.setText(body);\n        this.textViewWattsMax.setText(OhaHelper.formatNumber(wattsMax, \",##0.00\"));\n        final int id = cursor.getInt(EnergyUseBillEntry.INDEX_COLUMN_ID);\n        final long fromDate = cursor.getLong(EnergyUseBillEntry.INDEX_COLUMN_FROM);\n        final long toDate = cursor.getLong(EnergyUseBillEntry.INDEX_COLUMN_TO);\n        final double kwhCost = cursor.getDouble(EnergyUseBillEntry.INDEX_COLUMN_KWH_COST);\n        this.itemView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n\n                if (iOhaMainHolder != null) {\n                    iOhaMainHolder.onEnergyUseBillSelect(id, fromDate, toDate, kwhCost, R.id.action_details);\n                }\n            }\n        });\n\n        this.toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {\n            @Override\n            public boolean onMenuItemClick(MenuItem item) {\n                iOhaMainHolder.onEnergyUseBillSelect(id, fromDate, toDate, kwhCost, item.getItemId());\n                return true;\n            }\n        });\n    }\n\n    public static String getEnergyBillTitle(Context context, long fromDate, long toDate) {\n        return context.getString(\n                R.string.energy_use_bill_card_title,\n                OhaHelper.formatDate(fromDate, \"yyyy, MMM dd\"),\n                OhaHelper.formatDate(toDate, \"MMM dd\")\n        );\n    }\n}\nAndroid/appSupervisory/src/main/java/br/com/brolam/oha/supervisory/data/OhaEnergyUseContract.java\npublic class OhaEnergyUseContract {\n\n    /*Definir a URL base de acesso:*/\n    public static final String CONTENT_AUTHORITY = \"br.com.brolam.oha.supervisory.energy.use\";\n    public static final Uri BASE_CONTENT_URI = Uri.parse(\"content://\" + CONTENT_AUTHORITY);\n\n    /*Definir o caminho por recurso:*/\n    public static final String PATH_LOG = \"log\";\n    public static final String PATH_DAYS = \"days\";\n    //Parêmetro para informar a data final para consultar a utilização de energia por dia:\n    public static final String PATH_DAYS_PARAM_END_DATE = \"endDate\";\n    public static final String PATH_BILL = \"bill\";\n\n    /*Definir as URLs:*/\n    public static final Uri CONTENT_URI_LOG = BASE_CONTENT_URI.buildUpon()\n            .appendPath(PATH_LOG)\n            .build();\n\n    public static final Uri CONTENT_URI_DAYS = BASE_CONTENT_URI.buildUpon()\n            .appendPath(PATH_DAYS)\n            .build();\n\n    /**\n     * Recupear a URI para consultar a utilização de energia por dia {@link br.com.brolam.oha.supervisory.data.cursors.OhaEnergyUseDaysCursor}\n     * @param endDate informar a data final para limitar o curosr até a data informada.\n     */\n    public static Uri getUriDays(Date endDate){\n       return CONTENT_URI_DAYS.buildUpon().appendQueryParameter(PATH_DAYS_PARAM_END_DATE, Long.toString(endDate.getTime())).build();\n    }\n\n    public static final Uri CONTENT_URI_BILL = BASE_CONTENT_URI.buildUpon()\n            .appendPath(PATH_BILL)\n            .build();\n\n    /**\n     * Recuperar a Uri de uma conta de energia por ID para ser utilizada nas operações de Consulta,\n     * alteração e exclusão.\n     * @param id informar uma ID válido.\n     * @return Uri com o parâmetro _id\n     */\n    public static Uri getUriBillById(int id){\n        return CONTENT_URI_BILL.buildUpon().appendQueryParameter(BaseColumns._ID, String.valueOf(id)).build();\n    }\n\n    /**\n     * Armazenar os registros de utilização da energia.\n     */\n    public static final class EnergyUseLogEntry implements BaseColumns {\n        //Definir o nome  da tabela no banco de dados\n        public static final String TABLE_NAME = \"energyUserLog\";\n\n        //Duração em segundos entre esse log e o log anterior.\n        public static final String COLUMN_DURATION = \"duration\";\n        //Tensão média na Duração do log.\n        public static final String COLUMN_VOLTAGE = \"voltage\";\n        //Watts média da fase 1 na Duração do log.\n        public static final String COLUMN_WATTS_1 = \"watts1\";\n        //Watts média da fase 2 na Duração do log.\n        public static final String COLUMN_WATTS_2 = \"watts2\";\n        //Watts média da fase 3 na Duração do log.\n        public static final String COLUMN_WATTS_3 = \"watts3\";\n        //Watts média das fases 1,2 e 3 na Duração do log.\n        public static final String COLUMN_WATTS_TOTAL = \"watts_total\";\n\n        /*Campos calculado por Watts Horas: */\n        //Recuperar o período de disponibilidade de logs:\n        public static final String[] COLUMNS_CALC_PERIOD = new String[]{\n                String.format(\"MIN(%s)\", _ID),\n                String.format(\"MAX(%s)\", _ID)\n        };\n        //Índices referente a lista de campos COLUMNS_CALC_PERIOD, favor sempre utilizar\n        //esses Índices para acessar as colunas no cursor.\n        public static final byte INDEX_COLUMNS_CALC_PERIOD_BEGIN = 0;\n        public static final byte INDEX_COLUMNS_CALC_PERIOD_END = 1;\n\n        public static final String[] COLUMNS_CALC_TOTAL = new String[]{\n                String.format(\"SUM(%s)\", COLUMN_DURATION),\n                String.format(\"SUM((%s * %s) / 3600.00)\", COLUMN_WATTS_TOTAL, COLUMN_DURATION ),\n                String.format(\"MAX(%s)\", COLUMN_WATTS_TOTAL),\n                //Recuperar o custo por KWH:\n                String.format(\"(SELECT AVG(%s) FROM %s WHERE %s.%s BETWEEN %s AND %s)\", EnergyUseBillEntry.COLUMN_KWH_COST, EnergyUseBillEntry.TABLE_NAME, EnergyUseLogEntry.TABLE_NAME, EnergyUseLogEntry._ID, EnergyUseBillEntry.COLUMN_FROM, EnergyUseBillEntry.COLUMN_TO),\n        };\n\n        //Índices referente a lista de campos COLUMNS_CALC, favor sempre utilizar\n        //esses Índices para acessar as colunas no cursor.\n        public static final byte INDEX_COLUMN_CALC_DURATION_SUN = 0;\n        public static final byte INDEX_COLUMN_CALC_WH_TOTAL_SUN = 1;\n        public static final byte INDEX_COLUMN_CALC_WATTS_MAX = 2;\n        public static final byte INDEX_COLUMN_CALC_KWH_COST = 3;\n        //Somente disponível no {@link OhaEnergyUseDaysCursor}\n        public static final byte INDEX_COLUMN_CALC_DATE = 4;\n\n        /**\n         * Recuperar o SQL para criar a tabela energyUserLog no banco de dados.\n         */\n        public static String getSQLCreate(){\n            return String.format(\"CREATE TABLE %s ( %s LONG PRIMARY KEY, %s REAL, %s REAL, %s REAL, %s REAL, %s REAL, %s REAL)\",\n                    TABLE_NAME,\n                    _ID,\n                    COLUMN_DURATION,\n                    COLUMN_VOLTAGE,\n                    COLUMN_WATTS_1,\n                    COLUMN_WATTS_2,\n                    COLUMN_WATTS_3,\n                    COLUMN_WATTS_TOTAL);\n        }\n\n        /**\n         * Analisar e validar um registro de utilização de energia\n         */\n        public static ContentValues parse(Date dateTime, double duration, double voltage, double watts1, double watts2, double watts3){\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(_ID, dateTime.getTime());\n            contentValues.put(COLUMN_DURATION, duration );\n            contentValues.put(COLUMN_VOLTAGE, voltage );\n            contentValues.put(COLUMN_WATTS_1, watts1 );\n            contentValues.put(COLUMN_WATTS_2, watts2 );\n            contentValues.put(COLUMN_WATTS_3, watts3 );\n            contentValues.put(COLUMN_WATTS_TOTAL, watts1 + watts2 + watts3 );\n            return contentValues;\n        }\n\n        public enum FilterWatts{\n            NONE,\n            PHASE1,\n            PHASE2,\n            PHASE3,\n            TOTAL;\n\n            public String getFieldName(){\n                switch (this){\n                    case PHASE1: return EnergyUseLogEntry.COLUMN_WATTS_1;\n                    case PHASE2: return EnergyUseLogEntry.COLUMN_WATTS_2;\n                    case PHASE3: return EnergyUseLogEntry.COLUMN_WATTS_3;\n                    case TOTAL: return EnergyUseLogEntry.COLUMN_WATTS_TOTAL;\n                    default:return EnergyUseLogEntry.COLUMN_WATTS_TOTAL;\n                }\n            }\n        }\n    }\n\n    /**\n     * Armazenar a conta de utilização da energia.\n     */\n    public static final class EnergyUseBillEntry implements BaseColumns {\n        //Definir o nome  da tabela no banco de dados:\n        public static final String TABLE_NAME = \"energyUserBill\";\n\n        /*Definir os nomes dos campos na tabela:*/\n        public static final String COLUMN_FROM = \"period_from\";\n        public static final String COLUMN_TO = \"period_to\";\n        public static final String COLUMN_KWH_COST = \"kwh_cost\";\n        public static final String[] COLUMN_ALL = new String[]{\n                _ID,\n                COLUMN_FROM,\n                COLUMN_TO,\n                COLUMN_KWH_COST,\n        };\n\n        //Índices referente a lista de campos COLUMN_ALL, favor sempre utilizar\n        //esses Índices para acessar as colunas no cursor.\n        public static final byte INDEX_COLUMN_ID = 0;\n        public static final byte INDEX_COLUMN_FROM = 1;\n        public static final byte INDEX_COLUMN_TO = 2;\n        public static final byte INDEX_COLUMN_KWH_COST = 3;\n        //Somente disponível no {@link OhaEnergyUseBillCursor}\n        public static final byte INDEX_COLUMN_CALC_DURATION_SUN = 4;\n        public static final byte INDEX_COLUMN_CALC_WH_TOTAL_SUN = 5;\n        public static final byte INDEX_COLUMN_CALC_WATTS_MAX = 6;\n\n        /**\n         * Recuperar o SQL para criar a tabela energyUserBill no banco de dados.\n         */\n        public static String getSQLCreate(){\n            return String.format(\"CREATE TABLE %s ( %s INTEGER PRIMARY KEY autoincrement, %s LONG, %s LONG, %s REAL)\",\n                    TABLE_NAME,\n                    _ID,\n                    COLUMN_FROM,\n                    COLUMN_TO,\n                    COLUMN_KWH_COST\n            );\n        }\n\n        /**\n         * Analisar e validar um conta de utilização de energia\n         */\n        public static ContentValues parse(Date from, Date to, double kwhCost) {\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(COLUMN_FROM, OhaHelper.getDateBegin(from).getTime());\n            contentValues.put(COLUMN_TO, OhaHelper.getDateEnd(to, false).getTime());\n            contentValues.put(COLUMN_KWH_COST, kwhCost);\n            return contentValues;\n        }\n\n    }\n}\nAndroid/appSupervisory/src/main/java/br/com/brolam/oha/supervisory/ui/helpers/OhaBackupHelper.java\npublic class OhaBackupHelper {\n    public static final String BACKUP_ACTIVATED = \"backup_activated\";\n    public static final String BACKUP_FREQUENCY = \"backup_frequency\";\n    public static final String BACKUP_LAST_DATE_TIME = \"backup_last_date_time\";\n    public static final String BACKUP_RESTORE_FILE_PATH = \"backup_restore_file_path\";\n\n    SharedPreferences preferences;\n    public OhaBackupHelper(SharedPreferences preferences ) {\n        this.preferences = preferences;\n    }\n\n    public OhaBackupHelper(Context context ) {\n        this.preferences = PreferenceManager.getDefaultSharedPreferences(context);\n    }\n\n    public boolean isActivated() {\n        return preferences.getBoolean(BACKUP_ACTIVATED, true);\n    }\n\n    public String getFrequency() {\n        return preferences.getString(BACKUP_FREQUENCY, \"12\");\n    }\n\n    public long getLastDateTime() {\n        Long nextDateTime = preferences.getLong(BACKUP_LAST_DATE_TIME, 0);\n        if ( nextDateTime == 0 ){\n            setLastDateTime();\n            return getLastDateTime();\n        }\n        return nextDateTime;\n    }\n\n    public boolean isBackupTime() {\n        if (isActivated() == false) return false;\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(new Date(getLastDateTime()));\n        calendar.add(Calendar.HOUR, Integer.parseInt(getFrequency()));\n        return calendar.getTime().before(new Date());\n    }\n\n    public boolean isRestoreRequest(){\n        return getBackupRestoreFilePath() != null;\n    }\n\n    public String getBackupRestoreFilePath() {\n        return preferences.getString(BACKUP_RESTORE_FILE_PATH, null);\n    }\n\n    public void setActivated(boolean activated) {\n        SharedPreferences.Editor editor = preferences.edit();\n        editor.putBoolean(BACKUP_ACTIVATED, activated);\n        editor.commit();\n    }\n\n    public void setLastDateTime() {\n        Date date = new Date();\n        SharedPreferences.Editor editor = preferences.edit();\n        editor.putLong(BACKUP_LAST_DATE_TIME, date.getTime());\n        editor.commit();\n    }\n\n    public void setBackupTime(){\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.HOUR, Integer.parseInt(getFrequency()) * -1);\n        SharedPreferences.Editor editor = preferences.edit();\n        editor.putLong(BACKUP_LAST_DATE_TIME, calendar.getTime().getTime());\n        editor.commit();\n\n    }\n\n    public void setBackupRestoreFilePath(String backupRestoreFilePath){\n        SharedPreferences.Editor editor = preferences.edit();\n        editor.putString(BACKUP_RESTORE_FILE_PATH, backupRestoreFilePath);\n        editor.commit();\n    }\n\n    public void clearBackupRestoreFilePath(){\n        setBackupRestoreFilePath(null);\n    }\n\n}\nAndroid/appSupervisory/src/main/java/br/com/brolam/oha/supervisory/data/OhaEnergyUseContract.java\npublic class OhaEnergyUseContract {\n\n    /*Definir a URL base de acesso:*/\n    public static final String CONTENT_AUTHORITY = \"br.com.brolam.oha.supervisory.energy.use\";\n    public static final Uri BASE_CONTENT_URI = Uri.parse(\"content://\" + CONTENT_AUTHORITY);\n\n    /*Definir o caminho por recurso:*/\n    public static final String PATH_LOG = \"log\";\n    public static final String PATH_DAYS = \"days\";\n    //Parêmetro para informar a data final para consultar a utilização de energia por dia:\n    public static final String PATH_DAYS_PARAM_END_DATE = \"endDate\";\n    public static final String PATH_BILL = \"bill\";\n\n    /*Definir as URLs:*/\n    public static final Uri CONTENT_URI_LOG = BASE_CONTENT_URI.buildUpon()\n            .appendPath(PATH_LOG)\n            .build();\n\n    public static final Uri CONTENT_URI_DAYS = BASE_CONTENT_URI.buildUpon()\n            .appendPath(PATH_DAYS)\n            .build();\n\n    /**\n     * Recupear a URI para consultar a utilização de energia por dia {@link br.com.brolam.oha.supervisory.data.cursors.OhaEnergyUseDaysCursor}\n     * @param endDate informar a data final para limitar o curosr até a data informada.\n     */\n    public static Uri getUriDays(Date endDate){\n       return CONTENT_URI_DAYS.buildUpon().appendQueryParameter(PATH_DAYS_PARAM_END_DATE, Long.toString(endDate.getTime())).build();\n    }\n\n    public static final Uri CONTENT_URI_BILL = BASE_CONTENT_URI.buildUpon()\n            .appendPath(PATH_BILL)\n            .build();\n\n    /**\n     * Recuperar a Uri de uma conta de energia por ID para ser utilizada nas operações de Consulta,\n     * alteração e exclusão.\n     * @param id informar uma ID válido.\n     * @return Uri com o parâmetro _id\n     */\n    public static Uri getUriBillById(int id){\n        return CONTENT_URI_BILL.buildUpon().appendQueryParameter(BaseColumns._ID, String.valueOf(id)).build();\n    }\n\n    /**\n     * Armazenar os registros de utilização da energia.\n     */\n    public static final class EnergyUseLogEntry implements BaseColumns {\n        //Definir o nome  da tabela no banco de dados\n        public static final String TABLE_NAME = \"energyUserLog\";\n\n        //Duração em segundos entre esse log e o log anterior.\n        public static final String COLUMN_DURATION = \"duration\";\n        //Tensão média na Duração do log.\n        public static final String COLUMN_VOLTAGE = \"voltage\";\n        //Watts média da fase 1 na Duração do log.\n        public static final String COLUMN_WATTS_1 = \"watts1\";\n        //Watts média da fase 2 na Duração do log.\n        public static final String COLUMN_WATTS_2 = \"watts2\";\n        //Watts média da fase 3 na Duração do log.\n        public static final String COLUMN_WATTS_3 = \"watts3\";\n        //Watts média das fases 1,2 e 3 na Duração do log.\n        public static final String COLUMN_WATTS_TOTAL = \"watts_total\";\n\n        /*Campos calculado por Watts Horas: */\n        //Recuperar o período de disponibilidade de logs:\n        public static final String[] COLUMNS_CALC_PERIOD = new String[]{\n                String.format(\"MIN(%s)\", _ID),\n                String.format(\"MAX(%s)\", _ID)\n        };\n        //Índices referente a lista de campos COLUMNS_CALC_PERIOD, favor sempre utilizar\n        //esses Índices para acessar as colunas no cursor.\n        public static final byte INDEX_COLUMNS_CALC_PERIOD_BEGIN = 0;\n        public static final byte INDEX_COLUMNS_CALC_PERIOD_END = 1;\n\n        public static final String[] COLUMNS_CALC_TOTAL = new String[]{\n                String.format(\"SUM(%s)\", COLUMN_DURATION),\n                String.format(\"SUM((%s * %s) / 3600.00)\", COLUMN_WATTS_TOTAL, COLUMN_DURATION ),\n                String.format(\"MAX(%s)\", COLUMN_WATTS_TOTAL),\n                //Recuperar o custo por KWH:\n                String.format(\"(SELECT AVG(%s) FROM %s WHERE %s.%s BETWEEN %s AND %s)\", EnergyUseBillEntry.COLUMN_KWH_COST, EnergyUseBillEntry.TABLE_NAME, EnergyUseLogEntry.TABLE_NAME, EnergyUseLogEntry._ID, EnergyUseBillEntry.COLUMN_FROM, EnergyUseBillEntry.COLUMN_TO),\n        };\n\n        //Índices referente a lista de campos COLUMNS_CALC, favor sempre utilizar\n        //esses Índices para acessar as colunas no cursor.\n        public static final byte INDEX_COLUMN_CALC_DURATION_SUN = 0;\n        public static final byte INDEX_COLUMN_CALC_WH_TOTAL_SUN = 1;\n        public static final byte INDEX_COLUMN_CALC_WATTS_MAX = 2;\n        public static final byte INDEX_COLUMN_CALC_KWH_COST = 3;\n        //Somente disponível no {@link OhaEnergyUseDaysCursor}\n        public static final byte INDEX_COLUMN_CALC_DATE = 4;\n\n        /**\n         * Recuperar o SQL para criar a tabela energyUserLog no banco de dados.\n         */\n        public static String getSQLCreate(){\n            return String.format(\"CREATE TABLE %s ( %s LONG PRIMARY KEY, %s REAL, %s REAL, %s REAL, %s REAL, %s REAL, %s REAL)\",\n                    TABLE_NAME,\n                    _ID,\n                    COLUMN_DURATION,\n                    COLUMN_VOLTAGE,\n                    COLUMN_WATTS_1,\n                    COLUMN_WATTS_2,\n                    COLUMN_WATTS_3,\n                    COLUMN_WATTS_TOTAL);\n        }\n\n        /**\n         * Analisar e validar um registro de utilização de energia\n         */\n        public static ContentValues parse(Date dateTime, double duration, double voltage, double watts1, double watts2, double watts3){\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(_ID, dateTime.getTime());\n            contentValues.put(COLUMN_DURATION, duration );\n            contentValues.put(COLUMN_VOLTAGE, voltage );\n            contentValues.put(COLUMN_WATTS_1, watts1 );\n            contentValues.put(COLUMN_WATTS_2, watts2 );\n            contentValues.put(COLUMN_WATTS_3, watts3 );\n            contentValues.put(COLUMN_WATTS_TOTAL, watts1 + watts2 + watts3 );\n            return contentValues;\n        }\n\n        public enum FilterWatts{\n            NONE,\n            PHASE1,\n            PHASE2,\n            PHASE3,\n            TOTAL;\n\n            public String getFieldName(){\n                switch (this){\n                    case PHASE1: return EnergyUseLogEntry.COLUMN_WATTS_1;\n                    case PHASE2: return EnergyUseLogEntry.COLUMN_WATTS_2;\n                    case PHASE3: return EnergyUseLogEntry.COLUMN_WATTS_3;\n                    case TOTAL: return EnergyUseLogEntry.COLUMN_WATTS_TOTAL;\n                    default:return EnergyUseLogEntry.COLUMN_WATTS_TOTAL;\n                }\n            }\n        }\n    }\n\n    /**\n     * Armazenar a conta de utilização da energia.\n     */\n    public static final class EnergyUseBillEntry implements BaseColumns {\n        //Definir o nome  da tabela no banco de dados:\n        public static final String TABLE_NAME = \"energyUserBill\";\n\n        /*Definir os nomes dos campos na tabela:*/\n        public static final String COLUMN_FROM = \"period_from\";\n        public static final String COLUMN_TO = \"period_to\";\n        public static final String COLUMN_KWH_COST = \"kwh_cost\";\n        public static final String[] COLUMN_ALL = new String[]{\n                _ID,\n                COLUMN_FROM,\n                COLUMN_TO,\n                COLUMN_KWH_COST,\n        };\n\n        //Índices referente a lista de campos COLUMN_ALL, favor sempre utilizar\n        //esses Índices para acessar as colunas no cursor.\n        public static final byte INDEX_COLUMN_ID = 0;\n        public static final byte INDEX_COLUMN_FROM = 1;\n        public static final byte INDEX_COLUMN_TO = 2;\n        public static final byte INDEX_COLUMN_KWH_COST = 3;\n        //Somente disponível no {@link OhaEnergyUseBillCursor}\n        public static final byte INDEX_COLUMN_CALC_DURATION_SUN = 4;\n        public static final byte INDEX_COLUMN_CALC_WH_TOTAL_SUN = 5;\n        public static final byte INDEX_COLUMN_CALC_WATTS_MAX = 6;\n\n        /**\n         * Recuperar o SQL para criar a tabela energyUserBill no banco de dados.\n         */\n        public static String getSQLCreate(){\n            return String.format(\"CREATE TABLE %s ( %s INTEGER PRIMARY KEY autoincrement, %s LONG, %s LONG, %s REAL)\",\n                    TABLE_NAME,\n                    _ID,\n                    COLUMN_FROM,\n                    COLUMN_TO,\n                    COLUMN_KWH_COST\n            );\n        }\n\n        /**\n         * Analisar e validar um conta de utilização de energia\n         */\n        public static ContentValues parse(Date from, Date to, double kwhCost) {\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(COLUMN_FROM, OhaHelper.getDateBegin(from).getTime());\n            contentValues.put(COLUMN_TO, OhaHelper.getDateEnd(to, false).getTime());\n            contentValues.put(COLUMN_KWH_COST, kwhCost);\n            return contentValues;\n        }\n\n    }\n}\nAndroid/appSupervisory/src/main/java/br/com/brolam/oha/supervisory/ui/adapters/holders/OhaMainHolder.java\npublic abstract class OhaMainHolder extends RecyclerView.ViewHolder {\n\n    public OhaMainHolder(View itemView) {\n        super(itemView);\n    }\n\n    public interface IOhaMainHolder {\n        Context getContext();\n        void onEnergyUseDaySelect(long beginDate, double kwhCost, int menuItemId);\n        void onEnergyUseBillSelect(int id, long fromDate, long toDate, double kwhCost, int menuItemId);\n    }\n\n    public void bindView(final Cursor cursor, final OhaMainHolder.IOhaMainHolder iOhaMainHolder) {\n\n    }\n\n\n}\nAndroid/appSupervisory/src/main/java/br/com/brolam/oha/supervisory/OhaBroadcast.java\npublic class OhaBroadcast extends BroadcastReceiver {\n    //Evento para acionar a sincronização dos logs de utilização de energia.\n    public static final String START_SYNC_ENERGY_USE = \"br.com.brolam.oha.supervisory.broadcast.START_SYNC_ENERGY_USE\";\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        switch (intent.getAction()) {\n            case START_SYNC_ENERGY_USE:\n                OhaSyncService.start(context);\n                return;\n            case Intent.ACTION_BOOT_COMPLETED:\n                OhaSyncService.start(context);\n                return;\n            case ConnectivityManager.CONNECTIVITY_ACTION:\n                OhaSyncService.start(context);\n                return;\n\n        }\n    }\n\n    /**\n     * Registrar o agendamento para acionar o serviço de sincronização dos logs\n     * de utilização de energia.\n     * @param context informar um contexto válido.\n     */\n    public static void registerSyncAlarm(Context context) {\n        //Realizar um verificação se o PendingIntent está ativo a cada 5 segundos.\n        int INTERVAL_IMPORT = 5000;\n        Intent intent = new Intent(context, OhaBroadcast.class);\n        intent.setAction(START_SYNC_ENERGY_USE);\n        //Utilizar o parâmetro PendingIntent.FLAG_UPDATE_CURRENT para manter somente um\n        //PendingIntent ativo e evitar o acionamento da sincronização mais de uma vez.\n        PendingIntent sender = PendingIntent.getBroadcast(context, 1, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n        //Agendar o acionamento.\n        AlarmManager alarmManager = (AlarmManager) context\n                .getSystemService(Context.ALARM_SERVICE);\n        alarmManager.setRepeating(\n                AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                INTERVAL_IMPORT,\n                INTERVAL_IMPORT,\n                sender);\n    }\n}\nAndroid/appSupervisory/src/main/java/br/com/brolam/oha/supervisory/ui/fragments/OhaRestoreDatabaseFragment.java\npublic class OhaRestoreDatabaseFragment extends DialogFragment implements   Toolbar.OnMenuItemClickListener, AdapterView.OnItemClickListener {\n    public static String TAG = OhaRestoreDatabaseFragment.class.getName();\n\n    public interface IOhaRestoreDatabaseFragment{\n        void onRequestRestoreDatabase(File backup);\n    }\n\n    ListView listView;\n    Toolbar toolbar;\n    //Lista de backups disponível.\n    File[] backups;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        this.backups = OhaSQLHelper.getBackups();\n    }\n\n    public static OhaRestoreDatabaseFragment getInstance(Activity activity){\n        OhaRestoreDatabaseFragment ohaEnergyUseBillFragment = (OhaRestoreDatabaseFragment) activity.getFragmentManager().findFragmentByTag(TAG);\n        return (ohaEnergyUseBillFragment == null)? new OhaRestoreDatabaseFragment(): ohaEnergyUseBillFragment;\n    }\n\n    @Override\n    public void onViewStateRestored(Bundle savedInstanceState) {\n        super.onViewStateRestored(savedInstanceState);\n        //Somente exibir o botão de restore quando um backup for selecionado:\n        parseActionRestoreDatabase();\n\n    }\n\n    public static void show(Activity activity) {\n        OhaRestoreDatabaseFragment ohaEnergyUseBillFragment = getInstance(activity);\n        Bundle bundle = new Bundle();\n        ohaEnergyUseBillFragment.setArguments(bundle);\n        ohaEnergyUseBillFragment.show(activity.getFragmentManager(), TAG);\n    }\n\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.fragment_restore_database, container, false);\n        this.listView = (ListView) view.findViewById(R.id.listView);\n        int amountBackups = this.backups != null?this.backups.length:0;\n        String[] backupsName = new String[amountBackups];\n        for(int index = 0; index <amountBackups; index++ ){\n            backupsName[index] = this.backups[index].getName();\n        }\n        this.listView.setAdapter(new ArrayAdapter<String>(this.getActivity(),  android.R.layout.simple_list_item_checked, backupsName));\n        this.toolbar = (Toolbar) view.findViewById(R.id.toolbar);\n        this.toolbar.inflateMenu(R.menu.fragment_restore_database);\n        this.toolbar.setOnMenuItemClickListener(this);\n        this.listView.setOnItemClickListener(this);\n        //Somente exibir o botão de restore quando um backup for selecionado:\n        parseActionRestoreDatabase();\n\n        return view;\n    }\n\n    @Override\n    public boolean onMenuItemClick(MenuItem item) {\n        switch (item.getItemId()){\n            case R.id.action_restore_database:\n                IOhaRestoreDatabaseFragment iOhaRestoreDatabaseFragment = getActivity() instanceof IOhaRestoreDatabaseFragment? (IOhaRestoreDatabaseFragment) getActivity(): null;\n                if ( iOhaRestoreDatabaseFragment != null){\n                    iOhaRestoreDatabaseFragment.onRequestRestoreDatabase(this.backups[this.listView.getCheckedItemPosition()]);\n                }\n                this.dismiss();\n                return false;\n            case R.id.action_cancel:\n                this.dismiss();\n                return false;\n        }\n        return false;\n    }\n\n    @Override\n    public void onItemClick(AdapterView<?> adapterView, View view, int position, long id) {\n        //Somente exibir o botão de restore quando um backup for selecionado:\n        parseActionRestoreDatabase();\n    }\n\n    /**\n     * Somente exibir o botão de restore quando um backup for selecionado\n     */\n    private void parseActionRestoreDatabase() {\n        MenuItem menuItem = this.toolbar.getMenu().findItem(R.id.action_restore_database);\n        if (menuItem != null)\n            menuItem.setVisible(this.listView.getCheckedItemPosition() >= 0);\n    }\n\n}\nAndroid/library/src/main/java/br/com/brolam/library/helpers/OhaHelper.java\npublic class OhaHelper {\n    static String defaultCurrencySymbol;\n    /**\n     * Obter um texto com o Ano, Mês e Dia.\n     *\n     * @param date informar uma data válida.\n     * @return texto no formato yyyyMMdd\n     */\n    public static String getStrDate(Date date) {\n        return new SimpleDateFormat(\"yyMMdd\", Locale.ENGLISH).format(date);\n    }\n\n    /**\n     * Obter um texto com a Hora, Minuto e Segundo.\n     *\n     * @param date informar uma data válida.\n     * @return texto no formato HHmmss.\n     */\n    public static String getStrTime(Date date) {\n        return new SimpleDateFormat(\"HHmmss\", Locale.ENGLISH).format(date);\n    }\n\n    /**\n     * Obter um texto com a hora.\n     *\n     * @param date informar uma data válida.\n     * @return texto no formato HH\n     */\n    public static String getStrHour(Date date) {\n        return new SimpleDateFormat(\"HH\", Locale.ENGLISH).format(date);\n    }\n\n    /**\n     * Obter um texto com a Hora e Minuto\n     *\n     * @param date informar uma data válida.\n     * @return texto no formato HHmm.\n     */\n    public static String getStrTimeHHmm(Date date) {\n        return new SimpleDateFormat(\"HHmm\", Locale.ENGLISH).format(date);\n    }\n\n    /**\n     * Obter um Calendar conforme os paramentos abaixo:\n     *\n     * @param strDate  informar texto com data no formato YYYYMMDD\n     * @param strTime  informar texto com a Hora, Minuto e segundo no formato HHmmss\n     * @param duration informar a duração em milisegundos que será adicionada a data.\n     * @return um Calendar com o resultado da soma da strDate + strTime +  duration\n     * @throws ParseException\n     */\n    public static Calendar getCalendar(String strDate, String strTime, long duration) throws ParseException {\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyMMddHHmmss\");\n        Date date = simpleDateFormat.parse(strDate + strTime);\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        while (duration > 0) {\n            calendar.add(Calendar.MILLISECOND, (duration > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) duration));\n            duration = duration - Integer.MAX_VALUE;\n        }\n        return calendar;\n    }\n\n    /**\n     * Obter um Calendar conforme os paramentos abaixo:\n     *\n     * @param strDate informar texto com data no formato YYYYMMDD\n     * @return um Calendar conforme o paramento strDate\n     * @throws ParseException\n     */\n    public static Calendar getCalendar(String strDate) throws ParseException {\n        return getCalendar(strDate, \"000000\", 0);\n    }\n\n    /**\n     * Obter um Calendar conforme os paramentos abaixo:\n     *\n     * @param strDate informar texto com data no formato YYYYMMDD\n     * @param strHour informar texto com a hora no formato HH\n     * @return um Calendar conforme os paramentos  strDate e strHour\n     * @throws ParseException\n     */\n    public static Calendar getCalendar(String strDate, String strHour) throws ParseException {\n        return getCalendar(strDate, strHour + \"0000\", 0);\n    }\n\n    /**\n     * Recuperar a quantidade de dias entre duas datas.\n     * @param begin informar a data de inicio\n     * @param end   informar a data final\n     * @return quantidade de dias entre as duas datas.\n     */\n    public static long getAmountDays(long begin, long end) {\n        double days = ((end / (24.00 * 60.00 * 60.00 * 1000.00))\n                - (begin / (24.00 * 60.00 * 60.00 * 1000.00)));\n        return days > 0 && days < 1 ? 1 : Math.round(days);\n\n    }\n\n    /**\n     * Recuperar uma data com hora, minutos e segundos zerados.\n     * @param date informar uma data válida.\n     */\n    public static Date getDateBegin(Date date) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        return calendar.getTime();\n    }\n\n    /**\n     * Recuperar uma data com a hora final do dia.\n     * @param date       informar uma data válida.\n     * @param untilToday informar se a hora final não deve ultrapassar a hora atual.\n     * @return uma data com a hora igual a 23:59:59.\n     */\n    public static Date getDateEnd(Date date, boolean untilToday) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.set(Calendar.HOUR_OF_DAY, 23);\n        calendar.set(Calendar.MINUTE, 59);\n        calendar.set(Calendar.SECOND, 59);\n        calendar.set(Calendar.MILLISECOND, 999);\n        Date dateToday = new Date();\n        if (untilToday && (dateToday.before(calendar.getTime()))) {\n            calendar.setTime(dateToday);\n        }\n        return calendar.getTime();\n    }\n\n    /**\n     * Recuperar uma hora com minutos e segundos zerados.\n     * @param date informar uma data válida.\n     */\n    public static Date getBeginHour(Date date) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        return calendar.getTime();\n\n    }\n\n    /**\n     * Recuperar hora com minutos e segundos iguais a 59.\n     * @param date informar uma data válida.\n     */\n    public static Date getEndHour(Date date, boolean untilToday) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.set(Calendar.MINUTE, 59);\n        calendar.set(Calendar.SECOND, 59);\n        calendar.set(Calendar.MILLISECOND, 999);\n\n        Date dateToday = new Date();\n        if (untilToday && (dateToday.before(calendar.getTime()))) {\n            calendar.setTime(dateToday);\n        }\n        return calendar.getTime();\n\n    }\n\n    /**\n     * Recuperar uma data formatada conforme o parâmetro date Format.\n     *\n     * @param date       informar uma data válida\n     * @param dateFormat informar um formato conforme o Date and Time Patterns: https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html\n     * @return texto com a data formatada.\n     */\n    public static String formatDate(Date date, String dateFormat) {\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat);\n        return simpleDateFormat.format(date);\n    }\n\n    /**\n     * Recuperar uma data formatada conforme o parâmetro date Format.\n     *\n     * @param longDateTime informar uma data válida\n     * @param dateFormat   informar um formato conforme o Date and Time Patterns{@link SimpleDateFormat} :\n     *                     https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html\n     * @return texto com a data formatada.\n     */\n    public static String formatDate(long longDateTime, String dateFormat) {\n        Date date = new Date(longDateTime);\n        return formatDate(date, dateFormat);\n    }\n\n    //Recuperar o símbolo monentário padrão para o usuário.\n    public static String getDefaultCurrencySymbol(){\n        if ( defaultCurrencySymbol == null){\n            defaultCurrencySymbol = Currency.getInstance(Locale.getDefault()).getSymbol();\n        }\n        return defaultCurrencySymbol;\n    }\n\n    /**\n     * Recuperar um número formatado conforme o decimalFormat.\n     * @param number  informar um número válido\n     * @param pattern informar o formato conforme o {@link DecimalFormat}:\n     *                https://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html\n     * @return texto com o número formatado.\n     */\n    public static String formatNumber(double number, String pattern) {\n        return new DecimalFormat(pattern).format(number);\n    }\n\n    /**\n     * Recuperar um número formatado conforme o decimalFormat mais o símbolo monentário\n     * @param number  informar um número válido\n     * @param pattern informar o formato conforme o {@link DecimalFormat}:\n     *                https://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html\n     * @return texto com o número formatado.\n     */\n    public static String formatMoney(double number, String pattern) {\n        return String.format(\"%s%s\", getDefaultCurrencySymbol(), new DecimalFormat(pattern).format(number));\n    }\n\n    /**\n     * Recuperar um texto para ser editado em um EditText.\n     * @param value informar um valor numérico válido.\n     * @return texto formatado para ser editado em um EditText.\n     */\n    public static String getEditable(double value) {\n        return value == 0.00 ? \"\" : String.valueOf(value);\n    }\n\n    /**\n     * Recuperar o percentual da precisão do tempo de leitura sobre 24 horas.\n     * @param context  informar um contexto válido.\n     * @param duration duração em segundos da leitura.\n     * @param untilNow informar se o tempo total não deve ser maior do que a hora atual.\n     * @return texto formatado informando o percentual da precisão, EX: Accuracy 99.99%\n     */\n    public static String formatAccuracyDay(Context context, double duration, boolean untilNow) {\n        Date date = new Date();\n        long beginDate = getDateBegin(date).getTime();\n        long endDate = getDateEnd(date, false).getTime();\n        return formatAccuracy(context, beginDate, endDate, duration, untilNow);\n    }\n    \n    /**\n     * Recuperar o percentual da precisão do tempo de leitura sobre um período.\n     * @param context  informar um contexto válido.\n     * @param beginDateTime informar a data e hora inicial.\n     * @param endDateTime informar a data e hora final.\n     * @param duration duração em segundos da leitura.\n     * @param untilNow informar se a data e hora final deve ser menor do que a data e hora atual.\n     * @return texto formatado informando o percentual da precisão, EX: Accuracy 99.99%\n     */\n    public static String formatAccuracy(Context context, long beginDateTime, long endDateTime, double duration, boolean untilNow) {\n        long now = new Date().getTime();\n        //Se o paramentro untilNow for verdadeiro, considerar o hora final a hora atual:\n        double periodInMillis = (((untilNow && now < endDateTime) ? now : endDateTime) - beginDateTime) / 1000.00;\n        double accuracy = duration > 0 ? (duration / periodInMillis) * 100 : 0.00;\n        return String.format(context.getString(R.string.format_accuracy_day), formatNumber(accuracy, \"#0.00\"));\n    }\n\n    /**\n     * Recuperar um texto com a primeira letra maiúscula.\n     * @param string informar uma string válida.\n     */\n    public static String formatCamelCase(String string) {\n        return string.length() > 0 ? string.replaceFirst(\n                Character.toString(string.charAt(0)),\n                Character.toString(Character.toUpperCase(string.charAt(0)))\n        ) : string;\n    }\n\n    /**\n     * Converter um texto em um valor numérico\n     * @param string texto com um valor numérico válido.\n     * @param ifError valor que deve ser retornado se o texto for inválido.\n     * @return um valor numérico válido.\n     */\n    public static double convertToDouble(String string, double ifError){\n        if ((string  == null ) || string.isEmpty() ) return ifError;\n        try {\n            return Double.parseDouble(string);\n        } catch (Exception e){\n            e.printStackTrace();\n            return ifError;\n        }\n    }\n\n    /**\n     * Converter milisegundos em horas.\n     *\n     * @param millis informar os milisegundos.\n     * @return total em horas.\n     */\n    public static double convertMillisToHours(double millis) {\n        return millis > 0.00 ? millis / DateUtils.HOUR_IN_MILLIS : 0.00;\n    }\n\n    /**\n     * Converter segundos em horas\n     */\n    public static double convertSecondsToHours(double seconds) {\n        return seconds > 0.00 ? (seconds * 1000.00) / DateUtils.HOUR_IN_MILLIS : 0.00;\n    }\n\n    /**\n     * Converter segundos em dias\n     */\n    public static double convertSecondsToDays(double seconds) {\n        return seconds > 0.00 ? (seconds * 1000.00) / DateUtils.DAY_IN_MILLIS : 0.00;\n    }\n\n    /**\n     * Converter o total de Wh em Kwh.\n     *\n     * @param totalWh total de Wh.\n     * @return Kwh\n     */\n    public static double convertWhToKWH(double totalWh) {\n        return totalWh > 0 ? totalWh / 1000.00 : 0.00;\n    }\n\n\n    /**\n     * Informar o processo de compactação ou descompactação de um arquivo.\n     */\n    public interface IZipFile {\n        void progress(long size, long sizeProcessed);\n    }\n\n    /**\n     * Compactar uma arquivo.\n     * @param inputFile informar o arquivo a ser compactado.\n     * @param zipFilePath informar o nome e caminho zip.\n     * @param iZipFile se necessário, informar uma {@link IZipFile}.\n     * @throws IOException\n     */\n    public static void zipFile(File inputFile, String zipFilePath, IZipFile iZipFile) throws IOException {\n        FileOutputStream fileOutputStream = new FileOutputStream(zipFilePath);\n        ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream);\n        ZipEntry zipEntry = new ZipEntry(inputFile.getName());\n        zipOutputStream.putNextEntry(zipEntry);\n        FileInputStream fileInputStream = new FileInputStream(inputFile);\n        FileChannel fileChannel = fileInputStream.getChannel();\n        FileLock fileLock = fileChannel.tryLock(0L, Long.MAX_VALUE, /*shared*/true);\n        long sizeToZip = fileInputStream.available();\n        long sizeCompacted = 0;\n        try {\n            byte[] buf = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fileInputStream.read(buf)) > 0) {\n                sizeCompacted += bytesRead;\n                zipOutputStream.write(buf, 0, bytesRead);\n                if (iZipFile != null) iZipFile.progress(sizeToZip, sizeCompacted);\n            }\n        } finally {\n            fileLock.release();\n            zipOutputStream.closeEntry();\n            zipOutputStream.close();\n            fileOutputStream.close();\n        }\n    }\n\n    /**\n     * Descompactar um arquivo zip.\n     * @param zipFilePath informar o caminho completo do arquivo zip.\n     * @param fileName se necessário informar o nome do arquivo que deve ser descompactado ou nulo para todos.\n     * @param directory informar o diretório onde os arquivo serão descompactados.\n     * @param iZipFile se necessário, informar uma {@link IZipFile}.\n     * @throws IOException\n     */\n    public static void unZipFile(String zipFilePath, String fileName, String directory, IZipFile iZipFile) throws IOException {\n        FileInputStream streamZipFile = new FileInputStream(zipFilePath);\n        ZipInputStream streamZips = new ZipInputStream(streamZipFile);\n        try {\n            ZipEntry zipEntry = null;\n            while ((zipEntry = streamZips.getNextEntry()) != null) {\n                long sizeZip = zipEntry.getSize();\n                long sizeProcessed = 0;\n                if (!zipEntry.isDirectory()) {\n                    if ( (fileName == null) || zipEntry.getName().contains(fileName)) {\n                        byte[] buf = new byte[1024];\n                        int bytesRead;\n                        String fileOutputName = String.format(\"%s/%s\", directory, zipEntry.getName());\n                        FileOutputStream fileOutputStream = new FileOutputStream(fileOutputName);\n                        while ((bytesRead = streamZips.read(buf)) > 0) {\n                            sizeProcessed += bytesRead;\n                            fileOutputStream.write(buf, 0, bytesRead);\n                            if (iZipFile != null) iZipFile.progress(sizeZip, sizeProcessed);\n                        }\n                    }\n                }\n\n            }\n        } finally {\n            if (streamZipFile != null) streamZipFile.close();\n            if (streamZips != null) streamZips.close();\n        }\n    }\n}\nAndroid/appSupervisory/src/main/java/br/com/brolam/oha/supervisory/ui/fragments/OhaEnergyUseBillFragment.java\n */public class OhaEnergyUseBillFragment extends DialogFragment implements View.OnClickListener, Toolbar.OnMenuItemClickListener, DatePicker.OnDateChangedListener {\n    public static String TAG = OhaEnergyUseBillFragment.class.getName();\n\n    public interface IOhaEnergyUseBillFragment{\n        void onSaveEnergyUseBill(int id, long fromDate, long toDate, double kwhCost );\n    }\n\n    public static final String PARAM_ID = \"param_id\";\n    private int id;\n    public static final String PARAM_FROM_DATE = \"param_from_date\";\n    private long fromDate;\n    public static final String PARAM_TO_DATE = \"param_to_date\";\n    private long toDate;\n    public static final String PARAM_KWH_COST = \"param_kwh_cost\";\n    double kwhCost;\n    int amountDays;\n\n    RadioButton radioButtonFromDate;\n    RadioButton radioButtonToDate;\n    EditText editKwhCost;\n    DatePicker datePicker;\n    Toolbar toolbar;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Bundle bundle = savedInstanceState != null ? savedInstanceState : this.getArguments();\n        this.id = this.getArguments().getInt(PARAM_ID);\n        this.fromDate = bundle.getLong(PARAM_FROM_DATE);\n        this.toDate = bundle.getLong(PARAM_TO_DATE);\n        this.kwhCost = bundle.getDouble(PARAM_KWH_COST);\n        this.amountDays = (int) OhaHelper.getAmountDays(this.fromDate, this.toDate);\n    }\n\n    @Override\n    public void onViewStateRestored(Bundle savedInstanceState) {\n        super.onViewStateRestored(savedInstanceState);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putLong(PARAM_FROM_DATE, this.fromDate);\n        outState.putLong(PARAM_TO_DATE, this.toDate);\n        outState.putDouble(PARAM_KWH_COST, this.kwhCost);\n    }\n\n    public static OhaEnergyUseBillFragment getInstance(Activity activity){\n        OhaEnergyUseBillFragment ohaEnergyUseBillFragment = (OhaEnergyUseBillFragment) activity.getFragmentManager().findFragmentByTag(TAG);\n        return (ohaEnergyUseBillFragment == null)? new OhaEnergyUseBillFragment(): ohaEnergyUseBillFragment;\n    }\n\n    public static void add(Activity activity) {\n        OhaEnergyUseBillFragment ohaEnergyUseBillFragment = getInstance(activity);\n        Calendar calendar = Calendar.getInstance();\n        double defaultKwhCost = 0.0;\n        int amountDays = 30;\n        //Recuperar a ultima conta para definir os valores padrão da nova conta de energia:\n        Cursor cursor = activity.getContentResolver().query(CONTENT_URI_BILL, null, null, null, String.format(\"%s DESC\", EnergyUseBillEntry.COLUMN_TO));\n        try {\n            if (cursor.moveToFirst()) {\n                calendar.setTime(new Date(cursor.getLong(EnergyUseBillEntry.INDEX_COLUMN_TO)));\n                calendar.add(Calendar.DATE, 1);\n                defaultKwhCost = cursor.getDouble(EnergyUseBillEntry.INDEX_COLUMN_KWH_COST);\n                amountDays = (int) OhaHelper.getAmountDays(cursor.getLong(EnergyUseBillEntry.INDEX_COLUMN_FROM), cursor.getLong(EnergyUseBillEntry.INDEX_COLUMN_TO));\n            }\n        } finally {\n            cursor.close();\n        }\n\n        Bundle bundle = new Bundle();\n        bundle.putInt(PARAM_ID, -1);\n        bundle.putLong(PARAM_FROM_DATE, OhaHelper.getDateBegin(calendar.getTime()).getTime());\n        calendar.add(Calendar.DATE, amountDays);\n        bundle.putLong(PARAM_TO_DATE, OhaHelper.getDateBegin(calendar.getTime()).getTime());\n        bundle.putDouble(PARAM_KWH_COST, defaultKwhCost);\n        ohaEnergyUseBillFragment.setArguments(bundle);\n        ohaEnergyUseBillFragment.show(activity.getFragmentManager(), TAG);\n    }\n\n\n    public static void update(Activity activity, int id, long fromDate, long toDate, double kwhCost ) {\n        OhaEnergyUseBillFragment ohaEnergyUseBillFragment = getInstance(activity);\n        Bundle bundle = new Bundle();\n        bundle.putInt(PARAM_ID, id);\n        bundle.putLong(PARAM_FROM_DATE, fromDate);\n        bundle.putLong(PARAM_TO_DATE, toDate);\n        bundle.putDouble(PARAM_KWH_COST, kwhCost);\n        ohaEnergyUseBillFragment.setArguments(bundle);\n        ohaEnergyUseBillFragment.show(activity.getFragmentManager(), TAG);\n    }\n\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {\n\n        View view = inflater.inflate(R.layout.fragment_energy_use_bill, container, false);\n        this.radioButtonFromDate = (RadioButton) view.findViewById(R.id.radioButtonFromDate);\n        this.radioButtonToDate = (RadioButton) view.findViewById(R.id.radioButtonToDate);\n        this.editKwhCost = (EditText) view.findViewById(R.id.editKwhCost);\n        this.datePicker = (DatePicker) view.findViewById(R.id.datePicker);\n        this.toolbar = (Toolbar) view.findViewById(R.id.toolbar);\n        this.setTextRadioButtonDate(radioButtonFromDate, this.fromDate);\n        this.setTextRadioButtonDate(radioButtonToDate, this.toDate);\n        this.setCalendarView();\n        this.editKwhCost.setText(OhaHelper.getEditable(this.kwhCost));\n        this.radioButtonFromDate.setOnClickListener(this);\n        this.radioButtonToDate.setOnClickListener(this);\n        this.datePicker.setOnClickListener(this);\n        //Remover o date_picker_header do datePicker se o mesmo existir\n        View viewDayDatePicker = datePicker.findViewById(Resources.getSystem().getIdentifier(\"date_picker_header\", \"id\", \"android\"));\n        if (viewDayDatePicker != null) {\n            viewDayDatePicker.setVisibility(View.GONE);\n        }\n        this.toolbar.inflateMenu(R.menu.fragment_energy_use_bill);\n        this.toolbar.setOnMenuItemClickListener(this);\n        return view;\n    }\n\n    @Override\n    public boolean onMenuItemClick(MenuItem item) {\n        switch (item.getItemId()){\n            case R.id.action_save:\n                this.kwhCost = OhaHelper.convertToDouble(this.editKwhCost.getText().toString(), 0.0);\n                //Acionar o evento onSaveEnergyUseBill se a atividade suportar a interface IOhaEnergyUseBillFragment\n                IOhaEnergyUseBillFragment iOhaEnergyUseBillFragment  = getActivity() instanceof IOhaEnergyUseBillFragment? (IOhaEnergyUseBillFragment)getActivity(): null;\n                if ( iOhaEnergyUseBillFragment != null ){\n                    iOhaEnergyUseBillFragment.onSaveEnergyUseBill(this.id, this.fromDate, this.toDate, this.kwhCost);\n                }\n                this.dismiss();\n                return false;\n\n            case R.id.action_cancel:\n                this.dismiss();\n                return false;\n        }\n        return false;\n    }\n\n    private void setCalendarView() {\n        long selectedDate;\n        if (radioButtonFromDate.isChecked()) {\n            selectedDate = this.fromDate;\n        } else if ( radioButtonToDate.isChecked()){\n            selectedDate = this.toDate;\n        } else {\n            selectedDate = this.fromDate;\n            this.radioButtonFromDate.setChecked(true);\n            this.radioButtonToDate.setChecked(false);\n        }\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(new Date(selectedDate));\n        datePicker.init(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), this);\n    }\n\n    private void setTextRadioButtonDate(RadioButton radioButtonDate, long date) {\n        radioButtonDate.setText(OhaHelper.formatDate(date, \"dd, MMM yyyy\"));\n    }\n\n    @Override\n    public void onResume() {\n        //Definir o tamanho da janela conforme percentual definido no dimens.xml:\n        Window window = getDialog().getWindow();\n        Point size = new Point();\n        Display display = window.getWindowManager().getDefaultDisplay();\n        display.getSize(size);\n        double percentWidth = getResources().getInteger(R.integer.energy_use_bill_fragment_width_percent) / 100.00;\n        double percentHeight = getResources().getInteger(R.integer.energy_use_bill_fragment_height_percent) / 100.00;\n        window.setLayout((int) (size.x * percentWidth), (int) (size.y * percentHeight));\n        window.setGravity(Gravity.CENTER);\n        super.onResume();\n    }\n\n    @Override\n    public void onClick(View view) {\n        switch (view.getId()) {\n            case R.id.radioButtonFromDate:\n                this.radioButtonToDate.setChecked(false);\n                setCalendarView();\n                return;\n            case R.id.radioButtonToDate:\n                this.radioButtonFromDate.setChecked(false);\n                setCalendarView();\n                return;\n        }\n    }\n\n    @Override\n    public void onDateChanged(DatePicker datePicker, int year, int month, int dayOfMonth) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.set(year, month, dayOfMonth);\n        if (this.radioButtonFromDate.isChecked()) {\n            this.fromDate = calendar.getTime().getTime();\n            //Corrigir o toDate\n            if (this.fromDate > this.toDate) {\n                calendar.add(Calendar.DATE, this.amountDays);\n                this.toDate = calendar.getTime().getTime();\n            }\n\n        } else if (radioButtonToDate.isChecked()) {\n            //Corrigir o fromDate\n            this.toDate = calendar.getTime().getTime();\n            if (this.fromDate > this.toDate) {\n                calendar.add(Calendar.DATE, this.amountDays * -1);\n                this.fromDate = calendar.getTime().getTime();\n            }\n        }\n        setTextRadioButtonDate(radioButtonFromDate, this.fromDate);\n        setTextRadioButtonDate(radioButtonToDate, this.toDate);\n        this.amountDays = (int) OhaHelper.getAmountDays(this.fromDate, this.toDate);\n    }\n\n}\n", "answers": ["        OhaRestoreDatabaseFragment.IOhaRestoreDatabaseFragment, SwipeRefreshLayout.OnRefreshListener {"], "length": 5219, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "03c058a20159fdf73dc14630c73f180f26da1a71f65876a8"}
{"input": "package com.github.duncpro.jackal.cdc;\nimport com.google.common.base.Preconditions;\nimport com.github.duncpro.jackal.FinalKey;\nimport com.github.duncpro.jackal.FinalKeyBuilder;\nimport com.github.duncpro.jackal.Outline;\nimport com.github.duncpro.jackal.OutlineBuilder;\nimport com.github.duncpro.jackal.cdc.transform.MalformedTransformerException;\nimport com.github.duncpro.jackal.cdc.transform.Transformer;\nimport com.github.duncpro.jackal.cdc.transform.TransformerException;\nimport com.github.duncpro.jackal.cdc.transform.Transformers;\nimport com.github.duncpro.jackal.cdc.transform.TransformersBuilder;\nimport com.github.duncpro.jackal.constraint.CatchAllConstraintException;\nimport com.github.duncpro.jackal.constraint.Constraint;\nimport com.github.duncpro.jackal.constraint.IncompatibleConstraintException;\nimport com.github.duncpro.jackal.constraint.InversionPolicy;\nimport com.github.duncpro.jackal.path.Path;\nimport com.github.duncpro.jackal.path.Paths;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\n\n\n\n\n/**\n * Creates {@link Outline}s from CDCs.\n */\npublic class CdcOutliner {\n  private static final Logger log = LoggerFactory.getLogger(CdcOutliner.class);\n\n  // The section to outline\n  private final Class<?> section;\n\n  // The path that leads to the section we are outlining\n  private final Path basePath;\n\n  /**\n   * Constructs a CdcOutliner. The only parameter validation done is ensuring that the provided\n   * section is indeed an interface.\n   * \n   * @param section the CDC section\n   * @param basePath the path to the section\n   */\n  private CdcOutliner(Class<?> section, Path basePath) {\n    Preconditions.checkArgument(section.isInterface(),\n        section.getCanonicalName() + \" is not\" + \" an interface.\");\n\n    this.section = section;\n    this.basePath = basePath;\n  }\n\n  /**\n   * Writes the contents of the CDC section to an {@link OutlineBuilder}. This method performs no\n   * parameter validation.\n   * \n   * @param outline the {@link OutlineBuilder} to write to.\n   * @param inheritedTransformers the {@link Transformers} this section inherits\n   * @return true if the CDC section was successfully outlined, false if an error occurred\n   */\n  private boolean write(OutlineBuilder outline, Transformers inheritedTransformers) {\n    // Did an error occur while creating an outline\n    boolean error = false;\n\n    TransformersBuilder builder = new TransformersBuilder(); // Does not include defaults\n\n    // If we are inheriting any transformers\n    if (inheritedTransformers != null) {\n      builder.addAll(inheritedTransformers);\n      log.debug(\"All keys beyond {} will inherit these transformers: {}.\",\n          basePath == null ? \"[root]\" : basePath, inheritedTransformers.toSet());\n    }\n\n    if (section.isAnnotationPresent(ExtraTransformers.class)) {\n      for (Class<? extends Transformer> extraTransformer : section\n          .getAnnotation(ExtraTransformers.class).value()) {\n        try {\n          builder.add(extraTransformer);\n          log.debug(\"Extra transformer ({}) declared for keys following {} (refer to {}).\",\n              extraTransformer.getCanonicalName(), basePath, section.getCanonicalName());\n        } catch (MalformedTransformerException ex) {\n          error = true;\n          log.error(\"Can not use extra transformer ({}): {}\", extraTransformer.getCanonicalName(),\n              ex.getMessage());\n        }\n      }\n    }\n\n    Transformers transformers = builder.build();\n\n    methodLoop: for (Method method : section.getDeclaredMethods()) {\n      String identifier = getIdentifier(method);\n\n      // Skip method if it is static\n      if (Modifier.isStatic(method.getModifiers())) {\n        log.debug(\"Skipping {}, it is static.\", identifier);\n        continue;\n      }\n\n      // The return type of the method\n      Class<?> type = method.getReturnType();\n\n      // The full path to the final key\n      Path path;\n      if (basePath == null) {\n        path = Path.of(method.getName());\n      } else {\n        path = Paths.combine(basePath, Path.of(method.getName()));\n      }\n\n      // Ensure the method does not return void.\n      if (type == Void.TYPE) {\n        log.error(\"{} was not assigned a type. Please redefine {}.\", path, identifier);\n        error = true;\n        continue;\n      }\n\n      if (type.isAnnotationPresent(Section.class)) {\n        // Not dire but still worth reporting\n        if (method.isAnnotationPresent(Comment.class)) {\n          log.warn(\"Comments are not supported on non-final keys. Please redefine\" + \" {}.\",\n              identifier);\n        }\n\n        if (method.isAnnotationPresent(Require.class)) {\n          log.warn(\"Requirements not supported on sections. Please redefine {}.\", identifier);\n        }\n        if (method.isAnnotationPresent(Default.class)) {\n          log.warn(\"Default values not supported on sections. Please redefine {}.\", identifier);\n        }\n\n        CdcOutliner outliner = new CdcOutliner(type, path);\n        if (!outliner.write(outline, transformers)) {\n          error = true;\n        }\n        continue;\n      }\n\n      // The final key builder\n      FinalKeyBuilder key = new FinalKeyBuilder(path, type);\n\n      // If constraints are imposed on the value, add them to the final key\n      if (method.isAnnotationPresent(Require.class)) {", "context": "src/main/java/com/github/duncpro/jackal/cdc/transform/TransformersBuilder.java\n@NotThreadSafe\npublic class TransformersBuilder {\n  private static final Logger log = LoggerFactory.getLogger(TransformersBuilder.class);\n\n  /**\n   * The default Transformers included with Jackal.\n   */\n  private static final Transformers defaults;\n\n  static {\n    defaults = new TransformersBuilder().add(IntegerTransformer.class).add(StringTransformer.class)\n        .add(BooleanTransformer.class).add(FloatTransformer.class).add(DoubleTransformer.class)\n        .add(ShortTransformer.class).add(CharTransformer.class).add(LongTransformer.class)\n        .add(EnumTransformer.class).build();\n  }\n\n  private final Map<Class<?>, Transformer> transformerMap = Maps.newHashMap();\n\n  /**\n   * Constructs a TransformersBuilder.\n   * \n   * @param includeDefaults will this auto-include Jackal's default transformers?\n   */\n  public TransformersBuilder(boolean includeDefaults) {\n    if (includeDefaults) {\n      addAll(defaults);\n    }\n  }\n\n  /**\n   * Constructs an empty TransofrmersBuilder.\n   */\n  public TransformersBuilder() {\n    this(false);\n  }\n\n  /**\n   * Instantiates the provided transformer class and adds it. If an old transformer is bound to any\n   * of the same types as the new transformer the old transformer will be unbound for those types\n   * and the new transformer will be bound.\n   * \n   * @param transformerClass the transformer class to add.\n   * @return this builder\n   * @throws MalformedTransformerException if the transformer is malformed.\n   */\n  public TransformersBuilder add(Class<? extends Transformer> transformerClass) {\n    Preconditions.checkNotNull(transformerClass, \"Transformer cannot be null\");\n\n    // throws MalformedTransformerException\n    Transformer transformer = Transformer.instantiate(transformerClass);\n\n    for (Class<?> type : transformerClass.getAnnotation(Produces.class).value()) {\n      if (transformerMap.containsKey(type)) {\n        log.warn(\"{} already has a transformer ({}), it is being replaced with {}.\",\n            type.getCanonicalName(), transformerMap.get(type), transformerClass);\n      }\n\n      transformerMap.put(type, transformer);\n    }\n\n    return this;\n  }\n\n  /**\n   * Adds each {@link Transformer} from the provided Transformers to this TransformersBuilder.\n   * \n   * @param transformers the transformers to copy\n   * @return this builders\n   */\n  public TransformersBuilder addAll(Transformers transformers) {\n    for (Map.Entry<Class<?>, Transformer> entry : transformers.getTransformerMap().entrySet()) {\n      Class<?> type = entry.getKey();\n      Transformer transformer = entry.getValue();\n\n      if (transformerMap.containsKey(type)) {\n        log.warn(\"{} already has a transformer ({}), it is being replaced with {}.\",\n            type.getCanonicalName(), transformerMap.get(type),\n            transformer.getClass().getCanonicalName());\n      }\n      transformerMap.put(type, transformer);\n    }\n\n    return this;\n  }\n\n  /**\n   * Builds a {@link Transformers} with the attributes of this {@link TransformersBuilder}.\n   * \n   * @return a new transformers\n   */\n  public Transformers build() {\n    return new Transformers(ImmutableMap.copyOf(transformerMap));\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/OutlineBuilder.java\n@NotThreadSafe\npublic class OutlineBuilder {\n  private final Map<Path, FinalKey> finalKeys = Maps.newHashMap();\n\n  /**\n   * Adds a {@link FinalKey} to the outline. If a final key already exists at the proposed keys\n   * path, then the older key is erased and replaced with the newer key.\n   * \n   * @param finalKey the key to add\n   * @return this builder\n   */\n  public OutlineBuilder addFinalKey(FinalKey finalKey) {\n    Preconditions.checkNotNull(finalKey, \"Final key cannot be null\");\n\n    // The key's path\n    Path path = finalKey.getPath();\n\n    // No duplicate paths\n    if (finalKeys.containsKey(path)) {\n      finalKeys.remove(path);\n    }\n\n    finalKeys.put(path, finalKey);\n\n    return this;\n  }\n\n  /**\n   * Builds a new {@link Outline} with this builders attributes.\n   * \n   * @return the new outline\n   */\n  public Outline build() {\n    // Create an immutable copy of the list\n    ImmutableList<FinalKey> immutableCopy = ImmutableList.copyOf(finalKeys.values());\n\n    return new Outline(immutableCopy);\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/constraint/InversionPolicy.java\npublic enum InversionPolicy {\n  INVERTED,\n  NOT_INVERTED;\n  \n  /**\n   * Returns the opposite. So if INVERTED then NOT_INVERTED, or if NOT_INVERTED \n   * then INVERTED.\n   */\n  public InversionPolicy opposite() {\n    switch (this) {\n      case INVERTED:\n        return NOT_INVERTED;\n      case NOT_INVERTED:\n        return INVERTED;\n      default:\n        throw new AssertionError();\n    }\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/cdc/transform/TransformerException.java\n@SuppressWarnings(\"serial\")\npublic class TransformerException extends Exception {\n  public TransformerException(String message) {\n    super(message);\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/constraint/Constraint.java\npublic interface Constraint {\n  /**\n   * Determines whether or not the provided object passes the constraint. Null will be passed to\n   * this method.\n   */\n  Result check(Object value);\n\n  /**\n   * Instantiates a {@link Constraint}.\n   * \n   * @param clazz the constraint class\n   * @return the instantiated constraint\n   * @throws MalformedConstraintException if the constraint class is malformed.\n   */\n  static Constraint instantiate(Class<? extends Constraint> clazz) {\n    Preconditions.checkNotNull(clazz, \"Class cannot be null\");\n\n    // Ensure that the constraint class has declared checkable types\n    Set<Class<?>> acceptedTypes = Sets.newHashSet();\n    if (clazz.isAnnotationPresent(AppliesTo.class)) {\n      for (Class<?> accepted : clazz.getAnnotation(AppliesTo.class).value()) {\n        acceptedTypes.add(accepted);\n      }\n    }\n    if (acceptedTypes.isEmpty()) {\n      throw new MalformedConstraintException(\n          clazz.getCanonicalName() + \" has not declared\" + \" any checkable types.\");\n    }\n\n    // Ensure that the constraint class has the no-args constructor\n    Constructor<? extends Constraint> constructor;\n    try {\n      constructor = clazz.getConstructor();\n    } catch (NoSuchMethodException ex) {\n      throw new MalformedConstraintException(\n          \"No no-args constructor found for \" + clazz.getCanonicalName(), ex);\n    }\n\n    // Instantiate the constraint class\n    Constraint constraint;\n    try {\n      constraint = constructor.newInstance();\n    } catch (InstantiationException ex) {\n      throw new MalformedConstraintException(\"Cannot instantiate \" + clazz.getCanonicalName(), ex);\n    } catch (IllegalAccessException ex) {\n      throw new MalformedConstraintException(clazz.getCanonicalName()\n          + \"'s constructor is not accessible (It probably needs to be public).\", ex);\n    } catch (InvocationTargetException ex) {\n      throw new MalformedConstraintException(\n          clazz.getCanonicalName() + \" threw an exception while undergoing construction.\", ex);\n    }\n\n    return constraint;\n  }\n\n  /**\n   * Checks whether or not a specific {@link Constraint} can be applied to a specific type.\n   * \n   * @param constraint the constraint to check\n   * @param type the type to check\n   * @return true if the type applies to the constraint\n   */\n  static boolean isCompatible(Constraint constraint, Class<?> type) {\n    Preconditions.checkNotNull(constraint, \" Constraint cannot be null\");\n    Preconditions.checkNotNull(type, \"Type cannot be null.\");\n\n    boolean compatible = false;\n    for (Class<?> accepted : constraint.getClass().getAnnotation(AppliesTo.class).value()) {\n      if (accepted.isAssignableFrom(type)) {\n        compatible = true;\n      }\n    }\n\n    return compatible;\n  }\n\n  /**\n   * {@link #isCompatible(Constraint, Class)} except throws an\n   * {@link IncompatibleConstraintException} instead of returning false.\n   */\n  static void ensureCompatibility(Constraint constraint, Class<?> type) {\n    if (!isCompatible(constraint, type)) {\n      throw new IncompatibleConstraintException(constraint.getClass().getCanonicalName()\n          + \" is not compatible with \" + type.getCanonicalName());\n    }\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/path/Paths.java\npublic class Paths {\n  /**\n   * Returns the last part in the given path.\n   */\n  public static Part finalPart(Path path) {\n    return path.partAt(path.length() - 1);\n  }\n\n  /**\n   * Creates a new {@link Path} with some or all of the keys from the provided path. This method\n   * always shortens from the back of the provided path. The new length cannot be greater than the\n   * old length although it can be equal to. If it is equal to then there will be no change.\n   * \n   * @param path the path to clone\n   * @param newLength the length of the new path\n   * @return a new path with the specified length\n   */\n  public static Path shorten(Path path, int newLength) {\n    Preconditions.checkNotNull(path);\n\n    // A path can never be < 1\n    if (newLength < 1) {\n      throw new IllegalArgumentException(\"New length must be greater than 0\");\n    }\n\n    // The path must be less than or equal to the length of the old path\n    if (newLength > path.length()) {\n      throw new IllegalArgumentException(\n          \"New length must be equal to or less than the length of the existing\" + \" path.\");\n    }\n\n    // A new list to store represent the new path we are creating\n    List<Part> parts = new ArrayList<>(newLength);\n\n    // Populate the new path\n    for (int i = 0; i < newLength; i++) {\n      parts.add(path.partAt(i));\n    }\n\n    return new HierarchicalPath(parts);\n  }\n\n  /**\n   * Combines the first path with the last path, leading with the first path.\n   * \n   * @param first the path to lead with\n   * @param rest the path to end with\n   * @return the combined paths\n   */\n  public static Path combine(Path first, Path... rest) {\n    Preconditions.checkNotNull(first);\n    Preconditions.checkNotNull(rest);\n\n    // Verify no gaps will exist in the new path\n    List<Path> paths = Arrays.asList(rest);\n    if (paths.contains(null)) {\n      throw new IllegalArgumentException(\"Cannot append null\");\n    }\n\n    // The parts in our new combined path\n    List<Part> parts = new ArrayList<>();\n\n    // Add first\n    parts.addAll(first.toPartList());\n\n    // Add rest\n    for (Path path : rest) {\n      parts.addAll(path.toPartList());\n    }\n\n    return new HierarchicalPath(parts);\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/FinalKeyBuilder.java\n@NotThreadSafe\npublic class FinalKeyBuilder {\n  private Object defaultValue;\n\n  private DefaultValueType defaultValueType;\n\n  private final Path path;\n\n  private final ConstraintsBuilder constraintsBuilder;\n\n  private Constraints constraints;\n\n  private final Class<?> type;\n\n  private String comment;\n\n  /**\n   * Constructs a FinalKey builder.\n   *\n   * <p>\n   * If the value type is primitive, the NotNull constraint will automatically be assigned.\n   * </p>\n   * \n   * @param path the path of the final key\n   * @param type the type of value that this key holds\n   */\n  public FinalKeyBuilder(Path path, Class<?> type) {\n    Preconditions.checkNotNull(path, \"Path cannot be null.\");\n    Preconditions.checkNotNull(type, \"Type cannot be null.\");\n\n    this.path = path;\n    this.constraintsBuilder = new ConstraintsBuilder(type);\n    this.type = type;\n\n    // All primitives are automatically assigned the NotNull constraint\n    if (type.isPrimitive()) {\n      constraintsBuilder.add(Null.class, InversionPolicy.INVERTED);\n    }\n  }\n\n  /**\n   * Sets the comment for this final key. Null will clear any set comment. This method is optional,\n   * if never called the final key will be created with no comment.\n   * \n   * @param comment the comment to set or null for no comment\n   * @return this builder\n   */\n  public FinalKeyBuilder setComment(String comment) {\n    // No not-null precondition check. Null will clear the comment.\n\n    this.comment = comment;\n\n    return this;\n  }\n\n  /**\n   * Specifies a constraint that should be applied on this key's value. All constraints should be\n   * declared before BEFORE {@link #setDefaultValue(DefaultValueType, Object)} or\n   * {@link #setNoDefaultValue()} has been called.\n   * \n   * @param clazz the class of the constraint.\n   * @return this builder.\n   * @throws IllegalStateException if the default value for the key has already been set\n   * @throws IncompatibleConstraintException if the constraint cannot be applied to this keys type.\n   */\n  public FinalKeyBuilder withConstraint(Class<? extends Constraint> clazz, InversionPolicy invert) {\n    Preconditions.checkNotNull(clazz, \"Constraint class cannot be null.\");\n    Preconditions.checkNotNull(invert, \"Invert cannot be null.\");\n\n    if (constraints != null) {\n      throw new IllegalStateException(\"The default value has already been set. You must apply all\"\n          + \" constraints before setting the default value.\");\n    }\n\n    // Add the constraint\n    // ConstraintBuilder ignores duplicates so no need to check here.\n    // throws MalformedConstraintException, IncompatibleConstraintException\n    constraintsBuilder.add(clazz, invert);\n\n    return this;\n  }\n\n  /**\n   * Sets the default value for this final key. All constraints should be declared before this\n   * method is called. If the type is set to {@link DefaultValueType#NONE} then the value is\n   * ignored. Null is a valid default value.\n   * \n   * @param type the type of default value that this key has.\n   * @param value the default value for this key.\n   * @return this builder\n   * @throws InvalidDefaultValueException if the provided default value fails any constraints that\n   *           are applied to this key.\n   */\n  public FinalKeyBuilder setDefaultValue(DefaultValueType type, Object value) {\n    Preconditions.checkNotNull(type, \"Type cannot be null.\");\n\n    defaultValueType = type;\n    defaultValue = value;\n\n    // If the default value has been set already then there is no need to regenerate the\n    // constraints.\n    if (constraints == null) {\n      constraints = constraintsBuilder.build();\n    }\n\n    // If we are supplying a default value\n    if (type != DefaultValueType.NONE) {\n      // Ensure default value meets constraints\n      Result result = constraints.check(value);\n      if (result.getType() == ResultType.FAIL) {\n        throw new InvalidDefaultValueException(\"'\" + value + \"' failed to meet\"\n            + \" constraints, it cannot be a default value: \" + result.getMessage());\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Calls {@link #setDefaultValue(DefaultValueType, Object)} with a type of\n   * {@link DefaultValueType#NONE}.\n   * \n   * @return this builder.\n   */\n  public FinalKeyBuilder setNoDefaultValue() {\n    return setDefaultValue(DefaultValueType.NONE, null);\n  }\n\n  /**\n   * Builds the {@link FinalKey} object. Before building either\n   * {@link #setDefaultValue(DefaultValueType, Object)} or {@link #setNoDefaultValue()} must have\n   * been invoked.\n   * \n   * @return a new final key that has the this builders attributes\n   */\n  public FinalKey build() {\n    // The default value has not been set.\n    if (constraints == null) {\n      throw new IllegalStateException(\"A default value has not been set yet, cannot build.\");\n    }\n\n    return new FinalKey(defaultValue, defaultValueType, path, type, constraints, comment);\n  }\n\n  /**\n   * Thrown when the default value breaks a constraint.\n   */\n  @SuppressWarnings(\"serial\")\n  public class InvalidDefaultValueException extends RuntimeException {\n    InvalidDefaultValueException(String message) {\n      super(message);\n    }\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/constraint/CatchAllConstraintException.java\npublic class CatchAllConstraintException extends RuntimeException {\n  private static final long serialVersionUID = -2156983181303305767L;\n\n  public CatchAllConstraintException(String message) {\n    super(message);\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/cdc/transform/Transformers.java\n@Immutable\npublic class Transformers {\n  private final Map<Class<?>, Transformer> transformerMap;\n\n  /**\n   * Constructs a Transformers. Performs no parameter validation.\n   * \n   * @param transformerMap mapping of value type to transformer\n   */\n  Transformers(ImmutableMap<Class<?>, Transformer> transformerMap) {\n    this.transformerMap = transformerMap;\n  }\n\n  /**\n   * Constructs an object of the given type using the given String. If no {@link Transformer} is\n   * capable a {@link TransformerException} is thrown. Do not pass null.\n   * \n   * @param type the type of object to construct\n   * @param string the string to supply the transformer with\n   * @return the freshly constructed object\n   * @throws TransformerException if no transformer was capable of transforming the provided type or\n   *           the string was malformed.\n   */\n  public Object transform(Class<?> type, String string) throws TransformerException {\n    Preconditions.checkNotNull(type, \"Type must not be null\");\n    Preconditions.checkNotNull(string, \"String must not be null\");\n    \n    for (Class<?> transformable : transformerMap.keySet()) {\n      if (transformable.isAssignableFrom(type)) {\n        return transformerMap.get(transformable).transform(string, type);\n      }\n    }\n    \n    throw new TransformerException(\"No transformer for type: \" + type.getCanonicalName());\n  }\n\n  /**\n   * Returns an immutable set containing all the transformers in this collection.\n   */\n  public Set<Transformer> toSet() {\n    Set<Transformer> transformers = Sets.newIdentityHashSet();\n    transformers.addAll(transformerMap.values());\n    return ImmutableSet.copyOf(transformers);\n  }\n\n  /**\n   * Returns an immutable mapping of types to transformers.\n   */\n  Map<Class<?>, Transformer> getTransformerMap() {\n    return transformerMap; // Already immutable, refer to constructor\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/FinalKey.java\n@Immutable\npublic class FinalKey {\n  /**\n   * The default value that will be used when the provided value is non-existent or deemed invalid.\n   * If defaultValueType == NONE then this value is ignored.\n   */\n  private final Object defaultValue;\n\n  /**\n   * The type of default value.\n   */\n  private final DefaultValueType defaultValueType;\n\n  /**\n   * The path to this final key.\n   */\n  private final Path path;\n\n  /**\n   * The constraints applied to values set to this key. These constraints are also applied to the\n   * default value.\n   */\n  private final Constraints constraints;\n\n  /**\n   * The type of value that lives at this key.\n   */\n  private final Class<?> type;\n\n  /**\n   * Documentation explaining how changing this value with effect the application.\n   */\n  private final String comment;\n\n  /**\n   * Constructs a FinalKey. This method does no parameter checking.\n   * \n   * @param defaultValue the default value for this key\n   * @param defaultValueType the type of default value for this key\n   * @param path the path of this key\n   * @param type the type of value allowed at this key\n   * @param constraints the constraints applied to the value of this key\n   * @param comment the documentation comment explaining the purpose of this key,\n   */\n  FinalKey(Object defaultValue, DefaultValueType defaultValueType, Path path, Class<?> type,\n      Constraints constraints, String comment) {\n    this.defaultValue = defaultValue;\n    this.defaultValueType = defaultValueType;\n    this.path = path;\n    this.type = type;\n    this.constraints = constraints;\n    this.comment = comment;\n  }\n\n  /**\n   * Returns the default value. This might return null if the default value is null. This is the\n   * value that will be used when the provided value is non-existent or deemed invalid.\n   */\n  public Object getDefaultValue() {\n    return defaultValue;\n  }\n\n  /**\n   * Returns the default value type.\n   */\n  public DefaultValueType getDefaultValueType() {\n    return defaultValueType;\n  }\n\n  /**\n   * Returns the path to this final key.\n   */\n  public Path getPath() {\n    return path;\n  }\n\n  /**\n   * Returns the constraints applied to values set to this key.\n   */\n  public Constraints getConstraints() {\n    return constraints;\n  }\n\n  /**\n   * Returns the type of value that will live at this key.\n   */\n  public Class<?> getType() {\n    return type;\n  }\n\n  /**\n   * Returns documentation explaining how changing this value with effect the application. May be\n   * null if no documentation was provided.\n   */\n  public String getComment() {\n    return comment;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((comment == null) ? 0 : comment.hashCode());\n    result = prime * result + ((constraints == null) ? 0 : constraints.hashCode());\n    result = prime * result + ((defaultValue == null) ? 0 : defaultValue.hashCode());\n    result = prime * result + ((defaultValueType == null) ? 0 : defaultValueType.hashCode());\n    result = prime * result + ((path == null) ? 0 : path.hashCode());\n    result = prime * result + ((type == null) ? 0 : type.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass() != obj.getClass()) {\n      return false;\n    }\n    FinalKey other = (FinalKey) obj;\n    if (comment == null) {\n      if (other.comment != null) {\n        return false;\n      }\n    } else if (!comment.equals(other.comment)) {\n      return false;\n    }\n    if (constraints == null) {\n      if (other.constraints != null) {\n        return false;\n      }\n    } else if (!constraints.equals(other.constraints)) {\n      return false;\n    }\n    if (defaultValue == null) {\n      if (other.defaultValue != null) {\n        return false;\n      }\n    } else if (!defaultValue.equals(other.defaultValue)) {\n      return false;\n    }\n    if (defaultValueType != other.defaultValueType) {\n      return false;\n    }\n    if (path == null) {\n      if (other.path != null) {\n        return false;\n      }\n    } else if (!path.equals(other.path)) {\n      return false;\n    }\n    if (type == null) {\n      if (other.type != null) {\n        return false;\n      }\n    } else if (!type.equals(other.type)) {\n      return false;\n    }\n    return true;\n  }\n\n}\nsrc/main/java/com/github/duncpro/jackal/cdc/transform/MalformedTransformerException.java\npublic class MalformedTransformerException extends RuntimeException {\n  private static final long serialVersionUID = 64240346128316755L;\n\n  MalformedTransformerException(String message) {\n    super(message);\n  }\n\n  /**\n   * Constructs a MalformedTransformerException. Performs no parameter validation.\n   * \n   * @param message the exception's message\n   * @param cause the cause of the exception\n   */\n  MalformedTransformerException(String message, Throwable cause) {\n    super(message, cause);\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/constraint/IncompatibleConstraintException.java\npublic class IncompatibleConstraintException extends RuntimeException {\n  private static final long serialVersionUID = 617541059933332439L;\n\n  IncompatibleConstraintException(String message) {\n    super(message);\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/cdc/transform/Transformer.java\npublic interface Transformer {\n  /**\n   * Constructs an object using the provided String. Jackal will never pass null.\n   * Jackal will never pass a value that is of a type this transformer can not produce.\n   * \n   * @param type the type of class to transform.\n   * @throws TransformerException The string cannot be used to construct an object.\n   */\n  Object transform(String string, Class<?> type) throws TransformerException;\n\n  /**\n   * Instantiates a {@link Transformer}.\n   * \n   * @param clazz the transfortmer's class.\n   * @return the instantiated transformer\n   * @throws MalformedTransformerException if the transformer is malformed.\n   */\n  static Transformer instantiate(Class<? extends Transformer> clazz) {\n    Preconditions.checkNotNull(clazz, \"Class cannot be null.\");\n\n    if (!clazz.isAnnotationPresent(Produces.class)) {\n      throw new MalformedTransformerException(\n          clazz.getCanonicalName() + \" does not declare any producible types.\"\n              + \" (Transformers must have the Produces(Class<?>[]) annotation)\");\n    }\n\n    if (clazz.getAnnotation(Produces.class).value().length < 1) {\n      throw new MalformedTransformerException(\n          clazz.getCanonicalName() + \" does not declare any producible types.\"\n              + \" (Transformers must produce at least one type)\");\n    }\n\n    // Ensure that the transformer class has the no-args constructor\n    Constructor<? extends Transformer> constructor;\n    try {\n      constructor = clazz.getConstructor();\n    } catch (NoSuchMethodException ex) {\n      throw new MalformedTransformerException(\n          \"No no-args constructor found for \" + clazz.getCanonicalName(), ex);\n    }\n\n    // Instantiate the transformer class\n    Transformer transformer;\n    try {\n      transformer = constructor.newInstance();\n    } catch (InstantiationException ex) {\n      throw new MalformedTransformerException(\"Cannot instantiate \" + clazz.getCanonicalName(), ex);\n    } catch (IllegalAccessException ex) {\n      throw new MalformedTransformerException(clazz.getCanonicalName()\n          + \"'s constructor is not accessible (It probably needs to be public).\", ex);\n    } catch (InvocationTargetException ex) {\n      throw new MalformedTransformerException(\n          clazz.getCanonicalName() + \" threw an exception while undergoing construction.\", ex);\n    }\n\n    return transformer;\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/Outline.java\n@Immutable\npublic class Outline {\n  private static final Logger log = LoggerFactory.getLogger(Outline.class);\n\n  /**\n   * The final keys in the configuration.\n   */\n  private final List<FinalKey> finalKeys;\n\n  /**\n   * Constructs an Outline. Does no parameter validation.\n   *\n   * @param finalKeys the final keys in this outline\n   */\n  Outline(ImmutableList<FinalKey> finalKeys) {\n    // All preconditions are dealt with in OutlineBuilder\n    this.finalKeys = finalKeys;\n  }\n\n  /**\n   * Stores this outlines final keys that are contained in the provided {@link Contents} to the\n   * provided {@link Storage}. If the outline expects the existence of a key but the contents does\n   * not contain it, the key will just be skipped and not written to storage. If the contents\n   * contains any keys that are not outlined, they to will be ignored.\n   *\n   * @param contents the contents to store\n   * @param storage where to store\n   * @throws StorageException if the storage experiences an unrecoverable error.\n   */\n  public void storeContents(Contents contents, Storage storage) throws StorageException {\n    Preconditions.checkNotNull(contents, \"Contents cannot be null\");\n    Preconditions.checkNotNull(storage, \"Storage cannot be null\");\n\n    for (FinalKey finalKey : finalKeys) {\n      Path path = finalKey.getPath();\n\n      Optional<Optional<Object>> entry = contents.get(path);\n\n      if (entry.isPresent()) {\n        Object value = entry.get().orElse(null);\n        log.debug(\"Setting {} to {} in {}\", path, value, storage.getName());\n        storage.setValue(path, value, finalKey.getComment());\n      } else {\n        log.debug(\"{} was not found in contents.\", path);\n      }\n    }\n  }\n\n  /**\n   * Records all of the outlined keys that exist in the storage to a {@link Contents}. If the\n   * storage is missing keys or contains keys that are not outlined, those are skipped. If the\n   * storage reports that some values are malformed and cannot be properly retrieved those are\n   * skipped as well.\n   *\n   * @param storage the storage to retrieve from\n   * @return the contents\n   * @throws StorageException if the storage experiences an unrecoverable error.\n   */\n  public Contents captureContents(Storage storage) throws StorageException {\n    Preconditions.checkNotNull(storage, \"Contents cannot be null\");\n\n    log.debug(\"Capturing contents of {}.\", storage.getName());\n\n    Contents contents = new Contents();\n\n    for (FinalKey finalKey : finalKeys) {\n      Path path = finalKey.getPath();\n\n      log.debug(\"Querying {} for {}...\", storage.getName(), path);\n      try {\n        Optional<Optional<Object>> entryOpt = storage.getValue(path, finalKey.getType());\n        if (entryOpt.isPresent()) {\n          Object value = entryOpt.get().orElse(null);\n          log.debug(\"{} is set to {}\", path, value);\n\n          contents.set(path, value);\n        } else {\n          log.debug(\"{} does not exist in {}.\", path, storage.getName());\n        }\n      } catch (MalformedValueException ex) {\n        log.debug(\"Storage reported that {} is malformed. Not capturing it.\");\n      }\n    }\n\n    return contents;\n  }\n\n  /**\n   * Validates the provided contents, optionally amending it to the best of its ability. If the\n   * contents were completely amended then a positive validity is returned, otherwise if the\n   * contents were invalid, a negative validity is returned.\n   *\n   * @param contents the contents to validate\n   * @param amend weather or not to amend the contents\n   * @return the validity of post-amended contents or just the contents if amend was set to false.\n   */\n  public Validity validate(Contents contents, boolean amend) {\n    Map<FinalKey, String> unamendable = Maps.newHashMap();\n\n    for (FinalKey key : finalKeys) {\n      Path path = key.getPath();\n      DefaultValueType defaultValueType = key.getDefaultValueType();\n      Object defaultValue = key.getDefaultValue();\n      Constraints constraints = key.getConstraints();\n\n      Optional<Optional<Object>> entry = contents.get(path);\n\n      if (entry.isPresent()) {\n        Object value = entry.get().orElse(null);\n        Result constraintResult = constraints.check(value);\n        if (constraintResult.getType() == ResultType.FAIL) {\n          if (defaultValueType == DefaultValueType.NONE) {\n            log.debug(\"{} was deemed invalid ({}) and could not be amended because no\"\n                + \" default value was provided in the outline.\", path,\n                constraintResult.getMessage());\n            unamendable.put(key, constraintResult.getMessage());\n          } else {\n            if (amend) {\n              contents.set(path, defaultValue);\n            }\n          }\n        } else {\n          log.debug(\"{} was found in contents and deemed valid (value: {}).\", path, value);\n        }\n      } else {\n        // Entry was not even present in the config\n        if (defaultValueType == DefaultValueType.NONE) {\n          // No default value provided\n          log.debug(\n              \"{} was not found and has no default value to use.\",\n              path);\n          unamendable.put(key, \"No value provided.\");\n        } else {\n          if (amend) {\n            log.debug(\"Set {} to its default value of {} because no entry existed in contents.\",\n                path, defaultValue);\n            contents.set(path, defaultValue);\n          }\n        }\n      }\n    }\n\n    Set<FinalKey> placeholders = scanForPlaceholders(contents);\n\n    return new Validity(ImmutableMap.copyOf(unamendable), ImmutableSet.copyOf(placeholders));\n  }\n\n  /**\n   * Returns a list of all the placeholders that exist in the contents.\n   *\n   * @param contents the contents to scan\n   * @return a list of all the placeholders that exist or if none exist then an empty list.\n   */\n  private Set<FinalKey> scanForPlaceholders(Contents contents) {\n    Set<FinalKey> placeholders = Sets.newHashSet();\n\n    for (FinalKey key : finalKeys) {\n      Path path = key.getPath();\n      Optional<Optional<Object>> entry = contents.get(path);\n\n      if (entry.isPresent()) {\n        Object value = entry.get().orElse(null);\n\n        if (key.getDefaultValueType() == DefaultValueType.PLACEHOLDER) {\n          if (Objects.equals(value, key.getDefaultValue())) {\n            log.debug(\"Placeholder ({}) found at {}.\", value, path);\n            placeholders.add(key);\n          }\n        }\n      }\n    }\n\n    return placeholders;\n  }\n}\nsrc/main/java/com/github/duncpro/jackal/path/Path.java\npublic interface Path extends Iterable<Part> {\n  // The default delimiter used for separating individual parts in a path string.\n  String DEFAULT_DELIM = \".\";\n\n  /**\n   * Returns the Part at the specified index.\n   * \n   * @throws IndexOutOfBoundsException if the index does not exist\n   */\n  Part partAt(int index) throws IndexOutOfBoundsException;\n\n  /**\n   * Returns the amount of parts in the path.\n   */\n  int length();\n\n  List<Part> toPartList();\n\n  /**\n   * Rapidly create Paths using delimited-part notation.\n   *\n   * <p>\n   * Delimited-part notation refers to the representation of a path linearly in a String. Each part\n   * is separated from its child using a delimiter. For example \"a.b.c\" would be delimited-part\n   * notation for a path of \"a.b.c\". Of course the delimiter does not have to be a period, it can be\n   * any string you like.\n   * </p>\n   * \n   * @param string delimited-part notation\n   * @param delim the delimiter used to separate each Part in the path\n   */\n  static Path of(String string, String delim) {\n    // Ensure that the string and the delimiter are not null or empty\n    Preconditions.checkArgument(!Strings.isNullOrEmpty(string), \"String must not be null or empty\");\n    Preconditions.checkArgument(!Strings.isNullOrEmpty(delim),\n        \"Delimiter must not be null or empty\");\n\n    Preconditions.checkArgument(string.trim().equals(string),\n        \"String must not contain\" + \" any trailing or leading whitespace.\");\n\n    String[] split = string.split(Pattern.quote(delim));\n    if (split.length > 1) {\n      List<Part> parts = new ArrayList<>();\n      for (int i = 0; i < split.length; i++) {\n        parts.add(new Part(split[i]));\n      }\n      return new HierarchicalPath(parts);\n    } else {\n      return new Part(split[0]);\n    }\n  }\n\n  /**\n   * See {@link #of(String, String)}. Uses the default delimiter (which is a period, \".\")\n   */\n  static Path of(String string) {\n    return of(string, DEFAULT_DELIM);\n  }\n}\n", "answers": ["        for (Class<? extends Constraint> constraint : method.getAnnotation(Require.class).value()) {"], "length": 4522, "dataset": "repobench-p_e", "language": "java", "all_classes": null, "_id": "755c8af62ba1528c7a39909b198190d1910c3ff87da8cfb8"}
{"input": "import static es.uvigo.darwin.prottest.util.logging.ProtTestLogger.getDefaultLogger;\nimport static es.uvigo.darwin.prottest.util.logging.ProtTestLogger.infoln;\nimport java.awt.Font;\nimport java.io.PrintWriter;\nimport java.util.logging.Handler;\nimport java.util.logging.Level;\nimport org.jdesktop.application.Action;\nimport org.jdesktop.application.Application;\nimport org.jdesktop.application.ResourceMap;\nimport pal.alignment.Alignment;\nimport pal.misc.Identifier;\nimport pal.tree.Tree;\nimport es.uvigo.darwin.prottest.facade.TreeFacade;\nimport es.uvigo.darwin.prottest.model.Model;\nimport es.uvigo.darwin.prottest.selection.AIC;\nimport es.uvigo.darwin.prottest.selection.AICc;\nimport es.uvigo.darwin.prottest.selection.BIC;\nimport es.uvigo.darwin.prottest.selection.DT;\nimport es.uvigo.darwin.prottest.selection.InformationCriterion;\nimport es.uvigo.darwin.prottest.selection.LNL;\nimport es.uvigo.darwin.prottest.util.collection.ModelCollection;\nimport es.uvigo.darwin.prottest.util.collection.SingleModelCollection;\nimport es.uvigo.darwin.prottest.util.exception.ProtTestInternalException;\nimport es.uvigo.darwin.prottest.util.logging.ProtTestLogger;\nimport es.uvigo.darwin.prottest.util.printer.ProtTestPrinter;\nimport es.uvigo.darwin.xprottest.XProtTestView;\nimport es.uvigo.darwin.xprottest.util.TextAreaWriter;\n/*\nCopyright (C) 2009  Diego Darriba\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage es.uvigo.darwin.xprottest.analysis.consensus;\n\n\n\n\n\n/**\n * \n * @author diego\n */\npublic class Consensus extends javax.swing.JFrame {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 7857819028765401188L;\n\n\tprivate static final int AIC_SELECTION = 0;\n\tprivate static final int BIC_SELECTION = 1;\n\tprivate static final int AICC_SELECTION = 2;\n\tprivate static final int LNL_SELECTION = 3;\n\tprivate static final int DT_SELECTION = 4;\n\tprivate static final int DISABLED_SELECTION = 5;\n\tprivate static final String[] SELECTION = { \"AIC\", \"BIC\", \"AICc\", \"LK\",\n\t\t\t\"DT\", \"Disabled\" };\n\tprivate ResourceMap resourceMap;", "context": "src/main/java/es/uvigo/darwin/prottest/util/printer/ProtTestPrinter.java\npublic class ProtTestPrinter {\n\n    private static final String H_RULE =\n            \"********************************************************\";\n    /** The output print writer. */\n    private PrintWriter out;\n    /** The error print writer. */\n    private PrintWriter err;\n\n    /**\n     * Instantiates a new ProtTestPrinter.\n     * \n     * @param out the output writer\n     * @param err the error writer\n     */\n    public ProtTestPrinter(PrintWriter out, PrintWriter err) {\n        this.out = out;\n        this.err = err;\n    }\n\n    /**\n     * Prints out the header section of the application.\n     */\n    public static void printHeader() {\n        println(\"\");\n        println(ProtTestFormattedOutput.space(94, '-'));\n        println(\"ProtTest \" + ProtTest.versionNumber\n                + ProtTestFormattedOutput.space(27 - ProtTest.versionNumber.length(), ' ') +\n                                                    \"Fast selection of the best-fit models of protein evolution\");\n        println(\"(c) 2009-2016   Diego Darriba (1,2), Guillermo Taboada (2), Ramón Doallo (2), David Posada (1)\");\n        println(\"(1)                               Facultad de Biologia, Universidad de Vigo, 36200 Vigo, Spain\");\n        println(\"(2)                    Facultade de Informática, Universidade da Coruña, 15071 A Coruña, Spain\");\n        println(ProtTestFormattedOutput.space(94, '-'));\n        println(\"Manual:\" + \n        \t\tProtTestFormattedOutput.space(87 - ProtTest.URL_MANUAL.length(), ' ') +\n        \t\tProtTest.URL_MANUAL);\n        println(\"Homepage:\" + \n        \t\tProtTestFormattedOutput.space(85 - ProtTest.URL_HOMEPAGE.length(), ' ') +\n        \t\tProtTest.URL_HOMEPAGE);\n        println(\"Discussion group:\" + \n        \t\tProtTestFormattedOutput.space(77 - ProtTest.URL_DISCUSSION_GROUP.length(), ' ') +\n        \t\tProtTest.URL_DISCUSSION_GROUP);\n        println(\"Contact:                                                  ddarriba@h-its.org, dposada@uvigo.es\");\n        println(ProtTestFormattedOutput.space(94, '-'));\n        println(\"\");\n        println(\"Version:  \" + ProtTest.versionNumber + \" : \" + ProtTest.versionDate);\n        println(\"Date:     \" + (new Date()).toString());\n        println(\"OS:       \" + System.getProperty(\"os.name\") +\n                \" (\" + System.getProperty(\"os.version\") + \")\");\n        println(\"Arch:     \" + System.getProperty(\"os.arch\"));\n        println(\"Java:     \" + System.getProperty(\"java.version\") +\n                \" (\" + System.getProperty(\"java.vendor\") + \")\");\n//        println(\"VM Mem.(MB)= \" +\n//        \t\t  Runtime.getRuntime().totalMemory()/(1024*1024) + \" (total) \" +\n//        \t\t  Runtime.getRuntime().maxMemory()/(1024*1024) + \" (max) \" +\n//        \t\t  Runtime.getRuntime().freeMemory()/(1024*1024) + \" (free)\");\n        println(\"PhyML:    \" + PhyMLv3AminoAcidRunEstimator.phymlBinaryStr);\n        println(\"\");\n        println(\"Citation: Darriba D, Taboada GL, Doallo R, Posada D. ProtTest 3: fast selection of best-fit \");\n        println(\"          models of protein evolution. Bioinformatics, 27:1164-1165, 2011\");\n        println(\"\");\n    }\n\n    /**\n     * Prints out the header of the pre-analysis section.\n     */\n    public static void printPreAnalysisHeader() {\n        println(\"\");\n        println(H_RULE);\n        println(center(\"ALIGNMENT ANALYSIS\"));\n        println(H_RULE);\n        println(\"\");\n    }\n\n    /**\n     * Prints out the header of the selection section\n     */\n    public static void printSelectionHeader(String criterionName) {\n        println(\"\");\n        println(\"\");\n        println(H_RULE);\n        println(center(criterionName));\n        println(H_RULE);\n    }\n\n    /**\n     * Prints out the header of the tree display\n     */\n    public static void printTreeHeader(String modelName) {\n        println(\"\");\n        println(H_RULE);\n        println(center(modelName));\n        println(H_RULE);\n        println(\"\");\n    }\n\n    public static void printExecutionHeader(ApplicationOptions options) {\n        println(\"\");\n        println(H_RULE);\n        println(center(\"MODEL OPTIMIZATION\"));\n        println(H_RULE);\n        options.reportModelOptimization();\n        println(\"\");\n    }\n\n    /**\n     * Prints file data\n     */\n    public static void printFileData(File f) {\n        println(\"\");\n        println(\"File: \" + f.getAbsolutePath());\n        println(\"Size: \" + f.length());\n        println(\"\");\n    }\n    public static void println(String text) {\n        ProtTestLogger.infoln(text, ProtTestPrinter.class);\n    }\n\n    /**\n     * Prints out the footer section of the application.\n     */\n    public static void printFooter() {\n        println(\"\");\n        println(\"\");\n        println(\"ProtTest-HPC - \" + ProtTest.versionNumber);\n    }\n    private static String center(String text) {\n        return ProtTestFormattedOutput.space((H_RULE.length() - text.length())/2, ' ') + text;\n    }\n\n    /**\n     * Gets the output writer.\n     * \n     * @return the output writer\n     */\n    public PrintWriter getOutputWriter() {\n        return out;\n    }\n\n    /**\n     * Sets the output writer.\n     * \n     * @param out the new output writer\n     */\n    public void setOutputWriter(PrintWriter out) {\n        this.out = out;\n    }\n\n    /**\n     * Gets the error writer.\n     * \n     * @return the error writer\n     */\n    public PrintWriter getErrorWriter() {\n        return err;\n    }\n\n    /**\n     * Sets the error writer.\n     * \n     * @param err the new error writer\n     */\n    public void setErrorWriter(PrintWriter err) {\n        this.err = err;\n    }\n\n    /**\n     * Flushes output writer.\n     */\n    public void flush() {\n        out.flush();\n    }\n\n    /**\n     * Flushes error writer.\n     */\n    public void flushError() {\n        err.flush();\n    }\n\n    /**\n     * Closes error writer.\n     */\n    public void closeError() {\n        err.close();\n    }\n}\nsrc/main/java/es/uvigo/darwin/xprottest/util/TextAreaWriter.java\npublic final class TextAreaWriter extends Writer {\n\n\tprivate final JTextArea textArea;\n\n\tpublic TextAreaWriter(final JTextArea textArea) {\n\t\tthis.textArea = textArea;\n\t}\n\n    @Override\n    public void flush(){ }\n    \n    @Override\n    public void close(){ }\n\n    @Override\n    public void write(char[] cbuf, int off, int len) throws IOException {\n        textArea.append(new String(cbuf, off, len));\n        textArea.setCaretPosition(off);\n    }\n}\nsrc/main/java/es/uvigo/darwin/prottest/selection/BIC.java\npublic class BIC extends InformationCriterion\n{\n\t\n//\t/**\n//\t * Instantiates a new Bayesian Information Criterion.\n//\t * \n//\t * @param models the models\n//\t * @param confidenceInterval the confidence interval\n//\t */\n//\tpublic BIC (ModelCollection models, double confidenceInterval) \n//\t\t{\n//\t\tsuper(models, confidenceInterval);\n//\t\t\n//\t\tCollections.sort(selectionModels);\n//\t\t}\n\t\n\t/**\n\t * Instantiates a new Bayesian Information Criterion.\n\t * \n\t * @param models the models\n\t * @param confidenceInterval the confidence interval\n\t * @param sampleSize the sample size if different of the default\n\t */\n\tpublic BIC (ModelCollection models, double confidenceInterval, double sampleSize) \n\t\t{\n\t\tsuper(models, confidenceInterval, sampleSize);\n\t\t\n\t\tCollections.sort(selectionModels);\n\t\t}\n\t\n\t/* (non-Javadoc)\n\t * @see es.uvigo.darwin.prottest.selection.InformationCriterion#getSelectionModels(es.uvigo.darwin.prottest.util.collection.ModelIterator)\n\t */\n\tprotected List<SelectionModel> getSelectionModels(List<Model> models) {\n\t\tList<SelectionModel> list = new ArrayList<SelectionModel>();\n\t\tfor (Model model : models) {\n\t\t\tSelectionModel toAdd = new BICSelectionModel(\n\t\t\t\t\tmodel, \n\t\t\t\t\tsampleSize); \n\t\t\tlist.add( toAdd );\n\t\t\thashModels.put(model, toAdd);\n\t\t}\n\t\treturn list;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see es.uvigo.darwin.prottest.selection.InformationCriterion#getCriterionName()\n\t */\n\tpublic String getCriterionName() {\n\t\treturn \"BIC\";\n\t}\n}\nsrc/main/java/es/uvigo/darwin/prottest/model/Model.java\npublic abstract class Model implements Serializable {\n\n    /** The serialVersionUID. */\n    private static final long serialVersionUID = 20090804L;\n\n    // distributions\n    /** Useful constant for uniform distribution. */\n    public static final int DISTRIBUTION_UNIFORM = 0;\n    /** Useful constant for distribution with a proportion of invariable sites. */\n    public static final int DISTRIBUTION_INVARIABLE = 1;\n    /** Useful constant for gamma distribution. */\n    public static final int DISTRIBUTION_GAMMA = 2;\n    /** Useful constant for gamma distribution with a proportion of invariable sites. */\n    public static final int DISTRIBUTION_GAMMA_INV = 3;\n    \n    // frequencies distribution\n    /** The value of Uniform Frequencies Distribution. */\n    static final int FREQ_DISTRIBUTION_UNIFORM = 1;\n    /** The value of Empirical Frequencies Distribution. */\n    static final int FREQ_DISTRIBUTION_EMPIRICAL = 2;\n    /** The value of Maximum Likelihood Frequencies Distribution. */\n    static final int FREQ_DISTRIBUTION_MAXIMUM_LIKELIHOOD = 3;\n    /** The value of any other frequencies distribution. */\n    static final int FREQ_DISTRIBUTION_OTHER = 4;\n    \n    /** Useful constant for consider observed frequencies. */\n    public static final String PROP_PLUS_F = \"plusF\";\n    /** The matrix name. */\n    private String matrix;\n    /** The distribution. */\n    private int distribution;\n    /** Consider observed frequencies. */\n    private boolean plusF;\n    /** The frequencies distribution. */\n    protected int frequenciesDistribution;\n    /** The alignment hashcode. */\n    private int alignment;\n    /** The number of sequences. */\n    private int numberOfSequences;\n    /** The tree. */\n    private Tree tree;\n    /** The number of model parameters. */\n//\tprivate  int numModelParameters;\n    /** The number of transition categories. */\n    private int numOfTransCategories;\n    /** The likelihood calculation state. */\n    private ModelLkState lkState;\n    /** The external executor command line. */\n    private String[] commandLine;\n\n    /**\n     * Gets the likelihood estimated value.\n     * \n     * @return the likelihood estimated value\n     */\n    public double getLk() {\n        return lkState.getLk();\n    }\n\n    /**\n     * Checks if is computed.\n     * \n     * @return true, if is computed\n     */\n    public boolean isComputed() {\n        return (lkState instanceof ModelFilledLkState);\n    }\n\n    /**\n     * Sets the likelihood estimated value.\n     * \n     * @param lk the new likelihood estimated value\n     */\n    public void setLk(double lk) {\n        lkState = lkState.setLk(lk);\n    }\n\n    /**\n     * Gets the alpha estimated value.\n     * \n     * @return the alpha estimated value\n     */\n    public double getAlpha() {\n        return lkState.getAlpha();\n    }\n\n    /**\n     * Sets the alpha estimated value.\n     * \n     * @param alpha the new alpha estimated value\n     */\n    public void setAlpha(double alpha) {\n        lkState = lkState.setAlpha(alpha);\n    }\n\n    /**\n     * Gets the proportion of invariant sites.\n     * \n     * @return the proportion of invariant sites\n     */\n    public double getInv() {\n        return lkState.getInv();\n    }\n\n    /**\n     * Sets the proportion of invariant sites.\n     * \n     * @param inv the new proportion of invariant sites\n     */\n    public void setInv(double inv) {\n        lkState = lkState.setInv(inv);\n    }\n\n    /**\n     * Gets the alignment hashcode.\n     * \n     * @return the alignment hashcode\n     */\n    public int getAlignment() {\n        return alignment;\n    }\n\n    /**\n     * Sets the alignment only if there wasn't set or it is a different instance of the same object.\n     * \n     * @param alignment the new alignment\n     */\n    public void setAlignment(Alignment alignment) {\n        if (this.alignment != 0 && this.alignment != alignment.toString().hashCode()) {\n            throw new ProtTestInternalException(\"cannot set a different alignment\");\n        }\n        this.alignment = alignment.toString().hashCode();\n        this.numberOfSequences = alignment.getSequenceCount();\n    }\n\n    /**\n     * Checks if an alignment matches the internal model alignment\n     * \n     * @return alignment equality\n     */\n    public boolean checkAlignment(Alignment alignment) {\n        if (alignment == null) {\n            return false;\n        }\n        return (this.alignment == alignment.toString().hashCode() &&\n                this.numberOfSequences == alignment.getSequenceCount());\n    }\n\n    /**\n     * Gets the tree.\n     * \n     * @return the tree\n     */\n    public Tree getTree() {\n        return tree;\n    }\n\n    /**\n     * Sets the tree.\n     * \n     * @param tree the new tree\n     */\n    public void setTree(Tree tree) {\n        this.tree = tree;\n    }\n\n    /**\n     * Gets the command line.\n     * \n     * @return the command line\n     */\n    public String[] getCommandLine() {\n        return commandLine;\n    }\n\n    /**\n     * Sets the command line.\n     * \n     * @param commandLine the new command line\n     */\n    public void setCommandLine(String[] commandLine) {\n        this.commandLine = commandLine;\n    }\n\n    /**\n     * Gets the number of transition categories.\n     * \n     * @return the number of transition categories\n     */\n    public int getNumberOfTransitionCategories() {\n        return numOfTransCategories;\n    }\n\n    /**\n     * Instantiates a new substitution model.\n     * \n     * @param matrix the matrix name\n     * @param distribution the distribution value\n     * @param plusF consider observed frequencies\n     * @param alignment the alignment\n     * @param tree the tree\n     * @param ncat the ncat\n     */\n    public Model(String matrix, int distribution, boolean plusF, Alignment alignment, Tree tree, int ncat) {\n\n        if (distribution < 0 || distribution > 3) {\n            throw new ProtTestInternalException(\"Distribution not supported \" + distribution);\n        }\n\n        if (alignment == null) {\n            throw new ProtTestInternalException(\"Null alignment\");\n        }\n\n        this.matrix = matrix;\n        this.distribution = distribution;\n        this.plusF = plusF;\n        this.alignment = alignment.toString().hashCode();\n        this.numberOfSequences = alignment.getSequenceCount();\n        this.tree = tree;\n        this.lkState = new ModelEmptyLkState();\n\n//\t\tnumBranches = 2*alignment.getSequenceCount() - 3;\n        switch (distribution) {\n            case DISTRIBUTION_UNIFORM:\n                numOfTransCategories = 1;\n                break;\n            case DISTRIBUTION_INVARIABLE:\n                numOfTransCategories = 1;\n                break;\n            case DISTRIBUTION_GAMMA:\n                numOfTransCategories = ncat;\n                break;\n            case DISTRIBUTION_GAMMA_INV:\n                numOfTransCategories = ncat;\n                break;\n            }\n\n    }\n\n    /**\n     * Gets the number of parameters according with the distribution.\n     * \n     * @return the distribution parameters according with the distribution\n     */\n    public int getDistributionParameters() {\n        int value = -1;\n        switch (distribution) {\n            case DISTRIBUTION_UNIFORM:\n                value = 0;\n                break;\n            case DISTRIBUTION_INVARIABLE:\n                value = 1;\n                break;\n            case DISTRIBUTION_GAMMA:\n                value = 1;\n                break;\n            case DISTRIBUTION_GAMMA_INV:\n                value = 2;\n                break;\n            }\n        return value;\n    }\n\n    /**\n     * Gets the number of model parameters.\n     * \n     * @return the number of model parameters\n     */\n    public abstract int getNumberOfModelParameters();\n\n    /**\n     * Gets the matrix name.\n     * \n     * @return the matrix name\n     */\n    public String getMatrix() {\n        return matrix;\n    }\n\n    /**\n     * Gets the distribution.\n     * \n     * @return the distribution\n     */\n    public int getDistribution() {\n        return distribution;\n    }\n\n    /**\n     * Checks if observed frequencies are considered.\n     * \n     * @return true, if the model considers observed frequencies\n     */\n    public boolean isPlusF() {\n        return plusF;\n    }\n\n    /* (non-Javadoc)\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + distribution;\n        result = prime * result + ((matrix == null) ? 0 : matrix.hashCode());\n        result = prime * result + (isPlusF() ? 1231 : 1237);\n        return result;\n    }\n\n    /* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        Model other = (Model) obj;\n        if (distribution != other.distribution) {\n            return false;\n        }\n        if (matrix == null) {\n            if (other.matrix != null) {\n                return false;\n            }\n        } else if (!matrix.equals(other.matrix)) {\n            return false;\n        }\n        if (isPlusF() != other.isPlusF()) {\n            return false;\n        }\n        return true;\n    }\n\n    /* (non-Javadoc)\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return \"Model [distribution=\" + distribution + \", matrix=\" + matrix + \", plusF=\" + isPlusF();\n//\t\t+ \", weight=\" + weight + \"]\";\n    }\n\n    /**\n     * Gets the complete model name.\n     * \n     * @return the model name\n     */\n    public abstract String getModelName();\n\n    /**\n     * Gets the number of branches.\n     * \n     * @return the number of branches\n     */\n    public int getNumBranches() {\n        return 2 * numberOfSequences - 3;\n    }\n\n    /**\n     * Checks if distribution is gamma.\n     * \n     * @return true, if is gamma\n     */\n    public boolean isGamma() {\n        return (distribution == DISTRIBUTION_GAMMA ||\n                distribution == DISTRIBUTION_GAMMA_INV);\n    }\n\n    /**\n     * Checks if a proportion of invariant sites are considered.\n     * \n     * @return true, if considers a proportion of invariant sites\n     */\n    public boolean isInv() {\n        return (distribution == DISTRIBUTION_INVARIABLE ||\n                distribution == DISTRIBUTION_GAMMA_INV);\n    }\n\n    /**\n     * Prints the model status report.\n     */\n    public void printReport() {\n\n        println(\"Model................................ : \" + getModelName());\n        print(\"  Number of parameters............... : \" + getNumberOfModelParameters());\n        println(\" (\" + (getNumberOfModelParameters() - getNumBranches()) + \" + \" +\n                getNumBranches() + \" branch length estimates)\");\n\n        if (isComputed()) {\n            if (isGamma()) {\n                println(\"    gamma shape (\" + getNumberOfTransitionCategories() + \" rate categories).. = \" + getAlpha());\n            }\n            if (isInv()) {\n                println(\"    proportion of invariable sites... = \" + getInv());\n            }\n            if (isPlusF()) {\n                println(\"    aminoacid frequencies............ = observed (see above)\");\n            }\n            print(\" -lnL................................ = \" + ProtTestFormattedOutput.getDecimalString((-1 * getLk()), 2));\n            println(\"\");\n\n            verboseln(\"The tree:\");\n            verboseln(\"---------\");\n            StringWriter ascciiSw = new StringWriter();\n            TreeUtils.report(getTree(), new PrintWriter(ascciiSw));\n            ascciiSw.flush();\n            verboseln(ascciiSw.toString());\n            StringWriter newickSw = new StringWriter();\n            verboseln(\"---------\");\n            TreeUtils.printNH(getTree(), new PrintWriter(newickSw));\n            newickSw.flush();\n            verboseln(newickSw.toString());\n            verboseln(\"\");\n        }\n        flush(Model.class);\n    }\n\n    private void print(String message) {\n        info(message, Model.class);\n    }\n\n    private void println(String message) {\n        infoln(message, Model.class);\n    }\n\n    private void verbose(String message) {\n        finer(message, Model.class);\n    }\n\n    private void verboseln(String message) {\n        finerln(message, Model.class);\n    }\n}\nsrc/main/java/es/uvigo/darwin/prottest/util/logging/ProtTestLogger.java\npublic static void infoln(String text, Class loggingClass) {\n\tlog(Level.INFO, text + \"\\n\", loggingClass);\n\tflush(loggingClass);\n}\nsrc/main/java/es/uvigo/darwin/prottest/selection/AICc.java\npublic class AICc extends InformationCriterion\n{\n\t\n\t/**\n\t * Instantiates a new Corrected Akaike Information Criterion.\n\t * \n\t * @param models the models\n\t * @param confidenceInterval the confidence interval\n\t * @param sampleSize the sample size if different of the default\n\t */\n\tpublic AICc (ModelCollection models, double confidenceInterval, double sampleSize) \n\t\t{\n\t\tsuper(models, confidenceInterval, sampleSize);\n\t\t\n\t\tCollections.sort(selectionModels);\n\t\t}\n\t\n\t/* (non-Javadoc)\n\t * @see es.uvigo.darwin.prottest.selection.InformationCriterion#getSelectionModels(es.uvigo.darwin.prottest.util.collection.ModelIterator)\n\t */\n\tprotected List<SelectionModel> getSelectionModels(List<Model> models) {\n\t\tList<SelectionModel> list = new ArrayList<SelectionModel>();\n\t\tfor (Model model : models) {\n\t\t\tSelectionModel toAdd = new AICcSelectionModel(\n\t\t\t\t\tmodel, \n\t\t\t\t\tsampleSize); \n\t\t\tlist.add( toAdd );\n\t\t\thashModels.put(model, toAdd);\n\t\t}\n\t\treturn list;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see es.uvigo.darwin.prottest.selection.InformationCriterion#getCriterionName()\n\t */\n\tpublic String getCriterionName() {\n\t\treturn \"AICc\";\n\t}\n}\nsrc/main/java/es/uvigo/darwin/prottest/util/exception/ProtTestInternalException.java\npublic class ProtTestInternalException extends RuntimeException {\n\n\t/** The Constant serialVersionUID. */\n\tprivate static final long serialVersionUID = 20090728L;\n\n\t/**\n\t * Instantiates a new prot test internal exception.\n\t */\n\tpublic ProtTestInternalException() {}\n\t\n\t/**\n\t * Instantiates a new prot test internal exception.\n\t * \n\t * @param description the description\n\t */\n\tpublic ProtTestInternalException(String description) {\n\t\tsuper(description);\n\t}\n\n}\nsrc/main/java/es/uvigo/darwin/prottest/selection/DT.java\npublic class DT extends InformationCriterion\n{\n\t\n\tprivate BIC bic;\n\tprivate TreeDistancesCache distancesCache;\n\t\n\t/**\n\t * Instantiates a new Decision Theory Information Criterion.\n\t * \n\t * @param models the models\n\t * @param confidenceInterval the confidence interval\n\t * @param sampleSize the sample size if different of the default\n\t */\n\tpublic DT (ModelCollection models, double confidenceInterval, double sampleSize) \n\t\t{\n\t\tsuper(models, confidenceInterval, sampleSize);\n\t\tCollections.sort(selectionModels);\n\t\t}\n\t\n\t/* (non-Javadoc)\n\t * @see es.uvigo.darwin.prottest.selection.InformationCriterion#getSelectionModels(es.uvigo.darwin.prottest.util.collection.ModelIterator)\n\t */\n\tprotected List<SelectionModel> getSelectionModels(List<Model> models) {\n\t\tModelCollection modelCollection = new SingleModelCollection(\n                        models.toArray(new Model[0]),\n                        alignment);\n\t\tbic = new BIC(modelCollection, confidenceInterval, sampleSize);\n\t\tdistancesCache = TreeEuclideanDistancesCache.getInstance();\n\t\t\n\t\tList<SelectionModel> list = new ArrayList<SelectionModel>();\n\t\tfor (Model model : models) {\n\t\t\tSelectionModel toAdd = new DTSelectionModel(\n\t\t\t\t\tmodel, \n\t\t\t\t\tsampleSize,\n\t\t\t\t\tbic,\n\t\t\t\t\tdistancesCache); \n\t\t\tlist.add( toAdd );\n\t\t\thashModels.put(model, toAdd);\n\t\t}\n\t\treturn list;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see es.uvigo.darwin.prottest.selection.InformationCriterion#getCriterionName()\n\t */\n\tpublic String getCriterionName() {\n\t\treturn \"DT\";\n\t}\n}\nsrc/main/java/es/uvigo/darwin/prottest/facade/TreeFacade.java\npublic interface TreeFacade {\n\n    //\t**********************************************************\n    //\t\t  TREE SERVICES\n    //**********************************************************\n\n    /**\n     * Gets ASCII representation of a Tree instance.\n     * \n     * @param tree the tree\n     */\n    public String toASCII(Tree tree);\n\n    /**\n     * Gets branch information of a Tree instance.\n     * \n     * @param tree the tree\n     */\n    public String branchInfo(Tree tree);\n\n    /**\n     * Gets height information of a Tree instance.\n     * \n     * @param tree the tree\n     */\n    public String heightInfo(Tree tree);\n\n    /**\n     * Gets newick representation of a Tree instance.\n     * \n     * @param tree the tree\n     * @param printLengths if branch lengths should be included\n     * @param printInternalLabels if internal labels should be included\n     * @param printCladeSupport if clade support should be included\n     */\n    public String toNewick(Tree tree, boolean printLengths,\n            boolean printInternalLabels, boolean printCladeSupport);\n\n    /**\n     * Create a consensus tree from a list of trees.\n     * \n     * @param treeCollection the trees and its weights to build consensus\n     * @param threshold the minimum clade support\n     */\n    public Tree createConsensusTree(List<WeightedTree> treeCollection, double threshold);\n\n    /**\n     * Create a weighted consensus tree from an information criterion.\n     * \n     * @param ic the weighted models with the trees to build consensus\n     * @param threshold the minimum clade support\n     */\n    public Tree createConsensusTree(InformationCriterion ic, double threshold);\n    \n    /**\n     * Create a weighted consensus instance from an information criterion.\n     * \n     * @param ic the weighted models with the trees to build consensus\n     * @param threshold the minimum clade support\n     */\n    public Consensus createConsensus(InformationCriterion ic, double threshold);\n    \n}\nsrc/main/java/es/uvigo/darwin/prottest/util/logging/ProtTestLogger.java\n@SuppressWarnings(\"rawtypes\")\npublic class ProtTestLogger {\n\n\tpublic static final String DEFAULT_LOGGER_NAME = \"default\";\n\tpublic static final Level DEFAULT_LEVEL = Level.INFO;\n\n\tprivate static HashMap<String, ProtTestLogger> loggers;\n\n\tstatic {\n\n\t\tloggers = new HashMap<String, ProtTestLogger>();\n\t\tProtTestLogger defaultLogger = new ProtTestLogger(DEFAULT_LOGGER_NAME);\n\t\tloggers.put(DEFAULT_LOGGER_NAME, defaultLogger);\n\n\t}\n\n\tprivate String loggerName;\n\tprivate Level loggerLevel;\n\tprivate List<Handler> handlers;\n\tprivate Handler stdHandler;\n\tprivate Handler lowLevelHandler = null;\n\n\tpublic static ProtTestLogger getLogger(String loggerName, boolean force) {\n\t\tif (!loggers.containsKey(loggerName)) {\n\t\t\tif (force)\n\t\t\t\tloggers.put(loggerName, new ProtTestLogger(loggerName));\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t\treturn loggers.get(loggerName);\n\t}\n\n\tpublic static boolean exists(Class classLogger) {\n\t\treturn getLogger(classLogger.getName(), false) != null;\n\t}\n\n\tpublic ProtTestLogger(String loggerName) {\n\t\tthis.loggerName = loggerName;\n\t\tif (loggers.containsKey(loggerName))\n\t\t\tthrow new ProtTestInternalException(\"ProtTestLogger with name \"\n\t\t\t\t\t+ loggerName + \" already exists. \"\n\t\t\t\t\t+ \" Use getLogger() instead\");\n\t\tthis.loggerLevel = Level.ALL;\n\n\t\t// Add standard output handler\n\t\tthis.handlers = new ArrayList<Handler>();\n\t\tstdHandler = new StreamHandler(System.out, new ProtTestLogFormatter());\n\t\tstdHandler.setLevel(Level.OFF);\n\t\thandlers.add(stdHandler);\n\t}\n\n\tpublic static ProtTestLogger getDefaultLogger() {\n\t\treturn getLogger(DEFAULT_LOGGER_NAME, true);\n\t}\n\n\t/**\n\t * Check if a message of the given level would actually be logged by this\n\t * logger. This check is based on the Loggers effective level, which may be\n\t * inherited from its parent.\n\t * \n\t * @param level\n\t *            a message logging level\n\t * @return true if the given message level is currently being logged.\n\t */\n\tpublic boolean isLoggable(Level level) {\n\t\tif (level.intValue() < loggerLevel.intValue()\n\t\t\t\t|| loggerLevel.intValue() == Level.OFF.intValue()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic void addHandler(Handler handler) {\n\t\tif (handler == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tthis.handlers.add(handler);\n\t}\n\n\tpublic void addHandler(Handler[] newHandlers) {\n\t\tfor (Handler handler : newHandlers) {\n\t\t\tif (handler == null) {\n\t\t\t\tthrow new NullPointerException();\n\t\t\t}\n\t\t\tif (!handlers.contains(handler))\n\t\t\t\tthis.handlers.add(handler);\n\t\t}\n\t}\n\n\tpublic Handler addHandler(OutputStream out) {\n\t\treturn addHandler(out, DEFAULT_LEVEL);\n\t}\n\n\tpublic Handler addHandler(OutputStream out, Level level) {\n\t\tif (out == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tHandler handler = new StreamHandler(out, new ProtTestLogFormatter());\n\t\thandler.setLevel(level);\n\t\tthis.handlers.add(handler);\n\t\treturn handler;\n\t}\n\n\tpublic Handler addHandler(Writer out) {\n\t\treturn addHandler(out, DEFAULT_LEVEL);\n\t}\n\n\tpublic Handler addHandler(final Writer out, Level level) {\n\t\tif (out == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tHandler handler = new StreamHandler(\n\t\t  new OutputStream()\n\t\t  {\n\t\t\tprotected Writer _writer = out;\n\t\t    protected String _encoding;\n\t\t    private byte[] _buf=new byte[1];\n\t\t    \n\t\t\t@Override\n\t\t    public void close()\n\t\t        throws IOException\n\t\t    {\n\t\t        _writer.close();\n\t\t        _writer=null;\n\t\t        _encoding=null;\n\t\t    }\n\t\t    \n\t\t    @Override\n\t\t    public void flush()\n\t\t        throws IOException\n\t\t    {\n\t\t        _writer.flush();\n\t\t    }\n\t\t    \n\t\t    @Override\n\t\t    public void write(byte[] b) \n\t\t        throws IOException\n\t\t    {\n\t\t        if (_encoding==null)\n\t\t            _writer.write(new String(b));\n\t\t        else\n\t\t            _writer.write(new String(b,_encoding));\n\t\t    }\n\t\t    \n\t\t    @Override\n\t\t    public void write(byte[] b, int off, int len)\n\t\t        throws IOException\n\t\t    {\n\t\t        if (_encoding==null)\n\t\t            _writer.write(new String(b,off,len));\n\t\t        else\n\t\t            _writer.write(new String(b,off,len,_encoding));\n\t\t    }\n\t\t    \n\t\t    public synchronized void write(int b)\n\t\t        throws IOException\n\t\t    {\n\t\t        _buf[0]=(byte)b;\n\t\t        write(_buf);\n\t\t    }\n\t\t},\n\t\t\t\tnew ProtTestLogFormatter());\n\t\thandler.setLevel(level);\n\t\tthis.handlers.add(handler);\n\t\treturn handler;\n\t}\n\n\tpublic Handler addLowLevelHandler(final Writer out) {\n\t\tif (out == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tHandler handler = new StreamHandler(new OutputStream()\n\t\t  {\n\t\t\tprotected Writer _writer = out;\n\t\t    protected String _encoding;\n\t\t    private byte[] _buf=new byte[1];\n\t\t    \n\t\t\t@Override\n\t\t    public void close()\n\t\t        throws IOException\n\t\t    {\n\t\t        _writer.close();\n\t\t        _writer=null;\n\t\t        _encoding=null;\n\t\t    }\n\t\t    \n\t\t    @Override\n\t\t    public void flush()\n\t\t        throws IOException\n\t\t    {\n\t\t        _writer.flush();\n\t\t    }\n\t\t    \n\t\t    @Override\n\t\t    public void write(byte[] b) \n\t\t        throws IOException\n\t\t    {\n\t\t        if (_encoding==null)\n\t\t            _writer.write(new String(b));\n\t\t        else\n\t\t            _writer.write(new String(b,_encoding));\n\t\t    }\n\t\t    \n\t\t    @Override\n\t\t    public void write(byte[] b, int off, int len)\n\t\t        throws IOException\n\t\t    {\n\t\t        if (_encoding==null)\n\t\t            _writer.write(new String(b,off,len));\n\t\t        else\n\t\t            _writer.write(new String(b,off,len,_encoding));\n\t\t    }\n\t\t    \n\t\t    public synchronized void write(int b)\n\t\t        throws IOException\n\t\t    {\n\t\t        _buf[0]=(byte)b;\n\t\t        write(_buf);\n\t\t    }\n\t\t},\n\t\t\t\tnew ProtTestLogFormatter());\n\t\thandler.setLevel(Level.ALL);\n\t\tlowLevelHandler = handler;\n\t\treturn handler;\n\t}\n\n\tpublic Handler getLowLevelHandler() {\n\t\treturn lowLevelHandler;\n\t}\n\n\tpublic boolean removeHandler(Handler handler) {\n\t\treturn this.handlers.remove(handler);\n\t}\n\n\tpublic Handler[] getHandlers() {\n\t\treturn handlers.toArray(new Handler[0]);\n\t}\n\n\tpublic void setStdHandlerLevel(Level newLevel) {\n\t\tif (newLevel == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tstdHandler.setLevel(newLevel);\n\t}\n\n\tpublic Level getStdHandlerLevel() {\n\t\treturn stdHandler.getLevel();\n\t}\n\n\tpublic void setLevel(Level newLevel) {\n\t\tif (newLevel == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tloggerLevel = newLevel;\n\t}\n\n\tpublic Level getLevel() {\n\t\treturn loggerLevel;\n\t}\n\n\tpublic void info(String text) {\n\t\tlog(Level.INFO, text);\n\t}\n\n\tpublic void warning(String text) {\n\t\tlog(Level.WARNING, text);\n\t}\n\n\tpublic void config(String text) {\n\t\tlog(Level.CONFIG, text);\n\t}\n\n\tpublic void severe(String text) {\n\t\tlog(Level.SEVERE, text);\n\t}\n\n\tpublic void fine(String text) {\n\t\tlog(Level.FINE, text);\n\t}\n\n\tpublic void finer(String text) {\n\t\tlog(Level.FINER, text);\n\t}\n\n\tpublic void finest(String text) {\n\t\tlog(Level.FINEST, text);\n\t}\n\n\tpublic void infoln(String text) {\n\t\tlog(Level.INFO, text + \"\\n\");\n\t\tflush();\n\t}\n\n\tpublic void warningln(String text) {\n\t\tlog(Level.WARNING, text + \"\\n\");\n\t\tflush();\n\t}\n\n\tpublic void configln(String text) {\n\t\tlog(Level.CONFIG, text + \"\\n\");\n\t\tflush();\n\t}\n\n\tpublic void severeln(String text) {\n\t\tlog(Level.SEVERE, text + \"\\n\");\n\t\tflush();\n\t}\n\n\tpublic void fineln(String text) {\n\t\tlog(Level.FINE, text + \"\\n\");\n\t\tflush();\n\t}\n\n\tpublic void finerln(String text) {\n\t\tlog(Level.FINER, text + \"\\n\");\n\t\tflush();\n\t}\n\n\tpublic void finestln(String text) {\n\t\tlog(Level.FINEST, text + \"\\n\");\n\t\tflush();\n\t}\n\n\tpublic static void info(String text, Class loggingClass) {\n\t\tlog(Level.INFO, text, loggingClass);\n\t}\n\n\tpublic static void warning(String text, Class loggingClass) {\n\t\tlog(Level.WARNING, text, loggingClass);\n\t}\n\n\tpublic static void config(String text, Class loggingClass) {\n\t\tlog(Level.CONFIG, text, loggingClass);\n\t}\n\n\tpublic static void severe(String text, Class loggingClass) {\n\t\tlog(Level.SEVERE, text, loggingClass);\n\t}\n\n\tpublic static void fine(String text, Class loggingClass) {\n\t\tlog(Level.FINE, text, loggingClass);\n\t}\n\n\tpublic static void finer(String text, Class loggingClass) {\n\t\tlog(Level.FINER, text, loggingClass);\n\t}\n\n\tpublic static void finest(String text, Class loggingClass) {\n\t\tlog(Level.FINEST, text, loggingClass);\n\t}\n\n\tpublic static void infoln(String text, Class loggingClass) {\n\t\tlog(Level.INFO, text + \"\\n\", loggingClass);\n\t\tflush(loggingClass);\n\t}\n\n\tpublic static void warningln(String text, Class loggingClass) {\n\t\tlog(Level.WARNING, text + \"\\n\", loggingClass);\n\t\tflush(loggingClass);\n\t}\n\n\tpublic static void configln(String text, Class loggingClass) {\n\t\tlog(Level.CONFIG, text + \"\\n\", loggingClass);\n\t\tflush(loggingClass);\n\t}\n\n\tpublic static void severeln(String text, Class loggingClass) {\n\t\tlog(Level.SEVERE, text + \"\\n\", loggingClass);\n\t\tflush(loggingClass);\n\t}\n\n\tpublic static void fineln(String text, Class loggingClass) {\n\t\tlog(Level.FINE, text + \"\\n\", loggingClass);\n\t\tflush(loggingClass);\n\t}\n\n\tpublic static void finerln(String text, Class loggingClass) {\n\t\tlog(Level.FINER, text + \"\\n\", loggingClass);\n\t\tflush(loggingClass);\n\t}\n\n\tpublic static void finestln(String text, Class loggingClass) {\n\t\tlog(Level.FINEST, text + \"\\n\", loggingClass);\n\t\tflush(loggingClass);\n\t}\n\n\tpublic static void log(Level level, String text, Class loggingClass) {\n\t\t// default logging + class logging\n\t\tgetDefaultLogger().log(level, text);\n\t\tif (exists(loggingClass))\n\t\t\tgetLogger(loggingClass.getName(), false).log(level, text);\n\t}\n\n\tpublic void log(Level level, String text) {\n\t\tlog(new LogRecord(level, text));\n\t}\n\n\tpublic void log(LogRecord lr) {\n\n\t\tif (lr.getLevel().intValue() > loggerLevel.intValue()\n\t\t\t\t&& loggerLevel.intValue() != Level.OFF.intValue()) {\n\n\t\t\tfor (Handler handler : handlers)\n\t\t\t\thandler.publish(lr);\n\n\t\t}\n\n\t}\n\n\tpublic static void lowLevelLog(String text) {\n\t\tif (getDefaultLogger().lowLevelHandler != null) {\n\t\t\tLogRecord lr = new LogRecord(Level.INFO, text + \"\\n\");\n\t\t\tgetDefaultLogger().lowLevelHandler.publish(lr);\n\t\t\tgetDefaultLogger().lowLevelHandler.flush();\n\t\t}\n\t}\n\n\tpublic void flush() {\n\t\tfor (Handler handler : handlers)\n\t\t\thandler.flush();\n\t}\n\n\tpublic static void flush(Class loggingClass) {\n\t\tgetDefaultLogger().flush();\n\t\tif (exists(loggingClass))\n\t\t\tgetLogger(loggingClass.getName(), false).flush();\n\t}\n}\nsrc/main/java/es/uvigo/darwin/prottest/util/collection/SingleModelCollection.java\npublic class SingleModelCollection extends ModelCollection {\n\n\t/** The Constant serialVersionUID. */\n\tprivate static final long serialVersionUID = 20090804L;\n\n\t/**\n\t * Instantiates a new single model collection.\n\t */\n\tpublic SingleModelCollection(Alignment alignment) {\n\t\tsuper(alignment);\n\t}\n\t\n\t/**\n\t * Instantiates a new single model collection.\n\t * \n\t * @param models the models\n\t */\n\tpublic SingleModelCollection(Model[] models, Alignment alignment) {\n\t\tsuper(models, alignment);\n\t}\n\n        /**\n\t * Instantiates a new single model collection.\n\t *\n\t * @param models the models\n\t */\n\tpublic SingleModelCollection(ModelCollection models) {\n\t\tsuper(models);\n\t}\n\n}\nsrc/main/java/es/uvigo/darwin/prottest/util/logging/ProtTestLogger.java\npublic static ProtTestLogger getDefaultLogger() {\n\treturn getLogger(DEFAULT_LOGGER_NAME, true);\n}\nsrc/main/java/es/uvigo/darwin/xprottest/XProtTestView.java\npublic final class XProtTestView extends FrameView {\n\n\t/* Application colors */\n\tpublic static final Color NORMAL_COLOR = Color.BLACK;\n\tpublic static final Color CRITIC_COLOR = new Color(153, 0, 0);\n\tpublic static final Color DONE_COLOR = new Color(102, 102, 153);\n\t/* Settings */\n\tprivate int errorBehavior;\n\t/* General variables */\n\tprivate ResourceMap resourceMap;\n\tprivate Alignment alignment;\n\tprivate Tree tree;\n\tprivate ProtTestFacade prottestFacade;\n\tprivate boolean alignmentLoaded;\n\tprivate File alignmentFile;\n\tprivate boolean lnlCalculated;\n\tprivate Model[] models;\n\tprivate PrintWriter displayWriter;\n\tprivate Handler mainHandler;\n\tprivate PrintWriter lowLevelDisplayWriter;\n\tprivate Handler lowLevelHandler;\n\t/* WINDOWS */\n\tprivate ResultsView resultsView;\n\tprivate TreeView treeView;\n\tprivate Consensus consensusView;\n\tprivate FrequenciesView frequenciesView;\n\tprivate ErrorLogView errorLogView;\n\n\tpublic int getErrorBehavior() {\n\t\treturn errorBehavior;\n\t}\n\n\tprotected void setErrorBehavior(int errorBehavior) {\n\t\tthis.errorBehavior = errorBehavior;\n\t}\n\n\tpublic ProtTestFacade getFacade() {\n\t\treturn prottestFacade;\n\t}\n\n\tprivate void setAlignmentFile(File alignmentFile) {\n\t\tenableHandler();\n\t\tint numDecimals = 5;\n\t\talignmentLoaded = (alignmentFile != null);\n\t\tif (alignmentLoaded) {\n\t\t\tlblDataFileStatus.setText(resourceMap.getString(\"msg-data-loaded\")\n\t\t\t\t\t+ \" \" + alignmentFile.getName());\n\t\t\tlblDataFileStatus.setForeground(DONE_COLOR);\n\t\t\tthis.alignmentFile = alignmentFile;\n\t\t\tshowFrequenciesItem.setEnabled(true);\n\t\t\tdouble[] frequencies = ProtTestAlignment.getFrequencies(alignment);\n\t\t\tdisplayWriter.println(\"\");\n\t\t\tdisplayWriter.println(resourceMap.getString(\"aa-frequencies\"));\n\t\t\tdisplayWriter.println(ProtTestFormattedOutput.space(resourceMap\n\t\t\t\t\t.getString(\"aa-frequencies\").length(), '-'));\n\n\t\t\tfor (int i = 0; i < frequencies.length; i++) {\n\t\t\t\tdisplayWriter.println(ProtTestAlignment.charOfIndex(i)\n\t\t\t\t\t\t+ \" - \"\n\t\t\t\t\t\t+ ProtTestFormattedOutput.getDecimalString(\n\t\t\t\t\t\t\t\tfrequencies[i], numDecimals));\n\t\t\t}\n\t\t} else {\n\t\t\tlblDataFileStatus.setText(resourceMap.getString(\"msg-no-data\"));\n\t\t\tlblDataFileStatus.setForeground(CRITIC_COLOR);\n\t\t\tshowFrequenciesItem.setEnabled(false);\n\t\t}\n\t\tfrequenciesView = null;\n\t\tcomputeMenuItem.setEnabled(alignmentLoaded);\n\t\tresultsMenuItem.setEnabled(false);\n\t\tif (resultsView != null) {\n\t\t\tresultsView.dispose();\n\t\t\tresultsView = null;\n\t\t}\n\t\tshowTreeMenuItem.setEnabled(false);\n\t\tif (treeView != null) {\n\t\t\ttreeView.dispose();\n\t\t\ttreeView = null;\n\t\t}\n\t\taveragingMenuItem.setEnabled(false);\n\t\tif (consensusView != null) {\n\t\t\tconsensusView.dispose();\n\t\t\tconsensusView = null;\n\t\t}\n\t\tdisableHandler();\n\t}\n\n\tpublic PrintWriter getDisplayWriter() {\n\t\treturn displayWriter;\n\t}\n\n\tpublic XProtTestView(SingleFrameApplication app, ProtTestFacade facade) {\n\t\tsuper(app);\n\n\t\tresourceMap = Application\n\t\t\t\t.getInstance(es.uvigo.darwin.xprottest.XProtTestApp.class)\n\t\t\t\t.getContext().getResourceMap(XProtTestView.class);\n\n\t\tthis.errorBehavior = Application\n\t\t\t\t.getInstance(es.uvigo.darwin.xprottest.XProtTestApp.class)\n\t\t\t\t.getContext().getResourceMap(XProtTestApp.class)\n\t\t\t\t.getInteger(\"default-error-behavior\");\n\n\t\tthis.prottestFacade = facade;\n\n\t\tinitComponents();\n\n\t\tImage image = new ImageIcon(\"icon.png\").getImage();\n\t    getFrame().setIconImage(image);\n\t      \n\t\tdisplayWriter = new PrintWriter(new TextAreaAppender(mainTextArea));\n\t\tlowLevelDisplayWriter = new PrintWriter(new TextAreaAppender(\n\t\t\t\tphymlTextArea));\n\n\t\tmainHandler = ProtTestLogger.getDefaultLogger().addHandler(\n\